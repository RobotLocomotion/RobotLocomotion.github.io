<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pydrake.planning &mdash; pydrake  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="pydrake.polynomial" href="pydrake.polynomial.html" />
    <link rel="prev" title="pydrake.perception" href="pydrake.perception.html" /> 
</head>

<body class="wy-body-for-nav">
<header class="site-header">
  <div class="site-header-inner contain">
    <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
    <div class="menu-mobile-toggle">
      <span></span>
    </div>
    <nav class="site-menu">
      <ul>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/">Home</a>
        </li>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/installation.html">Installation</a>
        </li>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/gallery.html">Gallery</a>
        </li>
        <li class="site-menu-item site-menu-item-main">API Documentation
          <div class="sub">
            <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a> <a class="site-menu-item" href="/pydrake/index.html">Python</a>
          </div>
        </li>
        <li class="site-menu-item site-menu-item-main">Resources
          <div class="sub">
            <a class="site-menu-item" href="/getting_help.html">Getting Help</a> <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/%2Findex.ipynb">Tutorials</a> <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a> <a class="site-menu-item" href="/developers.html">For Developers</a> <a class="site-menu-item" href="/credits.html">Credits</a>
          </div>
        </li>
        <li class="github-link">
          <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
        </li>
      </ul>
    </nav>
  </div>
</header>

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> pydrake
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search pydrake only…" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
    <input type="text" name="q" placeholder="Search all of Drake…" />
    <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu" />
  </form>
</div>

        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="pydrake.all.html">pydrake.all</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.autodiffutils.html">pydrake.autodiffutils</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.common.html">pydrake.common</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.examples.html">pydrake.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.forwarddiff.html">pydrake.forwarddiff</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.geometry.html">pydrake.geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.gym.html">pydrake.gym</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.lcm.html">pydrake.lcm</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.manipulation.html">pydrake.manipulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.math.html">pydrake.math</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.multibody.html">pydrake.multibody</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.perception.html">pydrake.perception</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">pydrake.planning</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.polynomial.html">pydrake.polynomial</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.html">pydrake.solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.symbolic.html">pydrake.symbolic</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.systems.html">pydrake.systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.trajectories.html">pydrake.trajectories</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.tutorials.html">pydrake.tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.visualization.html">pydrake.visualization</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pydrake</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>pydrake.planning</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-pydrake.planning">
<span id="pydrake-planning"></span><h1>pydrake.planning<a class="headerlink" href="#module-pydrake.planning" title="Permalink to this headline"></a></h1>
<p>A collection of motion planning algorithms for finding configurations
and/or trajectories of dynamical systems.</p>
<dl class="py function">
<dt class="sig sig-object py" id="pydrake.planning.AddDirectCollocationConstraint">
<span class="sig-prename descclassname"><span class="pre">pydrake.planning.</span></span><span class="sig-name descname"><span class="pre">AddDirectCollocationConstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">constraint</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.DirectCollocationConstraint" title="pydrake.planning.DirectCollocationConstraint"><span class="pre">pydrake.planning.DirectCollocationConstraint</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_step</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">next_state</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">next_input</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prog</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.MathematicalProgram" title="pydrake.solvers.MathematicalProgram"><span class="pre">pydrake.solvers.MathematicalProgram</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.Binding" title="pydrake.solvers.Binding"><span class="pre">pydrake.solvers.Binding</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Constraint</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.AddDirectCollocationConstraint" title="Permalink to this definition"></a></dt>
<dd><p>Helper method to add a DirectCollocationConstraint to the <code class="docutils literal notranslate"><span class="pre">prog</span></code>,
ensuring that the order of variables in the binding matches the order
expected by the constraint.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.planning.BodyShapeDescription">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.planning.</span></span><span class="sig-name descname"><span class="pre">BodyShapeDescription</span></span><a class="headerlink" href="#pydrake.planning.BodyShapeDescription" title="Permalink to this definition"></a></dt>
<dd><p>BodyShapeDescription captures all the information necessary to
describe a SceneGraph collision shape associated with a MultibodyPlant
Body: a shape S, the MultibodyPlant body B (identified by model
instance and body names), and the rigid pose of the shape S relative
to the body B, X_BS.</p>
<p>Most clients should use the factory method MakeBodyShapeDescription()
to construct a valid BodyShapeDescription; it will extract and verify
the correct information from a multibody plant and its context.</p>
<p>When moved-from, this object models a “null” description and all of
the getter functions will throw.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.BodyShapeDescription.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.planning.BodyShapeDescription.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.planning.BodyShapeDescription, shape: pydrake.geometry.Shape, X_BS: pydrake.math.RigidTransform, model_instance_name: str, body_name: str) -&gt; None</p></li>
</ol>
<p>Constructs a description with the given attributes. Does not check or
enforce correctness; callers are responsible for providing consistent
input.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.planning.BodyShapeDescription, other: pydrake.planning.BodyShapeDescription) -&gt; None</p></li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.BodyShapeDescription.body_name">
<span class="sig-name descname"><span class="pre">body_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.BodyShapeDescription" title="pydrake.planning.BodyShapeDescription"><span class="pre">pydrake.planning.BodyShapeDescription</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#pydrake.planning.BodyShapeDescription.body_name" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the body name passed at construction.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.BodyShapeDescription.model_instance_name">
<span class="sig-name descname"><span class="pre">model_instance_name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.BodyShapeDescription" title="pydrake.planning.BodyShapeDescription"><span class="pre">pydrake.planning.BodyShapeDescription</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#pydrake.planning.BodyShapeDescription.model_instance_name" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the model instance name passed at construction.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.BodyShapeDescription.pose_in_body">
<span class="sig-name descname"><span class="pre">pose_in_body</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.BodyShapeDescription" title="pydrake.planning.BodyShapeDescription"><span class="pre">pydrake.planning.BodyShapeDescription</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></span><a class="headerlink" href="#pydrake.planning.BodyShapeDescription.pose_in_body" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">X_BS</span></code>:</dt><dd><p>The pose passed at construction.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.BodyShapeDescription.shape">
<span class="sig-name descname"><span class="pre">shape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.BodyShapeDescription" title="pydrake.planning.BodyShapeDescription"><span class="pre">pydrake.planning.BodyShapeDescription</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.Shape" title="pydrake.geometry.Shape"><span class="pre">pydrake.geometry.Shape</span></a></span></span><a class="headerlink" href="#pydrake.planning.BodyShapeDescription.shape" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the shape passed at construction.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.planning.</span></span><span class="sig-name descname"><span class="pre">CollisionChecker</span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker" title="Permalink to this definition"></a></dt>
<dd><p>Interface for collision checkers to use.</p>
<p>This interface builds on the basic multi-threading idiom of Drake: one
context per thread. It offers two models to achieve multi-threaded
parallel collision checking:</p>
<ul class="simple">
<li><p>using thread pools (e.g. OpenMP or similar) and “implicit contexts” managed</p></li>
</ul>
<p>by this object
- using arbitrary threads and “explicit contexts” created by this object</p>
<p>&lt;h5&gt;Implicit Context Parallelism&lt;/h5&gt;</p>
<p>Many methods of this class aren’t designed for entry from arbitrary
threads (e.g. from std::async threads), but rather are designed for
use with a main thread and various thread-pool-parallel operations
achieved by using directives like <code class="docutils literal notranslate"><span class="pre">omp</span> <span class="pre">parallel</span></code>. To support this
usage, the base class <code class="docutils literal notranslate"><span class="pre">AllocateContexts()</span></code> protected method
establishes a pool of contexts to support the implicit context
parallelism specified in the constructor. (Note: if the collision
checker declares that parallel checking is not supported, only one
implict context will be allocated). <code class="docutils literal notranslate"><span class="pre">AllocateContexts()</span></code> must be
called and only be called as part of the constructor of a derived
class defined as final.</p>
<p>Once the context pool is created, clients can access a
thread-associated context by using <code class="docutils literal notranslate"><span class="pre">model_context(optional&lt;int&gt;</span>
<span class="pre">context_number)</span></code> and related methods. These methods may be called in
two ways:</p>
<ul class="simple">
<li><p>without a context number, the association between thread and context uses the</p></li>
</ul>
<p>OpenMP notion of thread number
- with a context number, the method uses the context corresponding to the
provided number</p>
<p>Without a context number, these context access methods are only safe
under the following conditions:</p>
<ul class="simple">
<li><p>the caller is the “main thread”</p></li>
<li><p>the caller is an OpenMP team thread <em>during execution of a parallel region</em></p></li>
</ul>
<p>With a context number, these context access methods are only safe
under the following conditions:</p>
<ul class="simple">
<li><p>no two or more threads simultaneously use the same context number</p></li>
</ul>
<p>Methods supporting implicit context parallelism are noted below by
having a reference to this section; as a rule of thumb, any public
method that takes a <code class="docutils literal notranslate"><span class="pre">context_number</span></code> argument uses implicit context
parallelism.</p>
<p>Users of this class (derived classes and others) can write their own
parallel operations using implicit contexts, provided they limit
parallel blocks to only use <code class="docutils literal notranslate"><span class="pre">const</span></code> methods or methods marked to
support implicit contexts parallelism, and the parallel operations
are:</p>
<ul class="simple">
<li><p>without a context number, only with parallelism using OpenMP directives</p></li>
<li><p>with a context number, via a parallelization method that provides a notion of</p></li>
</ul>
<p>thread numbers similar in behavior to OpenMP’s (i.e. a thread number in
[0, number of threads), not arbitrary values like
<code class="docutils literal notranslate"><span class="pre">std::this_thread::get_id()</span></code>)</p>
<p>To determine the greatest implicit context parallelism that can be
achieved in a parallelized operation, <code class="docutils literal notranslate"><span class="pre">GetNumberOfThreads(Parallelism</span>
<span class="pre">parallelize)</span></code> returns the lesser of the provided <code class="docutils literal notranslate"><span class="pre">parallelism</span></code> and
the supported implicit context parallelism.</p>
<p>&lt;h5&gt;Explicit Context Parallelism&lt;/h5&gt;</p>
<p>It is also possible to use arbitrary thread models to perform
collision checking in parallel using explicitly created contexts from
this class. Contexts returned from MakeStandaloneModelContext() may be
used in any thread, using only <code class="docutils literal notranslate"><span class="pre">const</span></code> methods of this class, or
“explicit context” methods.</p>
<p>Explicit contexts are tracked by this class using <code class="docutils literal notranslate"><span class="pre">std::weak_ptr</span></code> to
track their lifetimes. This mechanism is used by
PerformOperationAgainstAllModelContexts to map an operation over all
collision contexts, whether explicit or implicit.</p>
<p>Methods supporting explicit context parallelism are noted below by
having a reference to this section; as a rule of thumb, any public
method that takes a <code class="docutils literal notranslate"><span class="pre">model_context</span></code> first argument uses explicit
context parallelism.</p>
<p>In practice, multi-threaded collision checking with explicit contexts
may look something like the example below.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXd</span><span class="w"> </span><span class="n">start_q</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXd</span><span class="w"> </span><span class="n">sample_q1</span><span class="w"> </span><span class="p">...</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXd</span><span class="w"> </span><span class="n">sample_q2</span><span class="w"> </span><span class="p">...</span><span class="w"></span>

<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">check_edge_to</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="n">collision_checker</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">start_q</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXd</span><span class="o">&amp;</span><span class="w"> </span><span class="n">sample_q</span><span class="p">,</span><span class="w"></span>
<span class="n">CollisionCheckerContext</span><span class="o">*</span><span class="w"> </span><span class="n">explicit_context</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">return</span><span class="w"> </span><span class="n">collision_checker</span><span class="p">.</span><span class="n">CheckContextEdgeCollisionFree</span><span class="p">(</span><span class="w"></span>
<span class="n">explicit_context</span><span class="p">,</span><span class="w"> </span><span class="n">start_q</span><span class="p">,</span><span class="w"> </span><span class="n">sample_q</span><span class="p">);</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">context_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">collision_checker</span><span class="p">.</span><span class="n">MakeStandaloneModelContext</span><span class="p">();</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">context_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">collision_checker</span><span class="p">.</span><span class="n">MakeStandaloneModelContext</span><span class="p">();</span><span class="w"></span>

<span class="k">auto</span><span class="w"> </span><span class="n">future_q1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span><span class="w"> </span><span class="n">check_edge_to</span><span class="p">,</span><span class="w"> </span><span class="n">sample_q1</span><span class="p">,</span><span class="w"></span>
<span class="n">context_1</span><span class="p">.</span><span class="n">get</span><span class="p">());</span><span class="w"></span>
<span class="k">auto</span><span class="w"> </span><span class="n">future_q2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span><span class="w"> </span><span class="n">check_edge_to</span><span class="p">,</span><span class="w"> </span><span class="n">sample_q2</span><span class="p">,</span><span class="w"></span>
<span class="n">context_2</span><span class="p">.</span><span class="n">get</span><span class="p">());</span><span class="w"></span>

<span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">edge_1_valid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">future_q1</span><span class="p">.</span><span class="n">get</span><span class="p">();</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">edge_2_valid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">future_q2</span><span class="p">.</span><span class="n">get</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
</details><p>&lt;h5&gt;Mixing Threading Models&lt;/h5&gt;</p>
<p>It is possible to support mixed threading models, i.e., using both
OpenMP thread pools and arbitrary threads. In this case, each
arbitrary thread (say, from std::async) should have its own instance
of a collision checker made using Clone(). Then each arbitrary thread
will have its own implicit context pool.</p>
<p>&lt;h5&gt;Implementing Derived Classes&lt;/h5&gt;</p>
<p>Collision checkers deriving from CollisionChecker <em>must</em> support
parallel operations from both of the above parallelism models. This is
generally accomplished by placing all mutable state within the
per-thread context. If this cannot be accomplished, the shared mutable
state must be accessed in a thread-safe manner. There are APIs that
depend on SupportsParallelChecking() (e.g.,
CheckConfigsCollisionFree(), CheckEdgeCollisionFreeParallel(),
CheckEdgesCollisionFree(), etc); a derived implementation should
return <code class="docutils literal notranslate"><span class="pre">False</span></code> from SupportsParallelChecking() if there is no
meaningful benefit to attempting to do work in parallel (e.g., they
must fully serialize on shared state).</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.planning.CollisionChecker.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.AddCollisionShape">
<span class="sig-name descname"><span class="pre">AddCollisionShape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">group_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">description</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.BodyShapeDescription" title="pydrake.planning.BodyShapeDescription"><span class="pre">pydrake.planning.BodyShapeDescription</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.AddCollisionShape" title="Permalink to this definition"></a></dt>
<dd><p>Requests the addition of a shape to a body, both given in
<code class="docutils literal notranslate"><span class="pre">description</span></code>. If added, the shape will belong to the named geometry
group.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">group_name</span></code>:</dt><dd><p>The name of the group to add the geometry to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">description</span></code>:</dt><dd><p>The data describing the shape and target body.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if the shape was added.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.AddCollisionShapes">
<span class="sig-name descname"><span class="pre">AddCollisionShapes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.planning.CollisionChecker.AddCollisionShapes" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddCollisionShapes(self: pydrake.planning.CollisionChecker, group_name: str, descriptions: list[pydrake.planning.BodyShapeDescription]) -&gt; int</p></li>
</ol>
<p>Requests the addition of N shapes to N bodies, each given in the set
of <code class="docutils literal notranslate"><span class="pre">descriptions</span></code>. Each added shape will belong to the named
geometry group.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">group_name</span></code>:</dt><dd><p>The name of the group to add the geometry to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">descriptions</span></code>:</dt><dd><p>The descriptions of N (shape, body) pairs.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The total number of shapes in <code class="docutils literal notranslate"><span class="pre">descriptions</span></code> that got added.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>AddCollisionShapes(self: pydrake.planning.CollisionChecker, geometry_groups: dict[str, list[pydrake.planning.BodyShapeDescription]]) -&gt; dict[str, int]</p></li>
</ol>
<p>Requests the addition of a collection of shapes to bodies across
multiple geometry groups. <code class="docutils literal notranslate"><span class="pre">geometry_groups</span></code> specifies a collection
of (shape, body) descriptors across multiple geometry groups.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">geometry_groups</span></code>:</dt><dd><p>A map from a named geometry group to the (shape, body) pairs to
add to that group.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A map from input named geometry group to the <em>number</em> of
geometries added to that group.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.AddCollisionShapeToBody">
<span class="sig-name descname"><span class="pre">AddCollisionShapeToBody</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">group_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bodyA</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.Shape" title="pydrake.geometry.Shape"><span class="pre">pydrake.geometry.Shape</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_AG</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.AddCollisionShapeToBody" title="Permalink to this definition"></a></dt>
<dd><p>Requests the addition of <code class="docutils literal notranslate"><span class="pre">shape</span></code> to the body A in the checker’s
model The added <code class="docutils literal notranslate"><span class="pre">shape</span></code> will belong to the named geometry group.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">group_name</span></code>:</dt><dd><p>The name of the group to add the geometry to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">bodyA</span></code>:</dt><dd><p>The body the shape should be rigidly affixed to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">shape</span></code>:</dt><dd><p>The requested shape, defined in its canonical frame G.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_AG</span></code>:</dt><dd><p>The pose of the shape in body A’s frame.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if the shape was added.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.AddCollisionShapeToFrame">
<span class="sig-name descname"><span class="pre">AddCollisionShapeToFrame</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">group_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frameA</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.Frame" title="pydrake.multibody.tree.Frame"><span class="pre">pydrake.multibody.tree.Frame</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.Shape" title="pydrake.geometry.Shape"><span class="pre">pydrake.geometry.Shape</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_AG</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.AddCollisionShapeToFrame" title="Permalink to this definition"></a></dt>
<dd><p>Requests the addition of <code class="docutils literal notranslate"><span class="pre">shape</span></code> to the frame A in the checker’s
model. The added <code class="docutils literal notranslate"><span class="pre">shape</span></code> will belong to the named geometry group.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">group_name</span></code>:</dt><dd><p>The name of the group to add the geometry to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameA</span></code>:</dt><dd><p>The frame the shape should be rigidly affixed to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">shape</span></code>:</dt><dd><p>The requested shape, defined in its canonical frame G.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_AG</span></code>:</dt><dd><p>The pose of the shape in the frame A.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if the shape was added.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.CalcContextRobotClearance">
<span class="sig-name descname"><span class="pre">CalcContextRobotClearance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionCheckerContext" title="pydrake.planning.CollisionCheckerContext"><span class="pre">pydrake.planning.CollisionCheckerContext</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">influence_distance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.planning.RobotClearance" title="pydrake.planning.RobotClearance"><span class="pre">pydrake.planning.RobotClearance</span></a></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.CalcContextRobotClearance" title="Permalink to this definition"></a></dt>
<dd><p>Explicit Context-based version of CalcRobotClearance().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if model_context is nullptr.</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ccb_explicit_contexts “Explicit Context Parallelism”.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.CalcRobotClearance">
<span class="sig-name descname"><span class="pre">CalcRobotClearance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">influence_distance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context_number</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.planning.RobotClearance" title="pydrake.planning.RobotClearance"><span class="pre">pydrake.planning.RobotClearance</span></a></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.CalcRobotClearance" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the distance, ϕ, and distance Jacobian, Jqᵣ_ϕ, for each
potential collision whose distance is less than
<code class="docutils literal notranslate"><span class="pre">influence_distance</span></code>, using the current thread’s associated context.</p>
<p>Distances for filtered collisions will not be returned.</p>
<p>Distances between a pair of robot bodies (i.e., where
<code class="docutils literal notranslate"><span class="pre">collision_types()</span></code> reports <code class="docutils literal notranslate"><span class="pre">SelfCollision</span></code>) report one body’s
index in <code class="docutils literal notranslate"><span class="pre">robot_indices()</span></code> and the the other body’s in
<code class="docutils literal notranslate"><span class="pre">other_indices()</span></code>; which body appears in which column is arbitrary.</p>
<p>The total number of rows can depend on how the model is defined and
how a particular CollisionChecker instance is implemented (see
MaxNumDistances()).</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RobotClearance for details on the quantities ϕ and Jqᵣ_ϕ (and
other details).</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context_number</span></code>:</dt><dd><p>Optional implicit context number.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ccb_implicit_contexts “Implicit Context Parallelism”.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.CheckConfigCollisionFree">
<span class="sig-name descname"><span class="pre">CheckConfigCollisionFree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context_number</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.CheckConfigCollisionFree" title="Permalink to this definition"></a></dt>
<dd><p>Checks a single configuration for collision using the current thread’s
associated context.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">q</span></code>:</dt><dd><p>Configuration to check</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context_number</span></code>:</dt><dd><p>Optional implicit context number.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>true if collision free, false if in collision.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ccb_implicit_contexts “Implicit Context Parallelism”.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.CheckConfigsCollisionFree">
<span class="sig-name descname"><span class="pre">CheckConfigsCollisionFree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">configs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parallelize</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.common.html#pydrake.common.Parallelism" title="pydrake.common.Parallelism"><span class="pre">pydrake.common.Parallelism</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.CheckConfigsCollisionFree" title="Permalink to this definition"></a></dt>
<dd><p>Checks a vector of configurations for collision, evaluating in
parallel when supported and enabled by <code class="docutils literal notranslate"><span class="pre">parallelize</span></code>.
Parallelization in configuration collision checks is provided using
OpenMP and is supported when both: (1) the collision checker declares
that parallelization is supported (i.e. when
SupportsParallelChecking() is true) and (2) when multiple OpenMP
threads are available for execution. See
collision_checker_parallel_edge “function-level parallelism” for
guidance on proper usage.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">configs</span></code>:</dt><dd><p>Configurations to check</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">parallelize</span></code>:</dt><dd><p>How much should collision checks be parallelized?</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>std::vector&lt;uint8_t&gt;, one for each configuration in configs. For
each configuration, 1 if collision free, 0 if in collision.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.CheckContextConfigCollisionFree">
<span class="sig-name descname"><span class="pre">CheckContextConfigCollisionFree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionCheckerContext" title="pydrake.planning.CollisionCheckerContext"><span class="pre">pydrake.planning.CollisionCheckerContext</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.CheckContextConfigCollisionFree" title="Permalink to this definition"></a></dt>
<dd><p>Explicit Context-based version of CheckConfigCollisionFree().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if model_context is nullptr.</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ccb_explicit_contexts “Explicit Context Parallelism”.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.CheckContextEdgeCollisionFree">
<span class="sig-name descname"><span class="pre">CheckContextEdgeCollisionFree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionCheckerContext" title="pydrake.planning.CollisionCheckerContext"><span class="pre">pydrake.planning.CollisionCheckerContext</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">q1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.CheckContextEdgeCollisionFree" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.CheckEdgeCollisionFree">
<span class="sig-name descname"><span class="pre">CheckEdgeCollisionFree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">q1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context_number</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.CheckEdgeCollisionFree" title="Permalink to this definition"></a></dt>
<dd><p>Checks a single configuration-to-configuration edge for collision,
using the current thread’s associated context.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">q1</span></code>:</dt><dd><p>Start configuration for edge.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">q2</span></code>:</dt><dd><p>End configuration for edge.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context_number</span></code>:</dt><dd><p>Optional implicit context number.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>true if collision free, false if in collision.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ccb_implicit_contexts “Implicit Context Parallelism”.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.CheckEdgeCollisionFreeParallel">
<span class="sig-name descname"><span class="pre">CheckEdgeCollisionFreeParallel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">q1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parallelize</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.common.html#pydrake.common.Parallelism" title="pydrake.common.Parallelism"><span class="pre">pydrake.common.Parallelism</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.CheckEdgeCollisionFreeParallel" title="Permalink to this definition"></a></dt>
<dd><p>Checks a single configuration-to-configuration edge for collision.
Collision check is parallelized via OpenMP when supported. See
collision_checker_parallel_edge “function-level parallelism” for
guidance on proper usage.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">q1</span></code>:</dt><dd><p>Start configuration for edge.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">q2</span></code>:</dt><dd><p>End configuration for edge.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">parallelize</span></code>:</dt><dd><p>How much should edge collision check be parallelized?</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>true if collision free, false if in collision.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.CheckEdgesCollisionFree">
<span class="sig-name descname"><span class="pre">CheckEdgesCollisionFree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">edges</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parallelize</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.common.html#pydrake.common.Parallelism" title="pydrake.common.Parallelism"><span class="pre">pydrake.common.Parallelism</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.CheckEdgesCollisionFree" title="Permalink to this definition"></a></dt>
<dd><p>Checks multiple configuration-to-configuration edges for collision.
Collision checks are parallelized via OpenMP when supported and
enabled by <code class="docutils literal notranslate"><span class="pre">parallelize</span></code>. See collision_checker_parallel_edge
“function-level parallelism” for guidance on proper usage.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">edges</span></code>:</dt><dd><p>Edges to check, each in the form of pair&lt;q1, q2&gt;.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">parallelize</span></code>:</dt><dd><p>How much should edge collision checks be parallelized?</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>std::vector&lt;uint8_t&gt;, one for each edge in edges. For each edge, 1
if collision free, 0 if in collision.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.ClassifyBodyCollisions">
<span class="sig-name descname"><span class="pre">ClassifyBodyCollisions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context_number</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#pydrake.planning.RobotCollisionType" title="pydrake.planning.RobotCollisionType"><span class="pre">pydrake.planning.RobotCollisionType</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.ClassifyBodyCollisions" title="Permalink to this definition"></a></dt>
<dd><p>Classifies which robot bodies are in collision (and which type of
collision) for the provided configuration <code class="docutils literal notranslate"><span class="pre">q</span></code>, using the current
thread’s associated context.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context_number</span></code>:</dt><dd><p>Optional implicit context number.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a vector of collision types arranged in body index order. Only
entries for robot bodies are guaranteed to be valid; entries for
environment bodies are populated with kNoCollision, regardless of
their actual status.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ccb_implicit_contexts “Implicit Context Parallelism”.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.ClassifyContextBodyCollisions">
<span class="sig-name descname"><span class="pre">ClassifyContextBodyCollisions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionCheckerContext" title="pydrake.planning.CollisionCheckerContext"><span class="pre">pydrake.planning.CollisionCheckerContext</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#pydrake.planning.RobotCollisionType" title="pydrake.planning.RobotCollisionType"><span class="pre">pydrake.planning.RobotCollisionType</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.ClassifyContextBodyCollisions" title="Permalink to this definition"></a></dt>
<dd><p>Explicit Context-based version of ClassifyBodyCollisions().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if model_context is nullptr.</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ccb_explicit_contexts “Explicit Context Parallelism”.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.Clone">
<span class="sig-name descname"><span class="pre">Clone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.Clone" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.ComputeConfigurationDistance">
<span class="sig-name descname"><span class="pre">ComputeConfigurationDistance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">q1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.ComputeConfigurationDistance" title="Permalink to this definition"></a></dt>
<dd><p>Computes configuration-space distance between the provided
configurations <code class="docutils literal notranslate"><span class="pre">q1</span></code> and <code class="docutils literal notranslate"><span class="pre">q2</span></code>, using the distance function
configured at construction- time or via
SetConfigurationDistanceFunction().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.distance_and_interpolation_provider">
<span class="sig-name descname"><span class="pre">distance_and_interpolation_provider</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.planning.DistanceAndInterpolationProvider" title="pydrake.planning.DistanceAndInterpolationProvider"><span class="pre">pydrake.planning.DistanceAndInterpolationProvider</span></a></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.distance_and_interpolation_provider" title="Permalink to this definition"></a></dt>
<dd><p>Gets the DistanceAndInterpolationProvider in use.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.edge_step_size">
<span class="sig-name descname"><span class="pre">edge_step_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.edge_step_size" title="Permalink to this definition"></a></dt>
<dd><p>Gets the current edge step size.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.get_body">
<span class="sig-name descname"><span class="pre">get_body</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.RigidBody" title="pydrake.multibody.tree.RigidBody"><span class="pre">pydrake.multibody.tree.RigidBody</span></a></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.get_body" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a <code class="docutils literal notranslate"><span class="pre">const</span></code> body reference to a body in the full model’s plant for
the given <code class="docutils literal notranslate"><span class="pre">body_index</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.GetAllAddedCollisionShapes">
<span class="sig-name descname"><span class="pre">GetAllAddedCollisionShapes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">dict</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#pydrake.planning.BodyShapeDescription" title="pydrake.planning.BodyShapeDescription"><span class="pre">pydrake.planning.BodyShapeDescription</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.GetAllAddedCollisionShapes" title="Permalink to this definition"></a></dt>
<dd><p>Gets all checker geometries currently added across the whole checker.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A mapping from each geometry group name to the collection of
(shape, body) descriptions in that group.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.GetFilteredCollisionMatrix">
<span class="sig-name descname"><span class="pre">GetFilteredCollisionMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.GetFilteredCollisionMatrix" title="Permalink to this definition"></a></dt>
<dd><p>Gets the “active” collision filter matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.GetLargestPadding">
<span class="sig-name descname"><span class="pre">GetLargestPadding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.GetLargestPadding" title="Permalink to this definition"></a></dt>
<dd><p>Gets the current largest collision padding across all (robot, <em>) body
pairs. This excludes the meaningless zeros on the diagonal and
environment-environment pairs; the return value *can</em> be negative.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.GetNominalFilteredCollisionMatrix">
<span class="sig-name descname"><span class="pre">GetNominalFilteredCollisionMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.GetNominalFilteredCollisionMatrix" title="Permalink to this definition"></a></dt>
<dd><p>Returns the “nominal” collision filter matrix. The nominal matrix is
initialized at construction time and represents the configuration of
the model’s plant and scene graph. It serves as a reference point to
assess any changes to collision filters beyond this checker’s
intrinsic model.</p>
<p>Collisions between bodies A and B are filtered in the following cases:</p>
<ul class="simple">
<li><p>There exists a welded path between A and B.</p></li>
<li><p>SceneGraph has filtered the collisions between <em>all</em> pairs of geometries</p></li>
</ul>
<p>of A and B.</p>
<p>Note: SceneGraph allows arbitrary collision filter configuration at
the geometry* level. The filters on one geometry of body need not be
the same as another geometry on the same body. CollisionChecker is
body centric. It requires all geometries on a body to be filtered
homogeneously. A SceneGraph that violates this stricter requirement
cannot be used in a CollisionChecker. It is highly unlikely that a
SceneGraph instance will ever be in this configuration by accident.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.GetPaddingBetween">
<span class="sig-name descname"><span class="pre">GetPaddingBetween</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.planning.CollisionChecker.GetPaddingBetween" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetPaddingBetween(self: pydrake.planning.CollisionChecker, bodyA_index: pydrake.multibody.tree.BodyIndex, bodyB_index: pydrake.multibody.tree.BodyIndex) -&gt; float</p></li>
</ol>
<p>Gets the padding value for the pair of bodies specified. If the body
indices are the same, zero will always be returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if either body index is out of range.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetPaddingBetween(self: pydrake.planning.CollisionChecker, bodyA: pydrake.multibody.tree.RigidBody, bodyB: pydrake.multibody.tree.RigidBody) -&gt; float</p></li>
</ol>
<p>Overload that uses body references.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.GetPaddingMatrix">
<span class="sig-name descname"><span class="pre">GetPaddingMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.GetPaddingMatrix" title="Permalink to this definition"></a></dt>
<dd><p>Gets the collision padding matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.GetZeroConfiguration">
<span class="sig-name descname"><span class="pre">GetZeroConfiguration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.GetZeroConfiguration" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a generalized position vector, sized according to the full model,
whose values are all zero.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>A zero vector is not necessarily a valid configuration, e.g., in
case the configuration has quaternions, or position constraints,
or etc.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.InterpolateBetweenConfigurations">
<span class="sig-name descname"><span class="pre">InterpolateBetweenConfigurations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">q1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ratio</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.InterpolateBetweenConfigurations" title="Permalink to this definition"></a></dt>
<dd><p>Interpolates between provided configurations <code class="docutils literal notranslate"><span class="pre">q1</span></code> and <code class="docutils literal notranslate"><span class="pre">q2</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">ratio</span></code>:</dt><dd><p>Interpolation ratio.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Interpolated configuration.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>RuntimeError if ratio is not in range</strong><strong> [</strong><strong>0</strong><strong>, </strong><strong>1</strong><strong>]</strong><strong></strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ConfigurationInterpolationFunction for more.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.IsCollisionFilteredBetween">
<span class="sig-name descname"><span class="pre">IsCollisionFilteredBetween</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.planning.CollisionChecker.IsCollisionFilteredBetween" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>IsCollisionFilteredBetween(self: pydrake.planning.CollisionChecker, bodyA_index: pydrake.multibody.tree.BodyIndex, bodyB_index: pydrake.multibody.tree.BodyIndex) -&gt; bool</p></li>
</ol>
<p>Checks if collision is filtered between the two bodies specified.
Note: collision between two environment bodies is <em>always</em> filtered.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if either body index is out of range.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>IsCollisionFilteredBetween(self: pydrake.planning.CollisionChecker, bodyA: pydrake.multibody.tree.RigidBody, bodyB: pydrake.multibody.tree.RigidBody) -&gt; bool</p></li>
</ol>
<p>Overload that uses body references.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.IsPartOfRobot">
<span class="sig-name descname"><span class="pre">IsPartOfRobot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.planning.CollisionChecker.IsPartOfRobot" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>IsPartOfRobot(self: pydrake.planning.CollisionChecker, body: pydrake.multibody.tree.RigidBody) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>true if the indicated body is part of the robot.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>IsPartOfRobot(self: pydrake.planning.CollisionChecker, body_index: pydrake.multibody.tree.BodyIndex) -&gt; bool</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>true if the indicated body is part of the robot.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.MakeStandaloneConfigurationDistanceFunction">
<span class="sig-name descname"><span class="pre">MakeStandaloneConfigurationDistanceFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.MakeStandaloneConfigurationDistanceFunction" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a functor that captures this object, so it can be used like a free
function. The returned functor is only valid during the lifetime
of this object. The math of the function is equivalent to
ComputeConfigurationDistance().</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>do not pass this standalone function back into
SetConfigurationDistanceFunction() function; doing so would create
an infinite loop.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.MakeStandaloneConfigurationInterpolationFunction">
<span class="sig-name descname"><span class="pre">MakeStandaloneConfigurationInterpolationFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.MakeStandaloneConfigurationInterpolationFunction" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a functor that captures this object, so it can be used like a free
function. The returned functor is only valid during the lifetime
of this object. The math of the function is equivalent to
InterpolateBetweenConfigurations().</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>do not pass this standalone function back into our
SetConfigurationInterpolationFunction() function; doing so would
create an infinite loop.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.MakeStandaloneModelContext">
<span class="sig-name descname"><span class="pre">MakeStandaloneModelContext</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.planning.CollisionCheckerContext" title="pydrake.planning.CollisionCheckerContext"><span class="pre">pydrake.planning.CollisionCheckerContext</span></a></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.MakeStandaloneModelContext" title="Permalink to this definition"></a></dt>
<dd><p>Make and track a CollisionCheckerContext. The returned context will
participate in PerformOperationAgainstAllModelContexts() until it is
destroyed.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.MaxContextNumDistances">
<span class="sig-name descname"><span class="pre">MaxContextNumDistances</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionCheckerContext" title="pydrake.planning.CollisionCheckerContext"><span class="pre">pydrake.planning.CollisionCheckerContext</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.MaxContextNumDistances" title="Permalink to this definition"></a></dt>
<dd><p>Explicit Context-based version of MaxNumDistances().</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ccb_explicit_contexts “Explicit Context Parallelism”.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.MaxNumDistances">
<span class="sig-name descname"><span class="pre">MaxNumDistances</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context_number</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.MaxNumDistances" title="Permalink to this definition"></a></dt>
<dd><p>Returns an upper bound on the number of distances returned by
CalcRobotClearance(), using the current thread’s associated context.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context_number</span></code>:</dt><dd><p>Optional implicit context number.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ccb_implicit_contexts “Implicit Context Parallelism”.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.MaybeGetUniformRobotEnvironmentPadding">
<span class="sig-name descname"><span class="pre">MaybeGetUniformRobotEnvironmentPadding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.MaybeGetUniformRobotEnvironmentPadding" title="Permalink to this definition"></a></dt>
<dd><p>If the padding between all robot bodies and environment bodies is the
same, returns the common padding value. Returns nullopt otherwise.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.MaybeGetUniformRobotRobotPadding">
<span class="sig-name descname"><span class="pre">MaybeGetUniformRobotRobotPadding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.MaybeGetUniformRobotRobotPadding" title="Permalink to this definition"></a></dt>
<dd><p>If the padding between all pairs of robot bodies is the same, returns
the common padding value. Returns nullopt otherwise.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.MeasureContextEdgeCollisionFree">
<span class="sig-name descname"><span class="pre">MeasureContextEdgeCollisionFree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionCheckerContext" title="pydrake.planning.CollisionCheckerContext"><span class="pre">pydrake.planning.CollisionCheckerContext</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">q1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.planning.EdgeMeasure" title="pydrake.planning.EdgeMeasure"><span class="pre">pydrake.planning.EdgeMeasure</span></a></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.MeasureContextEdgeCollisionFree" title="Permalink to this definition"></a></dt>
<dd><p>Explicit Context-based version of MeasureEdgeCollisionFree().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if model_context is nullptr.</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ccb_explicit_contexts “Explicit Context Parallelism”.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.MeasureEdgeCollisionFree">
<span class="sig-name descname"><span class="pre">MeasureEdgeCollisionFree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">q1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context_number</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.planning.EdgeMeasure" title="pydrake.planning.EdgeMeasure"><span class="pre">pydrake.planning.EdgeMeasure</span></a></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.MeasureEdgeCollisionFree" title="Permalink to this definition"></a></dt>
<dd><p>Checks a single configuration-to-configuration edge for collision,
using the current thread’s associated context.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">q1</span></code>:</dt><dd><p>Start configuration for edge.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">q2</span></code>:</dt><dd><p>End configuration for edge.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context_number</span></code>:</dt><dd><p>Optional implicit context number.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A measure of how much of the edge is collision free.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ccb_implicit_contexts “Implicit Context Parallelism”.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.MeasureEdgeCollisionFreeParallel">
<span class="sig-name descname"><span class="pre">MeasureEdgeCollisionFreeParallel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">q1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parallelize</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.common.html#pydrake.common.Parallelism" title="pydrake.common.Parallelism"><span class="pre">pydrake.common.Parallelism</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.planning.EdgeMeasure" title="pydrake.planning.EdgeMeasure"><span class="pre">pydrake.planning.EdgeMeasure</span></a></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.MeasureEdgeCollisionFreeParallel" title="Permalink to this definition"></a></dt>
<dd><p>Checks a single configuration-to-configuration edge for collision.
Collision check is parallelized via OpenMP when supported. See
collision_checker_parallel_edge “function-level parallelism” for
guidance on proper usage.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">q1</span></code>:</dt><dd><p>Start configuration for edge.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">q2</span></code>:</dt><dd><p>End configuration for edge.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">parallelize</span></code>:</dt><dd><p>How much should edge collision check be parallelized?</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A measure of how much of the edge is collision free.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.MeasureEdgesCollisionFree">
<span class="sig-name descname"><span class="pre">MeasureEdgesCollisionFree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">edges</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parallelize</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.common.html#pydrake.common.Parallelism" title="pydrake.common.Parallelism"><span class="pre">pydrake.common.Parallelism</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#pydrake.planning.EdgeMeasure" title="pydrake.planning.EdgeMeasure"><span class="pre">pydrake.planning.EdgeMeasure</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.MeasureEdgesCollisionFree" title="Permalink to this definition"></a></dt>
<dd><p>Checks multiple configuration-to-configuration edge for collision.
Collision checks are parallelized via OpenMP when supported and
enabled by <code class="docutils literal notranslate"><span class="pre">parallelize</span></code>. See collision_checker_parallel_edge
“function-level parallelism” for guidance on proper usage.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">edges</span></code>:</dt><dd><p>Edges to check, each in the form of pair&lt;q1, q2&gt;.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">parallelize</span></code>:</dt><dd><p>How much should edge collision checks be parallelized?</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A measure of how much of each edge is collision free. The iᵗʰ
entry is the result for the iᵗʰ edge.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.model">
<span class="sig-name descname"><span class="pre">model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.planning.RobotDiagram" title="pydrake.planning.RobotDiagram"><span class="pre">pydrake.planning.RobotDiagram</span></a></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.model" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a <code class="docutils literal notranslate"><span class="pre">const</span></code> reference to the full model.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.model_context">
<span class="sig-name descname"><span class="pre">model_context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context_number</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.planning.CollisionCheckerContext" title="pydrake.planning.CollisionCheckerContext"><span class="pre">pydrake.planning.CollisionCheckerContext</span></a></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.model_context" title="Permalink to this definition"></a></dt>
<dd><p>Accesses a collision checking context from within the implicit context
pool owned by this collision checker.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context_number</span></code>:</dt><dd><p>Optional implicit context number.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a <code class="docutils literal notranslate"><span class="pre">const</span></code> reference to either the collision checking context
given by the <code class="docutils literal notranslate"><span class="pre">context_number</span></code>, or when nullopt the context to be
used with the current OpenMP thread.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ccb_implicit_contexts “Implicit Context Parallelism”.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.num_allocated_contexts">
<span class="sig-name descname"><span class="pre">num_allocated_contexts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.num_allocated_contexts" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the number of internal (not standalone) per-thread contexts.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.PerformOperationAgainstAllModelContexts">
<span class="sig-name descname"><span class="pre">PerformOperationAgainstAllModelContexts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">operation</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#pydrake.planning.RobotDiagram" title="pydrake.planning.RobotDiagram"><span class="pre">pydrake.planning.RobotDiagram</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#pydrake.planning.CollisionCheckerContext" title="pydrake.planning.CollisionCheckerContext"><span class="pre">pydrake.planning.CollisionCheckerContext</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">None</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.PerformOperationAgainstAllModelContexts" title="Permalink to this definition"></a></dt>
<dd><p>Allows externally-provided operations that must be performed against
all contexts in the per-thread context pool, and any standalone
contexts made with MakeStandaloneModelContext().</p>
<p>For any standalone contexts, note that it is illegal to mutate a
context from two different threads. No other threads should be
mutating any of our standalone contexts when this function is called.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.plant">
<span class="sig-name descname"><span class="pre">plant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.plant.html#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.plant" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a <a href="#id1"><span class="problematic" id="id2">`</span></a>const reference to the full model’s plant.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.plant_context">
<span class="sig-name descname"><span class="pre">plant_context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context_number</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.plant_context" title="Permalink to this definition"></a></dt>
<dd><p>Accesses a multibody plant sub-context context from within the
implicit context pool owned by this collision checker.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context_number</span></code>:</dt><dd><p>Optional implicit context number.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a <code class="docutils literal notranslate"><span class="pre">const</span></code> reference to the multibody plant sub-context within
the context given by the <code class="docutils literal notranslate"><span class="pre">context_number</span></code>, or when nullopt the
context to be used with the current OpenMP thread.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ccb_implicit_contexts “Implicit Context Parallelism”.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.RemoveAllAddedCollisionShapes">
<span class="sig-name descname"><span class="pre">RemoveAllAddedCollisionShapes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.planning.CollisionChecker.RemoveAllAddedCollisionShapes" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>RemoveAllAddedCollisionShapes(self: pydrake.planning.CollisionChecker, group_name: str) -&gt; None</p></li>
</ol>
<p>Removes all added checker geometries which belong to the named group.</p>
<ol class="arabic simple" start="2">
<li><p>RemoveAllAddedCollisionShapes(self: pydrake.planning.CollisionChecker) -&gt; None</p></li>
</ol>
<p>Removes all added checker geometries from all geometry groups.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.robot_model_instances">
<span class="sig-name descname"><span class="pre">robot_model_instances</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.ModelInstanceIndex" title="pydrake.multibody.tree.ModelInstanceIndex"><span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.robot_model_instances" title="Permalink to this definition"></a></dt>
<dd><p>Gets the set of model instances belonging to the robot. The returned
vector has no duplicates and is in sorted order.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.set_edge_step_size">
<span class="sig-name descname"><span class="pre">set_edge_step_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_step_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.set_edge_step_size" title="Permalink to this definition"></a></dt>
<dd><p>Sets the edge step size to <code class="docutils literal notranslate"><span class="pre">edge_step_size</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if edge_step_size is not positive.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.SetCollisionFilteredBetween">
<span class="sig-name descname"><span class="pre">SetCollisionFilteredBetween</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.planning.CollisionChecker.SetCollisionFilteredBetween" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetCollisionFilteredBetween(self: pydrake.planning.CollisionChecker, bodyA_index: pydrake.multibody.tree.BodyIndex, bodyB_index: pydrake.multibody.tree.BodyIndex, filter_collision: bool) -&gt; None</p></li>
</ol>
<p>Declares the body pair (bodyA, bodyB) to be filtered (or not) based on
<code class="docutils literal notranslate"><span class="pre">filter_collision</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">filter_collision</span></code>:</dt><dd><p>Sets the to body pair to be filtered if <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if either body index is out of range.</strong> – </p></li>
<li><p><strong>RuntimeError if both indices refer to the same body.</strong> – </p></li>
<li><p><strong>RuntimeError if both indices refer to environment bodies.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SetCollisionFilteredBetween(self: pydrake.planning.CollisionChecker, bodyA: pydrake.multibody.tree.RigidBody, bodyB: pydrake.multibody.tree.RigidBody, filter_collision: bool) -&gt; None</p></li>
</ol>
<p>Overload that uses body references.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.SetCollisionFilteredWithAllBodies">
<span class="sig-name descname"><span class="pre">SetCollisionFilteredWithAllBodies</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.planning.CollisionChecker.SetCollisionFilteredWithAllBodies" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetCollisionFilteredWithAllBodies(self: pydrake.planning.CollisionChecker, body_index: pydrake.multibody.tree.BodyIndex) -&gt; None</p></li>
</ol>
<p>Declares that body pair (B, O) is filtered (for all bodies O in this
checker’s plant).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if body_index is out of range.</strong> – </p></li>
<li><p><strong>RuntimeError if body_index refers to an environment body.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SetCollisionFilteredWithAllBodies(self: pydrake.planning.CollisionChecker, body: pydrake.multibody.tree.RigidBody) -&gt; None</p></li>
</ol>
<p>Overload that uses body references.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.SetCollisionFilterMatrix">
<span class="sig-name descname"><span class="pre">SetCollisionFilterMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_matrix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.SetCollisionFilterMatrix" title="Permalink to this definition"></a></dt>
<dd><p>Sets the “active” collision filter matrix</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">filter_matrix</span></code>:</dt><dd><p>must meet the above conditions to be a “consistent” collision
filter matrix.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the given matrix is incompatible with this</strong> – </p></li>
<li><p><strong>collision checker</strong><strong>, or </strong><strong>if it is inconsistent.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.SetConfigurationDistanceFunction">
<span class="sig-name descname"><span class="pre">SetConfigurationDistanceFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance_function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.SetConfigurationDistanceFunction" title="Permalink to this definition"></a></dt>
<dd><p>Sets the configuration distance function to <code class="docutils literal notranslate"><span class="pre">distance_function</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>distance_function satisfies the requirements documented on
ConfigurationDistanceFunction and a
DistanceAndInterpolationProvider is not already in use.</p>
</dd>
<dt>Precondition:</dt><dd><p>the collision checker was created with separate distance and
interpolation functions, not a combined
DistanceAndInterpolationProvider.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>the <code class="docutils literal notranslate"><span class="pre">distance_function</span></code> object will be copied and retained by
this collision checker, so if the function has any lambda-captured
data then that data must outlive this collision checker.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.SetConfigurationInterpolationFunction">
<span class="sig-name descname"><span class="pre">SetConfigurationInterpolationFunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">interpolation_function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.SetConfigurationInterpolationFunction" title="Permalink to this definition"></a></dt>
<dd><p>Sets the configuration interpolation function to
<code class="docutils literal notranslate"><span class="pre">interpolation_function</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">interpolation_function</span></code>:</dt><dd><p>a functor, or nullptr. If nullptr, the default function will be
configured and used.</p>
</dd>
<dt>Precondition:</dt><dd><p>interpolation_function satisfies the requirements documented on
ConfigurationInterpolationFunction, or is nullptr and a
DistanceAndInterpolationProvider is not already in use.</p>
</dd>
<dt>Precondition:</dt><dd><p>the collision checker was created with separate distance and
interpolation functions, not a combined
DistanceAndInterpolationProvider.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>the <code class="docutils literal notranslate"><span class="pre">interpolation_function</span></code> object will be copied and retained
by this collision checker, so if the function has any
lambda-captured data then that data must outlive this collision
checker.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>the default function uses linear interpolation for most variables,
and uses slerp for quaternion valued variables.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.SetDistanceAndInterpolationProvider">
<span class="sig-name descname"><span class="pre">SetDistanceAndInterpolationProvider</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">provider</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.DistanceAndInterpolationProvider" title="pydrake.planning.DistanceAndInterpolationProvider"><span class="pre">pydrake.planning.DistanceAndInterpolationProvider</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.SetDistanceAndInterpolationProvider" title="Permalink to this definition"></a></dt>
<dd><p>Sets the distance and interpolation provider to use. Note that in case
any of the (to-be-deprecated) separate distance and interpolation
functions were in use, this supplants <em>both</em> of them.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>provider satisfies the requirements documents on
DistanceAndInterpolationProvider.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.SetPaddingAllRobotEnvironmentPairs">
<span class="sig-name descname"><span class="pre">SetPaddingAllRobotEnvironmentPairs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">padding</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.SetPaddingAllRobotEnvironmentPairs" title="Permalink to this definition"></a></dt>
<dd><p>Sets the padding for all (robot, environment) pairs.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the collision_checker_padding_prereqs</strong> – </p></li>
<li><p><strong>&quot;configuration prerequisites&quot; are not met.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.SetPaddingAllRobotRobotPairs">
<span class="sig-name descname"><span class="pre">SetPaddingAllRobotRobotPairs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">padding</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.SetPaddingAllRobotRobotPairs" title="Permalink to this definition"></a></dt>
<dd><p>Sets the padding for all (robot, robot) pairs.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the collision_checker_padding_prereqs</strong> – </p></li>
<li><p><strong>&quot;configuration prerequisites&quot; are not met.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.SetPaddingBetween">
<span class="sig-name descname"><span class="pre">SetPaddingBetween</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.planning.CollisionChecker.SetPaddingBetween" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetPaddingBetween(self: pydrake.planning.CollisionChecker, bodyA_index: pydrake.multibody.tree.BodyIndex, bodyB_index: pydrake.multibody.tree.BodyIndex, padding: float) -&gt; None</p></li>
</ol>
<p>Sets the padding value for the pair of bodies specified.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the collision_checker_padding_prereqs</strong> – </p></li>
<li><p><strong>&quot;configuration prerequisites&quot; are not met</strong><strong> or </strong><strong>``bodyA_index ==</strong> – </p></li>
<li><p><strong>bodyB_index``.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SetPaddingBetween(self: pydrake.planning.CollisionChecker, bodyA: pydrake.multibody.tree.RigidBody, bodyB: pydrake.multibody.tree.RigidBody, padding: float) -&gt; None</p></li>
</ol>
<p>Overload that uses body references.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.SetPaddingMatrix">
<span class="sig-name descname"><span class="pre">SetPaddingMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">collision_padding</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.SetPaddingMatrix" title="Permalink to this definition"></a></dt>
<dd><p>Sets the collision padding matrix. Note that this matrix contains all
padding data, both robot-robot “self” padding, and robot-environment
padding. <code class="docutils literal notranslate"><span class="pre">collision_padding</span></code> must have the following properties to
be considered valid.</p>
<ul class="simple">
<li><p>It is a square NxN matrix (where N is the total number of bodies).</p></li>
<li><p>Diagonal values are all zero.</p></li>
<li><p>Entries involving only environment bodies are all zero.</p></li>
<li><p>It is symmetric.</p></li>
<li><p>All values are finite.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if collision_padding doesn't have the enumerated</strong> – </p></li>
<li><p><strong>properties.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.SetPaddingOneRobotBodyAllEnvironmentPairs">
<span class="sig-name descname"><span class="pre">SetPaddingOneRobotBodyAllEnvironmentPairs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">body_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">padding</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.SetPaddingOneRobotBodyAllEnvironmentPairs" title="Permalink to this definition"></a></dt>
<dd><p>Sets the environment collision padding for the provided robot body
with respect to all environment bodies.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the collision_checker_padding_prereqs</strong> – </p></li>
<li><p><strong>&quot;configuration prerequisites&quot; are not met.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.SupportsParallelChecking">
<span class="sig-name descname"><span class="pre">SupportsParallelChecking</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.SupportsParallelChecking" title="Permalink to this definition"></a></dt>
<dd><p>Does the collision checker support true parallel collision checks?</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>true if parallel checking is supported.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.UpdateContextPositions">
<span class="sig-name descname"><span class="pre">UpdateContextPositions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionCheckerContext" title="pydrake.planning.CollisionCheckerContext"><span class="pre">pydrake.planning.CollisionCheckerContext</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.UpdateContextPositions" title="Permalink to this definition"></a></dt>
<dd><p>Explicit Context-based version of UpdatePositions().</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if model_context is nullptr.</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ccb_explicit_contexts “Explicit Context Parallelism”.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionChecker.UpdatePositions">
<span class="sig-name descname"><span class="pre">UpdatePositions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context_number</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></span><a class="headerlink" href="#pydrake.planning.CollisionChecker.UpdatePositions" title="Permalink to this definition"></a></dt>
<dd><p>Updates the generalized positions <code class="docutils literal notranslate"><span class="pre">q</span></code> in the implicit context
specified and returns a reference to the MultibodyPlant’s now-updated
context. The implicit context is either that specified by
<code class="docutils literal notranslate"><span class="pre">context_number</span></code>, or when nullopt the context to be used with the
current OpenMP thread.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context_number</span></code>:</dt><dd><p>Optional implicit context number.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ccb_implicit_contexts “Implicit Context Parallelism”.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.planning.CollisionCheckerContext">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.planning.</span></span><span class="sig-name descname"><span class="pre">CollisionCheckerContext</span></span><a class="headerlink" href="#pydrake.planning.CollisionCheckerContext" title="Permalink to this definition"></a></dt>
<dd><p>This class represents the data necessary for CollisionChecker to
operate safely across multiple threads in its <code class="docutils literal notranslate"><span class="pre">const</span></code> API. Instances
of this class are owned and managed by a particular CollisionChecker.</p>
<p>If using OMP to perform parallel const queries on a CollisionChecker,
it will never be necessary to interact with CollisionCheckerContext
instances. Only if using some other threading paradigm will it be
necessary to work with “stand alone” instances. See CollisionChecker’s
documentation for more details.</p>
<p>In all cases, modifying context should happen through
CollisionChecker::PerformOperationAgainstAllModelContexts(). Modifying
the contained Drake Contexts directly is generally erroneous.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionCheckerContext.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionCheckerContext" title="pydrake.planning.CollisionCheckerContext"><span class="pre">pydrake.planning.CollisionCheckerContext</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagram" title="pydrake.planning.RobotDiagram"><span class="pre">pydrake.planning.RobotDiagram</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.CollisionCheckerContext.__init__" title="Permalink to this definition"></a></dt>
<dd><p>The resulting object stores an alias to <code class="docutils literal notranslate"><span class="pre">model</span></code>; the passed model
should have a lifetime greater than the constructed object.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>model is not null.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionCheckerContext.Clone">
<span class="sig-name descname"><span class="pre">Clone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionCheckerContext" title="pydrake.planning.CollisionCheckerContext"><span class="pre">pydrake.planning.CollisionCheckerContext</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.planning.CollisionCheckerContext" title="pydrake.planning.CollisionCheckerContext"><span class="pre">pydrake.planning.CollisionCheckerContext</span></a></span></span><a class="headerlink" href="#pydrake.planning.CollisionCheckerContext.Clone" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionCheckerContext.GetQueryObject">
<span class="sig-name descname"><span class="pre">GetQueryObject</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionCheckerContext" title="pydrake.planning.CollisionCheckerContext"><span class="pre">pydrake.planning.CollisionCheckerContext</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.QueryObject" title="pydrake.geometry.QueryObject"><span class="pre">pydrake.geometry.QueryObject</span></a></span></span><a class="headerlink" href="#pydrake.planning.CollisionCheckerContext.GetQueryObject" title="Permalink to this definition"></a></dt>
<dd><p>Gets the scene graph geometry query object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionCheckerContext.model_context">
<span class="sig-name descname"><span class="pre">model_context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionCheckerContext" title="pydrake.planning.CollisionCheckerContext"><span class="pre">pydrake.planning.CollisionCheckerContext</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></span><a class="headerlink" href="#pydrake.planning.CollisionCheckerContext.model_context" title="Permalink to this definition"></a></dt>
<dd><p>Gets the contained model context.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionCheckerContext.plant_context">
<span class="sig-name descname"><span class="pre">plant_context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionCheckerContext" title="pydrake.planning.CollisionCheckerContext"><span class="pre">pydrake.planning.CollisionCheckerContext</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></span><a class="headerlink" href="#pydrake.planning.CollisionCheckerContext.plant_context" title="Permalink to this definition"></a></dt>
<dd><p>Gets the contained plant context.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionCheckerContext.scene_graph_context">
<span class="sig-name descname"><span class="pre">scene_graph_context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionCheckerContext" title="pydrake.planning.CollisionCheckerContext"><span class="pre">pydrake.planning.CollisionCheckerContext</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></span><a class="headerlink" href="#pydrake.planning.CollisionCheckerContext.scene_graph_context" title="Permalink to this definition"></a></dt>
<dd><p>Gets the contained scene graph context.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.planning.CollisionCheckerParams">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.planning.</span></span><span class="sig-name descname"><span class="pre">CollisionCheckerParams</span></span><a class="headerlink" href="#pydrake.planning.CollisionCheckerParams" title="Permalink to this definition"></a></dt>
<dd><p>A set of common constructor parameters for a CollisionChecker. Not all
subclasses of CollisionChecker will necessarily support this
configuration struct, but many do so.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.CollisionCheckerParams.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.planning.CollisionCheckerParams.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.planning.CollisionCheckerParams) -&gt; None</p></li>
<li><p>__init__(self: pydrake.planning.CollisionCheckerParams, <a href="#id5"><span class="problematic" id="id6">**</span></a>kwargs) -&gt; None</p></li>
</ol>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.planning.CollisionCheckerParams.configuration_distance_function">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">configuration_distance_function</span></span><a class="headerlink" href="#pydrake.planning.CollisionCheckerParams.configuration_distance_function" title="Permalink to this definition"></a></dt>
<dd><p>Configuration (probably weighted) distance function.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Either a DistanceAndInterpolationProvider OR a
ConfigurationDistanceFunction may be provided, not both. If
neither is provided, a LinearDistanceAndInterpolationProvider with
default weights is used.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>the <code class="docutils literal notranslate"><span class="pre">configuration_distance_function</span></code> object will be copied and
retained by a collision checker, so if the function has any
lambda-captured data then that data must outlive the collision
checker.</p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.planning.CollisionCheckerParams.distance_and_interpolation_provider">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">distance_and_interpolation_provider</span></span><a class="headerlink" href="#pydrake.planning.CollisionCheckerParams.distance_and_interpolation_provider" title="Permalink to this definition"></a></dt>
<dd><p>A DistanceAndInterpolationProvider to support configuration distance
and interpolation operations.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Either a DistanceAndInterpolationProvider OR a
ConfigurationDistanceFunction may be provided, not both. If
neither is provided, a LinearDistanceAndInterpolationProvider with
default weights is used.</p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.planning.CollisionCheckerParams.edge_step_size">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">edge_step_size</span></span><a class="headerlink" href="#pydrake.planning.CollisionCheckerParams.edge_step_size" title="Permalink to this definition"></a></dt>
<dd><p>Step size for edge checking; in units compatible with the
configuration distance function. Collision checking of edges q1-&gt;q2 is
performed by interpolating from q1 to q2 at edge_step_size steps and
checking the interpolated configuration for collision. The value must
be positive.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.planning.CollisionCheckerParams.env_collision_padding">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">env_collision_padding</span></span><a class="headerlink" href="#pydrake.planning.CollisionCheckerParams.env_collision_padding" title="Permalink to this definition"></a></dt>
<dd><p>Additional padding to apply to all robot-environment collision
queries. If distance between robot and environment is less than
padding, the checker reports a collision.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.planning.CollisionCheckerParams.implicit_context_parallelism">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">implicit_context_parallelism</span></span><a class="headerlink" href="#pydrake.planning.CollisionCheckerParams.implicit_context_parallelism" title="Permalink to this definition"></a></dt>
<dd><p>Specify how many contexts should be allocated to support collision
checker implicit context parallelism. Defaults to the maximum
parallelism. If the specific collision checker type in use declares
that it <em>does not</em> support parallel queries, then implicit context
parallelism is set to None().</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ccb_implicit_contexts “Implicit Context Parallelism”.</p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.planning.CollisionCheckerParams.model">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">model</span></span><a class="headerlink" href="#pydrake.planning.CollisionCheckerParams.model" title="Permalink to this definition"></a></dt>
<dd><p>A RobotDiagram model of the robot and environment. Must not be
nullptr.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.planning.CollisionCheckerParams.robot_model_instances">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">robot_model_instances</span></span><a class="headerlink" href="#pydrake.planning.CollisionCheckerParams.robot_model_instances" title="Permalink to this definition"></a></dt>
<dd><p>A vector of model instance indices that identify which model instances
belong to the robot. The list must be non-empty and must not include
the world model instance.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.planning.CollisionCheckerParams.self_collision_padding">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">self_collision_padding</span></span><a class="headerlink" href="#pydrake.planning.CollisionCheckerParams.self_collision_padding" title="Permalink to this definition"></a></dt>
<dd><p>Additional padding to apply to all robot-robot self collision queries.
If distance between robot and itself is less than padding, the checker
reports a collision.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.planning.DirectCollocation">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.planning.</span></span><span class="sig-name descname"><span class="pre">DirectCollocation</span></span><a class="headerlink" href="#pydrake.planning.DirectCollocation" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.planning.MultipleShooting" title="pydrake.planning.MultipleShooting"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.planning.MultipleShooting</span></code></a></p>
<p>DirectCollocation implements the approach to trajectory optimization
as described in C. R. Hargraves and S. W. Paris. Direct trajectory
optimization using nonlinear programming and collocation. J Guidance,
10(4):338-342, July-August 1987. It assumes a first-order hold on the
input trajectory and a cubic spline representation of the state
trajectory, and adds dynamic constraints (and running costs) to the
midpoints as well as the breakpoints in order to achieve a 3rd order
integration accuracy.</p>
<p>Note: This algorithm only works with the continuous states of a
system.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.DirectCollocation.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self:</span> <span class="pre">pydrake.planning.DirectCollocation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">system:</span> <span class="pre">pydrake.systems.framework.System</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_time_samples:</span> <span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minimum_time_step:</span> <span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maximum_time_step:</span> <span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_port_index:</span> <span class="pre">Union[pydrake.systems.framework.InputPortSelection</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pydrake.systems.framework.InputPortIndex]</span> <span class="pre">=</span> <span class="pre">&lt;InputPortSelection.kUseFirstInputIfItExists:</span> <span class="pre">-2&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">assume_non_continuous_states_are_fixed:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prog:</span> <span class="pre">pydrake.solvers.MathematicalProgram</span> <span class="pre">=</span> <span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.DirectCollocation.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Constructs the MathematicalProgram% and adds the collocation
constraints.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">system</span></code>:</dt><dd><p>A dynamical system to be used in the dynamic constraints. This
system must support System::ToAutoDiffXd. Note that this is
aliased for the lifetime of this object.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Required to describe any parameters of the system. The values of
the state in this context do not have any effect. This context
will also be “cloned” by the optimization; changes to the context
after calling this method will NOT impact the trajectory
optimization.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_time_samples</span></code>:</dt><dd><p>The number of breakpoints in the trajectory.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">minimum_time_step</span></code>:</dt><dd><p>Minimum spacing between sample times.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">maximum_time_step</span></code>:</dt><dd><p>Maximum spacing between sample times.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">input_port_index</span></code>:</dt><dd><p>A valid input port index for <code class="docutils literal notranslate"><span class="pre">system</span></code> or InputPortSelection. All
other inputs on the system will be left disconnected (if they are
disconnected in <code class="docutils literal notranslate"><span class="pre">context)</span></code> or will be fixed to their current
values (if they are connected/fixed in <code class="docutils literal notranslate"><span class="pre">context)</span></code>.</p>
</dd>
<dt><em>Default:</em> kUseFirstInputIfItExists.</dt><dd><p>$Parameter <code class="docutils literal notranslate"><span class="pre">assume_non_continuous_states_are_fixed</span></code>:</p>
</dd>
</dl>
<p>Boolean which, if true, allows this algorithm to optimize without
considering the dynamics of any non-continuous states. This is helpful
for optimizing systems that might have some additional book-keeping
variables in their state. Only use this if you are sure that the
dynamics of the additional state variables cannot impact the dynamics
of the continuous states. $*Default:* false.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">prog</span></code>:</dt><dd><p>(optional). If non-null, then additional decision variables,
costs, and constraints will be added into the existing
MathematicalProgram. This can be useful for, e.g., combining
multiple trajectory optimizations into a single program, coupled
by a few constraints. If nullptr, then a new MathematicalProgram
will be allocated.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if system is not supported by this direct</strong> – </p></li>
<li><p><strong>collocation method.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.planning.DirectCollocationConstraint">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.planning.</span></span><span class="sig-name descname"><span class="pre">DirectCollocationConstraint</span></span><a class="headerlink" href="#pydrake.planning.DirectCollocationConstraint" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.Constraint" title="pydrake.solvers.Constraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Constraint</span></code></a></p>
<p>Implements the direct collocation constraints for a first-order hold
on the input and a cubic polynomial representation of the state
trajectories.</p>
<p>Note that the DirectCollocation implementation allocates only ONE of
these constraints, but binds that constraint multiple times (with
different decision variables, along the trajectory).</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.DirectCollocationConstraint.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self:</span> <span class="pre">pydrake.planning.DirectCollocationConstraint</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">system:</span> <span class="pre">pydrake.systems.framework.System</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_port_index:</span> <span class="pre">Union[pydrake.systems.framework.InputPortSelection</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pydrake.systems.framework.InputPortIndex]</span> <span class="pre">=</span> <span class="pre">&lt;InputPortSelection.kUseFirstInputIfItExists:</span> <span class="pre">-2&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">assume_non_continuous_states_are_fixed:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.DirectCollocationConstraint.__init__" title="Permalink to this definition"></a></dt>
<dd><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DirectCollocation constructor for a description of the parameters.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if system is not supported by this direct</strong> – </p></li>
<li><p><strong>collocation method.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.planning.DirectTranscription">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.planning.</span></span><span class="sig-name descname"><span class="pre">DirectTranscription</span></span><a class="headerlink" href="#pydrake.planning.DirectTranscription" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.planning.MultipleShooting" title="pydrake.planning.MultipleShooting"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.planning.MultipleShooting</span></code></a></p>
<p>DirectTranscription is perhaps the simplest implementation of a
multiple shooting method, where we have decision variables
representing the control and input at every sample time in the
trajectory, and one-step of numerical integration provides the dynamic
constraints between those decision variables.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.DirectTranscription.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.planning.DirectTranscription.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.planning.DirectTranscription, system: pydrake.systems.framework.System, context: pydrake.systems.framework.Context, num_time_samples: int, input_port_index: Union[pydrake.systems.framework.InputPortSelection, pydrake.systems.framework.InputPortIndex] = &lt;InputPortSelection.kUseFirstInputIfItExists: -2&gt;) -&gt; None</p></li>
</ol>
<p>Constructs the MathematicalProgram and adds the dynamic constraints.
This version of the constructor is only for simple discrete-time
systems (with a single periodic time step update). Continuous-time
systems must call one of the constructors that takes bounds on the
time step as an argument.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">system</span></code>:</dt><dd><p>A dynamical system to be used in the dynamic constraints. This
system must support System::ToAutoDiffXd. Note that this is
aliased for the lifetime of this object.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Required to describe any parameters of the system. The values of
the state in this context do not have any effect. This context
will also be “cloned” by the optimization; changes to the context
after calling this method will NOT impact the trajectory
optimization.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_time_samples</span></code>:</dt><dd><p>The number of breakpoints in the trajectory.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">input_port_index</span></code>:</dt><dd><p>A valid input port index or valid InputPortSelection for
<code class="docutils literal notranslate"><span class="pre">system</span></code>. All other inputs on the system will be left
disconnected (if they are disconnected in <code class="docutils literal notranslate"><span class="pre">context)</span></code> or will be
set to their current values (if they are connected/fixed in
<code class="docutils literal notranslate"><span class="pre">context)</span></code>.</p>
</dd>
<dt><em>Default:</em> kUseFirstInputIfItExists.</dt><dd><p>$Raises:</p>
</dd>
</dl>
<p>RuntimeError if <code class="docutils literal notranslate"><span class="pre">context.has_only_discrete_state()</span> <span class="pre">==</span> <span class="pre">false</span></code>.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.planning.DirectTranscription, system: pydrake.systems.framework.System, context: pydrake.systems.framework.Context, num_time_samples: int, fixed_time_step: pydrake.planning.DirectTranscription.TimeStep, input_port_index: Union[pydrake.systems.framework.InputPortSelection, pydrake.systems.framework.InputPortIndex] = &lt;InputPortSelection.kUseFirstInputIfItExists: -2&gt;) -&gt; None</p></li>
</ol>
<p>Constructs the MathematicalProgram and adds the dynamic constraints.
This version of the constructor is only for continuous-time systems;
the dynamics constraints use explicit forward Euler integration.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">system</span></code>:</dt><dd><p>A dynamical system to be used in the dynamic constraints. This
system must support System::ToAutoDiffXd. Note that this is
aliased for the lifetime of this object.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Required to describe any parameters of the system. The values of
the state in this context do not have any effect. This context
will also be “cloned” by the optimization; changes to the context
after calling this method will NOT impact the trajectory
optimization.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_time_samples</span></code>:</dt><dd><p>The number of breakpoints in the trajectory.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">fixed_time_step</span></code>:</dt><dd><p>The spacing between sample times.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">input_port_index</span></code>:</dt><dd><p>A valid input port index or valid InputPortSelection for
<code class="docutils literal notranslate"><span class="pre">system</span></code>. All other inputs on the system will be left
disconnected (if they are disconnected in <code class="docutils literal notranslate"><span class="pre">context)</span></code> or will be
set to their current values (if they are connected/fixed in
<code class="docutils literal notranslate"><span class="pre">context)</span></code>.</p>
</dd>
<dt><em>Default:</em> kUseFirstInputIfItExists.</dt><dd><p>$Raises:</p>
</dd>
</dl>
<p>RuntimeError if <code class="docutils literal notranslate"><span class="pre">context.has_only_continuous_state()</span> <span class="pre">==</span> <span class="pre">false</span></code>.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.planning.DirectTranscription.TimeStep">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">TimeStep</span></span><a class="headerlink" href="#pydrake.planning.DirectTranscription.TimeStep" title="Permalink to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.DirectTranscription.TimeStep.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.DirectTranscription.TimeStep" title="pydrake.planning.DirectTranscription.TimeStep"><span class="pre">pydrake.planning.DirectTranscription.TimeStep</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.DirectTranscription.TimeStep.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.planning.DirectTranscription.TimeStep.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#pydrake.planning.DirectTranscription.TimeStep.value" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.planning.DistanceAndInterpolationProvider">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.planning.</span></span><span class="sig-name descname"><span class="pre">DistanceAndInterpolationProvider</span></span><a class="headerlink" href="#pydrake.planning.DistanceAndInterpolationProvider" title="Permalink to this definition"></a></dt>
<dd><p>This class represents the base interface for performing configuration
distance and interpolation operations, used by CollisionChecker. See
LinearDistanceAndInterpolationProvider for an implementation covering
common “linear” distance and interpolation behavior.</p>
<p>Configuration distance and interpolation are necessary for a
CollisionChecker to perform edge collision checks, and an essential
part of many motion planning problems. The C-spaces for many planning
problems combine joints with widely differing effects (e.g. for a
given angular change, the shoulder joint of a robot arm results in
much more significant motion than the same change on a finger joint)
or units (e.g. a mobile robot with translation in meters and yaw in
radians). As a result, it is often necessary to weight elements of the
configuration differently when computing configuration distance.</p>
<p>Likewise, in more complex C-spaces, it may be necessary to perform
more complex interpolation behavior (e.g. when planning for a mobile
robot whose motion is modelled via Dubbins or Reeds-Shepp paths).</p>
<p>Configuration distance takes two configurations of the robot, from and
to, both as Eigen::VectorXd, and returns (potentially weighted)
C-space distance as a double. The returned distance will be strictly
non-negative.</p>
<p>To be valid, distance must satisfy the following condition:</p>
<ul class="simple">
<li><p>ComputeConfigurationDistance(q, q) ≡ 0</p></li>
</ul>
<p>for values of q that are valid for the C-space in use.</p>
<p>Configuration interpolation takes two configurations of the robot,
from and to, both as Eigen::VectorXd, plus a ratio in [0, 1] and
returns the interpolated configuration.</p>
<p>To be valid, interpolation must satisfy the following conditions:</p>
<ul class="simple">
<li><p>InterpolateBetweenConfigurations(from, to, 0) ≡ from</p></li>
<li><p>InterpolateBetweenConfigurations(from, to, 1) ≡ to</p></li>
<li><p>InterpolateBetweenConfigurations(q, q, ratio) ≡ q, for all ratio in [0, 1]</p></li>
</ul>
<p>for values of q, from, and to that are valid for the C-space in use.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.DistanceAndInterpolationProvider.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.planning.DistanceAndInterpolationProvider.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.DistanceAndInterpolationProvider.ComputeConfigurationDistance">
<span class="sig-name descname"><span class="pre">ComputeConfigurationDistance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.DistanceAndInterpolationProvider" title="pydrake.planning.DistanceAndInterpolationProvider"><span class="pre">pydrake.planning.DistanceAndInterpolationProvider</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.planning.DistanceAndInterpolationProvider.ComputeConfigurationDistance" title="Permalink to this definition"></a></dt>
<dd><p>Computes the configuration distance from the provided configuration
<code class="docutils literal notranslate"><span class="pre">from</span></code> to the provided configuration <code class="docutils literal notranslate"><span class="pre">to</span></code>. The returned distance
will be strictly non-negative.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>from.size() == to.size()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.DistanceAndInterpolationProvider.InterpolateBetweenConfigurations">
<span class="sig-name descname"><span class="pre">InterpolateBetweenConfigurations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.DistanceAndInterpolationProvider" title="pydrake.planning.DistanceAndInterpolationProvider"><span class="pre">pydrake.planning.DistanceAndInterpolationProvider</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.DistanceAndInterpolationProvider.InterpolateBetweenConfigurations" title="Permalink to this definition"></a></dt>
<dd><p>Returns the interpolated configuration between <code class="docutils literal notranslate"><span class="pre">from</span></code> and <code class="docutils literal notranslate"><span class="pre">to</span></code> at
<code class="docutils literal notranslate"><span class="pre">ratio</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>from.size() == to.size()</p>
</dd>
<dt>Precondition:</dt><dd><p>ratio in [0, 1]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.planning.EdgeMeasure">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.planning.</span></span><span class="sig-name descname"><span class="pre">EdgeMeasure</span></span><a class="headerlink" href="#pydrake.planning.EdgeMeasure" title="Permalink to this definition"></a></dt>
<dd><p>The measure of the distance of the edge from q1 to q2 and the portion
of that is collision free.</p>
<p>Distance is that produced by
CollisionChecker::ComputeConfigurationDistance() for the entire edge
between q1 and q2.</p>
<p>The portion of the edge between q1 and q2 that is collision free is
encoded as the value α with the following semantics:</p>
<ul class="simple">
<li><p>α = 1:</p></li>
</ul>
<p>No collisions were detected. The full edge can be considered collision
free. This is the <em>only</em> time completely_free() reports <code class="docutils literal notranslate"><span class="pre">True</span></code>.
- 0 ≤ α &lt; 1:
A collision was detected between q1 and q2. α is the <em>largest</em>
interpolation value such that an edge from q1 to qα can be considered
collision free (where qα = interpolate(q1, q2, α)). partially_free()
reports <code class="docutils literal notranslate"><span class="pre">True</span></code>.
- α is undefined:
q1 was found to be in collision. That means there exists no α for which the
edge (q1, qα) can be collision free.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The length of the collision-free edge can be computed via distance
* α. To simplify comparisons between a number of edges, some of
which may not have a defined α, the function
alpha_or(default_value) is provided. This is equivalent to
<code class="docutils literal notranslate"><span class="pre">edge.partially_free()</span> <span class="pre">?</span> <span class="pre">edge.alpha()</span> <span class="pre">:</span> <span class="pre">default_value</span></code>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For α to be meaningful, the caller is obliged to make sure that
they use the same interpolating function as the CollisionChecker
did when generating the measure. Calling
CollisionChecker::InterpolateBetweenConfigurations() on the same
checker instance would satisfy that requirement.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.EdgeMeasure.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.planning.EdgeMeasure.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.planning.EdgeMeasure, distance: float, alpha: float) -&gt; None</p></li>
</ol>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">≤</span> <span class="pre">distance</span></code></p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">≤</span> <span class="pre">alpha</span> <span class="pre">≤</span> <span class="pre">1</span></code> to indicate defined <code class="docutils literal notranslate"><span class="pre">alpha</span></code>, negative
otherwise.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.planning.EdgeMeasure, other: pydrake.planning.EdgeMeasure) -&gt; None</p></li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.EdgeMeasure.alpha">
<span class="sig-name descname"><span class="pre">alpha</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.EdgeMeasure" title="pydrake.planning.EdgeMeasure"><span class="pre">pydrake.planning.EdgeMeasure</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.planning.EdgeMeasure.alpha" title="Permalink to this definition"></a></dt>
<dd><p>Returns the value of alpha, if defined.</p>
<p>Note: Due to the sampling nature of the edge check, the edge (q1, qα)
may not actually be collision free (due to a missed collision).
There’s a further subtlety. Subsequently calling
CheckEdgeCollisionFree(q1, qα) may return <code class="docutils literal notranslate"><span class="pre">False</span></code>. This apparent
contradiction is due to the fact that the samples on the edge (q1, qα)
will not necessarily be the same as the samples originally tested on
the edge (q1, q2). It is possible for those new samples to detect a
previously missed collision. This is not a bug, merely a property of
sampling-based testing.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>partially_free() returns <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.EdgeMeasure.alpha_or">
<span class="sig-name descname"><span class="pre">alpha_or</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.EdgeMeasure" title="pydrake.planning.EdgeMeasure"><span class="pre">pydrake.planning.EdgeMeasure</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">default_value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.planning.EdgeMeasure.alpha_or" title="Permalink to this definition"></a></dt>
<dd><p>Returns the value of alpha, if defined, or the provided default value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.EdgeMeasure.completely_free">
<span class="sig-name descname"><span class="pre">completely_free</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.EdgeMeasure" title="pydrake.planning.EdgeMeasure"><span class="pre">pydrake.planning.EdgeMeasure</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.planning.EdgeMeasure.completely_free" title="Permalink to this definition"></a></dt>
<dd><p>Reports <code class="docutils literal notranslate"><span class="pre">True</span></code> if all samples were collision free.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.EdgeMeasure.distance">
<span class="sig-name descname"><span class="pre">distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.EdgeMeasure" title="pydrake.planning.EdgeMeasure"><span class="pre">pydrake.planning.EdgeMeasure</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.planning.EdgeMeasure.distance" title="Permalink to this definition"></a></dt>
<dd><p>Returns the edge distance.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.EdgeMeasure.partially_free">
<span class="sig-name descname"><span class="pre">partially_free</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.EdgeMeasure" title="pydrake.planning.EdgeMeasure"><span class="pre">pydrake.planning.EdgeMeasure</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.planning.EdgeMeasure.partially_free" title="Permalink to this definition"></a></dt>
<dd><p>Reports <code class="docutils literal notranslate"><span class="pre">True</span></code> if there’s <em>any</em> portion of the edge (starting from
q1) that is collision free. By implication, if completely_free()
reports <code class="docutils literal notranslate"><span class="pre">True</span></code>, so will this.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.planning.</span></span><span class="sig-name descname"><span class="pre">GcsTrajectoryOptimization</span></span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization" title="Permalink to this definition"></a></dt>
<dd><p>GcsTrajectoryOptimization implements a simplified motion planning
optimization problem introduced in the paper <a class="reference external" href="https://arxiv.org/abs/2205.04422">“Motion Planning around
Obstacles with Convex Optimization”</a> by Tobia Marcucci, Mark Petersen,
David von Wrangel, Russ Tedrake.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This feature is considered to be <strong>experimental</strong> and may change
or be removed at any time, without any deprecation notice ahead of
time.</p>
</div>
<p>Instead of using the full time-scaling curve, this problem uses a
single time-scaling variable for each region. This formulation yields
continuous trajectories, which are not differentiable at the
transition times between the regions since non-convex continuity
constraints are not supported yet. However, it supports continuity on
the path r(s) for arbitrary degree. The path r(s) can be reconstructed
from the gcs solution q(t) with <code class="docutils literal notranslate"><span class="pre">NormalizeSegmentTimes()</span></code> and
post-processed with e.g. Toppra to enforce acceleration bounds.</p>
<p>The ith piece of the composite trajectory is defined as q(t) = r((t -
tᵢ) / hᵢ). r : [0, 1] → ℝⁿ is a the path, parametrized as a Bézier
curve with order n. tᵢ and hᵢ are the initial time and duration of the
ith sub-trajectory.</p>
<p>This class supports the notion of a Subgraph of regions. This has
proven useful to facilitate multi-modal motion planning such as:
Subgraph A: find a collision-free trajectory for the robot to a
grasping posture, Subgraph B: find a collision-free trajectory for the
robot with the object in its hand to a placing posture, etc.</p>
<p><a href="#id7"><span class="problematic" id="id8">**</span></a>** Continuous Revolute Joints</p>
<p>This class also supports robots with continuous revolute joints
(revolute joints that don’t have any joint limits) and mobile bases.
Adding or subtracting 2π to such a joint’s angle leaves it unchanged;
this logic is implemented behind the scenes. To use it, one should
specify the joint indices that don’t have limits, and ensure all sets
satisfy the “convexity radius” property – their width along a
dimension corresponding to a continuous revolute joint must be less
than π. This can be enforced when constructing the convex sets, or
after the fact with <code class="docutils literal notranslate"><span class="pre">geometry::optimization::PartitionConvexSet</span></code>.
The <code class="docutils literal notranslate"><span class="pre">GcsTrajectoryOptimization</span></code> methods <code class="docutils literal notranslate"><span class="pre">AddRegions</span></code> and
<code class="docutils literal notranslate"><span class="pre">AddEdges</span></code> will handle all of the intersection checks behind the
scenes, including applying the appropriate logic to connect sets that
“wrap around” 2π.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.GcsTrajectoryOptimization" title="pydrake.planning.GcsTrajectoryOptimization"><span class="pre">pydrake.planning.GcsTrajectoryOptimization</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_positions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">continuous_revolute_joints</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Constructs the motion planning problem.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_positions</span></code>:</dt><dd><p>is the dimension of the configuration space.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">continuous_revolute_joints</span></code>:</dt><dd><p>is a list of indices corresponding to continuous revolute joints,
i.e., revolute joints which don’t have any joint limits, and hence
“wrap around” at 2π. Each entry in continuous_revolute_joints must
be non-negative, less than num_positions, and unique. This feature
is currently only supported within a single subgraph: continuous
revolute joints won’t be taken into account when constructing
edges between subgraphs or checking if sets intersect through a
subspace.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.AddContinuityConstraints">
<span class="sig-name descname"><span class="pre">AddContinuityConstraints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.GcsTrajectoryOptimization" title="pydrake.planning.GcsTrajectoryOptimization"><span class="pre">pydrake.planning.GcsTrajectoryOptimization</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">continuity_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.AddContinuityConstraints" title="Permalink to this definition"></a></dt>
<dd><p>Enforces derivative continuity constraints on the entire graph.</p>
<p>This adds a nonlinear constraint to the restriction and MIP
GraphOfConvexSets::Transcription, while adding a convex surrogate to
the relaxation. For more details, see nonconvex_graph_of_convex_sets
“Guiding Non-convex Optimization with the GraphOfConvexSets”.</p>
<p>The continuity is enforced on the control points of q(t), which appear
as nonlinear constraints.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">dᴺrᵤ</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dsᴺ</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">hᵤᴺ</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="n">dᴺrᵥ</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dsᴺ</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">hᵥᴺ</span><span class="w"></span>
</pre></div>
</div>
</details><p>The convex surrogate is simply the path continuity, where hᵤᴺ and hᵥᴺ
are replaced by the characteristic times of the respective sets:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">dᴺrᵤ</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dsᴺ</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">hᵤ₀ᴺ</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="n">dᴺrᵥ</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dsᴺ</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">hᵥ₀ᴺ</span><span class="w"></span>
</pre></div>
</div>
</details><p>. For now, these are set to one, but future work may involve scaling
them by the size of the sets.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">continuity_order</span></code>:</dt><dd><p>is the order of the continuity constraint.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the continuity order is less than one since path</strong> – </p></li>
<li><p><strong>continuity is enforced by default.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.AddEdges">
<span class="sig-name descname"><span class="pre">AddEdges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.GcsTrajectoryOptimization" title="pydrake.planning.GcsTrajectoryOptimization"><span class="pre">pydrake.planning.GcsTrajectoryOptimization</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">from_subgraph</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.GcsTrajectoryOptimization.Subgraph" title="pydrake.planning.GcsTrajectoryOptimization.Subgraph"><span class="pre">pydrake.planning.GcsTrajectoryOptimization.Subgraph</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">to_subgraph</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.GcsTrajectoryOptimization.Subgraph" title="pydrake.planning.GcsTrajectoryOptimization.Subgraph"><span class="pre">pydrake.planning.GcsTrajectoryOptimization.Subgraph</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">subspace</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.geometry.optimization.html#pydrake.geometry.optimization.ConvexSet" title="pydrake.geometry.optimization.ConvexSet"><span class="pre">pydrake.geometry.optimization.ConvexSet</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edges_between_regions</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_offsets</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.planning.GcsTrajectoryOptimization.EdgesBetweenSubgraphs" title="pydrake.planning.GcsTrajectoryOptimization.EdgesBetweenSubgraphs"><span class="pre">pydrake.planning.GcsTrajectoryOptimization.EdgesBetweenSubgraphs</span></a></span></span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.AddEdges" title="Permalink to this definition"></a></dt>
<dd><p>Connects two subgraphs with directed edges.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">from_subgraph</span></code>:</dt><dd><p>is the subgraph to connect from. Must have been created from a
call to AddRegions() on this object, not some other optimization
program.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">to_subgraph</span></code>:</dt><dd><p>is the subgraph to connect to. Must have been created from a call
to AddRegions() on this object, not some other optimization
program.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">subspace</span></code>:</dt><dd><p>is the subspace that the connecting control points must be in.
Subspace is optional. Only edges that connect through the subspace
will be added, and the subspace is added as a constraint on the
connecting control points. Subspaces of type point or HPolyhedron
are supported since other sets require constraints that are not
yet supported by the GraphOfConvexSets::Edge constraint, e.g., set
containment of a Hyperellipsoid is formulated via LorentzCone
constraints. Workaround: Create a subgraph of zero order with the
subspace as the region and connect it between the two subgraphs.
This works because GraphOfConvexSet::Vertex supports arbitrary
instances of ConvexSets.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">edges_between_regions</span></code>:</dt><dd><p>can be used to manually specify which edges should be added,
avoiding the intersection checks. It should be a list of tuples
<code class="docutils literal notranslate"><span class="pre">(i,j)</span></code>, where an edge will be added from the <code class="docutils literal notranslate"><span class="pre">i`th</span> <span class="pre">index</span>
<span class="pre">region</span> <span class="pre">in</span> <span class="pre">`from_subgraph</span></code> to the <code class="docutils literal notranslate"><span class="pre">j`th</span> <span class="pre">index</span> <span class="pre">region</span> <span class="pre">in</span>
<span class="pre">`to_subgraph</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">edge_offsets</span></code>:</dt><dd><p>is an optional list of vectors. If defined, the list must contain
the same number of entries as <code class="docutils literal notranslate"><span class="pre">edges_between_regions</span></code>, and the
order must match. In other words, if defined, there must be one
edge offset for each specified edge, and they must be at the same
index. For each pair of sets listed in <code class="docutils literal notranslate"><span class="pre">edges_between_regions</span></code>,
the first set is translated (in configuration space) by the
corresponding vector in edge_offsets before computing the
constraints associated to that edge. This is used to add edges
between sets that “wrap around” 2π along some dimension, due to,
e.g., a continuous revolute joint. This edge offset corresponds to
the translation component of the affine map τ_uv in equation (11)
of “Non-Euclidean Motion Planning with Graphs of
Geodesically-Convex Sets”, and per the discussion in Subsection VI
A, τ_uv has no rotation component. If edge_offsets is nullptr, it
will instead be computed automatically.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if edge_offsets is provided</strong><strong>, </strong><strong>but</strong> – </p></li>
<li><p><strong>edge_offsets.size</strong><strong>(</strong><strong>) </strong><strong>!= edges_between_regions.size</strong><strong>(</strong><strong>)</strong><strong>`</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.AddNonlinearDerivativeBounds">
<span class="sig-name descname"><span class="pre">AddNonlinearDerivativeBounds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.GcsTrajectoryOptimization" title="pydrake.planning.GcsTrajectoryOptimization"><span class="pre">pydrake.planning.GcsTrajectoryOptimization</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">lb</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ub</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derivative_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.AddNonlinearDerivativeBounds" title="Permalink to this definition"></a></dt>
<dd><p>Adds a nonlinear derivative constraints to the entire graph <code class="docutils literal notranslate"><span class="pre">lb</span></code> ≤
dᴺq(t) / dtᴺ ≤ <code class="docutils literal notranslate"><span class="pre">ub</span></code>.</p>
<p>This adds a nonlinear constraint to the restriction and MIP
GraphOfConvexSets::Transcription, while adding a convex surrogate to
the relaxation. For more details, see nonconvex_graph_of_convex_sets
“Guiding Non-convex Optimization with the GraphOfConvexSets”.</p>
<p>The nonlinear constraint involves the derivative dᴺq(t) / dtᴺ which is
decomposed as dᴺr(s) / dsᴺ / hᴺ. The convex surrogate replaces the
nonlinear component hᴺ with h₀ᴺ⁻¹h, where h₀ is the characteristic
time of the set. For now, h₀ is set to 1.0 for all sets.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lb</span></code>:</dt><dd><p>is the lower bound of the derivative.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">ub</span></code>:</dt><dd><p>is the upper bound of the derivative.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code>:</dt><dd><p>is the order of the derivative to be constrained.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if lb</strong><strong> or </strong><strong>ub are not of size num_positions</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
<li><p><strong>RuntimeError if the derivative order &lt;= 1</strong><strong>, </strong><strong>since the linear</strong> – </p></li>
<li><p><strong>velocity bounds are preferred.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.AddPathContinuityConstraints">
<span class="sig-name descname"><span class="pre">AddPathContinuityConstraints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.GcsTrajectoryOptimization" title="pydrake.planning.GcsTrajectoryOptimization"><span class="pre">pydrake.planning.GcsTrajectoryOptimization</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">continuity_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.AddPathContinuityConstraints" title="Permalink to this definition"></a></dt>
<dd><p>Enforces derivative continuity constraints on the entire graph.</p>
<p>Note that the constraints are on the control points of the derivatives
of r(s) and not q(t). This may result in discontinuities of the
trajectory return by <code class="docutils literal notranslate"><span class="pre">SolvePath()</span></code> since the r(s) will get rescaled
by the duration h to yield q(t). <code class="docutils literal notranslate"><span class="pre">NormalizeSegmentTimes()</span></code> will
return r(s) with valid continuity.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">continuity_order</span></code>:</dt><dd><p>is the order of the continuity constraint.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the continuity order is less than one since path</strong> – </p></li>
<li><p><strong>continuity is enforced by default.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.AddPathEnergyCost">
<span class="sig-name descname"><span class="pre">AddPathEnergyCost</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.AddPathEnergyCost" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddPathEnergyCost(self: pydrake.planning.GcsTrajectoryOptimization, weight_matrix: numpy.ndarray[numpy.float64[m, n]]) -&gt; None</p></li>
</ol>
<p>Similar to AddPathLengthCost in usage, but minimizes ∑ <a href="#id9"><span class="problematic" id="id10">|</span></a>weight_matrix
* (rᵢ₊₁ − rᵢ)|₂². In comparison to AddPathLength cost, this cost
encourages control points to be evenly spaced but may result in
greater number of regions and larger path length on the solution. It
is recommended to use this cost only with SolveConvexRestriction when
it becomes a quadratic cost for which some solvers show a better
performance.</p>
<p>This cost will be added to the entire graph. Since the path length is
only defined for Bézier curves that have two or more control points,
this cost will only added to all subgraphs with order greater than
zero. Note that this cost will be applied even to subgraphs added in
the future.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">weight_matrix</span></code>:</dt><dd><p>is the relative weight of each component for the cost. The
diagonal of the matrix is the weight for each dimension. The
off-diagonal elements are the weight for the cross terms, which
can be used to penalize diagonal movement.</p>
</dd>
<dt>Precondition:</dt><dd><p>weight_matrix must be of size num_positions() x num_positions().</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>AddPathEnergyCost(self: pydrake.planning.GcsTrajectoryOptimization, weight: float = 1.0) -&gt; None</p></li>
</ol>
<p>Similar to AddPathLengthCost in usage, but minimizes ∑ <a href="#id11"><span class="problematic" id="id12">|</span></a>(rᵢ₊₁ − rᵢ)|₂²
with weight being applied uniformly to all dimensions. In comparison
to AddPathLength cost, this cost encourages control points to be
evenly spaced but may result in greater number of regions and larger
path length on the solution. It is recommended to use this cost only
with SolveConvexRestriction when it becomes a quadratic cost for which
some solvers show a better performance.</p>
<p>This cost will be added to the entire graph. Since the path length is
only defined for Bézier curves that have two or more control points,
this cost will only added to all subgraphs with order greater than
zero. Note that this cost will be applied even to subgraphs added in
the future.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">weight</span></code>:</dt><dd><p>is the relative weight of the cost.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.AddPathLengthCost">
<span class="sig-name descname"><span class="pre">AddPathLengthCost</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.AddPathLengthCost" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddPathLengthCost(self: pydrake.planning.GcsTrajectoryOptimization, weight_matrix: numpy.ndarray[numpy.float64[m, n]]) -&gt; None</p></li>
</ol>
<p>Adds multiple L2Norm Costs on the upper bound of the path length.
Since we cannot directly compute the path length of a Bézier curve, we
minimize the upper bound of the path integral by minimizing the sum of
(weighted) distances between control points: ∑ <a href="#id13"><span class="problematic" id="id14">|</span></a>weight_matrix * (rᵢ₊₁
− rᵢ)|₂.</p>
<p>This cost will be added to the entire graph. Since the path length is
only defined for Bézier curves that have two or more control points,
this cost will only added to all subgraphs with order greater than
zero. Note that this cost will be applied even to subgraphs added in
the future.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">weight_matrix</span></code>:</dt><dd><p>is the relative weight of each component for the cost. The
diagonal of the matrix is the weight for each dimension. The
off-diagonal elements are the weight for the cross terms, which
can be used to penalize diagonal movement.</p>
</dd>
<dt>Precondition:</dt><dd><p>weight_matrix must be of size num_positions() x num_positions().</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>AddPathLengthCost(self: pydrake.planning.GcsTrajectoryOptimization, weight: float = 1.0) -&gt; None</p></li>
</ol>
<p>Adds multiple L2Norm Costs on the upper bound of the path length.
Since we cannot directly compute the path length of a Bézier curve, we
minimize the upper bound of the path integral by minimizing the sum of
distances between control points. For Bézier curves, this is
equivalent to the sum of the L2Norm of the derivative control points
of the curve divided by the order.</p>
<p>This cost will be added to the entire graph. Since the path length is
only defined for Bézier curves that have two or more control points,
this cost will only added to all subgraphs with order greater than
zero. Note that this cost will be applied even to subgraphs added in
the future.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">weight</span></code>:</dt><dd><p>is the relative weight of the cost.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.AddRegions">
<span class="sig-name descname"><span class="pre">AddRegions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.AddRegions" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddRegions(self: pydrake.planning.GcsTrajectoryOptimization, regions: list[pydrake.geometry.optimization.ConvexSet], edges_between_regions: list[tuple[int, int]], order: int, h_min: float = 1e-06, h_max: float = 20, name: str = ‘’, edge_offsets: Optional[list[numpy.ndarray[numpy.float64[m, 1]]]] = None) -&gt; pydrake.planning.GcsTrajectoryOptimization.Subgraph</p></li>
</ol>
<p>Creates a Subgraph with the given regions and indices.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">regions</span></code>:</dt><dd><p>represent the valid set a control point can be in. We retain a
copy of the regions since other functions may access them. If any
of the positions represent revolute joints without limits, each
region has a maximum width of strictly less than π along
dimensions corresponding to those joints.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">edges_between_regions</span></code>:</dt><dd><p>is a list of pairs of indices into the regions vector. For each
pair representing an edge between two regions, an edge is added
within the subgraph. Note that the edges are directed so (i,j)
will only add an edge from region i to region j.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">order</span></code>:</dt><dd><p>is the order of the Bézier curve.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">h_max</span></code>:</dt><dd><p>is the maximum duration to spend in a region (seconds). Some
solvers struggle numerically with large values.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">h_min</span></code>:</dt><dd><p>is the minimum duration to spend in a region (seconds) if that
region is visited on the optimal path. Some cost and constraints
are only convex for h &gt; 0. For example the perspective quadratic
cost of the path energy ||ṙ(s)||² / h becomes non-convex for h =
0. Otherwise h_min can be set to 0.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>is the name of the subgraph. If the passed name is an empty
string, a default name will be provided.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">edge_offsets</span></code>:</dt><dd><p>is an optional list of vectors. If defined, the list must contain
the same number of entries as <code class="docutils literal notranslate"><span class="pre">edges_between_regions</span></code>. For each
pair of sets listed in <code class="docutils literal notranslate"><span class="pre">edges_between_regions</span></code>, the first set is
translated (in configuration space) by the corresponding vector in
edge_offsets before computing the constraints associated to that
edge. This is used to add edges between sets that “wrap around” 2π
along some dimension, due to, e.g., a continuous revolute joint.
This edge offset corresponds to the translation component of the
affine map τ_uv in equation (11) of “Non-Euclidean Motion Planning
with Graphs of Geodesically-Convex Sets”, and per the discussion
in Subsection VI A, τ_uv has no rotation component. If
edge_offsets is nullptr, it will instead be computed
automatically.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if any index referenced in edges_between_regions</strong> – </p></li>
<li><p><strong>is outside the range</strong><strong> [</strong><strong>0</strong><strong>, </strong><strong>ssize</strong><strong>(</strong><strong>regions</strong><strong>)</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>AddRegions(self: pydrake.planning.GcsTrajectoryOptimization, regions: list[pydrake.geometry.optimization.ConvexSet], order: int, h_min: float = 1e-06, h_max: float = 20, name: str = ‘’) -&gt; pydrake.planning.GcsTrajectoryOptimization.Subgraph</p></li>
</ol>
<p>Creates a Subgraph with the given regions. This function will compute
the edges between the regions based on the set intersections.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">regions</span></code>:</dt><dd><p>represent the valid set a control point can be in. We retain a
copy of the regions since other functions may access them. If any
of the positions represent continuous revolute joints, each region
must have a maximum width of strictly less than π along dimensions
corresponding to those joints.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">order</span></code>:</dt><dd><p>is the order of the Bézier curve.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">h_min</span></code>:</dt><dd><p>is the minimum duration to spend in a region (seconds) if that
region is visited on the optimal path. Some cost and constraints
are only convex for h &gt; 0. For example the perspective quadratic
cost of the path energy ||ṙ(s)||² / h becomes non-convex for h =
0. Otherwise h_min can be set to 0.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">h_max</span></code>:</dt><dd><p>is the maximum duration to spend in a region (seconds). Some
solvers struggle numerically with large values.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>is the name of the subgraph. A default name will be provided.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if any of the regions has a width of π</strong><strong> or </strong><strong>greater</strong> – </p></li>
<li><p><strong>along dimensions corresponding to continuous revolute joints.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.AddTimeCost">
<span class="sig-name descname"><span class="pre">AddTimeCost</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.GcsTrajectoryOptimization" title="pydrake.planning.GcsTrajectoryOptimization"><span class="pre">pydrake.planning.GcsTrajectoryOptimization</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.AddTimeCost" title="Permalink to this definition"></a></dt>
<dd><p>Adds a minimum time cost to all regions in the whole graph. The cost
is the sum of the time scaling variables.</p>
<p>This cost will be added to the entire graph. Note that this cost will
be applied even to subgraphs added in the future.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">weight</span></code>:</dt><dd><p>is the relative weight of the cost.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.AddVelocityBounds">
<span class="sig-name descname"><span class="pre">AddVelocityBounds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.GcsTrajectoryOptimization" title="pydrake.planning.GcsTrajectoryOptimization"><span class="pre">pydrake.planning.GcsTrajectoryOptimization</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">lb</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ub</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.AddVelocityBounds" title="Permalink to this definition"></a></dt>
<dd><p>Adds a linear velocity constraint to the entire graph <code class="docutils literal notranslate"><span class="pre">lb</span></code> ≤ q̇(t) ≤
<code class="docutils literal notranslate"><span class="pre">ub</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lb</span></code>:</dt><dd><p>is the lower bound of the velocity.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">ub</span></code>:</dt><dd><p>is the upper bound of the velocity.</p>
</dd>
</dl>
<p>This constraint will be added to the entire graph. Since the velocity
requires forming the derivative of the Bézier curve, this constraint
will only added to all subgraphs with order greater than zero. Note
that this constraint will be applied even to subgraphs added in the
future.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if lb</strong><strong> or </strong><strong>ub are not of size num_positions</strong><strong>(</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.continuous_revolute_joints">
<span class="sig-name descname"><span class="pre">continuous_revolute_joints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.GcsTrajectoryOptimization" title="pydrake.planning.GcsTrajectoryOptimization"><span class="pre">pydrake.planning.GcsTrajectoryOptimization</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.continuous_revolute_joints" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of indices corresponding to continuous revolute joints.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.EdgesBetweenSubgraphs">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">EdgesBetweenSubgraphs</span></span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.EdgesBetweenSubgraphs" title="Permalink to this definition"></a></dt>
<dd><p>EdgesBetweenSubgraphs are defined as the connecting edges between two
given subgraphs. These edges are a subset of the many other edges in
the larger graph. From an API standpoint, EdgesBetweenSubgraphs enable
transitions between Subgraphs, which can enable transitions between
modes. Further, it allows different constraints to be added in the
transition between subgraphs. Note that the EdgesBetweenSubgraphs
can’t be separated from the actual edges in the GraphOfConvexSets
framework, thus mixing it with other instances of
GCSTrajetoryOptimization is not supported.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.EdgesBetweenSubgraphs.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.EdgesBetweenSubgraphs.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.EdgesBetweenSubgraphs.AddContinuityConstraints">
<span class="sig-name descname"><span class="pre">AddContinuityConstraints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.GcsTrajectoryOptimization.EdgesBetweenSubgraphs" title="pydrake.planning.GcsTrajectoryOptimization.EdgesBetweenSubgraphs"><span class="pre">pydrake.planning.GcsTrajectoryOptimization.EdgesBetweenSubgraphs</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">continuity_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.EdgesBetweenSubgraphs.AddContinuityConstraints" title="Permalink to this definition"></a></dt>
<dd><p>Enforces derivative continuity constraints on the edges between the
subgraphs.</p>
<p>This adds a nonlinear constraint to the restriction and MIP
GraphOfConvexSets::Transcription, while adding a convex surrogate to
the relaxation. For more details, see nonconvex_graph_of_convex_sets
“Guiding Non-convex Optimization with the GraphOfConvexSets”.</p>
<p>The continuity is enforced on the control points of q(t), which appear
as nonlinear constraints.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">dᴺrᵤ</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dsᴺ</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">hᵤᴺ</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="n">dᴺrᵥ</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dsᴺ</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">hᵥᴺ</span><span class="w"></span>
</pre></div>
</div>
</details><p>The convex surrogate is simply the path continuity, where hᵤᴺ and hᵥᴺ
are replaced by the characteristic times of the respective sets:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">dᴺrᵤ</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dsᴺ</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">hᵤ₀ᴺ</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="n">dᴺrᵥ</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dsᴺ</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">hᵥ₀ᴺ</span><span class="w"></span>
</pre></div>
</div>
</details><p>. For now, these are set to one, but future work may involve scaling
them by the size of the sets.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">continuity_order</span></code>:</dt><dd><p>is the order of the continuity constraint.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the continuity order is not equal</strong><strong> or </strong><strong>less than the</strong> – </p></li>
<li><p><strong>order of both subgraphs.</strong> – </p></li>
<li><p><strong>RuntimeError if the continuity order is less than one since path</strong> – </p></li>
<li><p><strong>continuity is enforced by default.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.EdgesBetweenSubgraphs.AddNonlinearDerivativeBounds">
<span class="sig-name descname"><span class="pre">AddNonlinearDerivativeBounds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.GcsTrajectoryOptimization.EdgesBetweenSubgraphs" title="pydrake.planning.GcsTrajectoryOptimization.EdgesBetweenSubgraphs"><span class="pre">pydrake.planning.GcsTrajectoryOptimization.EdgesBetweenSubgraphs</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">lb</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ub</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derivative_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.EdgesBetweenSubgraphs.AddNonlinearDerivativeBounds" title="Permalink to this definition"></a></dt>
<dd><p>Adds a nonlinear derivative constraints to the control point
connecting the subgraphs <code class="docutils literal notranslate"><span class="pre">lb</span></code> ≤ dᴺq(t) / dtᴺ ≤ <code class="docutils literal notranslate"><span class="pre">ub</span></code>.</p>
<p>This adds a nonlinear constraint to the restriction and MIP
GraphOfConvexSets::Transcription, while adding a convex surrogate to
the relaxation. For more details, see nonconvex_graph_of_convex_sets
“Guiding Non-convex Optimization with the GraphOfConvexSets”.</p>
<p>The nonlinear constraint involves the derivative dᴺq(t) / dtᴺ which is
decomposed as dᴺr(s) / dsᴺ / hᴺ. The convex surrogate replaces the
nonlinear component hᴺ with h₀ᴺ⁻¹h, where h₀ is the characteristic
time of the set. For now, h₀ is set to 1.0 for all sets.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lb</span></code>:</dt><dd><p>is the lower bound of the derivative.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">ub</span></code>:</dt><dd><p>is the upper bound of the derivative.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code>:</dt><dd><p>is the order of the derivative to be constrained.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if both subgraphs order is less than the desired</strong> – </p></li>
<li><p><strong>derivative order.</strong> – </p></li>
<li><p><strong>RuntimeError if the derivative order &lt;= 1</strong><strong>, </strong><strong>since the linear</strong> – </p></li>
<li><p><strong>velocity bounds are preferred.</strong> – </p></li>
<li><p><strong>RuntimeError if lb</strong><strong> or </strong><strong>ub are not of size num_positions</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.EdgesBetweenSubgraphs.AddPathContinuityConstraints">
<span class="sig-name descname"><span class="pre">AddPathContinuityConstraints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.GcsTrajectoryOptimization.EdgesBetweenSubgraphs" title="pydrake.planning.GcsTrajectoryOptimization.EdgesBetweenSubgraphs"><span class="pre">pydrake.planning.GcsTrajectoryOptimization.EdgesBetweenSubgraphs</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">continuity_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.EdgesBetweenSubgraphs.AddPathContinuityConstraints" title="Permalink to this definition"></a></dt>
<dd><p>Enforces derivative continuity constraints on the edges between the
subgraphs.</p>
<p>Note that the constraints are on the control points of the derivatives
of r(s) and not q(t). This may result in discontinuities of the
trajectory return by <code class="docutils literal notranslate"><span class="pre">SolvePath()</span></code> since the r(s) will get rescaled
by the duration h to yield q(t). <code class="docutils literal notranslate"><span class="pre">NormalizeSegmentTimes()</span></code> will
return r(s) with valid continuity.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">continuity_order</span></code>:</dt><dd><p>is the order of the continuity constraint.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the continuity order is not equal</strong><strong> or </strong><strong>less than the</strong> – </p></li>
<li><p><strong>order of both subgraphs.</strong> – </p></li>
<li><p><strong>RuntimeError if the continuity order is less than one since path</strong> – </p></li>
<li><p><strong>continuity is enforced by default.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.EdgesBetweenSubgraphs.AddVelocityBounds">
<span class="sig-name descname"><span class="pre">AddVelocityBounds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.GcsTrajectoryOptimization.EdgesBetweenSubgraphs" title="pydrake.planning.GcsTrajectoryOptimization.EdgesBetweenSubgraphs"><span class="pre">pydrake.planning.GcsTrajectoryOptimization.EdgesBetweenSubgraphs</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">lb</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ub</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.EdgesBetweenSubgraphs.AddVelocityBounds" title="Permalink to this definition"></a></dt>
<dd><p>Adds a linear velocity constraint to the control point connecting the
subgraphs <code class="docutils literal notranslate"><span class="pre">lb</span></code> ≤ q̇(t) ≤ <code class="docutils literal notranslate"><span class="pre">ub</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lb</span></code>:</dt><dd><p>is the lower bound of the velocity.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">ub</span></code>:</dt><dd><p>is the upper bound of the velocity.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if both subgraphs order is zero</strong><strong>, </strong><strong>since the velocity</strong> – </p></li>
<li><p><strong>is defined as the derivative of the Bézier curve. At least one of</strong> – </p></li>
<li><p><strong>the subgraphs must have an order of at least 1.</strong> – </p></li>
<li><p><strong>RuntimeError if lb</strong><strong> or </strong><strong>ub are not of size num_positions</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.EdgesBetweenSubgraphs.AddZeroDerivativeConstraints">
<span class="sig-name descname"><span class="pre">AddZeroDerivativeConstraints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.GcsTrajectoryOptimization.EdgesBetweenSubgraphs" title="pydrake.planning.GcsTrajectoryOptimization.EdgesBetweenSubgraphs"><span class="pre">pydrake.planning.GcsTrajectoryOptimization.EdgesBetweenSubgraphs</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">derivative_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.EdgesBetweenSubgraphs.AddZeroDerivativeConstraints" title="Permalink to this definition"></a></dt>
<dd><p>Enforces zero derivatives on the control point connecting the
subgraphs.</p>
<p>For velocity, acceleration, jerk, etc. enforcing zero-derivative on
the trajectory q(t) is equivalent to enforcing zero-derivative on the
trajectory r(s). Hence this constraint is convex.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code>:</dt><dd><p>is the order of the derivative to be constrained.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the derivative order &lt; 1.</strong> – </p></li>
<li><p><strong>RuntimeError if both subgraphs order is less than the desired</strong> – </p></li>
<li><p><strong>derivative order.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.EdgesBetweenSubgraphs.Edges">
<span class="sig-name descname"><span class="pre">Edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.GcsTrajectoryOptimization.EdgesBetweenSubgraphs" title="pydrake.planning.GcsTrajectoryOptimization.EdgesBetweenSubgraphs"><span class="pre">pydrake.planning.GcsTrajectoryOptimization.EdgesBetweenSubgraphs</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.geometry.optimization.html#pydrake.geometry.optimization.GraphOfConvexSets.Edge" title="pydrake.geometry.optimization.GraphOfConvexSets.Edge"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Edge</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.EdgesBetweenSubgraphs.Edges" title="Permalink to this definition"></a></dt>
<dd><p>Returns constant reference to a vector of mutable pointers to the
edges.</p>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.GetEdgesBetweenSubgraphs">
<span class="sig-name descname"><span class="pre">GetEdgesBetweenSubgraphs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.GcsTrajectoryOptimization" title="pydrake.planning.GcsTrajectoryOptimization"><span class="pre">pydrake.planning.GcsTrajectoryOptimization</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#pydrake.planning.GcsTrajectoryOptimization.EdgesBetweenSubgraphs" title="pydrake.planning.GcsTrajectoryOptimization.EdgesBetweenSubgraphs"><span class="pre">pydrake.planning.GcsTrajectoryOptimization.EdgesBetweenSubgraphs</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.GetEdgesBetweenSubgraphs" title="Permalink to this definition"></a></dt>
<dd><p>Returns a vector of all edges between subgraphs.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.GetGraphvizString">
<span class="sig-name descname"><span class="pre">GetGraphvizString</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.GetGraphvizString" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetGraphvizString(self: pydrake.planning.GcsTrajectoryOptimization, result: pydrake.solvers.MathematicalProgramResult = None, options: pydrake.geometry.optimization.GcsGraphvizOptions = GcsGraphvizOptions(show_slacks=True, show_vars=True, show_flows=True, show_costs=True, scientific=False, precision=3)) -&gt; str</p></li>
</ol>
<p>Returns a Graphviz string describing the graph vertices and edges. If
<code class="docutils literal notranslate"><span class="pre">result</span></code> is supplied, then the graph will be annotated with the
solution values.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">show_slacks</span></code>:</dt><dd><p>determines whether the values of the intermediate (slack)
variables are also displayed in the graph.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">precision</span></code>:</dt><dd><p>sets the floating point precision (how many digits are generated)
of the annotations.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">scientific</span></code>:</dt><dd><p>sets the floating point formatting to scientific (if true) or
fixed (if false).</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetGraphvizString(self: pydrake.planning.GcsTrajectoryOptimization, result: pydrake.solvers.MathematicalProgramResult = None, show_slacks: bool = True, show_vars: bool = True, show_flows: bool = True, show_costs: bool = True, scientific: bool = False, precision: int = 3) -&gt; str</p></li>
</ol>
<p>Returns a Graphviz string describing the graph vertices and edges. If
<code class="docutils literal notranslate"><span class="pre">result</span></code> is supplied, then the graph will be annotated with the
solution values.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">show_slacks</span></code>:</dt><dd><p>determines whether the values of the intermediate (slack)
variables are also displayed in the graph.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">precision</span></code>:</dt><dd><p>sets the floating point precision (how many digits are generated)
of the annotations.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">scientific</span></code>:</dt><dd><p>sets the floating point formatting to scientific (if true) or
fixed (if false).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.GetSubgraphs">
<span class="sig-name descname"><span class="pre">GetSubgraphs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.GcsTrajectoryOptimization" title="pydrake.planning.GcsTrajectoryOptimization"><span class="pre">pydrake.planning.GcsTrajectoryOptimization</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#pydrake.planning.GcsTrajectoryOptimization.Subgraph" title="pydrake.planning.GcsTrajectoryOptimization.Subgraph"><span class="pre">pydrake.planning.GcsTrajectoryOptimization.Subgraph</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.GetSubgraphs" title="Permalink to this definition"></a></dt>
<dd><p>Returns a vector of all subgraphs.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.graph_of_convex_sets">
<span class="sig-name descname"><span class="pre">graph_of_convex_sets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.GcsTrajectoryOptimization" title="pydrake.planning.GcsTrajectoryOptimization"><span class="pre">pydrake.planning.GcsTrajectoryOptimization</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.optimization.html#pydrake.geometry.optimization.GraphOfConvexSets" title="pydrake.geometry.optimization.GraphOfConvexSets"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets</span></a></span></span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.graph_of_convex_sets" title="Permalink to this definition"></a></dt>
<dd><p>Getter for the underlying GraphOfConvexSets. This is intended
primarily for inspecting the resulting programs.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.NormalizeSegmentTimes">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">NormalizeSegmentTimes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectory</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.trajectories.html#pydrake.trajectories.CompositeTrajectory" title="pydrake.trajectories.CompositeTrajectory"><span class="pre">pydrake.trajectories.CompositeTrajectory</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.trajectories.html#pydrake.trajectories.CompositeTrajectory" title="pydrake.trajectories.CompositeTrajectory"><span class="pre">pydrake.trajectories.CompositeTrajectory</span></a></span></span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.NormalizeSegmentTimes" title="Permalink to this definition"></a></dt>
<dd><p>Normalizes each trajectory segment to one second in duration.
Reconstructs the path r(s) from the solution trajectory q(t) of
<code class="docutils literal notranslate"><span class="pre">SolvePath()</span></code> s.t. each segment of the resulting trajectory will be
one second long. The start time will match the original start time.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">trajectory</span></code>:</dt><dd><p>The solution trajectory returned by <code class="docutils literal notranslate"><span class="pre">SolvePath()</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if not all trajectory segments of the</strong> – </p></li>
<li><p><strong>CompositeTrajectory are of type BezierCurve&lt;double&gt;</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.num_positions">
<span class="sig-name descname"><span class="pre">num_positions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.GcsTrajectoryOptimization" title="pydrake.planning.GcsTrajectoryOptimization"><span class="pre">pydrake.planning.GcsTrajectoryOptimization</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.num_positions" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of position variables.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.RemoveSubgraph">
<span class="sig-name descname"><span class="pre">RemoveSubgraph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.GcsTrajectoryOptimization" title="pydrake.planning.GcsTrajectoryOptimization"><span class="pre">pydrake.planning.GcsTrajectoryOptimization</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">subgraph</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.GcsTrajectoryOptimization.Subgraph" title="pydrake.planning.GcsTrajectoryOptimization.Subgraph"><span class="pre">pydrake.planning.GcsTrajectoryOptimization.Subgraph</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.RemoveSubgraph" title="Permalink to this definition"></a></dt>
<dd><p>Remove a subgraph and all associated edges found in the subgraph and
to and from other subgraphs.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>The subgraph must have been created from a call to AddRegions() on
this object.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.SolveConvexRestriction">
<span class="sig-name descname"><span class="pre">SolveConvexRestriction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">self:</span> <span class="pre">pydrake.planning.GcsTrajectoryOptimization,</span> <span class="pre">active_vertices:</span> <span class="pre">list[pydrake.geometry.optimization.GraphOfConvexSets.Vertex],</span> <span class="pre">options:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSetsOptions</span> <span class="pre">=</span> <span class="pre">GraphOfConvexSetsOptions(convex_relaxation=None,</span> <span class="pre">preprocessing=None,</span> <span class="pre">max_rounded_paths=None,</span> <span class="pre">max_rounding_trials=100,</span> <span class="pre">flow_tolerance=1e-05,</span> <span class="pre">rounding_seed=0,</span> <span class="pre">solver=None,</span> <span class="pre">restriction_solver=None,</span> <span class="pre">preprocessing_solver=None,</span> <span class="pre">solver_options=&lt;SolverOptions&gt;,</span> <span class="pre">restriction_solver_options=None,</span> <span class="pre">preprocessing_solver_options=None,</span> <span class="pre">)</span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.trajectories.html#pydrake.trajectories.CompositeTrajectory" title="pydrake.trajectories.CompositeTrajectory"><span class="pre">pydrake.trajectories.CompositeTrajectory</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.MathematicalProgramResult" title="pydrake.solvers.MathematicalProgramResult"><span class="pre">pydrake.solvers.MathematicalProgramResult</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.SolveConvexRestriction" title="Permalink to this definition"></a></dt>
<dd><p>Solves a trajectory optimization problem through specific vertices.</p>
<p>This method allows for targeted optimization by considering only
selected active vertices, reducing the problem’s complexity. See
geometry::optimization::GraphOfConvexSets::SolveConvexRestriction().
This API prefers a sequence of vertices over edges, as a user may know
which regions the solution should pass through.
GcsTrajectoryOptimization::AddRegions() automatically manages edge
creation and intersection checks, which makes passing a sequence of
edges less convenient.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">active_vertices</span></code>:</dt><dd><p>A sequence of ordered vertices of subgraphs to be included in the
problem.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">options</span></code>:</dt><dd><p>include all settings for solving the shortest path problem.</p>
</dd>
<dt>Precondition:</dt><dd><p>There must be at least two vertices in active_vertices.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the vertices are not connected.</strong> – </p></li>
<li><p><strong>RuntimeError if two vertices are connected by multiple edges. This</strong> – </p></li>
<li><p><strong>may happen if one connects two graphs through multiple subspaces</strong><strong>,</strong> – </p></li>
<li><p><strong>which is currently not supported with this method.</strong> – </p></li>
<li><p><strong>RuntimeError if the program cannot be written as a convex</strong> – </p></li>
<li><p><strong>optimization consumable by one of the standard solvers.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.SolvePath">
<span class="sig-name descname"><span class="pre">SolvePath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self:</span> <span class="pre">pydrake.planning.GcsTrajectoryOptimization</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source:</span> <span class="pre">pydrake.planning.GcsTrajectoryOptimization.Subgraph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target:</span> <span class="pre">pydrake.planning.GcsTrajectoryOptimization.Subgraph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options:</span> <span class="pre">pydrake.geometry.optimization.GraphOfConvexSetsOptions</span> <span class="pre">=</span> <span class="pre">GraphOfConvexSetsOptions(convex_relaxation=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preprocessing=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_rounded_paths=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_rounding_trials=100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flow_tolerance=1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rounding_seed=0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">restriction_solver=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preprocessing_solver=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver_options=&lt;SolverOptions&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">restriction_solver_options=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preprocessing_solver_options=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">)</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.trajectories.html#pydrake.trajectories.CompositeTrajectory" title="pydrake.trajectories.CompositeTrajectory"><span class="pre">pydrake.trajectories.CompositeTrajectory</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.MathematicalProgramResult" title="pydrake.solvers.MathematicalProgramResult"><span class="pre">pydrake.solvers.MathematicalProgramResult</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.SolvePath" title="Permalink to this definition"></a></dt>
<dd><p>Formulates and solves the mixed-integer convex formulation of the
shortest path problem on the whole graph.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="docutils literal notranslate"><span class="pre">geometry::optimization::GraphOfConvexSets::SolveShortestPath()</span></code>
for further details.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">source</span></code>:</dt><dd><p>specifies the source subgraph. Must have been created from a call
to AddRegions() on this object, not some other optimization
program. If the source is a subgraph with more than one region, an
empty set will be added and optimizer will choose the best region
to start in. To start in a particular point, consider adding a
subgraph of order zero with a single region of type Point.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">target</span></code>:</dt><dd><p>specifies the target subgraph. Must have been created from a call
to AddRegions() on this object, not some other optimization
program. If the target is a subgraph with more than one region, an
empty set will be added and optimizer will choose the best region
to end in. To end in a particular point, consider adding a
subgraph of order zero with a single region of type Point.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">options</span></code>:</dt><dd><p>include all settings for solving the shortest path problem. The
following default options will be used if they are not provided in
<code class="docutils literal notranslate"><span class="pre">options</span></code>: - <cite>options.convex_relaxation = true</cite>, -
<code class="docutils literal notranslate"><span class="pre">options.max_rounded_paths</span> <span class="pre">=</span> <span class="pre">5</span></code>, - <cite>options.preprocessing =
true</cite>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="docutils literal notranslate"><span class="pre">geometry::optimization::GraphOfConvexSetsOptions</span></code> for further
details.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.Subgraph">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Subgraph</span></span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.Subgraph" title="Permalink to this definition"></a></dt>
<dd><p>A Subgraph is a subset of the larger graph. It is defined by a set of
regions and edges between them based on intersection. From an API
standpoint, a Subgraph is useful to define a multi-modal motion
planning problem. Further, it allows different constraints and objects
to be added to different subgraphs. Note that the the
GraphOfConvexSets does not differentiate between subgraphs and can’t
be mixed with other instances of GcsTrajectoryOptimization.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.Subgraph.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.Subgraph.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.Subgraph.AddContinuityConstraints">
<span class="sig-name descname"><span class="pre">AddContinuityConstraints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.GcsTrajectoryOptimization.Subgraph" title="pydrake.planning.GcsTrajectoryOptimization.Subgraph"><span class="pre">pydrake.planning.GcsTrajectoryOptimization.Subgraph</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">continuity_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.Subgraph.AddContinuityConstraints" title="Permalink to this definition"></a></dt>
<dd><p>Enforces derivative continuity constraints on the subgraph.</p>
<p>This adds a nonlinear constraint to the restriction and MIP
GraphOfConvexSets::Transcription, while adding a convex surrogate to
the relaxation. For more details, see nonconvex_graph_of_convex_sets
“Guiding Non-convex Optimization with the GraphOfConvexSets”.</p>
<p>The continuity is enforced on the control points of q(t), which appear
as nonlinear constraints.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">dᴺrᵤ</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dsᴺ</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">hᵤᴺ</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="n">dᴺrᵥ</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dsᴺ</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">hᵥᴺ</span><span class="w"></span>
</pre></div>
</div>
</details><p>The convex surrogate is simply the path continuity, where hᵤᴺ and hᵥᴺ
are replaced by the characteristic times of the respective sets:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">dᴺrᵤ</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dsᴺ</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">hᵤ₀ᴺ</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="p">(</span><span class="n">dᴺrᵥ</span><span class="p">(</span><span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">dsᴺ</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">hᵥ₀ᴺ</span><span class="w"></span>
</pre></div>
</div>
</details><p>. For now, these are set to one, but future work may involve scaling
them by the size of the sets.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">continuity_order</span></code>:</dt><dd><p>is the order of the continuity constraint.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the continuity order is not equal</strong><strong> or </strong><strong>less than the</strong> – </p></li>
<li><p><strong>order the subgraphs.</strong> – </p></li>
<li><p><strong>RuntimeError if the continuity order is less than one since path</strong> – </p></li>
<li><p><strong>continuity is enforced by default.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.Subgraph.AddNonlinearDerivativeBounds">
<span class="sig-name descname"><span class="pre">AddNonlinearDerivativeBounds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.GcsTrajectoryOptimization.Subgraph" title="pydrake.planning.GcsTrajectoryOptimization.Subgraph"><span class="pre">pydrake.planning.GcsTrajectoryOptimization.Subgraph</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">lb</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ub</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derivative_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.Subgraph.AddNonlinearDerivativeBounds" title="Permalink to this definition"></a></dt>
<dd><p>Adds a nonlinear derivative constraints to the subgraph <code class="docutils literal notranslate"><span class="pre">lb</span></code> ≤
dᴺq(t) / dtᴺ ≤ <code class="docutils literal notranslate"><span class="pre">ub</span></code>.</p>
<p>This adds a nonlinear constraint to the restriction and MIP
GraphOfConvexSets::Transcription, while adding a convex surrogate to
the relaxation. For more details, see nonconvex_graph_of_convex_sets
“Guiding Non-convex Optimization with the GraphOfConvexSets”.</p>
<p>The nonlinear constraint involves the derivative dᴺq(t) / dtᴺ which is
decomposed as dᴺr(s) / dsᴺ / hᴺ. The convex surrogate replaces the
nonlinear component hᴺ with h₀ᴺ⁻¹h, where h₀ is the characteristic
time of the set. For now, h₀ is set to 1.0 for all sets.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lb</span></code>:</dt><dd><p>is the lower bound of the derivative.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">ub</span></code>:</dt><dd><p>is the upper bound of the derivative.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code>:</dt><dd><p>is the order of the derivative to be constrained.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if subgraph order is less than the derivative order.</strong> – </p></li>
<li><p><strong>RuntimeError if the derivative order &lt;= 1</strong><strong>, </strong><strong>since the linear</strong> – </p></li>
<li><p><strong>velocity bounds are preferred.</strong> – </p></li>
<li><p><strong>RuntimeError if lb</strong><strong> or </strong><strong>ub are not of size num_positions</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.Subgraph.AddPathContinuityConstraints">
<span class="sig-name descname"><span class="pre">AddPathContinuityConstraints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.GcsTrajectoryOptimization.Subgraph" title="pydrake.planning.GcsTrajectoryOptimization.Subgraph"><span class="pre">pydrake.planning.GcsTrajectoryOptimization.Subgraph</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">continuity_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.Subgraph.AddPathContinuityConstraints" title="Permalink to this definition"></a></dt>
<dd><p>Enforces derivative continuity constraints on the subgraph.</p>
<p>Note that the constraints are on the control points of the derivatives
of r(s) and not q(t). This may result in discontinuities of the
trajectory return by <code class="docutils literal notranslate"><span class="pre">SolvePath()</span></code> since the r(s) will get rescaled
by the duration h to yield q(t). <code class="docutils literal notranslate"><span class="pre">NormalizeSegmentTimes()</span></code> will
return r(s) with valid continuity.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">continuity_order</span></code>:</dt><dd><p>is the order of the continuity constraint.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the continuity order is not equal</strong><strong> or </strong><strong>less than the</strong> – </p></li>
<li><p><strong>order the subgraphs.</strong> – </p></li>
<li><p><strong>RuntimeError if the continuity order is less than one since path</strong> – </p></li>
<li><p><strong>continuity is enforced by default.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.Subgraph.AddPathEnergyCost">
<span class="sig-name descname"><span class="pre">AddPathEnergyCost</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.Subgraph.AddPathEnergyCost" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddPathEnergyCost(self: pydrake.planning.GcsTrajectoryOptimization.Subgraph, weight_matrix: numpy.ndarray[numpy.float64[m, n]]) -&gt; None</p></li>
</ol>
<p>Similar to AddPathLengthCost in usage, but minimizes ∑ <a href="#id15"><span class="problematic" id="id16">|</span></a>weight_matrix
* (rᵢ₊₁ − rᵢ)|₂². In comparison to AddPathLength cost, this cost
encourages control points to be evenly spaced but may result in
greater number of regions and larger path length on the solution. It
is recommended to use this cost only with SolveConvexRestriction when
it becomes a quadratic cost for which some solvers show a better
performance.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">weight_matrix</span></code>:</dt><dd><p>is the relative weight of each component for the cost. The
diagonal of the matrix is the weight for each dimension. The
off-diagonal elements are the weight for the cross terms, which
can be used to penalize diagonal movement.</p>
</dd>
<dt>Precondition:</dt><dd><p>weight_matrix must be of size num_positions() x num_positions().</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>AddPathEnergyCost(self: pydrake.planning.GcsTrajectoryOptimization.Subgraph, weight: float = 1.0) -&gt; None</p></li>
</ol>
<p>Similar to AddPathLengthCost in usage, but minimizes ∑ <a href="#id17"><span class="problematic" id="id18">|</span></a>(rᵢ₊₁ − rᵢ)|₂²
with weight being applied uniformly to all dimensions. In comparison
to AddPathLength cost, this cost encourages control points to be
evenly spaced but may result in greater number of regions and larger
path length on the solution. It is recommended to use this cost only
with SolveConvexRestriction when it becomes a quadratic cost for which
some solvers show a better performance.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">weight</span></code>:</dt><dd><p>is the relative weight of the cost.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.Subgraph.AddPathLengthCost">
<span class="sig-name descname"><span class="pre">AddPathLengthCost</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.Subgraph.AddPathLengthCost" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddPathLengthCost(self: pydrake.planning.GcsTrajectoryOptimization.Subgraph, weight_matrix: numpy.ndarray[numpy.float64[m, n]]) -&gt; None</p></li>
</ol>
<p>Adds multiple L2Norm Costs on the upper bound of the path length.
Since we cannot directly compute the path length of a Bézier curve, we
minimize the upper bound of the path integral by minimizing the sum of
distances between control points. For Bézier curves, this is
equivalent to the sum of the L2Norm of the derivative control points
of the curve divided by the order.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">weight_matrix</span></code>:</dt><dd><p>is the relative weight of each component for the cost. The
diagonal of the matrix is the weight for each dimension. The
off-diagonal elements are the weight for the cross terms, which
can be used to penalize diagonal movement.</p>
</dd>
<dt>Precondition:</dt><dd><p>weight_matrix must be of size num_positions() x num_positions().</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>AddPathLengthCost(self: pydrake.planning.GcsTrajectoryOptimization.Subgraph, weight: float = 1.0) -&gt; None</p></li>
</ol>
<p>Adds multiple L2Norm Costs on the upper bound of the path length. We
upper bound the trajectory length by the sum of the distances between
control points. For Bézier curves, this is equivalent to the sum of
the L2Norm of the derivative control points of the curve divided by
the order.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">weight</span></code>:</dt><dd><p>is the relative weight of the cost.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.Subgraph.AddTimeCost">
<span class="sig-name descname"><span class="pre">AddTimeCost</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.GcsTrajectoryOptimization.Subgraph" title="pydrake.planning.GcsTrajectoryOptimization.Subgraph"><span class="pre">pydrake.planning.GcsTrajectoryOptimization.Subgraph</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.Subgraph.AddTimeCost" title="Permalink to this definition"></a></dt>
<dd><p>Adds a minimum time cost to all regions in the subgraph. The cost is
the sum of the time scaling variables.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">weight</span></code>:</dt><dd><p>is the relative weight of the cost.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.Subgraph.AddVelocityBounds">
<span class="sig-name descname"><span class="pre">AddVelocityBounds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.GcsTrajectoryOptimization.Subgraph" title="pydrake.planning.GcsTrajectoryOptimization.Subgraph"><span class="pre">pydrake.planning.GcsTrajectoryOptimization.Subgraph</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">lb</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ub</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.Subgraph.AddVelocityBounds" title="Permalink to this definition"></a></dt>
<dd><p>Adds a linear velocity constraint to the subgraph <code class="docutils literal notranslate"><span class="pre">lb</span></code> ≤ q̇(t) ≤
<code class="docutils literal notranslate"><span class="pre">ub</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lb</span></code>:</dt><dd><p>is the lower bound of the velocity.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">ub</span></code>:</dt><dd><p>is the upper bound of the velocity.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if subgraph order is zero</strong><strong>, </strong><strong>since the velocity is</strong> – </p></li>
<li><p><strong>defined as the derivative of the Bézier curve.</strong> – </p></li>
<li><p><strong>RuntimeError if lb</strong><strong> or </strong><strong>ub are not of size num_positions</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.Subgraph.Edges">
<span class="sig-name descname"><span class="pre">Edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.GcsTrajectoryOptimization.Subgraph" title="pydrake.planning.GcsTrajectoryOptimization.Subgraph"><span class="pre">pydrake.planning.GcsTrajectoryOptimization.Subgraph</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.geometry.optimization.html#pydrake.geometry.optimization.GraphOfConvexSets.Edge" title="pydrake.geometry.optimization.GraphOfConvexSets.Edge"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Edge</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.Subgraph.Edges" title="Permalink to this definition"></a></dt>
<dd><p>Returns constant reference to a vector of mutable pointers to the
edges.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.Subgraph.name">
<span class="sig-name descname"><span class="pre">name</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.GcsTrajectoryOptimization.Subgraph" title="pydrake.planning.GcsTrajectoryOptimization.Subgraph"><span class="pre">pydrake.planning.GcsTrajectoryOptimization.Subgraph</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.Subgraph.name" title="Permalink to this definition"></a></dt>
<dd><p>Returns the name of the subgraph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.Subgraph.order">
<span class="sig-name descname"><span class="pre">order</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.GcsTrajectoryOptimization.Subgraph" title="pydrake.planning.GcsTrajectoryOptimization.Subgraph"><span class="pre">pydrake.planning.GcsTrajectoryOptimization.Subgraph</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.Subgraph.order" title="Permalink to this definition"></a></dt>
<dd><p>Returns the order of the Bézier trajectory within the region.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.Subgraph.regions">
<span class="sig-name descname"><span class="pre">regions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.GcsTrajectoryOptimization.Subgraph" title="pydrake.planning.GcsTrajectoryOptimization.Subgraph"><span class="pre">pydrake.planning.GcsTrajectoryOptimization.Subgraph</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">object</span></span></span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.Subgraph.regions" title="Permalink to this definition"></a></dt>
<dd><p>Returns the regions associated with this subgraph before the
CartesianProduct.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.Subgraph.size">
<span class="sig-name descname"><span class="pre">size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.GcsTrajectoryOptimization.Subgraph" title="pydrake.planning.GcsTrajectoryOptimization.Subgraph"><span class="pre">pydrake.planning.GcsTrajectoryOptimization.Subgraph</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.Subgraph.size" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of vertices in the subgraph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.Subgraph.Vertices">
<span class="sig-name descname"><span class="pre">Vertices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.GcsTrajectoryOptimization.Subgraph" title="pydrake.planning.GcsTrajectoryOptimization.Subgraph"><span class="pre">pydrake.planning.GcsTrajectoryOptimization.Subgraph</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.geometry.optimization.html#pydrake.geometry.optimization.GraphOfConvexSets.Vertex" title="pydrake.geometry.optimization.GraphOfConvexSets.Vertex"><span class="pre">pydrake.geometry.optimization.GraphOfConvexSets.Vertex</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.Subgraph.Vertices" title="Permalink to this definition"></a></dt>
<dd><p>Returns constant reference to a vector of mutable pointers to the
vertices stored in the subgraph. The order of the vertices is the same
as the order the regions were added.</p>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.GcsTrajectoryOptimization.UnwrapToContinousTrajectory">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">UnwrapToContinousTrajectory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gcs_trajectory</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.trajectories.html#pydrake.trajectories.CompositeTrajectory" title="pydrake.trajectories.CompositeTrajectory"><span class="pre">pydrake.trajectories.CompositeTrajectory</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">continuous_revolute_joints</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">starting_rounds</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-08</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.trajectories.html#pydrake.trajectories.CompositeTrajectory" title="pydrake.trajectories.CompositeTrajectory"><span class="pre">pydrake.trajectories.CompositeTrajectory</span></a></span></span><a class="headerlink" href="#pydrake.planning.GcsTrajectoryOptimization.UnwrapToContinousTrajectory" title="Permalink to this definition"></a></dt>
<dd><p>Unwraps a trajectory with continuous revolute joints into a continuous
trajectory in the Euclidean space. Trajectories produced by
GcsTrajectoryOptimization for robotic systems with continuous revolute
joints may include apparent discontinuities, where a multiple of 2π is
instantaneously added to a joint value at the boundary between two
adjacent segments of the trajectory. This function removes such
discontinuities by adding or subtracting the appropriate multiple of
2π, “unwrapping” the trajectory into a continuous representation
suitable for downstream tasks that do not take the joint wraparound
into account.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">gcs_trajectory</span></code>:</dt><dd><p>The trajectory to unwrap.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">continuous_revolute_joints</span></code>:</dt><dd><p>The indices of the continuous revolute joints.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">tol</span></code>:</dt><dd><p>The numerical tolerance used to determine if two subsequent
segments start and end at the same value modulo 2π for continuous
revolute joints.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">starting_rounds</span></code>:</dt><dd><p>A vector of integers that sets the starting rounds for each
continuous revolute joint. Given integer k for the starting_round
of a joint, its initial position will be wrapped into [2πk ,
2π(k+1)). If the starting rounds are not provided, the initial
position of <code class="docutils literal notranslate"><span class="pre">trajectory</span></code> will be unchanged.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>an unwrapped (continous in Euclidean space) CompositeTrajectory.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if</strong> – </p></li>
<li><p><strong>starting_rounds.size</strong><strong>(</strong><strong>)</strong><strong>!=continuous_revolute_joints.size</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
<li><p><strong>RuntimeError if continuous_revolute_joints contain repeated</strong> – </p></li>
<li><p><strong>indices and/or indices outside the range</strong><strong> [</strong><strong>0</strong><strong>,</strong> – </p></li>
<li><p><strong>gcs_trajectory.rows</strong><strong>(</strong><strong>)</strong><strong>)</strong><strong></strong> – </p></li>
<li><p><strong>RuntimeError if the gcs_trajectory is not continuous on the</strong> – </p></li>
<li><p><strong>manifold defined by the continuous_revolute_joints</strong><strong>, </strong><strong>i.e.</strong><strong>, </strong><strong>the</strong> – </p></li>
<li><p><strong>shift between two consecutive segments is not an integer multiple</strong> – </p></li>
<li><p><strong>of 2π</strong><strong> (</strong><strong>within a tolerance of tol radians</strong><strong>)</strong><strong></strong> – </p></li>
<li><p><strong>RuntimeError if all the segments are not of type BezierCurve.</strong> – </p></li>
<li><p><strong>Other types are not supported yet. Note that currently the output</strong> – </p></li>
<li><p><strong>of GcsTrajectoryOptimization::SolvePath</strong><strong>(</strong><strong>) </strong><strong>is a CompositeTrajectory</strong> – </p></li>
<li><p><strong>of BezierCurves.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.planning.GetContinuousRevoluteJointIndices">
<span class="sig-prename descclassname"><span class="pre">pydrake.planning.</span></span><span class="sig-name descname"><span class="pre">GetContinuousRevoluteJointIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">plant</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.plant.html#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.GetContinuousRevoluteJointIndices" title="Permalink to this definition"></a></dt>
<dd><p>Returns a list of indices in the plant’s generalized positions which
correspond to a continuous revolute joint (a revolute joint with no
joint limits). This includes the revolute component of PlanarJoint and
RpyFloatingJoint.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.planning.IrisFromCliqueCoverOptions">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.planning.</span></span><span class="sig-name descname"><span class="pre">IrisFromCliqueCoverOptions</span></span><a class="headerlink" href="#pydrake.planning.IrisFromCliqueCoverOptions" title="Permalink to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.IrisFromCliqueCoverOptions.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.IrisFromCliqueCoverOptions" title="pydrake.planning.IrisFromCliqueCoverOptions"><span class="pre">pydrake.planning.IrisFromCliqueCoverOptions</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.IrisFromCliqueCoverOptions.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.planning.IrisFromCliqueCoverOptions.coverage_termination_threshold">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">coverage_termination_threshold</span></span><a class="headerlink" href="#pydrake.planning.IrisFromCliqueCoverOptions.coverage_termination_threshold" title="Permalink to this definition"></a></dt>
<dd><p>The fraction of the domain that must be covered before we terminate
the algorithm.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.planning.IrisFromCliqueCoverOptions.iris_options">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">iris_options</span></span><a class="headerlink" href="#pydrake.planning.IrisFromCliqueCoverOptions.iris_options" title="Permalink to this definition"></a></dt>
<dd><p>The options used on internal calls to Iris. Currently, it is
recommended to only run Iris for one iteration when building from a
clique so as to avoid discarding the information gained from the
clique.</p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">IrisOptions</span></code> can optionally include a meshcat instance to
provide debugging visualization. If this is provided
<code class="docutils literal notranslate"><span class="pre">IrisFromCliqueCover</span></code> will provide debug visualization in meshcat
showing where in configuration space it is drawing from. However, if
the parallelism option is set to allow more than 1 thread, then the
debug visualizations of internal Iris calls will be disabled. This is
due to a limitation of drawing to meshcat from outside the main
thread.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.planning.IrisFromCliqueCoverOptions.iteration_limit">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">iteration_limit</span></span><a class="headerlink" href="#pydrake.planning.IrisFromCliqueCoverOptions.iteration_limit" title="Permalink to this definition"></a></dt>
<dd><p>The maximum number of iterations of the algorithm.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.planning.IrisFromCliqueCoverOptions.minimum_clique_size">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">minimum_clique_size</span></span><a class="headerlink" href="#pydrake.planning.IrisFromCliqueCoverOptions.minimum_clique_size" title="Permalink to this definition"></a></dt>
<dd><p>The minimum size of the cliques used to construct a region. If this is
set lower than the ambient dimension of the space we are trying to
cover, then this option will be overridden to be at least 1 + the
ambient dimension.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.planning.IrisFromCliqueCoverOptions.num_points_per_coverage_check">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">num_points_per_coverage_check</span></span><a class="headerlink" href="#pydrake.planning.IrisFromCliqueCoverOptions.num_points_per_coverage_check" title="Permalink to this definition"></a></dt>
<dd><p>The number of points to sample when testing coverage.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.planning.IrisFromCliqueCoverOptions.num_points_per_visibility_round">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">num_points_per_visibility_round</span></span><a class="headerlink" href="#pydrake.planning.IrisFromCliqueCoverOptions.num_points_per_visibility_round" title="Permalink to this definition"></a></dt>
<dd><p>Number of points to sample when building visibilty cliques. If this
option is less than twice the minimum clique size, it will be
overridden to be at least twice the minimum clique size. If the
algorithm ever fails to find a single clique in a visibility round,
then the number of points in a visibility round will be doubled.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.planning.IrisFromCliqueCoverOptions.parallelism">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">parallelism</span></span><a class="headerlink" href="#pydrake.planning.IrisFromCliqueCoverOptions.parallelism" title="Permalink to this definition"></a></dt>
<dd><p>The amount of parallelism to use. This algorithm makes heavy use of
parallelism at many points and thus it is highly recommended to set
this to the maximum tolerable parallelism.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.planning.IrisFromCliqueCoverOptions.point_in_set_tol">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">point_in_set_tol</span></span><a class="headerlink" href="#pydrake.planning.IrisFromCliqueCoverOptions.point_in_set_tol" title="Permalink to this definition"></a></dt>
<dd><p>The tolerance used for checking whether a point is contained inside an
HPolyhedron. See &#64;ConvexSet::PointInSet.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.planning.IrisFromCliqueCoverOptions.rank_tol_for_minimum_volume_circumscribed_ellipsoid">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rank_tol_for_minimum_volume_circumscribed_ellipsoid</span></span><a class="headerlink" href="#pydrake.planning.IrisFromCliqueCoverOptions.rank_tol_for_minimum_volume_circumscribed_ellipsoid" title="Permalink to this definition"></a></dt>
<dd><p>The rank tolerance used for computing the
MinimumVolumeCircumscribedEllipsoid of a clique. See
&#64;MinimumVolumeCircumscribedEllipsoid.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.planning.IrisInConfigurationSpaceFromCliqueCover">
<span class="sig-prename descclassname"><span class="pre">pydrake.planning.</span></span><span class="sig-name descname"><span class="pre">IrisInConfigurationSpaceFromCliqueCover</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">checker</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.IrisFromCliqueCoverOptions" title="pydrake.planning.IrisFromCliqueCoverOptions"><span class="pre">pydrake.planning.IrisFromCliqueCoverOptions</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">generator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.common.html#pydrake.common.RandomGenerator" title="pydrake.common.RandomGenerator"><span class="pre">pydrake.common.RandomGenerator</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">sets</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.geometry.optimization.html#pydrake.geometry.optimization.HPolyhedron" title="pydrake.geometry.optimization.HPolyhedron"><span class="pre">pydrake.geometry.optimization.HPolyhedron</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_clique_solver</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.MaxCliqueSolverBase" title="pydrake.planning.MaxCliqueSolverBase"><span class="pre">pydrake.planning.MaxCliqueSolverBase</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.geometry.optimization.html#pydrake.geometry.optimization.HPolyhedron" title="pydrake.geometry.optimization.HPolyhedron"><span class="pre">pydrake.geometry.optimization.HPolyhedron</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.IrisInConfigurationSpaceFromCliqueCover" title="Permalink to this definition"></a></dt>
<dd><p>Cover the configuration space in Iris regions using the Visibility
Clique Cover Algorithm as described in</p>
<p>P. Werner, A. Amice, T. Marcucci, D. Rus, R. Tedrake “Approximating
Robot Configuration Spaces with few Convex Sets using Clique Covers of
Visibility Graphs” In 2024 IEEE Internation Conference on Robotics and
Automation. <a class="reference external" href="https://arxiv.org/abs/2310.02875">https://arxiv.org/abs/2310.02875</a></p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">checker</span></code>:</dt><dd><p>The collision checker containing the plant and its associated
scene_graph.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">generator</span></code>:</dt><dd><p>There are points in the algorithm requiring randomness. The
generator controls this source of randomness.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">sets</span></code>:</dt><dd><p>[in/out] initial sets covering the space (potentially empty). The
cover is written into this vector.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">max_clique_solver</span></code>:</dt><dd><p>The min clique cover problem is approximatley solved by repeatedly
solving max clique on the uncovered graph and adding this largest
clique to the cover. The max clique problem is solved by this
solver. If parallelism is set to allow more than 1 thread, then
the solver <strong>must</strong> be implemented in C++.</p>
</dd>
</dl>
<p>If nullptr is passed as the <code class="docutils literal notranslate"><span class="pre">max_clique_solver</span></code>, then max clique
will be solved using an instance of MaxCliqueSolverViaGreedy, which is
a fast heuristic. If higher quality cliques are desired, consider
changing the solver to an instance of MaxCliqueSolverViaMip.
Currently, the padding in the collision checker is not forwarded to
the algorithm, and therefore the final regions do not necessarily
respect this padding. Effectively, this means that the regions are
generated as if the padding is set to 0. This behavior may be adjusted
in the future at the resolution of #18830.</p>
<p>Note that MaxCliqueSolverViaMip requires the availability of a
Mixed-Integer Linear Programming solver (e.g. Gurobi and/or Mosek). We
recommend enabling those solvers if possible because they produce
higher quality cliques
(<a class="reference external" href="https://drake.mit.edu/bazel.html#proprietary_solvers">https://drake.mit.edu/bazel.html#proprietary_solvers</a>). The method
will throw if <code class="docutils literal notranslate"><span class="pre">max_clique_solver</span></code> cannot solve the max clique
problem.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.planning.KinematicTrajectoryOptimization">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.planning.</span></span><span class="sig-name descname"><span class="pre">KinematicTrajectoryOptimization</span></span><a class="headerlink" href="#pydrake.planning.KinematicTrajectoryOptimization" title="Permalink to this definition"></a></dt>
<dd><p>Optimizes a trajectory, q(t) subject to costs and constraints on the
trajectory and its derivatives. This is accomplished using a <code class="docutils literal notranslate"><span class="pre">path</span></code>,
r(s), represented as a BsplineTrajectory on the interval s∈[0,1], and
a separate duration, T, which maps [0,1] =&gt; [0,T].</p>
<p>The q(t) trajectory is commonly associated with, for instance, the
generalized positions of a MultibodyPlant by adding multibody costs
and constraints; in this case take note that the velocities in this
optimization are q̇(t), not v(t).</p>
<p>Use solvers::Solve to solve the problem. A typical use case could look
like:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">KinematicTrajectoryOptimization</span><span class="w"> </span><span class="nf">trajopt</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span><span class="w"></span>
<span class="c1">// add costs and constraints</span>
<span class="n">trajopt</span><span class="p">.</span><span class="n">SetInitialGuess</span><span class="p">(...);</span><span class="w"></span>
<span class="k">auto</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">solvers</span><span class="o">::</span><span class="n">Solve</span><span class="p">(</span><span class="n">trajopt</span><span class="p">.</span><span class="n">prog</span><span class="p">());</span><span class="w"></span>
<span class="k">auto</span><span class="w"> </span><span class="n">traj</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">trajopt</span><span class="p">.</span><span class="n">ReconstructTrajectory</span><span class="p">(</span><span class="n">result</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</details><p>When possible this class attempts to formulate convex forms of the
costs and constraints.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.KinematicTrajectoryOptimization.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.planning.KinematicTrajectoryOptimization.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.planning.KinematicTrajectoryOptimization, num_positions: int, num_control_points: int, spline_order: int = 4, duration: float = 1.0) -&gt; None</p></li>
</ol>
<p>Constructs an optimization problem for a position trajectory
represented as a B-spline. The initial guess is the zero trajectory
over the time interval [0, T].</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_positions</span></code>:</dt><dd><p>The number of rows in the B-spline.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_control_points</span></code>:</dt><dd><p>The number of B-spline control points.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">spline_order</span></code>:</dt><dd><p>The order of the B-spline.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">duration</span></code>:</dt><dd><p>The duration (in seconds) of the initial guess.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.planning.KinematicTrajectoryOptimization, trajectory: pydrake.trajectories.BsplineTrajectory) -&gt; None</p></li>
</ol>
<p>Constructs an optimization problem for a trajectory represented by a
B-spline with the same order and number of control points as
<code class="docutils literal notranslate"><span class="pre">trajectory</span></code>. Additionally sets <code class="docutils literal notranslate"><span class="pre">trajectory</span></code> as the initial guess
for the optimization.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.KinematicTrajectoryOptimization.AddAccelerationBounds">
<span class="sig-name descname"><span class="pre">AddAccelerationBounds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.KinematicTrajectoryOptimization" title="pydrake.planning.KinematicTrajectoryOptimization"><span class="pre">pydrake.planning.KinematicTrajectoryOptimization</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">lb</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ub</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.Binding" title="pydrake.solvers.Binding"><span class="pre">pydrake.solvers.Binding</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Constraint</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.KinematicTrajectoryOptimization.AddAccelerationBounds" title="Permalink to this definition"></a></dt>
<dd><p>Adds generic (nonlinear) constraints to enforce the upper and lower
bounds to the acceleration trajectory, q̈(t). These constraints will
be respected at all times. Note that this does NOT directly constrain
r̈(s).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A vector of bindings with the ith element is itself a vector of
constraints (one per dof) adding a constraint to the ith control
point of the acceleration trajectory.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.KinematicTrajectoryOptimization.AddDurationConstraint">
<span class="sig-name descname"><span class="pre">AddDurationConstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.KinematicTrajectoryOptimization" title="pydrake.planning.KinematicTrajectoryOptimization"><span class="pre">pydrake.planning.KinematicTrajectoryOptimization</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">lb</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ub</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.Binding" title="pydrake.solvers.Binding"><span class="pre">pydrake.solvers.Binding</span></a><span class="p"><span class="pre">[</span></span><span class="pre">BoundingBoxConstraint</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.KinematicTrajectoryOptimization.AddDurationConstraint" title="Permalink to this definition"></a></dt>
<dd><p>Adds bounding box constraints for upper and lower bounds on the
duration of the trajectory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.KinematicTrajectoryOptimization.AddDurationCost">
<span class="sig-name descname"><span class="pre">AddDurationCost</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.KinematicTrajectoryOptimization" title="pydrake.planning.KinematicTrajectoryOptimization"><span class="pre">pydrake.planning.KinematicTrajectoryOptimization</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.Binding" title="pydrake.solvers.Binding"><span class="pre">pydrake.solvers.Binding</span></a><span class="p"><span class="pre">[</span></span><span class="pre">LinearCost</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.KinematicTrajectoryOptimization.AddDurationCost" title="Permalink to this definition"></a></dt>
<dd><p>Adds a linear cost on the duration of the trajectory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.KinematicTrajectoryOptimization.AddJerkBounds">
<span class="sig-name descname"><span class="pre">AddJerkBounds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.KinematicTrajectoryOptimization" title="pydrake.planning.KinematicTrajectoryOptimization"><span class="pre">pydrake.planning.KinematicTrajectoryOptimization</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">lb</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ub</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.Binding" title="pydrake.solvers.Binding"><span class="pre">pydrake.solvers.Binding</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Constraint</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.KinematicTrajectoryOptimization.AddJerkBounds" title="Permalink to this definition"></a></dt>
<dd><p>Adds generic (nonlinear) constraints to enforce the upper and lower
bounds to the jerk trajectory, d³qdt³(t). These constraints will be
respected at all times. Note that this does NOT directly constrain
d³rds³(s).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A vector of bindings with the ith element is itself a vector of
constraints (one per dof) adding a constraint to the ith control
point of the jerk trajectory.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.KinematicTrajectoryOptimization.AddPathAccelerationConstraint">
<span class="sig-name descname"><span class="pre">AddPathAccelerationConstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.KinematicTrajectoryOptimization" title="pydrake.planning.KinematicTrajectoryOptimization"><span class="pre">pydrake.planning.KinematicTrajectoryOptimization</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">lb</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ub</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.Binding" title="pydrake.solvers.Binding"><span class="pre">pydrake.solvers.Binding</span></a><span class="p"><span class="pre">[</span></span><span class="pre">LinearConstraint</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.KinematicTrajectoryOptimization.AddPathAccelerationConstraint" title="Permalink to this definition"></a></dt>
<dd><p>Adds a linear constraint on the second derivative of the path, <code class="docutils literal notranslate"><span class="pre">lb</span></code>
≤ r̈(s) ≤ <code class="docutils literal notranslate"><span class="pre">ub</span></code>. Note that this does NOT directly constrain q̈(t).</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>0 &lt;= <code class="docutils literal notranslate"><span class="pre">s</span></code> &lt;= 1.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.KinematicTrajectoryOptimization.AddPathEnergyCost">
<span class="sig-name descname"><span class="pre">AddPathEnergyCost</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.KinematicTrajectoryOptimization" title="pydrake.planning.KinematicTrajectoryOptimization"><span class="pre">pydrake.planning.KinematicTrajectoryOptimization</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.Binding" title="pydrake.solvers.Binding"><span class="pre">pydrake.solvers.Binding</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Cost</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.KinematicTrajectoryOptimization.AddPathEnergyCost" title="Permalink to this definition"></a></dt>
<dd><p>Adds a convex quadratic cost on an upper bound on the energy of the
path, ∫₀¹ <a href="#id19"><span class="problematic" id="id20">|</span></a>ṙ(s)|₂² ds, by summing the squared distance between the
path control points. In the limit of infinitely many control points,
minimizers for AddPathLengthCost and AddPathEnergyCost will follow the
same path, but potentially with different timing. They may have
different values if additional costs and constraints are imposed. This
cost yields simpler gradients than AddPathLengthCost, and biases the
control points towards being evenly spaced.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A vector of bindings with the ith element adding a cost to the ith
control point of the velocity trajectory.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.KinematicTrajectoryOptimization.AddPathLengthCost">
<span class="sig-name descname"><span class="pre">AddPathLengthCost</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.KinematicTrajectoryOptimization" title="pydrake.planning.KinematicTrajectoryOptimization"><span class="pre">pydrake.planning.KinematicTrajectoryOptimization</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_conic_constraint</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.Binding" title="pydrake.solvers.Binding"><span class="pre">pydrake.solvers.Binding</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Cost</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.KinematicTrajectoryOptimization.AddPathLengthCost" title="Permalink to this definition"></a></dt>
<dd><p>Adds a cost on an upper bound of the length of the path, ∫₀ᵀ <a href="#id21"><span class="problematic" id="id22">|</span></a>q̇(t)|₂
dt, or equivalently ∫₀¹ <a href="#id23"><span class="problematic" id="id24">|</span></a>ṙ(s)|₂ ds, by summing the distance between
the path control points. If <code class="docutils literal notranslate"><span class="pre">use_conic_constraint</span> <span class="pre">=</span> <span class="pre">false</span></code>, then
costs are added via MathematicalProgram::AddL2NormCost; otherwise they
are added via MathematicalProgram::AddL2NormCostUsingConicConstraint.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A vector of bindings with the ith element adding a cost to the ith
control point of the velocity trajectory.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.KinematicTrajectoryOptimization.AddPathPositionConstraint">
<span class="sig-name descname"><span class="pre">AddPathPositionConstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.planning.KinematicTrajectoryOptimization.AddPathPositionConstraint" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddPathPositionConstraint(self: pydrake.planning.KinematicTrajectoryOptimization, lb: numpy.ndarray[numpy.float64[m, 1]], ub: numpy.ndarray[numpy.float64[m, 1]], s: float) -&gt; pydrake.solvers.Binding[LinearConstraint]</p></li>
</ol>
<p>Adds a linear constraint on the value of the path, <code class="docutils literal notranslate"><span class="pre">lb</span></code> ≤ r(s) ≤
<code class="docutils literal notranslate"><span class="pre">ub</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>0 &lt;= <code class="docutils literal notranslate"><span class="pre">s</span></code> &lt;= 1.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>AddPathPositionConstraint(self: pydrake.planning.KinematicTrajectoryOptimization, constraint: pydrake.solvers.Constraint, s: float) -&gt; pydrake.solvers.Binding[Constraint]</p></li>
</ol>
<p>Adds a (generic) constraint on path. The constraint will be evaluated
as if it is bound with variables corresponding to <code class="docutils literal notranslate"><span class="pre">r(s)</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>constraint.num_vars() == num_positions()</p>
</dd>
<dt>Precondition:</dt><dd><p>0 &lt;= <code class="docutils literal notranslate"><span class="pre">s</span></code> &lt;= 1.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.KinematicTrajectoryOptimization.AddPathVelocityConstraint">
<span class="sig-name descname"><span class="pre">AddPathVelocityConstraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.KinematicTrajectoryOptimization" title="pydrake.planning.KinematicTrajectoryOptimization"><span class="pre">pydrake.planning.KinematicTrajectoryOptimization</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">lb</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ub</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.Binding" title="pydrake.solvers.Binding"><span class="pre">pydrake.solvers.Binding</span></a><span class="p"><span class="pre">[</span></span><span class="pre">LinearConstraint</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.KinematicTrajectoryOptimization.AddPathVelocityConstraint" title="Permalink to this definition"></a></dt>
<dd><p>Adds a linear constraint on the derivative of the path, <code class="docutils literal notranslate"><span class="pre">lb</span></code> ≤ ṙ(s)
≤ <code class="docutils literal notranslate"><span class="pre">ub</span></code>. Note that this does NOT directly constrain q̇(t).</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>0 &lt;= <code class="docutils literal notranslate"><span class="pre">s</span></code> &lt;= 1.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.KinematicTrajectoryOptimization.AddPositionBounds">
<span class="sig-name descname"><span class="pre">AddPositionBounds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.KinematicTrajectoryOptimization" title="pydrake.planning.KinematicTrajectoryOptimization"><span class="pre">pydrake.planning.KinematicTrajectoryOptimization</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">lb</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ub</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.Binding" title="pydrake.solvers.Binding"><span class="pre">pydrake.solvers.Binding</span></a><span class="p"><span class="pre">[</span></span><span class="pre">BoundingBoxConstraint</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.KinematicTrajectoryOptimization.AddPositionBounds" title="Permalink to this definition"></a></dt>
<dd><p>Adds bounding box constraints to enforce upper and lower bounds on the
positions trajectory, q(t). These bounds will be respected at all
times, t∈[0,T]. This also implies the constraints are satisfied for
r(s), for all s∈[0,1].</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A vector of bindings with the ith element adding a constraint to
the ith control point.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.KinematicTrajectoryOptimization.AddVelocityBounds">
<span class="sig-name descname"><span class="pre">AddVelocityBounds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.KinematicTrajectoryOptimization" title="pydrake.planning.KinematicTrajectoryOptimization"><span class="pre">pydrake.planning.KinematicTrajectoryOptimization</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">lb</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ub</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.Binding" title="pydrake.solvers.Binding"><span class="pre">pydrake.solvers.Binding</span></a><span class="p"><span class="pre">[</span></span><span class="pre">LinearConstraint</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.KinematicTrajectoryOptimization.AddVelocityBounds" title="Permalink to this definition"></a></dt>
<dd><p>Adds linear constraints to enforce upper and lower bounds on the
velocity trajectory, q̇(t). These bounds will be respected at all
times. Note this does NOT directly constrain ṙ(s).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A vector of bindings with the ith element adding a constraint to
the ith control point of the derivative trajectory.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.KinematicTrajectoryOptimization.AddVelocityConstraintAtNormalizedTime">
<span class="sig-name descname"><span class="pre">AddVelocityConstraintAtNormalizedTime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.KinematicTrajectoryOptimization" title="pydrake.planning.KinematicTrajectoryOptimization"><span class="pre">pydrake.planning.KinematicTrajectoryOptimization</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">constraint</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.Constraint" title="pydrake.solvers.Constraint"><span class="pre">pydrake.solvers.Constraint</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.Binding" title="pydrake.solvers.Binding"><span class="pre">pydrake.solvers.Binding</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Constraint</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.KinematicTrajectoryOptimization.AddVelocityConstraintAtNormalizedTime" title="Permalink to this definition"></a></dt>
<dd><p>Adds a (generic) constraint on trajectory velocity <code class="docutils literal notranslate"><span class="pre">q̇(t)</span></code>,
evaluated at <code class="docutils literal notranslate"><span class="pre">s</span></code>. The constraint will be evaluated as if it is bound
with variables corresponding to <code class="docutils literal notranslate"><span class="pre">[q(T*s),</span> <span class="pre">q̇(T*s)]</span></code>.</p>
<p>This is a potentially confusing mix of <code class="docutils literal notranslate"><span class="pre">s</span></code> and <code class="docutils literal notranslate"><span class="pre">t</span></code>, but it is
important in practice. For instance if you want to constrain the true
(trajectory) velocity at the final time, one would naturally want to
write AddVelocityConstraint(constraint, s=1).</p>
<p>This method should be compared with AddPathVelocityConstraint, which
only constrains ṙ(s) because it does not reason about the time
scaling, T. However, AddPathVelocityConstraint adds convex
constraints, whereas this method adds nonconvex generic constraints.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>constraint.num_vars() == num_positions()</p>
</dd>
<dt>Precondition:</dt><dd><p>0 &lt;= <code class="docutils literal notranslate"><span class="pre">s</span></code> &lt;= 1.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.KinematicTrajectoryOptimization.basis">
<span class="sig-name descname"><span class="pre">basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.KinematicTrajectoryOptimization" title="pydrake.planning.KinematicTrajectoryOptimization"><span class="pre">pydrake.planning.KinematicTrajectoryOptimization</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.math.html#pydrake.math.BsplineBasis" title="pydrake.math.BsplineBasis"><span class="pre">pydrake.math.BsplineBasis</span></a></span></span><a class="headerlink" href="#pydrake.planning.KinematicTrajectoryOptimization.basis" title="Permalink to this definition"></a></dt>
<dd><p>Returns the basis used to represent the path, r(s), over s∈[0,1].</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.KinematicTrajectoryOptimization.control_points">
<span class="sig-name descname"><span class="pre">control_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.KinematicTrajectoryOptimization" title="pydrake.planning.KinematicTrajectoryOptimization"><span class="pre">pydrake.planning.KinematicTrajectoryOptimization</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.KinematicTrajectoryOptimization.control_points" title="Permalink to this definition"></a></dt>
<dd><p>Returns the control points defining the path as an M-by-N matrix,
where M is the number of positions and N is the number of control
points.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.KinematicTrajectoryOptimization.duration">
<span class="sig-name descname"><span class="pre">duration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.KinematicTrajectoryOptimization" title="pydrake.planning.KinematicTrajectoryOptimization"><span class="pre">pydrake.planning.KinematicTrajectoryOptimization</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Variable" title="pydrake.symbolic.Variable"><span class="pre">pydrake.symbolic.Variable</span></a></span></span><a class="headerlink" href="#pydrake.planning.KinematicTrajectoryOptimization.duration" title="Permalink to this definition"></a></dt>
<dd><p>Returns the decision variable defining the time duration of the
trajectory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.KinematicTrajectoryOptimization.get_mutable_prog">
<span class="sig-name descname"><span class="pre">get_mutable_prog</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.KinematicTrajectoryOptimization" title="pydrake.planning.KinematicTrajectoryOptimization"><span class="pre">pydrake.planning.KinematicTrajectoryOptimization</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.MathematicalProgram" title="pydrake.solvers.MathematicalProgram"><span class="pre">pydrake.solvers.MathematicalProgram</span></a></span></span><a class="headerlink" href="#pydrake.planning.KinematicTrajectoryOptimization.get_mutable_prog" title="Permalink to this definition"></a></dt>
<dd><p>Getter for a mutable pointer to the optimization program.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.KinematicTrajectoryOptimization.num_control_points">
<span class="sig-name descname"><span class="pre">num_control_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.KinematicTrajectoryOptimization" title="pydrake.planning.KinematicTrajectoryOptimization"><span class="pre">pydrake.planning.KinematicTrajectoryOptimization</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.planning.KinematicTrajectoryOptimization.num_control_points" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of control points used for the path.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.KinematicTrajectoryOptimization.num_positions">
<span class="sig-name descname"><span class="pre">num_positions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.KinematicTrajectoryOptimization" title="pydrake.planning.KinematicTrajectoryOptimization"><span class="pre">pydrake.planning.KinematicTrajectoryOptimization</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.planning.KinematicTrajectoryOptimization.num_positions" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of position variables.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.KinematicTrajectoryOptimization.prog">
<span class="sig-name descname"><span class="pre">prog</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.KinematicTrajectoryOptimization" title="pydrake.planning.KinematicTrajectoryOptimization"><span class="pre">pydrake.planning.KinematicTrajectoryOptimization</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.MathematicalProgram" title="pydrake.solvers.MathematicalProgram"><span class="pre">pydrake.solvers.MathematicalProgram</span></a></span></span><a class="headerlink" href="#pydrake.planning.KinematicTrajectoryOptimization.prog" title="Permalink to this definition"></a></dt>
<dd><p>Getter for the optimization program.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.KinematicTrajectoryOptimization.ReconstructTrajectory">
<span class="sig-name descname"><span class="pre">ReconstructTrajectory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.KinematicTrajectoryOptimization" title="pydrake.planning.KinematicTrajectoryOptimization"><span class="pre">pydrake.planning.KinematicTrajectoryOptimization</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">result</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.MathematicalProgramResult" title="pydrake.solvers.MathematicalProgramResult"><span class="pre">pydrake.solvers.MathematicalProgramResult</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.trajectories.html#pydrake.trajectories.BsplineTrajectory" title="pydrake.trajectories.BsplineTrajectory"><span class="pre">pydrake.trajectories.BsplineTrajectory</span></a></span></span><a class="headerlink" href="#pydrake.planning.KinematicTrajectoryOptimization.ReconstructTrajectory" title="Permalink to this definition"></a></dt>
<dd><p>Returns the trajectory q(t) from the <code class="docutils literal notranslate"><span class="pre">result</span></code> of solving <code class="docutils literal notranslate"><span class="pre">prog()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.KinematicTrajectoryOptimization.SetInitialGuess">
<span class="sig-name descname"><span class="pre">SetInitialGuess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.KinematicTrajectoryOptimization" title="pydrake.planning.KinematicTrajectoryOptimization"><span class="pre">pydrake.planning.KinematicTrajectoryOptimization</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">trajectory</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.trajectories.html#pydrake.trajectories.BsplineTrajectory" title="pydrake.trajectories.BsplineTrajectory"><span class="pre">pydrake.trajectories.BsplineTrajectory</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.KinematicTrajectoryOptimization.SetInitialGuess" title="Permalink to this definition"></a></dt>
<dd><p>Sets the initial guess for the path and duration to match
<code class="docutils literal notranslate"><span class="pre">trajectory</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>trajectory.rows() == num_positions()</p>
</dd>
<dt>Precondition:</dt><dd><p>trajectory.columns() == 1</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.planning.LinearDistanceAndInterpolationProvider">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.planning.</span></span><span class="sig-name descname"><span class="pre">LinearDistanceAndInterpolationProvider</span></span><a class="headerlink" href="#pydrake.planning.LinearDistanceAndInterpolationProvider" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.planning.DistanceAndInterpolationProvider" title="pydrake.planning.DistanceAndInterpolationProvider"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.planning.DistanceAndInterpolationProvider</span></code></a></p>
<p>This class represents a basic “linear” implementation of
DistanceAndInterpolationProvider.</p>
<ul class="simple">
<li><p>Configuration distance is computed as difference.cwiseProduct(weights).norm(),</p></li>
</ul>
<p>where difference is computed as the angle between quaternion DoF and difference
between all other positions. Default weights are (1, 0, 0, 0) for quaternion
DoF and 1 for all other positions.
- Configuration interpolation is performed using slerp for quaternion DoF and
linear interpolation for all other positions.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.LinearDistanceAndInterpolationProvider.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.planning.LinearDistanceAndInterpolationProvider.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.planning.LinearDistanceAndInterpolationProvider, plant: pydrake.multibody.plant.MultibodyPlant) -&gt; None</p></li>
</ol>
<p>Constructs a LinearDistanceAndInterpolationProvider for the specified
<code class="docutils literal notranslate"><span class="pre">plant</span></code> with default distance weights (i.e. 1) for all positions.
Equivalent to constructing with an empty map of named joint distance
weights.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.planning.LinearDistanceAndInterpolationProvider, plant: pydrake.multibody.plant.MultibodyPlant, distance_weights: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs a LinearDistanceAndInterpolationProvider for the specified
<code class="docutils literal notranslate"><span class="pre">plant</span></code> with the provided distance weights <code class="docutils literal notranslate"><span class="pre">distance_weights</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>distance_weights must be the same size as plant.num_positions(),
all weights must be non-negative and finite, and weights for
quaternion DoF must be of the form (weight, 0, 0, 0).</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.planning.LinearDistanceAndInterpolationProvider, plant: pydrake.multibody.plant.MultibodyPlant, joint_distance_weights: dict[pydrake.multibody.tree.JointIndex, numpy.ndarray[numpy.float64[m, 1]]]) -&gt; None</p></li>
</ol>
<p>Constructs a LinearDistanceAndInterpolationProvider for the specified
<code class="docutils literal notranslate"><span class="pre">plant</span></code> using the provided map of distance weights
<code class="docutils literal notranslate"><span class="pre">joint_distance_weights</span></code> and default weights (i.e. 1) for all other
positions.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>all distance weights must be non-negative and finite.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.LinearDistanceAndInterpolationProvider.distance_weights">
<span class="sig-name descname"><span class="pre">distance_weights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.LinearDistanceAndInterpolationProvider" title="pydrake.planning.LinearDistanceAndInterpolationProvider"><span class="pre">pydrake.planning.LinearDistanceAndInterpolationProvider</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.LinearDistanceAndInterpolationProvider.distance_weights" title="Permalink to this definition"></a></dt>
<dd><p>Gets the distance weights.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.LinearDistanceAndInterpolationProvider.quaternion_dof_start_indices">
<span class="sig-name descname"><span class="pre">quaternion_dof_start_indices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.LinearDistanceAndInterpolationProvider" title="pydrake.planning.LinearDistanceAndInterpolationProvider"><span class="pre">pydrake.planning.LinearDistanceAndInterpolationProvider</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.LinearDistanceAndInterpolationProvider.quaternion_dof_start_indices" title="Permalink to this definition"></a></dt>
<dd><p>Gets the start indices for quaternion DoF in the position vector.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.planning.MakeBodyShapeDescription">
<span class="sig-prename descclassname"><span class="pre">pydrake.planning.</span></span><span class="sig-name descname"><span class="pre">MakeBodyShapeDescription</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">plant</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.plant.html#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">plant_context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">geometry_id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.GeometryId" title="pydrake.geometry.GeometryId"><span class="pre">pydrake.geometry.GeometryId</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.planning.BodyShapeDescription" title="pydrake.planning.BodyShapeDescription"><span class="pre">pydrake.planning.BodyShapeDescription</span></a></span></span><a class="headerlink" href="#pydrake.planning.MakeBodyShapeDescription" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a BodyShapeDescription by extracting the shape, pose, and
names associated with the provided geometry_id.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">plant_context</span></code> is compatible with <code class="docutils literal notranslate"><span class="pre">plant</span></code>.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">plant</span></code> is connected to a scene graph.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">geometry_id</span></code> refers to a geometry rigidly affixed to a body of
<code class="docutils literal notranslate"><span class="pre">plant</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.planning.MaxCliqueSolverBase">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.planning.</span></span><span class="sig-name descname"><span class="pre">MaxCliqueSolverBase</span></span><a class="headerlink" href="#pydrake.planning.MaxCliqueSolverBase" title="Permalink to this definition"></a></dt>
<dd><p>The problem of finding the maximum clique in a graph is known to be
NP-complete. This base class provides a unified interface for various
implementations of a solver for this problem which may be solved
rigorously or via heuristics.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.MaxCliqueSolverBase.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.MaxCliqueSolverBase" title="pydrake.planning.MaxCliqueSolverBase"><span class="pre">pydrake.planning.MaxCliqueSolverBase</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.MaxCliqueSolverBase.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.MaxCliqueSolverBase.SolveMaxClique">
<span class="sig-name descname"><span class="pre">SolveMaxClique</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.MaxCliqueSolverBase" title="pydrake.planning.MaxCliqueSolverBase"><span class="pre">pydrake.planning.MaxCliqueSolverBase</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">adjacency_matrix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">scipy.sparse.csc_matrix</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.MaxCliqueSolverBase.SolveMaxClique" title="Permalink to this definition"></a></dt>
<dd><p>Given the adjacency matrix of an undirected graph, find the maximum
clique within the graph. A clique is a collection of vertices in a
graph such that each pair of vertices is connected by an edge (i.e. a
fully connected subgraph). This problem is known to be NP-complete,
and so the concrete implementation of the solver determines whether
the return of this function is the true maximum clique in the graph
(which may take very long to compute), or only an approximate solution
found via heuristics.</p>
<p>This method throws if the adjacency matrix is not symmetric and may
throw depending on the concrete implementation of the solver.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">adjacency_matrix</span></code>:</dt><dd><p>a symmetric binary matrix encoding the edge relationship.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A binary vector with the same indexing as the adjacency matrix,
with true indicating membership in the clique.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.planning.MaxCliqueSolverViaGreedy">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.planning.</span></span><span class="sig-name descname"><span class="pre">MaxCliqueSolverViaGreedy</span></span><a class="headerlink" href="#pydrake.planning.MaxCliqueSolverViaGreedy" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.planning.MaxCliqueSolverBase" title="pydrake.planning.MaxCliqueSolverBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.planning.MaxCliqueSolverBase</span></code></a></p>
<p>Approximately solves the maximum clique problem via a greedy
heuristic. Vertices are greedily added to the clique based on their
degree of connectivity. The algorithm initializes the clique with an
empty set and makes every vertex a candidate, then the degree of every
vertex is computed and the candidate vertex with the highest degree is
added to the clique. Afterwards, new candidate list is updated and the
previous two steps are repeated until no candidates are left.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.MaxCliqueSolverViaGreedy.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.MaxCliqueSolverViaGreedy" title="pydrake.planning.MaxCliqueSolverViaGreedy"><span class="pre">pydrake.planning.MaxCliqueSolverViaGreedy</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.MaxCliqueSolverViaGreedy.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.planning.MaxCliqueSolverViaMip">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.planning.</span></span><span class="sig-name descname"><span class="pre">MaxCliqueSolverViaMip</span></span><a class="headerlink" href="#pydrake.planning.MaxCliqueSolverViaMip" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.planning.MaxCliqueSolverBase" title="pydrake.planning.MaxCliqueSolverBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.planning.MaxCliqueSolverBase</span></code></a></p>
<p>Solves the maximum clique problem to global optimality by solving the
mixed-integer program</p>
<p>Maximize ∑ᵢ xᵢ subject to xᵢ + xⱼ ≤ 1 if (i,j) is not in the edge xᵢ ∈
{0,1}.</p>
<p>Note: This solver requires the availability of a Mixed-Integer Linear
Programming solver (e.g. Gurobi and/or Mosek). We recommend enabling
those solvers if possible
(<a class="reference external" href="https://drake.mit.edu/bazel.html#proprietary_solvers">https://drake.mit.edu/bazel.html#proprietary_solvers</a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if no Mixed-Integer Linear Programming solver is</strong> – </p></li>
<li><p><strong>available.</strong> – </p></li>
<li><p><strong>RuntimeError if the initial guess has the wrong size for the</strong> – </p></li>
<li><p><strong>provided adjacency matrix.</strong> – </p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.MaxCliqueSolverViaMip.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.planning.MaxCliqueSolverViaMip.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.planning.MaxCliqueSolverViaMip) -&gt; None</p></li>
<li><p>__init__(self: pydrake.planning.MaxCliqueSolverViaMip, initial_guess: Optional[numpy.ndarray[numpy.float64[m, 1]]], solver_options: pydrake.solvers.SolverOptions) -&gt; None</p></li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.MaxCliqueSolverViaMip.GetInitialGuess">
<span class="sig-name descname"><span class="pre">GetInitialGuess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.MaxCliqueSolverViaMip" title="pydrake.planning.MaxCliqueSolverViaMip"><span class="pre">pydrake.planning.MaxCliqueSolverViaMip</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.MaxCliqueSolverViaMip.GetInitialGuess" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.MaxCliqueSolverViaMip.GetSolverOptions">
<span class="sig-name descname"><span class="pre">GetSolverOptions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.MaxCliqueSolverViaMip" title="pydrake.planning.MaxCliqueSolverViaMip"><span class="pre">pydrake.planning.MaxCliqueSolverViaMip</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.SolverOptions" title="pydrake.solvers.SolverOptions"><span class="pre">pydrake.solvers.SolverOptions</span></a></span></span><a class="headerlink" href="#pydrake.planning.MaxCliqueSolverViaMip.GetSolverOptions" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.MaxCliqueSolverViaMip.SetInitialGuess">
<span class="sig-name descname"><span class="pre">SetInitialGuess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.MaxCliqueSolverViaMip" title="pydrake.planning.MaxCliqueSolverViaMip"><span class="pre">pydrake.planning.MaxCliqueSolverViaMip</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_guess</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.MaxCliqueSolverViaMip.SetInitialGuess" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.MaxCliqueSolverViaMip.SetSolverOptions">
<span class="sig-name descname"><span class="pre">SetSolverOptions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.MaxCliqueSolverViaMip" title="pydrake.planning.MaxCliqueSolverViaMip"><span class="pre">pydrake.planning.MaxCliqueSolverViaMip</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver_options</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.SolverOptions" title="pydrake.solvers.SolverOptions"><span class="pre">pydrake.solvers.SolverOptions</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.MaxCliqueSolverViaMip.SetSolverOptions" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.planning.MinCliqueCoverSolverBase">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.planning.</span></span><span class="sig-name descname"><span class="pre">MinCliqueCoverSolverBase</span></span><a class="headerlink" href="#pydrake.planning.MinCliqueCoverSolverBase" title="Permalink to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.MinCliqueCoverSolverBase.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.MinCliqueCoverSolverBase" title="pydrake.planning.MinCliqueCoverSolverBase"><span class="pre">pydrake.planning.MinCliqueCoverSolverBase</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.MinCliqueCoverSolverBase.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.MinCliqueCoverSolverBase.SolveMinCliqueCover">
<span class="sig-name descname"><span class="pre">SolveMinCliqueCover</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.MinCliqueCoverSolverBase" title="pydrake.planning.MinCliqueCoverSolverBase"><span class="pre">pydrake.planning.MinCliqueCoverSolverBase</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">adjacency_matrix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">scipy.sparse.csc_matrix</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">partition</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">set</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.MinCliqueCoverSolverBase.SolveMinCliqueCover" title="Permalink to this definition"></a></dt>
<dd><p>Given the adjacency matrix of an undirected graph, finds a
(potentially approximate) minimum clique cover of the graph. A clique
is a collection of vertices in a graph such that each pair of vertices
is connected by an edge (i.e. a fully connected subgraph). A clique
cover is a collection of cliques where each vertex in the graph is in
at least one of the cliques. This problem is known to be NP-complete,
and so the concrete implementation of the solver determines whether
the return of this function is the true minimum clique cover of the
graph (which may take very long to compute), or only an approximate
solution found via heuristics.</p>
<p>This method throws if the adjacency matrix is not symmetric and may
throw depending on the concrete implementation of the solver.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">adjacency_matrix</span></code>:</dt><dd><p>a symmetric binary matrix encoding the edge relationship.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">partition</span></code>:</dt><dd><p>If true, then every vertex is allowed to be covered exactly once.
Otherwise, the same vertex may be covered multiple times.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A binary vector with the same indexing as the adjacency matrix,
with true indicating membership in the clique.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The ith entry of the returned vector is a vector containing the
indices of the ith clique.</p>
</dd>
</dl>
<p>Note that this method is intentionally not-const because some solvers
may use randomized algorithms.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.planning.MinCliqueCoverSolverViaGreedy">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.planning.</span></span><span class="sig-name descname"><span class="pre">MinCliqueCoverSolverViaGreedy</span></span><a class="headerlink" href="#pydrake.planning.MinCliqueCoverSolverViaGreedy" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.planning.MinCliqueCoverSolverBase" title="pydrake.planning.MinCliqueCoverSolverBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.planning.MinCliqueCoverSolverBase</span></code></a></p>
<p>Approximately solves the min clique cover problem via a greedy
heuristic.</p>
<p>At each step, the largest clique found by the provided max clique
solver is added to the clique cover. These vertices are then removed
from graph and max clique is solved again. This loop continues until a
clique is found which is smaller than the min clique size.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>if min clique size &gt; 1, then this class will not strictly compute
a clique cover since not all vertices will be covered.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.MinCliqueCoverSolverViaGreedy.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.MinCliqueCoverSolverViaGreedy" title="pydrake.planning.MinCliqueCoverSolverViaGreedy"><span class="pre">pydrake.planning.MinCliqueCoverSolverViaGreedy</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_clique_solver</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.MaxCliqueSolverBase" title="pydrake.planning.MaxCliqueSolverBase"><span class="pre">pydrake.planning.MaxCliqueSolverBase</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_clique_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.MinCliqueCoverSolverViaGreedy.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.MinCliqueCoverSolverViaGreedy.get_min_clique_size">
<span class="sig-name descname"><span class="pre">get_min_clique_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.MinCliqueCoverSolverViaGreedy" title="pydrake.planning.MinCliqueCoverSolverViaGreedy"><span class="pre">pydrake.planning.MinCliqueCoverSolverViaGreedy</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.planning.MinCliqueCoverSolverViaGreedy.get_min_clique_size" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.MinCliqueCoverSolverViaGreedy.set_min_clique_size">
<span class="sig-name descname"><span class="pre">set_min_clique_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.MinCliqueCoverSolverViaGreedy" title="pydrake.planning.MinCliqueCoverSolverViaGreedy"><span class="pre">pydrake.planning.MinCliqueCoverSolverViaGreedy</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_clique_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.MinCliqueCoverSolverViaGreedy.set_min_clique_size" title="Permalink to this definition"></a></dt>
<dd><p>Set the minimum clique size. Throws if this is less than 1.</p>
<p>Parameter <code class="docutils literal notranslate"><span class="pre">min_clique_size</span></code>:</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.planning.MultipleShooting">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.planning.</span></span><span class="sig-name descname"><span class="pre">MultipleShooting</span></span><a class="headerlink" href="#pydrake.planning.MultipleShooting" title="Permalink to this definition"></a></dt>
<dd><p>MultipleShooting is an abstract class for trajectory optimization that
creates decision variables for inputs, states, and (optionally) sample
times along the trajectory, then provides a number of methods for
working with those decision variables.</p>
<p>MultipleShooting classes add decision variables, costs, and
constraints to a MathematicalProgram. You can retrieve that program
using prog(), and add additional variables, costs, and constraints
using the MathematicalProgram interface directly.</p>
<p>Subclasses must implement the abstract methods: DoAddRunningCost()
ReconstructInputTrajectory() ReconstructStateTrajectory() using all of
the correct interpolation schemes for the specific transcription
method, and should add the constraints to impose the System% dynamics
in their constructor.</p>
<p>This class assumes that there are a fixed number (N) time
steps/samples, and that the trajectory is discretized into time steps
h (N-1 of these), state x (N of these), and control input u (N of
these).</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.MultipleShooting.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.planning.MultipleShooting.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.MultipleShooting.AddCompleteTrajectoryCallback">
<span class="sig-name descname"><span class="pre">AddCompleteTrajectoryCallback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.MultipleShooting" title="pydrake.planning.MultipleShooting"><span class="pre">pydrake.planning.MultipleShooting</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">None</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">names</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.Binding" title="pydrake.solvers.Binding"><span class="pre">pydrake.solvers.Binding</span></a><span class="p"><span class="pre">[</span></span><span class="pre">VisualizationCallback</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.MultipleShooting.AddCompleteTrajectoryCallback" title="Permalink to this definition"></a></dt>
<dd><p>Adds a callback method to visualize intermediate results of all
variables used in the trajectory optimization. The callback should be
of the form MyVisualization(sample_times, states, inputs, values),
where sample_times is an N-by-1 VectorXd of sample times, states is a
num_states-by-N MatrixXd of the current (intermediate) state
trajectory at the break points, inputs is a num_inputs-by-N MatrixXd
of the current (intermediate) input trajectory at the break points and
values is a vector of num_rows-by-N MatrixXds of the current
(intermediate) extra sequential variables specified by <code class="docutils literal notranslate"><span class="pre">names</span></code> at
the break points.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Just like other costs/constraints, not all solvers support
callbacks. Adding a callback here will force
MathematicalProgram::Solve to select a solver that support
callbacks. For instance, adding a visualization callback to a
quadratic programming problem may result in using a nonlinear
programming solver as the default solver.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.MultipleShooting.AddConstraintToAllKnotPoints">
<span class="sig-name descname"><span class="pre">AddConstraintToAllKnotPoints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.planning.MultipleShooting.AddConstraintToAllKnotPoints" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddConstraintToAllKnotPoints(self: pydrake.planning.MultipleShooting, f: pydrake.symbolic.Formula) -&gt; list[pydrake.solvers.Binding[Constraint]]</p></li>
</ol>
<p>Adds a constraint to all breakpoints, where any instances of time(),
state(), and/or input() placeholder variables, as well as placeholder
variables returned by calls to NewSequentialVariable(), are
substituted with the relevant variables for each time index.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A vector of the bindings added to each knot point.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>AddConstraintToAllKnotPoints(self: pydrake.planning.MultipleShooting, f: numpy.ndarray[object[m, 1]]) -&gt; list[pydrake.solvers.Binding[Constraint]]</p></li>
</ol>
<p>Variant of AddConstraintToAllKnotPoints that accepts a vector of
formulas.</p>
<ol class="arabic simple" start="3">
<li><p>AddConstraintToAllKnotPoints(self: pydrake.planning.MultipleShooting, constraint: pydrake.solvers.BoundingBoxConstraint, vars: numpy.ndarray[object[m, 1]]) -&gt; list[pydrake.solvers.Binding[BoundingBoxConstraint]]</p></li>
</ol>
<p>Adds a constraint to all breakpoints, where any instances in <code class="docutils literal notranslate"><span class="pre">vars</span></code>
of time(), state(), and/or input() placeholder variables, as well as
placeholder variables returned by calls to NewSequentialVariable(),
are substituted with the relevant variables for each time index.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A vector of the bindings added to each knot point.</p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>AddConstraintToAllKnotPoints(self: pydrake.planning.MultipleShooting, constraint: pydrake.solvers.LinearEqualityConstraint, vars: numpy.ndarray[object[m, 1]]) -&gt; list[pydrake.solvers.Binding[LinearEqualityConstraint]]</p></li>
</ol>
<p>Adds a constraint to all breakpoints, where any instances in <code class="docutils literal notranslate"><span class="pre">vars</span></code>
of time(), state(), and/or input() placeholder variables, as well as
placeholder variables returned by calls to NewSequentialVariable(),
are substituted with the relevant variables for each time index.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A vector of the bindings added to each knot point.</p>
</dd>
</dl>
<ol class="arabic simple" start="5">
<li><p>AddConstraintToAllKnotPoints(self: pydrake.planning.MultipleShooting, constraint: pydrake.solvers.LinearConstraint, vars: numpy.ndarray[object[m, 1]]) -&gt; list[pydrake.solvers.Binding[LinearConstraint]]</p></li>
</ol>
<p>Adds a constraint to all breakpoints, where any instances in <code class="docutils literal notranslate"><span class="pre">vars</span></code>
of time(), state(), and/or input() placeholder variables, as well as
placeholder variables returned by calls to NewSequentialVariable(),
are substituted with the relevant variables for each time index.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A vector of the bindings added to each knot point.</p>
</dd>
</dl>
<ol class="arabic simple" start="6">
<li><p>AddConstraintToAllKnotPoints(self: pydrake.planning.MultipleShooting, constraint: pydrake.solvers.Constraint, vars: numpy.ndarray[object[m, 1]]) -&gt; list[pydrake.solvers.Binding[Constraint]]</p></li>
</ol>
<p>Adds a constraint to all breakpoints, where any instances in <code class="docutils literal notranslate"><span class="pre">vars</span></code>
of time(), state(), and/or input() placeholder variables, as well as
placeholder variables returned by calls to NewSequentialVariable(),
are substituted with the relevant variables for each time index.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A vector of the bindings added to each knot point.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.MultipleShooting.AddDurationBounds">
<span class="sig-name descname"><span class="pre">AddDurationBounds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.MultipleShooting" title="pydrake.planning.MultipleShooting"><span class="pre">pydrake.planning.MultipleShooting</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower_bound</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper_bound</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.Binding" title="pydrake.solvers.Binding"><span class="pre">pydrake.solvers.Binding</span></a><span class="p"><span class="pre">[</span></span><span class="pre">LinearConstraint</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.MultipleShooting.AddDurationBounds" title="Permalink to this definition"></a></dt>
<dd><p>Adds a constraint on the total duration of the trajectory.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lower_bound</span></code>:</dt><dd><p>A scalar double lower bound.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">upper_bound</span></code>:</dt><dd><p>A scalar double upper bound.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The constraint enforcing the duration bounds.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>RuntimeError if time steps are not declared as decision variables.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.MultipleShooting.AddEqualTimeIntervalsConstraints">
<span class="sig-name descname"><span class="pre">AddEqualTimeIntervalsConstraints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.MultipleShooting" title="pydrake.planning.MultipleShooting"><span class="pre">pydrake.planning.MultipleShooting</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.Binding" title="pydrake.solvers.Binding"><span class="pre">pydrake.solvers.Binding</span></a><span class="p"><span class="pre">[</span></span><span class="pre">LinearConstraint</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.MultipleShooting.AddEqualTimeIntervalsConstraints" title="Permalink to this definition"></a></dt>
<dd><p>Adds constraints to enforce that all time steps have equal duration.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A vector of constraints enforcing all time intervals are equal.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>RuntimeError if time steps are not declared as decision variables.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.MultipleShooting.AddFinalCost">
<span class="sig-name descname"><span class="pre">AddFinalCost</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.planning.MultipleShooting.AddFinalCost" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddFinalCost(self: pydrake.planning.MultipleShooting, e: pydrake.symbolic.Expression) -&gt; pydrake.solvers.Binding[Cost]</p></li>
</ol>
<p>Adds a cost to the final time, of the form</p>
<div class="math notranslate nohighlight">
\[cost = e(t,x,u),\]</div>
<p>where any instances of time(), state(), and/or input() placeholder
variables, as well as placeholder variables returned by calls to
NewSequentialVariable(), are substituted with the relevant variables
for the final time index.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The final cost added to the problem.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>AddFinalCost(self: pydrake.planning.MultipleShooting, matrix: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; pydrake.solvers.Binding[Cost]</p></li>
</ol>
<p>Adds support for passing in a (scalar) matrix Expression, which is a
common output of most symbolic linear algebra operations.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The final cost added to the problem.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Derived classes will need to type using
MultipleShooting::AddFinalCost; to “unhide” this method.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.MultipleShooting.AddInputTrajectoryCallback">
<span class="sig-name descname"><span class="pre">AddInputTrajectoryCallback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.MultipleShooting" title="pydrake.planning.MultipleShooting"><span class="pre">pydrake.planning.MultipleShooting</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">None</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.Binding" title="pydrake.solvers.Binding"><span class="pre">pydrake.solvers.Binding</span></a><span class="p"><span class="pre">[</span></span><span class="pre">VisualizationCallback</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.MultipleShooting.AddInputTrajectoryCallback" title="Permalink to this definition"></a></dt>
<dd><p>Adds a callback method to visualize intermediate results of input
variables used in the trajectory optimization. The callback should be
of the form MyVisualization(sample_times, values), where breaks is a
N-by-1 VectorXd of sample times, and values is a num_inputs-by-N
MatrixXd representing the current (intermediate) value of the input
trajectory at the break points in each column.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Just like other costs/constraints, not all solvers support
callbacks. Adding a callback here will force
MathematicalProgram::Solve to select a solver that support
callbacks. For instance, adding a visualization callback to a
quadratic programming problem may result in using a nonlinear
programming solver as the default solver.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.MultipleShooting.AddRunningCost">
<span class="sig-name descname"><span class="pre">AddRunningCost</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.planning.MultipleShooting.AddRunningCost" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddRunningCost(self: pydrake.planning.MultipleShooting, g: pydrake.symbolic.Expression) -&gt; None</p></li>
</ol>
<p>Adds an integrated cost to all time steps, of the form</p>
<div class="math notranslate nohighlight">
\[cost = \int_0^T g(t,x,u) dt,\]</div>
<p>where any instances of time(), state(), and/or input() placeholder
variables, as well as placeholder variables returned by calls to
NewSequentialVariable(), are substituted with the relevant variables
for each time index. The particular integration scheme is determined
by the derived class implementation.</p>
<ol class="arabic simple" start="2">
<li><p>AddRunningCost(self: pydrake.planning.MultipleShooting, g: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; None</p></li>
</ol>
<p>Adds support for passing in a (scalar) matrix Expression, which is a
common output of most symbolic linear algebra operations.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.MultipleShooting.AddStateTrajectoryCallback">
<span class="sig-name descname"><span class="pre">AddStateTrajectoryCallback</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.MultipleShooting" title="pydrake.planning.MultipleShooting"><span class="pre">pydrake.planning.MultipleShooting</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">None</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.Binding" title="pydrake.solvers.Binding"><span class="pre">pydrake.solvers.Binding</span></a><span class="p"><span class="pre">[</span></span><span class="pre">VisualizationCallback</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.MultipleShooting.AddStateTrajectoryCallback" title="Permalink to this definition"></a></dt>
<dd><p>Adds a callback method to visualize intermediate results of state
variables used in the trajectory optimization. The callback should be
of the form MyVisualization(sample_times, values), where sample_times
is a N-by-1 VectorXd of sample times, and values is a num_states-by-N
MatrixXd representing the current (intermediate) value of the state
trajectory at the break points in each column.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Just like other costs/constraints, not all solvers support
callbacks. Adding a callback here will force
MathematicalProgram::Solve to select a solver that support
callbacks. For instance, adding a visualization callback to a
quadratic programming problem may result in using a nonlinear
programming solver as the default solver.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.MultipleShooting.AddTimeIntervalBounds">
<span class="sig-name descname"><span class="pre">AddTimeIntervalBounds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.MultipleShooting" title="pydrake.planning.MultipleShooting"><span class="pre">pydrake.planning.MultipleShooting</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower_bound</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper_bound</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.Binding" title="pydrake.solvers.Binding"><span class="pre">pydrake.solvers.Binding</span></a><span class="p"><span class="pre">[</span></span><span class="pre">BoundingBoxConstraint</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.MultipleShooting.AddTimeIntervalBounds" title="Permalink to this definition"></a></dt>
<dd><p>Adds bounds on all time intervals.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lower_bound</span></code>:</dt><dd><p>A scalar double lower bound.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">upper_bound</span></code>:</dt><dd><p>A scalar double upper bound.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The bounding box constraint enforcing time interval bounds.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>RuntimeError if time steps are not declared as decision variables.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.MultipleShooting.final_state">
<span class="sig-name descname"><span class="pre">final_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.MultipleShooting" title="pydrake.planning.MultipleShooting"><span class="pre">pydrake.planning.MultipleShooting</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.MultipleShooting.final_state" title="Permalink to this definition"></a></dt>
<dd><p>Returns the decision variables associated with the state, x, at the
final time index.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.MultipleShooting.fixed_time_step">
<span class="sig-name descname"><span class="pre">fixed_time_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.MultipleShooting" title="pydrake.planning.MultipleShooting"><span class="pre">pydrake.planning.MultipleShooting</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.planning.MultipleShooting.fixed_time_step" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.MultipleShooting.GetInputSamples">
<span class="sig-name descname"><span class="pre">GetInputSamples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.MultipleShooting" title="pydrake.planning.MultipleShooting"><span class="pre">pydrake.planning.MultipleShooting</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">result</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.MathematicalProgramResult" title="pydrake.solvers.MathematicalProgramResult"><span class="pre">pydrake.solvers.MathematicalProgramResult</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.MultipleShooting.GetInputSamples" title="Permalink to this definition"></a></dt>
<dd><p>Returns a matrix containing the input values (arranged in columns) at
each breakpoint at the solution.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.MultipleShooting.GetSampleTimes">
<span class="sig-name descname"><span class="pre">GetSampleTimes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.MultipleShooting" title="pydrake.planning.MultipleShooting"><span class="pre">pydrake.planning.MultipleShooting</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">result</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.MathematicalProgramResult" title="pydrake.solvers.MathematicalProgramResult"><span class="pre">pydrake.solvers.MathematicalProgramResult</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.MultipleShooting.GetSampleTimes" title="Permalink to this definition"></a></dt>
<dd><p>Returns a vector containing the elapsed time at each breakpoint.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.MultipleShooting.GetSequentialVariableAtIndex">
<span class="sig-name descname"><span class="pre">GetSequentialVariableAtIndex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.MultipleShooting" title="pydrake.planning.MultipleShooting"><span class="pre">pydrake.planning.MultipleShooting</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.MultipleShooting.GetSequentialVariableAtIndex" title="Permalink to this definition"></a></dt>
<dd><p>Returns the decision variables associated with the sequential variable
<code class="docutils literal notranslate"><span class="pre">name</span></code> at time index <code class="docutils literal notranslate"><span class="pre">index</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>NewSequentialVariable().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.MultipleShooting.GetSequentialVariableSamples">
<span class="sig-name descname"><span class="pre">GetSequentialVariableSamples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.MultipleShooting" title="pydrake.planning.MultipleShooting"><span class="pre">pydrake.planning.MultipleShooting</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">result</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.MathematicalProgramResult" title="pydrake.solvers.MathematicalProgramResult"><span class="pre">pydrake.solvers.MathematicalProgramResult</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.MultipleShooting.GetSequentialVariableSamples" title="Permalink to this definition"></a></dt>
<dd><p>Returns a matrix containing the sequential variable values (arranged
in columns) at each breakpoint at the solution.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>The name of sequential variable to get the results for. Must
correspond to an already added sequential variable.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.MultipleShooting.GetStateSamples">
<span class="sig-name descname"><span class="pre">GetStateSamples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.MultipleShooting" title="pydrake.planning.MultipleShooting"><span class="pre">pydrake.planning.MultipleShooting</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">result</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.MathematicalProgramResult" title="pydrake.solvers.MathematicalProgramResult"><span class="pre">pydrake.solvers.MathematicalProgramResult</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.MultipleShooting.GetStateSamples" title="Permalink to this definition"></a></dt>
<dd><p>Returns a matrix containing the state values (arranged in columns) at
each breakpoint at the solution.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.MultipleShooting.initial_state">
<span class="sig-name descname"><span class="pre">initial_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.MultipleShooting" title="pydrake.planning.MultipleShooting"><span class="pre">pydrake.planning.MultipleShooting</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.MultipleShooting.initial_state" title="Permalink to this definition"></a></dt>
<dd><p>Returns the decision variables associated with the state, x, at the
initial time index.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.MultipleShooting.input">
<span class="sig-name descname"><span class="pre">input</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.planning.MultipleShooting.input" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>input(self: pydrake.planning.MultipleShooting) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Returns placeholder decision variables (not actually declared as
decision variables in the MathematicalProgram) associated with the
input, u, but with the time-index undetermined. These variables will
be substituted for real decision variables at particular times in
methods like AddRunningCost. Passing these variables directly into
objectives/constraints for the parent classes will result in an error.</p>
<ol class="arabic simple" start="2">
<li><p>input(self: pydrake.planning.MultipleShooting, index: int) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Returns the decision variables associated with the input, u, at time
index <code class="docutils literal notranslate"><span class="pre">index</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.MultipleShooting.NewSequentialVariable">
<span class="sig-name descname"><span class="pre">NewSequentialVariable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.MultipleShooting" title="pydrake.planning.MultipleShooting"><span class="pre">pydrake.planning.MultipleShooting</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">rows</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.MultipleShooting.NewSequentialVariable" title="Permalink to this definition"></a></dt>
<dd><p>Adds a sequential variable (a variable that has associated decision
variables for each time index) to the optimization problem and returns
a placeholder variable (not actually declared as a decision variable
in the MathematicalProgram). This variable will be substituted for
real decision variables at particular times in methods like
AddRunningCost(). Passing this variable directly into
objectives/constraints for the parent classes will result in an error.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.MultipleShooting.prog">
<span class="sig-name descname"><span class="pre">prog</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.MultipleShooting" title="pydrake.planning.MultipleShooting"><span class="pre">pydrake.planning.MultipleShooting</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.MathematicalProgram" title="pydrake.solvers.MathematicalProgram"><span class="pre">pydrake.solvers.MathematicalProgram</span></a></span></span><a class="headerlink" href="#pydrake.planning.MultipleShooting.prog" title="Permalink to this definition"></a></dt>
<dd><p>Returns a reference to the MathematicalProgram associated with the
trajectory optimization problem.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.MultipleShooting.ReconstructInputTrajectory">
<span class="sig-name descname"><span class="pre">ReconstructInputTrajectory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.MultipleShooting" title="pydrake.planning.MultipleShooting"><span class="pre">pydrake.planning.MultipleShooting</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">result</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.MathematicalProgramResult" title="pydrake.solvers.MathematicalProgramResult"><span class="pre">pydrake.solvers.MathematicalProgramResult</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.trajectories.html#pydrake.trajectories.PiecewisePolynomial" title="pydrake.trajectories.PiecewisePolynomial"><span class="pre">pydrake.trajectories.PiecewisePolynomial</span></a></span></span><a class="headerlink" href="#pydrake.planning.MultipleShooting.ReconstructInputTrajectory" title="Permalink to this definition"></a></dt>
<dd><p>Get the input trajectory at the solution as a PiecewisePolynomial. The
order of the trajectory will be determined by the integrator used in
the dynamic constraints. Requires that the system has at least one
input port.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.MultipleShooting.ReconstructStateTrajectory">
<span class="sig-name descname"><span class="pre">ReconstructStateTrajectory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.MultipleShooting" title="pydrake.planning.MultipleShooting"><span class="pre">pydrake.planning.MultipleShooting</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">result</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.solvers.html#pydrake.solvers.MathematicalProgramResult" title="pydrake.solvers.MathematicalProgramResult"><span class="pre">pydrake.solvers.MathematicalProgramResult</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.trajectories.html#pydrake.trajectories.PiecewisePolynomial" title="pydrake.trajectories.PiecewisePolynomial"><span class="pre">pydrake.trajectories.PiecewisePolynomial</span></a></span></span><a class="headerlink" href="#pydrake.planning.MultipleShooting.ReconstructStateTrajectory" title="Permalink to this definition"></a></dt>
<dd><p>Get the state trajectory at the solution as a PiecewisePolynomial. The
order of the trajectory will be determined by the integrator used in
the dynamic constraints.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.MultipleShooting.SetInitialTrajectory">
<span class="sig-name descname"><span class="pre">SetInitialTrajectory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.MultipleShooting" title="pydrake.planning.MultipleShooting"><span class="pre">pydrake.planning.MultipleShooting</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">traj_init_u</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.trajectories.html#pydrake.trajectories.PiecewisePolynomial" title="pydrake.trajectories.PiecewisePolynomial"><span class="pre">pydrake.trajectories.PiecewisePolynomial</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">traj_init_x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.trajectories.html#pydrake.trajectories.PiecewisePolynomial" title="pydrake.trajectories.PiecewisePolynomial"><span class="pre">pydrake.trajectories.PiecewisePolynomial</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.MultipleShooting.SetInitialTrajectory" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.MultipleShooting.state">
<span class="sig-name descname"><span class="pre">state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.planning.MultipleShooting.state" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>state(self: pydrake.planning.MultipleShooting) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Returns placeholder decision variables (not actually declared as
decision variables in the MathematicalProgram) associated with the
state, x, but with the time-index undetermined. These variables will
be substituted for real decision variables at particular times in
methods like AddRunningCost. Passing these variables directly into
objectives/constraints for the parent classes will result in an error.</p>
<ol class="arabic simple" start="2">
<li><p>state(self: pydrake.planning.MultipleShooting, index: int) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Returns the decision variables associated with the state, x, at time
index <code class="docutils literal notranslate"><span class="pre">index</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.MultipleShooting.time">
<span class="sig-name descname"><span class="pre">time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.MultipleShooting" title="pydrake.planning.MultipleShooting"><span class="pre">pydrake.planning.MultipleShooting</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.MultipleShooting.time" title="Permalink to this definition"></a></dt>
<dd><p>Returns a placeholder decision variable (not actually declared as a
decision variable in the MathematicalProgram) associated with the
time, t. This variable will be substituted for real decision variables
at particular times in methods like AddRunningCost. Passing this
variable directly into objectives/constraints for the parent classes
will result in an error.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.MultipleShooting.time_step">
<span class="sig-name descname"><span class="pre">time_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.MultipleShooting" title="pydrake.planning.MultipleShooting"><span class="pre">pydrake.planning.MultipleShooting</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.MultipleShooting.time_step" title="Permalink to this definition"></a></dt>
<dd><p>Returns the decision variable associated with the time step, h, at
time index <code class="docutils literal notranslate"><span class="pre">index</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if time steps are not declared as decision variables.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.planning.RobotClearance">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.planning.</span></span><span class="sig-name descname"><span class="pre">RobotClearance</span></span><a class="headerlink" href="#pydrake.planning.RobotClearance" title="Permalink to this definition"></a></dt>
<dd><p>A summary of the clearance – a collection of distance measurements –
between the robot and everything in the world. This data can be used
to define collision avoidance strategies.</p>
<p>Conceptually, this class represents a table:</p>
<div class="line-block">
<div class="line">body index R | body index O | type | ϕᴼ(R) | Jq_ϕᴼ(R) | |</div>
</div>
<dl class="field-list">
<dt class="field-odd">———-</dt>
<dd class="field-odd"><div class="line-block">
<div class="line">:———-: | :–: | :—: | :——: | | … | … |</div>
</div>
</dd>
</dl>
<p>Member functions return each column of the table as an ordered
collection. The iᵗʰ entry in each collection belongs to the iᵗʰ row.</p>
<p>Each row characterizes the relationship between a particular <em>robot</em>
body (annotated as body R) and some “other” body (annotated as body O)
in the model. That other body O may be part of the robot or the
environment.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">body</span> <span class="pre">index</span> <span class="pre">R</span></code> is the BodyIndex of body R.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">body</span> <span class="pre">index</span> <span class="pre">O</span></code> is the BodyIndex of body O.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">type</span></code> implies the type of body O. Given that we know body R is a robot</p></li>
</ul>
<p>body, <code class="docutils literal notranslate"><span class="pre">type</span></code> indicates that body O is also a robot body with the value
RobotCollisionType::kSelfCollision or an environment body with the value
RobotCollisionType::kEnvironmentCollision. For a correct implementation of
CollisionChecker, it will never be
RobotCollisionType::kEnvironmentAndSelfCollision.
- <code class="docutils literal notranslate"><span class="pre">ϕᴼ(R)</span></code> is the signed distance function of the other body O evaluated on
body R. The reported distance is offset by the padding value for the body
pair recorded in the CollisionChecker. It is the minimum padded distance
between bodies O and R. A point on the padded surface of body O would
report a distance of zero. Points inside that boundary report negative
distance and points outside have positive distance.
- <code class="docutils literal notranslate"><span class="pre">Jqᵣ_ϕᴼ(R)</span></code> is the Jacobian of ϕᴼ(R) with respect to the robot
configuration vector <code class="docutils literal notranslate"><span class="pre">qᵣ</span></code>. The Jacobian is the derivative as observed in
the world frame.
- The vector <code class="docutils literal notranslate"><span class="pre">qᵣ</span></code> will be a subset of the plant’s full configuration <code class="docutils literal notranslate"><span class="pre">q</span></code>
when there are floating bodies or joints in the plant other than the
robot. The Jacobian is only taken with respect to the robot.
- The <code class="docutils literal notranslate"><span class="pre">jacobians()</span></code> matrix has <code class="docutils literal notranslate"><span class="pre">plant.num_positions()</span></code> columns and the
column order matches up with the full <code class="docutils literal notranslate"><span class="pre">plant.GetPositions()</span></code> order.
The columns associated with non-robot joints will be zero.</p>
<p>Several important notes:</p>
<ul class="simple">
<li><p>A single robot body index can appear many times as there may be many</p></li>
</ul>
<p>measured distances between that robot body and other bodies in the model.
- A row <em>may</em> contain a zero-valued Jacobian Jqᵣ_ϕᴼ(R). Appropriately
filtering collisions will cull most of these Jacobians. But depending on
the structure of the robot and its representative collision geometry, it
is still possible to evaluate the Jacobian at a configuration that
represents a local optimum (zero-valued Jacobian).</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotClearance.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.planning.RobotClearance.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.planning.RobotClearance, num_positions: int) -&gt; None</p></li>
</ol>
<p>Creates an empty clearance with size() == 0 and num_positions as
given.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.planning.RobotClearance, other: pydrake.planning.RobotClearance) -&gt; None</p></li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotClearance.Append">
<span class="sig-name descname"><span class="pre">Append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotClearance" title="pydrake.planning.RobotClearance"><span class="pre">pydrake.planning.RobotClearance</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">robot_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">other_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">collision_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotCollisionType" title="pydrake.planning.RobotCollisionType"><span class="pre">pydrake.planning.RobotCollisionType</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jacobian</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.RobotClearance.Append" title="Permalink to this definition"></a></dt>
<dd><p>Appends one measurement to this table.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotClearance.collision_types">
<span class="sig-name descname"><span class="pre">collision_types</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotClearance" title="pydrake.planning.RobotClearance"><span class="pre">pydrake.planning.RobotClearance</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#pydrake.planning.RobotCollisionType" title="pydrake.planning.RobotCollisionType"><span class="pre">pydrake.planning.RobotCollisionType</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.RobotClearance.collision_types" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the vector of body collision types.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotClearance.distances">
<span class="sig-name descname"><span class="pre">distances</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotClearance" title="pydrake.planning.RobotClearance"><span class="pre">pydrake.planning.RobotClearance</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.RobotClearance.distances" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the vector of distances (<code class="docutils literal notranslate"><span class="pre">ϕᴼ(R)</span></code>).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotClearance.jacobians">
<span class="sig-name descname"><span class="pre">jacobians</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotClearance" title="pydrake.planning.RobotClearance"><span class="pre">pydrake.planning.RobotClearance</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.c_contiguous</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.RobotClearance.jacobians" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the vector of distance Jacobians (<code class="docutils literal notranslate"><span class="pre">Jqᵣ_ϕᴼ(R)</span></code>); the return type
is a readonly Eigen::Map with size() rows and num_positions()
columns.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotClearance.mutable_jacobians">
<span class="sig-name descname"><span class="pre">mutable_jacobians</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotClearance" title="pydrake.planning.RobotClearance"><span class="pre">pydrake.planning.RobotClearance</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.writeable</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.c_contiguous</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.RobotClearance.mutable_jacobians" title="Permalink to this definition"></a></dt>
<dd><p>(Advanced) The mutable flavor of jacobians().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotClearance.num_positions">
<span class="sig-name descname"><span class="pre">num_positions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotClearance" title="pydrake.planning.RobotClearance"><span class="pre">pydrake.planning.RobotClearance</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.planning.RobotClearance.num_positions" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the number of positions (i.e., columns) in jacobians().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotClearance.other_indices">
<span class="sig-name descname"><span class="pre">other_indices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotClearance" title="pydrake.planning.RobotClearance"><span class="pre">pydrake.planning.RobotClearance</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.RobotClearance.other_indices" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the vector of <em>other</em> body indices.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotClearance.Reserve">
<span class="sig-name descname"><span class="pre">Reserve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotClearance" title="pydrake.planning.RobotClearance"><span class="pre">pydrake.planning.RobotClearance</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.RobotClearance.Reserve" title="Permalink to this definition"></a></dt>
<dd><p>Ensures this object has storage for at least <code class="docutils literal notranslate"><span class="pre">size</span></code> rows.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotClearance.robot_indices">
<span class="sig-name descname"><span class="pre">robot_indices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotClearance" title="pydrake.planning.RobotClearance"><span class="pre">pydrake.planning.RobotClearance</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.multibody.tree.html#pydrake.multibody.tree.BodyIndex" title="pydrake.multibody.tree.BodyIndex"><span class="pre">pydrake.multibody.tree.BodyIndex</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.RobotClearance.robot_indices" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the vector of <em>robot</em> body indices.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotClearance.size">
<span class="sig-name descname"><span class="pre">size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotClearance" title="pydrake.planning.RobotClearance"><span class="pre">pydrake.planning.RobotClearance</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.planning.RobotClearance.size" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the number of distance measurements (rows in the table).</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.planning.RobotCollisionType">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.planning.</span></span><span class="sig-name descname"><span class="pre">RobotCollisionType</span></span><a class="headerlink" href="#pydrake.planning.RobotCollisionType" title="Permalink to this definition"></a></dt>
<dd><p>Enumerates these predicates (and their combinations): - is the robot
in collision with itself? - is the robot in collision with something
in the environment?</p>
<p>Members:</p>
<blockquote>
<div><p>kNoCollision :</p>
<p>kEnvironmentCollision :</p>
<p>kSelfCollision :</p>
<p>kEnvironmentAndSelfCollision :</p>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotCollisionType.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotCollisionType" title="pydrake.planning.RobotCollisionType"><span class="pre">pydrake.planning.RobotCollisionType</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.RobotCollisionType.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.planning.RobotCollisionType.kEnvironmentAndSelfCollision">
<span class="sig-name descname"><span class="pre">kEnvironmentAndSelfCollision</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;RobotCollisionType.kEnvironmentAndSelfCollision:</span> <span class="pre">3&gt;</span></em><a class="headerlink" href="#pydrake.planning.RobotCollisionType.kEnvironmentAndSelfCollision" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.planning.RobotCollisionType.kEnvironmentCollision">
<span class="sig-name descname"><span class="pre">kEnvironmentCollision</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;RobotCollisionType.kEnvironmentCollision:</span> <span class="pre">1&gt;</span></em><a class="headerlink" href="#pydrake.planning.RobotCollisionType.kEnvironmentCollision" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.planning.RobotCollisionType.kNoCollision">
<span class="sig-name descname"><span class="pre">kNoCollision</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;RobotCollisionType.kNoCollision:</span> <span class="pre">0&gt;</span></em><a class="headerlink" href="#pydrake.planning.RobotCollisionType.kNoCollision" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.planning.RobotCollisionType.kSelfCollision">
<span class="sig-name descname"><span class="pre">kSelfCollision</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;RobotCollisionType.kSelfCollision:</span> <span class="pre">2&gt;</span></em><a class="headerlink" href="#pydrake.planning.RobotCollisionType.kSelfCollision" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotCollisionType.MakeUpdated">
<span class="sig-name descname"><span class="pre">MakeUpdated</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotCollisionType" title="pydrake.planning.RobotCollisionType"><span class="pre">pydrake.planning.RobotCollisionType</span></a></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_environment_collision</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_self_collision</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.planning.RobotCollisionType" title="pydrake.planning.RobotCollisionType"><span class="pre">pydrake.planning.RobotCollisionType</span></a></span></span><a class="headerlink" href="#pydrake.planning.RobotCollisionType.MakeUpdated" title="Permalink to this definition"></a></dt>
<dd><p>Returns the RobotCollisionType value that reflects an incrementally different collision status versus the current value; the <code class="docutils literal notranslate"><span class="pre">self</span></code> object is unchanged. If <code class="docutils literal notranslate"><span class="pre">in_environment_collision</span></code> and/or <code class="docutils literal notranslate"><span class="pre">in_self_collision</span></code> is given, the return value will reflect those given value(s). This function subsumes the C++ free functions <code class="docutils literal notranslate"><span class="pre">SetInEnvironmentCollision()</span></code> and <code class="docutils literal notranslate"><span class="pre">SetInSelfCollision()</span></code>.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.planning.RobotCollisionType.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#pydrake.planning.RobotCollisionType.name" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.planning.RobotCollisionType.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#pydrake.planning.RobotCollisionType.value" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagram">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.planning.</span></span><span class="sig-name descname"><span class="pre">RobotDiagram</span></span><a class="headerlink" href="#pydrake.planning.RobotDiagram" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Diagram" title="pydrake.systems.framework.Diagram"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.Diagram</span></code></a></p>
<p>Storage for a combined diagram, plant, and scene graph.</p>
<p>This class is a convenient syntactic sugar, especially in C++ code
where it simplifies object lifetime tracking and downcasting of the
plant and scene graph references. It’s purpose is to serve as
planner-specific syntactic sugar for operating on a MultibodyPlant.
For other purposes (e.g., simulation), users should generally prefer
to just use a Diagram, instead.</p>
<p>Use RobotDiagramBuilder to construct a RobotDiagram.</p>
<p>By default, the ports exposed by a RobotDiagram are the set of all
ports provided by the plant and scene graph (excluding the internal
connections between the two). Refer to their individual overview
figures for details (see multibody::MultibodyPlant and
geometry::SceneGraph), or see the full list by viewing the
robot_diagram.GetGraphvizString().</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">plant_actuation&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">plant_applied_generalized_force&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">... etc ...&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>RobotDiagram</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; plant_state</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; ... etc ...</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; scene_graph_query</td></tr></table></td></tr></table><p>However, if the RobotDiagramBuilder::builder() was used to change the
diagram or if either the plant or scene graph were renamed, then no
ports will be exported by default. In that case, you can use the
builder to export any desired ports.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <a class="reference internal" href="#pydrake.planning.RobotDiagram_" title="pydrake.planning.RobotDiagram_"><code class="xref py py-class docutils literal notranslate"><span class="pre">RobotDiagram_</span></code></a>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagram.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.planning.RobotDiagram.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagram.mutable_plant_context">
<span class="sig-name descname"><span class="pre">mutable_plant_context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagram" title="pydrake.planning.RobotDiagram"><span class="pre">pydrake.planning.RobotDiagram</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">root_context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></span><a class="headerlink" href="#pydrake.planning.RobotDiagram.mutable_plant_context" title="Permalink to this definition"></a></dt>
<dd><p>Gets the contained plant’s context (mutable) out of the given root
context. Refer to drake::systems::System::GetMyContextFromRoot() to
understand <code class="docutils literal notranslate"><span class="pre">root_context</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the root_context is not a root context.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagram.mutable_scene_graph">
<span class="sig-name descname"><span class="pre">mutable_scene_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagram" title="pydrake.planning.RobotDiagram"><span class="pre">pydrake.planning.RobotDiagram</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.SceneGraph" title="pydrake.geometry.SceneGraph"><span class="pre">pydrake.geometry.SceneGraph</span></a></span></span><a class="headerlink" href="#pydrake.planning.RobotDiagram.mutable_scene_graph" title="Permalink to this definition"></a></dt>
<dd><p>Gets the contained scene graph (mutable).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagram.mutable_scene_graph_context">
<span class="sig-name descname"><span class="pre">mutable_scene_graph_context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagram" title="pydrake.planning.RobotDiagram"><span class="pre">pydrake.planning.RobotDiagram</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">root_context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></span><a class="headerlink" href="#pydrake.planning.RobotDiagram.mutable_scene_graph_context" title="Permalink to this definition"></a></dt>
<dd><p>Gets the contained scene graph’s context (mutable) out of the given
root context. Refer to drake::systems::System::GetMyContextFromRoot()
to understand <code class="docutils literal notranslate"><span class="pre">root_context</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the root_context is not a root context.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagram.plant">
<span class="sig-name descname"><span class="pre">plant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagram" title="pydrake.planning.RobotDiagram"><span class="pre">pydrake.planning.RobotDiagram</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.plant.html#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></span><a class="headerlink" href="#pydrake.planning.RobotDiagram.plant" title="Permalink to this definition"></a></dt>
<dd><p>Gets the contained plant (readonly).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagram.plant_context">
<span class="sig-name descname"><span class="pre">plant_context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagram" title="pydrake.planning.RobotDiagram"><span class="pre">pydrake.planning.RobotDiagram</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">root_context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></span><a class="headerlink" href="#pydrake.planning.RobotDiagram.plant_context" title="Permalink to this definition"></a></dt>
<dd><p>Gets the contained plant’s context (readonly) out of the given root
context. Refer to drake::systems::System::GetMyContextFromRoot() to
understand <code class="docutils literal notranslate"><span class="pre">root_context</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the root_context is not a root context.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagram.scene_graph">
<span class="sig-name descname"><span class="pre">scene_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagram" title="pydrake.planning.RobotDiagram"><span class="pre">pydrake.planning.RobotDiagram</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.SceneGraph" title="pydrake.geometry.SceneGraph"><span class="pre">pydrake.geometry.SceneGraph</span></a></span></span><a class="headerlink" href="#pydrake.planning.RobotDiagram.scene_graph" title="Permalink to this definition"></a></dt>
<dd><p>Gets the contained scene graph (readonly).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagram.scene_graph_context">
<span class="sig-name descname"><span class="pre">scene_graph_context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagram" title="pydrake.planning.RobotDiagram"><span class="pre">pydrake.planning.RobotDiagram</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">root_context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context" title="pydrake.systems.framework.Context"><span class="pre">pydrake.systems.framework.Context</span></a></span></span><a class="headerlink" href="#pydrake.planning.RobotDiagram.scene_graph_context" title="Permalink to this definition"></a></dt>
<dd><p>Gets the contained scene graph’s context (readonly) out of the given
root context. Refer to drake::systems::System::GetMyContextFromRoot()
to understand <code class="docutils literal notranslate"><span class="pre">root_context</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the root_context is not a root context.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagram_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.planning.</span></span><span class="sig-name descname"><span class="pre">RobotDiagram_</span></span><a class="headerlink" href="#pydrake.planning.RobotDiagram_" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">RobotDiagram_[float]</span></code>, <a class="reference internal" href="#pydrake.planning.RobotDiagram_-AutoDiffXd" title="pydrake.planning.RobotDiagram_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">RobotDiagram_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.planning.RobotDiagram_-Expression" title="pydrake.planning.RobotDiagram_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">RobotDiagram_[Expression]</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagram_-AutoDiffXd">
<span id="pydrake.planning.RobotDiagram_[AutoDiffXd]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.planning.</span></span><span class="sig-name descname"><span class="pre">RobotDiagram_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.planning.RobotDiagram_-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Diagram_-AutoDiffXd" title="pydrake.systems.framework.Diagram_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.Diagram_[AutoDiffXd]</span></code></a></p>
<p>Storage for a combined diagram, plant, and scene graph.</p>
<p>This class is a convenient syntactic sugar, especially in C++ code
where it simplifies object lifetime tracking and downcasting of the
plant and scene graph references. It’s purpose is to serve as
planner-specific syntactic sugar for operating on a MultibodyPlant.
For other purposes (e.g., simulation), users should generally prefer
to just use a Diagram, instead.</p>
<p>Use RobotDiagramBuilder to construct a RobotDiagram.</p>
<p>By default, the ports exposed by a RobotDiagram are the set of all
ports provided by the plant and scene graph (excluding the internal
connections between the two). Refer to their individual overview
figures for details (see multibody::MultibodyPlant and
geometry::SceneGraph), or see the full list by viewing the
robot_diagram.GetGraphvizString().</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">plant_actuation&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">plant_applied_generalized_force&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">... etc ...&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>RobotDiagram</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; plant_state</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; ... etc ...</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; scene_graph_query</td></tr></table></td></tr></table><p>However, if the RobotDiagramBuilder::builder() was used to change the
diagram or if either the plant or scene graph were renamed, then no
ports will be exported by default. In that case, you can use the
builder to export any desired ports.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagram_-AutoDiffXd-.__init__">
<span id="pydrake.planning.RobotDiagram_[AutoDiffXd].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.planning.RobotDiagram_-AutoDiffXd-.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagram_-AutoDiffXd-.mutable_plant_context">
<span id="pydrake.planning.RobotDiagram_[AutoDiffXd].mutable_plant_context"></span><span class="sig-name descname"><span class="pre">mutable_plant_context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagram_" title="pydrake.planning.RobotDiagram_"><span class="pre">pydrake.planning.RobotDiagram_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">root_context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.RobotDiagram_-AutoDiffXd-.mutable_plant_context" title="Permalink to this definition"></a></dt>
<dd><p>Gets the contained plant’s context (mutable) out of the given root
context. Refer to drake::systems::System::GetMyContextFromRoot() to
understand <code class="docutils literal notranslate"><span class="pre">root_context</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the root_context is not a root context.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagram_-AutoDiffXd-.mutable_scene_graph">
<span id="pydrake.planning.RobotDiagram_[AutoDiffXd].mutable_scene_graph"></span><span class="sig-name descname"><span class="pre">mutable_scene_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagram_" title="pydrake.planning.RobotDiagram_"><span class="pre">pydrake.planning.RobotDiagram_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.SceneGraph_" title="pydrake.geometry.SceneGraph_"><span class="pre">pydrake.geometry.SceneGraph_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.RobotDiagram_-AutoDiffXd-.mutable_scene_graph" title="Permalink to this definition"></a></dt>
<dd><p>Gets the contained scene graph (mutable).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagram_-AutoDiffXd-.mutable_scene_graph_context">
<span id="pydrake.planning.RobotDiagram_[AutoDiffXd].mutable_scene_graph_context"></span><span class="sig-name descname"><span class="pre">mutable_scene_graph_context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagram_" title="pydrake.planning.RobotDiagram_"><span class="pre">pydrake.planning.RobotDiagram_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">root_context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.RobotDiagram_-AutoDiffXd-.mutable_scene_graph_context" title="Permalink to this definition"></a></dt>
<dd><p>Gets the contained scene graph’s context (mutable) out of the given
root context. Refer to drake::systems::System::GetMyContextFromRoot()
to understand <code class="docutils literal notranslate"><span class="pre">root_context</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the root_context is not a root context.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagram_-AutoDiffXd-.plant">
<span id="pydrake.planning.RobotDiagram_[AutoDiffXd].plant"></span><span class="sig-name descname"><span class="pre">plant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagram_" title="pydrake.planning.RobotDiagram_"><span class="pre">pydrake.planning.RobotDiagram_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.plant.html#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.RobotDiagram_-AutoDiffXd-.plant" title="Permalink to this definition"></a></dt>
<dd><p>Gets the contained plant (readonly).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagram_-AutoDiffXd-.plant_context">
<span id="pydrake.planning.RobotDiagram_[AutoDiffXd].plant_context"></span><span class="sig-name descname"><span class="pre">plant_context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagram_" title="pydrake.planning.RobotDiagram_"><span class="pre">pydrake.planning.RobotDiagram_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">root_context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.RobotDiagram_-AutoDiffXd-.plant_context" title="Permalink to this definition"></a></dt>
<dd><p>Gets the contained plant’s context (readonly) out of the given root
context. Refer to drake::systems::System::GetMyContextFromRoot() to
understand <code class="docutils literal notranslate"><span class="pre">root_context</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the root_context is not a root context.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagram_-AutoDiffXd-.scene_graph">
<span id="pydrake.planning.RobotDiagram_[AutoDiffXd].scene_graph"></span><span class="sig-name descname"><span class="pre">scene_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagram_" title="pydrake.planning.RobotDiagram_"><span class="pre">pydrake.planning.RobotDiagram_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.SceneGraph_" title="pydrake.geometry.SceneGraph_"><span class="pre">pydrake.geometry.SceneGraph_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.RobotDiagram_-AutoDiffXd-.scene_graph" title="Permalink to this definition"></a></dt>
<dd><p>Gets the contained scene graph (readonly).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagram_-AutoDiffXd-.scene_graph_context">
<span id="pydrake.planning.RobotDiagram_[AutoDiffXd].scene_graph_context"></span><span class="sig-name descname"><span class="pre">scene_graph_context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagram_" title="pydrake.planning.RobotDiagram_"><span class="pre">pydrake.planning.RobotDiagram_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">root_context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.RobotDiagram_-AutoDiffXd-.scene_graph_context" title="Permalink to this definition"></a></dt>
<dd><p>Gets the contained scene graph’s context (readonly) out of the given
root context. Refer to drake::systems::System::GetMyContextFromRoot()
to understand <code class="docutils literal notranslate"><span class="pre">root_context</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the root_context is not a root context.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagram_-Expression">
<span id="pydrake.planning.RobotDiagram_[Expression]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.planning.</span></span><span class="sig-name descname"><span class="pre">RobotDiagram_[Expression]</span></span><a class="headerlink" href="#pydrake.planning.RobotDiagram_-Expression" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Diagram_-Expression" title="pydrake.systems.framework.Diagram_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.Diagram_[Expression]</span></code></a></p>
<p>Storage for a combined diagram, plant, and scene graph.</p>
<p>This class is a convenient syntactic sugar, especially in C++ code
where it simplifies object lifetime tracking and downcasting of the
plant and scene graph references. It’s purpose is to serve as
planner-specific syntactic sugar for operating on a MultibodyPlant.
For other purposes (e.g., simulation), users should generally prefer
to just use a Diagram, instead.</p>
<p>Use RobotDiagramBuilder to construct a RobotDiagram.</p>
<p>By default, the ports exposed by a RobotDiagram are the set of all
ports provided by the plant and scene graph (excluding the internal
connections between the two). Refer to their individual overview
figures for details (see multibody::MultibodyPlant and
geometry::SceneGraph), or see the full list by viewing the
robot_diagram.GetGraphvizString().</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">plant_actuation&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">plant_applied_generalized_force&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">... etc ...&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>RobotDiagram</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; plant_state</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; ... etc ...</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; scene_graph_query</td></tr></table></td></tr></table><p>However, if the RobotDiagramBuilder::builder() was used to change the
diagram or if either the plant or scene graph were renamed, then no
ports will be exported by default. In that case, you can use the
builder to export any desired ports.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagram_-Expression-.__init__">
<span id="pydrake.planning.RobotDiagram_[Expression].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.planning.RobotDiagram_-Expression-.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagram_-Expression-.mutable_plant_context">
<span id="pydrake.planning.RobotDiagram_[Expression].mutable_plant_context"></span><span class="sig-name descname"><span class="pre">mutable_plant_context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagram_" title="pydrake.planning.RobotDiagram_"><span class="pre">pydrake.planning.RobotDiagram_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">root_context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.RobotDiagram_-Expression-.mutable_plant_context" title="Permalink to this definition"></a></dt>
<dd><p>Gets the contained plant’s context (mutable) out of the given root
context. Refer to drake::systems::System::GetMyContextFromRoot() to
understand <code class="docutils literal notranslate"><span class="pre">root_context</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the root_context is not a root context.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagram_-Expression-.mutable_scene_graph">
<span id="pydrake.planning.RobotDiagram_[Expression].mutable_scene_graph"></span><span class="sig-name descname"><span class="pre">mutable_scene_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagram_" title="pydrake.planning.RobotDiagram_"><span class="pre">pydrake.planning.RobotDiagram_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.SceneGraph_" title="pydrake.geometry.SceneGraph_"><span class="pre">pydrake.geometry.SceneGraph_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.RobotDiagram_-Expression-.mutable_scene_graph" title="Permalink to this definition"></a></dt>
<dd><p>Gets the contained scene graph (mutable).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagram_-Expression-.mutable_scene_graph_context">
<span id="pydrake.planning.RobotDiagram_[Expression].mutable_scene_graph_context"></span><span class="sig-name descname"><span class="pre">mutable_scene_graph_context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagram_" title="pydrake.planning.RobotDiagram_"><span class="pre">pydrake.planning.RobotDiagram_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">root_context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.RobotDiagram_-Expression-.mutable_scene_graph_context" title="Permalink to this definition"></a></dt>
<dd><p>Gets the contained scene graph’s context (mutable) out of the given
root context. Refer to drake::systems::System::GetMyContextFromRoot()
to understand <code class="docutils literal notranslate"><span class="pre">root_context</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the root_context is not a root context.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagram_-Expression-.plant">
<span id="pydrake.planning.RobotDiagram_[Expression].plant"></span><span class="sig-name descname"><span class="pre">plant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagram_" title="pydrake.planning.RobotDiagram_"><span class="pre">pydrake.planning.RobotDiagram_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.plant.html#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.RobotDiagram_-Expression-.plant" title="Permalink to this definition"></a></dt>
<dd><p>Gets the contained plant (readonly).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagram_-Expression-.plant_context">
<span id="pydrake.planning.RobotDiagram_[Expression].plant_context"></span><span class="sig-name descname"><span class="pre">plant_context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagram_" title="pydrake.planning.RobotDiagram_"><span class="pre">pydrake.planning.RobotDiagram_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">root_context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.RobotDiagram_-Expression-.plant_context" title="Permalink to this definition"></a></dt>
<dd><p>Gets the contained plant’s context (readonly) out of the given root
context. Refer to drake::systems::System::GetMyContextFromRoot() to
understand <code class="docutils literal notranslate"><span class="pre">root_context</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the root_context is not a root context.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagram_-Expression-.scene_graph">
<span id="pydrake.planning.RobotDiagram_[Expression].scene_graph"></span><span class="sig-name descname"><span class="pre">scene_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagram_" title="pydrake.planning.RobotDiagram_"><span class="pre">pydrake.planning.RobotDiagram_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.SceneGraph_" title="pydrake.geometry.SceneGraph_"><span class="pre">pydrake.geometry.SceneGraph_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.RobotDiagram_-Expression-.scene_graph" title="Permalink to this definition"></a></dt>
<dd><p>Gets the contained scene graph (readonly).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagram_-Expression-.scene_graph_context">
<span id="pydrake.planning.RobotDiagram_[Expression].scene_graph_context"></span><span class="sig-name descname"><span class="pre">scene_graph_context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagram_" title="pydrake.planning.RobotDiagram_"><span class="pre">pydrake.planning.RobotDiagram_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">root_context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.RobotDiagram_-Expression-.scene_graph_context" title="Permalink to this definition"></a></dt>
<dd><p>Gets the contained scene graph’s context (readonly) out of the given
root context. Refer to drake::systems::System::GetMyContextFromRoot()
to understand <code class="docutils literal notranslate"><span class="pre">root_context</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the root_context is not a root context.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagramBuilder">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.planning.</span></span><span class="sig-name descname"><span class="pre">RobotDiagramBuilder</span></span><a class="headerlink" href="#pydrake.planning.RobotDiagramBuilder" title="Permalink to this definition"></a></dt>
<dd><p>Storage for a combined diagram builder, plant, and scene graph. When T
== double, a parser (and package map) is also available.</p>
<p>This class is a convenient syntactic sugar to help build a robot
diagram, especially in C++ code where it simplifies object lifetime
tracking and downcasting of the plant and scene graph references.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <a class="reference internal" href="#pydrake.planning.RobotDiagramBuilder_" title="pydrake.planning.RobotDiagramBuilder_"><code class="xref py py-class docutils literal notranslate"><span class="pre">RobotDiagramBuilder_</span></code></a>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagramBuilder.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagramBuilder" title="pydrake.planning.RobotDiagramBuilder"><span class="pre">pydrake.planning.RobotDiagramBuilder</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_step</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.RobotDiagramBuilder.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Constructs with the specified time step for the contained plant.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time_step</span></code>:</dt><dd><p>Governs whether the MultibodyPlant is modeled as a discrete system
(<code class="docutils literal notranslate"><span class="pre">time_step</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>) or as a continuous system (<code class="docutils literal notranslate"><span class="pre">time_step</span> <span class="pre">=</span> <span class="pre">0</span></code>).
See multibody_simulation for further details. The default here
matches the default value from multibody::MultibodyPlantConfig.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagramBuilder.Build">
<span class="sig-name descname"><span class="pre">Build</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagramBuilder" title="pydrake.planning.RobotDiagramBuilder"><span class="pre">pydrake.planning.RobotDiagramBuilder</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.planning.RobotDiagram" title="pydrake.planning.RobotDiagram"><span class="pre">pydrake.planning.RobotDiagram</span></a></span></span><a class="headerlink" href="#pydrake.planning.RobotDiagramBuilder.Build" title="Permalink to this definition"></a></dt>
<dd><p>Builds the diagram and returns the diagram plus plant and scene graph
in a RobotDiagram. The plant will be finalized during this function,
unless it’s already been finalized.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>exception when IsDiagramBuilt</strong><strong>(</strong><strong>) </strong><strong>already.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagramBuilder.builder">
<span class="sig-name descname"><span class="pre">builder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagramBuilder" title="pydrake.planning.RobotDiagramBuilder"><span class="pre">pydrake.planning.RobotDiagramBuilder</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.DiagramBuilder" title="pydrake.systems.framework.DiagramBuilder"><span class="pre">pydrake.systems.framework.DiagramBuilder</span></a></span></span><a class="headerlink" href="#pydrake.planning.RobotDiagramBuilder.builder" title="Permalink to this definition"></a></dt>
<dd><p>Gets the contained DiagramBuilder (mutable). Do not call Build() on
the return value; instead, call Build() on this.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>exception when IsDiagramBuilt</strong><strong>(</strong><strong>) </strong><strong>already.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagramBuilder.IsDiagramBuilt">
<span class="sig-name descname"><span class="pre">IsDiagramBuilt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagramBuilder" title="pydrake.planning.RobotDiagramBuilder"><span class="pre">pydrake.planning.RobotDiagramBuilder</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.planning.RobotDiagramBuilder.IsDiagramBuilt" title="Permalink to this definition"></a></dt>
<dd><p>Checks if the diagram has already been built.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagramBuilder.parser">
<span class="sig-name descname"><span class="pre">parser</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagramBuilder" title="pydrake.planning.RobotDiagramBuilder"><span class="pre">pydrake.planning.RobotDiagramBuilder</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.parsing.html#pydrake.multibody.parsing.Parser" title="pydrake.multibody.parsing.Parser"><span class="pre">pydrake.multibody.parsing.Parser</span></a></span></span><a class="headerlink" href="#pydrake.planning.RobotDiagramBuilder.parser" title="Permalink to this definition"></a></dt>
<dd><p>Gets the contained Parser (mutable).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>exception when IsDiagramBuilt</strong><strong>(</strong><strong>) </strong><strong>already.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagramBuilder.plant">
<span class="sig-name descname"><span class="pre">plant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagramBuilder" title="pydrake.planning.RobotDiagramBuilder"><span class="pre">pydrake.planning.RobotDiagramBuilder</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.plant.html#pydrake.multibody.plant.MultibodyPlant" title="pydrake.multibody.plant.MultibodyPlant"><span class="pre">pydrake.multibody.plant.MultibodyPlant</span></a></span></span><a class="headerlink" href="#pydrake.planning.RobotDiagramBuilder.plant" title="Permalink to this definition"></a></dt>
<dd><p>Gets the contained plant (mutable).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>exception when IsDiagramBuilt</strong><strong>(</strong><strong>) </strong><strong>already.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagramBuilder.scene_graph">
<span class="sig-name descname"><span class="pre">scene_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagramBuilder" title="pydrake.planning.RobotDiagramBuilder"><span class="pre">pydrake.planning.RobotDiagramBuilder</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.SceneGraph" title="pydrake.geometry.SceneGraph"><span class="pre">pydrake.geometry.SceneGraph</span></a></span></span><a class="headerlink" href="#pydrake.planning.RobotDiagramBuilder.scene_graph" title="Permalink to this definition"></a></dt>
<dd><p>Gets the contained scene graph (mutable).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>exception when IsDiagramBuilt</strong><strong>(</strong><strong>) </strong><strong>already.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagramBuilder_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.planning.</span></span><span class="sig-name descname"><span class="pre">RobotDiagramBuilder_</span></span><a class="headerlink" href="#pydrake.planning.RobotDiagramBuilder_" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">RobotDiagramBuilder_[float]</span></code>, <a class="reference internal" href="#pydrake.planning.RobotDiagramBuilder_-AutoDiffXd" title="pydrake.planning.RobotDiagramBuilder_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">RobotDiagramBuilder_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.planning.RobotDiagramBuilder_-Expression" title="pydrake.planning.RobotDiagramBuilder_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">RobotDiagramBuilder_[Expression]</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagramBuilder_-AutoDiffXd">
<span id="pydrake.planning.RobotDiagramBuilder_[AutoDiffXd]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.planning.</span></span><span class="sig-name descname"><span class="pre">RobotDiagramBuilder_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.planning.RobotDiagramBuilder_-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><p>Storage for a combined diagram builder, plant, and scene graph. When T
== double, a parser (and package map) is also available.</p>
<p>This class is a convenient syntactic sugar to help build a robot
diagram, especially in C++ code where it simplifies object lifetime
tracking and downcasting of the plant and scene graph references.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagramBuilder_-AutoDiffXd-.__init__">
<span id="pydrake.planning.RobotDiagramBuilder_[AutoDiffXd].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagramBuilder_" title="pydrake.planning.RobotDiagramBuilder_"><span class="pre">pydrake.planning.RobotDiagramBuilder_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_step</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.RobotDiagramBuilder_-AutoDiffXd-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Constructs with the specified time step for the contained plant.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time_step</span></code>:</dt><dd><p>Governs whether the MultibodyPlant is modeled as a discrete system
(<code class="docutils literal notranslate"><span class="pre">time_step</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>) or as a continuous system (<code class="docutils literal notranslate"><span class="pre">time_step</span> <span class="pre">=</span> <span class="pre">0</span></code>).
See multibody_simulation for further details. The default here
matches the default value from multibody::MultibodyPlantConfig.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagramBuilder_-AutoDiffXd-.Build">
<span id="pydrake.planning.RobotDiagramBuilder_[AutoDiffXd].Build"></span><span class="sig-name descname"><span class="pre">Build</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagramBuilder_" title="pydrake.planning.RobotDiagramBuilder_"><span class="pre">pydrake.planning.RobotDiagramBuilder_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.planning.RobotDiagram_" title="pydrake.planning.RobotDiagram_"><span class="pre">pydrake.planning.RobotDiagram_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.RobotDiagramBuilder_-AutoDiffXd-.Build" title="Permalink to this definition"></a></dt>
<dd><p>Builds the diagram and returns the diagram plus plant and scene graph
in a RobotDiagram. The plant will be finalized during this function,
unless it’s already been finalized.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>exception when IsDiagramBuilt</strong><strong>(</strong><strong>) </strong><strong>already.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagramBuilder_-AutoDiffXd-.builder">
<span id="pydrake.planning.RobotDiagramBuilder_[AutoDiffXd].builder"></span><span class="sig-name descname"><span class="pre">builder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagramBuilder_" title="pydrake.planning.RobotDiagramBuilder_"><span class="pre">pydrake.planning.RobotDiagramBuilder_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.DiagramBuilder_" title="pydrake.systems.framework.DiagramBuilder_"><span class="pre">pydrake.systems.framework.DiagramBuilder_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.RobotDiagramBuilder_-AutoDiffXd-.builder" title="Permalink to this definition"></a></dt>
<dd><p>Gets the contained DiagramBuilder (mutable). Do not call Build() on
the return value; instead, call Build() on this.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>exception when IsDiagramBuilt</strong><strong>(</strong><strong>) </strong><strong>already.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagramBuilder_-AutoDiffXd-.IsDiagramBuilt">
<span id="pydrake.planning.RobotDiagramBuilder_[AutoDiffXd].IsDiagramBuilt"></span><span class="sig-name descname"><span class="pre">IsDiagramBuilt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagramBuilder_" title="pydrake.planning.RobotDiagramBuilder_"><span class="pre">pydrake.planning.RobotDiagramBuilder_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.planning.RobotDiagramBuilder_-AutoDiffXd-.IsDiagramBuilt" title="Permalink to this definition"></a></dt>
<dd><p>Checks if the diagram has already been built.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagramBuilder_-AutoDiffXd-.plant">
<span id="pydrake.planning.RobotDiagramBuilder_[AutoDiffXd].plant"></span><span class="sig-name descname"><span class="pre">plant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagramBuilder_" title="pydrake.planning.RobotDiagramBuilder_"><span class="pre">pydrake.planning.RobotDiagramBuilder_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.plant.html#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.RobotDiagramBuilder_-AutoDiffXd-.plant" title="Permalink to this definition"></a></dt>
<dd><p>Gets the contained plant (mutable).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>exception when IsDiagramBuilt</strong><strong>(</strong><strong>) </strong><strong>already.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagramBuilder_-AutoDiffXd-.scene_graph">
<span id="pydrake.planning.RobotDiagramBuilder_[AutoDiffXd].scene_graph"></span><span class="sig-name descname"><span class="pre">scene_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagramBuilder_" title="pydrake.planning.RobotDiagramBuilder_"><span class="pre">pydrake.planning.RobotDiagramBuilder_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.SceneGraph_" title="pydrake.geometry.SceneGraph_"><span class="pre">pydrake.geometry.SceneGraph_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.RobotDiagramBuilder_-AutoDiffXd-.scene_graph" title="Permalink to this definition"></a></dt>
<dd><p>Gets the contained scene graph (mutable).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>exception when IsDiagramBuilt</strong><strong>(</strong><strong>) </strong><strong>already.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagramBuilder_-Expression">
<span id="pydrake.planning.RobotDiagramBuilder_[Expression]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.planning.</span></span><span class="sig-name descname"><span class="pre">RobotDiagramBuilder_[Expression]</span></span><a class="headerlink" href="#pydrake.planning.RobotDiagramBuilder_-Expression" title="Permalink to this definition"></a></dt>
<dd><p>Storage for a combined diagram builder, plant, and scene graph. When T
== double, a parser (and package map) is also available.</p>
<p>This class is a convenient syntactic sugar to help build a robot
diagram, especially in C++ code where it simplifies object lifetime
tracking and downcasting of the plant and scene graph references.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagramBuilder_-Expression-.__init__">
<span id="pydrake.planning.RobotDiagramBuilder_[Expression].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagramBuilder_" title="pydrake.planning.RobotDiagramBuilder_"><span class="pre">pydrake.planning.RobotDiagramBuilder_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_step</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.RobotDiagramBuilder_-Expression-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Constructs with the specified time step for the contained plant.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time_step</span></code>:</dt><dd><p>Governs whether the MultibodyPlant is modeled as a discrete system
(<code class="docutils literal notranslate"><span class="pre">time_step</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>) or as a continuous system (<code class="docutils literal notranslate"><span class="pre">time_step</span> <span class="pre">=</span> <span class="pre">0</span></code>).
See multibody_simulation for further details. The default here
matches the default value from multibody::MultibodyPlantConfig.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagramBuilder_-Expression-.Build">
<span id="pydrake.planning.RobotDiagramBuilder_[Expression].Build"></span><span class="sig-name descname"><span class="pre">Build</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagramBuilder_" title="pydrake.planning.RobotDiagramBuilder_"><span class="pre">pydrake.planning.RobotDiagramBuilder_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.planning.RobotDiagram_" title="pydrake.planning.RobotDiagram_"><span class="pre">pydrake.planning.RobotDiagram_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.RobotDiagramBuilder_-Expression-.Build" title="Permalink to this definition"></a></dt>
<dd><p>Builds the diagram and returns the diagram plus plant and scene graph
in a RobotDiagram. The plant will be finalized during this function,
unless it’s already been finalized.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>exception when IsDiagramBuilt</strong><strong>(</strong><strong>) </strong><strong>already.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagramBuilder_-Expression-.builder">
<span id="pydrake.planning.RobotDiagramBuilder_[Expression].builder"></span><span class="sig-name descname"><span class="pre">builder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagramBuilder_" title="pydrake.planning.RobotDiagramBuilder_"><span class="pre">pydrake.planning.RobotDiagramBuilder_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.DiagramBuilder_" title="pydrake.systems.framework.DiagramBuilder_"><span class="pre">pydrake.systems.framework.DiagramBuilder_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.RobotDiagramBuilder_-Expression-.builder" title="Permalink to this definition"></a></dt>
<dd><p>Gets the contained DiagramBuilder (mutable). Do not call Build() on
the return value; instead, call Build() on this.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>exception when IsDiagramBuilt</strong><strong>(</strong><strong>) </strong><strong>already.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagramBuilder_-Expression-.IsDiagramBuilt">
<span id="pydrake.planning.RobotDiagramBuilder_[Expression].IsDiagramBuilt"></span><span class="sig-name descname"><span class="pre">IsDiagramBuilt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagramBuilder_" title="pydrake.planning.RobotDiagramBuilder_"><span class="pre">pydrake.planning.RobotDiagramBuilder_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.planning.RobotDiagramBuilder_-Expression-.IsDiagramBuilt" title="Permalink to this definition"></a></dt>
<dd><p>Checks if the diagram has already been built.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagramBuilder_-Expression-.plant">
<span id="pydrake.planning.RobotDiagramBuilder_[Expression].plant"></span><span class="sig-name descname"><span class="pre">plant</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagramBuilder_" title="pydrake.planning.RobotDiagramBuilder_"><span class="pre">pydrake.planning.RobotDiagramBuilder_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.multibody.plant.html#pydrake.multibody.plant.MultibodyPlant_" title="pydrake.multibody.plant.MultibodyPlant_"><span class="pre">pydrake.multibody.plant.MultibodyPlant_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.RobotDiagramBuilder_-Expression-.plant" title="Permalink to this definition"></a></dt>
<dd><p>Gets the contained plant (mutable).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>exception when IsDiagramBuilt</strong><strong>(</strong><strong>) </strong><strong>already.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.RobotDiagramBuilder_-Expression-.scene_graph">
<span id="pydrake.planning.RobotDiagramBuilder_[Expression].scene_graph"></span><span class="sig-name descname"><span class="pre">scene_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagramBuilder_" title="pydrake.planning.RobotDiagramBuilder_"><span class="pre">pydrake.planning.RobotDiagramBuilder_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.geometry.html#pydrake.geometry.SceneGraph_" title="pydrake.geometry.SceneGraph_"><span class="pre">pydrake.geometry.SceneGraph_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.RobotDiagramBuilder_-Expression-.scene_graph" title="Permalink to this definition"></a></dt>
<dd><p>Gets the contained scene graph (mutable).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>exception when IsDiagramBuilt</strong><strong>(</strong><strong>) </strong><strong>already.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.planning.SceneGraphCollisionChecker">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.planning.</span></span><span class="sig-name descname"><span class="pre">SceneGraphCollisionChecker</span></span><a class="headerlink" href="#pydrake.planning.SceneGraphCollisionChecker" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.planning.CollisionChecker</span></code></a></p>
<p>An implementation of CollisionChecker that uses SceneGraph to provide
collision checks. Its behavior and limitations are exactly those of
SceneGraph, e.g., in terms of what kinds of geometries can be
collided.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.SceneGraphCollisionChecker.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.SceneGraphCollisionChecker" title="pydrake.planning.SceneGraphCollisionChecker"><span class="pre">pydrake.planning.SceneGraphCollisionChecker</span></a></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagram" title="pydrake.planning.RobotDiagram"><span class="pre">pydrake.planning.RobotDiagram</span></a></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.SceneGraphCollisionChecker.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Creates a new checker with the given params.</p>
<p>See <a class="reference internal" href="#pydrake.planning.CollisionCheckerParams" title="pydrake.planning.CollisionCheckerParams"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.planning.CollisionCheckerParams</span></code></a> for the list of properties available here as kwargs.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.planning.UnimplementedCollisionChecker">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.planning.</span></span><span class="sig-name descname"><span class="pre">UnimplementedCollisionChecker</span></span><a class="headerlink" href="#pydrake.planning.UnimplementedCollisionChecker" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.planning.CollisionChecker</span></code></a></p>
<p>A concrete collision checker implementation that throws an exception
for every virtual function hook. This might be useful for unit testing
or for deriving your own collision checker without providing for the
full suite of operations.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.UnimplementedCollisionChecker.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.UnimplementedCollisionChecker" title="pydrake.planning.UnimplementedCollisionChecker"><span class="pre">pydrake.planning.UnimplementedCollisionChecker</span></a></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.RobotDiagram" title="pydrake.planning.RobotDiagram"><span class="pre">pydrake.planning.RobotDiagram</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">supports_parallel_checking</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.UnimplementedCollisionChecker.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a checker.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">supports_parallel_checking</span></code>:</dt><dd><p>will serve as the return value of the
CollisionChecker::SupportsParallelChecking() function.</p>
</dd>
</dl>
<p>See <a class="reference internal" href="#pydrake.planning.CollisionCheckerParams" title="pydrake.planning.CollisionCheckerParams"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.planning.CollisionCheckerParams</span></code></a> for the list of properties available here as kwargs.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.planning.VisibilityGraph">
<span class="sig-prename descclassname"><span class="pre">pydrake.planning.</span></span><span class="sig-name descname"><span class="pre">VisibilityGraph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">checker</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.CollisionChecker" title="pydrake.planning.CollisionChecker"><span class="pre">pydrake.planning.CollisionChecker</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">points</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parallelize</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.common.html#pydrake.common.Parallelism" title="pydrake.common.Parallelism"><span class="pre">pydrake.common.Parallelism</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">scipy.sparse.csc_matrix</span><span class="p"><span class="pre">[</span></span><span class="pre">bool</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.VisibilityGraph" title="Permalink to this definition"></a></dt>
<dd><p>Given some number of sampled points in the configuration space of
<code class="docutils literal notranslate"><span class="pre">checker`'s</span> <span class="pre">plant(),</span> <span class="pre">computes</span> <span class="pre">the</span> <span class="pre">&quot;visibility</span> <span class="pre">graph&quot;</span> <span class="pre">--</span> <span class="pre">two</span> <span class="pre">`points</span></code>
have an edge between them if the line segment connecting them is
collision free. See CollisionChecker documentation for more
information on how edge collision checks are performed.</p>
<p>Note that this method assumes the collision checker has symmetric
behavior (i.e. checking edge (q1, q2) is the same as checking edge
(q2, q1)). This is true for many collision checkers (e.g. those using
LinearDistanceAndInterpolationProvider, which is the default), but
some more complex spaces with non-linear interpolation (e.g. a Dubin’s
car) are not symmetric.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">parallelize</span></code> specifies more than one thread, then the
CollisionCheckerParams::distance_and_interpolation_provider for
<code class="docutils literal notranslate"><span class="pre">checker</span></code> must be implemented in C++, either by providing the C++
implementation directly directly or by using the default provider.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the adjacency matrix, A(i,j) == true iff points.col(i) is visible
from points.col(j). A is always symmetric.</p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>points.rows() == total number of positions in the collision
checker plant.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.planning.ZmpPlanner">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.planning.</span></span><span class="sig-name descname"><span class="pre">ZmpPlanner</span></span><a class="headerlink" href="#pydrake.planning.ZmpPlanner" title="Permalink to this definition"></a></dt>
<dd><p>Given a desired two dimensional (X and Y) zero-moment point (ZMP)
trajectory parameterized as a piecewise polynomial, an optimal center
of mass (CoM) trajectory is planned using a linear inverted pendulum
model (LIPM). A second order value function (optimal cost-to-go) and a
linear policy are also computed alongside the optimal trajectory. The
system dynamics for the X and Y directions are decoupled, however, we
plan the XY motion together for convenience.</p>
<p>Let <span class="math notranslate nohighlight">\(c\)</span> be the CoM position, the state of the system, <span class="math notranslate nohighlight">\(x\)</span>,
is <span class="math notranslate nohighlight">\([c; \dot{c}]\)</span>, the control, <span class="math notranslate nohighlight">\(u = \ddot{c}\)</span>, and
<span class="math notranslate nohighlight">\(y\)</span> represents the center of pressure (CoP). For the X
direction, the LIPM dynamics is:</p>
<div class="math notranslate nohighlight">
\[y = c - \frac{z}{g} * u,\]</div>
<p>where <span class="math notranslate nohighlight">\(g\)</span> is the gravity constant and <span class="math notranslate nohighlight">\(z\)</span> is the CoM
height. <span class="math notranslate nohighlight">\(z\)</span> is assumed to be constant in LIPM. The full dynamics
can also be written in the matrix form as:</p>
<div class="math notranslate nohighlight">
\[\dot{x} = A x + B u \\]</div>
<p>y = C x + D u</p>
<p>The one step cost function <span class="math notranslate nohighlight">\(L\)</span> is defined as:</p>
<div class="math notranslate nohighlight">
\[L(y, u, t) = (y - y_d(t))^T Q_y (y - y_d(t)) + u^T R u,\]</div>
<p>where <span class="math notranslate nohighlight">\(Q_y\)</span> and <span class="math notranslate nohighlight">\(R\)</span> are weighting matrices, and
<span class="math notranslate nohighlight">\(y_d(t)\)</span> is the desired ZMP trajectory at time <span class="math notranslate nohighlight">\(t\)</span>.</p>
<p>The value function is defined as</p>
<div class="math notranslate nohighlight">
\[V(x, t) = \min_{u[t:t_f]} \bar{x}(t_f)^T S \bar{x}(t_f)\]</div>
<ul class="simple">
<li><p>int_{t}^{t_f} L(y, u, tau) dtau,</p></li>
</ul>
<p>subject to the dynamics, and <span class="math notranslate nohighlight">\(t_f\)</span> is the last time in the
desired ZMP trajectory, <span class="math notranslate nohighlight">\(\bar{x} = [c - y_d(t_f); \dot{c}]\)</span>,
<span class="math notranslate nohighlight">\(S\)</span> is the quadratic term from the infinite horizon continuous
time LQR solution solved with the same dynamics and one step cost
function.</p>
<p>For this problem, <span class="math notranslate nohighlight">\(V\)</span> is known to have a quadratic form of:</p>
<div class="math notranslate nohighlight">
\[V(x, t) = \bar{x}^T V_{xx} \bar{x} + \bar{x}^T V_x(t) + V_0(t),\]</div>
<p>and the corresponding optimal control policy, <span class="math notranslate nohighlight">\(u^*\)</span>, is linear
w.r.t. to <span class="math notranslate nohighlight">\(x\)</span>:</p>
<div class="math notranslate nohighlight">
\[u^*(x, t) = K \bar{x} + u_0(t).\]</div>
<p>See the following reference for more details about the algorithm:</p>
<p>[1] R. Tedrake, S. Kuindersma, R. Deits and K. Miura, “A closed-form
solution for real-time ZMP gait generation and feedback
stabilization,” 2015 IEEE-RAS 15th International Conference on
Humanoid Robots (Humanoids), Seoul, 2015, pp. 936-940.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.ZmpPlanner.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.ZmpPlanner" title="pydrake.planning.ZmpPlanner"><span class="pre">pydrake.planning.ZmpPlanner</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.ZmpPlanner.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.ZmpPlanner.comdd_to_cop">
<span class="sig-name descname"><span class="pre">comdd_to_cop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.ZmpPlanner" title="pydrake.planning.ZmpPlanner"><span class="pre">pydrake.planning.ZmpPlanner</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">4</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">u</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">2</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">2</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.ZmpPlanner.comdd_to_cop" title="Permalink to this definition"></a></dt>
<dd><p>Converts CoM acceleration to center of pressure (CoP) using cop = C *
x + D * u, which is equivalent to cop = com - z / g * comdd Should
only be called after Plan is called.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">x</span></code>:</dt><dd><p>CoM position and velocity</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">u</span></code>:</dt><dd><p>CoM acceleration</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>center of pressure (CoP)</p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Plan() has already been called.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.ZmpPlanner.ComputeOptimalCoMdd">
<span class="sig-name descname"><span class="pre">ComputeOptimalCoMdd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.ZmpPlanner" title="pydrake.planning.ZmpPlanner"><span class="pre">pydrake.planning.ZmpPlanner</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">4</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">2</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.ZmpPlanner.ComputeOptimalCoMdd" title="Permalink to this definition"></a></dt>
<dd><p>Computes the optimal control (CoM acceleration) at <code class="docutils literal notranslate"><span class="pre">time</span></code> given CoM
state <code class="docutils literal notranslate"><span class="pre">x</span></code> using the linear policy.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time</span></code>:</dt><dd><p>Current time.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">x</span></code>:</dt><dd><p>Current state.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Optimal CoMdd.</p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Plan() has already been called.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.ZmpPlanner.get_A">
<span class="sig-name descname"><span class="pre">get_A</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.ZmpPlanner" title="pydrake.planning.ZmpPlanner"><span class="pre">pydrake.planning.ZmpPlanner</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">4</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">4</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.ZmpPlanner.get_A" title="Permalink to this definition"></a></dt>
<dd><p>Getter for A matrix.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Plan() has already been called.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.ZmpPlanner.get_B">
<span class="sig-name descname"><span class="pre">get_B</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.ZmpPlanner" title="pydrake.planning.ZmpPlanner"><span class="pre">pydrake.planning.ZmpPlanner</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">4</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">2</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.ZmpPlanner.get_B" title="Permalink to this definition"></a></dt>
<dd><p>Getter for B matrix.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Plan() has already been called.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.ZmpPlanner.get_C">
<span class="sig-name descname"><span class="pre">get_C</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.ZmpPlanner" title="pydrake.planning.ZmpPlanner"><span class="pre">pydrake.planning.ZmpPlanner</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">2</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">4</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.ZmpPlanner.get_C" title="Permalink to this definition"></a></dt>
<dd><p>Getter for C matrix.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Plan() has already been called.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.ZmpPlanner.get_D">
<span class="sig-name descname"><span class="pre">get_D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.ZmpPlanner" title="pydrake.planning.ZmpPlanner"><span class="pre">pydrake.planning.ZmpPlanner</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">2</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">2</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.ZmpPlanner.get_D" title="Permalink to this definition"></a></dt>
<dd><p>Getter for D matrix.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Plan() has already been called.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.ZmpPlanner.get_desired_zmp">
<span class="sig-name descname"><span class="pre">get_desired_zmp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.planning.ZmpPlanner.get_desired_zmp" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_desired_zmp(self: pydrake.planning.ZmpPlanner, time: float) -&gt; numpy.ndarray[numpy.float64[2, 1]]</p></li>
</ol>
<p>Returns the desired ZMP evaluated at <code class="docutils literal notranslate"><span class="pre">time</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Plan() has already been called.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>get_desired_zmp(self: pydrake.planning.ZmpPlanner) -&gt; pydrake.trajectories.PiecewisePolynomial</p></li>
</ol>
<p>Returns the desired ZMP trajectory.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Plan() has already been called.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.ZmpPlanner.get_final_desired_zmp">
<span class="sig-name descname"><span class="pre">get_final_desired_zmp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.ZmpPlanner" title="pydrake.planning.ZmpPlanner"><span class="pre">pydrake.planning.ZmpPlanner</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">2</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.ZmpPlanner.get_final_desired_zmp" title="Permalink to this definition"></a></dt>
<dd><p>Returns the position of the ZMP at the end of the desired trajectory.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Plan() has already been called.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.ZmpPlanner.get_nominal_com">
<span class="sig-name descname"><span class="pre">get_nominal_com</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.planning.ZmpPlanner.get_nominal_com" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_nominal_com(self: pydrake.planning.ZmpPlanner, time: float) -&gt; numpy.ndarray[numpy.float64[2, 1]]</p></li>
</ol>
<p>Returns the nominal CoM position evaluated at <code class="docutils literal notranslate"><span class="pre">time</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Plan() has already been called.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>get_nominal_com(self: pydrake.planning.ZmpPlanner) -&gt; pydrake.trajectories.ExponentialPlusPiecewisePolynomial</p></li>
</ol>
<p>Returns the nominal CoM trajectory.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Plan() has already been called.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.ZmpPlanner.get_nominal_comd">
<span class="sig-name descname"><span class="pre">get_nominal_comd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.planning.ZmpPlanner.get_nominal_comd" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_nominal_comd(self: pydrake.planning.ZmpPlanner, time: float) -&gt; numpy.ndarray[numpy.float64[2, 1]]</p></li>
</ol>
<p>Returns the nominal CoM velocity evaluated at <code class="docutils literal notranslate"><span class="pre">time</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Plan() has already been called.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>get_nominal_comd(self: pydrake.planning.ZmpPlanner) -&gt; pydrake.trajectories.ExponentialPlusPiecewisePolynomial</p></li>
</ol>
<p>Returns the nominal CoM velocity trajectory.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Plan() has already been called.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.ZmpPlanner.get_nominal_comdd">
<span class="sig-name descname"><span class="pre">get_nominal_comdd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.planning.ZmpPlanner.get_nominal_comdd" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_nominal_comdd(self: pydrake.planning.ZmpPlanner, time: float) -&gt; numpy.ndarray[numpy.float64[2, 1]]</p></li>
</ol>
<p>Returns the nominal CoM acceleration evaluated at <code class="docutils literal notranslate"><span class="pre">time</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Plan() has already been called.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>get_nominal_comdd(self: pydrake.planning.ZmpPlanner) -&gt; pydrake.trajectories.ExponentialPlusPiecewisePolynomial</p></li>
</ol>
<p>Returns the nominal CoM acceleration trajectory.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Plan() has already been called.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.ZmpPlanner.get_Qy">
<span class="sig-name descname"><span class="pre">get_Qy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.ZmpPlanner" title="pydrake.planning.ZmpPlanner"><span class="pre">pydrake.planning.ZmpPlanner</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">2</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">2</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.ZmpPlanner.get_Qy" title="Permalink to this definition"></a></dt>
<dd><p>Getter for Qy matrix.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Plan() has already been called.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.ZmpPlanner.get_R">
<span class="sig-name descname"><span class="pre">get_R</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.ZmpPlanner" title="pydrake.planning.ZmpPlanner"><span class="pre">pydrake.planning.ZmpPlanner</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">2</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">2</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.ZmpPlanner.get_R" title="Permalink to this definition"></a></dt>
<dd><p>Getter for R matrix.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Plan() has already been called.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.ZmpPlanner.get_Vx">
<span class="sig-name descname"><span class="pre">get_Vx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.planning.ZmpPlanner.get_Vx" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>get_Vx(self: pydrake.planning.ZmpPlanner, time: float) -&gt; numpy.ndarray[numpy.float64[4, 1]]</p></li>
</ol>
<p>Returns the time varying first order term (s2 in [1]) of the value
function, evaluated at the given <code class="docutils literal notranslate"><span class="pre">time</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Plan() has already been called.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>get_Vx(self: pydrake.planning.ZmpPlanner) -&gt; pydrake.trajectories.ExponentialPlusPiecewisePolynomial</p></li>
</ol>
<p>Returns the time varying first order term (s2 in [1]) of the value
function.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Plan() has already been called.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.ZmpPlanner.get_Vxx">
<span class="sig-name descname"><span class="pre">get_Vxx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.ZmpPlanner" title="pydrake.planning.ZmpPlanner"><span class="pre">pydrake.planning.ZmpPlanner</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">4</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">4</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.planning.ZmpPlanner.get_Vxx" title="Permalink to this definition"></a></dt>
<dd><p>Returns the time invariant second order term (S1 in [1]) of the value
function.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Plan() has already been called.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.ZmpPlanner.has_planned">
<span class="sig-name descname"><span class="pre">has_planned</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.ZmpPlanner" title="pydrake.planning.ZmpPlanner"><span class="pre">pydrake.planning.ZmpPlanner</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.planning.ZmpPlanner.has_planned" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if Plan() has been called.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.planning.ZmpPlanner.Plan">
<span class="sig-name descname"><span class="pre">Plan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.planning.ZmpPlanner" title="pydrake.planning.ZmpPlanner"><span class="pre">pydrake.planning.ZmpPlanner</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">zmp_d</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.trajectories.html#pydrake.trajectories.PiecewisePolynomial" title="pydrake.trajectories.PiecewisePolynomial"><span class="pre">pydrake.trajectories.PiecewisePolynomial</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">4</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">height</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gravity</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">9.81</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Qy</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">2</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">2</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([[1.,</span> <span class="pre">0.],</span> <span class="pre">[0.,</span> <span class="pre">1.]])</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">2</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">2</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([[0.1,</span> <span class="pre">0.],</span> <span class="pre">[0.,</span> <span class="pre">0.1]])</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.planning.ZmpPlanner.Plan" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="pydrake.perception.html" class="btn btn-neutral float-left" title="pydrake.perception" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="pydrake.polynomial.html" class="btn btn-neutral float-right" title="pydrake.polynomial" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p></p>
  </div>

  
</footer>
<script>
  /* Enables clicking for the mobile "hamburger" (three-line) menu item. */
  const siteHeader = document.querySelector('.site-header')
  const mobileButton = document.querySelector('.menu-mobile-toggle')
  const body = document.querySelector('body')

  mobileButton.addEventListener('click', function(event) {
    siteHeader.classList.toggle('open');
    body.classList.toggle('overflow-hidden');
  })
</script>
<footer class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg">
    </a>
    <div class="footer-menu">
      <ul>
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"></a>
        </li>
      </ul>
    </div>
  </div>


</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>