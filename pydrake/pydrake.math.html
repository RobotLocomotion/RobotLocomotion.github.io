<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pydrake.math &mdash; pydrake  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="pydrake.multibody" href="pydrake.multibody.html" />
    <link rel="prev" title="pydrake.manipulation" href="pydrake.manipulation.html" /> 
</head>

<body class="wy-body-for-nav">
<header class="site-header">
  <div class="site-header-inner contain">
    <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
    <div class="menu-mobile-toggle">
      <span></span>
    </div>
    <nav class="site-menu">
      <ul>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/">Home</a>
        </li>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/installation.html">Installation</a>
        </li>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/gallery.html">Gallery</a>
        </li>
        <li class="site-menu-item site-menu-item-main">API Documentation
          <div class="sub">
            <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a> <a class="site-menu-item" href="/pydrake/index.html">Python</a>
          </div>
        </li>
        <li class="site-menu-item site-menu-item-main">Resources
          <div class="sub">
            <a class="site-menu-item" href="/getting_help.html">Getting Help</a> <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/%2Findex.ipynb">Tutorials</a> <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a> <a class="site-menu-item" href="/developers.html">For Developers</a> <a class="site-menu-item" href="/credits.html">Credits</a>
          </div>
        </li>
        <li class="github-link">
          <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
        </li>
      </ul>
    </nav>
  </div>
</header>

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> pydrake
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search pydrake only…" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
    <input type="text" name="q" placeholder="Search all of Drake…" />
    <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu" />
  </form>
</div>

        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="pydrake.all.html">pydrake.all</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.autodiffutils.html">pydrake.autodiffutils</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.common.html">pydrake.common</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.examples.html">pydrake.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.forwarddiff.html">pydrake.forwarddiff</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.geometry.html">pydrake.geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.gym.html">pydrake.gym</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.lcm.html">pydrake.lcm</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.manipulation.html">pydrake.manipulation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">pydrake.math</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.multibody.html">pydrake.multibody</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.perception.html">pydrake.perception</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.planning.html">pydrake.planning</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.polynomial.html">pydrake.polynomial</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.html">pydrake.solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.symbolic.html">pydrake.symbolic</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.systems.html">pydrake.systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.trajectories.html">pydrake.trajectories</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.tutorials.html">pydrake.tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.visualization.html">pydrake.visualization</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pydrake</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>pydrake.math</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-pydrake.math">
<span id="pydrake-math"></span><h1>pydrake.math<a class="headerlink" href="#module-pydrake.math" title="Permalink to this headline"></a></h1>
<p>Bindings for <code class="docutils literal notranslate"><span class="pre">math</span></code>, including overloads for scalar types and basic SE(3)
representations.</p>
<p>Note that arrays of symbolic scalar types, such as <code class="docutils literal notranslate"><span class="pre">Variable</span></code> and
<code class="docutils literal notranslate"><span class="pre">Expression</span></code>, are exposed using <code class="docutils literal notranslate"><span class="pre">ndarray[object]</span></code>, and as such logical
operations are constrained to return boolean values given NumPy’s
implementation; this is not desirable, as one should really get a <code class="docutils literal notranslate"><span class="pre">Formula</span></code>
object. As a workaround, this module provides the following vectorized
operators, following suit with the <code class="docutils literal notranslate"><span class="pre">operator</span></code> builtin module:
<code class="docutils literal notranslate"><span class="pre">lt</span></code>, <code class="docutils literal notranslate"><span class="pre">le</span></code>, <code class="docutils literal notranslate"><span class="pre">eq</span></code>, <code class="docutils literal notranslate"><span class="pre">ne</span></code>, <code class="docutils literal notranslate"><span class="pre">ge</span></code>, and <code class="docutils literal notranslate"><span class="pre">gt</span></code>.</p>
<p>As an example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;x0&quot;</span><span class="p">),</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;x1&quot;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;y0&quot;</span><span class="p">),</span> <span class="n">Variable</span><span class="p">(</span><span class="s2">&quot;y1&quot;</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">y</span>
<span class="go"># This should throw a RuntimeError</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ge</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="go">array([&lt;Formula &quot;(x0 &gt;= y0)&quot;&gt;, &lt;Formula &quot;(x1 &gt;= y1)&quot;&gt;], dtype=object)</span>
</pre></div>
</div>
<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.abs">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">abs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.abs" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>abs(arg0: float) -&gt; float</p></li>
<li><p>abs(arg0: pydrake.autodiffutils.AutoDiffXd) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
<li><p>abs(arg0: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</p></li>
</ol>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.acos">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">acos</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.acos" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>acos(arg0: float) -&gt; float</p></li>
<li><p>acos(arg0: pydrake.autodiffutils.AutoDiffXd) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
<li><p>acos(arg0: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</p></li>
</ol>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.arccos">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">arccos</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.arccos" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>arccos(arg0: float) -&gt; float</p></li>
<li><p>arccos(arg0: pydrake.autodiffutils.AutoDiffXd) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
<li><p>arccos(arg0: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</p></li>
</ol>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.arcsin">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">arcsin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.arcsin" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>arcsin(arg0: float) -&gt; float</p></li>
<li><p>arcsin(arg0: pydrake.autodiffutils.AutoDiffXd) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
<li><p>arcsin(arg0: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</p></li>
</ol>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.arctan">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">arctan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.arctan" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>arctan(arg0: float) -&gt; float</p></li>
<li><p>arctan(arg0: pydrake.autodiffutils.AutoDiffXd) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
<li><p>arctan(arg0: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</p></li>
</ol>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.arctan2">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">arctan2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.arctan2" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>arctan2(y: float, x: float) -&gt; float</p></li>
<li><p>arctan2(y: pydrake.autodiffutils.AutoDiffXd, x: pydrake.autodiffutils.AutoDiffXd) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
<li><p>arctan2(y: pydrake.symbolic.Expression, x: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</p></li>
</ol>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.AreQuaternionsEqualForOrientation">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">AreQuaternionsEqualForOrientation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.AreQuaternionsEqualForOrientation" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AreQuaternionsEqualForOrientation(quat1: pydrake.common.eigen_geometry.Quaternion, quat2: pydrake.common.eigen_geometry.Quaternion, tolerance: float) -&gt; bool</p></li>
</ol>
<p>This function tests whether two quaternions represent the same
orientation. This function converts each quaternion to its canonical
form and tests whether the absolute value of the difference in
corresponding elements of these canonical quaternions is within
tolerance.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quat1</span></code>:</dt><dd><p>Quaternion [w, x, y, z] that relates two right-handed orthogonal
unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: quat
is analogous to the rotation matrix R_AB.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quat2</span></code>:</dt><dd><p>Quaternion with a description analogous to quat1.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">tolerance</span></code>:</dt><dd><p>Nonnegative real scalar defining the allowable difference in the
orientation described by quat1 and quat2.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if quat1 and quat2 represent the same orientation (to
within tolerance), otherwise <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>AreQuaternionsEqualForOrientation(quat1: pydrake.common.eigen_geometry.Quaternion_[AutoDiffXd], quat2: pydrake.common.eigen_geometry.Quaternion_[AutoDiffXd], tolerance: pydrake.autodiffutils.AutoDiffXd) -&gt; bool</p></li>
</ol>
<p>This function tests whether two quaternions represent the same
orientation. This function converts each quaternion to its canonical
form and tests whether the absolute value of the difference in
corresponding elements of these canonical quaternions is within
tolerance.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quat1</span></code>:</dt><dd><p>Quaternion [w, x, y, z] that relates two right-handed orthogonal
unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: quat
is analogous to the rotation matrix R_AB.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quat2</span></code>:</dt><dd><p>Quaternion with a description analogous to quat1.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">tolerance</span></code>:</dt><dd><p>Nonnegative real scalar defining the allowable difference in the
orientation described by quat1 and quat2.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if quat1 and quat2 represent the same orientation (to
within tolerance), otherwise <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>AreQuaternionsEqualForOrientation(quat1: pydrake.common.eigen_geometry.Quaternion_[Expression], quat2: pydrake.common.eigen_geometry.Quaternion_[Expression], tolerance: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Formula</p></li>
</ol>
<p>This function tests whether two quaternions represent the same
orientation. This function converts each quaternion to its canonical
form and tests whether the absolute value of the difference in
corresponding elements of these canonical quaternions is within
tolerance.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quat1</span></code>:</dt><dd><p>Quaternion [w, x, y, z] that relates two right-handed orthogonal
unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: quat
is analogous to the rotation matrix R_AB.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quat2</span></code>:</dt><dd><p>Quaternion with a description analogous to quat1.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">tolerance</span></code>:</dt><dd><p>Nonnegative real scalar defining the allowable difference in the
orientation described by quat1 and quat2.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if quat1 and quat2 represent the same orientation (to
within tolerance), otherwise <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.asin">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">asin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.asin" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>asin(arg0: float) -&gt; float</p></li>
<li><p>asin(arg0: pydrake.autodiffutils.AutoDiffXd) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
<li><p>asin(arg0: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</p></li>
</ol>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.atan">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">atan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.atan" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>atan(arg0: float) -&gt; float</p></li>
<li><p>atan(arg0: pydrake.autodiffutils.AutoDiffXd) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
<li><p>atan(arg0: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</p></li>
</ol>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.atan2">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">atan2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.atan2" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>atan2(y: float, x: float) -&gt; float</p></li>
<li><p>atan2(y: pydrake.autodiffutils.AutoDiffXd, x: pydrake.autodiffutils.AutoDiffXd) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
<li><p>atan2(y: pydrake.symbolic.Expression, x: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</p></li>
</ol>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.BalanceQuadraticForms">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">BalanceQuadraticForms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">S</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">P</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.BalanceQuadraticForms" title="Permalink to this definition"></a></dt>
<dd><p>Given two quadratic forms, x’Sx &gt; 0 and x’Px, (with P symmetric and
full rank), finds a change of variables x = Ty, which simultaneously
diagonalizes both forms (as inspired by “balanced truncation” in
model-order reduction [1]). In this note, we use abs(M) to indicate
the elementwise absolute value.</p>
<p>Adapting from [1], we observe that there is a family of coordinate
systems that can simultaneously diagonalize T’ST and T’PT. Using D to
denote a diagonal matrix, we call the result S-normal if T’ST = I and
abs(T’PT) = D⁻², call it P-normal if T’ST = D² and abs(T’PT) = I, and
call it “balanced” if T’ST = D and abs(T’PT) = D⁻¹. Note that if P &gt;
0, then T’PT = D⁻¹.</p>
<p>We find x=Ty such that T’ST = D and abs(T’PT) = D⁻¹, where D is
diagonal. The recipe is: - Factorize S = LL’, and choose R=L⁻¹. - Take
svd(RPR’) = UΣV’, and note that U=V for positive definite matrices,
and V is U up to a sign flip of the singular vectors for all symmetric
matrices. - Choose T = R’U Σ^{-1/4}, where the matrix exponent can be
taken elementwise because Σ is diagonal. This gives T’ST = Σ^{-1/2}
(by using U’U=I), and abs(T’PT) = Σ^{1/2}. If P &gt; 0, then T’PT =
Σ^{1/2}.</p>
<p>Note that the numerical “balancing” can address the absolute scaling
of the quadratic forms, but not the relative scaling. To understand
this, consider the scalar case: we have two quadratic functions, sx²
and px², with s&gt;0, p&gt;0. We’d like to choose x=Ty so that sT²y² and
pT²y² are “balanced” (we’d like them both to be close to y²). We’ll
choose T=p^{-1/4}s^{-1/4}, which gives sx² = sqrt(s/p)y², and px² =
sqrt(p/s)y². For instance if s=1e8 and p=1e8, then t=1e-4 and st^2 =
pt^2 = 1. But if s=10, p=1e7, then t=0.01, and st^2 = 1e-3, pt^2 =
1e3.</p>
<p>In the matrix case, the absolute scaling is important – it ensures
that the two quadratic forms have the same matrix condition number and
makes them as close as possible to 1. Besides absolute scaling, in the
matrix case the balancing transform diagonalizes both quadratic forms.</p>
<p>[1] B. Moore, “Principal component analysis in linear systems:
Controllability, observability, and model reduction,” IEEE Trans.
Automat. Contr., vol. 26, no. 1, pp. 17–32, Feb. 1981.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.math.BarycentricMesh">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">BarycentricMesh</span></span><a class="headerlink" href="#pydrake.math.BarycentricMesh" title="Permalink to this definition"></a></dt>
<dd><p>Represents a multi-linear function (from vector inputs to vector
outputs) by interpolating between points on a mesh using (triangular)
barycentric interpolation.</p>
<p>For a technical description of barycentric interpolation, see e.g.
Remi Munos and Andrew Moore, “Barycentric Interpolators for Continuous
Space and Time Reinforcement Learning”, NIPS 1998</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BarycentricMesh.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.BarycentricMesh" title="pydrake.math.BarycentricMesh"><span class="pre">pydrake.math.BarycentricMesh</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">set</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.math.BarycentricMesh.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Constructs the mesh.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BarycentricMesh.Eval">
<span class="sig-name descname"><span class="pre">Eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.BarycentricMesh" title="pydrake.math.BarycentricMesh"><span class="pre">pydrake.math.BarycentricMesh</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.BarycentricMesh.Eval" title="Permalink to this definition"></a></dt>
<dd><p>Returns the function evaluated at <code class="docutils literal notranslate"><span class="pre">input</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BarycentricMesh.EvalBarycentricWeights">
<span class="sig-name descname"><span class="pre">EvalBarycentricWeights</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.BarycentricMesh" title="pydrake.math.BarycentricMesh"><span class="pre">pydrake.math.BarycentricMesh</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.BarycentricMesh.EvalBarycentricWeights" title="Permalink to this definition"></a></dt>
<dd><p>Writes the mesh indices used for interpolation to <code class="docutils literal notranslate"><span class="pre">mesh_indices</span></code>,
and the interpolating coefficients to <code class="docutils literal notranslate"><span class="pre">weights</span></code>. Inputs that are
outside the bounding box of the input_grid are interpolated as though
they were projected (elementwise) to the closest face of the defined
mesh.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">input</span></code>:</dt><dd><p>must be a vector of length get_num_inputs().</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mesh_indices</span></code>:</dt><dd><p>is a pointer to a vector of length get_num_interpolants().</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">weights</span></code>:</dt><dd><p>is a vector of coefficients (which sum to 1) of length
get_num_interpolants().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BarycentricMesh.get_all_mesh_points">
<span class="sig-name descname"><span class="pre">get_all_mesh_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.BarycentricMesh" title="pydrake.math.BarycentricMesh"><span class="pre">pydrake.math.BarycentricMesh</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.BarycentricMesh.get_all_mesh_points" title="Permalink to this definition"></a></dt>
<dd><p>Returns a matrix with all of the mesh points, one per column.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BarycentricMesh.get_input_grid">
<span class="sig-name descname"><span class="pre">get_input_grid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.BarycentricMesh" title="pydrake.math.BarycentricMesh"><span class="pre">pydrake.math.BarycentricMesh</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">set</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.BarycentricMesh.get_input_grid" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BarycentricMesh.get_input_size">
<span class="sig-name descname"><span class="pre">get_input_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.BarycentricMesh" title="pydrake.math.BarycentricMesh"><span class="pre">pydrake.math.BarycentricMesh</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.math.BarycentricMesh.get_input_size" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BarycentricMesh.get_mesh_point">
<span class="sig-name descname"><span class="pre">get_mesh_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.BarycentricMesh" title="pydrake.math.BarycentricMesh"><span class="pre">pydrake.math.BarycentricMesh</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.BarycentricMesh.get_mesh_point" title="Permalink to this definition"></a></dt>
<dd><p>Returns the position of a mesh point in the input space referenced by
its scalar index to <code class="docutils literal notranslate"><span class="pre">point</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">index</span></code>:</dt><dd><p>must be in [0, get_num_mesh_points).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BarycentricMesh.get_num_interpolants">
<span class="sig-name descname"><span class="pre">get_num_interpolants</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.BarycentricMesh" title="pydrake.math.BarycentricMesh"><span class="pre">pydrake.math.BarycentricMesh</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.math.BarycentricMesh.get_num_interpolants" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BarycentricMesh.get_num_mesh_points">
<span class="sig-name descname"><span class="pre">get_num_mesh_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.BarycentricMesh" title="pydrake.math.BarycentricMesh"><span class="pre">pydrake.math.BarycentricMesh</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.math.BarycentricMesh.get_num_mesh_points" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BarycentricMesh.MeshValuesFrom">
<span class="sig-name descname"><span class="pre">MeshValuesFrom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.BarycentricMesh" title="pydrake.math.BarycentricMesh"><span class="pre">pydrake.math.BarycentricMesh</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.BarycentricMesh.MeshValuesFrom" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates <code class="docutils literal notranslate"><span class="pre">vector_func</span></code> at all input mesh points and extracts the
mesh value matrix that should be used to approximate the function with
this barycentric interpolation.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MatrixXd</span><span class="w"> </span><span class="n">mesh_values</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bary</span><span class="p">.</span><span class="n">MeshValuesFrom</span><span class="p">(</span><span class="w"></span>
<span class="w">    </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">Vector1d</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
</pre></div>
</div>
</details></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.math.BsplineBasis">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">BsplineBasis</span></span><a class="headerlink" href="#pydrake.math.BsplineBasis" title="Permalink to this definition"></a></dt>
<dd><p>Given a set of non-descending breakpoints t₀ ≤ t₁ ≤ ⋅⋅⋅ ≤ tₘ, a
B-spline basis of order k is a set of n + 1 (where n = m - k)
piecewise polynomials of degree k - 1 defined over those breakpoints.
The elements of this set are called “B-splines”. The vector (t₀, t₁,
…, tₘ)’ is referred to as the “knot vector” of the basis and its
elements are referred to as “knots”.</p>
<p>At a breakpoint with multiplicity p (i.e. a breakpoint that appears p
times in the knot vector), B-splines are guaranteed to have Cᵏ⁻ᵖ⁻¹
continuity.</p>
<p>A B-spline curve using a B-spline basis B, is a parametric curve
mapping parameter values in [tₖ₋₁, tₙ₊₁] to a vector space V. For t ∈
[tₖ₋₁, tₙ₊₁] the value of the curve is given by the linear combination
of n + 1 control points, pᵢ ∈ V, with the elements of B evaluated at
t.</p>
<p>For more information on B-splines and their uses, see (for example)
Patrikalakis et al. [1].</p>
<p>[1] <a class="reference external" href="https://web.mit.edu/hyperbook/Patrikalakis-Maekawa-Cho/node15.html">https://web.mit.edu/hyperbook/Patrikalakis-Maekawa-Cho/node15.html</a></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <a class="reference internal" href="#pydrake.math.BsplineBasis_" title="pydrake.math.BsplineBasis_"><code class="xref py py-class docutils literal notranslate"><span class="pre">BsplineBasis_</span></code></a>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BsplineBasis.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.BsplineBasis.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.math.BsplineBasis) -&gt; None</p></li>
<li><p>__init__(self: pydrake.math.BsplineBasis, order: int, knots: list[float]) -&gt; None</p></li>
</ol>
<p>Constructs a B-spline basis with the specified <code class="docutils literal notranslate"><span class="pre">order</span></code> and
<code class="docutils literal notranslate"><span class="pre">knots</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">knots</span></code> is sorted in non-descending order.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if knots.size</strong><strong>(</strong><strong>) </strong><strong>&lt; 2 * order.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.math.BsplineBasis, order: int, num_basis_functions: int, type: pydrake.math.KnotVectorType = &lt;KnotVectorType.kClampedUniform: 1&gt;, initial_parameter_value: float = 0.0, final_parameter_value: float = 1.0) -&gt; None</p></li>
</ol>
<p>Constructs a B-spline basis with the specified <code class="docutils literal notranslate"><span class="pre">order</span></code>,
<cite>num_basis_functions</cite>, <code class="docutils literal notranslate"><span class="pre">initial_parameter_value</span></code>,
<cite>final_parameter_value</cite>, and an auto-generated knot vector of the
specified <code class="docutils literal notranslate"><span class="pre">type</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if num_basis_functions &lt; order</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>initial_parameter_value ≤ final_parameter_value</p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.math.BsplineBasis, other: pydrake.math.BsplineBasis) -&gt; None</p></li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BsplineBasis.ComputeActiveBasisFunctionIndices">
<span class="sig-name descname"><span class="pre">ComputeActiveBasisFunctionIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.BsplineBasis.ComputeActiveBasisFunctionIndices" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>ComputeActiveBasisFunctionIndices(self: pydrake.math.BsplineBasis, parameter_interval: Annotated[list[float], FixedSize(2)]) -&gt; list[int]</p></li>
</ol>
<p>Returns the indices of the basis functions which may evaluate to
non-zero values for some parameter value in <code class="docutils literal notranslate"><span class="pre">parameter_interval</span></code>;
all other basis functions are strictly zero over
<code class="docutils literal notranslate"><span class="pre">parameter_interval</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>parameter_interval[0] ≤ parameter_interval[1]</p>
</dd>
<dt>Precondition:</dt><dd><p>parameter_interval[0] ≥ initial_parameter_value()</p>
</dd>
<dt>Precondition:</dt><dd><p>parameter_interval[1] ≤ final_parameter_value()</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>ComputeActiveBasisFunctionIndices(self: pydrake.math.BsplineBasis, parameter_value: float) -&gt; list[int]</p></li>
</ol>
<p>Returns the indices of the basis functions which may evaluate to
non-zero values for <code class="docutils literal notranslate"><span class="pre">parameter_value</span></code>; all other basis functions are
strictly zero at this point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>parameter_value ≥ initial_parameter_value()</p>
</dd>
<dt>Precondition:</dt><dd><p>parameter_value ≤ final_parameter_value()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BsplineBasis.degree">
<span class="sig-name descname"><span class="pre">degree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.BsplineBasis" title="pydrake.math.BsplineBasis"><span class="pre">pydrake.math.BsplineBasis</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.math.BsplineBasis.degree" title="Permalink to this definition"></a></dt>
<dd><p>The degree of the piecewise polynomials comprising this B-spline basis
(k - 1 in the class description).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BsplineBasis.EvaluateBasisFunctionI">
<span class="sig-name descname"><span class="pre">EvaluateBasisFunctionI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.BsplineBasis" title="pydrake.math.BsplineBasis"><span class="pre">pydrake.math.BsplineBasis</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parameter_value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.math.BsplineBasis.EvaluateBasisFunctionI" title="Permalink to this definition"></a></dt>
<dd><p>Returns the value of the <code class="docutils literal notranslate"><span class="pre">i</span></code>-th basis function evaluated at
<code class="docutils literal notranslate"><span class="pre">parameter_value</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BsplineBasis.EvaluateCurve">
<span class="sig-name descname"><span class="pre">EvaluateCurve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.BsplineBasis" title="pydrake.math.BsplineBasis"><span class="pre">pydrake.math.BsplineBasis</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">control_points</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parameter_value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.BsplineBasis.EvaluateCurve" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates the B-spline curve defined by <code class="docutils literal notranslate"><span class="pre">this</span></code> and
<code class="docutils literal notranslate"><span class="pre">control_points</span></code> at the given <code class="docutils literal notranslate"><span class="pre">parameter_value</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">control_points</span></code>:</dt><dd><p>Control points of the B-spline curve.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">parameter_value</span></code>:</dt><dd><p>Parameter value at which to evaluate the B-spline curve defined by
<code class="docutils literal notranslate"><span class="pre">this</span></code> and <code class="docutils literal notranslate"><span class="pre">control_points</span></code>.</p>
</dd>
<dt>Precondition:</dt><dd><p>control_points.size() == num_basis_functions()</p>
</dd>
<dt>Precondition:</dt><dd><p>parameter_value ≥ initial_parameter_value()</p>
</dd>
<dt>Precondition:</dt><dd><p>parameter_value ≤ final_parameter_value()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BsplineBasis.final_parameter_value">
<span class="sig-name descname"><span class="pre">final_parameter_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.BsplineBasis" title="pydrake.math.BsplineBasis"><span class="pre">pydrake.math.BsplineBasis</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.math.BsplineBasis.final_parameter_value" title="Permalink to this definition"></a></dt>
<dd><p>The maximum allowable parameter value for B-spline curves using this
basis (tₙ₊₁ in the class description).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BsplineBasis.FindContainingInterval">
<span class="sig-name descname"><span class="pre">FindContainingInterval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.BsplineBasis" title="pydrake.math.BsplineBasis"><span class="pre">pydrake.math.BsplineBasis</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">parameter_value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.math.BsplineBasis.FindContainingInterval" title="Permalink to this definition"></a></dt>
<dd><p>For a <code class="docutils literal notranslate"><span class="pre">parameter_value</span></code> = t, the interval that contains it is the
pair of knot values [tᵢ, tᵢ₊₁] for the greatest i such that tᵢ ≤ t and
tᵢ &lt; final_parameter_value(). This function returns that value of i.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>parameter_value ≥ initial_parameter_value()</p>
</dd>
<dt>Precondition:</dt><dd><p>parameter_value ≤ final_parameter_value()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BsplineBasis.initial_parameter_value">
<span class="sig-name descname"><span class="pre">initial_parameter_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.BsplineBasis" title="pydrake.math.BsplineBasis"><span class="pre">pydrake.math.BsplineBasis</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.math.BsplineBasis.initial_parameter_value" title="Permalink to this definition"></a></dt>
<dd><p>The minimum allowable parameter value for B-spline curves using this
basis (tₖ₋₁ in the class description).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BsplineBasis.knots">
<span class="sig-name descname"><span class="pre">knots</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.BsplineBasis" title="pydrake.math.BsplineBasis"><span class="pre">pydrake.math.BsplineBasis</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.BsplineBasis.knots" title="Permalink to this definition"></a></dt>
<dd><p>The knot vector of this B-spline basis (the vector (t₀, t₁, …, tₘ)’
in the class description).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BsplineBasis.num_basis_functions">
<span class="sig-name descname"><span class="pre">num_basis_functions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.BsplineBasis" title="pydrake.math.BsplineBasis"><span class="pre">pydrake.math.BsplineBasis</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.math.BsplineBasis.num_basis_functions" title="Permalink to this definition"></a></dt>
<dd><p>The number of basis functions in this B-spline basis (n + 1 in the
class description).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BsplineBasis.order">
<span class="sig-name descname"><span class="pre">order</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.BsplineBasis" title="pydrake.math.BsplineBasis"><span class="pre">pydrake.math.BsplineBasis</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.math.BsplineBasis.order" title="Permalink to this definition"></a></dt>
<dd><p>The order of this B-spline basis (k in the class description).</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.math.BsplineBasis_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">BsplineBasis_</span></span><a class="headerlink" href="#pydrake.math.BsplineBasis_" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">BsplineBasis_[float]</span></code>, <a class="reference internal" href="#pydrake.math.BsplineBasis_-AutoDiffXd" title="pydrake.math.BsplineBasis_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">BsplineBasis_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.math.BsplineBasis_-Expression" title="pydrake.math.BsplineBasis_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">BsplineBasis_[Expression]</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.math.BsplineBasis_-AutoDiffXd">
<span id="pydrake.math.BsplineBasis_[AutoDiffXd]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">BsplineBasis_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.math.BsplineBasis_-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><p>Given a set of non-descending breakpoints t₀ ≤ t₁ ≤ ⋅⋅⋅ ≤ tₘ, a
B-spline basis of order k is a set of n + 1 (where n = m - k)
piecewise polynomials of degree k - 1 defined over those breakpoints.
The elements of this set are called “B-splines”. The vector (t₀, t₁,
…, tₘ)’ is referred to as the “knot vector” of the basis and its
elements are referred to as “knots”.</p>
<p>At a breakpoint with multiplicity p (i.e. a breakpoint that appears p
times in the knot vector), B-splines are guaranteed to have Cᵏ⁻ᵖ⁻¹
continuity.</p>
<p>A B-spline curve using a B-spline basis B, is a parametric curve
mapping parameter values in [tₖ₋₁, tₙ₊₁] to a vector space V. For t ∈
[tₖ₋₁, tₙ₊₁] the value of the curve is given by the linear combination
of n + 1 control points, pᵢ ∈ V, with the elements of B evaluated at
t.</p>
<p>For more information on B-splines and their uses, see (for example)
Patrikalakis et al. [1].</p>
<p>[1] <a class="reference external" href="https://web.mit.edu/hyperbook/Patrikalakis-Maekawa-Cho/node15.html">https://web.mit.edu/hyperbook/Patrikalakis-Maekawa-Cho/node15.html</a></p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BsplineBasis_-AutoDiffXd-.__init__">
<span id="pydrake.math.BsplineBasis_[AutoDiffXd].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.BsplineBasis_-AutoDiffXd-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.math.BsplineBasis_[AutoDiffXd]) -&gt; None</p></li>
<li><p>__init__(self: pydrake.math.BsplineBasis_[AutoDiffXd], order: int, knots: list[pydrake.autodiffutils.AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Constructs a B-spline basis with the specified <code class="docutils literal notranslate"><span class="pre">order</span></code> and
<code class="docutils literal notranslate"><span class="pre">knots</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">knots</span></code> is sorted in non-descending order.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if knots.size</strong><strong>(</strong><strong>) </strong><strong>&lt; 2 * order.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.math.BsplineBasis_[AutoDiffXd], order: int, num_basis_functions: int, type: pydrake.math.KnotVectorType = &lt;KnotVectorType.kClampedUniform: 1&gt;, initial_parameter_value: pydrake.autodiffutils.AutoDiffXd = 0.0, final_parameter_value: pydrake.autodiffutils.AutoDiffXd = 1.0) -&gt; None</p></li>
</ol>
<p>Constructs a B-spline basis with the specified <code class="docutils literal notranslate"><span class="pre">order</span></code>,
<cite>num_basis_functions</cite>, <code class="docutils literal notranslate"><span class="pre">initial_parameter_value</span></code>,
<cite>final_parameter_value</cite>, and an auto-generated knot vector of the
specified <code class="docutils literal notranslate"><span class="pre">type</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if num_basis_functions &lt; order</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>initial_parameter_value ≤ final_parameter_value</p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.math.BsplineBasis_[AutoDiffXd], other: pydrake.math.BsplineBasis_[AutoDiffXd]) -&gt; None</p></li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BsplineBasis_-AutoDiffXd-.ComputeActiveBasisFunctionIndices">
<span id="pydrake.math.BsplineBasis_[AutoDiffXd].ComputeActiveBasisFunctionIndices"></span><span class="sig-name descname"><span class="pre">ComputeActiveBasisFunctionIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.BsplineBasis_-AutoDiffXd-.ComputeActiveBasisFunctionIndices" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>ComputeActiveBasisFunctionIndices(self: pydrake.math.BsplineBasis_[AutoDiffXd], parameter_interval: Annotated[list[pydrake.autodiffutils.AutoDiffXd], FixedSize(2)]) -&gt; list[int]</p></li>
</ol>
<p>Returns the indices of the basis functions which may evaluate to
non-zero values for some parameter value in <code class="docutils literal notranslate"><span class="pre">parameter_interval</span></code>;
all other basis functions are strictly zero over
<code class="docutils literal notranslate"><span class="pre">parameter_interval</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>parameter_interval[0] ≤ parameter_interval[1]</p>
</dd>
<dt>Precondition:</dt><dd><p>parameter_interval[0] ≥ initial_parameter_value()</p>
</dd>
<dt>Precondition:</dt><dd><p>parameter_interval[1] ≤ final_parameter_value()</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>ComputeActiveBasisFunctionIndices(self: pydrake.math.BsplineBasis_[AutoDiffXd], parameter_value: pydrake.autodiffutils.AutoDiffXd) -&gt; list[int]</p></li>
</ol>
<p>Returns the indices of the basis functions which may evaluate to
non-zero values for <code class="docutils literal notranslate"><span class="pre">parameter_value</span></code>; all other basis functions are
strictly zero at this point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>parameter_value ≥ initial_parameter_value()</p>
</dd>
<dt>Precondition:</dt><dd><p>parameter_value ≤ final_parameter_value()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BsplineBasis_-AutoDiffXd-.degree">
<span id="pydrake.math.BsplineBasis_[AutoDiffXd].degree"></span><span class="sig-name descname"><span class="pre">degree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.BsplineBasis_" title="pydrake.math.BsplineBasis_"><span class="pre">pydrake.math.BsplineBasis_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.math.BsplineBasis_-AutoDiffXd-.degree" title="Permalink to this definition"></a></dt>
<dd><p>The degree of the piecewise polynomials comprising this B-spline basis
(k - 1 in the class description).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BsplineBasis_-AutoDiffXd-.EvaluateBasisFunctionI">
<span id="pydrake.math.BsplineBasis_[AutoDiffXd].EvaluateBasisFunctionI"></span><span class="sig-name descname"><span class="pre">EvaluateBasisFunctionI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.BsplineBasis_" title="pydrake.math.BsplineBasis_"><span class="pre">pydrake.math.BsplineBasis_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parameter_value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></span><a class="headerlink" href="#pydrake.math.BsplineBasis_-AutoDiffXd-.EvaluateBasisFunctionI" title="Permalink to this definition"></a></dt>
<dd><p>Returns the value of the <code class="docutils literal notranslate"><span class="pre">i</span></code>-th basis function evaluated at
<code class="docutils literal notranslate"><span class="pre">parameter_value</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BsplineBasis_-AutoDiffXd-.EvaluateCurve">
<span id="pydrake.math.BsplineBasis_[AutoDiffXd].EvaluateCurve"></span><span class="sig-name descname"><span class="pre">EvaluateCurve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.BsplineBasis_" title="pydrake.math.BsplineBasis_"><span class="pre">pydrake.math.BsplineBasis_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">control_points</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parameter_value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.BsplineBasis_-AutoDiffXd-.EvaluateCurve" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates the B-spline curve defined by <code class="docutils literal notranslate"><span class="pre">this</span></code> and
<code class="docutils literal notranslate"><span class="pre">control_points</span></code> at the given <code class="docutils literal notranslate"><span class="pre">parameter_value</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">control_points</span></code>:</dt><dd><p>Control points of the B-spline curve.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">parameter_value</span></code>:</dt><dd><p>Parameter value at which to evaluate the B-spline curve defined by
<code class="docutils literal notranslate"><span class="pre">this</span></code> and <code class="docutils literal notranslate"><span class="pre">control_points</span></code>.</p>
</dd>
<dt>Precondition:</dt><dd><p>control_points.size() == num_basis_functions()</p>
</dd>
<dt>Precondition:</dt><dd><p>parameter_value ≥ initial_parameter_value()</p>
</dd>
<dt>Precondition:</dt><dd><p>parameter_value ≤ final_parameter_value()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BsplineBasis_-AutoDiffXd-.final_parameter_value">
<span id="pydrake.math.BsplineBasis_[AutoDiffXd].final_parameter_value"></span><span class="sig-name descname"><span class="pre">final_parameter_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.BsplineBasis_" title="pydrake.math.BsplineBasis_"><span class="pre">pydrake.math.BsplineBasis_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></span><a class="headerlink" href="#pydrake.math.BsplineBasis_-AutoDiffXd-.final_parameter_value" title="Permalink to this definition"></a></dt>
<dd><p>The maximum allowable parameter value for B-spline curves using this
basis (tₙ₊₁ in the class description).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BsplineBasis_-AutoDiffXd-.FindContainingInterval">
<span id="pydrake.math.BsplineBasis_[AutoDiffXd].FindContainingInterval"></span><span class="sig-name descname"><span class="pre">FindContainingInterval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.BsplineBasis_" title="pydrake.math.BsplineBasis_"><span class="pre">pydrake.math.BsplineBasis_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parameter_value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.math.BsplineBasis_-AutoDiffXd-.FindContainingInterval" title="Permalink to this definition"></a></dt>
<dd><p>For a <code class="docutils literal notranslate"><span class="pre">parameter_value</span></code> = t, the interval that contains it is the
pair of knot values [tᵢ, tᵢ₊₁] for the greatest i such that tᵢ ≤ t and
tᵢ &lt; final_parameter_value(). This function returns that value of i.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>parameter_value ≥ initial_parameter_value()</p>
</dd>
<dt>Precondition:</dt><dd><p>parameter_value ≤ final_parameter_value()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BsplineBasis_-AutoDiffXd-.initial_parameter_value">
<span id="pydrake.math.BsplineBasis_[AutoDiffXd].initial_parameter_value"></span><span class="sig-name descname"><span class="pre">initial_parameter_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.BsplineBasis_" title="pydrake.math.BsplineBasis_"><span class="pre">pydrake.math.BsplineBasis_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></span><a class="headerlink" href="#pydrake.math.BsplineBasis_-AutoDiffXd-.initial_parameter_value" title="Permalink to this definition"></a></dt>
<dd><p>The minimum allowable parameter value for B-spline curves using this
basis (tₖ₋₁ in the class description).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BsplineBasis_-AutoDiffXd-.knots">
<span id="pydrake.math.BsplineBasis_[AutoDiffXd].knots"></span><span class="sig-name descname"><span class="pre">knots</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.BsplineBasis_" title="pydrake.math.BsplineBasis_"><span class="pre">pydrake.math.BsplineBasis_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.BsplineBasis_-AutoDiffXd-.knots" title="Permalink to this definition"></a></dt>
<dd><p>The knot vector of this B-spline basis (the vector (t₀, t₁, …, tₘ)’
in the class description).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BsplineBasis_-AutoDiffXd-.num_basis_functions">
<span id="pydrake.math.BsplineBasis_[AutoDiffXd].num_basis_functions"></span><span class="sig-name descname"><span class="pre">num_basis_functions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.BsplineBasis_" title="pydrake.math.BsplineBasis_"><span class="pre">pydrake.math.BsplineBasis_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.math.BsplineBasis_-AutoDiffXd-.num_basis_functions" title="Permalink to this definition"></a></dt>
<dd><p>The number of basis functions in this B-spline basis (n + 1 in the
class description).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BsplineBasis_-AutoDiffXd-.order">
<span id="pydrake.math.BsplineBasis_[AutoDiffXd].order"></span><span class="sig-name descname"><span class="pre">order</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.BsplineBasis_" title="pydrake.math.BsplineBasis_"><span class="pre">pydrake.math.BsplineBasis_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.math.BsplineBasis_-AutoDiffXd-.order" title="Permalink to this definition"></a></dt>
<dd><p>The order of this B-spline basis (k in the class description).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.math.BsplineBasis_-Expression">
<span id="pydrake.math.BsplineBasis_[Expression]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">BsplineBasis_[Expression]</span></span><a class="headerlink" href="#pydrake.math.BsplineBasis_-Expression" title="Permalink to this definition"></a></dt>
<dd><p>Given a set of non-descending breakpoints t₀ ≤ t₁ ≤ ⋅⋅⋅ ≤ tₘ, a
B-spline basis of order k is a set of n + 1 (where n = m - k)
piecewise polynomials of degree k - 1 defined over those breakpoints.
The elements of this set are called “B-splines”. The vector (t₀, t₁,
…, tₘ)’ is referred to as the “knot vector” of the basis and its
elements are referred to as “knots”.</p>
<p>At a breakpoint with multiplicity p (i.e. a breakpoint that appears p
times in the knot vector), B-splines are guaranteed to have Cᵏ⁻ᵖ⁻¹
continuity.</p>
<p>A B-spline curve using a B-spline basis B, is a parametric curve
mapping parameter values in [tₖ₋₁, tₙ₊₁] to a vector space V. For t ∈
[tₖ₋₁, tₙ₊₁] the value of the curve is given by the linear combination
of n + 1 control points, pᵢ ∈ V, with the elements of B evaluated at
t.</p>
<p>For more information on B-splines and their uses, see (for example)
Patrikalakis et al. [1].</p>
<p>[1] <a class="reference external" href="https://web.mit.edu/hyperbook/Patrikalakis-Maekawa-Cho/node15.html">https://web.mit.edu/hyperbook/Patrikalakis-Maekawa-Cho/node15.html</a></p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BsplineBasis_-Expression-.__init__">
<span id="pydrake.math.BsplineBasis_[Expression].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.BsplineBasis_-Expression-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.math.BsplineBasis_[Expression]) -&gt; None</p></li>
<li><p>__init__(self: pydrake.math.BsplineBasis_[Expression], order: int, knots: list[pydrake.symbolic.Expression]) -&gt; None</p></li>
</ol>
<p>Constructs a B-spline basis with the specified <code class="docutils literal notranslate"><span class="pre">order</span></code> and
<code class="docutils literal notranslate"><span class="pre">knots</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">knots</span></code> is sorted in non-descending order.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if knots.size</strong><strong>(</strong><strong>) </strong><strong>&lt; 2 * order.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.math.BsplineBasis_[Expression], order: int, num_basis_functions: int, type: pydrake.math.KnotVectorType = &lt;KnotVectorType.kClampedUniform: 1&gt;, initial_parameter_value: pydrake.symbolic.Expression = 0.0, final_parameter_value: pydrake.symbolic.Expression = 1.0) -&gt; None</p></li>
</ol>
<p>Constructs a B-spline basis with the specified <code class="docutils literal notranslate"><span class="pre">order</span></code>,
<cite>num_basis_functions</cite>, <code class="docutils literal notranslate"><span class="pre">initial_parameter_value</span></code>,
<cite>final_parameter_value</cite>, and an auto-generated knot vector of the
specified <code class="docutils literal notranslate"><span class="pre">type</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if num_basis_functions &lt; order</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>initial_parameter_value ≤ final_parameter_value</p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.math.BsplineBasis_[Expression], other: pydrake.math.BsplineBasis_[Expression]) -&gt; None</p></li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BsplineBasis_-Expression-.ComputeActiveBasisFunctionIndices">
<span id="pydrake.math.BsplineBasis_[Expression].ComputeActiveBasisFunctionIndices"></span><span class="sig-name descname"><span class="pre">ComputeActiveBasisFunctionIndices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.BsplineBasis_-Expression-.ComputeActiveBasisFunctionIndices" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>ComputeActiveBasisFunctionIndices(self: pydrake.math.BsplineBasis_[Expression], parameter_interval: Annotated[list[pydrake.symbolic.Expression], FixedSize(2)]) -&gt; list[int]</p></li>
</ol>
<p>Returns the indices of the basis functions which may evaluate to
non-zero values for some parameter value in <code class="docutils literal notranslate"><span class="pre">parameter_interval</span></code>;
all other basis functions are strictly zero over
<code class="docutils literal notranslate"><span class="pre">parameter_interval</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>parameter_interval[0] ≤ parameter_interval[1]</p>
</dd>
<dt>Precondition:</dt><dd><p>parameter_interval[0] ≥ initial_parameter_value()</p>
</dd>
<dt>Precondition:</dt><dd><p>parameter_interval[1] ≤ final_parameter_value()</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>ComputeActiveBasisFunctionIndices(self: pydrake.math.BsplineBasis_[Expression], parameter_value: pydrake.symbolic.Expression) -&gt; list[int]</p></li>
</ol>
<p>Returns the indices of the basis functions which may evaluate to
non-zero values for <code class="docutils literal notranslate"><span class="pre">parameter_value</span></code>; all other basis functions are
strictly zero at this point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>parameter_value ≥ initial_parameter_value()</p>
</dd>
<dt>Precondition:</dt><dd><p>parameter_value ≤ final_parameter_value()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BsplineBasis_-Expression-.degree">
<span id="pydrake.math.BsplineBasis_[Expression].degree"></span><span class="sig-name descname"><span class="pre">degree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.BsplineBasis_" title="pydrake.math.BsplineBasis_"><span class="pre">pydrake.math.BsplineBasis_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.math.BsplineBasis_-Expression-.degree" title="Permalink to this definition"></a></dt>
<dd><p>The degree of the piecewise polynomials comprising this B-spline basis
(k - 1 in the class description).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BsplineBasis_-Expression-.EvaluateBasisFunctionI">
<span id="pydrake.math.BsplineBasis_[Expression].EvaluateBasisFunctionI"></span><span class="sig-name descname"><span class="pre">EvaluateBasisFunctionI</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.BsplineBasis_" title="pydrake.math.BsplineBasis_"><span class="pre">pydrake.math.BsplineBasis_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parameter_value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></span><a class="headerlink" href="#pydrake.math.BsplineBasis_-Expression-.EvaluateBasisFunctionI" title="Permalink to this definition"></a></dt>
<dd><p>Returns the value of the <code class="docutils literal notranslate"><span class="pre">i</span></code>-th basis function evaluated at
<code class="docutils literal notranslate"><span class="pre">parameter_value</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BsplineBasis_-Expression-.EvaluateCurve">
<span id="pydrake.math.BsplineBasis_[Expression].EvaluateCurve"></span><span class="sig-name descname"><span class="pre">EvaluateCurve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.BsplineBasis_" title="pydrake.math.BsplineBasis_"><span class="pre">pydrake.math.BsplineBasis_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">control_points</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parameter_value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.BsplineBasis_-Expression-.EvaluateCurve" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates the B-spline curve defined by <code class="docutils literal notranslate"><span class="pre">this</span></code> and
<code class="docutils literal notranslate"><span class="pre">control_points</span></code> at the given <code class="docutils literal notranslate"><span class="pre">parameter_value</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">control_points</span></code>:</dt><dd><p>Control points of the B-spline curve.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">parameter_value</span></code>:</dt><dd><p>Parameter value at which to evaluate the B-spline curve defined by
<code class="docutils literal notranslate"><span class="pre">this</span></code> and <code class="docutils literal notranslate"><span class="pre">control_points</span></code>.</p>
</dd>
<dt>Precondition:</dt><dd><p>control_points.size() == num_basis_functions()</p>
</dd>
<dt>Precondition:</dt><dd><p>parameter_value ≥ initial_parameter_value()</p>
</dd>
<dt>Precondition:</dt><dd><p>parameter_value ≤ final_parameter_value()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BsplineBasis_-Expression-.final_parameter_value">
<span id="pydrake.math.BsplineBasis_[Expression].final_parameter_value"></span><span class="sig-name descname"><span class="pre">final_parameter_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.BsplineBasis_" title="pydrake.math.BsplineBasis_"><span class="pre">pydrake.math.BsplineBasis_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></span><a class="headerlink" href="#pydrake.math.BsplineBasis_-Expression-.final_parameter_value" title="Permalink to this definition"></a></dt>
<dd><p>The maximum allowable parameter value for B-spline curves using this
basis (tₙ₊₁ in the class description).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BsplineBasis_-Expression-.FindContainingInterval">
<span id="pydrake.math.BsplineBasis_[Expression].FindContainingInterval"></span><span class="sig-name descname"><span class="pre">FindContainingInterval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.BsplineBasis_" title="pydrake.math.BsplineBasis_"><span class="pre">pydrake.math.BsplineBasis_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parameter_value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.math.BsplineBasis_-Expression-.FindContainingInterval" title="Permalink to this definition"></a></dt>
<dd><p>For a <code class="docutils literal notranslate"><span class="pre">parameter_value</span></code> = t, the interval that contains it is the
pair of knot values [tᵢ, tᵢ₊₁] for the greatest i such that tᵢ ≤ t and
tᵢ &lt; final_parameter_value(). This function returns that value of i.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>parameter_value ≥ initial_parameter_value()</p>
</dd>
<dt>Precondition:</dt><dd><p>parameter_value ≤ final_parameter_value()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BsplineBasis_-Expression-.initial_parameter_value">
<span id="pydrake.math.BsplineBasis_[Expression].initial_parameter_value"></span><span class="sig-name descname"><span class="pre">initial_parameter_value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.BsplineBasis_" title="pydrake.math.BsplineBasis_"><span class="pre">pydrake.math.BsplineBasis_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></span><a class="headerlink" href="#pydrake.math.BsplineBasis_-Expression-.initial_parameter_value" title="Permalink to this definition"></a></dt>
<dd><p>The minimum allowable parameter value for B-spline curves using this
basis (tₖ₋₁ in the class description).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BsplineBasis_-Expression-.knots">
<span id="pydrake.math.BsplineBasis_[Expression].knots"></span><span class="sig-name descname"><span class="pre">knots</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.BsplineBasis_" title="pydrake.math.BsplineBasis_"><span class="pre">pydrake.math.BsplineBasis_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.BsplineBasis_-Expression-.knots" title="Permalink to this definition"></a></dt>
<dd><p>The knot vector of this B-spline basis (the vector (t₀, t₁, …, tₘ)’
in the class description).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BsplineBasis_-Expression-.num_basis_functions">
<span id="pydrake.math.BsplineBasis_[Expression].num_basis_functions"></span><span class="sig-name descname"><span class="pre">num_basis_functions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.BsplineBasis_" title="pydrake.math.BsplineBasis_"><span class="pre">pydrake.math.BsplineBasis_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.math.BsplineBasis_-Expression-.num_basis_functions" title="Permalink to this definition"></a></dt>
<dd><p>The number of basis functions in this B-spline basis (n + 1 in the
class description).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.BsplineBasis_-Expression-.order">
<span id="pydrake.math.BsplineBasis_[Expression].order"></span><span class="sig-name descname"><span class="pre">order</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.BsplineBasis_" title="pydrake.math.BsplineBasis_"><span class="pre">pydrake.math.BsplineBasis_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.math.BsplineBasis_-Expression-.order" title="Permalink to this definition"></a></dt>
<dd><p>The order of this B-spline basis (k in the class description).</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.CalculateAngularVelocityExpressedInBFromQuaternionDt">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">CalculateAngularVelocityExpressedInBFromQuaternionDt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.CalculateAngularVelocityExpressedInBFromQuaternionDt" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CalculateAngularVelocityExpressedInBFromQuaternionDt(quat_AB: pydrake.common.eigen_geometry.Quaternion, quatDt: numpy.ndarray[numpy.float64[4, 1]]) -&gt; numpy.ndarray[numpy.float64[3, 1]]</p></li>
</ol>
<p>This function calculates angular velocity from a quaternion and its
time- derivative. Algorithm from [Kane, 1983] Section 1.13, Pages
58-59.</p>
<ul class="simple">
<li><p>[Kane, 1983] “Spacecraft Dynamics,” McGraw-Hill Book Co., New York, 1983.
(with P. W. Likins and D. A. Levinson).  Available for free .pdf download:
<a class="reference external" href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></p></li>
</ul>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quat_AB</span></code>:</dt><dd><p>Quaternion [w, x, y, z] that relates two right-handed orthogonal
unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note:
quat_AB is analogous to the rotation matrix R_AB.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quatDt</span></code>:</dt><dd><p>Time-derivative of <code class="docutils literal notranslate"><span class="pre">quat_AB</span></code>, i.e. [ẇ, ẋ, ẏ, ż].</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">w_AB_B</span></code>:</dt><dd><p>B’s angular velocity in A, expressed in B.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>CalculateAngularVelocityExpressedInBFromQuaternionDt(quat_AB: pydrake.common.eigen_geometry.Quaternion_[AutoDiffXd], quatDt: numpy.ndarray[object[4, 1]]) -&gt; numpy.ndarray[object[3, 1]]</p></li>
</ol>
<p>This function calculates angular velocity from a quaternion and its
time- derivative. Algorithm from [Kane, 1983] Section 1.13, Pages
58-59.</p>
<ul class="simple">
<li><p>[Kane, 1983] “Spacecraft Dynamics,” McGraw-Hill Book Co., New York, 1983.
(with P. W. Likins and D. A. Levinson).  Available for free .pdf download:
<a class="reference external" href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></p></li>
</ul>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quat_AB</span></code>:</dt><dd><p>Quaternion [w, x, y, z] that relates two right-handed orthogonal
unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note:
quat_AB is analogous to the rotation matrix R_AB.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quatDt</span></code>:</dt><dd><p>Time-derivative of <code class="docutils literal notranslate"><span class="pre">quat_AB</span></code>, i.e. [ẇ, ẋ, ẏ, ż].</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">w_AB_B</span></code>:</dt><dd><p>B’s angular velocity in A, expressed in B.</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>CalculateAngularVelocityExpressedInBFromQuaternionDt(quat_AB: pydrake.common.eigen_geometry.Quaternion_[Expression], quatDt: numpy.ndarray[object[4, 1]]) -&gt; numpy.ndarray[object[3, 1]]</p></li>
</ol>
<p>This function calculates angular velocity from a quaternion and its
time- derivative. Algorithm from [Kane, 1983] Section 1.13, Pages
58-59.</p>
<ul class="simple">
<li><p>[Kane, 1983] “Spacecraft Dynamics,” McGraw-Hill Book Co., New York, 1983.
(with P. W. Likins and D. A. Levinson).  Available for free .pdf download:
<a class="reference external" href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></p></li>
</ul>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quat_AB</span></code>:</dt><dd><p>Quaternion [w, x, y, z] that relates two right-handed orthogonal
unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note:
quat_AB is analogous to the rotation matrix R_AB.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quatDt</span></code>:</dt><dd><p>Time-derivative of <code class="docutils literal notranslate"><span class="pre">quat_AB</span></code>, i.e. [ẇ, ẋ, ẏ, ż].</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">w_AB_B</span></code>:</dt><dd><p>B’s angular velocity in A, expressed in B.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.CalculateQuaternionDtConstraintViolation">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">CalculateQuaternionDtConstraintViolation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.CalculateQuaternionDtConstraintViolation" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CalculateQuaternionDtConstraintViolation(quat: pydrake.common.eigen_geometry.Quaternion, quatDt: numpy.ndarray[numpy.float64[4, 1]]) -&gt; float</p></li>
</ol>
<p>This function calculates how well a quaternion and its time-derivative
satisfy the quaternion time-derivative constraint specified in [Kane,
1983] Section 1.13, equations 12-13, page 59. For a quaternion [w, x,
y, z], the quaternion must satisfy: w^2 + x^2 + y^2 + z^2 = 1, hence
its time-derivative must satisfy: 2*(w*ẇ + x*ẋ + y*ẏ + z*ż) = 0.</p>
<ul class="simple">
<li><p>[Kane, 1983] “Spacecraft Dynamics,” McGraw-Hill Book Co., New York, 1983.
(with P. W. Likins and D. A. Levinson).  Available for free .pdf download:
<a class="reference external" href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></p></li>
</ul>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quat</span></code>:</dt><dd><p>Quaternion [w, x, y, z] that relates two right-handed orthogonal
unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: A
quaternion like quat_AB is analogous to the rotation matrix R_AB.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quatDt</span></code>:</dt><dd><p>Time-derivative of <code class="docutils literal notranslate"><span class="pre">quat</span></code>, i.e., [ẇ, ẋ, ẏ, ż].</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">quaternionDt_constraint_violation</span></code>:</dt><dd><p>The amount the time- derivative of the quaternion constraint has
been violated, which may be positive or negative (0 means the
constraint is perfectly satisfied).</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>CalculateQuaternionDtConstraintViolation(quat: pydrake.common.eigen_geometry.Quaternion_[AutoDiffXd], quatDt: numpy.ndarray[object[4, 1]]) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
</ol>
<p>This function calculates how well a quaternion and its time-derivative
satisfy the quaternion time-derivative constraint specified in [Kane,
1983] Section 1.13, equations 12-13, page 59. For a quaternion [w, x,
y, z], the quaternion must satisfy: w^2 + x^2 + y^2 + z^2 = 1, hence
its time-derivative must satisfy: 2*(w*ẇ + x*ẋ + y*ẏ + z*ż) = 0.</p>
<ul class="simple">
<li><p>[Kane, 1983] “Spacecraft Dynamics,” McGraw-Hill Book Co., New York, 1983.
(with P. W. Likins and D. A. Levinson).  Available for free .pdf download:
<a class="reference external" href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></p></li>
</ul>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quat</span></code>:</dt><dd><p>Quaternion [w, x, y, z] that relates two right-handed orthogonal
unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: A
quaternion like quat_AB is analogous to the rotation matrix R_AB.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quatDt</span></code>:</dt><dd><p>Time-derivative of <code class="docutils literal notranslate"><span class="pre">quat</span></code>, i.e., [ẇ, ẋ, ẏ, ż].</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">quaternionDt_constraint_violation</span></code>:</dt><dd><p>The amount the time- derivative of the quaternion constraint has
been violated, which may be positive or negative (0 means the
constraint is perfectly satisfied).</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>CalculateQuaternionDtConstraintViolation(quat: pydrake.common.eigen_geometry.Quaternion_[Expression], quatDt: numpy.ndarray[object[4, 1]]) -&gt; pydrake.symbolic.Expression</p></li>
</ol>
<p>This function calculates how well a quaternion and its time-derivative
satisfy the quaternion time-derivative constraint specified in [Kane,
1983] Section 1.13, equations 12-13, page 59. For a quaternion [w, x,
y, z], the quaternion must satisfy: w^2 + x^2 + y^2 + z^2 = 1, hence
its time-derivative must satisfy: 2*(w*ẇ + x*ẋ + y*ẏ + z*ż) = 0.</p>
<ul class="simple">
<li><p>[Kane, 1983] “Spacecraft Dynamics,” McGraw-Hill Book Co., New York, 1983.
(with P. W. Likins and D. A. Levinson).  Available for free .pdf download:
<a class="reference external" href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></p></li>
</ul>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quat</span></code>:</dt><dd><p>Quaternion [w, x, y, z] that relates two right-handed orthogonal
unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: A
quaternion like quat_AB is analogous to the rotation matrix R_AB.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quatDt</span></code>:</dt><dd><p>Time-derivative of <code class="docutils literal notranslate"><span class="pre">quat</span></code>, i.e., [ẇ, ẋ, ẏ, ż].</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">quaternionDt_constraint_violation</span></code>:</dt><dd><p>The amount the time- derivative of the quaternion constraint has
been violated, which may be positive or negative (0 means the
constraint is perfectly satisfied).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.CalculateQuaternionDtFromAngularVelocityExpressedInB">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">CalculateQuaternionDtFromAngularVelocityExpressedInB</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.CalculateQuaternionDtFromAngularVelocityExpressedInB" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CalculateQuaternionDtFromAngularVelocityExpressedInB(quat_AB: pydrake.common.eigen_geometry.Quaternion, w_AB_B: numpy.ndarray[numpy.float64[3, 1]]) -&gt; numpy.ndarray[numpy.float64[4, 1]]</p></li>
</ol>
<p>This function calculates a quaternion’s time-derivative from its
quaternion and angular velocity. Algorithm from [Kane, 1983] Section
1.13, Pages 58-59.</p>
<ul class="simple">
<li><p>[Kane, 1983] “Spacecraft Dynamics,” McGraw-Hill Book Co., New York, 1983.
(With P. W. Likins and D. A. Levinson).  Available for free .pdf download:
<a class="reference external" href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></p></li>
</ul>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quat_AB</span></code>:</dt><dd><p>Quaternion [w, x, y, z] that relates two right-handed orthogonal
unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note:
quat_AB is analogous to the rotation matrix R_AB.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">w_AB_B</span></code>:</dt><dd><p>B’s angular velocity in A, expressed in B.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">quatDt</span></code>:</dt><dd><p>Time-derivative of quat_AB, i.e., [ẇ, ẋ, ẏ, ż].</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>CalculateQuaternionDtFromAngularVelocityExpressedInB(quat_AB: pydrake.common.eigen_geometry.Quaternion_[AutoDiffXd], w_AB_B: numpy.ndarray[object[3, 1]]) -&gt; numpy.ndarray[object[4, 1]]</p></li>
</ol>
<p>This function calculates a quaternion’s time-derivative from its
quaternion and angular velocity. Algorithm from [Kane, 1983] Section
1.13, Pages 58-59.</p>
<ul class="simple">
<li><p>[Kane, 1983] “Spacecraft Dynamics,” McGraw-Hill Book Co., New York, 1983.
(With P. W. Likins and D. A. Levinson).  Available for free .pdf download:
<a class="reference external" href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></p></li>
</ul>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quat_AB</span></code>:</dt><dd><p>Quaternion [w, x, y, z] that relates two right-handed orthogonal
unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note:
quat_AB is analogous to the rotation matrix R_AB.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">w_AB_B</span></code>:</dt><dd><p>B’s angular velocity in A, expressed in B.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">quatDt</span></code>:</dt><dd><p>Time-derivative of quat_AB, i.e., [ẇ, ẋ, ẏ, ż].</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>CalculateQuaternionDtFromAngularVelocityExpressedInB(quat_AB: pydrake.common.eigen_geometry.Quaternion_[Expression], w_AB_B: numpy.ndarray[object[3, 1]]) -&gt; numpy.ndarray[object[4, 1]]</p></li>
</ol>
<p>This function calculates a quaternion’s time-derivative from its
quaternion and angular velocity. Algorithm from [Kane, 1983] Section
1.13, Pages 58-59.</p>
<ul class="simple">
<li><p>[Kane, 1983] “Spacecraft Dynamics,” McGraw-Hill Book Co., New York, 1983.
(With P. W. Likins and D. A. Levinson).  Available for free .pdf download:
<a class="reference external" href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></p></li>
</ul>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quat_AB</span></code>:</dt><dd><p>Quaternion [w, x, y, z] that relates two right-handed orthogonal
unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note:
quat_AB is analogous to the rotation matrix R_AB.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">w_AB_B</span></code>:</dt><dd><p>B’s angular velocity in A, expressed in B.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">quatDt</span></code>:</dt><dd><p>Time-derivative of quat_AB, i.e., [ẇ, ẋ, ẏ, ż].</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.ceil">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">ceil</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.ceil" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>ceil(arg0: float) -&gt; float</p></li>
<li><p>ceil(arg0: pydrake.autodiffutils.AutoDiffXd) -&gt; float</p></li>
<li><p>ceil(arg0: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</p></li>
</ol>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.ClosestQuaternion">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">ClosestQuaternion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.ClosestQuaternion" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>ClosestQuaternion(quat1: pydrake.common.eigen_geometry.Quaternion, quat2: pydrake.common.eigen_geometry.Quaternion) -&gt; pydrake.common.eigen_geometry.Quaternion</p></li>
</ol>
<p>Returns a unit quaternion that represents the same orientation as
<code class="docutils literal notranslate"><span class="pre">quat2</span></code>, and has the “shortest” geodesic distance on the unit sphere
to <code class="docutils literal notranslate"><span class="pre">quat1</span></code>.</p>
<ol class="arabic simple" start="2">
<li><p>ClosestQuaternion(quat1: pydrake.common.eigen_geometry.Quaternion_[AutoDiffXd], quat2: pydrake.common.eigen_geometry.Quaternion_[AutoDiffXd]) -&gt; pydrake.common.eigen_geometry.Quaternion_[AutoDiffXd]</p></li>
</ol>
<p>Returns a unit quaternion that represents the same orientation as
<code class="docutils literal notranslate"><span class="pre">quat2</span></code>, and has the “shortest” geodesic distance on the unit sphere
to <code class="docutils literal notranslate"><span class="pre">quat1</span></code>.</p>
<ol class="arabic simple" start="3">
<li><p>ClosestQuaternion(quat1: pydrake.common.eigen_geometry.Quaternion_[Expression], quat2: pydrake.common.eigen_geometry.Quaternion_[Expression]) -&gt; pydrake.common.eigen_geometry.Quaternion_[Expression]</p></li>
</ol>
<p>Returns a unit quaternion that represents the same orientation as
<code class="docutils literal notranslate"><span class="pre">quat2</span></code>, and has the “shortest” geodesic distance on the unit sphere
to <code class="docutils literal notranslate"><span class="pre">quat1</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.ComputeNumericalGradient">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">ComputeNumericalGradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">calc_func:</span> <span class="pre">Callable[[numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]],</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]],</span> <span class="pre">x:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">option:</span> <span class="pre">pydrake.math.NumericalGradientOption</span> <span class="pre">=</span> <span class="pre">&lt;NumericalGradientOption(&lt;NumericalGradientMethod.kForward:</span> <span class="pre">0&gt;)&gt;</span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.ComputeNumericalGradient" title="Permalink to this definition"></a></dt>
<dd><p>Compute the gradient of a function f(x) through numerical difference.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">calc_func</span></code>:</dt><dd><p>calc_func(x, &amp;y) computes the value of f(x), and stores the value
in y. <code class="docutils literal notranslate"><span class="pre">calc_func</span></code> is responsible for properly resizing the
output <code class="docutils literal notranslate"><span class="pre">y</span></code> when it consists of an Eigen vector of Eigen::Dynamic
size.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">x</span></code>:</dt><dd><p>The point at which the numerical gradient is computed.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">option</span></code>:</dt><dd><p>The options for computing numerical gradient.</p>
</dd>
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">DerivedX</span></code>:</dt><dd><p>an Eigen column vector.</p>
</dd>
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">DerivedY</span></code>:</dt><dd><p>an Eigen column vector.</p>
</dd>
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">DerivedCalcX</span></code>:</dt><dd><p>The type of x in the calc_func. Must be an Eigen column vector. It
is possible to have DerivedCalcX being different from DerivedX,
for example, <code class="docutils literal notranslate"><span class="pre">calc_func</span></code> could be solvers::EvaluatorBase(const
Eigen::Ref&lt;const Eigen::VectorXd&gt;&amp;, Eigen::VectorXd*), but <code class="docutils literal notranslate"><span class="pre">x</span></code>
could be of type Eigen::VectorXd. TODO(hongkai.dai): understand
why the default template DerivedCalcX = DerivedX doesn’t compile
when I instantiate ComputeNumericalGradient&lt;DerivedX,
DerivedY&gt;(calc_func, x);</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">gradient</span></code>:</dt><dd><p>a matrix of size x.rows() x y.rows(). gradient(i, j) is ∂f(i) /
∂x(j)</p>
</dd>
</dl>
<p>Examples:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">cc</span><span class="p">}</span><span class="w"></span>
<span class="c1">// Create a std::function from a lambda expression.</span>
<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector2d</span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="n">Vector3d</span><span class="o">*</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="k">const</span><span class="w"></span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector2d</span><span class="o">&amp;</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">Vector3d</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">y</span><span class="p">)(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">y</span><span class="p">)(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="p">(</span><span class="o">*</span><span class="n">y</span><span class="p">)(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">));};</span><span class="w"></span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span><span class="w"> </span><span class="nf">x_eval</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w"></span>
<span class="k">auto</span><span class="w"> </span><span class="n">J</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ComputeNumericalGradient</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="w"> </span><span class="n">x_eval</span><span class="p">);</span><span class="w"></span>
<span class="c1">// Note that if we pass in a lambda to ComputeNumericalGradient, then</span>
<span class="c1">// ComputeNumericalGradient has to instantiate the template types explicitly,</span>
<span class="c1">// as in this example. The issue of template deduction with std::function is</span>
<span class="c1">// explained in</span>
<span class="c1">//</span>
<span class="nl">https</span><span class="p">:</span><span class="c1">//stackoverflow.com/questions/48529410/template-arguments-deduction-failed-passing-func-pointer-to-stdfunction</span>
<span class="k">auto</span><span class="w"> </span><span class="n">bar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="k">const</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector2d</span><span class="o">&amp;</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector2d</span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="o">*</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="k">auto</span><span class="w"> </span><span class="n">J2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ComputeNumericalGradient</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector2d</span><span class="p">,</span><span class="w"></span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector2d</span><span class="p">,</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector2d</span><span class="o">&gt;</span><span class="p">(</span><span class="n">bar</span><span class="p">,</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector2d</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">));</span><span class="w"></span>
</pre></div>
</div>
</details></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.ContinuousAlgebraicRiccatiEquation">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">ContinuousAlgebraicRiccatiEquation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">B</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.ContinuousAlgebraicRiccatiEquation" title="Permalink to this definition"></a></dt>
<dd><p>Computes the unique stabilizing solution S to the continuous-time
algebraic Riccati equation:</p>
<div class="math notranslate nohighlight">
\[S A + A' S - S B R^{-1} B' S + Q = 0\]</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the Hamiltanoian matrix</strong> – </p>
</dd>
</dl>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>⌈A   BR⁻¹Bᵀ⌉
⌊Q      −Aᵀ⌋
</pre></div>
</div>
</details><p>is not invertible.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if R is not positive definite.</strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>the pair (A, B) should be stabilizable, and (Q, A) should be
detectable. For more information, please refer to page 526-527 of
Linear Systems by Thomas Kailath.</p>
</div>
<p>Based on the Matrix Sign Function method outlined in this paper:
<a class="reference external" href="http://www.engr.iupui.edu/~skoskie/ECE684/Riccati_algorithms.pdf">http://www.engr.iupui.edu/~skoskie/ECE684/Riccati_algorithms.pdf</a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.cos">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">cos</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.cos" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>cos(arg0: float) -&gt; float</p></li>
<li><p>cos(arg0: pydrake.autodiffutils.AutoDiffXd) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
<li><p>cos(arg0: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</p></li>
</ol>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.cosh">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">cosh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.cosh" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>cosh(arg0: float) -&gt; float</p></li>
<li><p>cosh(arg0: pydrake.autodiffutils.AutoDiffXd) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
<li><p>cosh(arg0: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</p></li>
</ol>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.DecomposePositiveQuadraticForm">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">DecomposePositiveQuadraticForm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">tuple</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.DecomposePositiveQuadraticForm" title="Permalink to this definition"></a></dt>
<dd><p>Rewrite a quadratic form xᵀQx + bᵀx + c to (Rx+d)ᵀ(Rx+d) where</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">RᵀR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Q</span><span class="w"></span>
<span class="n">Rᵀd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="w"></span>
<span class="n">dᵀd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="w"></span>
</pre></div>
</div>
</details><p>This decomposition requires the matrix</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>⌈Q     b/2⌉
⌊bᵀ/2    c⌋
</pre></div>
</div>
</details><p>to be positive semidefinite.</p>
<p>We return R and d with the minimal number of rows, namely the rows of
R and d equal to the rank of the matrix</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>⌈Q     b/2⌉
⌊bᵀ/2    c⌋
</pre></div>
</div>
</details><p>Notice that R might have more rows than Q, For example, the quadratic
expression x² + 2x + 5 =(x+1)² + 2², it can be decomposed as</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>⎛⌈1⌉ * x + ⌈1⌉⎞ᵀ * ⎛⌈1⌉ * x + ⌈1⌉⎞
⎝⌊0⌋       ⌊2⌋⎠    ⎝⌊0⌋       ⌊2⌋⎠
</pre></div>
</div>
</details><p>Here R has 2 rows while Q only has 1 row.</p>
<p>On the other hand the quadratic expression x² + 2x + 1 can be
decomposed as (x+1) * (x+1), where R has 1 row, same as Q.</p>
<p>Also notice that this decomposition is not unique. For example, with
any permutation matrix P, we can define</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">R₁</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">P</span><span class="o">*</span><span class="n">R</span><span class="w"></span>
<span class="n">d₁</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">P</span><span class="o">*</span><span class="n">d</span><span class="w"></span>
</pre></div>
</div>
</details><p>Then (R₁*x+d₁)ᵀ(R₁*x+d₁) gives the same quadratic form.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Q</span></code>:</dt><dd><p>The square matrix.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>:</dt><dd><p>The vector containing the linear coefficients.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">c</span></code>:</dt><dd><p>The constant term.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">tol</span></code>:</dt><dd><p>We will determine if this quadratic form is always non-negative,
by checking the Eigen values of the matrix [Q b/2] [bᵀ/2 c] are
all greater than -tol. $*Default:* is 0.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">(R</span></code>:</dt><dd><p>, d). R and d have the same number of rows. R.cols() == x.rows().
R.rows() equals to the rank of the matrix</p>
</dd>
</dl>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">Q</span><span class="w">    </span><span class="n">b</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span><span class="w"></span>
<span class="w">   </span><span class="p">[</span><span class="n">bᵀ</span><span class="o">/</span><span class="mi">2</span><span class="w">   </span><span class="n">c</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
</details><p>Precondition:
1. The quadratic form is always non-negative, namely the matrix</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">Q</span><span class="w">    </span><span class="n">b</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span><span class="w"></span>
<span class="w">        </span><span class="p">[</span><span class="n">bᵀ</span><span class="o">/</span><span class="mi">2</span><span class="w">   </span><span class="n">c</span><span class="p">]</span><span class="w"></span>
</pre></div>
</div>
</details><p>is positive semidefinite. 2. <code class="docutils literal notranslate"><span class="pre">Q</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> are of the correct size.
3. <code class="docutils literal notranslate"><span class="pre">tol</span></code> is non-negative.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the precondition is not satisfied.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.DecomposePSDmatrixIntoXtransposeTimesX">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">DecomposePSDmatrixIntoXtransposeTimesX</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Y</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zero_tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_empty_if_not_psd</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.DecomposePSDmatrixIntoXtransposeTimesX" title="Permalink to this definition"></a></dt>
<dd><p>For a symmetric positive semidefinite matrix Y, decompose it into XᵀX,
where the number of rows in X equals to the rank of Y. Notice that
this decomposition is not unique. For any orthonormal matrix U, s.t
UᵀU = identity, X_prime = UX also satisfies X_primeᵀX_prime = Y. Here
we only return one valid decomposition.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Y</span></code>:</dt><dd><p>A symmetric positive semidefinite matrix.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">zero_tol</span></code>:</dt><dd><p>We will need to check if some value (for example, the absolute
value of Y’s eigenvalues) is smaller than zero_tol. If it is, then
we deem that value as 0.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">return_empty_if_not_psd</span></code>:</dt><dd><p>If true, then return an empty matrix of size 0-by-Y.cols() if Y is
not PSD (either the decomposition fails or the resulting
eigenvalues are less that <code class="docutils literal notranslate"><span class="pre">zero_tol)</span></code>. If false (the default),
then throw an exception if Y is not PSD. This option is
particularly useful because it is brittle/expensive to test the
exact success criteria before calling this function.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">X</span></code>:</dt><dd><p>. The matrix X satisfies XᵀX = Y and X.rows() = rank(Y).</p>
</dd>
</dl>
<p>Precondition:
1. Y is positive semidefinite or return_empty_if_not_psd = true.</p>
<blockquote>
<div><blockquote>
<div><ol class="arabic simple" start="2">
<li><p>zero_tol is non-negative.</p></li>
</ol>
</div></blockquote>
<p>$Raises:</p>
</div></blockquote>
<p>RuntimeError when the pre-conditions are not satisfied.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We only use the lower triangular part of Y.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.DiscreteAlgebraicRiccatiEquation">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">DiscreteAlgebraicRiccatiEquation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.DiscreteAlgebraicRiccatiEquation" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>DiscreteAlgebraicRiccatiEquation(A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], B: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], Q: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], R: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]) -&gt; numpy.ndarray[numpy.float64[m, n]]</p></li>
</ol>
<p>Computes the unique stabilizing solution X to the discrete-time
algebraic Riccati equation:</p>
<p>AᵀXA − X − AᵀXB(BᵀXB + R)⁻¹BᵀXA + Q = 0</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if Q is not symmetric positive semidefinite.</strong> – </p></li>
<li><p><strong>RuntimeError if R is not symmetric positive definite.</strong> – </p></li>
<li><p><strong>RuntimeError if</strong><strong> (</strong><strong>A</strong><strong>, </strong><strong>B</strong><strong>) </strong><strong>isn't a stabilizable pair.</strong> – </p></li>
<li><p><strong>RuntimeError if</strong><strong> (</strong><strong>A</strong><strong>, </strong><strong>C</strong><strong>) </strong><strong>isn't a detectable pair where Q = CᵀC.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>DiscreteAlgebraicRiccatiEquation(A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], B: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], Q: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], R: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], N: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]) -&gt; numpy.ndarray[numpy.float64[m, n]]</p></li>
</ol>
<p>Computes the unique stabilizing solution X to the discrete-time
algebraic Riccati equation:</p>
<p>AᵀXA − X − (AᵀXB + N)(BᵀXB + R)⁻¹(BᵀXA + Nᵀ) + Q = 0</p>
<p>This is equivalent to solving the original DARE:</p>
<p>A₂ᵀXA₂ − X − A₂ᵀXB(BᵀXB + R)⁻¹BᵀXA₂ + Q₂ = 0</p>
<p>where A₂ and Q₂ are a change of variables:</p>
<p>A₂ = A − BR⁻¹Nᵀ and Q₂ = Q − NR⁻¹Nᵀ</p>
<p>This overload of the DARE is useful for finding the control law uₖ
that minimizes the following cost function subject to xₖ₊₁ = Axₖ +
Buₖ.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>∞ [xₖ]ᵀ[Q  N][xₖ]
J = Σ [uₖ] [Nᵀ R][uₖ] ΔT
k=0
</pre></div>
</div>
</details><p>This is a more general form of the following. The linear-quadratic
regulator is the feedback control law uₖ that minimizes the following
cost function subject to xₖ₊₁ = Axₖ + Buₖ:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>∞
J = Σ (xₖᵀQxₖ + uₖᵀRuₖ) ΔT
k=0
</pre></div>
</div>
</details><p>This can be refactored as:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>∞ [xₖ]ᵀ[Q 0][xₖ]
J = Σ [uₖ] [0 R][uₖ] ΔT
k=0
</pre></div>
</div>
</details><dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if Q₂ is not symmetric positive semidefinite.</strong> – </p></li>
<li><p><strong>RuntimeError if R is not symmetric positive definite.</strong> – </p></li>
<li><p><strong>RuntimeError if</strong><strong> (</strong><strong>A₂</strong><strong>, </strong><strong>B</strong><strong>) </strong><strong>isn't a stabilizable pair.</strong> – </p></li>
<li><p><strong>RuntimeError if</strong><strong> (</strong><strong>A₂</strong><strong>, </strong><strong>C</strong><strong>) </strong><strong>isn't a detectable pair where Q₂ = CᵀC.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.exp">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">exp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.exp" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>exp(arg0: float) -&gt; float</p></li>
<li><p>exp(arg0: pydrake.autodiffutils.AutoDiffXd) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
<li><p>exp(arg0: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</p></li>
</ol>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.ExtractPrincipalSubmatrix">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">ExtractPrincipalSubmatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">set</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.ExtractPrincipalSubmatrix" title="Permalink to this definition"></a></dt>
<dd><p>Extracts the principal submatrix from the ordered set of indices. The
indices must be in monotonically increasing order and non-empty. This
method makes no assumptions about the symmetry of the matrix, nor that
the matrix is square. However, all indices must be valid for both rows
and columns.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.floor">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">floor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.floor" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>floor(arg0: float) -&gt; float</p></li>
<li><p>floor(arg0: pydrake.autodiffutils.AutoDiffXd) -&gt; float</p></li>
<li><p>floor(arg0: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</p></li>
</ol>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.inv">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">inv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.inv" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>inv(arg0: numpy.ndarray[numpy.float64[m, n]]) -&gt; numpy.ndarray[numpy.float64[m, n]]</p></li>
<li><p>inv(arg0: numpy.ndarray[object[m, n]]) -&gt; numpy.ndarray[object[m, n]]</p></li>
<li><p>inv(arg0: numpy.ndarray[object[m, n]]) -&gt; numpy.ndarray[object[m, n]]</p></li>
</ol>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.is_quaternion_in_canonical_form">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">is_quaternion_in_canonical_form</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.is_quaternion_in_canonical_form" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>is_quaternion_in_canonical_form(quat: pydrake.common.eigen_geometry.Quaternion) -&gt; bool</p></li>
</ol>
<p>This function tests whether a quaternion is in “canonical form”
meaning that it tests whether the quaternion [w, x, y, z] has a
non-negative w value. Example: [-0.3, +0.4, +0.5, +0.707] is not in
canonical form. Example: [+0.3, -0.4, -0.5, -0.707] is in canonical
form.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quat</span></code>:</dt><dd><p>Quaternion [w, x, y, z] that relates two right-handed orthogonal
unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: quat
is analogous to the rotation matrix R_AB.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if quat.w() is nonnegative (in canonical form), else
<code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>is_quaternion_in_canonical_form(quat: pydrake.common.eigen_geometry.Quaternion_[AutoDiffXd]) -&gt; bool</p></li>
</ol>
<p>This function tests whether a quaternion is in “canonical form”
meaning that it tests whether the quaternion [w, x, y, z] has a
non-negative w value. Example: [-0.3, +0.4, +0.5, +0.707] is not in
canonical form. Example: [+0.3, -0.4, -0.5, -0.707] is in canonical
form.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quat</span></code>:</dt><dd><p>Quaternion [w, x, y, z] that relates two right-handed orthogonal
unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: quat
is analogous to the rotation matrix R_AB.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if quat.w() is nonnegative (in canonical form), else
<code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>is_quaternion_in_canonical_form(quat: pydrake.common.eigen_geometry.Quaternion_[Expression]) -&gt; pydrake.symbolic.Formula</p></li>
</ol>
<p>This function tests whether a quaternion is in “canonical form”
meaning that it tests whether the quaternion [w, x, y, z] has a
non-negative w value. Example: [-0.3, +0.4, +0.5, +0.707] is not in
canonical form. Example: [+0.3, -0.4, -0.5, -0.707] is in canonical
form.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quat</span></code>:</dt><dd><p>Quaternion [w, x, y, z] that relates two right-handed orthogonal
unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: quat
is analogous to the rotation matrix R_AB.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if quat.w() is nonnegative (in canonical form), else
<code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.IsBothQuaternionAndQuaternionDtOK">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">IsBothQuaternionAndQuaternionDtOK</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.IsBothQuaternionAndQuaternionDtOK" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>IsBothQuaternionAndQuaternionDtOK(quat: pydrake.common.eigen_geometry.Quaternion, quatDt: numpy.ndarray[numpy.float64[4, 1]], tolerance: float) -&gt; bool</p></li>
</ol>
<p>This function tests if a quaternion satisfies the time-derivative
constraint specified in [Kane, 1983] Section 1.13, equation 13, page
59. A quaternion [w, x, y, z] must satisfy w^2 + x^2 + y^2 + z^2 = 1,
hence its time-derivative must satisfy 2*(w*ẇ + x*ẋ + y*ẏ + z*ż) =
0. Note: To accurately test whether the time-derivative quaternion
constraint is satisfied, the quaternion constraint is also tested to
be accurate.</p>
<ul class="simple">
<li><p>[Kane, 1983] “Spacecraft Dynamics,” McGraw-Hill Book Co., New York, 1983.
(with P. W. Likins and D. A. Levinson).  Available for free .pdf download:
<a class="reference external" href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></p></li>
</ul>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quat</span></code>:</dt><dd><p>Quaternion [w, x, y, z] that relates two right-handed orthogonal
unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: A
quaternion like quat_AB is analogous to the rotation matrix R_AB.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quatDt</span></code>:</dt><dd><p>Time-derivative of <code class="docutils literal notranslate"><span class="pre">quat</span></code>, i.e., [ẇ, ẋ, ẏ, ż].</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">tolerance</span></code>:</dt><dd><p>Tolerance for quaternion constraints.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if both of the two previous constraints are within
tolerance.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>IsBothQuaternionAndQuaternionDtOK(quat: pydrake.common.eigen_geometry.Quaternion_[AutoDiffXd], quatDt: numpy.ndarray[object[4, 1]], tolerance: float) -&gt; bool</p></li>
</ol>
<p>This function tests if a quaternion satisfies the time-derivative
constraint specified in [Kane, 1983] Section 1.13, equation 13, page
59. A quaternion [w, x, y, z] must satisfy w^2 + x^2 + y^2 + z^2 = 1,
hence its time-derivative must satisfy 2*(w*ẇ + x*ẋ + y*ẏ + z*ż) =
0. Note: To accurately test whether the time-derivative quaternion
constraint is satisfied, the quaternion constraint is also tested to
be accurate.</p>
<ul class="simple">
<li><p>[Kane, 1983] “Spacecraft Dynamics,” McGraw-Hill Book Co., New York, 1983.
(with P. W. Likins and D. A. Levinson).  Available for free .pdf download:
<a class="reference external" href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></p></li>
</ul>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quat</span></code>:</dt><dd><p>Quaternion [w, x, y, z] that relates two right-handed orthogonal
unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: A
quaternion like quat_AB is analogous to the rotation matrix R_AB.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quatDt</span></code>:</dt><dd><p>Time-derivative of <code class="docutils literal notranslate"><span class="pre">quat</span></code>, i.e., [ẇ, ẋ, ẏ, ż].</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">tolerance</span></code>:</dt><dd><p>Tolerance for quaternion constraints.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if both of the two previous constraints are within
tolerance.</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>IsBothQuaternionAndQuaternionDtOK(quat: pydrake.common.eigen_geometry.Quaternion_[Expression], quatDt: numpy.ndarray[object[4, 1]], tolerance: float) -&gt; pydrake.symbolic.Formula</p></li>
</ol>
<p>This function tests if a quaternion satisfies the time-derivative
constraint specified in [Kane, 1983] Section 1.13, equation 13, page
59. A quaternion [w, x, y, z] must satisfy w^2 + x^2 + y^2 + z^2 = 1,
hence its time-derivative must satisfy 2*(w*ẇ + x*ẋ + y*ẏ + z*ż) =
0. Note: To accurately test whether the time-derivative quaternion
constraint is satisfied, the quaternion constraint is also tested to
be accurate.</p>
<ul class="simple">
<li><p>[Kane, 1983] “Spacecraft Dynamics,” McGraw-Hill Book Co., New York, 1983.
(with P. W. Likins and D. A. Levinson).  Available for free .pdf download:
<a class="reference external" href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></p></li>
</ul>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quat</span></code>:</dt><dd><p>Quaternion [w, x, y, z] that relates two right-handed orthogonal
unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: A
quaternion like quat_AB is analogous to the rotation matrix R_AB.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quatDt</span></code>:</dt><dd><p>Time-derivative of <code class="docutils literal notranslate"><span class="pre">quat</span></code>, i.e., [ẇ, ẋ, ẏ, ż].</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">tolerance</span></code>:</dt><dd><p>Tolerance for quaternion constraints.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if both of the two previous constraints are within
tolerance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.isnan">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">isnan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.isnan" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>isnan(x: float) -&gt; bool</p></li>
<li><p>isnan(x: pydrake.autodiffutils.AutoDiffXd) -&gt; bool</p></li>
<li><p>isnan(x: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Formula</p></li>
</ol>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.IsPositiveDefinite">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">IsPositiveDefinite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.math.IsPositiveDefinite" title="Permalink to this definition"></a></dt>
<dd><p>Checks if a matrix is symmetric (with tolerance <code class="docutils literal notranslate"><span class="pre">symmetry_tolerance</span></code>
– see IsSymmetric) and has all eigenvalues greater than
<code class="docutils literal notranslate"><span class="pre">eigenvalue_tolerance</span></code>. <code class="docutils literal notranslate"><span class="pre">eigenvalue_tolerance</span></code> must be &gt;= 0 –
where 0 implies positive semi-definite (but is of course subject to
all of the pitfalls of floating point).</p>
<p>To consider the numerical robustness of the eigenvalue estimation, we
specifically check that min_eigenvalue &gt;= eigenvalue_tolerance *
max(1, max_abs_eigenvalue).</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.IsQuaternionValid">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">IsQuaternionValid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.IsQuaternionValid" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>IsQuaternionValid(quat: pydrake.common.eigen_geometry.Quaternion, tolerance: float) -&gt; bool</p></li>
</ol>
<p>This function tests if a quaternion satisfies the quaternion
constraint specified in [Kane, 1983] Section 1.3, equation 4, page 12,
i.e., a quaternion [w, x, y, z] must satisfy: w^2 + x^2 + y^2 + z^2 =
1.</p>
<ul class="simple">
<li><p>[Kane, 1983] “Spacecraft Dynamics,” McGraw-Hill Book Co., New York, 1983.
(with P. W. Likins and D. A. Levinson).  Available for free .pdf download:
<a class="reference external" href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></p></li>
</ul>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quat</span></code>:</dt><dd><p>Quaternion [w, x, y, z] that relates two right-handed orthogonal
unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: A
quaternion like quat_AB is analogous to the rotation matrix R_AB.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">tolerance</span></code>:</dt><dd><p>Tolerance for quaternion constraint, i.e., how much is w^2 + x^2 +
y^2 + z^2 allowed to differ from 1.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if the quaternion constraint is satisfied within
tolerance.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>IsQuaternionValid(quat: pydrake.common.eigen_geometry.Quaternion_[AutoDiffXd], tolerance: float) -&gt; bool</p></li>
</ol>
<p>This function tests if a quaternion satisfies the quaternion
constraint specified in [Kane, 1983] Section 1.3, equation 4, page 12,
i.e., a quaternion [w, x, y, z] must satisfy: w^2 + x^2 + y^2 + z^2 =
1.</p>
<ul class="simple">
<li><p>[Kane, 1983] “Spacecraft Dynamics,” McGraw-Hill Book Co., New York, 1983.
(with P. W. Likins and D. A. Levinson).  Available for free .pdf download:
<a class="reference external" href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></p></li>
</ul>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quat</span></code>:</dt><dd><p>Quaternion [w, x, y, z] that relates two right-handed orthogonal
unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: A
quaternion like quat_AB is analogous to the rotation matrix R_AB.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">tolerance</span></code>:</dt><dd><p>Tolerance for quaternion constraint, i.e., how much is w^2 + x^2 +
y^2 + z^2 allowed to differ from 1.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if the quaternion constraint is satisfied within
tolerance.</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>IsQuaternionValid(quat: pydrake.common.eigen_geometry.Quaternion_[Expression], tolerance: float) -&gt; pydrake.symbolic.Formula</p></li>
</ol>
<p>This function tests if a quaternion satisfies the quaternion
constraint specified in [Kane, 1983] Section 1.3, equation 4, page 12,
i.e., a quaternion [w, x, y, z] must satisfy: w^2 + x^2 + y^2 + z^2 =
1.</p>
<ul class="simple">
<li><p>[Kane, 1983] “Spacecraft Dynamics,” McGraw-Hill Book Co., New York, 1983.
(with P. W. Likins and D. A. Levinson).  Available for free .pdf download:
<a class="reference external" href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></p></li>
</ul>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quat</span></code>:</dt><dd><p>Quaternion [w, x, y, z] that relates two right-handed orthogonal
unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: A
quaternion like quat_AB is analogous to the rotation matrix R_AB.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">tolerance</span></code>:</dt><dd><p>Tolerance for quaternion constraint, i.e., how much is w^2 + x^2 +
y^2 + z^2 allowed to differ from 1.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if the quaternion constraint is satisfied within
tolerance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.IsSymmetric">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">IsSymmetric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.IsSymmetric" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>IsSymmetric(matrix: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]) -&gt; bool</p></li>
</ol>
<p>Determines if a matrix is symmetric. If std::equal_to&lt;&gt;()(matrix(i,
j), matrix(j, i)) is true for all i, j, then the matrix is symmetric.</p>
<ol class="arabic simple" start="2">
<li><p>IsSymmetric(matrix: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], precision: float) -&gt; bool</p></li>
</ol>
<p>Determines if a matrix is symmetric based on whether the difference
between matrix(i, j) and matrix(j, i) is smaller than <code class="docutils literal notranslate"><span class="pre">precision</span></code>
for all i, j. The precision is absolute. Matrix with nan or inf
entries is not allowed.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.math.KnotVectorType">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">KnotVectorType</span></span><a class="headerlink" href="#pydrake.math.KnotVectorType" title="Permalink to this definition"></a></dt>
<dd><p>Enum representing types of knot vectors. “Uniform” refers to the
spacing between the knots. “Clamped” indicates that the first and last
knots have multiplicity equal to the order of the spline.</p>
<p>Reference:
<a class="reference external" href="http://web.mit.edu/hyperbook/Patrikalakis-Maekawa-Cho/node17.html">http://web.mit.edu/hyperbook/Patrikalakis-Maekawa-Cho/node17.html</a></p>
<p>Members:</p>
<blockquote>
<div><p>kUniform :</p>
<p>kClampedUniform :</p>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.KnotVectorType.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.KnotVectorType" title="pydrake.math.KnotVectorType"><span class="pre">pydrake.math.KnotVectorType</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.math.KnotVectorType.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.math.KnotVectorType.kClampedUniform">
<span class="sig-name descname"><span class="pre">kClampedUniform</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;KnotVectorType.kClampedUniform:</span> <span class="pre">1&gt;</span></em><a class="headerlink" href="#pydrake.math.KnotVectorType.kClampedUniform" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.math.KnotVectorType.kUniform">
<span class="sig-name descname"><span class="pre">kUniform</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;KnotVectorType.kUniform:</span> <span class="pre">0&gt;</span></em><a class="headerlink" href="#pydrake.math.KnotVectorType.kUniform" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.math.KnotVectorType.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#pydrake.math.KnotVectorType.name" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.math.KnotVectorType.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#pydrake.math.KnotVectorType.value" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.log">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.log" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>log(arg0: float) -&gt; float</p></li>
<li><p>log(arg0: pydrake.autodiffutils.AutoDiffXd) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
<li><p>log(arg0: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</p></li>
</ol>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.matmul">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">matmul</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.matmul" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>matmul(arg0: numpy.ndarray[numpy.float64[m, n]], arg1: numpy.ndarray[numpy.float64[m, n]]) -&gt; numpy.ndarray[numpy.float64[m, n]]</p></li>
</ol>
<p>Matrix product for dtype=float &#64; dtype=float -&gt; dtype=float. The numpy matmul <code class="docutils literal notranslate"><span class="pre">A</span> <span class="pre">&#64;</span> <span class="pre">B</span></code> is typically slow when multiplying user-defined dtypes such as AutoDiffXd or Expression. Use this function for better performance, e.g., <code class="docutils literal notranslate"><span class="pre">matmul(A,</span> <span class="pre">B)</span></code>. For a dtype=float &#64; dtype=float, this might be a little slower than numpy, but is provided here for convenience so that the user doesn’t need to be overly careful about the dtype of arguments.</p>
<ol class="arabic simple" start="2">
<li><p>matmul(arg0: numpy.ndarray[numpy.float64[m, n]], arg1: numpy.ndarray[object[m, n]]) -&gt; numpy.ndarray[object[m, n]]</p></li>
</ol>
<p>Matrix product for dtype=float &#64; dtype=AutoDiffXd -&gt; dtype=AutoDiffXd.</p>
<ol class="arabic simple" start="3">
<li><p>matmul(arg0: numpy.ndarray[object[m, n]], arg1: numpy.ndarray[numpy.float64[m, n]]) -&gt; numpy.ndarray[object[m, n]]</p></li>
</ol>
<p>Matrix product for dtype=AutoDiffXd &#64; dtype=float -&gt; dtype=AutoDiffXd.</p>
<ol class="arabic simple" start="4">
<li><p>matmul(arg0: numpy.ndarray[object[m, n]], arg1: numpy.ndarray[object[m, n]]) -&gt; numpy.ndarray[object[m, n]]</p></li>
</ol>
<p>Matrix product for dtype=AutoDiffXd &#64; dtype=AutoDiffXd -&gt; dtype=AutoDiffXd.</p>
<ol class="arabic simple" start="5">
<li><p>matmul(arg0: numpy.ndarray[numpy.float64[m, n]], arg1: numpy.ndarray[object[m, n]]) -&gt; numpy.ndarray[object[m, n]]</p></li>
</ol>
<p>Matrix product for dtype=float &#64; dtype=Variable -&gt; dtype=Expression.</p>
<ol class="arabic simple" start="6">
<li><p>matmul(arg0: numpy.ndarray[object[m, n]], arg1: numpy.ndarray[numpy.float64[m, n]]) -&gt; numpy.ndarray[object[m, n]]</p></li>
</ol>
<p>Matrix product for dtype=Variable &#64; dtype=float -&gt; dtype=Expression.</p>
<ol class="arabic simple" start="7">
<li><p>matmul(arg0: numpy.ndarray[numpy.float64[m, n]], arg1: numpy.ndarray[object[m, n]]) -&gt; numpy.ndarray[object[m, n]]</p></li>
</ol>
<p>Matrix product for dtype=float &#64; dtype=Monomial -&gt; dtype=Polynomial.</p>
<ol class="arabic simple" start="8">
<li><p>matmul(arg0: numpy.ndarray[object[m, n]], arg1: numpy.ndarray[numpy.float64[m, n]]) -&gt; numpy.ndarray[object[m, n]]</p></li>
</ol>
<p>Matrix product for dtype=Monomial &#64; dtype=float -&gt; dtype=Polynomial.</p>
<ol class="arabic simple" start="9">
<li><p>matmul(arg0: numpy.ndarray[numpy.float64[m, n]], arg1: numpy.ndarray[object[m, n]]) -&gt; numpy.ndarray[object[m, n]]</p></li>
</ol>
<p>Matrix product for dtype=float &#64; dtype=Polynomial -&gt; dtype=Polynomial.</p>
<ol class="arabic simple" start="10">
<li><p>matmul(arg0: numpy.ndarray[object[m, n]], arg1: numpy.ndarray[numpy.float64[m, n]]) -&gt; numpy.ndarray[object[m, n]]</p></li>
</ol>
<p>Matrix product for dtype=Polynomial &#64; dtype=float -&gt; dtype=Polynomial.</p>
<ol class="arabic simple" start="11">
<li><p>matmul(arg0: numpy.ndarray[numpy.float64[m, n]], arg1: numpy.ndarray[object[m, n]]) -&gt; numpy.ndarray[object[m, n]]</p></li>
</ol>
<p>Matrix product for dtype=float &#64; dtype=Expression -&gt; dtype=Expression.</p>
<ol class="arabic simple" start="12">
<li><p>matmul(arg0: numpy.ndarray[object[m, n]], arg1: numpy.ndarray[numpy.float64[m, n]]) -&gt; numpy.ndarray[object[m, n]]</p></li>
</ol>
<p>Matrix product for dtype=Expression &#64; dtype=float -&gt; dtype=Expression.</p>
<ol class="arabic simple" start="13">
<li><p>matmul(arg0: numpy.ndarray[object[m, n]], arg1: numpy.ndarray[object[m, n]]) -&gt; numpy.ndarray[object[m, n]]</p></li>
</ol>
<p>Matrix product for dtype=Variable &#64; dtype=Variable -&gt; dtype=Expression.</p>
<ol class="arabic simple" start="14">
<li><p>matmul(arg0: numpy.ndarray[object[m, n]], arg1: numpy.ndarray[object[m, n]]) -&gt; numpy.ndarray[object[m, n]]</p></li>
</ol>
<p>Matrix product for dtype=Variable &#64; dtype=Monomial -&gt; dtype=Polynomial.</p>
<ol class="arabic simple" start="15">
<li><p>matmul(arg0: numpy.ndarray[object[m, n]], arg1: numpy.ndarray[object[m, n]]) -&gt; numpy.ndarray[object[m, n]]</p></li>
</ol>
<p>Matrix product for dtype=Monomial &#64; dtype=Variable -&gt; dtype=Polynomial.</p>
<ol class="arabic simple" start="16">
<li><p>matmul(arg0: numpy.ndarray[object[m, n]], arg1: numpy.ndarray[object[m, n]]) -&gt; numpy.ndarray[object[m, n]]</p></li>
</ol>
<p>Matrix product for dtype=Variable &#64; dtype=Polynomial -&gt; dtype=Polynomial.</p>
<ol class="arabic simple" start="17">
<li><p>matmul(arg0: numpy.ndarray[object[m, n]], arg1: numpy.ndarray[object[m, n]]) -&gt; numpy.ndarray[object[m, n]]</p></li>
</ol>
<p>Matrix product for dtype=Polynomial &#64; dtype=Variable -&gt; dtype=Polynomial.</p>
<ol class="arabic simple" start="18">
<li><p>matmul(arg0: numpy.ndarray[object[m, n]], arg1: numpy.ndarray[object[m, n]]) -&gt; numpy.ndarray[object[m, n]]</p></li>
</ol>
<p>Matrix product for dtype=Variable &#64; dtype=Expression -&gt; dtype=Expression.</p>
<ol class="arabic simple" start="19">
<li><p>matmul(arg0: numpy.ndarray[object[m, n]], arg1: numpy.ndarray[object[m, n]]) -&gt; numpy.ndarray[object[m, n]]</p></li>
</ol>
<p>Matrix product for dtype=Expression &#64; dtype=Variable -&gt; dtype=Expression.</p>
<ol class="arabic simple" start="20">
<li><p>matmul(arg0: numpy.ndarray[object[m, n]], arg1: numpy.ndarray[object[m, n]]) -&gt; numpy.ndarray[object[m, n]]</p></li>
</ol>
<p>Matrix product for dtype=Monomial &#64; dtype=Monomial -&gt; dtype=Polynomial.</p>
<ol class="arabic simple" start="21">
<li><p>matmul(arg0: numpy.ndarray[object[m, n]], arg1: numpy.ndarray[object[m, n]]) -&gt; numpy.ndarray[object[m, n]]</p></li>
</ol>
<p>Matrix product for dtype=Monomial &#64; dtype=Polynomial -&gt; dtype=Polynomial.</p>
<ol class="arabic simple" start="22">
<li><p>matmul(arg0: numpy.ndarray[object[m, n]], arg1: numpy.ndarray[object[m, n]]) -&gt; numpy.ndarray[object[m, n]]</p></li>
</ol>
<p>Matrix product for dtype=Polynomial &#64; dtype=Monomial -&gt; dtype=Polynomial.</p>
<ol class="arabic simple" start="23">
<li><p>matmul(arg0: numpy.ndarray[object[m, n]], arg1: numpy.ndarray[object[m, n]]) -&gt; numpy.ndarray[object[m, n]]</p></li>
</ol>
<p>Matrix product for dtype=Monomial &#64; dtype=Expression -&gt; dtype=Expression.</p>
<ol class="arabic simple" start="24">
<li><p>matmul(arg0: numpy.ndarray[object[m, n]], arg1: numpy.ndarray[object[m, n]]) -&gt; numpy.ndarray[object[m, n]]</p></li>
</ol>
<p>Matrix product for dtype=Expression &#64; dtype=Monomial -&gt; dtype=Expression.</p>
<ol class="arabic simple" start="25">
<li><p>matmul(arg0: numpy.ndarray[object[m, n]], arg1: numpy.ndarray[object[m, n]]) -&gt; numpy.ndarray[object[m, n]]</p></li>
</ol>
<p>Matrix product for dtype=Polynomial &#64; dtype=Polynomial -&gt; dtype=Polynomial.</p>
<ol class="arabic simple" start="26">
<li><p>matmul(arg0: numpy.ndarray[object[m, n]], arg1: numpy.ndarray[object[m, n]]) -&gt; numpy.ndarray[object[m, n]]</p></li>
</ol>
<p>Matrix product for dtype=Polynomial &#64; dtype=Expression -&gt; dtype=Expression.</p>
<ol class="arabic simple" start="27">
<li><p>matmul(arg0: numpy.ndarray[object[m, n]], arg1: numpy.ndarray[object[m, n]]) -&gt; numpy.ndarray[object[m, n]]</p></li>
</ol>
<p>Matrix product for dtype=Expression &#64; dtype=Polynomial -&gt; dtype=Expression.</p>
<ol class="arabic simple" start="28">
<li><p>matmul(arg0: numpy.ndarray[object[m, n]], arg1: numpy.ndarray[object[m, n]]) -&gt; numpy.ndarray[object[m, n]]</p></li>
</ol>
<p>Matrix product for dtype=Expression &#64; dtype=Expression -&gt; dtype=Expression.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.max">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">max</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.max" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>max(arg0: float, arg1: float) -&gt; float</p></li>
<li><p>max(arg0: pydrake.autodiffutils.AutoDiffXd, arg1: pydrake.autodiffutils.AutoDiffXd) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
<li><p>max(arg0: pydrake.symbolic.Expression, arg1: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</p></li>
</ol>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.min">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">min</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.min" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>min(arg0: float, arg1: float) -&gt; float</p></li>
<li><p>min(arg0: pydrake.autodiffutils.AutoDiffXd, arg1: pydrake.autodiffutils.AutoDiffXd) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
<li><p>min(arg0: pydrake.symbolic.Expression, arg1: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</p></li>
</ol>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.math.NumericalGradientMethod">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">NumericalGradientMethod</span></span><a class="headerlink" href="#pydrake.math.NumericalGradientMethod" title="Permalink to this definition"></a></dt>
<dd><p>Members:</p>
<blockquote>
<div><p>kForward : Compute the gradient as (f(x + Δx) - f(x)) / Δx, with Δx &gt; 0</p>
<p>kBackward : Compute the gradient as (f(x) - f(x - Δx)) / Δx, with Δx &gt; 0</p>
<p>kCentral : Compute the gradient as (f(x + Δx) - f(x - Δx)) / (2Δx), with Δx &gt; 0</p>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.NumericalGradientMethod.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.NumericalGradientMethod" title="pydrake.math.NumericalGradientMethod"><span class="pre">pydrake.math.NumericalGradientMethod</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.math.NumericalGradientMethod.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.math.NumericalGradientMethod.kBackward">
<span class="sig-name descname"><span class="pre">kBackward</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;NumericalGradientMethod.kBackward:</span> <span class="pre">1&gt;</span></em><a class="headerlink" href="#pydrake.math.NumericalGradientMethod.kBackward" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.math.NumericalGradientMethod.kCentral">
<span class="sig-name descname"><span class="pre">kCentral</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;NumericalGradientMethod.kCentral:</span> <span class="pre">2&gt;</span></em><a class="headerlink" href="#pydrake.math.NumericalGradientMethod.kCentral" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.math.NumericalGradientMethod.kForward">
<span class="sig-name descname"><span class="pre">kForward</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;NumericalGradientMethod.kForward:</span> <span class="pre">0&gt;</span></em><a class="headerlink" href="#pydrake.math.NumericalGradientMethod.kForward" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.math.NumericalGradientMethod.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#pydrake.math.NumericalGradientMethod.name" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.math.NumericalGradientMethod.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#pydrake.math.NumericalGradientMethod.value" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.math.NumericalGradientOption">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">NumericalGradientOption</span></span><a class="headerlink" href="#pydrake.math.NumericalGradientOption" title="Permalink to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.NumericalGradientOption.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.NumericalGradientOption" title="pydrake.math.NumericalGradientOption"><span class="pre">pydrake.math.NumericalGradientOption</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.NumericalGradientMethod" title="pydrake.math.NumericalGradientMethod"><span class="pre">pydrake.math.NumericalGradientMethod</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">function_accuracy</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1e-15</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.math.NumericalGradientOption.__init__" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">function_accuracy</span></code>:</dt><dd><p>The accuracy of evaluating function f(x). For double-valued
functions (with magnitude around 1), the accuracy is usually about
1E-15.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.NumericalGradientOption.NumericalGradientMethod">
<span class="sig-name descname"><span class="pre">NumericalGradientMethod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.NumericalGradientOption" title="pydrake.math.NumericalGradientOption"><span class="pre">pydrake.math.NumericalGradientOption</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.NumericalGradientMethod" title="pydrake.math.NumericalGradientMethod"><span class="pre">pydrake.math.NumericalGradientMethod</span></a></span></span><a class="headerlink" href="#pydrake.math.NumericalGradientOption.NumericalGradientMethod" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.NumericalGradientOption.perturbation_size">
<span class="sig-name descname"><span class="pre">perturbation_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.NumericalGradientOption" title="pydrake.math.NumericalGradientOption"><span class="pre">pydrake.math.NumericalGradientOption</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.math.NumericalGradientOption.perturbation_size" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.pow">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">pow</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.pow" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>pow(arg0: float, arg1: float) -&gt; float</p></li>
<li><p>pow(arg0: pydrake.autodiffutils.AutoDiffXd, arg1: float) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
<li><p>pow(arg0: pydrake.symbolic.Expression, arg1: float) -&gt; pydrake.symbolic.Expression</p></li>
<li><p>pow(arg0: pydrake.symbolic.Expression, arg1: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</p></li>
</ol>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.QuaternionToCanonicalForm">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">QuaternionToCanonicalForm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.QuaternionToCanonicalForm" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>QuaternionToCanonicalForm(quat: pydrake.common.eigen_geometry.Quaternion) -&gt; pydrake.common.eigen_geometry.Quaternion</p></li>
</ol>
<p>This function returns a quaternion in its “canonical form” meaning
that it returns a quaternion [w, x, y, z] with a non-negative w. For
example, if passed a quaternion [-0.3, +0.4, +0.5, +0.707], the
function returns the quaternion’s canonical form [+0.3, -0.4, -0.5,
-0.707].</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quat</span></code>:</dt><dd><p>Quaternion [w, x, y, z] that relates two right-handed orthogonal
unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: quat
is analogous to the rotation matrix R_AB.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Canonical form of quat, which means that either the original quat
is returned or a quaternion representing the same orientation but
with negated [w, x, y, z], to ensure a positive w in returned
quaternion.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>QuaternionToCanonicalForm(quat: pydrake.common.eigen_geometry.Quaternion_[AutoDiffXd]) -&gt; pydrake.common.eigen_geometry.Quaternion_[AutoDiffXd]</p></li>
</ol>
<p>This function returns a quaternion in its “canonical form” meaning
that it returns a quaternion [w, x, y, z] with a non-negative w. For
example, if passed a quaternion [-0.3, +0.4, +0.5, +0.707], the
function returns the quaternion’s canonical form [+0.3, -0.4, -0.5,
-0.707].</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quat</span></code>:</dt><dd><p>Quaternion [w, x, y, z] that relates two right-handed orthogonal
unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: quat
is analogous to the rotation matrix R_AB.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Canonical form of quat, which means that either the original quat
is returned or a quaternion representing the same orientation but
with negated [w, x, y, z], to ensure a positive w in returned
quaternion.</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>QuaternionToCanonicalForm(quat: pydrake.common.eigen_geometry.Quaternion_[Expression]) -&gt; pydrake.common.eigen_geometry.Quaternion_[Expression]</p></li>
</ol>
<p>This function returns a quaternion in its “canonical form” meaning
that it returns a quaternion [w, x, y, z] with a non-negative w. For
example, if passed a quaternion [-0.3, +0.4, +0.5, +0.707], the
function returns the quaternion’s canonical form [+0.3, -0.4, -0.5,
-0.707].</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quat</span></code>:</dt><dd><p>Quaternion [w, x, y, z] that relates two right-handed orthogonal
unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: quat
is analogous to the rotation matrix R_AB.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Canonical form of quat, which means that either the original quat
is returned or a quaternion representing the same orientation but
with negated [w, x, y, z], to ensure a positive w in returned
quaternion.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.RealContinuousLyapunovEquation">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">RealContinuousLyapunovEquation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RealContinuousLyapunovEquation" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">A</span></code>:</dt><dd><p>A user defined real square matrix.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Q</span></code>:</dt><dd><p>A user defined real symmetric matrix.</p>
</dd>
<dt>Precondition:</dt><dd><p>Q is a symmetric matrix.</p>
</dd>
</dl>
<p>Computes a unique solution X to the continuous Lyapunov equation:
<code class="docutils literal notranslate"><span class="pre">AᵀX</span> <span class="pre">+</span> <span class="pre">XA</span> <span class="pre">+</span> <span class="pre">Q</span> <span class="pre">=</span> <span class="pre">0</span></code>, where A is real and square, and Q is real,
symmetric and of equal size as A.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if A</strong><strong> or </strong><strong>Q are not square matrices</strong><strong> or </strong><strong>do not have the</strong> – </p></li>
<li><p><strong>same size.</strong> – </p></li>
</ul>
</dd>
</dl>
<p>Limitations: Given the Eigenvalues of A as λ₁, …, λₙ, there exists a
unique solution if and only if λᵢ + λ̅ⱼ ≠ 0 ∀ i,j, where λ̅ⱼ is the
complex conjugate of λⱼ.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the solution is not unique.</strong> – </p>
</dd>
</dl>
<p>There are no further limitations on the eigenvalues of A. Further, if
all λᵢ have negative real parts, and if Q is positive semi-definite,
then X is also positive semi-definite [1]. Therefore, if one searches
for a Lyapunov function V(z) = zᵀXz for the stable linear system ż =
Az, then the solution of the Lyapunov Equation <code class="docutils literal notranslate"><span class="pre">AᵀX</span> <span class="pre">+</span> <span class="pre">XA</span> <span class="pre">+</span> <span class="pre">Q</span> <span class="pre">=</span> <span class="pre">0</span></code>
only returns a valid Lyapunov function if Q is positive semi-definite.</p>
<p>The implementation is based on SLICOT routine SB03MD [2]. Note the
transformation Q = -C. The complexity of this routine is O(n³). If A
is larger than 2-by-2, then a Schur factorization is performed.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if Schur factorization failed.</strong> – </p>
</dd>
</dl>
<p>A tolerance of ε is used to check if a double variable is equal to
zero, where the default value for ε is 1e-10. It has been used to
check (1) if λᵢ + λ̅ⱼ = 0, ∀ i,j; (2) if A is a 1-by-1 zero matrix;
(3) if A’s trace or determinant is 0 when A is a 2-by-2 matrix.</p>
<p>[1] Bartels, R.H. and G.W. Stewart, “Solution of the Matrix Equation
AX + XB = C,” Comm. of the ACM, Vol. 15, No. 9, 1972.</p>
<p>[2] <a class="reference external" href="http://slicot.org/objects/software/shared/doc/SB03MD.html">http://slicot.org/objects/software/shared/doc/SB03MD.html</a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.RealDiscreteLyapunovEquation">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">RealDiscreteLyapunovEquation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Q</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RealDiscreteLyapunovEquation" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">A</span></code>:</dt><dd><p>A user defined real square matrix.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Q</span></code>:</dt><dd><p>A user defined real symmetric matrix.</p>
</dd>
<dt>Precondition:</dt><dd><p>Q is a symmetric matrix.</p>
</dd>
</dl>
<p>Computes the unique solution X to the discrete Lyapunov equation:
<code class="docutils literal notranslate"><span class="pre">AᵀXA</span> <span class="pre">-</span> <span class="pre">X</span> <span class="pre">+</span> <span class="pre">Q</span> <span class="pre">=</span> <span class="pre">0</span></code>, where A is real and square, and Q is real,
symmetric and of equal size as A.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if A</strong><strong> or </strong><strong>Q are not square matrices</strong><strong> or </strong><strong>do not have the</strong> – </p></li>
<li><p><strong>same size.</strong> – </p></li>
</ul>
</dd>
</dl>
<p>Limitations: Given the Eigenvalues of A as λ₁, …, λₙ, there exists a
unique solution if and only if λᵢ * λⱼ ≠ 1 ∀ i,j and λᵢ ≠ ±1, ∀ i [1].</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the solution is not unique.</strong><strong>[</strong><strong>3</strong><strong>]</strong> – </p>
</dd>
</dl>
<p>There are no further limitations on the eigenvalues of A. Further, if
<a href="#id1"><span class="problematic" id="id2">|</span></a>λᵢ|&lt;1, ∀ i, and if Q is positive semi-definite, then X is also
positive semi-definite [2]. Therefore, if one searches for a Lyapunov
function V(z) = zᵀXz for the stable linear system zₙ₊₁ = Azₙ, then the
solution of the Lyapunov Equation <code class="docutils literal notranslate"><span class="pre">AᵀXA</span> <span class="pre">-</span> <span class="pre">X</span> <span class="pre">+</span> <span class="pre">Q</span> <span class="pre">=</span> <span class="pre">0</span></code> only returns a
valid Lyapunov function if Q is positive semi-definite.</p>
<p>The implementation is based on SLICOT routine SB03MD [2]. Note the
transformation Q = -C. The complexity of this routine is O(n³). If A
is larger than 2-by-2, then a Schur factorization is performed.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if Schur factorization fails.</strong> – </p>
</dd>
</dl>
<p>A tolerance of ε is used to check if a double variable is equal to
zero, where the default value for ε is 1e-10. It has been used to
check (1) if λᵢ = ±1 ∀ i; (2) if λᵢ * λⱼ = 1, i ≠ j.</p>
<p>[1] Barraud, A.Y., “A numerical algorithm to solve AᵀXA - X = Q,”
IEEE® Trans. Auto. Contr., AC-22, pp. 883-885, 1977.</p>
<p>[2] <a class="reference external" href="http://slicot.org/objects/software/shared/doc/SB03MD.html">http://slicot.org/objects/software/shared/doc/SB03MD.html</a></p>
<p>[3] <a class="reference external" href="https://www.mathworks.com/help/control/ref/dlyap.html">https://www.mathworks.com/help/control/ref/dlyap.html</a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">RigidTransform</span></span><a class="headerlink" href="#pydrake.math.RigidTransform" title="Permalink to this definition"></a></dt>
<dd><p>This class represents a proper rigid transform between two frames
which can be regarded in two ways. A rigid transform describes the
“pose” between two frames A and B (i.e., the relative orientation and
position of A to B). Alternately, it can be regarded as a
distance-preserving operator that can rotate and/or translate a rigid
body without changing its shape or size (rigid) and without
mirroring/reflecting the body (proper), e.g., it can add one position
vector to another and express the result in a particular basis as
<code class="docutils literal notranslate"><span class="pre">p_AoQ_A</span> <span class="pre">=</span> <span class="pre">X_AB</span> <span class="pre">*</span> <span class="pre">p_BoQ_B</span></code> (Q is any point). In many ways, this
rigid transform class is conceptually similar to using a homogeneous
matrix as a linear operator. See operator* documentation for an
exception.</p>
<p>The class stores a RotationMatrix that relates right-handed orthogonal
unit vectors Ax, Ay, Az fixed in frame A to right-handed orthogonal
unit vectors Bx, By, Bz fixed in frame B. The class also stores a
position vector from Ao (the origin of frame A) to Bo (the origin of
frame B). The position vector is expressed in frame A. The monogram
notation for the transform relating frame A to B is <code class="docutils literal notranslate"><span class="pre">X_AB</span></code>. The
monogram notation for the rotation matrix relating A to B is <code class="docutils literal notranslate"><span class="pre">R_AB</span></code>.
The monogram notation for the position vector from Ao to Bo is
<code class="docutils literal notranslate"><span class="pre">p_AoBo_A</span></code>. See multibody_quantities for monogram notation for
dynamics.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class does not store the frames associated with the transform
and cannot enforce correct usage of this class. For example, it
makes sense to multiply RigidTransforms as <code class="docutils literal notranslate"><span class="pre">X_AB</span> <span class="pre">*</span> <span class="pre">X_BC</span></code>, but
not <code class="docutils literal notranslate"><span class="pre">X_AB</span> <span class="pre">*</span> <span class="pre">X_CB</span></code>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is not a 4x4 transformation matrix – even though its
operator*() methods act mostly like 4x4 matrix multiplication.
Instead, this class contains a 3x3 rotation matrix class and a 3x1
position vector. To convert this to a 3x4 matrix, use
GetAsMatrix34(). To convert this to a 4x4 matrix, use
GetAsMatrix4(). To convert this to an Eigen::Isometry, use
GetAsIsometry().</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>An isometry is sometimes regarded as synonymous with rigid
transform. The RigidTransform class has important advantages over
Eigen::Isometry. - RigidTransform is built on an underlying
rigorous 3x3 RotationMatrix class that has significant
functionality for 3D orientation. - In Debug builds,
RigidTransform requires a valid 3x3 rotation matrix and a valid
(non-NAN) position vector. Eigen::Isometry does not. -
RigidTransform catches bugs that are undetected by
Eigen::Isometry. - RigidTransform has additional functionality and
ease-of-use, resulting in shorter, easier to write, and easier to
read code. - The name Isometry is unfamiliar to many roboticists
and dynamicists and for them Isometry.linear() is (for example) a
counter-intuitive method name to return a rotation matrix.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>One of the constructors in this class provides an implicit
conversion from an Eigen Translation to RigidTransform.</p>
</div>
<dl class="simple">
<dt>Authors:</dt><dd><p>Paul Mitiguy (2018) Original author.</p>
</dd>
<dt>Authors:</dt><dd><p>Drake team (see <a class="reference external" href="https://drake.mit.edu/credits">https://drake.mit.edu/credits</a>).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><code class="xref py py-class docutils literal notranslate"><span class="pre">RigidTransform_</span></code></a>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.RigidTransform.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.math.RigidTransform) -&gt; None</p></li>
</ol>
<p>Constructs the RigidTransform that corresponds to aligning the two
frames so unit vectors Ax = Bx, Ay = By, Az = Bz and point Ao is
coincident with Bo. Hence, the constructed RigidTransform contains an
identity RotationMatrix and a zero position vector.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.math.RigidTransform, other: pydrake.math.RigidTransform) -&gt; None</p></li>
<li><p>__init__(self: pydrake.math.RigidTransform, R: pydrake.math.RotationMatrix, p: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs a RigidTransform from a rotation matrix and a position
vector.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R</span></code>:</dt><dd><p>rotation matrix relating frames A and B (e.g., <code class="docutils literal notranslate"><span class="pre">R_AB</span></code>).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p</span></code>:</dt><dd><p>position vector from frame A’s origin to frame B’s origin,
expressed in frame A. In monogram notation p is denoted
<code class="docutils literal notranslate"><span class="pre">p_AoBo_A</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.math.RigidTransform, rpy: pydrake.math.RollPitchYaw, p: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs a RigidTransform from a RollPitchYaw and a position vector.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rpy</span></code>:</dt><dd><p>a RollPitchYaw which is a Space-fixed (extrinsic) X-Y-Z rotation
with “roll-pitch-yaw” angles <code class="docutils literal notranslate"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code> or equivalently a Body-
fixed (intrinsic) Z-Y-X rotation with “yaw-pitch-roll” angles
<code class="docutils literal notranslate"><span class="pre">[y,</span> <span class="pre">p,</span> <span class="pre">r]</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RotationMatrix::RotationMatrix(const RollPitchYaw&lt;T&gt;&amp;)</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p</span></code>:</dt><dd><p>position vector from frame A’s origin to frame B’s origin,
expressed in frame A. In monogram notation p is denoted
<code class="docutils literal notranslate"><span class="pre">p_AoBo_A</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="5">
<li><p>__init__(self: pydrake.math.RigidTransform, quaternion: pydrake.common.eigen_geometry.Quaternion, p: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs a RigidTransform from a Quaternion and a position vector.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quaternion</span></code>:</dt><dd><p>a non-zero, finite quaternion which may or may not have unit
length [i.e., <code class="docutils literal notranslate"><span class="pre">quaternion.norm()</span></code> does not have to be 1].</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p</span></code>:</dt><dd><p>position vector from frame A’s origin to frame B’s origin,
expressed in frame A. In monogram notation p is denoted
<code class="docutils literal notranslate"><span class="pre">p_AoBo_A</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError in debug builds if the rotation matrix that is built</strong> – </p></li>
<li><p><strong>from quaternion is invalid.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RotationMatrix::RotationMatrix(const Eigen::Quaternion&lt;T&gt;&amp;)</p>
</div>
<ol class="arabic simple" start="6">
<li><p>__init__(self: pydrake.math.RigidTransform, theta_lambda: pydrake.common.eigen_geometry.AngleAxis, p: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs a RigidTransform from an AngleAxis and a position vector.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta_lambda</span></code>:</dt><dd><p>an Eigen::AngleAxis whose associated axis (vector direction herein
called <code class="docutils literal notranslate"><span class="pre">lambda</span></code>) is non-zero and finite, but which may or may
not have unit length [i.e., <code class="docutils literal notranslate"><span class="pre">lambda.norm()</span></code> does not have to be
1].</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p</span></code>:</dt><dd><p>position vector from frame A’s origin to frame B’s origin,
expressed in frame A. In monogram notation p is denoted <a href="#id3"><span class="problematic" id="id4">``</span></a>p_AoBo_A</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError in debug builds if the rotation matrix that is built</strong> – </p></li>
<li><p><strong>from theta_lambda` is invalid.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RotationMatrix::RotationMatrix(const Eigen::AngleAxis&lt;T&gt;&amp;)</p>
</div>
<ol class="arabic simple" start="7">
<li><p>__init__(self: pydrake.math.RigidTransform, R: pydrake.math.RotationMatrix) -&gt; None</p></li>
</ol>
<p>Constructs a RigidTransform with a given RotationMatrix and a zero
position vector.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R</span></code>:</dt><dd><p>rotation matrix relating frames A and B (e.g., <code class="docutils literal notranslate"><span class="pre">R_AB</span></code>).</p>
</dd>
</dl>
<ol class="arabic simple" start="8">
<li><p>__init__(self: pydrake.math.RigidTransform, p: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs a RigidTransform that contains an identity RotationMatrix
and a given position vector <code class="docutils literal notranslate"><span class="pre">p</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p</span></code>:</dt><dd><p>position vector from frame A’s origin to frame B’s origin,
expressed in frame A. In monogram notation p is denoted
<code class="docutils literal notranslate"><span class="pre">p_AoBo_A</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="9">
<li><p>__init__(self: pydrake.math.RigidTransform, pose: pydrake.common.eigen_geometry.Isometry3) -&gt; None</p></li>
</ol>
<p>Constructs a RigidTransform from an Eigen Isometry3.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pose</span></code>:</dt><dd><p>Isometry3 that contains an allegedly valid rotation matrix
<code class="docutils literal notranslate"><span class="pre">R_AB</span></code> and also contains a position vector <code class="docutils literal notranslate"><span class="pre">p_AoBo_A</span></code> from
frame A’s origin to frame B’s origin. <code class="docutils literal notranslate"><span class="pre">p_AoBo_A</span></code> must be
expressed in frame A.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError in debug builds if R_AB is not a proper orthonormal</strong> – </p></li>
<li><p><strong>3x3 rotation matrix.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>No attempt is made to orthogonalize the 3x3 rotation matrix part
of <code class="docutils literal notranslate"><span class="pre">pose</span></code>. As needed, use
RotationMatrix::ProjectToRotationMatrix().</p>
</div>
<ol class="arabic simple" start="10">
<li><p>__init__(self: pydrake.math.RigidTransform, pose: numpy.ndarray[numpy.float64[m, n]]) -&gt; None</p></li>
</ol>
<p>Constructs a RigidTransform from an appropriate Eigen <strong>expression</strong>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pose</span></code>:</dt><dd><p>Generic Eigen matrix <strong>expression</strong>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the Eigen expression in pose does not resolve</strong> – </p></li>
<li><p><strong>to a Vector3</strong><strong> or </strong><strong>3x4 matrix</strong><strong> or </strong><strong>4x4 matrix</strong><strong> or </strong><strong>if the rotational part</strong> – </p></li>
<li><p><strong>of pose is not a proper orthonormal 3x3 rotation matrix</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>pose` is a 4x4 matrix whose final row is not</strong><strong> [</strong><strong>0</strong><strong>, </strong><strong>0</strong><strong>, </strong><strong>0</strong><strong>, </strong><strong>1</strong><strong>]</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>No attempt is made to orthogonalize the 3x3 rotation matrix part
of <code class="docutils literal notranslate"><span class="pre">pose</span></code>. As needed, use
RotationMatrix::ProjectToRotationMatrix().</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This constructor prevents ambiguity that would otherwise exist for
a RigidTransform constructor whose argument is an Eigen
<strong>expression</strong>.</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="n">Vector3</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">position</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">X1</span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">position</span><span class="p">);</span><span class="w"></span>
<span class="o">----------------------------------------------</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">R</span><span class="p">(</span><span class="n">RollPitchYaw</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">));</span><span class="w"></span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pose34</span><span class="p">;</span><span class="w"></span>
<span class="n">pose34</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">R</span><span class="p">.</span><span class="n">matrix</span><span class="p">(),</span><span class="w"> </span><span class="n">position</span><span class="p">;</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">X2</span><span class="p">(</span><span class="mf">1.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pose34</span><span class="p">);</span><span class="w"></span>
<span class="o">----------------------------------------------</span><span class="w"></span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pose4</span><span class="p">;</span><span class="w"></span>
<span class="n">pose4</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">R</span><span class="p">.</span><span class="n">matrix</span><span class="p">(),</span><span class="w"> </span><span class="n">position</span><span class="p">,</span><span class="w"></span>
<span class="w">         </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">X3</span><span class="p">(</span><span class="n">pose4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pose4</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</details></dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform.cast">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">cast</span></span><a class="headerlink" href="#pydrake.math.RigidTransform.cast" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">cast[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">cast[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">cast[Expression]</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform.cast-AutoDiffXd">
<span id="pydrake.math.RigidTransform.cast[AutoDiffXd]"></span><span class="sig-name descname"><span class="pre">cast[AutoDiffXd]</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform.cast-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><p>Creates a RigidTransform templatized on a scalar type U from a
RigidTransform templatized on scalar type T. For example,</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">Identity</span><span class="p">();</span><span class="w"></span>
<span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">source</span><span class="p">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
</details><dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">U</span></code>:</dt><dd><p>Scalar type on which the returned RigidTransform is templated.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">RigidTransform&lt;From&gt;::cast&lt;To&gt;()</span></code> creates a new
<code class="docutils literal notranslate"><span class="pre">RigidTransform&lt;To&gt;</span></code> from a <code class="docutils literal notranslate"><span class="pre">RigidTransform&lt;From&gt;</span></code> but only if
type <code class="docutils literal notranslate"><span class="pre">To</span></code> is constructible from type <code class="docutils literal notranslate"><span class="pre">From</span></code>. This cast method
works in accordance with Eigen’s cast method for Eigen’s objects
that underlie this RigidTransform. For example, Eigen currently
allows cast from type double to AutoDiffXd, but not vice-versa.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform.cast-Expression">
<span id="pydrake.math.RigidTransform.cast[Expression]"></span><span class="sig-name descname"><span class="pre">cast[Expression]</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform.cast-Expression" title="Permalink to this definition"></a></dt>
<dd><p>Creates a RigidTransform templatized on a scalar type U from a
RigidTransform templatized on scalar type T. For example,</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">Identity</span><span class="p">();</span><span class="w"></span>
<span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">source</span><span class="p">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
</details><dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">U</span></code>:</dt><dd><p>Scalar type on which the returned RigidTransform is templated.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">RigidTransform&lt;From&gt;::cast&lt;To&gt;()</span></code> creates a new
<code class="docutils literal notranslate"><span class="pre">RigidTransform&lt;To&gt;</span></code> from a <code class="docutils literal notranslate"><span class="pre">RigidTransform&lt;From&gt;</span></code> but only if
type <code class="docutils literal notranslate"><span class="pre">To</span></code> is constructible from type <code class="docutils literal notranslate"><span class="pre">From</span></code>. This cast method
works in accordance with Eigen’s cast method for Eigen’s objects
that underlie this RigidTransform. For example, Eigen currently
allows cast from type double to AutoDiffXd, but not vice-versa.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform.cast-float">
<span id="pydrake.math.RigidTransform.cast[float]"></span><span class="sig-name descname"><span class="pre">cast[float]</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></span><a class="headerlink" href="#pydrake.math.RigidTransform.cast-float" title="Permalink to this definition"></a></dt>
<dd><p>Creates a RigidTransform templatized on a scalar type U from a
RigidTransform templatized on scalar type T. For example,</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">Identity</span><span class="p">();</span><span class="w"></span>
<span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">source</span><span class="p">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
</details><dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">U</span></code>:</dt><dd><p>Scalar type on which the returned RigidTransform is templated.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">RigidTransform&lt;From&gt;::cast&lt;To&gt;()</span></code> creates a new
<code class="docutils literal notranslate"><span class="pre">RigidTransform&lt;To&gt;</span></code> from a <code class="docutils literal notranslate"><span class="pre">RigidTransform&lt;From&gt;</span></code> but only if
type <code class="docutils literal notranslate"><span class="pre">To</span></code> is constructible from type <code class="docutils literal notranslate"><span class="pre">From</span></code>. This cast method
works in accordance with Eigen’s cast method for Eigen’s objects
that underlie this RigidTransform. For example, Eigen currently
allows cast from type double to AutoDiffXd, but not vice-versa.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform.GetAsIsometry3">
<span class="sig-name descname"><span class="pre">GetAsIsometry3</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.common.eigen_geometry.html#pydrake.common.eigen_geometry.Isometry3" title="pydrake.common.eigen_geometry.Isometry3"><span class="pre">pydrake.common.eigen_geometry.Isometry3</span></a></span></span><a class="headerlink" href="#pydrake.math.RigidTransform.GetAsIsometry3" title="Permalink to this definition"></a></dt>
<dd><p>Returns the isometry in ℜ³ that is equivalent to a RigidTransform.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform.GetAsMatrix34">
<span class="sig-name descname"><span class="pre">GetAsMatrix34</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">4</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform.GetAsMatrix34" title="Permalink to this definition"></a></dt>
<dd><p>Returns the 3x4 matrix associated with this RigidTransform, i.e.,
X_AB.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>┌                ┐
 │ R_AB  p_AoBo_A │
 └                ┘
</pre></div>
</div>
</details></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform.GetAsMatrix4">
<span class="sig-name descname"><span class="pre">GetAsMatrix4</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">4</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">4</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform.GetAsMatrix4" title="Permalink to this definition"></a></dt>
<dd><p>Returns the 4x4 matrix associated with this RigidTransform, i.e.,
X_AB.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>┌                ┐
 │ R_AB  p_AoBo_A │
 │                │
 │   0      1     │
 └                ┘
</pre></div>
</div>
</details></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform.GetMaximumAbsoluteDifference">
<span class="sig-name descname"><span class="pre">GetMaximumAbsoluteDifference</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform.GetMaximumAbsoluteDifference" title="Permalink to this definition"></a></dt>
<dd><p>Computes the infinity norm of <code class="docutils literal notranslate"><span class="pre">this</span></code> - <cite>other</cite> (i.e., the maximum
absolute value of the difference between the elements of <code class="docutils literal notranslate"><span class="pre">this</span></code> and
<code class="docutils literal notranslate"><span class="pre">other</span></code>).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other</span></code>:</dt><dd><p>RigidTransform to subtract from <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>‖<cite>this</cite> - <cite>other</cite>‖∞</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform.GetMaximumAbsoluteTranslationDifference">
<span class="sig-name descname"><span class="pre">GetMaximumAbsoluteTranslationDifference</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform.GetMaximumAbsoluteTranslationDifference" title="Permalink to this definition"></a></dt>
<dd><p>Returns the maximum absolute value of the difference in the position
vectors (translation) in <code class="docutils literal notranslate"><span class="pre">this</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>. In other words,
returns the infinity norm of the difference in the position vectors.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other</span></code>:</dt><dd><p>RigidTransform whose position vector is subtracted from the
position vector in <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform.Identity">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Identity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></span><a class="headerlink" href="#pydrake.math.RigidTransform.Identity" title="Permalink to this definition"></a></dt>
<dd><p>Returns the identity RigidTransform (corresponds to coincident
frames).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the RigidTransform that corresponds to aligning the two frames so
unit vectors Ax = Bx, Ay = By, Az = Bz and point Ao is coincident
with Bo. Hence, the returned RigidTransform contains a 3x3
identity matrix and a zero position vector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform.inverse">
<span class="sig-name descname"><span class="pre">inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></span><a class="headerlink" href="#pydrake.math.RigidTransform.inverse" title="Permalink to this definition"></a></dt>
<dd><p>Returns X_BA = X_AB⁻¹, the inverse of <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The inverse of RigidTransform X_AB is X_BA, which contains the
rotation matrix R_BA = R_AB⁻¹ = R_ABᵀ and the position vector
<code class="docutils literal notranslate"><span class="pre">p_BoAo_B_</span></code> (position from B’s origin Bo to A’s origin Ao,
expressed in frame B).</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>: The square-root of a RigidTransform’s condition number is
roughly the magnitude of the position vector. The accuracy of the
calculation for the inverse of a RigidTransform drops off with the
sqrt condition number.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform.InvertAndCompose">
<span class="sig-name descname"><span class="pre">InvertAndCompose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></span><a class="headerlink" href="#pydrake.math.RigidTransform.InvertAndCompose" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the product of <code class="docutils literal notranslate"><span class="pre">this</span></code> inverted and another
RigidTransform. If you consider <code class="docutils literal notranslate"><span class="pre">this</span></code> to be the transform X_AB, and
<code class="docutils literal notranslate"><span class="pre">other</span></code> to be X_AC, then this method returns X_BC = X_AB⁻¹ * X_AC.
For T==double, this method can be <em>much</em> faster than inverting first
and then performing the composition, because it can take advantage of
the special structure of a rigid transform to avoid unnecessary memory
and floating point operations. On some platforms it can use SIMD
instructions for further speedups.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other</span></code>:</dt><dd><p>RigidTransform that post-multiplies <code class="docutils literal notranslate"><span class="pre">this</span></code> inverted.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">X_BC</span></code>:</dt><dd><p>where X_BC = this⁻¹ * other.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is possible (albeit improbable) to create an invalid rigid
transform by accumulating round-off error with a large number of
multiplies.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform.IsExactlyEqualTo">
<span class="sig-name descname"><span class="pre">IsExactlyEqualTo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform.IsExactlyEqualTo" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if <code class="docutils literal notranslate"><span class="pre">this</span></code> is exactly equal to <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other</span></code>:</dt><dd><p>RigidTransform to compare to <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if each element of <code class="docutils literal notranslate"><span class="pre">this</span></code> is exactly equal to the
corresponding element of <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform.IsExactlyIdentity">
<span class="sig-name descname"><span class="pre">IsExactlyIdentity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform.IsExactlyIdentity" title="Permalink to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">this</span></code> is exactly the identity RigidTransform.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>IsNearlyIdentity().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform.IsNearlyEqualTo">
<span class="sig-name descname"><span class="pre">IsNearlyEqualTo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform.IsNearlyEqualTo" title="Permalink to this definition"></a></dt>
<dd><p>Compares each element of <code class="docutils literal notranslate"><span class="pre">this</span></code> to the corresponding element of
<code class="docutils literal notranslate"><span class="pre">other</span></code> to check if they are the same to within a specified
<code class="docutils literal notranslate"><span class="pre">tolerance</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other</span></code>:</dt><dd><p>RigidTransform to compare to <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">tolerance</span></code>:</dt><dd><p>maximum allowable absolute difference between the elements in
<code class="docutils literal notranslate"><span class="pre">this</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">‖this.matrix()</span> <span class="pre">-</span> <span class="pre">other.matrix()‖∞</span> <span class="pre">&lt;=</span> <span class="pre">tolerance</span></code>.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Consider scaling tolerance with the largest of magA and magB,
where magA and magB denoted the magnitudes of <code class="docutils literal notranslate"><span class="pre">this</span></code> position
vector and <code class="docutils literal notranslate"><span class="pre">other</span></code> position vectors, respectively.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform.IsNearlyIdentity">
<span class="sig-name descname"><span class="pre">IsNearlyIdentity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">translation_tolerance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform.IsNearlyIdentity" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if <code class="docutils literal notranslate"><span class="pre">this</span></code> is within tolerance of the identity
RigidTransform.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">translation_tolerance</span></code>:</dt><dd><p>a non-negative number. One way to choose <code class="docutils literal notranslate"><span class="pre">translation_tolerance</span></code>
is to multiply a characteristic length (e.g., the magnitude of a
characteristic position vector) by an epsilon (e.g.,
RotationMatrix::get_internal_tolerance_for_orthonormality()).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if the RotationMatrix portion of <code class="docutils literal notranslate"><span class="pre">this</span></code> satisfies
RotationMatrix::IsNearlyIdentity() and if the position vector
portion of <code class="docutils literal notranslate"><span class="pre">this</span></code> is equal to zero vector within
<code class="docutils literal notranslate"><span class="pre">translation_tolerance</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>IsExactlyIdentity().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform.MakeUnchecked">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeUnchecked</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pose</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">4</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></span><a class="headerlink" href="#pydrake.math.RigidTransform.MakeUnchecked" title="Permalink to this definition"></a></dt>
<dd><p>(Advanced) Constructs a RigidTransform from a 3x4 matrix, without any
validity checks nor orthogonalization.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pose</span></code>:</dt><dd><p>3x4 matrix that contains a 3x3 rotation matrix <code class="docutils literal notranslate"><span class="pre">R_AB</span></code> and also a
3x1 position vector <code class="docutils literal notranslate"><span class="pre">p_AoBo_A</span></code> (the position vector from frame
A’s origin to frame B’s origin, expressed in frame A).</p>
</dd>
</dl>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>┌                ┐
 │ R_AB  p_AoBo_A │
 └                ┘
</pre></div>
</div>
</details></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform.multiply">
<span class="sig-name descname"><span class="pre">multiply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.RigidTransform.multiply" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>multiply(self: pydrake.math.RigidTransform, other: pydrake.math.RigidTransform) -&gt; pydrake.math.RigidTransform</p></li>
</ol>
<p>Multiplies <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform <code class="docutils literal notranslate"><span class="pre">X_AB</span></code> by the <code class="docutils literal notranslate"><span class="pre">other</span></code>
RigidTransform <code class="docutils literal notranslate"><span class="pre">X_BC</span></code> and returns the RigidTransform <code class="docutils literal notranslate"><span class="pre">X_AC</span> <span class="pre">=</span> <span class="pre">X_AB</span> <span class="pre">*</span>
<span class="pre">X_BC</span></code>.</p>
<ol class="arabic simple" start="2">
<li><p>multiply(self: pydrake.math.RigidTransform, p_BoQ_B: numpy.ndarray[numpy.float64[3, 1]]) -&gt; numpy.ndarray[numpy.float64[3, 1]]</p></li>
</ol>
<p>Multiplies <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform <code class="docutils literal notranslate"><span class="pre">X_AB</span></code> by the position vector
<code class="docutils literal notranslate"><span class="pre">p_BoQ_B</span></code> which is from Bo (B’s origin) to an arbitrary point Q.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BoQ_B</span></code>:</dt><dd><p>position vector from Bo to Q, expressed in frame B.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_AoQ_A</span></code>:</dt><dd><p>position vector from Ao to Q, expressed in frame A.</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>multiply(self: pydrake.math.RigidTransform, vec_B: numpy.ndarray[numpy.float64[4, 1]]) -&gt; numpy.ndarray[numpy.float64[4, 1]]</p></li>
</ol>
<p>Multiplies <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform <code class="docutils literal notranslate"><span class="pre">X_AB</span></code> by the 4-element vector
<code class="docutils literal notranslate"><span class="pre">vec_B</span></code>, equivalent to <code class="docutils literal notranslate"><span class="pre">X_AB.GetAsMatrix4()</span> <span class="pre">*</span> <span class="pre">vec_B</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">vec_B</span></code>:</dt><dd><p>4-element vector whose first 3 elements are the position vector
p_BoQ_B from Bo (frame B’s origin) to an arbitrary point Q,
expressed in frame B and whose 4ᵗʰ element is 1 𝐨𝐫 whose first 3
elements are a vector (maybe unrelated to Bo or Q) and whose 4ᵗʰ
element is 0.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">vec_A</span></code>:</dt><dd><p>4-element vector whose first 3 elements are the position vector
p_AoQ_A from Ao (frame A’s origin) to Q, expressed in frame A and
whose 4ᵗʰ element is 1 𝐨𝐫 whose first 3 elements are a vector
(maybe unrelated to Bo and Q) and whose 4ᵗʰ element is 0.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the 4ᵗʰ element of vec_B is not 0</strong><strong> or </strong><strong>1.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>multiply(self: pydrake.math.RigidTransform, p_BoQ_B: numpy.ndarray[numpy.float64[3, n]]) -&gt; numpy.ndarray[numpy.float64[3, n]]</p></li>
</ol>
<p>Multiplies <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform <code class="docutils literal notranslate"><span class="pre">X_AB</span></code> by the n position vectors
<code class="docutils literal notranslate"><span class="pre">p_BoQ1_B</span></code> … <cite>p_BoQn_B</cite>, where <code class="docutils literal notranslate"><span class="pre">p_BoQi_B</span></code> is the iᵗʰ position
vector from Bo (frame B’s origin) to an arbitrary point Qi, expressed
in frame B.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BoQ_B</span></code>:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix with n position vectors <code class="docutils literal notranslate"><span class="pre">p_BoQi_B</span></code> or an
expression that resolves to a <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix of position
vectors.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_AoQ_A</span></code>:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix with n position vectors <code class="docutils literal notranslate"><span class="pre">p_AoQi_A</span></code>, i.e., n
position vectors from Ao (frame A’s origin) to Qi, expressed in
frame A. Specifically, this operator* is defined so that <code class="docutils literal notranslate"><span class="pre">X_AB</span> <span class="pre">*</span>
<span class="pre">p_BoQ_B</span></code> returns <code class="docutils literal notranslate"><span class="pre">p_AoQ_A</span> <span class="pre">=</span> <span class="pre">p_AoBo_A</span> <span class="pre">+</span> <span class="pre">R_AB</span> <span class="pre">*</span> <span class="pre">p_BoQ_B</span></code>, where
<code class="docutils literal notranslate"><span class="pre">p_AoBo_A</span></code> is the position vector from Ao to Bo expressed in A
and <code class="docutils literal notranslate"><span class="pre">R_AB</span></code> is the rotation matrix relating the orientation of
frames A and B.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As needed, use parentheses. This operator* is not associative. To
see this, let <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">p_AoBo_A</span></code>, <cite>q = p_BoQ_B</cite> and note (X_AB * q)
* 7 = (p + R_AB * q) * 7 ≠ X_AB * (q * 7) = p + R_AB * (q * 7).</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="n">RollPitchYaw</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">rpy</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span><span class="w"> </span><span class="mf">0.2</span><span class="p">,</span><span class="w"> </span><span class="mf">0.3</span><span class="p">);</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">X_AB</span><span class="p">(</span><span class="n">rpy</span><span class="p">,</span><span class="w"> </span><span class="n">Vector3d</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">));</span><span class="w"></span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p_BoQ_B</span><span class="p">;</span><span class="w"></span>
<span class="n">p_BoQ_B</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Vector3d</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span><span class="w"></span>
<span class="n">p_BoQ_B</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Vector3d</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">);</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p_AoQ_A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X_AB</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p_BoQ_B</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</details></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform.rotation">
<span class="sig-name descname"><span class="pre">rotation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RotationMatrix" title="pydrake.math.RotationMatrix"><span class="pre">pydrake.math.RotationMatrix</span></a></span></span><a class="headerlink" href="#pydrake.math.RigidTransform.rotation" title="Permalink to this definition"></a></dt>
<dd><p>Returns R_AB, the rotation matrix portion of <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform.</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">R_AB</span></code>:</dt><dd><p>the rotation matrix portion of <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform.set">
<span class="sig-name descname"><span class="pre">set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix" title="pydrake.math.RotationMatrix"><span class="pre">pydrake.math.RotationMatrix</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform.set" title="Permalink to this definition"></a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform from a RotationMatrix and a position
vector.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R</span></code>:</dt><dd><p>rotation matrix relating frames A and B (e.g., <code class="docutils literal notranslate"><span class="pre">R_AB</span></code>).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p</span></code>:</dt><dd><p>position vector from frame A’s origin to frame B’s origin,
expressed in frame A. In monogram notation p is denoted
<code class="docutils literal notranslate"><span class="pre">p_AoBo_A</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform.set_rotation">
<span class="sig-name descname"><span class="pre">set_rotation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.RigidTransform.set_rotation" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>set_rotation(self: pydrake.math.RigidTransform, R: pydrake.math.RotationMatrix) -&gt; None</p></li>
</ol>
<p>Sets the RotationMatrix portion of <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R</span></code>:</dt><dd><p>rotation matrix relating frames A and B (e.g., <code class="docutils literal notranslate"><span class="pre">R_AB</span></code>).</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>set_rotation(self: pydrake.math.RigidTransform, rpy: pydrake.math.RollPitchYaw) -&gt; None</p></li>
</ol>
<p>Sets the rotation part of <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform from a RollPitchYaw.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rpy</span></code>:</dt><dd><p>“roll-pitch-yaw” angles.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RotationMatrix::RotationMatrix(const RollPitchYaw&lt;T&gt;&amp;) which
describes the parameter, preconditions, etc.</p>
</div>
<ol class="arabic simple" start="3">
<li><p>set_rotation(self: pydrake.math.RigidTransform, quaternion: pydrake.common.eigen_geometry.Quaternion) -&gt; None</p></li>
</ol>
<p>Sets the rotation part of <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform from a Quaternion.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quaternion</span></code>:</dt><dd><p>a quaternion which may or may not have unit length.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RotationMatrix::RotationMatrix(const Eigen::Quaternion&lt;T&gt;&amp;) which
describes the parameter, preconditions, exception conditions, etc.</p>
</div>
<ol class="arabic simple" start="4">
<li><p>set_rotation(self: pydrake.math.RigidTransform, theta_lambda: pydrake.common.eigen_geometry.AngleAxis) -&gt; None</p></li>
</ol>
<p>Sets the rotation part of <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform from an AngleAxis.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta_lambda</span></code>:</dt><dd><p>an angle <code class="docutils literal notranslate"><span class="pre">theta</span></code> (in radians) and vector <code class="docutils literal notranslate"><span class="pre">lambda</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RotationMatrix::RotationMatrix(const Eigen::AngleAxis&lt;T&gt;&amp;) which
describes the parameter, preconditions, exception conditions, etc.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform.set_translation">
<span class="sig-name descname"><span class="pre">set_translation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform.set_translation" title="Permalink to this definition"></a></dt>
<dd><p>Sets the position vector portion of <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p</span></code>:</dt><dd><p>position vector from Ao (frame A’s origin) to Bo (frame B’s
origin) expressed in frame A. In monogram notation p is denoted
p_AoBo_A.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform.SetFromIsometry3">
<span class="sig-name descname"><span class="pre">SetFromIsometry3</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">pose</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.common.eigen_geometry.html#pydrake.common.eigen_geometry.Isometry3" title="pydrake.common.eigen_geometry.Isometry3"><span class="pre">pydrake.common.eigen_geometry.Isometry3</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform.SetFromIsometry3" title="Permalink to this definition"></a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform from an Eigen Isometry3.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pose</span></code>:</dt><dd><p>Isometry3 that contains an allegedly valid rotation matrix
<code class="docutils literal notranslate"><span class="pre">R_AB</span></code> and also contains a position vector <code class="docutils literal notranslate"><span class="pre">p_AoBo_A</span></code> from
frame A’s origin to frame B’s origin. <code class="docutils literal notranslate"><span class="pre">p_AoBo_A</span></code> must be
expressed in frame A.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError in debug builds if R_AB is not a proper orthonormal</strong> – </p></li>
<li><p><strong>3x3 rotation matrix.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>No attempt is made to orthogonalize the 3x3 rotation matrix part
of <code class="docutils literal notranslate"><span class="pre">pose</span></code>. As needed, use
RotationMatrix::ProjectToRotationMatrix().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform.SetIdentity">
<span class="sig-name descname"><span class="pre">SetIdentity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></span><a class="headerlink" href="#pydrake.math.RigidTransform.SetIdentity" title="Permalink to this definition"></a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform so it corresponds to aligning the two
frames so unit vectors Ax = Bx, Ay = By, Az = Bz and point Ao is
coincident with Bo. Hence, <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform contains a 3x3
identity matrix and a zero position vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform.translation">
<span class="sig-name descname"><span class="pre">translation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform.translation" title="Permalink to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">p_AoBo_A</span></code>, the position vector portion of <code class="docutils literal notranslate"><span class="pre">this</span></code>
RigidTransform, i.e., position vector from Ao (frame A’s origin) to Bo
(frame B’s origin).</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">RigidTransform_</span></span><a class="headerlink" href="#pydrake.math.RigidTransform_" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">RigidTransform_[float]</span></code>, <a class="reference internal" href="#pydrake.math.RigidTransform_-AutoDiffXd" title="pydrake.math.RigidTransform_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">RigidTransform_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.math.RigidTransform_-Expression" title="pydrake.math.RigidTransform_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">RigidTransform_[Expression]</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-AutoDiffXd">
<span id="pydrake.math.RigidTransform_[AutoDiffXd]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">RigidTransform_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><p>This class represents a proper rigid transform between two frames
which can be regarded in two ways. A rigid transform describes the
“pose” between two frames A and B (i.e., the relative orientation and
position of A to B). Alternately, it can be regarded as a
distance-preserving operator that can rotate and/or translate a rigid
body without changing its shape or size (rigid) and without
mirroring/reflecting the body (proper), e.g., it can add one position
vector to another and express the result in a particular basis as
<code class="docutils literal notranslate"><span class="pre">p_AoQ_A</span> <span class="pre">=</span> <span class="pre">X_AB</span> <span class="pre">*</span> <span class="pre">p_BoQ_B</span></code> (Q is any point). In many ways, this
rigid transform class is conceptually similar to using a homogeneous
matrix as a linear operator. See operator* documentation for an
exception.</p>
<p>The class stores a RotationMatrix that relates right-handed orthogonal
unit vectors Ax, Ay, Az fixed in frame A to right-handed orthogonal
unit vectors Bx, By, Bz fixed in frame B. The class also stores a
position vector from Ao (the origin of frame A) to Bo (the origin of
frame B). The position vector is expressed in frame A. The monogram
notation for the transform relating frame A to B is <code class="docutils literal notranslate"><span class="pre">X_AB</span></code>. The
monogram notation for the rotation matrix relating A to B is <code class="docutils literal notranslate"><span class="pre">R_AB</span></code>.
The monogram notation for the position vector from Ao to Bo is
<code class="docutils literal notranslate"><span class="pre">p_AoBo_A</span></code>. See multibody_quantities for monogram notation for
dynamics.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class does not store the frames associated with the transform
and cannot enforce correct usage of this class. For example, it
makes sense to multiply RigidTransforms as <code class="docutils literal notranslate"><span class="pre">X_AB</span> <span class="pre">*</span> <span class="pre">X_BC</span></code>, but
not <code class="docutils literal notranslate"><span class="pre">X_AB</span> <span class="pre">*</span> <span class="pre">X_CB</span></code>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is not a 4x4 transformation matrix – even though its
operator*() methods act mostly like 4x4 matrix multiplication.
Instead, this class contains a 3x3 rotation matrix class and a 3x1
position vector. To convert this to a 3x4 matrix, use
GetAsMatrix34(). To convert this to a 4x4 matrix, use
GetAsMatrix4(). To convert this to an Eigen::Isometry, use
GetAsIsometry().</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>An isometry is sometimes regarded as synonymous with rigid
transform. The RigidTransform class has important advantages over
Eigen::Isometry. - RigidTransform is built on an underlying
rigorous 3x3 RotationMatrix class that has significant
functionality for 3D orientation. - In Debug builds,
RigidTransform requires a valid 3x3 rotation matrix and a valid
(non-NAN) position vector. Eigen::Isometry does not. -
RigidTransform catches bugs that are undetected by
Eigen::Isometry. - RigidTransform has additional functionality and
ease-of-use, resulting in shorter, easier to write, and easier to
read code. - The name Isometry is unfamiliar to many roboticists
and dynamicists and for them Isometry.linear() is (for example) a
counter-intuitive method name to return a rotation matrix.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>One of the constructors in this class provides an implicit
conversion from an Eigen Translation to RigidTransform.</p>
</div>
<dl class="simple">
<dt>Authors:</dt><dd><p>Paul Mitiguy (2018) Original author.</p>
</dd>
<dt>Authors:</dt><dd><p>Drake team (see <a class="reference external" href="https://drake.mit.edu/credits">https://drake.mit.edu/credits</a>).</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-AutoDiffXd-.__init__">
<span id="pydrake.math.RigidTransform_[AutoDiffXd].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.RigidTransform_-AutoDiffXd-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.math.RigidTransform_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Constructs the RigidTransform that corresponds to aligning the two
frames so unit vectors Ax = Bx, Ay = By, Az = Bz and point Ao is
coincident with Bo. Hence, the constructed RigidTransform contains an
identity RotationMatrix and a zero position vector.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.math.RigidTransform_[AutoDiffXd], other: pydrake.math.RigidTransform_[AutoDiffXd]) -&gt; None</p></li>
<li><p>__init__(self: pydrake.math.RigidTransform_[AutoDiffXd], R: pydrake.math.RotationMatrix_[AutoDiffXd], p: numpy.ndarray[object[3, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs a RigidTransform from a rotation matrix and a position
vector.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R</span></code>:</dt><dd><p>rotation matrix relating frames A and B (e.g., <code class="docutils literal notranslate"><span class="pre">R_AB</span></code>).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p</span></code>:</dt><dd><p>position vector from frame A’s origin to frame B’s origin,
expressed in frame A. In monogram notation p is denoted
<code class="docutils literal notranslate"><span class="pre">p_AoBo_A</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.math.RigidTransform_[AutoDiffXd], rpy: pydrake.math.RollPitchYaw_[AutoDiffXd], p: numpy.ndarray[object[3, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs a RigidTransform from a RollPitchYaw and a position vector.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rpy</span></code>:</dt><dd><p>a RollPitchYaw which is a Space-fixed (extrinsic) X-Y-Z rotation
with “roll-pitch-yaw” angles <code class="docutils literal notranslate"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code> or equivalently a Body-
fixed (intrinsic) Z-Y-X rotation with “yaw-pitch-roll” angles
<code class="docutils literal notranslate"><span class="pre">[y,</span> <span class="pre">p,</span> <span class="pre">r]</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RotationMatrix::RotationMatrix(const RollPitchYaw&lt;T&gt;&amp;)</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p</span></code>:</dt><dd><p>position vector from frame A’s origin to frame B’s origin,
expressed in frame A. In monogram notation p is denoted
<code class="docutils literal notranslate"><span class="pre">p_AoBo_A</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="5">
<li><p>__init__(self: pydrake.math.RigidTransform_[AutoDiffXd], quaternion: pydrake.common.eigen_geometry.Quaternion_[AutoDiffXd], p: numpy.ndarray[object[3, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs a RigidTransform from a Quaternion and a position vector.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quaternion</span></code>:</dt><dd><p>a non-zero, finite quaternion which may or may not have unit
length [i.e., <code class="docutils literal notranslate"><span class="pre">quaternion.norm()</span></code> does not have to be 1].</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p</span></code>:</dt><dd><p>position vector from frame A’s origin to frame B’s origin,
expressed in frame A. In monogram notation p is denoted
<code class="docutils literal notranslate"><span class="pre">p_AoBo_A</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError in debug builds if the rotation matrix that is built</strong> – </p></li>
<li><p><strong>from quaternion is invalid.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RotationMatrix::RotationMatrix(const Eigen::Quaternion&lt;T&gt;&amp;)</p>
</div>
<ol class="arabic simple" start="6">
<li><p>__init__(self: pydrake.math.RigidTransform_[AutoDiffXd], theta_lambda: pydrake.common.eigen_geometry.AngleAxis_[AutoDiffXd], p: numpy.ndarray[object[3, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs a RigidTransform from an AngleAxis and a position vector.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta_lambda</span></code>:</dt><dd><p>an Eigen::AngleAxis whose associated axis (vector direction herein
called <code class="docutils literal notranslate"><span class="pre">lambda</span></code>) is non-zero and finite, but which may or may
not have unit length [i.e., <code class="docutils literal notranslate"><span class="pre">lambda.norm()</span></code> does not have to be
1].</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p</span></code>:</dt><dd><p>position vector from frame A’s origin to frame B’s origin,
expressed in frame A. In monogram notation p is denoted <a href="#id5"><span class="problematic" id="id6">``</span></a>p_AoBo_A</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError in debug builds if the rotation matrix that is built</strong> – </p></li>
<li><p><strong>from theta_lambda` is invalid.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RotationMatrix::RotationMatrix(const Eigen::AngleAxis&lt;T&gt;&amp;)</p>
</div>
<ol class="arabic simple" start="7">
<li><p>__init__(self: pydrake.math.RigidTransform_[AutoDiffXd], R: pydrake.math.RotationMatrix_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Constructs a RigidTransform with a given RotationMatrix and a zero
position vector.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R</span></code>:</dt><dd><p>rotation matrix relating frames A and B (e.g., <code class="docutils literal notranslate"><span class="pre">R_AB</span></code>).</p>
</dd>
</dl>
<ol class="arabic simple" start="8">
<li><p>__init__(self: pydrake.math.RigidTransform_[AutoDiffXd], p: numpy.ndarray[object[3, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs a RigidTransform that contains an identity RotationMatrix
and a given position vector <code class="docutils literal notranslate"><span class="pre">p</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p</span></code>:</dt><dd><p>position vector from frame A’s origin to frame B’s origin,
expressed in frame A. In monogram notation p is denoted
<code class="docutils literal notranslate"><span class="pre">p_AoBo_A</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="9">
<li><p>__init__(self: pydrake.math.RigidTransform_[AutoDiffXd], pose: pydrake.common.eigen_geometry.Isometry3_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Constructs a RigidTransform from an Eigen Isometry3.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pose</span></code>:</dt><dd><p>Isometry3 that contains an allegedly valid rotation matrix
<code class="docutils literal notranslate"><span class="pre">R_AB</span></code> and also contains a position vector <code class="docutils literal notranslate"><span class="pre">p_AoBo_A</span></code> from
frame A’s origin to frame B’s origin. <code class="docutils literal notranslate"><span class="pre">p_AoBo_A</span></code> must be
expressed in frame A.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError in debug builds if R_AB is not a proper orthonormal</strong> – </p></li>
<li><p><strong>3x3 rotation matrix.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>No attempt is made to orthogonalize the 3x3 rotation matrix part
of <code class="docutils literal notranslate"><span class="pre">pose</span></code>. As needed, use
RotationMatrix::ProjectToRotationMatrix().</p>
</div>
<ol class="arabic simple" start="10">
<li><p>__init__(self: pydrake.math.RigidTransform_[AutoDiffXd], pose: numpy.ndarray[object[m, n]]) -&gt; None</p></li>
</ol>
<p>Constructs a RigidTransform from an appropriate Eigen <strong>expression</strong>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pose</span></code>:</dt><dd><p>Generic Eigen matrix <strong>expression</strong>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the Eigen expression in pose does not resolve</strong> – </p></li>
<li><p><strong>to a Vector3</strong><strong> or </strong><strong>3x4 matrix</strong><strong> or </strong><strong>4x4 matrix</strong><strong> or </strong><strong>if the rotational part</strong> – </p></li>
<li><p><strong>of pose is not a proper orthonormal 3x3 rotation matrix</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>pose` is a 4x4 matrix whose final row is not</strong><strong> [</strong><strong>0</strong><strong>, </strong><strong>0</strong><strong>, </strong><strong>0</strong><strong>, </strong><strong>1</strong><strong>]</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>No attempt is made to orthogonalize the 3x3 rotation matrix part
of <code class="docutils literal notranslate"><span class="pre">pose</span></code>. As needed, use
RotationMatrix::ProjectToRotationMatrix().</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This constructor prevents ambiguity that would otherwise exist for
a RigidTransform constructor whose argument is an Eigen
<strong>expression</strong>.</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="n">Vector3</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">position</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">X1</span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">position</span><span class="p">);</span><span class="w"></span>
<span class="o">----------------------------------------------</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">R</span><span class="p">(</span><span class="n">RollPitchYaw</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">));</span><span class="w"></span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pose34</span><span class="p">;</span><span class="w"></span>
<span class="n">pose34</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">R</span><span class="p">.</span><span class="n">matrix</span><span class="p">(),</span><span class="w"> </span><span class="n">position</span><span class="p">;</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">X2</span><span class="p">(</span><span class="mf">1.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pose34</span><span class="p">);</span><span class="w"></span>
<span class="o">----------------------------------------------</span><span class="w"></span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pose4</span><span class="p">;</span><span class="w"></span>
<span class="n">pose4</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">R</span><span class="p">.</span><span class="n">matrix</span><span class="p">(),</span><span class="w"> </span><span class="n">position</span><span class="p">,</span><span class="w"></span>
<span class="w">         </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">X3</span><span class="p">(</span><span class="n">pose4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pose4</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</details></dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-AutoDiffXd-.cast">
<span id="pydrake.math.RigidTransform_[AutoDiffXd].cast"></span><em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">cast</span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-AutoDiffXd-.cast" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">cast[AutoDiffXd]</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-AutoDiffXd-.cast-AutoDiffXd">
<span id="pydrake.math.RigidTransform_[AutoDiffXd].cast[AutoDiffXd]"></span><span class="sig-name descname"><span class="pre">cast[AutoDiffXd]</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-AutoDiffXd-.cast-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><p>Creates a RigidTransform templatized on a scalar type U from a
RigidTransform templatized on scalar type T. For example,</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">Identity</span><span class="p">();</span><span class="w"></span>
<span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">source</span><span class="p">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
</details><dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">U</span></code>:</dt><dd><p>Scalar type on which the returned RigidTransform is templated.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">RigidTransform&lt;From&gt;::cast&lt;To&gt;()</span></code> creates a new
<code class="docutils literal notranslate"><span class="pre">RigidTransform&lt;To&gt;</span></code> from a <code class="docutils literal notranslate"><span class="pre">RigidTransform&lt;From&gt;</span></code> but only if
type <code class="docutils literal notranslate"><span class="pre">To</span></code> is constructible from type <code class="docutils literal notranslate"><span class="pre">From</span></code>. This cast method
works in accordance with Eigen’s cast method for Eigen’s objects
that underlie this RigidTransform. For example, Eigen currently
allows cast from type double to AutoDiffXd, but not vice-versa.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-AutoDiffXd-.GetAsIsometry3">
<span id="pydrake.math.RigidTransform_[AutoDiffXd].GetAsIsometry3"></span><span class="sig-name descname"><span class="pre">GetAsIsometry3</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.common.eigen_geometry.html#pydrake.common.eigen_geometry.Isometry3_" title="pydrake.common.eigen_geometry.Isometry3_"><span class="pre">pydrake.common.eigen_geometry.Isometry3_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-AutoDiffXd-.GetAsIsometry3" title="Permalink to this definition"></a></dt>
<dd><p>Returns the isometry in ℜ³ that is equivalent to a RigidTransform.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-AutoDiffXd-.GetAsMatrix34">
<span id="pydrake.math.RigidTransform_[AutoDiffXd].GetAsMatrix34"></span><span class="sig-name descname"><span class="pre">GetAsMatrix34</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">4</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-AutoDiffXd-.GetAsMatrix34" title="Permalink to this definition"></a></dt>
<dd><p>Returns the 3x4 matrix associated with this RigidTransform, i.e.,
X_AB.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>┌                ┐
 │ R_AB  p_AoBo_A │
 └                ┘
</pre></div>
</div>
</details></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-AutoDiffXd-.GetAsMatrix4">
<span id="pydrake.math.RigidTransform_[AutoDiffXd].GetAsMatrix4"></span><span class="sig-name descname"><span class="pre">GetAsMatrix4</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">4</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">4</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-AutoDiffXd-.GetAsMatrix4" title="Permalink to this definition"></a></dt>
<dd><p>Returns the 4x4 matrix associated with this RigidTransform, i.e.,
X_AB.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>┌                ┐
 │ R_AB  p_AoBo_A │
 │                │
 │   0      1     │
 └                ┘
</pre></div>
</div>
</details></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-AutoDiffXd-.GetMaximumAbsoluteDifference">
<span id="pydrake.math.RigidTransform_[AutoDiffXd].GetMaximumAbsoluteDifference"></span><span class="sig-name descname"><span class="pre">GetMaximumAbsoluteDifference</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-AutoDiffXd-.GetMaximumAbsoluteDifference" title="Permalink to this definition"></a></dt>
<dd><p>Computes the infinity norm of <code class="docutils literal notranslate"><span class="pre">this</span></code> - <cite>other</cite> (i.e., the maximum
absolute value of the difference between the elements of <code class="docutils literal notranslate"><span class="pre">this</span></code> and
<code class="docutils literal notranslate"><span class="pre">other</span></code>).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other</span></code>:</dt><dd><p>RigidTransform to subtract from <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>‖<cite>this</cite> - <cite>other</cite>‖∞</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-AutoDiffXd-.GetMaximumAbsoluteTranslationDifference">
<span id="pydrake.math.RigidTransform_[AutoDiffXd].GetMaximumAbsoluteTranslationDifference"></span><span class="sig-name descname"><span class="pre">GetMaximumAbsoluteTranslationDifference</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-AutoDiffXd-.GetMaximumAbsoluteTranslationDifference" title="Permalink to this definition"></a></dt>
<dd><p>Returns the maximum absolute value of the difference in the position
vectors (translation) in <code class="docutils literal notranslate"><span class="pre">this</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>. In other words,
returns the infinity norm of the difference in the position vectors.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other</span></code>:</dt><dd><p>RigidTransform whose position vector is subtracted from the
position vector in <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-AutoDiffXd-.Identity">
<span id="pydrake.math.RigidTransform_[AutoDiffXd].Identity"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Identity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-AutoDiffXd-.Identity" title="Permalink to this definition"></a></dt>
<dd><p>Returns the identity RigidTransform (corresponds to coincident
frames).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the RigidTransform that corresponds to aligning the two frames so
unit vectors Ax = Bx, Ay = By, Az = Bz and point Ao is coincident
with Bo. Hence, the returned RigidTransform contains a 3x3
identity matrix and a zero position vector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-AutoDiffXd-.inverse">
<span id="pydrake.math.RigidTransform_[AutoDiffXd].inverse"></span><span class="sig-name descname"><span class="pre">inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-AutoDiffXd-.inverse" title="Permalink to this definition"></a></dt>
<dd><p>Returns X_BA = X_AB⁻¹, the inverse of <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The inverse of RigidTransform X_AB is X_BA, which contains the
rotation matrix R_BA = R_AB⁻¹ = R_ABᵀ and the position vector
<code class="docutils literal notranslate"><span class="pre">p_BoAo_B_</span></code> (position from B’s origin Bo to A’s origin Ao,
expressed in frame B).</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>: The square-root of a RigidTransform’s condition number is
roughly the magnitude of the position vector. The accuracy of the
calculation for the inverse of a RigidTransform drops off with the
sqrt condition number.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-AutoDiffXd-.InvertAndCompose">
<span id="pydrake.math.RigidTransform_[AutoDiffXd].InvertAndCompose"></span><span class="sig-name descname"><span class="pre">InvertAndCompose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-AutoDiffXd-.InvertAndCompose" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the product of <code class="docutils literal notranslate"><span class="pre">this</span></code> inverted and another
RigidTransform. If you consider <code class="docutils literal notranslate"><span class="pre">this</span></code> to be the transform X_AB, and
<code class="docutils literal notranslate"><span class="pre">other</span></code> to be X_AC, then this method returns X_BC = X_AB⁻¹ * X_AC.
For T==double, this method can be <em>much</em> faster than inverting first
and then performing the composition, because it can take advantage of
the special structure of a rigid transform to avoid unnecessary memory
and floating point operations. On some platforms it can use SIMD
instructions for further speedups.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other</span></code>:</dt><dd><p>RigidTransform that post-multiplies <code class="docutils literal notranslate"><span class="pre">this</span></code> inverted.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">X_BC</span></code>:</dt><dd><p>where X_BC = this⁻¹ * other.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is possible (albeit improbable) to create an invalid rigid
transform by accumulating round-off error with a large number of
multiplies.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-AutoDiffXd-.IsExactlyEqualTo">
<span id="pydrake.math.RigidTransform_[AutoDiffXd].IsExactlyEqualTo"></span><span class="sig-name descname"><span class="pre">IsExactlyEqualTo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-AutoDiffXd-.IsExactlyEqualTo" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if <code class="docutils literal notranslate"><span class="pre">this</span></code> is exactly equal to <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other</span></code>:</dt><dd><p>RigidTransform to compare to <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if each element of <code class="docutils literal notranslate"><span class="pre">this</span></code> is exactly equal to the
corresponding element of <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-AutoDiffXd-.IsExactlyIdentity">
<span id="pydrake.math.RigidTransform_[AutoDiffXd].IsExactlyIdentity"></span><span class="sig-name descname"><span class="pre">IsExactlyIdentity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-AutoDiffXd-.IsExactlyIdentity" title="Permalink to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">this</span></code> is exactly the identity RigidTransform.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>IsNearlyIdentity().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-AutoDiffXd-.IsNearlyEqualTo">
<span id="pydrake.math.RigidTransform_[AutoDiffXd].IsNearlyEqualTo"></span><span class="sig-name descname"><span class="pre">IsNearlyEqualTo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-AutoDiffXd-.IsNearlyEqualTo" title="Permalink to this definition"></a></dt>
<dd><p>Compares each element of <code class="docutils literal notranslate"><span class="pre">this</span></code> to the corresponding element of
<code class="docutils literal notranslate"><span class="pre">other</span></code> to check if they are the same to within a specified
<code class="docutils literal notranslate"><span class="pre">tolerance</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other</span></code>:</dt><dd><p>RigidTransform to compare to <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">tolerance</span></code>:</dt><dd><p>maximum allowable absolute difference between the elements in
<code class="docutils literal notranslate"><span class="pre">this</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">‖this.matrix()</span> <span class="pre">-</span> <span class="pre">other.matrix()‖∞</span> <span class="pre">&lt;=</span> <span class="pre">tolerance</span></code>.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Consider scaling tolerance with the largest of magA and magB,
where magA and magB denoted the magnitudes of <code class="docutils literal notranslate"><span class="pre">this</span></code> position
vector and <code class="docutils literal notranslate"><span class="pre">other</span></code> position vectors, respectively.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-AutoDiffXd-.IsNearlyIdentity">
<span id="pydrake.math.RigidTransform_[AutoDiffXd].IsNearlyIdentity"></span><span class="sig-name descname"><span class="pre">IsNearlyIdentity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">translation_tolerance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-AutoDiffXd-.IsNearlyIdentity" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if <code class="docutils literal notranslate"><span class="pre">this</span></code> is within tolerance of the identity
RigidTransform.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">translation_tolerance</span></code>:</dt><dd><p>a non-negative number. One way to choose <code class="docutils literal notranslate"><span class="pre">translation_tolerance</span></code>
is to multiply a characteristic length (e.g., the magnitude of a
characteristic position vector) by an epsilon (e.g.,
RotationMatrix::get_internal_tolerance_for_orthonormality()).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if the RotationMatrix portion of <code class="docutils literal notranslate"><span class="pre">this</span></code> satisfies
RotationMatrix::IsNearlyIdentity() and if the position vector
portion of <code class="docutils literal notranslate"><span class="pre">this</span></code> is equal to zero vector within
<code class="docutils literal notranslate"><span class="pre">translation_tolerance</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>IsExactlyIdentity().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-AutoDiffXd-.MakeUnchecked">
<span id="pydrake.math.RigidTransform_[AutoDiffXd].MakeUnchecked"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeUnchecked</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pose</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">4</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-AutoDiffXd-.MakeUnchecked" title="Permalink to this definition"></a></dt>
<dd><p>(Advanced) Constructs a RigidTransform from a 3x4 matrix, without any
validity checks nor orthogonalization.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pose</span></code>:</dt><dd><p>3x4 matrix that contains a 3x3 rotation matrix <code class="docutils literal notranslate"><span class="pre">R_AB</span></code> and also a
3x1 position vector <code class="docutils literal notranslate"><span class="pre">p_AoBo_A</span></code> (the position vector from frame
A’s origin to frame B’s origin, expressed in frame A).</p>
</dd>
</dl>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>┌                ┐
 │ R_AB  p_AoBo_A │
 └                ┘
</pre></div>
</div>
</details></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-AutoDiffXd-.multiply">
<span id="pydrake.math.RigidTransform_[AutoDiffXd].multiply"></span><span class="sig-name descname"><span class="pre">multiply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.RigidTransform_-AutoDiffXd-.multiply" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>multiply(self: pydrake.math.RigidTransform_[AutoDiffXd], other: pydrake.math.RigidTransform_[AutoDiffXd]) -&gt; pydrake.math.RigidTransform_[AutoDiffXd]</p></li>
</ol>
<p>Multiplies <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform <code class="docutils literal notranslate"><span class="pre">X_AB</span></code> by the <code class="docutils literal notranslate"><span class="pre">other</span></code>
RigidTransform <code class="docutils literal notranslate"><span class="pre">X_BC</span></code> and returns the RigidTransform <code class="docutils literal notranslate"><span class="pre">X_AC</span> <span class="pre">=</span> <span class="pre">X_AB</span> <span class="pre">*</span>
<span class="pre">X_BC</span></code>.</p>
<ol class="arabic simple" start="2">
<li><p>multiply(self: pydrake.math.RigidTransform_[AutoDiffXd], p_BoQ_B: numpy.ndarray[object[3, 1]]) -&gt; numpy.ndarray[object[3, 1]]</p></li>
</ol>
<p>Multiplies <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform <code class="docutils literal notranslate"><span class="pre">X_AB</span></code> by the position vector
<code class="docutils literal notranslate"><span class="pre">p_BoQ_B</span></code> which is from Bo (B’s origin) to an arbitrary point Q.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BoQ_B</span></code>:</dt><dd><p>position vector from Bo to Q, expressed in frame B.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_AoQ_A</span></code>:</dt><dd><p>position vector from Ao to Q, expressed in frame A.</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>multiply(self: pydrake.math.RigidTransform_[AutoDiffXd], vec_B: numpy.ndarray[object[4, 1]]) -&gt; numpy.ndarray[object[4, 1]]</p></li>
</ol>
<p>Multiplies <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform <code class="docutils literal notranslate"><span class="pre">X_AB</span></code> by the 4-element vector
<code class="docutils literal notranslate"><span class="pre">vec_B</span></code>, equivalent to <code class="docutils literal notranslate"><span class="pre">X_AB.GetAsMatrix4()</span> <span class="pre">*</span> <span class="pre">vec_B</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">vec_B</span></code>:</dt><dd><p>4-element vector whose first 3 elements are the position vector
p_BoQ_B from Bo (frame B’s origin) to an arbitrary point Q,
expressed in frame B and whose 4ᵗʰ element is 1 𝐨𝐫 whose first 3
elements are a vector (maybe unrelated to Bo or Q) and whose 4ᵗʰ
element is 0.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">vec_A</span></code>:</dt><dd><p>4-element vector whose first 3 elements are the position vector
p_AoQ_A from Ao (frame A’s origin) to Q, expressed in frame A and
whose 4ᵗʰ element is 1 𝐨𝐫 whose first 3 elements are a vector
(maybe unrelated to Bo and Q) and whose 4ᵗʰ element is 0.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the 4ᵗʰ element of vec_B is not 0</strong><strong> or </strong><strong>1.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>multiply(self: pydrake.math.RigidTransform_[AutoDiffXd], p_BoQ_B: numpy.ndarray[object[3, n]]) -&gt; numpy.ndarray[object[3, n]]</p></li>
</ol>
<p>Multiplies <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform <code class="docutils literal notranslate"><span class="pre">X_AB</span></code> by the n position vectors
<code class="docutils literal notranslate"><span class="pre">p_BoQ1_B</span></code> … <cite>p_BoQn_B</cite>, where <code class="docutils literal notranslate"><span class="pre">p_BoQi_B</span></code> is the iᵗʰ position
vector from Bo (frame B’s origin) to an arbitrary point Qi, expressed
in frame B.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BoQ_B</span></code>:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix with n position vectors <code class="docutils literal notranslate"><span class="pre">p_BoQi_B</span></code> or an
expression that resolves to a <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix of position
vectors.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_AoQ_A</span></code>:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix with n position vectors <code class="docutils literal notranslate"><span class="pre">p_AoQi_A</span></code>, i.e., n
position vectors from Ao (frame A’s origin) to Qi, expressed in
frame A. Specifically, this operator* is defined so that <code class="docutils literal notranslate"><span class="pre">X_AB</span> <span class="pre">*</span>
<span class="pre">p_BoQ_B</span></code> returns <code class="docutils literal notranslate"><span class="pre">p_AoQ_A</span> <span class="pre">=</span> <span class="pre">p_AoBo_A</span> <span class="pre">+</span> <span class="pre">R_AB</span> <span class="pre">*</span> <span class="pre">p_BoQ_B</span></code>, where
<code class="docutils literal notranslate"><span class="pre">p_AoBo_A</span></code> is the position vector from Ao to Bo expressed in A
and <code class="docutils literal notranslate"><span class="pre">R_AB</span></code> is the rotation matrix relating the orientation of
frames A and B.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As needed, use parentheses. This operator* is not associative. To
see this, let <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">p_AoBo_A</span></code>, <cite>q = p_BoQ_B</cite> and note (X_AB * q)
* 7 = (p + R_AB * q) * 7 ≠ X_AB * (q * 7) = p + R_AB * (q * 7).</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="n">RollPitchYaw</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">rpy</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span><span class="w"> </span><span class="mf">0.2</span><span class="p">,</span><span class="w"> </span><span class="mf">0.3</span><span class="p">);</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">X_AB</span><span class="p">(</span><span class="n">rpy</span><span class="p">,</span><span class="w"> </span><span class="n">Vector3d</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">));</span><span class="w"></span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p_BoQ_B</span><span class="p">;</span><span class="w"></span>
<span class="n">p_BoQ_B</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Vector3d</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span><span class="w"></span>
<span class="n">p_BoQ_B</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Vector3d</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">);</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p_AoQ_A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X_AB</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p_BoQ_B</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</details></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-AutoDiffXd-.rotation">
<span id="pydrake.math.RigidTransform_[AutoDiffXd].rotation"></span><span class="sig-name descname"><span class="pre">rotation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-AutoDiffXd-.rotation" title="Permalink to this definition"></a></dt>
<dd><p>Returns R_AB, the rotation matrix portion of <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform.</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">R_AB</span></code>:</dt><dd><p>the rotation matrix portion of <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-AutoDiffXd-.set">
<span id="pydrake.math.RigidTransform_[AutoDiffXd].set"></span><span class="sig-name descname"><span class="pre">set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-AutoDiffXd-.set" title="Permalink to this definition"></a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform from a RotationMatrix and a position
vector.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R</span></code>:</dt><dd><p>rotation matrix relating frames A and B (e.g., <code class="docutils literal notranslate"><span class="pre">R_AB</span></code>).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p</span></code>:</dt><dd><p>position vector from frame A’s origin to frame B’s origin,
expressed in frame A. In monogram notation p is denoted
<code class="docutils literal notranslate"><span class="pre">p_AoBo_A</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-AutoDiffXd-.set_rotation">
<span id="pydrake.math.RigidTransform_[AutoDiffXd].set_rotation"></span><span class="sig-name descname"><span class="pre">set_rotation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.RigidTransform_-AutoDiffXd-.set_rotation" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>set_rotation(self: pydrake.math.RigidTransform_[AutoDiffXd], R: pydrake.math.RotationMatrix_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Sets the RotationMatrix portion of <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R</span></code>:</dt><dd><p>rotation matrix relating frames A and B (e.g., <code class="docutils literal notranslate"><span class="pre">R_AB</span></code>).</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>set_rotation(self: pydrake.math.RigidTransform_[AutoDiffXd], rpy: pydrake.math.RollPitchYaw_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Sets the rotation part of <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform from a RollPitchYaw.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rpy</span></code>:</dt><dd><p>“roll-pitch-yaw” angles.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RotationMatrix::RotationMatrix(const RollPitchYaw&lt;T&gt;&amp;) which
describes the parameter, preconditions, etc.</p>
</div>
<ol class="arabic simple" start="3">
<li><p>set_rotation(self: pydrake.math.RigidTransform_[AutoDiffXd], quaternion: pydrake.common.eigen_geometry.Quaternion_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Sets the rotation part of <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform from a Quaternion.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quaternion</span></code>:</dt><dd><p>a quaternion which may or may not have unit length.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RotationMatrix::RotationMatrix(const Eigen::Quaternion&lt;T&gt;&amp;) which
describes the parameter, preconditions, exception conditions, etc.</p>
</div>
<ol class="arabic simple" start="4">
<li><p>set_rotation(self: pydrake.math.RigidTransform_[AutoDiffXd], theta_lambda: pydrake.common.eigen_geometry.AngleAxis_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Sets the rotation part of <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform from an AngleAxis.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta_lambda</span></code>:</dt><dd><p>an angle <code class="docutils literal notranslate"><span class="pre">theta</span></code> (in radians) and vector <code class="docutils literal notranslate"><span class="pre">lambda</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RotationMatrix::RotationMatrix(const Eigen::AngleAxis&lt;T&gt;&amp;) which
describes the parameter, preconditions, exception conditions, etc.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-AutoDiffXd-.set_translation">
<span id="pydrake.math.RigidTransform_[AutoDiffXd].set_translation"></span><span class="sig-name descname"><span class="pre">set_translation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-AutoDiffXd-.set_translation" title="Permalink to this definition"></a></dt>
<dd><p>Sets the position vector portion of <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p</span></code>:</dt><dd><p>position vector from Ao (frame A’s origin) to Bo (frame B’s
origin) expressed in frame A. In monogram notation p is denoted
p_AoBo_A.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-AutoDiffXd-.SetFromIsometry3">
<span id="pydrake.math.RigidTransform_[AutoDiffXd].SetFromIsometry3"></span><span class="sig-name descname"><span class="pre">SetFromIsometry3</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pose</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.common.eigen_geometry.html#pydrake.common.eigen_geometry.Isometry3_" title="pydrake.common.eigen_geometry.Isometry3_"><span class="pre">pydrake.common.eigen_geometry.Isometry3_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-AutoDiffXd-.SetFromIsometry3" title="Permalink to this definition"></a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform from an Eigen Isometry3.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pose</span></code>:</dt><dd><p>Isometry3 that contains an allegedly valid rotation matrix
<code class="docutils literal notranslate"><span class="pre">R_AB</span></code> and also contains a position vector <code class="docutils literal notranslate"><span class="pre">p_AoBo_A</span></code> from
frame A’s origin to frame B’s origin. <code class="docutils literal notranslate"><span class="pre">p_AoBo_A</span></code> must be
expressed in frame A.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError in debug builds if R_AB is not a proper orthonormal</strong> – </p></li>
<li><p><strong>3x3 rotation matrix.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>No attempt is made to orthogonalize the 3x3 rotation matrix part
of <code class="docutils literal notranslate"><span class="pre">pose</span></code>. As needed, use
RotationMatrix::ProjectToRotationMatrix().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-AutoDiffXd-.SetIdentity">
<span id="pydrake.math.RigidTransform_[AutoDiffXd].SetIdentity"></span><span class="sig-name descname"><span class="pre">SetIdentity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-AutoDiffXd-.SetIdentity" title="Permalink to this definition"></a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform so it corresponds to aligning the two
frames so unit vectors Ax = Bx, Ay = By, Az = Bz and point Ao is
coincident with Bo. Hence, <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform contains a 3x3
identity matrix and a zero position vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-AutoDiffXd-.translation">
<span id="pydrake.math.RigidTransform_[AutoDiffXd].translation"></span><span class="sig-name descname"><span class="pre">translation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-AutoDiffXd-.translation" title="Permalink to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">p_AoBo_A</span></code>, the position vector portion of <code class="docutils literal notranslate"><span class="pre">this</span></code>
RigidTransform, i.e., position vector from Ao (frame A’s origin) to Bo
(frame B’s origin).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-Expression">
<span id="pydrake.math.RigidTransform_[Expression]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">RigidTransform_[Expression]</span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-Expression" title="Permalink to this definition"></a></dt>
<dd><p>This class represents a proper rigid transform between two frames
which can be regarded in two ways. A rigid transform describes the
“pose” between two frames A and B (i.e., the relative orientation and
position of A to B). Alternately, it can be regarded as a
distance-preserving operator that can rotate and/or translate a rigid
body without changing its shape or size (rigid) and without
mirroring/reflecting the body (proper), e.g., it can add one position
vector to another and express the result in a particular basis as
<code class="docutils literal notranslate"><span class="pre">p_AoQ_A</span> <span class="pre">=</span> <span class="pre">X_AB</span> <span class="pre">*</span> <span class="pre">p_BoQ_B</span></code> (Q is any point). In many ways, this
rigid transform class is conceptually similar to using a homogeneous
matrix as a linear operator. See operator* documentation for an
exception.</p>
<p>The class stores a RotationMatrix that relates right-handed orthogonal
unit vectors Ax, Ay, Az fixed in frame A to right-handed orthogonal
unit vectors Bx, By, Bz fixed in frame B. The class also stores a
position vector from Ao (the origin of frame A) to Bo (the origin of
frame B). The position vector is expressed in frame A. The monogram
notation for the transform relating frame A to B is <code class="docutils literal notranslate"><span class="pre">X_AB</span></code>. The
monogram notation for the rotation matrix relating A to B is <code class="docutils literal notranslate"><span class="pre">R_AB</span></code>.
The monogram notation for the position vector from Ao to Bo is
<code class="docutils literal notranslate"><span class="pre">p_AoBo_A</span></code>. See multibody_quantities for monogram notation for
dynamics.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class does not store the frames associated with the transform
and cannot enforce correct usage of this class. For example, it
makes sense to multiply RigidTransforms as <code class="docutils literal notranslate"><span class="pre">X_AB</span> <span class="pre">*</span> <span class="pre">X_BC</span></code>, but
not <code class="docutils literal notranslate"><span class="pre">X_AB</span> <span class="pre">*</span> <span class="pre">X_CB</span></code>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is not a 4x4 transformation matrix – even though its
operator*() methods act mostly like 4x4 matrix multiplication.
Instead, this class contains a 3x3 rotation matrix class and a 3x1
position vector. To convert this to a 3x4 matrix, use
GetAsMatrix34(). To convert this to a 4x4 matrix, use
GetAsMatrix4(). To convert this to an Eigen::Isometry, use
GetAsIsometry().</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>An isometry is sometimes regarded as synonymous with rigid
transform. The RigidTransform class has important advantages over
Eigen::Isometry. - RigidTransform is built on an underlying
rigorous 3x3 RotationMatrix class that has significant
functionality for 3D orientation. - In Debug builds,
RigidTransform requires a valid 3x3 rotation matrix and a valid
(non-NAN) position vector. Eigen::Isometry does not. -
RigidTransform catches bugs that are undetected by
Eigen::Isometry. - RigidTransform has additional functionality and
ease-of-use, resulting in shorter, easier to write, and easier to
read code. - The name Isometry is unfamiliar to many roboticists
and dynamicists and for them Isometry.linear() is (for example) a
counter-intuitive method name to return a rotation matrix.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>One of the constructors in this class provides an implicit
conversion from an Eigen Translation to RigidTransform.</p>
</div>
<dl class="simple">
<dt>Authors:</dt><dd><p>Paul Mitiguy (2018) Original author.</p>
</dd>
<dt>Authors:</dt><dd><p>Drake team (see <a class="reference external" href="https://drake.mit.edu/credits">https://drake.mit.edu/credits</a>).</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-Expression-.__init__">
<span id="pydrake.math.RigidTransform_[Expression].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.RigidTransform_-Expression-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.math.RigidTransform_[Expression]) -&gt; None</p></li>
</ol>
<p>Constructs the RigidTransform that corresponds to aligning the two
frames so unit vectors Ax = Bx, Ay = By, Az = Bz and point Ao is
coincident with Bo. Hence, the constructed RigidTransform contains an
identity RotationMatrix and a zero position vector.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.math.RigidTransform_[Expression], other: pydrake.math.RigidTransform_[Expression]) -&gt; None</p></li>
<li><p>__init__(self: pydrake.math.RigidTransform_[Expression], R: pydrake.math.RotationMatrix_[Expression], p: numpy.ndarray[object[3, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs a RigidTransform from a rotation matrix and a position
vector.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R</span></code>:</dt><dd><p>rotation matrix relating frames A and B (e.g., <code class="docutils literal notranslate"><span class="pre">R_AB</span></code>).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p</span></code>:</dt><dd><p>position vector from frame A’s origin to frame B’s origin,
expressed in frame A. In monogram notation p is denoted
<code class="docutils literal notranslate"><span class="pre">p_AoBo_A</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.math.RigidTransform_[Expression], rpy: pydrake.math.RollPitchYaw_[Expression], p: numpy.ndarray[object[3, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs a RigidTransform from a RollPitchYaw and a position vector.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rpy</span></code>:</dt><dd><p>a RollPitchYaw which is a Space-fixed (extrinsic) X-Y-Z rotation
with “roll-pitch-yaw” angles <code class="docutils literal notranslate"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code> or equivalently a Body-
fixed (intrinsic) Z-Y-X rotation with “yaw-pitch-roll” angles
<code class="docutils literal notranslate"><span class="pre">[y,</span> <span class="pre">p,</span> <span class="pre">r]</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RotationMatrix::RotationMatrix(const RollPitchYaw&lt;T&gt;&amp;)</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p</span></code>:</dt><dd><p>position vector from frame A’s origin to frame B’s origin,
expressed in frame A. In monogram notation p is denoted
<code class="docutils literal notranslate"><span class="pre">p_AoBo_A</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="5">
<li><p>__init__(self: pydrake.math.RigidTransform_[Expression], quaternion: pydrake.common.eigen_geometry.Quaternion_[Expression], p: numpy.ndarray[object[3, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs a RigidTransform from a Quaternion and a position vector.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quaternion</span></code>:</dt><dd><p>a non-zero, finite quaternion which may or may not have unit
length [i.e., <code class="docutils literal notranslate"><span class="pre">quaternion.norm()</span></code> does not have to be 1].</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p</span></code>:</dt><dd><p>position vector from frame A’s origin to frame B’s origin,
expressed in frame A. In monogram notation p is denoted
<code class="docutils literal notranslate"><span class="pre">p_AoBo_A</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError in debug builds if the rotation matrix that is built</strong> – </p></li>
<li><p><strong>from quaternion is invalid.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RotationMatrix::RotationMatrix(const Eigen::Quaternion&lt;T&gt;&amp;)</p>
</div>
<ol class="arabic simple" start="6">
<li><p>__init__(self: pydrake.math.RigidTransform_[Expression], theta_lambda: pydrake.common.eigen_geometry.AngleAxis_[Expression], p: numpy.ndarray[object[3, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs a RigidTransform from an AngleAxis and a position vector.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta_lambda</span></code>:</dt><dd><p>an Eigen::AngleAxis whose associated axis (vector direction herein
called <code class="docutils literal notranslate"><span class="pre">lambda</span></code>) is non-zero and finite, but which may or may
not have unit length [i.e., <code class="docutils literal notranslate"><span class="pre">lambda.norm()</span></code> does not have to be
1].</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p</span></code>:</dt><dd><p>position vector from frame A’s origin to frame B’s origin,
expressed in frame A. In monogram notation p is denoted <a href="#id7"><span class="problematic" id="id8">``</span></a>p_AoBo_A</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError in debug builds if the rotation matrix that is built</strong> – </p></li>
<li><p><strong>from theta_lambda` is invalid.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RotationMatrix::RotationMatrix(const Eigen::AngleAxis&lt;T&gt;&amp;)</p>
</div>
<ol class="arabic simple" start="7">
<li><p>__init__(self: pydrake.math.RigidTransform_[Expression], R: pydrake.math.RotationMatrix_[Expression]) -&gt; None</p></li>
</ol>
<p>Constructs a RigidTransform with a given RotationMatrix and a zero
position vector.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R</span></code>:</dt><dd><p>rotation matrix relating frames A and B (e.g., <code class="docutils literal notranslate"><span class="pre">R_AB</span></code>).</p>
</dd>
</dl>
<ol class="arabic simple" start="8">
<li><p>__init__(self: pydrake.math.RigidTransform_[Expression], p: numpy.ndarray[object[3, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs a RigidTransform that contains an identity RotationMatrix
and a given position vector <code class="docutils literal notranslate"><span class="pre">p</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p</span></code>:</dt><dd><p>position vector from frame A’s origin to frame B’s origin,
expressed in frame A. In monogram notation p is denoted
<code class="docutils literal notranslate"><span class="pre">p_AoBo_A</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="9">
<li><p>__init__(self: pydrake.math.RigidTransform_[Expression], pose: pydrake.common.eigen_geometry.Isometry3_[Expression]) -&gt; None</p></li>
</ol>
<p>Constructs a RigidTransform from an Eigen Isometry3.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pose</span></code>:</dt><dd><p>Isometry3 that contains an allegedly valid rotation matrix
<code class="docutils literal notranslate"><span class="pre">R_AB</span></code> and also contains a position vector <code class="docutils literal notranslate"><span class="pre">p_AoBo_A</span></code> from
frame A’s origin to frame B’s origin. <code class="docutils literal notranslate"><span class="pre">p_AoBo_A</span></code> must be
expressed in frame A.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError in debug builds if R_AB is not a proper orthonormal</strong> – </p></li>
<li><p><strong>3x3 rotation matrix.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>No attempt is made to orthogonalize the 3x3 rotation matrix part
of <code class="docutils literal notranslate"><span class="pre">pose</span></code>. As needed, use
RotationMatrix::ProjectToRotationMatrix().</p>
</div>
<ol class="arabic simple" start="10">
<li><p>__init__(self: pydrake.math.RigidTransform_[Expression], pose: numpy.ndarray[object[m, n]]) -&gt; None</p></li>
</ol>
<p>Constructs a RigidTransform from an appropriate Eigen <strong>expression</strong>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pose</span></code>:</dt><dd><p>Generic Eigen matrix <strong>expression</strong>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the Eigen expression in pose does not resolve</strong> – </p></li>
<li><p><strong>to a Vector3</strong><strong> or </strong><strong>3x4 matrix</strong><strong> or </strong><strong>4x4 matrix</strong><strong> or </strong><strong>if the rotational part</strong> – </p></li>
<li><p><strong>of pose is not a proper orthonormal 3x3 rotation matrix</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>pose` is a 4x4 matrix whose final row is not</strong><strong> [</strong><strong>0</strong><strong>, </strong><strong>0</strong><strong>, </strong><strong>0</strong><strong>, </strong><strong>1</strong><strong>]</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>No attempt is made to orthogonalize the 3x3 rotation matrix part
of <code class="docutils literal notranslate"><span class="pre">pose</span></code>. As needed, use
RotationMatrix::ProjectToRotationMatrix().</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This constructor prevents ambiguity that would otherwise exist for
a RigidTransform constructor whose argument is an Eigen
<strong>expression</strong>.</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="n">Vector3</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">position</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">X1</span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">position</span><span class="p">);</span><span class="w"></span>
<span class="o">----------------------------------------------</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">R</span><span class="p">(</span><span class="n">RollPitchYaw</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">));</span><span class="w"></span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pose34</span><span class="p">;</span><span class="w"></span>
<span class="n">pose34</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">R</span><span class="p">.</span><span class="n">matrix</span><span class="p">(),</span><span class="w"> </span><span class="n">position</span><span class="p">;</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">X2</span><span class="p">(</span><span class="mf">1.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pose34</span><span class="p">);</span><span class="w"></span>
<span class="o">----------------------------------------------</span><span class="w"></span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pose4</span><span class="p">;</span><span class="w"></span>
<span class="n">pose4</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">R</span><span class="p">.</span><span class="n">matrix</span><span class="p">(),</span><span class="w"> </span><span class="n">position</span><span class="p">,</span><span class="w"></span>
<span class="w">         </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">X3</span><span class="p">(</span><span class="n">pose4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">pose4</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</details></dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-Expression-.cast">
<span id="pydrake.math.RigidTransform_[Expression].cast"></span><em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">cast</span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-Expression-.cast" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">cast[Expression]</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-Expression-.cast-Expression">
<span id="pydrake.math.RigidTransform_[Expression].cast[Expression]"></span><span class="sig-name descname"><span class="pre">cast[Expression]</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-Expression-.cast-Expression" title="Permalink to this definition"></a></dt>
<dd><p>Creates a RigidTransform templatized on a scalar type U from a
RigidTransform templatized on scalar type T. For example,</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">Identity</span><span class="p">();</span><span class="w"></span>
<span class="n">RigidTransform</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">source</span><span class="p">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
</details><dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">U</span></code>:</dt><dd><p>Scalar type on which the returned RigidTransform is templated.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">RigidTransform&lt;From&gt;::cast&lt;To&gt;()</span></code> creates a new
<code class="docutils literal notranslate"><span class="pre">RigidTransform&lt;To&gt;</span></code> from a <code class="docutils literal notranslate"><span class="pre">RigidTransform&lt;From&gt;</span></code> but only if
type <code class="docutils literal notranslate"><span class="pre">To</span></code> is constructible from type <code class="docutils literal notranslate"><span class="pre">From</span></code>. This cast method
works in accordance with Eigen’s cast method for Eigen’s objects
that underlie this RigidTransform. For example, Eigen currently
allows cast from type double to AutoDiffXd, but not vice-versa.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-Expression-.GetAsIsometry3">
<span id="pydrake.math.RigidTransform_[Expression].GetAsIsometry3"></span><span class="sig-name descname"><span class="pre">GetAsIsometry3</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.common.eigen_geometry.html#pydrake.common.eigen_geometry.Isometry3_" title="pydrake.common.eigen_geometry.Isometry3_"><span class="pre">pydrake.common.eigen_geometry.Isometry3_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-Expression-.GetAsIsometry3" title="Permalink to this definition"></a></dt>
<dd><p>Returns the isometry in ℜ³ that is equivalent to a RigidTransform.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-Expression-.GetAsMatrix34">
<span id="pydrake.math.RigidTransform_[Expression].GetAsMatrix34"></span><span class="sig-name descname"><span class="pre">GetAsMatrix34</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">4</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-Expression-.GetAsMatrix34" title="Permalink to this definition"></a></dt>
<dd><p>Returns the 3x4 matrix associated with this RigidTransform, i.e.,
X_AB.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>┌                ┐
 │ R_AB  p_AoBo_A │
 └                ┘
</pre></div>
</div>
</details></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-Expression-.GetAsMatrix4">
<span id="pydrake.math.RigidTransform_[Expression].GetAsMatrix4"></span><span class="sig-name descname"><span class="pre">GetAsMatrix4</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">4</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">4</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-Expression-.GetAsMatrix4" title="Permalink to this definition"></a></dt>
<dd><p>Returns the 4x4 matrix associated with this RigidTransform, i.e.,
X_AB.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>┌                ┐
 │ R_AB  p_AoBo_A │
 │                │
 │   0      1     │
 └                ┘
</pre></div>
</div>
</details></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-Expression-.GetMaximumAbsoluteDifference">
<span id="pydrake.math.RigidTransform_[Expression].GetMaximumAbsoluteDifference"></span><span class="sig-name descname"><span class="pre">GetMaximumAbsoluteDifference</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-Expression-.GetMaximumAbsoluteDifference" title="Permalink to this definition"></a></dt>
<dd><p>Computes the infinity norm of <code class="docutils literal notranslate"><span class="pre">this</span></code> - <cite>other</cite> (i.e., the maximum
absolute value of the difference between the elements of <code class="docutils literal notranslate"><span class="pre">this</span></code> and
<code class="docutils literal notranslate"><span class="pre">other</span></code>).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other</span></code>:</dt><dd><p>RigidTransform to subtract from <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>‖<cite>this</cite> - <cite>other</cite>‖∞</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-Expression-.GetMaximumAbsoluteTranslationDifference">
<span id="pydrake.math.RigidTransform_[Expression].GetMaximumAbsoluteTranslationDifference"></span><span class="sig-name descname"><span class="pre">GetMaximumAbsoluteTranslationDifference</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-Expression-.GetMaximumAbsoluteTranslationDifference" title="Permalink to this definition"></a></dt>
<dd><p>Returns the maximum absolute value of the difference in the position
vectors (translation) in <code class="docutils literal notranslate"><span class="pre">this</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>. In other words,
returns the infinity norm of the difference in the position vectors.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other</span></code>:</dt><dd><p>RigidTransform whose position vector is subtracted from the
position vector in <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-Expression-.Identity">
<span id="pydrake.math.RigidTransform_[Expression].Identity"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Identity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-Expression-.Identity" title="Permalink to this definition"></a></dt>
<dd><p>Returns the identity RigidTransform (corresponds to coincident
frames).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the RigidTransform that corresponds to aligning the two frames so
unit vectors Ax = Bx, Ay = By, Az = Bz and point Ao is coincident
with Bo. Hence, the returned RigidTransform contains a 3x3
identity matrix and a zero position vector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-Expression-.inverse">
<span id="pydrake.math.RigidTransform_[Expression].inverse"></span><span class="sig-name descname"><span class="pre">inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-Expression-.inverse" title="Permalink to this definition"></a></dt>
<dd><p>Returns X_BA = X_AB⁻¹, the inverse of <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The inverse of RigidTransform X_AB is X_BA, which contains the
rotation matrix R_BA = R_AB⁻¹ = R_ABᵀ and the position vector
<code class="docutils literal notranslate"><span class="pre">p_BoAo_B_</span></code> (position from B’s origin Bo to A’s origin Ao,
expressed in frame B).</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>: The square-root of a RigidTransform’s condition number is
roughly the magnitude of the position vector. The accuracy of the
calculation for the inverse of a RigidTransform drops off with the
sqrt condition number.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-Expression-.InvertAndCompose">
<span id="pydrake.math.RigidTransform_[Expression].InvertAndCompose"></span><span class="sig-name descname"><span class="pre">InvertAndCompose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-Expression-.InvertAndCompose" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the product of <code class="docutils literal notranslate"><span class="pre">this</span></code> inverted and another
RigidTransform. If you consider <code class="docutils literal notranslate"><span class="pre">this</span></code> to be the transform X_AB, and
<code class="docutils literal notranslate"><span class="pre">other</span></code> to be X_AC, then this method returns X_BC = X_AB⁻¹ * X_AC.
For T==double, this method can be <em>much</em> faster than inverting first
and then performing the composition, because it can take advantage of
the special structure of a rigid transform to avoid unnecessary memory
and floating point operations. On some platforms it can use SIMD
instructions for further speedups.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other</span></code>:</dt><dd><p>RigidTransform that post-multiplies <code class="docutils literal notranslate"><span class="pre">this</span></code> inverted.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">X_BC</span></code>:</dt><dd><p>where X_BC = this⁻¹ * other.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is possible (albeit improbable) to create an invalid rigid
transform by accumulating round-off error with a large number of
multiplies.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-Expression-.IsExactlyEqualTo">
<span id="pydrake.math.RigidTransform_[Expression].IsExactlyEqualTo"></span><span class="sig-name descname"><span class="pre">IsExactlyEqualTo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Formula" title="pydrake.symbolic.Formula"><span class="pre">pydrake.symbolic.Formula</span></a></span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-Expression-.IsExactlyEqualTo" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if <code class="docutils literal notranslate"><span class="pre">this</span></code> is exactly equal to <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other</span></code>:</dt><dd><p>RigidTransform to compare to <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if each element of <code class="docutils literal notranslate"><span class="pre">this</span></code> is exactly equal to the
corresponding element of <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-Expression-.IsExactlyIdentity">
<span id="pydrake.math.RigidTransform_[Expression].IsExactlyIdentity"></span><span class="sig-name descname"><span class="pre">IsExactlyIdentity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Formula" title="pydrake.symbolic.Formula"><span class="pre">pydrake.symbolic.Formula</span></a></span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-Expression-.IsExactlyIdentity" title="Permalink to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">this</span></code> is exactly the identity RigidTransform.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>IsNearlyIdentity().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-Expression-.IsNearlyEqualTo">
<span id="pydrake.math.RigidTransform_[Expression].IsNearlyEqualTo"></span><span class="sig-name descname"><span class="pre">IsNearlyEqualTo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Formula" title="pydrake.symbolic.Formula"><span class="pre">pydrake.symbolic.Formula</span></a></span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-Expression-.IsNearlyEqualTo" title="Permalink to this definition"></a></dt>
<dd><p>Compares each element of <code class="docutils literal notranslate"><span class="pre">this</span></code> to the corresponding element of
<code class="docutils literal notranslate"><span class="pre">other</span></code> to check if they are the same to within a specified
<code class="docutils literal notranslate"><span class="pre">tolerance</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other</span></code>:</dt><dd><p>RigidTransform to compare to <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">tolerance</span></code>:</dt><dd><p>maximum allowable absolute difference between the elements in
<code class="docutils literal notranslate"><span class="pre">this</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">‖this.matrix()</span> <span class="pre">-</span> <span class="pre">other.matrix()‖∞</span> <span class="pre">&lt;=</span> <span class="pre">tolerance</span></code>.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Consider scaling tolerance with the largest of magA and magB,
where magA and magB denoted the magnitudes of <code class="docutils literal notranslate"><span class="pre">this</span></code> position
vector and <code class="docutils literal notranslate"><span class="pre">other</span></code> position vectors, respectively.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-Expression-.IsNearlyIdentity">
<span id="pydrake.math.RigidTransform_[Expression].IsNearlyIdentity"></span><span class="sig-name descname"><span class="pre">IsNearlyIdentity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">translation_tolerance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Formula" title="pydrake.symbolic.Formula"><span class="pre">pydrake.symbolic.Formula</span></a></span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-Expression-.IsNearlyIdentity" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if <code class="docutils literal notranslate"><span class="pre">this</span></code> is within tolerance of the identity
RigidTransform.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">translation_tolerance</span></code>:</dt><dd><p>a non-negative number. One way to choose <code class="docutils literal notranslate"><span class="pre">translation_tolerance</span></code>
is to multiply a characteristic length (e.g., the magnitude of a
characteristic position vector) by an epsilon (e.g.,
RotationMatrix::get_internal_tolerance_for_orthonormality()).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if the RotationMatrix portion of <code class="docutils literal notranslate"><span class="pre">this</span></code> satisfies
RotationMatrix::IsNearlyIdentity() and if the position vector
portion of <code class="docutils literal notranslate"><span class="pre">this</span></code> is equal to zero vector within
<code class="docutils literal notranslate"><span class="pre">translation_tolerance</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>IsExactlyIdentity().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-Expression-.MakeUnchecked">
<span id="pydrake.math.RigidTransform_[Expression].MakeUnchecked"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeUnchecked</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pose</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">4</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-Expression-.MakeUnchecked" title="Permalink to this definition"></a></dt>
<dd><p>(Advanced) Constructs a RigidTransform from a 3x4 matrix, without any
validity checks nor orthogonalization.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pose</span></code>:</dt><dd><p>3x4 matrix that contains a 3x3 rotation matrix <code class="docutils literal notranslate"><span class="pre">R_AB</span></code> and also a
3x1 position vector <code class="docutils literal notranslate"><span class="pre">p_AoBo_A</span></code> (the position vector from frame
A’s origin to frame B’s origin, expressed in frame A).</p>
</dd>
</dl>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>┌                ┐
 │ R_AB  p_AoBo_A │
 └                ┘
</pre></div>
</div>
</details></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-Expression-.multiply">
<span id="pydrake.math.RigidTransform_[Expression].multiply"></span><span class="sig-name descname"><span class="pre">multiply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.RigidTransform_-Expression-.multiply" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>multiply(self: pydrake.math.RigidTransform_[Expression], other: pydrake.math.RigidTransform_[Expression]) -&gt; pydrake.math.RigidTransform_[Expression]</p></li>
</ol>
<p>Multiplies <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform <code class="docutils literal notranslate"><span class="pre">X_AB</span></code> by the <code class="docutils literal notranslate"><span class="pre">other</span></code>
RigidTransform <code class="docutils literal notranslate"><span class="pre">X_BC</span></code> and returns the RigidTransform <code class="docutils literal notranslate"><span class="pre">X_AC</span> <span class="pre">=</span> <span class="pre">X_AB</span> <span class="pre">*</span>
<span class="pre">X_BC</span></code>.</p>
<ol class="arabic simple" start="2">
<li><p>multiply(self: pydrake.math.RigidTransform_[Expression], p_BoQ_B: numpy.ndarray[object[3, 1]]) -&gt; numpy.ndarray[object[3, 1]]</p></li>
</ol>
<p>Multiplies <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform <code class="docutils literal notranslate"><span class="pre">X_AB</span></code> by the position vector
<code class="docutils literal notranslate"><span class="pre">p_BoQ_B</span></code> which is from Bo (B’s origin) to an arbitrary point Q.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BoQ_B</span></code>:</dt><dd><p>position vector from Bo to Q, expressed in frame B.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_AoQ_A</span></code>:</dt><dd><p>position vector from Ao to Q, expressed in frame A.</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>multiply(self: pydrake.math.RigidTransform_[Expression], vec_B: numpy.ndarray[object[4, 1]]) -&gt; numpy.ndarray[object[4, 1]]</p></li>
</ol>
<p>Multiplies <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform <code class="docutils literal notranslate"><span class="pre">X_AB</span></code> by the 4-element vector
<code class="docutils literal notranslate"><span class="pre">vec_B</span></code>, equivalent to <code class="docutils literal notranslate"><span class="pre">X_AB.GetAsMatrix4()</span> <span class="pre">*</span> <span class="pre">vec_B</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">vec_B</span></code>:</dt><dd><p>4-element vector whose first 3 elements are the position vector
p_BoQ_B from Bo (frame B’s origin) to an arbitrary point Q,
expressed in frame B and whose 4ᵗʰ element is 1 𝐨𝐫 whose first 3
elements are a vector (maybe unrelated to Bo or Q) and whose 4ᵗʰ
element is 0.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">vec_A</span></code>:</dt><dd><p>4-element vector whose first 3 elements are the position vector
p_AoQ_A from Ao (frame A’s origin) to Q, expressed in frame A and
whose 4ᵗʰ element is 1 𝐨𝐫 whose first 3 elements are a vector
(maybe unrelated to Bo and Q) and whose 4ᵗʰ element is 0.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the 4ᵗʰ element of vec_B is not 0</strong><strong> or </strong><strong>1.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>multiply(self: pydrake.math.RigidTransform_[Expression], p_BoQ_B: numpy.ndarray[object[3, n]]) -&gt; numpy.ndarray[object[3, n]]</p></li>
</ol>
<p>Multiplies <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform <code class="docutils literal notranslate"><span class="pre">X_AB</span></code> by the n position vectors
<code class="docutils literal notranslate"><span class="pre">p_BoQ1_B</span></code> … <cite>p_BoQn_B</cite>, where <code class="docutils literal notranslate"><span class="pre">p_BoQi_B</span></code> is the iᵗʰ position
vector from Bo (frame B’s origin) to an arbitrary point Qi, expressed
in frame B.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BoQ_B</span></code>:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix with n position vectors <code class="docutils literal notranslate"><span class="pre">p_BoQi_B</span></code> or an
expression that resolves to a <code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix of position
vectors.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_AoQ_A</span></code>:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix with n position vectors <code class="docutils literal notranslate"><span class="pre">p_AoQi_A</span></code>, i.e., n
position vectors from Ao (frame A’s origin) to Qi, expressed in
frame A. Specifically, this operator* is defined so that <code class="docutils literal notranslate"><span class="pre">X_AB</span> <span class="pre">*</span>
<span class="pre">p_BoQ_B</span></code> returns <code class="docutils literal notranslate"><span class="pre">p_AoQ_A</span> <span class="pre">=</span> <span class="pre">p_AoBo_A</span> <span class="pre">+</span> <span class="pre">R_AB</span> <span class="pre">*</span> <span class="pre">p_BoQ_B</span></code>, where
<code class="docutils literal notranslate"><span class="pre">p_AoBo_A</span></code> is the position vector from Ao to Bo expressed in A
and <code class="docutils literal notranslate"><span class="pre">R_AB</span></code> is the rotation matrix relating the orientation of
frames A and B.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As needed, use parentheses. This operator* is not associative. To
see this, let <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">=</span> <span class="pre">p_AoBo_A</span></code>, <cite>q = p_BoQ_B</cite> and note (X_AB * q)
* 7 = (p + R_AB * q) * 7 ≠ X_AB * (q * 7) = p + R_AB * (q * 7).</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="n">RollPitchYaw</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">rpy</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span><span class="w"> </span><span class="mf">0.2</span><span class="p">,</span><span class="w"> </span><span class="mf">0.3</span><span class="p">);</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">RigidTransform</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">X_AB</span><span class="p">(</span><span class="n">rpy</span><span class="p">,</span><span class="w"> </span><span class="n">Vector3d</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">));</span><span class="w"></span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p_BoQ_B</span><span class="p">;</span><span class="w"></span>
<span class="n">p_BoQ_B</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Vector3d</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span><span class="w"></span>
<span class="n">p_BoQ_B</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Vector3d</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">);</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p_AoQ_A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X_AB</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p_BoQ_B</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</details></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-Expression-.rotation">
<span id="pydrake.math.RigidTransform_[Expression].rotation"></span><span class="sig-name descname"><span class="pre">rotation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-Expression-.rotation" title="Permalink to this definition"></a></dt>
<dd><p>Returns R_AB, the rotation matrix portion of <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform.</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">R_AB</span></code>:</dt><dd><p>the rotation matrix portion of <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-Expression-.set">
<span id="pydrake.math.RigidTransform_[Expression].set"></span><span class="sig-name descname"><span class="pre">set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-Expression-.set" title="Permalink to this definition"></a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform from a RotationMatrix and a position
vector.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R</span></code>:</dt><dd><p>rotation matrix relating frames A and B (e.g., <code class="docutils literal notranslate"><span class="pre">R_AB</span></code>).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p</span></code>:</dt><dd><p>position vector from frame A’s origin to frame B’s origin,
expressed in frame A. In monogram notation p is denoted
<code class="docutils literal notranslate"><span class="pre">p_AoBo_A</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-Expression-.set_rotation">
<span id="pydrake.math.RigidTransform_[Expression].set_rotation"></span><span class="sig-name descname"><span class="pre">set_rotation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.RigidTransform_-Expression-.set_rotation" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>set_rotation(self: pydrake.math.RigidTransform_[Expression], R: pydrake.math.RotationMatrix_[Expression]) -&gt; None</p></li>
</ol>
<p>Sets the RotationMatrix portion of <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R</span></code>:</dt><dd><p>rotation matrix relating frames A and B (e.g., <code class="docutils literal notranslate"><span class="pre">R_AB</span></code>).</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>set_rotation(self: pydrake.math.RigidTransform_[Expression], rpy: pydrake.math.RollPitchYaw_[Expression]) -&gt; None</p></li>
</ol>
<p>Sets the rotation part of <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform from a RollPitchYaw.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rpy</span></code>:</dt><dd><p>“roll-pitch-yaw” angles.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RotationMatrix::RotationMatrix(const RollPitchYaw&lt;T&gt;&amp;) which
describes the parameter, preconditions, etc.</p>
</div>
<ol class="arabic simple" start="3">
<li><p>set_rotation(self: pydrake.math.RigidTransform_[Expression], quaternion: pydrake.common.eigen_geometry.Quaternion_[Expression]) -&gt; None</p></li>
</ol>
<p>Sets the rotation part of <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform from a Quaternion.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quaternion</span></code>:</dt><dd><p>a quaternion which may or may not have unit length.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RotationMatrix::RotationMatrix(const Eigen::Quaternion&lt;T&gt;&amp;) which
describes the parameter, preconditions, exception conditions, etc.</p>
</div>
<ol class="arabic simple" start="4">
<li><p>set_rotation(self: pydrake.math.RigidTransform_[Expression], theta_lambda: pydrake.common.eigen_geometry.AngleAxis_[Expression]) -&gt; None</p></li>
</ol>
<p>Sets the rotation part of <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform from an AngleAxis.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta_lambda</span></code>:</dt><dd><p>an angle <code class="docutils literal notranslate"><span class="pre">theta</span></code> (in radians) and vector <code class="docutils literal notranslate"><span class="pre">lambda</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RotationMatrix::RotationMatrix(const Eigen::AngleAxis&lt;T&gt;&amp;) which
describes the parameter, preconditions, exception conditions, etc.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-Expression-.set_translation">
<span id="pydrake.math.RigidTransform_[Expression].set_translation"></span><span class="sig-name descname"><span class="pre">set_translation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-Expression-.set_translation" title="Permalink to this definition"></a></dt>
<dd><p>Sets the position vector portion of <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p</span></code>:</dt><dd><p>position vector from Ao (frame A’s origin) to Bo (frame B’s
origin) expressed in frame A. In monogram notation p is denoted
p_AoBo_A.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-Expression-.SetFromIsometry3">
<span id="pydrake.math.RigidTransform_[Expression].SetFromIsometry3"></span><span class="sig-name descname"><span class="pre">SetFromIsometry3</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pose</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.common.eigen_geometry.html#pydrake.common.eigen_geometry.Isometry3_" title="pydrake.common.eigen_geometry.Isometry3_"><span class="pre">pydrake.common.eigen_geometry.Isometry3_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-Expression-.SetFromIsometry3" title="Permalink to this definition"></a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform from an Eigen Isometry3.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pose</span></code>:</dt><dd><p>Isometry3 that contains an allegedly valid rotation matrix
<code class="docutils literal notranslate"><span class="pre">R_AB</span></code> and also contains a position vector <code class="docutils literal notranslate"><span class="pre">p_AoBo_A</span></code> from
frame A’s origin to frame B’s origin. <code class="docutils literal notranslate"><span class="pre">p_AoBo_A</span></code> must be
expressed in frame A.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError in debug builds if R_AB is not a proper orthonormal</strong> – </p></li>
<li><p><strong>3x3 rotation matrix.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>No attempt is made to orthogonalize the 3x3 rotation matrix part
of <code class="docutils literal notranslate"><span class="pre">pose</span></code>. As needed, use
RotationMatrix::ProjectToRotationMatrix().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-Expression-.SetIdentity">
<span id="pydrake.math.RigidTransform_[Expression].SetIdentity"></span><span class="sig-name descname"><span class="pre">SetIdentity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-Expression-.SetIdentity" title="Permalink to this definition"></a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform so it corresponds to aligning the two
frames so unit vectors Ax = Bx, Ay = By, Az = Bz and point Ao is
coincident with Bo. Hence, <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidTransform contains a 3x3
identity matrix and a zero position vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RigidTransform_-Expression-.translation">
<span id="pydrake.math.RigidTransform_[Expression].translation"></span><span class="sig-name descname"><span class="pre">translation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RigidTransform_-Expression-.translation" title="Permalink to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">p_AoBo_A</span></code>, the position vector portion of <code class="docutils literal notranslate"><span class="pre">this</span></code>
RigidTransform, i.e., position vector from Ao (frame A’s origin) to Bo
(frame B’s origin).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">RollPitchYaw</span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw" title="Permalink to this definition"></a></dt>
<dd><p>This class represents the orientation between two arbitrary frames A
and D associated with a Space-fixed (extrinsic) X-Y-Z rotation by
“roll-pitch-yaw” angles <code class="docutils literal notranslate"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code>, which is equivalent to a
Body-fixed (intrinsic) Z-Y-X rotation by “yaw-pitch-roll” angles <code class="docutils literal notranslate"><span class="pre">[y,</span>
<span class="pre">p,</span> <span class="pre">r]</span></code>. The rotation matrix <code class="docutils literal notranslate"><span class="pre">R_AD</span></code> associated with this
roll-pitch-yaw <code class="docutils literal notranslate"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code> rotation sequence is equal to the matrix
multiplication shown below.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>⎡cos(y) -sin(y)  0⎤   ⎡ cos(p)  0  sin(p)⎤   ⎡1      0        0 ⎤
R_AD = ⎢sin(y)  cos(y)  0⎥ * ⎢     0   1      0 ⎥ * ⎢0  cos(r)  -sin(r)⎥
       ⎣    0       0   1⎦   ⎣-sin(p)  0  cos(p)⎦   ⎣0  sin(r)   cos(r)⎦
     =       R_AB          *        R_BC          *        R_CD
</pre></div>
</div>
</details><div class="admonition note">
<p class="admonition-title">Note</p>
<p>In this discussion, A is the Space frame and D is the Body frame.
One way to visualize this rotation sequence is by introducing
intermediate frames B and C (useful constructs to understand this
rotation sequence). Initially, the frames are aligned so <code class="docutils literal notranslate"><span class="pre">Di</span> <span class="pre">=</span> <span class="pre">Ci</span>
<span class="pre">=</span> <span class="pre">Bi</span> <span class="pre">=</span> <span class="pre">Ai</span> <span class="pre">(i</span> <span class="pre">=</span> <span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code> where Dx, Dy, Dz and Ax, Ay, Az are
orthogonal unit vectors fixed in frames D and A respectively.
Similarly for Bx, By, Bz and Cx, Cy, Cz in frame B, C. Then D is
subjected to successive right-handed rotations relative to A.</p>
</div>
<ul class="simple">
<li><p>1st rotation R_CD: Frame D rotates relative to frames C, B, A by a</p></li>
</ul>
<p>roll angle <code class="docutils literal notranslate"><span class="pre">r</span></code> about <code class="docutils literal notranslate"><span class="pre">Dx</span> <span class="pre">=</span> <span class="pre">Cx</span></code>.  Note: D and C are no longer aligned.</p>
<ul class="simple">
<li><p>2nd rotation R_BC: Frames D, C (collectively – as if welded together)</p></li>
</ul>
<p>rotate relative to frame B, A by a pitch angle <code class="docutils literal notranslate"><span class="pre">p</span></code> about <code class="docutils literal notranslate"><span class="pre">Cy</span> <span class="pre">=</span> <span class="pre">By</span></code>.
Note: C and B are no longer aligned.</p>
<ul class="simple">
<li><p>3rd rotation R_AB: Frames D, C, B (collectively – as if welded)</p></li>
</ul>
<p>rotate relative to frame A by a yaw angle <code class="docutils literal notranslate"><span class="pre">y</span></code> about <code class="docutils literal notranslate"><span class="pre">Bz</span> <span class="pre">=</span> <span class="pre">Az</span></code>.
Note: B and A are no longer aligned.
The monogram notation for the rotation matrix relating A to D is <code class="docutils literal notranslate"><span class="pre">R_AD</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>multibody_quantities for monogram notation for dynamics and
orientation_discussion “a discussion on rotation matrices”.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class does not store the frames associated with this rotation
sequence.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <a class="reference internal" href="#pydrake.math.RollPitchYaw_" title="pydrake.math.RollPitchYaw_"><code class="xref py py-class docutils literal notranslate"><span class="pre">RollPitchYaw_</span></code></a>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.RollPitchYaw.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.math.RollPitchYaw, other: pydrake.math.RollPitchYaw) -&gt; None</p></li>
<li><p>__init__(self: pydrake.math.RollPitchYaw, rpy: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs a RollPitchYaw from a 3x1 array of angles.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rpy</span></code>:</dt><dd><p>3x1 array with roll, pitch, yaw angles (units of radians).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError in debug builds if !IsValid</strong><strong>(</strong><strong>rpy</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.math.RollPitchYaw, roll: float, pitch: float, yaw: float) -&gt; None</p></li>
</ol>
<p>Constructs a RollPitchYaw from roll, pitch, yaw angles (radian units).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">roll</span></code>:</dt><dd><p>x-directed angle in SpaceXYZ rotation sequence.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pitch</span></code>:</dt><dd><p>y-directed angle in SpaceXYZ rotation sequence.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">yaw</span></code>:</dt><dd><p>z-directed angle in SpaceXYZ rotation sequence.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError in debug builds if !IsValid</strong><strong>(</strong><strong>Vector3&lt;T&gt;</strong><strong>(</strong><strong>roll</strong><strong>, </strong><strong>pitch</strong><strong>,</strong> – </p></li>
<li><p><strong>yaw</strong><strong>)</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.math.RollPitchYaw, R: pydrake.math.RotationMatrix) -&gt; None</p></li>
</ol>
<p>Uses a RotationMatrix to construct a RollPitchYaw with roll-pitch-yaw
angles <code class="docutils literal notranslate"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code> in the range <code class="docutils literal notranslate"><span class="pre">-π</span> <span class="pre">&lt;=</span> <span class="pre">r</span> <span class="pre">&lt;=</span> <span class="pre">π</span></code>, <cite>-π/2 &lt;= p &lt;=
π/2</cite>, <code class="docutils literal notranslate"><span class="pre">-π</span> <span class="pre">&lt;=</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">π</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R</span></code>:</dt><dd><p>a RotationMatrix.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This new high-accuracy algorithm avoids numerical round-off issues
encountered by some algorithms when pitch is within 1E-6 of π/2 or
-π/2.</p>
</div>
<ol class="arabic simple" start="5">
<li><p>__init__(self: pydrake.math.RollPitchYaw, quaternion: pydrake.common.eigen_geometry.Quaternion) -&gt; None</p></li>
</ol>
<p>Uses a Quaternion to construct a RollPitchYaw with roll-pitch-yaw
angles <code class="docutils literal notranslate"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code> in the range <code class="docutils literal notranslate"><span class="pre">-π</span> <span class="pre">&lt;=</span> <span class="pre">r</span> <span class="pre">&lt;=</span> <span class="pre">π</span></code>, <cite>-π/2 &lt;= p &lt;=
π/2</cite>, <code class="docutils literal notranslate"><span class="pre">-π</span> <span class="pre">&lt;=</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">π</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quaternion</span></code>:</dt><dd><p>unit Quaternion.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This new high-accuracy algorithm avoids numerical round-off issues
encountered by some algorithms when pitch is within 1E-6 of π/2 or
-π/2.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError in debug builds if !IsValid</strong><strong>(</strong><strong>rpy</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="6">
<li><p>__init__(self: pydrake.math.RollPitchYaw, matrix: numpy.ndarray[numpy.float64[3, 3]]) -&gt; None</p></li>
</ol>
<p>Construct from raw rotation matrix. See RotationMatrix overload for more information.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw.CalcAngularVelocityInChildFromRpyDt">
<span class="sig-name descname"><span class="pre">CalcAngularVelocityInChildFromRpyDt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RollPitchYaw" title="pydrake.math.RollPitchYaw"><span class="pre">pydrake.math.RollPitchYaw</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">rpyDt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw.CalcAngularVelocityInChildFromRpyDt" title="Permalink to this definition"></a></dt>
<dd><p>Calculates angular velocity from <code class="docutils literal notranslate"><span class="pre">this</span></code> RollPitchYaw whose
roll-pitch-yaw angles <code class="docutils literal notranslate"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code> relate the orientation of two
generic frames A and D.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rpyDt</span></code>:</dt><dd><p>Time-derivative of <code class="docutils literal notranslate"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code>, i.e., <code class="docutils literal notranslate"><span class="pre">[ṙ;</span> <span class="pre">ṗ;</span> <span class="pre">ẏ]</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>w_AD_D, frame D’s angular velocity in frame A, expressed in
“child” frame D. In other words, returns [ω0; ω1; ω2]ᴅ, where
<code class="docutils literal notranslate"><span class="pre">w_AD_D</span> <span class="pre">=</span> <span class="pre">ω0</span> <span class="pre">Dx</span> <span class="pre">+</span> <span class="pre">ω1</span> <span class="pre">Dy</span> <span class="pre">+</span> <span class="pre">ω2</span> <span class="pre">Dz</span></code>, and where [ω0; ω1; ω2]ᴅ is
calculated via the 3x3 matrix Nc⁻¹ (the inverse of the matrix Nc
documented in CalcMatrixRelatingRpyDtToAngularVelocityInChild()).</p>
</dd>
</dl>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>⌈ ω0 ⌉         ⌈ ṙ ⌉            ⌈ 1      0        -sin(p)    ⌉
| ω1 |  = Nc⁻¹ | ṗ |     Nc⁻¹ = | 0   cos(r)   sin(r)*cos(p) |
⌊ ω2 ⌋ᴅ        ⌊ ẏ ⌋            ⌊ 0  -sin(r)   cos(r)*cos(p) ⌋
</pre></div>
</div>
</details></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw.CalcAngularVelocityInParentFromRpyDt">
<span class="sig-name descname"><span class="pre">CalcAngularVelocityInParentFromRpyDt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RollPitchYaw" title="pydrake.math.RollPitchYaw"><span class="pre">pydrake.math.RollPitchYaw</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">rpyDt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw.CalcAngularVelocityInParentFromRpyDt" title="Permalink to this definition"></a></dt>
<dd><p>Calculates angular velocity from <code class="docutils literal notranslate"><span class="pre">this</span></code> RollPitchYaw whose
roll-pitch-yaw angles <code class="docutils literal notranslate"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code> relate the orientation of two
generic frames A and D.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rpyDt</span></code>:</dt><dd><p>Time-derivative of <code class="docutils literal notranslate"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code>, i.e., <code class="docutils literal notranslate"><span class="pre">[ṙ;</span> <span class="pre">ṗ;</span> <span class="pre">ẏ]</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>w_AD_A, frame D’s angular velocity in frame A, expressed in
“parent” frame A. In other words, returns [ωx; ωy; ωz]ᴀ, where
<code class="docutils literal notranslate"><span class="pre">w_AD_A</span> <span class="pre">=</span> <span class="pre">ωx</span> <span class="pre">Ax</span> <span class="pre">+</span> <span class="pre">ωy</span> <span class="pre">Ay</span> <span class="pre">+</span> <span class="pre">ωz</span> <span class="pre">Az</span></code>, and where [ωx; ωy; ωz]ᴀ is
calculated via the the 3x3 matrix Np⁻¹ (the inverse of the matrix
Np documented in
CalcMatrixRelatingRpyDtToAngularVelocityInParent()).</p>
</dd>
</dl>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>⌈ ωx ⌉         ⌈ ṙ ⌉            ⌈ cos(y)*cos(p)  -sin(y)  0 ⌉
| ωy |  = Np⁻¹ | ṗ |     Np⁻¹ = | sin(y)*cos(p)   cos(y)  0 |
⌊ ωz ⌋ᴀ        ⌊ ẏ ⌋            ⌊   -sin(p)         0     1 ⌋
</pre></div>
</div>
</details></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw.CalcRotationMatrixDt">
<span class="sig-name descname"><span class="pre">CalcRotationMatrixDt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RollPitchYaw" title="pydrake.math.RollPitchYaw"><span class="pre">pydrake.math.RollPitchYaw</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">rpyDt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw.CalcRotationMatrixDt" title="Permalink to this definition"></a></dt>
<dd><p>Forms Ṙ, the ordinary derivative of the RotationMatrix <code class="docutils literal notranslate"><span class="pre">R</span></code> with
respect to an independent variable <code class="docutils literal notranslate"><span class="pre">t</span></code> (<cite>t</cite> usually denotes time)
and <code class="docutils literal notranslate"><span class="pre">R</span></code> is the RotationMatrix formed by <code class="docutils literal notranslate"><span class="pre">this</span></code> RollPitchYaw. The
roll-pitch-yaw angles r, p, y are regarded as functions of <code class="docutils literal notranslate"><span class="pre">t</span></code>
[i.e., r(t), p(t), y(t)].</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rpyDt</span></code>:</dt><dd><p>Ordinary derivative of rpy with respect to an independent variable
<code class="docutils literal notranslate"><span class="pre">t</span></code> (<cite>t</cite> usually denotes time, but not necessarily).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Ṙ, the ordinary derivative of <code class="docutils literal notranslate"><span class="pre">R</span></code> with respect to <code class="docutils literal notranslate"><span class="pre">t</span></code>,
calculated as Ṙ = ∂R/∂r * ṙ + ∂R/∂p * ṗ + ∂R/∂y * ẏ. In other
words, the returned (i, j) element is ∂Rij/∂r * ṙ + ∂Rij/∂p * ṗ
+ ∂Rij/∂y * ẏ.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw.CalcRpyDDtFromAngularAccelInChild">
<span class="sig-name descname"><span class="pre">CalcRpyDDtFromAngularAccelInChild</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RollPitchYaw" title="pydrake.math.RollPitchYaw"><span class="pre">pydrake.math.RollPitchYaw</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">rpyDt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha_AD_D</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw.CalcRpyDDtFromAngularAccelInChild" title="Permalink to this definition"></a></dt>
<dd><p>Uses angular acceleration to compute the 2ⁿᵈ time-derivative of
<code class="docutils literal notranslate"><span class="pre">this</span></code> RollPitchYaw whose angles <code class="docutils literal notranslate"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code> orient two generic
frames A and D.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rpyDt</span></code>:</dt><dd><p>time-derivative of <code class="docutils literal notranslate"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code>, i.e., <code class="docutils literal notranslate"><span class="pre">[ṙ;</span> <span class="pre">ṗ;</span> <span class="pre">ẏ]</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">alpha_AD_D</span></code>:</dt><dd><p>frame D’s angular acceleration in frame A, expressed in frame D.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">[r̈,</span> <span class="pre">p̈,</span> <span class="pre">ÿ]</span></code>, the 2ⁿᵈ time-derivative of <code class="docutils literal notranslate"><span class="pre">this</span></code>
RollPitchYaw.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>RuntimeError if cos</strong><strong>(</strong><strong>p</strong><strong>) </strong><strong>≈ 0</strong><strong> (</strong><strong>p is near gimbal-lock</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method has a divide-by-zero error (singularity) when the
cosine of the pitch angle <code class="docutils literal notranslate"><span class="pre">p</span></code> is zero [i.e., <code class="docutils literal notranslate"><span class="pre">cos(p)</span> <span class="pre">=</span> <span class="pre">0`].</span>
<span class="pre">This</span> <span class="pre">problem</span> <span class="pre">(called</span> <span class="pre">&quot;gimbal</span> <span class="pre">lock&quot;)</span> <span class="pre">occurs</span> <span class="pre">when</span> <span class="pre">`p</span> <span class="pre">=</span> <span class="pre">n</span> <span class="pre">π</span> <span class="pre">+</span> <span class="pre">π</span> <span class="pre">/</span>
<span class="pre">2</span></code>, where n is any integer. There are associated precision
problems (inaccuracies) in the neighborhood of these pitch angles,
i.e., when <code class="docutils literal notranslate"><span class="pre">cos(p)</span> <span class="pre">≈</span> <span class="pre">0</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw.CalcRpyDDtFromRpyDtAndAngularAccelInParent">
<span class="sig-name descname"><span class="pre">CalcRpyDDtFromRpyDtAndAngularAccelInParent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RollPitchYaw" title="pydrake.math.RollPitchYaw"><span class="pre">pydrake.math.RollPitchYaw</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">rpyDt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha_AD_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw.CalcRpyDDtFromRpyDtAndAngularAccelInParent" title="Permalink to this definition"></a></dt>
<dd><p>Uses angular acceleration to compute the 2ⁿᵈ time-derivative of
<code class="docutils literal notranslate"><span class="pre">this</span></code> RollPitchYaw whose angles <code class="docutils literal notranslate"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code> orient two generic
frames A and D.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rpyDt</span></code>:</dt><dd><p>time-derivative of <code class="docutils literal notranslate"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code>, i.e., <code class="docutils literal notranslate"><span class="pre">[ṙ;</span> <span class="pre">ṗ;</span> <span class="pre">ẏ]</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">alpha_AD_A</span></code>:</dt><dd><p>frame D’s angular acceleration in frame A, expressed in frame A.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">[r̈,</span> <span class="pre">p̈,</span> <span class="pre">ÿ]</span></code>, the 2ⁿᵈ time-derivative of <code class="docutils literal notranslate"><span class="pre">this</span></code>
RollPitchYaw.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>RuntimeError if cos</strong><strong>(</strong><strong>p</strong><strong>) </strong><strong>≈ 0</strong><strong> (</strong><strong>p is near gimbal-lock</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method has a divide-by-zero error (singularity) when the
cosine of the pitch angle <code class="docutils literal notranslate"><span class="pre">p</span></code> is zero [i.e., <code class="docutils literal notranslate"><span class="pre">cos(p)</span> <span class="pre">=</span> <span class="pre">0`].</span>
<span class="pre">This</span> <span class="pre">problem</span> <span class="pre">(called</span> <span class="pre">&quot;gimbal</span> <span class="pre">lock&quot;)</span> <span class="pre">occurs</span> <span class="pre">when</span> <span class="pre">`p</span> <span class="pre">=</span> <span class="pre">n</span> <span class="pre">π</span> <span class="pre">+</span> <span class="pre">π</span> <span class="pre">/</span>
<span class="pre">2</span></code>, where n is any integer. There are associated precision
problems (inaccuracies) in the neighborhood of these pitch angles,
i.e., when <code class="docutils literal notranslate"><span class="pre">cos(p)</span> <span class="pre">≈</span> <span class="pre">0</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw.CalcRpyDtFromAngularVelocityInChild">
<span class="sig-name descname"><span class="pre">CalcRpyDtFromAngularVelocityInChild</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RollPitchYaw" title="pydrake.math.RollPitchYaw"><span class="pre">pydrake.math.RollPitchYaw</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_AD_D</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw.CalcRpyDtFromAngularVelocityInChild" title="Permalink to this definition"></a></dt>
<dd><p>Uses angular velocity to compute the 1ˢᵗ time-derivative of <code class="docutils literal notranslate"><span class="pre">this</span></code>
RollPitchYaw whose angles <code class="docutils literal notranslate"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code> orient two generic frames A
and D.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">w_AD_D</span></code>:</dt><dd><p>frame D’s angular velocity in frame A, expressed in D.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">[ṙ;</span> <span class="pre">ṗ;</span> <span class="pre">ẏ]</span></code>, the 1ˢᵗ time-derivative of <code class="docutils literal notranslate"><span class="pre">this</span></code>
RollPitchYaw.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>RuntimeError if cos</strong><strong>(</strong><strong>p</strong><strong>) </strong><strong>≈ 0</strong><strong> (</strong><strong>p is near gimbal-lock</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Enhanced documentation for this method and its gimbal-lock
(divide- by-zero error) is in
CalcMatrixRelatingRpyDtToAngularVelocityInChild().</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcRpyDtFromAngularVelocityInParent()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw.CalcRpyDtFromAngularVelocityInParent">
<span class="sig-name descname"><span class="pre">CalcRpyDtFromAngularVelocityInParent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RollPitchYaw" title="pydrake.math.RollPitchYaw"><span class="pre">pydrake.math.RollPitchYaw</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_AD_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw.CalcRpyDtFromAngularVelocityInParent" title="Permalink to this definition"></a></dt>
<dd><p>Uses angular velocity to compute the 1ˢᵗ time-derivative of <code class="docutils literal notranslate"><span class="pre">this</span></code>
RollPitchYaw whose angles <code class="docutils literal notranslate"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code> orient two generic frames A
and D.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">w_AD_A</span></code>:</dt><dd><p>frame D’s angular velocity in frame A, expressed in A.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">[ṙ;</span> <span class="pre">ṗ;</span> <span class="pre">ẏ]</span></code>, the 1ˢᵗ time-derivative of <code class="docutils literal notranslate"><span class="pre">this</span></code>
RollPitchYaw.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>RuntimeError if cos</strong><strong>(</strong><strong>p</strong><strong>) </strong><strong>≈ 0</strong><strong> (</strong><strong>p is near gimbal-lock</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Enhanced documentation for this method and its gimbal-lock
(divide- by-zero error) is in
CalcMatrixRelatingRpyDtToAngularVelocityInParent().</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcRpyDtFromAngularVelocityInChild()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw.pitch_angle">
<span class="sig-name descname"><span class="pre">pitch_angle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RollPitchYaw" title="pydrake.math.RollPitchYaw"><span class="pre">pydrake.math.RollPitchYaw</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw.pitch_angle" title="Permalink to this definition"></a></dt>
<dd><p>Returns the pitch-angle underlying <code class="docutils literal notranslate"><span class="pre">this</span></code> RollPitchYaw.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw.roll_angle">
<span class="sig-name descname"><span class="pre">roll_angle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RollPitchYaw" title="pydrake.math.RollPitchYaw"><span class="pre">pydrake.math.RollPitchYaw</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw.roll_angle" title="Permalink to this definition"></a></dt>
<dd><p>Returns the roll-angle underlying <code class="docutils literal notranslate"><span class="pre">this</span></code> RollPitchYaw.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw.ToQuaternion">
<span class="sig-name descname"><span class="pre">ToQuaternion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RollPitchYaw" title="pydrake.math.RollPitchYaw"><span class="pre">pydrake.math.RollPitchYaw</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.common.eigen_geometry.html#pydrake.common.eigen_geometry.Quaternion" title="pydrake.common.eigen_geometry.Quaternion"><span class="pre">pydrake.common.eigen_geometry.Quaternion</span></a></span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw.ToQuaternion" title="Permalink to this definition"></a></dt>
<dd><p>Returns a quaternion representation of <code class="docutils literal notranslate"><span class="pre">this</span></code> RollPitchYaw.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw.ToRotationMatrix">
<span class="sig-name descname"><span class="pre">ToRotationMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RollPitchYaw" title="pydrake.math.RollPitchYaw"><span class="pre">pydrake.math.RollPitchYaw</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RotationMatrix" title="pydrake.math.RotationMatrix"><span class="pre">pydrake.math.RotationMatrix</span></a></span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw.ToRotationMatrix" title="Permalink to this definition"></a></dt>
<dd><p>Returns the RotationMatrix representation of <code class="docutils literal notranslate"><span class="pre">this</span></code> RollPitchYaw.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw.vector">
<span class="sig-name descname"><span class="pre">vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RollPitchYaw" title="pydrake.math.RollPitchYaw"><span class="pre">pydrake.math.RollPitchYaw</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw.vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns the Vector3 underlying <code class="docutils literal notranslate"><span class="pre">this</span></code> RollPitchYaw.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw.yaw_angle">
<span class="sig-name descname"><span class="pre">yaw_angle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RollPitchYaw" title="pydrake.math.RollPitchYaw"><span class="pre">pydrake.math.RollPitchYaw</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw.yaw_angle" title="Permalink to this definition"></a></dt>
<dd><p>Returns the yaw-angle underlying <code class="docutils literal notranslate"><span class="pre">this</span></code> RollPitchYaw.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">RollPitchYaw_</span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw_" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">RollPitchYaw_[float]</span></code>, <a class="reference internal" href="#pydrake.math.RollPitchYaw_-AutoDiffXd" title="pydrake.math.RollPitchYaw_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">RollPitchYaw_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.math.RollPitchYaw_-Expression" title="pydrake.math.RollPitchYaw_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">RollPitchYaw_[Expression]</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw_-AutoDiffXd">
<span id="pydrake.math.RollPitchYaw_[AutoDiffXd]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">RollPitchYaw_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw_-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><p>This class represents the orientation between two arbitrary frames A
and D associated with a Space-fixed (extrinsic) X-Y-Z rotation by
“roll-pitch-yaw” angles <code class="docutils literal notranslate"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code>, which is equivalent to a
Body-fixed (intrinsic) Z-Y-X rotation by “yaw-pitch-roll” angles <code class="docutils literal notranslate"><span class="pre">[y,</span>
<span class="pre">p,</span> <span class="pre">r]</span></code>. The rotation matrix <code class="docutils literal notranslate"><span class="pre">R_AD</span></code> associated with this
roll-pitch-yaw <code class="docutils literal notranslate"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code> rotation sequence is equal to the matrix
multiplication shown below.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>⎡cos(y) -sin(y)  0⎤   ⎡ cos(p)  0  sin(p)⎤   ⎡1      0        0 ⎤
R_AD = ⎢sin(y)  cos(y)  0⎥ * ⎢     0   1      0 ⎥ * ⎢0  cos(r)  -sin(r)⎥
       ⎣    0       0   1⎦   ⎣-sin(p)  0  cos(p)⎦   ⎣0  sin(r)   cos(r)⎦
     =       R_AB          *        R_BC          *        R_CD
</pre></div>
</div>
</details><div class="admonition note">
<p class="admonition-title">Note</p>
<p>In this discussion, A is the Space frame and D is the Body frame.
One way to visualize this rotation sequence is by introducing
intermediate frames B and C (useful constructs to understand this
rotation sequence). Initially, the frames are aligned so <code class="docutils literal notranslate"><span class="pre">Di</span> <span class="pre">=</span> <span class="pre">Ci</span>
<span class="pre">=</span> <span class="pre">Bi</span> <span class="pre">=</span> <span class="pre">Ai</span> <span class="pre">(i</span> <span class="pre">=</span> <span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code> where Dx, Dy, Dz and Ax, Ay, Az are
orthogonal unit vectors fixed in frames D and A respectively.
Similarly for Bx, By, Bz and Cx, Cy, Cz in frame B, C. Then D is
subjected to successive right-handed rotations relative to A.</p>
</div>
<ul class="simple">
<li><p>1st rotation R_CD: Frame D rotates relative to frames C, B, A by a</p></li>
</ul>
<p>roll angle <code class="docutils literal notranslate"><span class="pre">r</span></code> about <code class="docutils literal notranslate"><span class="pre">Dx</span> <span class="pre">=</span> <span class="pre">Cx</span></code>.  Note: D and C are no longer aligned.</p>
<ul class="simple">
<li><p>2nd rotation R_BC: Frames D, C (collectively – as if welded together)</p></li>
</ul>
<p>rotate relative to frame B, A by a pitch angle <code class="docutils literal notranslate"><span class="pre">p</span></code> about <code class="docutils literal notranslate"><span class="pre">Cy</span> <span class="pre">=</span> <span class="pre">By</span></code>.
Note: C and B are no longer aligned.</p>
<ul class="simple">
<li><p>3rd rotation R_AB: Frames D, C, B (collectively – as if welded)</p></li>
</ul>
<p>rotate relative to frame A by a yaw angle <code class="docutils literal notranslate"><span class="pre">y</span></code> about <code class="docutils literal notranslate"><span class="pre">Bz</span> <span class="pre">=</span> <span class="pre">Az</span></code>.
Note: B and A are no longer aligned.
The monogram notation for the rotation matrix relating A to D is <code class="docutils literal notranslate"><span class="pre">R_AD</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>multibody_quantities for monogram notation for dynamics and
orientation_discussion “a discussion on rotation matrices”.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class does not store the frames associated with this rotation
sequence.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw_-AutoDiffXd-.__init__">
<span id="pydrake.math.RollPitchYaw_[AutoDiffXd].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.RollPitchYaw_-AutoDiffXd-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.math.RollPitchYaw_[AutoDiffXd], other: pydrake.math.RollPitchYaw_[AutoDiffXd]) -&gt; None</p></li>
<li><p>__init__(self: pydrake.math.RollPitchYaw_[AutoDiffXd], rpy: numpy.ndarray[object[3, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs a RollPitchYaw from a 3x1 array of angles.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rpy</span></code>:</dt><dd><p>3x1 array with roll, pitch, yaw angles (units of radians).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError in debug builds if !IsValid</strong><strong>(</strong><strong>rpy</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.math.RollPitchYaw_[AutoDiffXd], roll: pydrake.autodiffutils.AutoDiffXd, pitch: pydrake.autodiffutils.AutoDiffXd, yaw: pydrake.autodiffutils.AutoDiffXd) -&gt; None</p></li>
</ol>
<p>Constructs a RollPitchYaw from roll, pitch, yaw angles (radian units).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">roll</span></code>:</dt><dd><p>x-directed angle in SpaceXYZ rotation sequence.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pitch</span></code>:</dt><dd><p>y-directed angle in SpaceXYZ rotation sequence.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">yaw</span></code>:</dt><dd><p>z-directed angle in SpaceXYZ rotation sequence.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError in debug builds if !IsValid</strong><strong>(</strong><strong>Vector3&lt;T&gt;</strong><strong>(</strong><strong>roll</strong><strong>, </strong><strong>pitch</strong><strong>,</strong> – </p></li>
<li><p><strong>yaw</strong><strong>)</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.math.RollPitchYaw_[AutoDiffXd], R: pydrake.math.RotationMatrix_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Uses a RotationMatrix to construct a RollPitchYaw with roll-pitch-yaw
angles <code class="docutils literal notranslate"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code> in the range <code class="docutils literal notranslate"><span class="pre">-π</span> <span class="pre">&lt;=</span> <span class="pre">r</span> <span class="pre">&lt;=</span> <span class="pre">π</span></code>, <cite>-π/2 &lt;= p &lt;=
π/2</cite>, <code class="docutils literal notranslate"><span class="pre">-π</span> <span class="pre">&lt;=</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">π</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R</span></code>:</dt><dd><p>a RotationMatrix.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This new high-accuracy algorithm avoids numerical round-off issues
encountered by some algorithms when pitch is within 1E-6 of π/2 or
-π/2.</p>
</div>
<ol class="arabic simple" start="5">
<li><p>__init__(self: pydrake.math.RollPitchYaw_[AutoDiffXd], quaternion: pydrake.common.eigen_geometry.Quaternion_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Uses a Quaternion to construct a RollPitchYaw with roll-pitch-yaw
angles <code class="docutils literal notranslate"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code> in the range <code class="docutils literal notranslate"><span class="pre">-π</span> <span class="pre">&lt;=</span> <span class="pre">r</span> <span class="pre">&lt;=</span> <span class="pre">π</span></code>, <cite>-π/2 &lt;= p &lt;=
π/2</cite>, <code class="docutils literal notranslate"><span class="pre">-π</span> <span class="pre">&lt;=</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">π</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quaternion</span></code>:</dt><dd><p>unit Quaternion.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This new high-accuracy algorithm avoids numerical round-off issues
encountered by some algorithms when pitch is within 1E-6 of π/2 or
-π/2.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError in debug builds if !IsValid</strong><strong>(</strong><strong>rpy</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="6">
<li><p>__init__(self: pydrake.math.RollPitchYaw_[AutoDiffXd], matrix: numpy.ndarray[object[3, 3]]) -&gt; None</p></li>
</ol>
<p>Construct from raw rotation matrix. See RotationMatrix overload for more information.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw_-AutoDiffXd-.CalcAngularVelocityInChildFromRpyDt">
<span id="pydrake.math.RollPitchYaw_[AutoDiffXd].CalcAngularVelocityInChildFromRpyDt"></span><span class="sig-name descname"><span class="pre">CalcAngularVelocityInChildFromRpyDt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RollPitchYaw_" title="pydrake.math.RollPitchYaw_"><span class="pre">pydrake.math.RollPitchYaw_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rpyDt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw_-AutoDiffXd-.CalcAngularVelocityInChildFromRpyDt" title="Permalink to this definition"></a></dt>
<dd><p>Calculates angular velocity from <code class="docutils literal notranslate"><span class="pre">this</span></code> RollPitchYaw whose
roll-pitch-yaw angles <code class="docutils literal notranslate"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code> relate the orientation of two
generic frames A and D.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rpyDt</span></code>:</dt><dd><p>Time-derivative of <code class="docutils literal notranslate"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code>, i.e., <code class="docutils literal notranslate"><span class="pre">[ṙ;</span> <span class="pre">ṗ;</span> <span class="pre">ẏ]</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>w_AD_D, frame D’s angular velocity in frame A, expressed in
“child” frame D. In other words, returns [ω0; ω1; ω2]ᴅ, where
<code class="docutils literal notranslate"><span class="pre">w_AD_D</span> <span class="pre">=</span> <span class="pre">ω0</span> <span class="pre">Dx</span> <span class="pre">+</span> <span class="pre">ω1</span> <span class="pre">Dy</span> <span class="pre">+</span> <span class="pre">ω2</span> <span class="pre">Dz</span></code>, and where [ω0; ω1; ω2]ᴅ is
calculated via the 3x3 matrix Nc⁻¹ (the inverse of the matrix Nc
documented in CalcMatrixRelatingRpyDtToAngularVelocityInChild()).</p>
</dd>
</dl>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>⌈ ω0 ⌉         ⌈ ṙ ⌉            ⌈ 1      0        -sin(p)    ⌉
| ω1 |  = Nc⁻¹ | ṗ |     Nc⁻¹ = | 0   cos(r)   sin(r)*cos(p) |
⌊ ω2 ⌋ᴅ        ⌊ ẏ ⌋            ⌊ 0  -sin(r)   cos(r)*cos(p) ⌋
</pre></div>
</div>
</details></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw_-AutoDiffXd-.CalcAngularVelocityInParentFromRpyDt">
<span id="pydrake.math.RollPitchYaw_[AutoDiffXd].CalcAngularVelocityInParentFromRpyDt"></span><span class="sig-name descname"><span class="pre">CalcAngularVelocityInParentFromRpyDt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RollPitchYaw_" title="pydrake.math.RollPitchYaw_"><span class="pre">pydrake.math.RollPitchYaw_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rpyDt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw_-AutoDiffXd-.CalcAngularVelocityInParentFromRpyDt" title="Permalink to this definition"></a></dt>
<dd><p>Calculates angular velocity from <code class="docutils literal notranslate"><span class="pre">this</span></code> RollPitchYaw whose
roll-pitch-yaw angles <code class="docutils literal notranslate"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code> relate the orientation of two
generic frames A and D.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rpyDt</span></code>:</dt><dd><p>Time-derivative of <code class="docutils literal notranslate"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code>, i.e., <code class="docutils literal notranslate"><span class="pre">[ṙ;</span> <span class="pre">ṗ;</span> <span class="pre">ẏ]</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>w_AD_A, frame D’s angular velocity in frame A, expressed in
“parent” frame A. In other words, returns [ωx; ωy; ωz]ᴀ, where
<code class="docutils literal notranslate"><span class="pre">w_AD_A</span> <span class="pre">=</span> <span class="pre">ωx</span> <span class="pre">Ax</span> <span class="pre">+</span> <span class="pre">ωy</span> <span class="pre">Ay</span> <span class="pre">+</span> <span class="pre">ωz</span> <span class="pre">Az</span></code>, and where [ωx; ωy; ωz]ᴀ is
calculated via the the 3x3 matrix Np⁻¹ (the inverse of the matrix
Np documented in
CalcMatrixRelatingRpyDtToAngularVelocityInParent()).</p>
</dd>
</dl>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>⌈ ωx ⌉         ⌈ ṙ ⌉            ⌈ cos(y)*cos(p)  -sin(y)  0 ⌉
| ωy |  = Np⁻¹ | ṗ |     Np⁻¹ = | sin(y)*cos(p)   cos(y)  0 |
⌊ ωz ⌋ᴀ        ⌊ ẏ ⌋            ⌊   -sin(p)         0     1 ⌋
</pre></div>
</div>
</details></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw_-AutoDiffXd-.CalcRotationMatrixDt">
<span id="pydrake.math.RollPitchYaw_[AutoDiffXd].CalcRotationMatrixDt"></span><span class="sig-name descname"><span class="pre">CalcRotationMatrixDt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RollPitchYaw_" title="pydrake.math.RollPitchYaw_"><span class="pre">pydrake.math.RollPitchYaw_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rpyDt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw_-AutoDiffXd-.CalcRotationMatrixDt" title="Permalink to this definition"></a></dt>
<dd><p>Forms Ṙ, the ordinary derivative of the RotationMatrix <code class="docutils literal notranslate"><span class="pre">R</span></code> with
respect to an independent variable <code class="docutils literal notranslate"><span class="pre">t</span></code> (<cite>t</cite> usually denotes time)
and <code class="docutils literal notranslate"><span class="pre">R</span></code> is the RotationMatrix formed by <code class="docutils literal notranslate"><span class="pre">this</span></code> RollPitchYaw. The
roll-pitch-yaw angles r, p, y are regarded as functions of <code class="docutils literal notranslate"><span class="pre">t</span></code>
[i.e., r(t), p(t), y(t)].</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rpyDt</span></code>:</dt><dd><p>Ordinary derivative of rpy with respect to an independent variable
<code class="docutils literal notranslate"><span class="pre">t</span></code> (<cite>t</cite> usually denotes time, but not necessarily).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Ṙ, the ordinary derivative of <code class="docutils literal notranslate"><span class="pre">R</span></code> with respect to <code class="docutils literal notranslate"><span class="pre">t</span></code>,
calculated as Ṙ = ∂R/∂r * ṙ + ∂R/∂p * ṗ + ∂R/∂y * ẏ. In other
words, the returned (i, j) element is ∂Rij/∂r * ṙ + ∂Rij/∂p * ṗ
+ ∂Rij/∂y * ẏ.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw_-AutoDiffXd-.CalcRpyDDtFromAngularAccelInChild">
<span id="pydrake.math.RollPitchYaw_[AutoDiffXd].CalcRpyDDtFromAngularAccelInChild"></span><span class="sig-name descname"><span class="pre">CalcRpyDDtFromAngularAccelInChild</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RollPitchYaw_" title="pydrake.math.RollPitchYaw_"><span class="pre">pydrake.math.RollPitchYaw_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rpyDt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha_AD_D</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw_-AutoDiffXd-.CalcRpyDDtFromAngularAccelInChild" title="Permalink to this definition"></a></dt>
<dd><p>Uses angular acceleration to compute the 2ⁿᵈ time-derivative of
<code class="docutils literal notranslate"><span class="pre">this</span></code> RollPitchYaw whose angles <code class="docutils literal notranslate"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code> orient two generic
frames A and D.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rpyDt</span></code>:</dt><dd><p>time-derivative of <code class="docutils literal notranslate"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code>, i.e., <code class="docutils literal notranslate"><span class="pre">[ṙ;</span> <span class="pre">ṗ;</span> <span class="pre">ẏ]</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">alpha_AD_D</span></code>:</dt><dd><p>frame D’s angular acceleration in frame A, expressed in frame D.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">[r̈,</span> <span class="pre">p̈,</span> <span class="pre">ÿ]</span></code>, the 2ⁿᵈ time-derivative of <code class="docutils literal notranslate"><span class="pre">this</span></code>
RollPitchYaw.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>RuntimeError if cos</strong><strong>(</strong><strong>p</strong><strong>) </strong><strong>≈ 0</strong><strong> (</strong><strong>p is near gimbal-lock</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method has a divide-by-zero error (singularity) when the
cosine of the pitch angle <code class="docutils literal notranslate"><span class="pre">p</span></code> is zero [i.e., <code class="docutils literal notranslate"><span class="pre">cos(p)</span> <span class="pre">=</span> <span class="pre">0`].</span>
<span class="pre">This</span> <span class="pre">problem</span> <span class="pre">(called</span> <span class="pre">&quot;gimbal</span> <span class="pre">lock&quot;)</span> <span class="pre">occurs</span> <span class="pre">when</span> <span class="pre">`p</span> <span class="pre">=</span> <span class="pre">n</span> <span class="pre">π</span> <span class="pre">+</span> <span class="pre">π</span> <span class="pre">/</span>
<span class="pre">2</span></code>, where n is any integer. There are associated precision
problems (inaccuracies) in the neighborhood of these pitch angles,
i.e., when <code class="docutils literal notranslate"><span class="pre">cos(p)</span> <span class="pre">≈</span> <span class="pre">0</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw_-AutoDiffXd-.CalcRpyDDtFromRpyDtAndAngularAccelInParent">
<span id="pydrake.math.RollPitchYaw_[AutoDiffXd].CalcRpyDDtFromRpyDtAndAngularAccelInParent"></span><span class="sig-name descname"><span class="pre">CalcRpyDDtFromRpyDtAndAngularAccelInParent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RollPitchYaw_" title="pydrake.math.RollPitchYaw_"><span class="pre">pydrake.math.RollPitchYaw_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rpyDt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha_AD_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw_-AutoDiffXd-.CalcRpyDDtFromRpyDtAndAngularAccelInParent" title="Permalink to this definition"></a></dt>
<dd><p>Uses angular acceleration to compute the 2ⁿᵈ time-derivative of
<code class="docutils literal notranslate"><span class="pre">this</span></code> RollPitchYaw whose angles <code class="docutils literal notranslate"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code> orient two generic
frames A and D.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rpyDt</span></code>:</dt><dd><p>time-derivative of <code class="docutils literal notranslate"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code>, i.e., <code class="docutils literal notranslate"><span class="pre">[ṙ;</span> <span class="pre">ṗ;</span> <span class="pre">ẏ]</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">alpha_AD_A</span></code>:</dt><dd><p>frame D’s angular acceleration in frame A, expressed in frame A.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">[r̈,</span> <span class="pre">p̈,</span> <span class="pre">ÿ]</span></code>, the 2ⁿᵈ time-derivative of <code class="docutils literal notranslate"><span class="pre">this</span></code>
RollPitchYaw.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>RuntimeError if cos</strong><strong>(</strong><strong>p</strong><strong>) </strong><strong>≈ 0</strong><strong> (</strong><strong>p is near gimbal-lock</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method has a divide-by-zero error (singularity) when the
cosine of the pitch angle <code class="docutils literal notranslate"><span class="pre">p</span></code> is zero [i.e., <code class="docutils literal notranslate"><span class="pre">cos(p)</span> <span class="pre">=</span> <span class="pre">0`].</span>
<span class="pre">This</span> <span class="pre">problem</span> <span class="pre">(called</span> <span class="pre">&quot;gimbal</span> <span class="pre">lock&quot;)</span> <span class="pre">occurs</span> <span class="pre">when</span> <span class="pre">`p</span> <span class="pre">=</span> <span class="pre">n</span> <span class="pre">π</span> <span class="pre">+</span> <span class="pre">π</span> <span class="pre">/</span>
<span class="pre">2</span></code>, where n is any integer. There are associated precision
problems (inaccuracies) in the neighborhood of these pitch angles,
i.e., when <code class="docutils literal notranslate"><span class="pre">cos(p)</span> <span class="pre">≈</span> <span class="pre">0</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw_-AutoDiffXd-.CalcRpyDtFromAngularVelocityInChild">
<span id="pydrake.math.RollPitchYaw_[AutoDiffXd].CalcRpyDtFromAngularVelocityInChild"></span><span class="sig-name descname"><span class="pre">CalcRpyDtFromAngularVelocityInChild</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RollPitchYaw_" title="pydrake.math.RollPitchYaw_"><span class="pre">pydrake.math.RollPitchYaw_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_AD_D</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw_-AutoDiffXd-.CalcRpyDtFromAngularVelocityInChild" title="Permalink to this definition"></a></dt>
<dd><p>Uses angular velocity to compute the 1ˢᵗ time-derivative of <code class="docutils literal notranslate"><span class="pre">this</span></code>
RollPitchYaw whose angles <code class="docutils literal notranslate"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code> orient two generic frames A
and D.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">w_AD_D</span></code>:</dt><dd><p>frame D’s angular velocity in frame A, expressed in D.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">[ṙ;</span> <span class="pre">ṗ;</span> <span class="pre">ẏ]</span></code>, the 1ˢᵗ time-derivative of <code class="docutils literal notranslate"><span class="pre">this</span></code>
RollPitchYaw.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>RuntimeError if cos</strong><strong>(</strong><strong>p</strong><strong>) </strong><strong>≈ 0</strong><strong> (</strong><strong>p is near gimbal-lock</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Enhanced documentation for this method and its gimbal-lock
(divide- by-zero error) is in
CalcMatrixRelatingRpyDtToAngularVelocityInChild().</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcRpyDtFromAngularVelocityInParent()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw_-AutoDiffXd-.CalcRpyDtFromAngularVelocityInParent">
<span id="pydrake.math.RollPitchYaw_[AutoDiffXd].CalcRpyDtFromAngularVelocityInParent"></span><span class="sig-name descname"><span class="pre">CalcRpyDtFromAngularVelocityInParent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RollPitchYaw_" title="pydrake.math.RollPitchYaw_"><span class="pre">pydrake.math.RollPitchYaw_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_AD_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw_-AutoDiffXd-.CalcRpyDtFromAngularVelocityInParent" title="Permalink to this definition"></a></dt>
<dd><p>Uses angular velocity to compute the 1ˢᵗ time-derivative of <code class="docutils literal notranslate"><span class="pre">this</span></code>
RollPitchYaw whose angles <code class="docutils literal notranslate"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code> orient two generic frames A
and D.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">w_AD_A</span></code>:</dt><dd><p>frame D’s angular velocity in frame A, expressed in A.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">[ṙ;</span> <span class="pre">ṗ;</span> <span class="pre">ẏ]</span></code>, the 1ˢᵗ time-derivative of <code class="docutils literal notranslate"><span class="pre">this</span></code>
RollPitchYaw.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>RuntimeError if cos</strong><strong>(</strong><strong>p</strong><strong>) </strong><strong>≈ 0</strong><strong> (</strong><strong>p is near gimbal-lock</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Enhanced documentation for this method and its gimbal-lock
(divide- by-zero error) is in
CalcMatrixRelatingRpyDtToAngularVelocityInParent().</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcRpyDtFromAngularVelocityInChild()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw_-AutoDiffXd-.pitch_angle">
<span id="pydrake.math.RollPitchYaw_[AutoDiffXd].pitch_angle"></span><span class="sig-name descname"><span class="pre">pitch_angle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RollPitchYaw_" title="pydrake.math.RollPitchYaw_"><span class="pre">pydrake.math.RollPitchYaw_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw_-AutoDiffXd-.pitch_angle" title="Permalink to this definition"></a></dt>
<dd><p>Returns the pitch-angle underlying <code class="docutils literal notranslate"><span class="pre">this</span></code> RollPitchYaw.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw_-AutoDiffXd-.roll_angle">
<span id="pydrake.math.RollPitchYaw_[AutoDiffXd].roll_angle"></span><span class="sig-name descname"><span class="pre">roll_angle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RollPitchYaw_" title="pydrake.math.RollPitchYaw_"><span class="pre">pydrake.math.RollPitchYaw_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw_-AutoDiffXd-.roll_angle" title="Permalink to this definition"></a></dt>
<dd><p>Returns the roll-angle underlying <code class="docutils literal notranslate"><span class="pre">this</span></code> RollPitchYaw.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw_-AutoDiffXd-.ToQuaternion">
<span id="pydrake.math.RollPitchYaw_[AutoDiffXd].ToQuaternion"></span><span class="sig-name descname"><span class="pre">ToQuaternion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RollPitchYaw_" title="pydrake.math.RollPitchYaw_"><span class="pre">pydrake.math.RollPitchYaw_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.common.eigen_geometry.html#pydrake.common.eigen_geometry.Quaternion_" title="pydrake.common.eigen_geometry.Quaternion_"><span class="pre">pydrake.common.eigen_geometry.Quaternion_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw_-AutoDiffXd-.ToQuaternion" title="Permalink to this definition"></a></dt>
<dd><p>Returns a quaternion representation of <code class="docutils literal notranslate"><span class="pre">this</span></code> RollPitchYaw.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw_-AutoDiffXd-.ToRotationMatrix">
<span id="pydrake.math.RollPitchYaw_[AutoDiffXd].ToRotationMatrix"></span><span class="sig-name descname"><span class="pre">ToRotationMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RollPitchYaw_" title="pydrake.math.RollPitchYaw_"><span class="pre">pydrake.math.RollPitchYaw_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw_-AutoDiffXd-.ToRotationMatrix" title="Permalink to this definition"></a></dt>
<dd><p>Returns the RotationMatrix representation of <code class="docutils literal notranslate"><span class="pre">this</span></code> RollPitchYaw.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw_-AutoDiffXd-.vector">
<span id="pydrake.math.RollPitchYaw_[AutoDiffXd].vector"></span><span class="sig-name descname"><span class="pre">vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RollPitchYaw_" title="pydrake.math.RollPitchYaw_"><span class="pre">pydrake.math.RollPitchYaw_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw_-AutoDiffXd-.vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns the Vector3 underlying <code class="docutils literal notranslate"><span class="pre">this</span></code> RollPitchYaw.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw_-AutoDiffXd-.yaw_angle">
<span id="pydrake.math.RollPitchYaw_[AutoDiffXd].yaw_angle"></span><span class="sig-name descname"><span class="pre">yaw_angle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RollPitchYaw_" title="pydrake.math.RollPitchYaw_"><span class="pre">pydrake.math.RollPitchYaw_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw_-AutoDiffXd-.yaw_angle" title="Permalink to this definition"></a></dt>
<dd><p>Returns the yaw-angle underlying <code class="docutils literal notranslate"><span class="pre">this</span></code> RollPitchYaw.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw_-Expression">
<span id="pydrake.math.RollPitchYaw_[Expression]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">RollPitchYaw_[Expression]</span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw_-Expression" title="Permalink to this definition"></a></dt>
<dd><p>This class represents the orientation between two arbitrary frames A
and D associated with a Space-fixed (extrinsic) X-Y-Z rotation by
“roll-pitch-yaw” angles <code class="docutils literal notranslate"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code>, which is equivalent to a
Body-fixed (intrinsic) Z-Y-X rotation by “yaw-pitch-roll” angles <code class="docutils literal notranslate"><span class="pre">[y,</span>
<span class="pre">p,</span> <span class="pre">r]</span></code>. The rotation matrix <code class="docutils literal notranslate"><span class="pre">R_AD</span></code> associated with this
roll-pitch-yaw <code class="docutils literal notranslate"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code> rotation sequence is equal to the matrix
multiplication shown below.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>⎡cos(y) -sin(y)  0⎤   ⎡ cos(p)  0  sin(p)⎤   ⎡1      0        0 ⎤
R_AD = ⎢sin(y)  cos(y)  0⎥ * ⎢     0   1      0 ⎥ * ⎢0  cos(r)  -sin(r)⎥
       ⎣    0       0   1⎦   ⎣-sin(p)  0  cos(p)⎦   ⎣0  sin(r)   cos(r)⎦
     =       R_AB          *        R_BC          *        R_CD
</pre></div>
</div>
</details><div class="admonition note">
<p class="admonition-title">Note</p>
<p>In this discussion, A is the Space frame and D is the Body frame.
One way to visualize this rotation sequence is by introducing
intermediate frames B and C (useful constructs to understand this
rotation sequence). Initially, the frames are aligned so <code class="docutils literal notranslate"><span class="pre">Di</span> <span class="pre">=</span> <span class="pre">Ci</span>
<span class="pre">=</span> <span class="pre">Bi</span> <span class="pre">=</span> <span class="pre">Ai</span> <span class="pre">(i</span> <span class="pre">=</span> <span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code> where Dx, Dy, Dz and Ax, Ay, Az are
orthogonal unit vectors fixed in frames D and A respectively.
Similarly for Bx, By, Bz and Cx, Cy, Cz in frame B, C. Then D is
subjected to successive right-handed rotations relative to A.</p>
</div>
<ul class="simple">
<li><p>1st rotation R_CD: Frame D rotates relative to frames C, B, A by a</p></li>
</ul>
<p>roll angle <code class="docutils literal notranslate"><span class="pre">r</span></code> about <code class="docutils literal notranslate"><span class="pre">Dx</span> <span class="pre">=</span> <span class="pre">Cx</span></code>.  Note: D and C are no longer aligned.</p>
<ul class="simple">
<li><p>2nd rotation R_BC: Frames D, C (collectively – as if welded together)</p></li>
</ul>
<p>rotate relative to frame B, A by a pitch angle <code class="docutils literal notranslate"><span class="pre">p</span></code> about <code class="docutils literal notranslate"><span class="pre">Cy</span> <span class="pre">=</span> <span class="pre">By</span></code>.
Note: C and B are no longer aligned.</p>
<ul class="simple">
<li><p>3rd rotation R_AB: Frames D, C, B (collectively – as if welded)</p></li>
</ul>
<p>rotate relative to frame A by a yaw angle <code class="docutils literal notranslate"><span class="pre">y</span></code> about <code class="docutils literal notranslate"><span class="pre">Bz</span> <span class="pre">=</span> <span class="pre">Az</span></code>.
Note: B and A are no longer aligned.
The monogram notation for the rotation matrix relating A to D is <code class="docutils literal notranslate"><span class="pre">R_AD</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>multibody_quantities for monogram notation for dynamics and
orientation_discussion “a discussion on rotation matrices”.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class does not store the frames associated with this rotation
sequence.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw_-Expression-.__init__">
<span id="pydrake.math.RollPitchYaw_[Expression].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.RollPitchYaw_-Expression-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.math.RollPitchYaw_[Expression], other: pydrake.math.RollPitchYaw_[Expression]) -&gt; None</p></li>
<li><p>__init__(self: pydrake.math.RollPitchYaw_[Expression], rpy: numpy.ndarray[object[3, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs a RollPitchYaw from a 3x1 array of angles.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rpy</span></code>:</dt><dd><p>3x1 array with roll, pitch, yaw angles (units of radians).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError in debug builds if !IsValid</strong><strong>(</strong><strong>rpy</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.math.RollPitchYaw_[Expression], roll: pydrake.symbolic.Expression, pitch: pydrake.symbolic.Expression, yaw: pydrake.symbolic.Expression) -&gt; None</p></li>
</ol>
<p>Constructs a RollPitchYaw from roll, pitch, yaw angles (radian units).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">roll</span></code>:</dt><dd><p>x-directed angle in SpaceXYZ rotation sequence.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pitch</span></code>:</dt><dd><p>y-directed angle in SpaceXYZ rotation sequence.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">yaw</span></code>:</dt><dd><p>z-directed angle in SpaceXYZ rotation sequence.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError in debug builds if !IsValid</strong><strong>(</strong><strong>Vector3&lt;T&gt;</strong><strong>(</strong><strong>roll</strong><strong>, </strong><strong>pitch</strong><strong>,</strong> – </p></li>
<li><p><strong>yaw</strong><strong>)</strong><strong>)</strong><strong></strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.math.RollPitchYaw_[Expression], R: pydrake.math.RotationMatrix_[Expression]) -&gt; None</p></li>
</ol>
<p>Uses a RotationMatrix to construct a RollPitchYaw with roll-pitch-yaw
angles <code class="docutils literal notranslate"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code> in the range <code class="docutils literal notranslate"><span class="pre">-π</span> <span class="pre">&lt;=</span> <span class="pre">r</span> <span class="pre">&lt;=</span> <span class="pre">π</span></code>, <cite>-π/2 &lt;= p &lt;=
π/2</cite>, <code class="docutils literal notranslate"><span class="pre">-π</span> <span class="pre">&lt;=</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">π</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R</span></code>:</dt><dd><p>a RotationMatrix.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This new high-accuracy algorithm avoids numerical round-off issues
encountered by some algorithms when pitch is within 1E-6 of π/2 or
-π/2.</p>
</div>
<ol class="arabic simple" start="5">
<li><p>__init__(self: pydrake.math.RollPitchYaw_[Expression], quaternion: pydrake.common.eigen_geometry.Quaternion_[Expression]) -&gt; None</p></li>
</ol>
<p>Uses a Quaternion to construct a RollPitchYaw with roll-pitch-yaw
angles <code class="docutils literal notranslate"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code> in the range <code class="docutils literal notranslate"><span class="pre">-π</span> <span class="pre">&lt;=</span> <span class="pre">r</span> <span class="pre">&lt;=</span> <span class="pre">π</span></code>, <cite>-π/2 &lt;= p &lt;=
π/2</cite>, <code class="docutils literal notranslate"><span class="pre">-π</span> <span class="pre">&lt;=</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">π</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quaternion</span></code>:</dt><dd><p>unit Quaternion.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This new high-accuracy algorithm avoids numerical round-off issues
encountered by some algorithms when pitch is within 1E-6 of π/2 or
-π/2.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError in debug builds if !IsValid</strong><strong>(</strong><strong>rpy</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="6">
<li><p>__init__(self: pydrake.math.RollPitchYaw_[Expression], matrix: numpy.ndarray[object[3, 3]]) -&gt; None</p></li>
</ol>
<p>Construct from raw rotation matrix. See RotationMatrix overload for more information.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw_-Expression-.CalcAngularVelocityInChildFromRpyDt">
<span id="pydrake.math.RollPitchYaw_[Expression].CalcAngularVelocityInChildFromRpyDt"></span><span class="sig-name descname"><span class="pre">CalcAngularVelocityInChildFromRpyDt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RollPitchYaw_" title="pydrake.math.RollPitchYaw_"><span class="pre">pydrake.math.RollPitchYaw_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rpyDt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw_-Expression-.CalcAngularVelocityInChildFromRpyDt" title="Permalink to this definition"></a></dt>
<dd><p>Calculates angular velocity from <code class="docutils literal notranslate"><span class="pre">this</span></code> RollPitchYaw whose
roll-pitch-yaw angles <code class="docutils literal notranslate"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code> relate the orientation of two
generic frames A and D.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rpyDt</span></code>:</dt><dd><p>Time-derivative of <code class="docutils literal notranslate"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code>, i.e., <code class="docutils literal notranslate"><span class="pre">[ṙ;</span> <span class="pre">ṗ;</span> <span class="pre">ẏ]</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>w_AD_D, frame D’s angular velocity in frame A, expressed in
“child” frame D. In other words, returns [ω0; ω1; ω2]ᴅ, where
<code class="docutils literal notranslate"><span class="pre">w_AD_D</span> <span class="pre">=</span> <span class="pre">ω0</span> <span class="pre">Dx</span> <span class="pre">+</span> <span class="pre">ω1</span> <span class="pre">Dy</span> <span class="pre">+</span> <span class="pre">ω2</span> <span class="pre">Dz</span></code>, and where [ω0; ω1; ω2]ᴅ is
calculated via the 3x3 matrix Nc⁻¹ (the inverse of the matrix Nc
documented in CalcMatrixRelatingRpyDtToAngularVelocityInChild()).</p>
</dd>
</dl>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>⌈ ω0 ⌉         ⌈ ṙ ⌉            ⌈ 1      0        -sin(p)    ⌉
| ω1 |  = Nc⁻¹ | ṗ |     Nc⁻¹ = | 0   cos(r)   sin(r)*cos(p) |
⌊ ω2 ⌋ᴅ        ⌊ ẏ ⌋            ⌊ 0  -sin(r)   cos(r)*cos(p) ⌋
</pre></div>
</div>
</details></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw_-Expression-.CalcAngularVelocityInParentFromRpyDt">
<span id="pydrake.math.RollPitchYaw_[Expression].CalcAngularVelocityInParentFromRpyDt"></span><span class="sig-name descname"><span class="pre">CalcAngularVelocityInParentFromRpyDt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RollPitchYaw_" title="pydrake.math.RollPitchYaw_"><span class="pre">pydrake.math.RollPitchYaw_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rpyDt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw_-Expression-.CalcAngularVelocityInParentFromRpyDt" title="Permalink to this definition"></a></dt>
<dd><p>Calculates angular velocity from <code class="docutils literal notranslate"><span class="pre">this</span></code> RollPitchYaw whose
roll-pitch-yaw angles <code class="docutils literal notranslate"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code> relate the orientation of two
generic frames A and D.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rpyDt</span></code>:</dt><dd><p>Time-derivative of <code class="docutils literal notranslate"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code>, i.e., <code class="docutils literal notranslate"><span class="pre">[ṙ;</span> <span class="pre">ṗ;</span> <span class="pre">ẏ]</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>w_AD_A, frame D’s angular velocity in frame A, expressed in
“parent” frame A. In other words, returns [ωx; ωy; ωz]ᴀ, where
<code class="docutils literal notranslate"><span class="pre">w_AD_A</span> <span class="pre">=</span> <span class="pre">ωx</span> <span class="pre">Ax</span> <span class="pre">+</span> <span class="pre">ωy</span> <span class="pre">Ay</span> <span class="pre">+</span> <span class="pre">ωz</span> <span class="pre">Az</span></code>, and where [ωx; ωy; ωz]ᴀ is
calculated via the the 3x3 matrix Np⁻¹ (the inverse of the matrix
Np documented in
CalcMatrixRelatingRpyDtToAngularVelocityInParent()).</p>
</dd>
</dl>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>⌈ ωx ⌉         ⌈ ṙ ⌉            ⌈ cos(y)*cos(p)  -sin(y)  0 ⌉
| ωy |  = Np⁻¹ | ṗ |     Np⁻¹ = | sin(y)*cos(p)   cos(y)  0 |
⌊ ωz ⌋ᴀ        ⌊ ẏ ⌋            ⌊   -sin(p)         0     1 ⌋
</pre></div>
</div>
</details></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw_-Expression-.CalcRotationMatrixDt">
<span id="pydrake.math.RollPitchYaw_[Expression].CalcRotationMatrixDt"></span><span class="sig-name descname"><span class="pre">CalcRotationMatrixDt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RollPitchYaw_" title="pydrake.math.RollPitchYaw_"><span class="pre">pydrake.math.RollPitchYaw_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rpyDt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw_-Expression-.CalcRotationMatrixDt" title="Permalink to this definition"></a></dt>
<dd><p>Forms Ṙ, the ordinary derivative of the RotationMatrix <code class="docutils literal notranslate"><span class="pre">R</span></code> with
respect to an independent variable <code class="docutils literal notranslate"><span class="pre">t</span></code> (<cite>t</cite> usually denotes time)
and <code class="docutils literal notranslate"><span class="pre">R</span></code> is the RotationMatrix formed by <code class="docutils literal notranslate"><span class="pre">this</span></code> RollPitchYaw. The
roll-pitch-yaw angles r, p, y are regarded as functions of <code class="docutils literal notranslate"><span class="pre">t</span></code>
[i.e., r(t), p(t), y(t)].</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rpyDt</span></code>:</dt><dd><p>Ordinary derivative of rpy with respect to an independent variable
<code class="docutils literal notranslate"><span class="pre">t</span></code> (<cite>t</cite> usually denotes time, but not necessarily).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Ṙ, the ordinary derivative of <code class="docutils literal notranslate"><span class="pre">R</span></code> with respect to <code class="docutils literal notranslate"><span class="pre">t</span></code>,
calculated as Ṙ = ∂R/∂r * ṙ + ∂R/∂p * ṗ + ∂R/∂y * ẏ. In other
words, the returned (i, j) element is ∂Rij/∂r * ṙ + ∂Rij/∂p * ṗ
+ ∂Rij/∂y * ẏ.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw_-Expression-.CalcRpyDDtFromAngularAccelInChild">
<span id="pydrake.math.RollPitchYaw_[Expression].CalcRpyDDtFromAngularAccelInChild"></span><span class="sig-name descname"><span class="pre">CalcRpyDDtFromAngularAccelInChild</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RollPitchYaw_" title="pydrake.math.RollPitchYaw_"><span class="pre">pydrake.math.RollPitchYaw_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rpyDt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha_AD_D</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw_-Expression-.CalcRpyDDtFromAngularAccelInChild" title="Permalink to this definition"></a></dt>
<dd><p>Uses angular acceleration to compute the 2ⁿᵈ time-derivative of
<code class="docutils literal notranslate"><span class="pre">this</span></code> RollPitchYaw whose angles <code class="docutils literal notranslate"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code> orient two generic
frames A and D.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rpyDt</span></code>:</dt><dd><p>time-derivative of <code class="docutils literal notranslate"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code>, i.e., <code class="docutils literal notranslate"><span class="pre">[ṙ;</span> <span class="pre">ṗ;</span> <span class="pre">ẏ]</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">alpha_AD_D</span></code>:</dt><dd><p>frame D’s angular acceleration in frame A, expressed in frame D.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">[r̈,</span> <span class="pre">p̈,</span> <span class="pre">ÿ]</span></code>, the 2ⁿᵈ time-derivative of <code class="docutils literal notranslate"><span class="pre">this</span></code>
RollPitchYaw.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>RuntimeError if cos</strong><strong>(</strong><strong>p</strong><strong>) </strong><strong>≈ 0</strong><strong> (</strong><strong>p is near gimbal-lock</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method has a divide-by-zero error (singularity) when the
cosine of the pitch angle <code class="docutils literal notranslate"><span class="pre">p</span></code> is zero [i.e., <code class="docutils literal notranslate"><span class="pre">cos(p)</span> <span class="pre">=</span> <span class="pre">0`].</span>
<span class="pre">This</span> <span class="pre">problem</span> <span class="pre">(called</span> <span class="pre">&quot;gimbal</span> <span class="pre">lock&quot;)</span> <span class="pre">occurs</span> <span class="pre">when</span> <span class="pre">`p</span> <span class="pre">=</span> <span class="pre">n</span> <span class="pre">π</span> <span class="pre">+</span> <span class="pre">π</span> <span class="pre">/</span>
<span class="pre">2</span></code>, where n is any integer. There are associated precision
problems (inaccuracies) in the neighborhood of these pitch angles,
i.e., when <code class="docutils literal notranslate"><span class="pre">cos(p)</span> <span class="pre">≈</span> <span class="pre">0</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw_-Expression-.CalcRpyDDtFromRpyDtAndAngularAccelInParent">
<span id="pydrake.math.RollPitchYaw_[Expression].CalcRpyDDtFromRpyDtAndAngularAccelInParent"></span><span class="sig-name descname"><span class="pre">CalcRpyDDtFromRpyDtAndAngularAccelInParent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RollPitchYaw_" title="pydrake.math.RollPitchYaw_"><span class="pre">pydrake.math.RollPitchYaw_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rpyDt</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha_AD_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw_-Expression-.CalcRpyDDtFromRpyDtAndAngularAccelInParent" title="Permalink to this definition"></a></dt>
<dd><p>Uses angular acceleration to compute the 2ⁿᵈ time-derivative of
<code class="docutils literal notranslate"><span class="pre">this</span></code> RollPitchYaw whose angles <code class="docutils literal notranslate"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code> orient two generic
frames A and D.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rpyDt</span></code>:</dt><dd><p>time-derivative of <code class="docutils literal notranslate"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code>, i.e., <code class="docutils literal notranslate"><span class="pre">[ṙ;</span> <span class="pre">ṗ;</span> <span class="pre">ẏ]</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">alpha_AD_A</span></code>:</dt><dd><p>frame D’s angular acceleration in frame A, expressed in frame A.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">[r̈,</span> <span class="pre">p̈,</span> <span class="pre">ÿ]</span></code>, the 2ⁿᵈ time-derivative of <code class="docutils literal notranslate"><span class="pre">this</span></code>
RollPitchYaw.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>RuntimeError if cos</strong><strong>(</strong><strong>p</strong><strong>) </strong><strong>≈ 0</strong><strong> (</strong><strong>p is near gimbal-lock</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method has a divide-by-zero error (singularity) when the
cosine of the pitch angle <code class="docutils literal notranslate"><span class="pre">p</span></code> is zero [i.e., <code class="docutils literal notranslate"><span class="pre">cos(p)</span> <span class="pre">=</span> <span class="pre">0`].</span>
<span class="pre">This</span> <span class="pre">problem</span> <span class="pre">(called</span> <span class="pre">&quot;gimbal</span> <span class="pre">lock&quot;)</span> <span class="pre">occurs</span> <span class="pre">when</span> <span class="pre">`p</span> <span class="pre">=</span> <span class="pre">n</span> <span class="pre">π</span> <span class="pre">+</span> <span class="pre">π</span> <span class="pre">/</span>
<span class="pre">2</span></code>, where n is any integer. There are associated precision
problems (inaccuracies) in the neighborhood of these pitch angles,
i.e., when <code class="docutils literal notranslate"><span class="pre">cos(p)</span> <span class="pre">≈</span> <span class="pre">0</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw_-Expression-.CalcRpyDtFromAngularVelocityInChild">
<span id="pydrake.math.RollPitchYaw_[Expression].CalcRpyDtFromAngularVelocityInChild"></span><span class="sig-name descname"><span class="pre">CalcRpyDtFromAngularVelocityInChild</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RollPitchYaw_" title="pydrake.math.RollPitchYaw_"><span class="pre">pydrake.math.RollPitchYaw_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_AD_D</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw_-Expression-.CalcRpyDtFromAngularVelocityInChild" title="Permalink to this definition"></a></dt>
<dd><p>Uses angular velocity to compute the 1ˢᵗ time-derivative of <code class="docutils literal notranslate"><span class="pre">this</span></code>
RollPitchYaw whose angles <code class="docutils literal notranslate"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code> orient two generic frames A
and D.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">w_AD_D</span></code>:</dt><dd><p>frame D’s angular velocity in frame A, expressed in D.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">[ṙ;</span> <span class="pre">ṗ;</span> <span class="pre">ẏ]</span></code>, the 1ˢᵗ time-derivative of <code class="docutils literal notranslate"><span class="pre">this</span></code>
RollPitchYaw.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>RuntimeError if cos</strong><strong>(</strong><strong>p</strong><strong>) </strong><strong>≈ 0</strong><strong> (</strong><strong>p is near gimbal-lock</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Enhanced documentation for this method and its gimbal-lock
(divide- by-zero error) is in
CalcMatrixRelatingRpyDtToAngularVelocityInChild().</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcRpyDtFromAngularVelocityInParent()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw_-Expression-.CalcRpyDtFromAngularVelocityInParent">
<span id="pydrake.math.RollPitchYaw_[Expression].CalcRpyDtFromAngularVelocityInParent"></span><span class="sig-name descname"><span class="pre">CalcRpyDtFromAngularVelocityInParent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RollPitchYaw_" title="pydrake.math.RollPitchYaw_"><span class="pre">pydrake.math.RollPitchYaw_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w_AD_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw_-Expression-.CalcRpyDtFromAngularVelocityInParent" title="Permalink to this definition"></a></dt>
<dd><p>Uses angular velocity to compute the 1ˢᵗ time-derivative of <code class="docutils literal notranslate"><span class="pre">this</span></code>
RollPitchYaw whose angles <code class="docutils literal notranslate"><span class="pre">[r;</span> <span class="pre">p;</span> <span class="pre">y]</span></code> orient two generic frames A
and D.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">w_AD_A</span></code>:</dt><dd><p>frame D’s angular velocity in frame A, expressed in A.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">[ṙ;</span> <span class="pre">ṗ;</span> <span class="pre">ẏ]</span></code>, the 1ˢᵗ time-derivative of <code class="docutils literal notranslate"><span class="pre">this</span></code>
RollPitchYaw.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>RuntimeError if cos</strong><strong>(</strong><strong>p</strong><strong>) </strong><strong>≈ 0</strong><strong> (</strong><strong>p is near gimbal-lock</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Enhanced documentation for this method and its gimbal-lock
(divide- by-zero error) is in
CalcMatrixRelatingRpyDtToAngularVelocityInParent().</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcRpyDtFromAngularVelocityInChild()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw_-Expression-.pitch_angle">
<span id="pydrake.math.RollPitchYaw_[Expression].pitch_angle"></span><span class="sig-name descname"><span class="pre">pitch_angle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RollPitchYaw_" title="pydrake.math.RollPitchYaw_"><span class="pre">pydrake.math.RollPitchYaw_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw_-Expression-.pitch_angle" title="Permalink to this definition"></a></dt>
<dd><p>Returns the pitch-angle underlying <code class="docutils literal notranslate"><span class="pre">this</span></code> RollPitchYaw.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw_-Expression-.roll_angle">
<span id="pydrake.math.RollPitchYaw_[Expression].roll_angle"></span><span class="sig-name descname"><span class="pre">roll_angle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RollPitchYaw_" title="pydrake.math.RollPitchYaw_"><span class="pre">pydrake.math.RollPitchYaw_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw_-Expression-.roll_angle" title="Permalink to this definition"></a></dt>
<dd><p>Returns the roll-angle underlying <code class="docutils literal notranslate"><span class="pre">this</span></code> RollPitchYaw.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw_-Expression-.ToQuaternion">
<span id="pydrake.math.RollPitchYaw_[Expression].ToQuaternion"></span><span class="sig-name descname"><span class="pre">ToQuaternion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RollPitchYaw_" title="pydrake.math.RollPitchYaw_"><span class="pre">pydrake.math.RollPitchYaw_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.common.eigen_geometry.html#pydrake.common.eigen_geometry.Quaternion_" title="pydrake.common.eigen_geometry.Quaternion_"><span class="pre">pydrake.common.eigen_geometry.Quaternion_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw_-Expression-.ToQuaternion" title="Permalink to this definition"></a></dt>
<dd><p>Returns a quaternion representation of <code class="docutils literal notranslate"><span class="pre">this</span></code> RollPitchYaw.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw_-Expression-.ToRotationMatrix">
<span id="pydrake.math.RollPitchYaw_[Expression].ToRotationMatrix"></span><span class="sig-name descname"><span class="pre">ToRotationMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RollPitchYaw_" title="pydrake.math.RollPitchYaw_"><span class="pre">pydrake.math.RollPitchYaw_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw_-Expression-.ToRotationMatrix" title="Permalink to this definition"></a></dt>
<dd><p>Returns the RotationMatrix representation of <code class="docutils literal notranslate"><span class="pre">this</span></code> RollPitchYaw.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw_-Expression-.vector">
<span id="pydrake.math.RollPitchYaw_[Expression].vector"></span><span class="sig-name descname"><span class="pre">vector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RollPitchYaw_" title="pydrake.math.RollPitchYaw_"><span class="pre">pydrake.math.RollPitchYaw_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw_-Expression-.vector" title="Permalink to this definition"></a></dt>
<dd><p>Returns the Vector3 underlying <code class="docutils literal notranslate"><span class="pre">this</span></code> RollPitchYaw.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RollPitchYaw_-Expression-.yaw_angle">
<span id="pydrake.math.RollPitchYaw_[Expression].yaw_angle"></span><span class="sig-name descname"><span class="pre">yaw_angle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RollPitchYaw_" title="pydrake.math.RollPitchYaw_"><span class="pre">pydrake.math.RollPitchYaw_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></span><a class="headerlink" href="#pydrake.math.RollPitchYaw_-Expression-.yaw_angle" title="Permalink to this definition"></a></dt>
<dd><p>Returns the yaw-angle underlying <code class="docutils literal notranslate"><span class="pre">this</span></code> RollPitchYaw.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">RotationMatrix</span></span><a class="headerlink" href="#pydrake.math.RotationMatrix" title="Permalink to this definition"></a></dt>
<dd><p>This class represents a 3x3 rotation matrix between two arbitrary
frames A and B and helps ensure users create valid rotation matrices.
This class relates right-handed orthogonal unit vectors Ax, Ay, Az
fixed in frame A to right-handed orthogonal unit vectors Bx, By, Bz
fixed in frame B. The monogram notation for the rotation matrix
relating A to B is <code class="docutils literal notranslate"><span class="pre">R_AB</span></code>. An example that gives context to this
rotation matrix is <code class="docutils literal notranslate"><span class="pre">v_A</span> <span class="pre">=</span> <span class="pre">R_AB</span> <span class="pre">*</span> <span class="pre">v_B</span></code>, where <code class="docutils literal notranslate"><span class="pre">v_B</span></code> denotes an
arbitrary vector v expressed in terms of Bx, By, Bz and <code class="docutils literal notranslate"><span class="pre">v_A</span></code>
denotes vector v expressed in terms of Ax, Ay, Az. See
multibody_quantities for monogram notation for dynamics. See
orientation_discussion “a discussion on rotation matrices”.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class does not store the frames associated with a rotation
matrix nor does it enforce strict proper usage of this class with
vectors.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When assertions are enabled, several methods in this class perform
a validity check and throw RuntimeError if the rotation matrix is
invalid. When assertions are disabled, many of these validity
checks are skipped (which helps improve speed). These validity
tests are only performed for scalar types for which
drake::scalar_predicate&lt;T&gt;::is_bool is <code class="docutils literal notranslate"><span class="pre">True</span></code>. For instance,
validity checks are not performed when T is symbolic::Expression.</p>
</div>
<dl class="simple">
<dt>Authors:</dt><dd><p>Paul Mitiguy (2018) Original author.</p>
</dd>
<dt>Authors:</dt><dd><p>Drake team (see <a class="reference external" href="https://drake.mit.edu/credits">https://drake.mit.edu/credits</a>).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotationMatrix_</span></code></a>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.RotationMatrix.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.math.RotationMatrix) -&gt; None</p></li>
</ol>
<p>Constructs a 3x3 identity RotationMatrix – which corresponds to
aligning two frames (so that unit vectors Ax = Bx, Ay = By, Az = Bz).</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.math.RotationMatrix, other: pydrake.math.RotationMatrix) -&gt; None</p></li>
<li><p>__init__(self: pydrake.math.RotationMatrix, R: numpy.ndarray[numpy.float64[3, 3]]) -&gt; None</p></li>
</ol>
<p>Constructs a RotationMatrix from a Matrix3.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R</span></code>:</dt><dd><p>an allegedly valid rotation matrix.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError in debug builds if R fails IsValid</strong><strong>(</strong><strong>R</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.math.RotationMatrix, quaternion: pydrake.common.eigen_geometry.Quaternion) -&gt; None</p></li>
</ol>
<p>Constructs a RotationMatrix from an Eigen::Quaternion.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quaternion</span></code>:</dt><dd><p>a non-zero, finite quaternion which may or may not have unit
length [i.e., <code class="docutils literal notranslate"><span class="pre">quaternion.norm()</span></code> does not have to be 1].</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError in debug builds if the rotation matrix R that is</strong> – </p></li>
<li><p><strong>built from quaternion fails IsValid</strong><strong>(</strong><strong>R</strong><strong>)</strong><strong> For example</strong><strong>, </strong><strong>an</strong> – </p></li>
<li><p><strong>exception is thrown if quaternion is zero</strong><strong> or </strong><strong>contains a NaN or</strong> – </p></li>
<li><p><strong>infinity.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method has the effect of normalizing its <code class="docutils literal notranslate"><span class="pre">quaternion</span></code>
argument, without the inefficiency of the square-root associated
with normalization.</p>
</div>
<ol class="arabic simple" start="5">
<li><p>__init__(self: pydrake.math.RotationMatrix, theta_lambda: pydrake.common.eigen_geometry.AngleAxis) -&gt; None</p></li>
</ol>
<p>Constructs a RotationMatrix from an Eigen::AngleAxis.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta_lambda</span></code>:</dt><dd><p>an Eigen::AngleAxis whose associated axis (vector direction herein
called <code class="docutils literal notranslate"><span class="pre">lambda</span></code>) is non-zero and finite, but which may or may
not have unit length [i.e., <code class="docutils literal notranslate"><span class="pre">lambda.norm()</span></code> does not have to be
1].</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError in debug builds if the rotation matrix R that is</strong> – </p></li>
<li><p><strong>built from theta_lambda fails IsValid</strong><strong>(</strong><strong>R</strong><strong>)</strong><strong> For example</strong><strong>, </strong><strong>an</strong> – </p></li>
<li><p><strong>exception is thrown if lambda is zero</strong><strong> or </strong><strong>contains a NaN or</strong> – </p></li>
<li><p><strong>infinity.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="6">
<li><p>__init__(self: pydrake.math.RotationMatrix, rpy: pydrake.math.RollPitchYaw) -&gt; None</p></li>
</ol>
<p>Constructs a RotationMatrix from an RollPitchYaw. In other words,
makes the RotationMatrix for a Space-fixed (extrinsic) X-Y-Z rotation
by “roll-pitch-yaw” angles <code class="docutils literal notranslate"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code>, which is equivalent to a
Body-fixed (intrinsic) Z-Y-X rotation by “yaw-pitch-roll” angles <code class="docutils literal notranslate"><span class="pre">[y,</span>
<span class="pre">p,</span> <span class="pre">r]</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rpy</span></code>:</dt><dd><p>a RollPitchYaw which is a Space-fixed (extrinsic) X-Y-Z rotation
with “roll-pitch-yaw” angles <code class="docutils literal notranslate"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code> or equivalently a Body-
fixed (intrinsic) Z-Y-X rotation with “yaw-pitch-roll” angles
<code class="docutils literal notranslate"><span class="pre">[y,</span> <span class="pre">p,</span> <span class="pre">r]</span></code>.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">R_AD</span></code>:</dt><dd><p>, rotation matrix relating frame A to frame D.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Denoting roll <code class="docutils literal notranslate"><span class="pre">r</span></code>, pitch <code class="docutils literal notranslate"><span class="pre">p</span></code>, yaw <code class="docutils literal notranslate"><span class="pre">y</span></code>, this method returns a
rotation matrix <code class="docutils literal notranslate"><span class="pre">R_AD</span></code> equal to the matrix multiplication shown
below.</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>⎡cos(y) -sin(y)  0⎤   ⎡ cos(p)  0  sin(p)⎤   ⎡1      0        0 ⎤
R_AD = ⎢sin(y)  cos(y)  0⎥ * ⎢     0   1      0 ⎥ * ⎢0  cos(r)  -sin(r)⎥
       ⎣    0       0   1⎦   ⎣-sin(p)  0  cos(p)⎦   ⎣0  sin(r)   cos(r)⎦
     =       R_AB          *        R_BC          *        R_CD
</pre></div>
</div>
</details><div class="admonition note">
<p class="admonition-title">Note</p>
<p>In this discussion, A is the Space frame and D is the Body frame.
One way to visualize this rotation sequence is by introducing
intermediate frames B and C (useful constructs to understand this
rotation sequence). Initially, the frames are aligned so <code class="docutils literal notranslate"><span class="pre">Di</span> <span class="pre">=</span> <span class="pre">Ci</span>
<span class="pre">=</span> <span class="pre">Bi</span> <span class="pre">=</span> <span class="pre">Ai</span> <span class="pre">(i</span> <span class="pre">=</span> <span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code>. Then D is subjected to successive
right-handed rotations relative to A.</p>
</div>
<ul class="simple">
<li><p>1st rotation R_CD: Frame D rotates relative to frames C, B, A by a</p></li>
</ul>
<p>roll angle <code class="docutils literal notranslate"><span class="pre">r</span></code> about <code class="docutils literal notranslate"><span class="pre">Dx</span> <span class="pre">=</span> <span class="pre">Cx</span></code>.  Note: D and C are no longer aligned.</p>
<ul class="simple">
<li><p>2nd rotation R_BC: Frames D, C (collectively – as if welded together)</p></li>
</ul>
<p>rotate relative to frame B, A by a pitch angle <code class="docutils literal notranslate"><span class="pre">p</span></code> about <code class="docutils literal notranslate"><span class="pre">Cy</span> <span class="pre">=</span> <span class="pre">By</span></code>.
Note: C and B are no longer aligned.</p>
<ul class="simple">
<li><p>3rd rotation R_AB: Frames D, C, B (collectively – as if welded)</p></li>
</ul>
<p>rotate relative to frame A by a roll angle <code class="docutils literal notranslate"><span class="pre">y</span></code> about <code class="docutils literal notranslate"><span class="pre">Bz</span> <span class="pre">=</span> <span class="pre">Az</span></code>.
Note: B and A are no longer aligned.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method constructs a RotationMatrix from a RollPitchYaw.
Vice-versa, there are high-accuracy RollPitchYaw
constructor/methods that form a RollPitchYaw from a rotation
matrix.</p>
</div>
</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix.cast">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">cast</span></span><a class="headerlink" href="#pydrake.math.RotationMatrix.cast" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">cast[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">cast[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">cast[Expression]</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix.cast-AutoDiffXd">
<span id="pydrake.math.RotationMatrix.cast[AutoDiffXd]"></span><span class="sig-name descname"><span class="pre">cast[AutoDiffXd]</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix" title="pydrake.math.RotationMatrix"><span class="pre">pydrake.math.RotationMatrix</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix.cast-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><p>Creates a RotationMatrix templatized on a scalar type U from a
RotationMatrix templatized on scalar type T. For example,</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">Identity</span><span class="p">();</span><span class="w"></span>
<span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">source</span><span class="p">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
</details><dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">U</span></code>:</dt><dd><p>Scalar type on which the returned RotationMatrix is templated.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">RotationMatrix&lt;From&gt;::cast&lt;To&gt;()</span></code> creates a new
<code class="docutils literal notranslate"><span class="pre">RotationMatrix&lt;To&gt;</span></code> from a <code class="docutils literal notranslate"><span class="pre">RotationMatrix&lt;From&gt;</span></code> but only if
type <code class="docutils literal notranslate"><span class="pre">To</span></code> is constructible from type <code class="docutils literal notranslate"><span class="pre">From</span></code>. This cast method
works in accordance with Eigen’s cast method for Eigen’s Matrix3
that underlies this RotationMatrix. For example, Eigen currently
allows cast from type double to AutoDiffXd, but not vice-versa.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix.cast-Expression">
<span id="pydrake.math.RotationMatrix.cast[Expression]"></span><span class="sig-name descname"><span class="pre">cast[Expression]</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix" title="pydrake.math.RotationMatrix"><span class="pre">pydrake.math.RotationMatrix</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix.cast-Expression" title="Permalink to this definition"></a></dt>
<dd><p>Creates a RotationMatrix templatized on a scalar type U from a
RotationMatrix templatized on scalar type T. For example,</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">Identity</span><span class="p">();</span><span class="w"></span>
<span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">source</span><span class="p">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
</details><dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">U</span></code>:</dt><dd><p>Scalar type on which the returned RotationMatrix is templated.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">RotationMatrix&lt;From&gt;::cast&lt;To&gt;()</span></code> creates a new
<code class="docutils literal notranslate"><span class="pre">RotationMatrix&lt;To&gt;</span></code> from a <code class="docutils literal notranslate"><span class="pre">RotationMatrix&lt;From&gt;</span></code> but only if
type <code class="docutils literal notranslate"><span class="pre">To</span></code> is constructible from type <code class="docutils literal notranslate"><span class="pre">From</span></code>. This cast method
works in accordance with Eigen’s cast method for Eigen’s Matrix3
that underlies this RotationMatrix. For example, Eigen currently
allows cast from type double to AutoDiffXd, but not vice-versa.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix.cast-float">
<span id="pydrake.math.RotationMatrix.cast[float]"></span><span class="sig-name descname"><span class="pre">cast[float]</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix" title="pydrake.math.RotationMatrix"><span class="pre">pydrake.math.RotationMatrix</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RotationMatrix" title="pydrake.math.RotationMatrix"><span class="pre">pydrake.math.RotationMatrix</span></a></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix.cast-float" title="Permalink to this definition"></a></dt>
<dd><p>Creates a RotationMatrix templatized on a scalar type U from a
RotationMatrix templatized on scalar type T. For example,</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">Identity</span><span class="p">();</span><span class="w"></span>
<span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">source</span><span class="p">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
</details><dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">U</span></code>:</dt><dd><p>Scalar type on which the returned RotationMatrix is templated.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">RotationMatrix&lt;From&gt;::cast&lt;To&gt;()</span></code> creates a new
<code class="docutils literal notranslate"><span class="pre">RotationMatrix&lt;To&gt;</span></code> from a <code class="docutils literal notranslate"><span class="pre">RotationMatrix&lt;From&gt;</span></code> but only if
type <code class="docutils literal notranslate"><span class="pre">To</span></code> is constructible from type <code class="docutils literal notranslate"><span class="pre">From</span></code>. This cast method
works in accordance with Eigen’s cast method for Eigen’s Matrix3
that underlies this RotationMatrix. For example, Eigen currently
allows cast from type double to AutoDiffXd, but not vice-versa.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix.col">
<span class="sig-name descname"><span class="pre">col</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix" title="pydrake.math.RotationMatrix"><span class="pre">pydrake.math.RotationMatrix</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix.col" title="Permalink to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> rotation matrix’s iᵗʰ column (i = 0, 1, 2). For
<code class="docutils literal notranslate"><span class="pre">this</span></code> rotation matrix R_AB (which relates right-handed sets of
orthogonal unit vectors Ax, Ay, Az to Bx, By, Bz), - col(0) returns
Bx_A (Bx expressed in terms of Ax, Ay, Az). - col(1) returns By_A (By
expressed in terms of Ax, Ay, Az). - col(2) returns Bz_A (Bz expressed
in terms of Ax, Ay, Az).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">index</span></code>:</dt><dd><p>requested column index (0 &lt;= index &lt;= 2).</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>row(), matrix()</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>In Debug builds</strong><strong>, </strong><strong>asserts</strong><strong> (</strong><strong>0 &lt;= index &lt;= 2</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For efficiency and consistency with Eigen, this method returns the
same quantity returned by Eigen’s col() operator. The returned
quantity can be assigned in various ways, e.g., as <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">auto&amp;</span>
<span class="pre">Bz_A</span> <span class="pre">=</span> <span class="pre">col(2);</span></code> or <code class="docutils literal notranslate"><span class="pre">Vector3&lt;T&gt;</span> <span class="pre">Bz_A</span> <span class="pre">=</span> <span class="pre">col(2);</span></code></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix.Identity">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Identity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RotationMatrix" title="pydrake.math.RotationMatrix"><span class="pre">pydrake.math.RotationMatrix</span></a></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix.Identity" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix.inverse">
<span class="sig-name descname"><span class="pre">inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix" title="pydrake.math.RotationMatrix"><span class="pre">pydrake.math.RotationMatrix</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RotationMatrix" title="pydrake.math.RotationMatrix"><span class="pre">pydrake.math.RotationMatrix</span></a></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix.inverse" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix.InvertAndCompose">
<span class="sig-name descname"><span class="pre">InvertAndCompose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix" title="pydrake.math.RotationMatrix"><span class="pre">pydrake.math.RotationMatrix</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix" title="pydrake.math.RotationMatrix"><span class="pre">pydrake.math.RotationMatrix</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RotationMatrix" title="pydrake.math.RotationMatrix"><span class="pre">pydrake.math.RotationMatrix</span></a></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix.InvertAndCompose" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the product of <code class="docutils literal notranslate"><span class="pre">this</span></code> inverted and another
RotationMatrix. If you consider <code class="docutils literal notranslate"><span class="pre">this</span></code> to be the rotation matrix
R_AB, and <code class="docutils literal notranslate"><span class="pre">other</span></code> to be R_AC, then this method returns R_BC = R_AB⁻¹
* R_AC. For T==double, this method can be <em>much</em> faster than inverting
first and then performing the composition because it can take
advantage of the orthogonality of rotation matrices. On some platforms
it can use SIMD instructions for further speedups.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other</span></code>:</dt><dd><p>RotationMatrix that post-multiplies <code class="docutils literal notranslate"><span class="pre">this</span></code> inverted.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">R_BC</span></code>:</dt><dd><p>where R_BC = this⁻¹ * other.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is possible (albeit improbable) to create an invalid rotation
matrix by accumulating round-off error with a large number of
multiplies.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix.IsExactlyIdentity">
<span class="sig-name descname"><span class="pre">IsExactlyIdentity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix" title="pydrake.math.RotationMatrix"><span class="pre">pydrake.math.RotationMatrix</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix.IsExactlyIdentity" title="Permalink to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">this</span></code> is exactly equal to the identity matrix.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>IsNearlyIdentity().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix.IsNearlyIdentity">
<span class="sig-name descname"><span class="pre">IsNearlyIdentity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix" title="pydrake.math.RotationMatrix"><span class="pre">pydrake.math.RotationMatrix</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2.842170943040401e-14</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix.IsNearlyIdentity" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if <code class="docutils literal notranslate"><span class="pre">this</span></code> is within tolerance of the identity
RigidTransform.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">tolerance</span></code>:</dt><dd><p>non-negative number that is generally the default value, namely
RotationMatrix::get_internal_tolerance_for_orthonormality().</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>IsExactlyIdentity().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix.IsValid">
<span class="sig-name descname"><span class="pre">IsValid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix" title="pydrake.math.RotationMatrix"><span class="pre">pydrake.math.RotationMatrix</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix.IsValid" title="Permalink to this definition"></a></dt>
<dd><p>Tests if <code class="docutils literal notranslate"><span class="pre">this</span></code> rotation matrix R is a proper orthonormal rotation
matrix to within the threshold of
get_internal_tolerance_for_orthonormality().</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">this</span></code> is a valid rotation matrix.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix.MakeFromOneVector">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeFromOneVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">b_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RotationMatrix" title="pydrake.math.RotationMatrix"><span class="pre">pydrake.math.RotationMatrix</span></a></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix.MakeFromOneVector" title="Permalink to this definition"></a></dt>
<dd><p>Creates a 3D right-handed orthonormal basis B from a given vector b_A,
returned as a rotation matrix R_AB. It consists of orthogonal unit
vectors u_A, v_A, w_A where u_A is the normalized b_A in the
axis_index column of R_AB and v_A has one element which is zero. If an
element of b_A is zero, then one element of w_A is 1 and the other two
elements are 0.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b_A</span></code>:</dt><dd><p>vector expressed in frame A that when normalized as u_A =
b_A.normalized() represents Bx, By, or Bz (depending on
axis_index).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">axis_index</span></code>:</dt><dd><p>The index ∈ {0, 1, 2} of the unit vector associated with u_A, 0
means u_A is Bx, 1 means u_A is By, and 2 means u_A is Bz.</p>
</dd>
<dt>Precondition:</dt><dd><p>axis_index is 0 or 1 or 2.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if b_A cannot be made into a unit vector because b_A</strong> – </p></li>
<li><p><strong>contains a NaN</strong><strong> or </strong><strong>infinity</strong><strong> or </strong><strong>b_A &lt; 1.0E-10.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MakeFromOneUnitVector() if b_A is known to already be unit length.</p>
</div>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">R_AB</span></code>:</dt><dd><p>the rotation matrix with properties as described above.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix.MakeUnchecked">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeUnchecked</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RotationMatrix" title="pydrake.math.RotationMatrix"><span class="pre">pydrake.math.RotationMatrix</span></a></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix.MakeUnchecked" title="Permalink to this definition"></a></dt>
<dd><p>(Advanced) Makes a RotationMatrix from a Matrix3. No check is
performed to test whether or not the parameter R is a valid rotation
matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix.MakeXRotation">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeXRotation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RotationMatrix" title="pydrake.math.RotationMatrix"><span class="pre">pydrake.math.RotationMatrix</span></a></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix.MakeXRotation" title="Permalink to this definition"></a></dt>
<dd><p>Makes the RotationMatrix <code class="docutils literal notranslate"><span class="pre">R_AB</span></code> associated with rotating a frame B
relative to a frame A by an angle <code class="docutils literal notranslate"><span class="pre">theta</span></code> about unit vector <code class="docutils literal notranslate"><span class="pre">Ax</span> <span class="pre">=</span>
<span class="pre">Bx</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt><dd><p>radian measure of rotation angle about Ax.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Orientation is same as Eigen::AngleAxis&lt;T&gt;(theta,
Vector3d::UnitX().</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">R_AB</span></code> relates two frames A and B having unit vectors Ax, Ay, Az
and Bx, By, Bz. Initially, <code class="docutils literal notranslate"><span class="pre">Bx</span> <span class="pre">=</span> <span class="pre">Ax</span></code>, <cite>By = Ay</cite>, <code class="docutils literal notranslate"><span class="pre">Bz</span> <span class="pre">=</span> <span class="pre">Az</span></code>,
then B undergoes a right-handed rotation relative to A by an angle
<code class="docutils literal notranslate"><span class="pre">theta</span></code> about <code class="docutils literal notranslate"><span class="pre">Ax</span> <span class="pre">=</span> <span class="pre">Bx</span></code>.</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>⎡ 1       0                 0  ⎤
R_AB = ⎢ 0   cos(theta)   -sin(theta) ⎥
       ⎣ 0   sin(theta)    cos(theta) ⎦
</pre></div>
</div>
</details></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix.MakeYRotation">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeYRotation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RotationMatrix" title="pydrake.math.RotationMatrix"><span class="pre">pydrake.math.RotationMatrix</span></a></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix.MakeYRotation" title="Permalink to this definition"></a></dt>
<dd><p>Makes the RotationMatrix <code class="docutils literal notranslate"><span class="pre">R_AB</span></code> associated with rotating a frame B
relative to a frame A by an angle <code class="docutils literal notranslate"><span class="pre">theta</span></code> about unit vector <code class="docutils literal notranslate"><span class="pre">Ay</span> <span class="pre">=</span>
<span class="pre">By</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt><dd><p>radian measure of rotation angle about Ay.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Orientation is same as Eigen::AngleAxis&lt;T&gt;(theta,
Vector3d::UnitY().</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">R_AB</span></code> relates two frames A and B having unit vectors Ax, Ay, Az
and Bx, By, Bz. Initially, <code class="docutils literal notranslate"><span class="pre">Bx</span> <span class="pre">=</span> <span class="pre">Ax</span></code>, <cite>By = Ay</cite>, <code class="docutils literal notranslate"><span class="pre">Bz</span> <span class="pre">=</span> <span class="pre">Az</span></code>,
then B undergoes a right-handed rotation relative to A by an angle
<code class="docutils literal notranslate"><span class="pre">theta</span></code> about <code class="docutils literal notranslate"><span class="pre">Ay</span> <span class="pre">=</span> <span class="pre">By</span></code>.</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>⎡  cos(theta)   0   sin(theta) ⎤
R_AB = ⎢          0    1           0  ⎥
       ⎣ -sin(theta)   0   cos(theta) ⎦
</pre></div>
</div>
</details></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix.MakeZRotation">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeZRotation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RotationMatrix" title="pydrake.math.RotationMatrix"><span class="pre">pydrake.math.RotationMatrix</span></a></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix.MakeZRotation" title="Permalink to this definition"></a></dt>
<dd><p>Makes the RotationMatrix <code class="docutils literal notranslate"><span class="pre">R_AB</span></code> associated with rotating a frame B
relative to a frame A by an angle <code class="docutils literal notranslate"><span class="pre">theta</span></code> about unit vector <code class="docutils literal notranslate"><span class="pre">Az</span> <span class="pre">=</span>
<span class="pre">Bz</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt><dd><p>radian measure of rotation angle about Az.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Orientation is same as Eigen::AngleAxis&lt;T&gt;(theta,
Vector3d::UnitZ().</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">R_AB</span></code> relates two frames A and B having unit vectors Ax, Ay, Az
and Bx, By, Bz. Initially, <code class="docutils literal notranslate"><span class="pre">Bx</span> <span class="pre">=</span> <span class="pre">Ax</span></code>, <cite>By = Ay</cite>, <code class="docutils literal notranslate"><span class="pre">Bz</span> <span class="pre">=</span> <span class="pre">Az</span></code>,
then B undergoes a right-handed rotation relative to A by an angle
<code class="docutils literal notranslate"><span class="pre">theta</span></code> about <code class="docutils literal notranslate"><span class="pre">Az</span> <span class="pre">=</span> <span class="pre">Bz</span></code>.</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>⎡ cos(theta)  -sin(theta)   0 ⎤
R_AB = ⎢ sin(theta)   cos(theta)   0 ⎥
       ⎣         0            0    1 ⎦
</pre></div>
</div>
</details></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix.matrix">
<span class="sig-name descname"><span class="pre">matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix" title="pydrake.math.RotationMatrix"><span class="pre">pydrake.math.RotationMatrix</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix.matrix" title="Permalink to this definition"></a></dt>
<dd><p>Returns the Matrix3 underlying a RotationMatrix.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>col(), row()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix.multiply">
<span class="sig-name descname"><span class="pre">multiply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.RotationMatrix.multiply" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>multiply(self: pydrake.math.RotationMatrix, other: pydrake.math.RotationMatrix) -&gt; pydrake.math.RotationMatrix</p></li>
</ol>
<p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> rotation matrix <code class="docutils literal notranslate"><span class="pre">R_AB</span></code> multiplied by <code class="docutils literal notranslate"><span class="pre">other</span></code>
rotation matrix <code class="docutils literal notranslate"><span class="pre">R_BC</span></code>, returning the composition <code class="docutils literal notranslate"><span class="pre">R_AB</span> <span class="pre">*</span> <span class="pre">R_BC</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other</span></code>:</dt><dd><p>RotationMatrix that post-multiplies <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>rotation matrix that results from <code class="docutils literal notranslate"><span class="pre">this</span></code> multiplied by
<code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is possible (albeit improbable) to create an invalid rotation
matrix by accumulating round-off error with a large number of
multiplies.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>multiply(self: pydrake.math.RotationMatrix, v_B: numpy.ndarray[numpy.float64[3, 1]]) -&gt; numpy.ndarray[numpy.float64[3, 1]]</p></li>
</ol>
<p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> rotation matrix <code class="docutils literal notranslate"><span class="pre">R_AB</span></code> multiplied by an
arbitrary Vector3 expressed in the B frame.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v_B</span></code>:</dt><dd><p>3x1 vector that post-multiplies <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>3x1 vector <code class="docutils literal notranslate"><span class="pre">v_A</span> <span class="pre">=</span> <span class="pre">R_AB</span> <span class="pre">*</span> <span class="pre">v_B</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>multiply(self: pydrake.math.RotationMatrix, v_B: numpy.ndarray[numpy.float64[3, n]]) -&gt; numpy.ndarray[numpy.float64[3, n]]</p></li>
</ol>
<p>Multiplies <code class="docutils literal notranslate"><span class="pre">this</span></code> RotationMatrix <code class="docutils literal notranslate"><span class="pre">R_AB</span></code> by the n vectors <code class="docutils literal notranslate"><span class="pre">v1</span></code>,
… <cite>vn</cite>, where each vector has 3 elements and is expressed in frame
B.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v_B</span></code>:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix whose n columns are regarded as arbitrary vectors
<code class="docutils literal notranslate"><span class="pre">v1</span></code>, … <cite>vn</cite> expressed in frame B.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">v_A</span></code>:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix whose n columns are vectors <code class="docutils literal notranslate"><span class="pre">v1</span></code>, … <cite>vn</cite>
expressed in frame A.</p>
</dd>
</dl>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="n">RollPitchYaw</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">rpy</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span><span class="w"> </span><span class="mf">0.2</span><span class="p">,</span><span class="w"> </span><span class="mf">0.3</span><span class="p">);</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">R_AB</span><span class="p">(</span><span class="n">rpy</span><span class="p">);</span><span class="w"></span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v_B</span><span class="p">;</span><span class="w"></span>
<span class="n">v_B</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Vector3d</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span><span class="w"></span>
<span class="n">v_B</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Vector3d</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">);</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v_A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">R_AB</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v_B</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</details></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix.ProjectToRotationMatrix">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ProjectToRotationMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RotationMatrix" title="pydrake.math.RotationMatrix"><span class="pre">pydrake.math.RotationMatrix</span></a></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix.ProjectToRotationMatrix" title="Permalink to this definition"></a></dt>
<dd><p>Given an approximate rotation matrix M, finds the RotationMatrix R
closest to M. Closeness is measured with a matrix-2 norm (or
equivalently with a Frobenius norm). Hence, this method creates a
RotationMatrix R from a 3x3 matrix M by minimizing <code class="docutils literal notranslate"><span class="pre">‖R</span> <span class="pre">-</span> <span class="pre">M‖₂</span></code> (the
matrix-2 norm of (R-M)) subject to <code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">*</span> <span class="pre">Rᵀ</span> <span class="pre">=</span> <span class="pre">I</span></code>, where I is the 3x3
identity matrix. For this problem, closeness can also be measured by
forming the orthonormal matrix R whose elements minimize the
double-summation <code class="docutils literal notranslate"><span class="pre">∑ᵢ</span> <span class="pre">∑ⱼ</span> <span class="pre">(R(i,j)</span> <span class="pre">-</span> <span class="pre">M(i,j))²</span></code> where <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">=</span> <span class="pre">1:3,</span> <span class="pre">j</span> <span class="pre">=</span>
<span class="pre">1:3</span></code>, subject to <code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">*</span> <span class="pre">Rᵀ</span> <span class="pre">=</span> <span class="pre">I</span></code>. The square-root of this
double-summation is called the Frobenius norm.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M</span></code>:</dt><dd><p>a 3x3 matrix.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quality_factor</span></code>:</dt><dd><p>The quality of M as a rotation matrix. <code class="docutils literal notranslate"><span class="pre">quality_factor</span></code> = 1 is
perfect (M = R). <code class="docutils literal notranslate"><span class="pre">quality_factor</span></code> = 1.25 means that when M
multiplies a unit vector (magnitude 1), a vector of magnitude as
large as 1.25 may result. <code class="docutils literal notranslate"><span class="pre">quality_factor</span></code> = 0.8 means that when
M multiplies a unit vector, a vector of magnitude as small as 0.8
may result. <code class="docutils literal notranslate"><span class="pre">quality_factor</span></code> = 0 means M is singular, so at
least one of the bases related by matrix M does not span 3D space
(when M multiples a unit vector, a vector of magnitude as small as
0 may result).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>proper orthonormal matrix R that is closest to M.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>RuntimeError if R fails IsValid</strong><strong>(</strong><strong>R</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>William Kahan (UC Berkeley) and Hongkai Dai (Toyota Research
Institute) proved that for this problem, the same R that minimizes
the Frobenius norm also minimizes the matrix-2 norm (a.k.a an
induced-2 norm), which is defined [Dahleh, Section 4.2] as the
column matrix u which maximizes <code class="docutils literal notranslate"><span class="pre">‖(R</span> <span class="pre">-</span> <span class="pre">M)</span> <span class="pre">u‖</span> <span class="pre">/</span> <span class="pre">‖u‖</span></code>, where <code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">≠</span>
<span class="pre">0</span></code>. Since the matrix-2 norm of any matrix A is equal to the
maximum singular value of A, minimizing the matrix-2 norm of (R -
M) is equivalent to minimizing the maximum singular value of (R -
M).</p>
</div>
<ul class="simple">
<li><p>[Dahleh] “Lectures on Dynamic Systems and Controls: Electrical</p></li>
</ul>
<p>Engineering and Computer Science, Massachusetts Institute of Technology”
<a class="reference external" href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-241j-dynamic-systems-and-control-spring-2011/readings/MIT6_241JS11_chap04.pdf">https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-241j-dynamic-systems-and-control-spring-2011/readings/MIT6_241JS11_chap04.pdf</a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix.row">
<span class="sig-name descname"><span class="pre">row</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix" title="pydrake.math.RotationMatrix"><span class="pre">pydrake.math.RotationMatrix</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix.row" title="Permalink to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> rotation matrix’s iᵗʰ row (i = 0, 1, 2). For <code class="docutils literal notranslate"><span class="pre">this</span></code>
rotation matrix R_AB (which relates right-handed sets of orthogonal
unit vectors Ax, Ay, Az to Bx, By, Bz), - row(0) returns Ax_B (Ax
expressed in terms of Bx, By, Bz). - row(1) returns Ay_B (Ay expressed
in terms of Bx, By, Bz). - row(2) returns Az_B (Az expressed in terms
of Bx, By, Bz).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">index</span></code>:</dt><dd><p>requested row index (0 &lt;= index &lt;= 2).</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>col(), matrix()</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>In Debug builds</strong><strong>, </strong><strong>asserts</strong><strong> (</strong><strong>0 &lt;= index &lt;= 2</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For efficiency and consistency with Eigen, this method returns the
same quantity returned by Eigen’s row() operator. The returned
quantity can be assigned in various ways, e.g., as <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">auto&amp;</span>
<span class="pre">Az_B</span> <span class="pre">=</span> <span class="pre">row(2);</span></code> or <code class="docutils literal notranslate"><span class="pre">RowVector3&lt;T&gt;</span> <span class="pre">Az_B</span> <span class="pre">=</span> <span class="pre">row(2);</span></code></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix.set">
<span class="sig-name descname"><span class="pre">set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix" title="pydrake.math.RotationMatrix"><span class="pre">pydrake.math.RotationMatrix</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix.set" title="Permalink to this definition"></a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> RotationMatrix from a Matrix3.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R</span></code>:</dt><dd><p>an allegedly valid rotation matrix.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError in debug builds if R fails IsValid</strong><strong>(</strong><strong>R</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix.ToAngleAxis">
<span class="sig-name descname"><span class="pre">ToAngleAxis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix" title="pydrake.math.RotationMatrix"><span class="pre">pydrake.math.RotationMatrix</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.common.eigen_geometry.html#pydrake.common.eigen_geometry.AngleAxis" title="pydrake.common.eigen_geometry.AngleAxis"><span class="pre">pydrake.common.eigen_geometry.AngleAxis</span></a></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix.ToAngleAxis" title="Permalink to this definition"></a></dt>
<dd><p>Returns an AngleAxis <code class="docutils literal notranslate"><span class="pre">theta_lambda</span></code> containing an angle <code class="docutils literal notranslate"><span class="pre">theta</span></code>
and unit vector (axis direction) <code class="docutils literal notranslate"><span class="pre">lambda</span></code> that represents <code class="docutils literal notranslate"><span class="pre">this</span></code>
RotationMatrix.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The orientation and RotationMatrix associated with <code class="docutils literal notranslate"><span class="pre">theta</span> <span class="pre">*</span>
<span class="pre">lambda</span></code> is identical to that of <code class="docutils literal notranslate"><span class="pre">(-theta)</span> <span class="pre">*</span> <span class="pre">(-lambda)</span></code>. The
AngleAxis returned by this method chooses to have <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">theta</span> <span class="pre">&lt;=</span>
<span class="pre">pi</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>an AngleAxis with <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">theta</span> <span class="pre">&lt;=</span> <span class="pre">pi</span></code> and a unit vector
<code class="docutils literal notranslate"><span class="pre">lambda</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix.ToQuaternion">
<span class="sig-name descname"><span class="pre">ToQuaternion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix" title="pydrake.math.RotationMatrix"><span class="pre">pydrake.math.RotationMatrix</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.common.eigen_geometry.html#pydrake.common.eigen_geometry.Quaternion" title="pydrake.common.eigen_geometry.Quaternion"><span class="pre">pydrake.common.eigen_geometry.Quaternion</span></a></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix.ToQuaternion" title="Permalink to this definition"></a></dt>
<dd><p>Returns a quaternion q that represents <code class="docutils literal notranslate"><span class="pre">this</span></code> RotationMatrix. Since
the quaternion <code class="docutils literal notranslate"><span class="pre">q</span></code> and <code class="docutils literal notranslate"><span class="pre">-q</span></code> represent the same RotationMatrix,
this method chooses to return a canonical quaternion, i.e., with q(0)
&gt;= 0.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix.ToRollPitchYaw">
<span class="sig-name descname"><span class="pre">ToRollPitchYaw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix" title="pydrake.math.RotationMatrix"><span class="pre">pydrake.math.RotationMatrix</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RollPitchYaw" title="pydrake.math.RollPitchYaw"><span class="pre">pydrake.math.RollPitchYaw</span></a></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix.ToRollPitchYaw" title="Permalink to this definition"></a></dt>
<dd><p>Returns a RollPitchYaw that represents <code class="docutils literal notranslate"><span class="pre">this</span></code> RotationMatrix, with
roll-pitch-yaw angles <code class="docutils literal notranslate"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code> in the range <code class="docutils literal notranslate"><span class="pre">-π</span> <span class="pre">&lt;=</span> <span class="pre">r</span> <span class="pre">&lt;=</span> <span class="pre">π</span></code>,
<cite>-π/2 &lt;= p &lt;= π/2</cite>, <code class="docutils literal notranslate"><span class="pre">-π</span> <span class="pre">&lt;=</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">π</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This new high-accuracy algorithm avoids numerical round-off issues
encountered by some algorithms when pitch is within 1E-6 of π/2 or
-π/2.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix.transpose">
<span class="sig-name descname"><span class="pre">transpose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix" title="pydrake.math.RotationMatrix"><span class="pre">pydrake.math.RotationMatrix</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RotationMatrix" title="pydrake.math.RotationMatrix"><span class="pre">pydrake.math.RotationMatrix</span></a></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix.transpose" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">RotationMatrix_</span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">RotationMatrix_[float]</span></code>, <a class="reference internal" href="#pydrake.math.RotationMatrix_-AutoDiffXd" title="pydrake.math.RotationMatrix_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotationMatrix_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.math.RotationMatrix_-Expression" title="pydrake.math.RotationMatrix_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotationMatrix_[Expression]</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-AutoDiffXd">
<span id="pydrake.math.RotationMatrix_[AutoDiffXd]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">RotationMatrix_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><p>This class represents a 3x3 rotation matrix between two arbitrary
frames A and B and helps ensure users create valid rotation matrices.
This class relates right-handed orthogonal unit vectors Ax, Ay, Az
fixed in frame A to right-handed orthogonal unit vectors Bx, By, Bz
fixed in frame B. The monogram notation for the rotation matrix
relating A to B is <code class="docutils literal notranslate"><span class="pre">R_AB</span></code>. An example that gives context to this
rotation matrix is <code class="docutils literal notranslate"><span class="pre">v_A</span> <span class="pre">=</span> <span class="pre">R_AB</span> <span class="pre">*</span> <span class="pre">v_B</span></code>, where <code class="docutils literal notranslate"><span class="pre">v_B</span></code> denotes an
arbitrary vector v expressed in terms of Bx, By, Bz and <code class="docutils literal notranslate"><span class="pre">v_A</span></code>
denotes vector v expressed in terms of Ax, Ay, Az. See
multibody_quantities for monogram notation for dynamics. See
orientation_discussion “a discussion on rotation matrices”.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class does not store the frames associated with a rotation
matrix nor does it enforce strict proper usage of this class with
vectors.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When assertions are enabled, several methods in this class perform
a validity check and throw RuntimeError if the rotation matrix is
invalid. When assertions are disabled, many of these validity
checks are skipped (which helps improve speed). These validity
tests are only performed for scalar types for which
drake::scalar_predicate&lt;T&gt;::is_bool is <code class="docutils literal notranslate"><span class="pre">True</span></code>. For instance,
validity checks are not performed when T is symbolic::Expression.</p>
</div>
<dl class="simple">
<dt>Authors:</dt><dd><p>Paul Mitiguy (2018) Original author.</p>
</dd>
<dt>Authors:</dt><dd><p>Drake team (see <a class="reference external" href="https://drake.mit.edu/credits">https://drake.mit.edu/credits</a>).</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-AutoDiffXd-.__init__">
<span id="pydrake.math.RotationMatrix_[AutoDiffXd].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.RotationMatrix_-AutoDiffXd-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.math.RotationMatrix_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Constructs a 3x3 identity RotationMatrix – which corresponds to
aligning two frames (so that unit vectors Ax = Bx, Ay = By, Az = Bz).</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.math.RotationMatrix_[AutoDiffXd], other: pydrake.math.RotationMatrix_[AutoDiffXd]) -&gt; None</p></li>
<li><p>__init__(self: pydrake.math.RotationMatrix_[AutoDiffXd], R: numpy.ndarray[object[3, 3]]) -&gt; None</p></li>
</ol>
<p>Constructs a RotationMatrix from a Matrix3.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R</span></code>:</dt><dd><p>an allegedly valid rotation matrix.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError in debug builds if R fails IsValid</strong><strong>(</strong><strong>R</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.math.RotationMatrix_[AutoDiffXd], quaternion: pydrake.common.eigen_geometry.Quaternion_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Constructs a RotationMatrix from an Eigen::Quaternion.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quaternion</span></code>:</dt><dd><p>a non-zero, finite quaternion which may or may not have unit
length [i.e., <code class="docutils literal notranslate"><span class="pre">quaternion.norm()</span></code> does not have to be 1].</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError in debug builds if the rotation matrix R that is</strong> – </p></li>
<li><p><strong>built from quaternion fails IsValid</strong><strong>(</strong><strong>R</strong><strong>)</strong><strong> For example</strong><strong>, </strong><strong>an</strong> – </p></li>
<li><p><strong>exception is thrown if quaternion is zero</strong><strong> or </strong><strong>contains a NaN or</strong> – </p></li>
<li><p><strong>infinity.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method has the effect of normalizing its <code class="docutils literal notranslate"><span class="pre">quaternion</span></code>
argument, without the inefficiency of the square-root associated
with normalization.</p>
</div>
<ol class="arabic simple" start="5">
<li><p>__init__(self: pydrake.math.RotationMatrix_[AutoDiffXd], theta_lambda: pydrake.common.eigen_geometry.AngleAxis_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Constructs a RotationMatrix from an Eigen::AngleAxis.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta_lambda</span></code>:</dt><dd><p>an Eigen::AngleAxis whose associated axis (vector direction herein
called <code class="docutils literal notranslate"><span class="pre">lambda</span></code>) is non-zero and finite, but which may or may
not have unit length [i.e., <code class="docutils literal notranslate"><span class="pre">lambda.norm()</span></code> does not have to be
1].</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError in debug builds if the rotation matrix R that is</strong> – </p></li>
<li><p><strong>built from theta_lambda fails IsValid</strong><strong>(</strong><strong>R</strong><strong>)</strong><strong> For example</strong><strong>, </strong><strong>an</strong> – </p></li>
<li><p><strong>exception is thrown if lambda is zero</strong><strong> or </strong><strong>contains a NaN or</strong> – </p></li>
<li><p><strong>infinity.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="6">
<li><p>__init__(self: pydrake.math.RotationMatrix_[AutoDiffXd], rpy: pydrake.math.RollPitchYaw_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Constructs a RotationMatrix from an RollPitchYaw. In other words,
makes the RotationMatrix for a Space-fixed (extrinsic) X-Y-Z rotation
by “roll-pitch-yaw” angles <code class="docutils literal notranslate"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code>, which is equivalent to a
Body-fixed (intrinsic) Z-Y-X rotation by “yaw-pitch-roll” angles <code class="docutils literal notranslate"><span class="pre">[y,</span>
<span class="pre">p,</span> <span class="pre">r]</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rpy</span></code>:</dt><dd><p>a RollPitchYaw which is a Space-fixed (extrinsic) X-Y-Z rotation
with “roll-pitch-yaw” angles <code class="docutils literal notranslate"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code> or equivalently a Body-
fixed (intrinsic) Z-Y-X rotation with “yaw-pitch-roll” angles
<code class="docutils literal notranslate"><span class="pre">[y,</span> <span class="pre">p,</span> <span class="pre">r]</span></code>.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">R_AD</span></code>:</dt><dd><p>, rotation matrix relating frame A to frame D.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Denoting roll <code class="docutils literal notranslate"><span class="pre">r</span></code>, pitch <code class="docutils literal notranslate"><span class="pre">p</span></code>, yaw <code class="docutils literal notranslate"><span class="pre">y</span></code>, this method returns a
rotation matrix <code class="docutils literal notranslate"><span class="pre">R_AD</span></code> equal to the matrix multiplication shown
below.</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>⎡cos(y) -sin(y)  0⎤   ⎡ cos(p)  0  sin(p)⎤   ⎡1      0        0 ⎤
R_AD = ⎢sin(y)  cos(y)  0⎥ * ⎢     0   1      0 ⎥ * ⎢0  cos(r)  -sin(r)⎥
       ⎣    0       0   1⎦   ⎣-sin(p)  0  cos(p)⎦   ⎣0  sin(r)   cos(r)⎦
     =       R_AB          *        R_BC          *        R_CD
</pre></div>
</div>
</details><div class="admonition note">
<p class="admonition-title">Note</p>
<p>In this discussion, A is the Space frame and D is the Body frame.
One way to visualize this rotation sequence is by introducing
intermediate frames B and C (useful constructs to understand this
rotation sequence). Initially, the frames are aligned so <code class="docutils literal notranslate"><span class="pre">Di</span> <span class="pre">=</span> <span class="pre">Ci</span>
<span class="pre">=</span> <span class="pre">Bi</span> <span class="pre">=</span> <span class="pre">Ai</span> <span class="pre">(i</span> <span class="pre">=</span> <span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code>. Then D is subjected to successive
right-handed rotations relative to A.</p>
</div>
<ul class="simple">
<li><p>1st rotation R_CD: Frame D rotates relative to frames C, B, A by a</p></li>
</ul>
<p>roll angle <code class="docutils literal notranslate"><span class="pre">r</span></code> about <code class="docutils literal notranslate"><span class="pre">Dx</span> <span class="pre">=</span> <span class="pre">Cx</span></code>.  Note: D and C are no longer aligned.</p>
<ul class="simple">
<li><p>2nd rotation R_BC: Frames D, C (collectively – as if welded together)</p></li>
</ul>
<p>rotate relative to frame B, A by a pitch angle <code class="docutils literal notranslate"><span class="pre">p</span></code> about <code class="docutils literal notranslate"><span class="pre">Cy</span> <span class="pre">=</span> <span class="pre">By</span></code>.
Note: C and B are no longer aligned.</p>
<ul class="simple">
<li><p>3rd rotation R_AB: Frames D, C, B (collectively – as if welded)</p></li>
</ul>
<p>rotate relative to frame A by a roll angle <code class="docutils literal notranslate"><span class="pre">y</span></code> about <code class="docutils literal notranslate"><span class="pre">Bz</span> <span class="pre">=</span> <span class="pre">Az</span></code>.
Note: B and A are no longer aligned.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method constructs a RotationMatrix from a RollPitchYaw.
Vice-versa, there are high-accuracy RollPitchYaw
constructor/methods that form a RollPitchYaw from a rotation
matrix.</p>
</div>
</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-AutoDiffXd-.cast">
<span id="pydrake.math.RotationMatrix_[AutoDiffXd].cast"></span><em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">cast</span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-AutoDiffXd-.cast" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">cast[AutoDiffXd]</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-AutoDiffXd-.cast-AutoDiffXd">
<span id="pydrake.math.RotationMatrix_[AutoDiffXd].cast[AutoDiffXd]"></span><span class="sig-name descname"><span class="pre">cast[AutoDiffXd]</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-AutoDiffXd-.cast-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><p>Creates a RotationMatrix templatized on a scalar type U from a
RotationMatrix templatized on scalar type T. For example,</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">Identity</span><span class="p">();</span><span class="w"></span>
<span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">source</span><span class="p">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
</details><dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">U</span></code>:</dt><dd><p>Scalar type on which the returned RotationMatrix is templated.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">RotationMatrix&lt;From&gt;::cast&lt;To&gt;()</span></code> creates a new
<code class="docutils literal notranslate"><span class="pre">RotationMatrix&lt;To&gt;</span></code> from a <code class="docutils literal notranslate"><span class="pre">RotationMatrix&lt;From&gt;</span></code> but only if
type <code class="docutils literal notranslate"><span class="pre">To</span></code> is constructible from type <code class="docutils literal notranslate"><span class="pre">From</span></code>. This cast method
works in accordance with Eigen’s cast method for Eigen’s Matrix3
that underlies this RotationMatrix. For example, Eigen currently
allows cast from type double to AutoDiffXd, but not vice-versa.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-AutoDiffXd-.col">
<span id="pydrake.math.RotationMatrix_[AutoDiffXd].col"></span><span class="sig-name descname"><span class="pre">col</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-AutoDiffXd-.col" title="Permalink to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> rotation matrix’s iᵗʰ column (i = 0, 1, 2). For
<code class="docutils literal notranslate"><span class="pre">this</span></code> rotation matrix R_AB (which relates right-handed sets of
orthogonal unit vectors Ax, Ay, Az to Bx, By, Bz), - col(0) returns
Bx_A (Bx expressed in terms of Ax, Ay, Az). - col(1) returns By_A (By
expressed in terms of Ax, Ay, Az). - col(2) returns Bz_A (Bz expressed
in terms of Ax, Ay, Az).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">index</span></code>:</dt><dd><p>requested column index (0 &lt;= index &lt;= 2).</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>row(), matrix()</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>In Debug builds</strong><strong>, </strong><strong>asserts</strong><strong> (</strong><strong>0 &lt;= index &lt;= 2</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For efficiency and consistency with Eigen, this method returns the
same quantity returned by Eigen’s col() operator. The returned
quantity can be assigned in various ways, e.g., as <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">auto&amp;</span>
<span class="pre">Bz_A</span> <span class="pre">=</span> <span class="pre">col(2);</span></code> or <code class="docutils literal notranslate"><span class="pre">Vector3&lt;T&gt;</span> <span class="pre">Bz_A</span> <span class="pre">=</span> <span class="pre">col(2);</span></code></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-AutoDiffXd-.Identity">
<span id="pydrake.math.RotationMatrix_[AutoDiffXd].Identity"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Identity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-AutoDiffXd-.Identity" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-AutoDiffXd-.inverse">
<span id="pydrake.math.RotationMatrix_[AutoDiffXd].inverse"></span><span class="sig-name descname"><span class="pre">inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-AutoDiffXd-.inverse" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-AutoDiffXd-.InvertAndCompose">
<span id="pydrake.math.RotationMatrix_[AutoDiffXd].InvertAndCompose"></span><span class="sig-name descname"><span class="pre">InvertAndCompose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-AutoDiffXd-.InvertAndCompose" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the product of <code class="docutils literal notranslate"><span class="pre">this</span></code> inverted and another
RotationMatrix. If you consider <code class="docutils literal notranslate"><span class="pre">this</span></code> to be the rotation matrix
R_AB, and <code class="docutils literal notranslate"><span class="pre">other</span></code> to be R_AC, then this method returns R_BC = R_AB⁻¹
* R_AC. For T==double, this method can be <em>much</em> faster than inverting
first and then performing the composition because it can take
advantage of the orthogonality of rotation matrices. On some platforms
it can use SIMD instructions for further speedups.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other</span></code>:</dt><dd><p>RotationMatrix that post-multiplies <code class="docutils literal notranslate"><span class="pre">this</span></code> inverted.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">R_BC</span></code>:</dt><dd><p>where R_BC = this⁻¹ * other.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is possible (albeit improbable) to create an invalid rotation
matrix by accumulating round-off error with a large number of
multiplies.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-AutoDiffXd-.IsExactlyIdentity">
<span id="pydrake.math.RotationMatrix_[AutoDiffXd].IsExactlyIdentity"></span><span class="sig-name descname"><span class="pre">IsExactlyIdentity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-AutoDiffXd-.IsExactlyIdentity" title="Permalink to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">this</span></code> is exactly equal to the identity matrix.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>IsNearlyIdentity().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-AutoDiffXd-.IsNearlyIdentity">
<span id="pydrake.math.RotationMatrix_[AutoDiffXd].IsNearlyIdentity"></span><span class="sig-name descname"><span class="pre">IsNearlyIdentity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2.842170943040401e-14</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-AutoDiffXd-.IsNearlyIdentity" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if <code class="docutils literal notranslate"><span class="pre">this</span></code> is within tolerance of the identity
RigidTransform.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">tolerance</span></code>:</dt><dd><p>non-negative number that is generally the default value, namely
RotationMatrix::get_internal_tolerance_for_orthonormality().</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>IsExactlyIdentity().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-AutoDiffXd-.IsValid">
<span id="pydrake.math.RotationMatrix_[AutoDiffXd].IsValid"></span><span class="sig-name descname"><span class="pre">IsValid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-AutoDiffXd-.IsValid" title="Permalink to this definition"></a></dt>
<dd><p>Tests if <code class="docutils literal notranslate"><span class="pre">this</span></code> rotation matrix R is a proper orthonormal rotation
matrix to within the threshold of
get_internal_tolerance_for_orthonormality().</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">this</span></code> is a valid rotation matrix.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-AutoDiffXd-.MakeFromOneVector">
<span id="pydrake.math.RotationMatrix_[AutoDiffXd].MakeFromOneVector"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeFromOneVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">b_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-AutoDiffXd-.MakeFromOneVector" title="Permalink to this definition"></a></dt>
<dd><p>Creates a 3D right-handed orthonormal basis B from a given vector b_A,
returned as a rotation matrix R_AB. It consists of orthogonal unit
vectors u_A, v_A, w_A where u_A is the normalized b_A in the
axis_index column of R_AB and v_A has one element which is zero. If an
element of b_A is zero, then one element of w_A is 1 and the other two
elements are 0.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b_A</span></code>:</dt><dd><p>vector expressed in frame A that when normalized as u_A =
b_A.normalized() represents Bx, By, or Bz (depending on
axis_index).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">axis_index</span></code>:</dt><dd><p>The index ∈ {0, 1, 2} of the unit vector associated with u_A, 0
means u_A is Bx, 1 means u_A is By, and 2 means u_A is Bz.</p>
</dd>
<dt>Precondition:</dt><dd><p>axis_index is 0 or 1 or 2.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if b_A cannot be made into a unit vector because b_A</strong> – </p></li>
<li><p><strong>contains a NaN</strong><strong> or </strong><strong>infinity</strong><strong> or </strong><strong>b_A &lt; 1.0E-10.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MakeFromOneUnitVector() if b_A is known to already be unit length.</p>
</div>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">R_AB</span></code>:</dt><dd><p>the rotation matrix with properties as described above.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-AutoDiffXd-.MakeUnchecked">
<span id="pydrake.math.RotationMatrix_[AutoDiffXd].MakeUnchecked"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeUnchecked</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-AutoDiffXd-.MakeUnchecked" title="Permalink to this definition"></a></dt>
<dd><p>(Advanced) Makes a RotationMatrix from a Matrix3. No check is
performed to test whether or not the parameter R is a valid rotation
matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-AutoDiffXd-.MakeXRotation">
<span id="pydrake.math.RotationMatrix_[AutoDiffXd].MakeXRotation"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeXRotation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-AutoDiffXd-.MakeXRotation" title="Permalink to this definition"></a></dt>
<dd><p>Makes the RotationMatrix <code class="docutils literal notranslate"><span class="pre">R_AB</span></code> associated with rotating a frame B
relative to a frame A by an angle <code class="docutils literal notranslate"><span class="pre">theta</span></code> about unit vector <code class="docutils literal notranslate"><span class="pre">Ax</span> <span class="pre">=</span>
<span class="pre">Bx</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt><dd><p>radian measure of rotation angle about Ax.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Orientation is same as Eigen::AngleAxis&lt;T&gt;(theta,
Vector3d::UnitX().</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">R_AB</span></code> relates two frames A and B having unit vectors Ax, Ay, Az
and Bx, By, Bz. Initially, <code class="docutils literal notranslate"><span class="pre">Bx</span> <span class="pre">=</span> <span class="pre">Ax</span></code>, <cite>By = Ay</cite>, <code class="docutils literal notranslate"><span class="pre">Bz</span> <span class="pre">=</span> <span class="pre">Az</span></code>,
then B undergoes a right-handed rotation relative to A by an angle
<code class="docutils literal notranslate"><span class="pre">theta</span></code> about <code class="docutils literal notranslate"><span class="pre">Ax</span> <span class="pre">=</span> <span class="pre">Bx</span></code>.</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>⎡ 1       0                 0  ⎤
R_AB = ⎢ 0   cos(theta)   -sin(theta) ⎥
       ⎣ 0   sin(theta)    cos(theta) ⎦
</pre></div>
</div>
</details></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-AutoDiffXd-.MakeYRotation">
<span id="pydrake.math.RotationMatrix_[AutoDiffXd].MakeYRotation"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeYRotation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-AutoDiffXd-.MakeYRotation" title="Permalink to this definition"></a></dt>
<dd><p>Makes the RotationMatrix <code class="docutils literal notranslate"><span class="pre">R_AB</span></code> associated with rotating a frame B
relative to a frame A by an angle <code class="docutils literal notranslate"><span class="pre">theta</span></code> about unit vector <code class="docutils literal notranslate"><span class="pre">Ay</span> <span class="pre">=</span>
<span class="pre">By</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt><dd><p>radian measure of rotation angle about Ay.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Orientation is same as Eigen::AngleAxis&lt;T&gt;(theta,
Vector3d::UnitY().</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">R_AB</span></code> relates two frames A and B having unit vectors Ax, Ay, Az
and Bx, By, Bz. Initially, <code class="docutils literal notranslate"><span class="pre">Bx</span> <span class="pre">=</span> <span class="pre">Ax</span></code>, <cite>By = Ay</cite>, <code class="docutils literal notranslate"><span class="pre">Bz</span> <span class="pre">=</span> <span class="pre">Az</span></code>,
then B undergoes a right-handed rotation relative to A by an angle
<code class="docutils literal notranslate"><span class="pre">theta</span></code> about <code class="docutils literal notranslate"><span class="pre">Ay</span> <span class="pre">=</span> <span class="pre">By</span></code>.</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>⎡  cos(theta)   0   sin(theta) ⎤
R_AB = ⎢          0    1           0  ⎥
       ⎣ -sin(theta)   0   cos(theta) ⎦
</pre></div>
</div>
</details></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-AutoDiffXd-.MakeZRotation">
<span id="pydrake.math.RotationMatrix_[AutoDiffXd].MakeZRotation"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeZRotation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-AutoDiffXd-.MakeZRotation" title="Permalink to this definition"></a></dt>
<dd><p>Makes the RotationMatrix <code class="docutils literal notranslate"><span class="pre">R_AB</span></code> associated with rotating a frame B
relative to a frame A by an angle <code class="docutils literal notranslate"><span class="pre">theta</span></code> about unit vector <code class="docutils literal notranslate"><span class="pre">Az</span> <span class="pre">=</span>
<span class="pre">Bz</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt><dd><p>radian measure of rotation angle about Az.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Orientation is same as Eigen::AngleAxis&lt;T&gt;(theta,
Vector3d::UnitZ().</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">R_AB</span></code> relates two frames A and B having unit vectors Ax, Ay, Az
and Bx, By, Bz. Initially, <code class="docutils literal notranslate"><span class="pre">Bx</span> <span class="pre">=</span> <span class="pre">Ax</span></code>, <cite>By = Ay</cite>, <code class="docutils literal notranslate"><span class="pre">Bz</span> <span class="pre">=</span> <span class="pre">Az</span></code>,
then B undergoes a right-handed rotation relative to A by an angle
<code class="docutils literal notranslate"><span class="pre">theta</span></code> about <code class="docutils literal notranslate"><span class="pre">Az</span> <span class="pre">=</span> <span class="pre">Bz</span></code>.</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>⎡ cos(theta)  -sin(theta)   0 ⎤
R_AB = ⎢ sin(theta)   cos(theta)   0 ⎥
       ⎣         0            0    1 ⎦
</pre></div>
</div>
</details></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-AutoDiffXd-.matrix">
<span id="pydrake.math.RotationMatrix_[AutoDiffXd].matrix"></span><span class="sig-name descname"><span class="pre">matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-AutoDiffXd-.matrix" title="Permalink to this definition"></a></dt>
<dd><p>Returns the Matrix3 underlying a RotationMatrix.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>col(), row()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-AutoDiffXd-.multiply">
<span id="pydrake.math.RotationMatrix_[AutoDiffXd].multiply"></span><span class="sig-name descname"><span class="pre">multiply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.RotationMatrix_-AutoDiffXd-.multiply" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>multiply(self: pydrake.math.RotationMatrix_[AutoDiffXd], other: pydrake.math.RotationMatrix_[AutoDiffXd]) -&gt; pydrake.math.RotationMatrix_[AutoDiffXd]</p></li>
</ol>
<p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> rotation matrix <code class="docutils literal notranslate"><span class="pre">R_AB</span></code> multiplied by <code class="docutils literal notranslate"><span class="pre">other</span></code>
rotation matrix <code class="docutils literal notranslate"><span class="pre">R_BC</span></code>, returning the composition <code class="docutils literal notranslate"><span class="pre">R_AB</span> <span class="pre">*</span> <span class="pre">R_BC</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other</span></code>:</dt><dd><p>RotationMatrix that post-multiplies <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>rotation matrix that results from <code class="docutils literal notranslate"><span class="pre">this</span></code> multiplied by
<code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is possible (albeit improbable) to create an invalid rotation
matrix by accumulating round-off error with a large number of
multiplies.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>multiply(self: pydrake.math.RotationMatrix_[AutoDiffXd], v_B: numpy.ndarray[object[3, 1]]) -&gt; numpy.ndarray[object[3, 1]]</p></li>
</ol>
<p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> rotation matrix <code class="docutils literal notranslate"><span class="pre">R_AB</span></code> multiplied by an
arbitrary Vector3 expressed in the B frame.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v_B</span></code>:</dt><dd><p>3x1 vector that post-multiplies <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>3x1 vector <code class="docutils literal notranslate"><span class="pre">v_A</span> <span class="pre">=</span> <span class="pre">R_AB</span> <span class="pre">*</span> <span class="pre">v_B</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>multiply(self: pydrake.math.RotationMatrix_[AutoDiffXd], v_B: numpy.ndarray[object[3, n]]) -&gt; numpy.ndarray[object[3, n]]</p></li>
</ol>
<p>Multiplies <code class="docutils literal notranslate"><span class="pre">this</span></code> RotationMatrix <code class="docutils literal notranslate"><span class="pre">R_AB</span></code> by the n vectors <code class="docutils literal notranslate"><span class="pre">v1</span></code>,
… <cite>vn</cite>, where each vector has 3 elements and is expressed in frame
B.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v_B</span></code>:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix whose n columns are regarded as arbitrary vectors
<code class="docutils literal notranslate"><span class="pre">v1</span></code>, … <cite>vn</cite> expressed in frame B.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">v_A</span></code>:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix whose n columns are vectors <code class="docutils literal notranslate"><span class="pre">v1</span></code>, … <cite>vn</cite>
expressed in frame A.</p>
</dd>
</dl>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="n">RollPitchYaw</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">rpy</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span><span class="w"> </span><span class="mf">0.2</span><span class="p">,</span><span class="w"> </span><span class="mf">0.3</span><span class="p">);</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">R_AB</span><span class="p">(</span><span class="n">rpy</span><span class="p">);</span><span class="w"></span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v_B</span><span class="p">;</span><span class="w"></span>
<span class="n">v_B</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Vector3d</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span><span class="w"></span>
<span class="n">v_B</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Vector3d</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">);</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v_A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">R_AB</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v_B</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</details></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-AutoDiffXd-.ProjectToRotationMatrix">
<span id="pydrake.math.RotationMatrix_[AutoDiffXd].ProjectToRotationMatrix"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ProjectToRotationMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-AutoDiffXd-.ProjectToRotationMatrix" title="Permalink to this definition"></a></dt>
<dd><p>Given an approximate rotation matrix M, finds the RotationMatrix R
closest to M. Closeness is measured with a matrix-2 norm (or
equivalently with a Frobenius norm). Hence, this method creates a
RotationMatrix R from a 3x3 matrix M by minimizing <code class="docutils literal notranslate"><span class="pre">‖R</span> <span class="pre">-</span> <span class="pre">M‖₂</span></code> (the
matrix-2 norm of (R-M)) subject to <code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">*</span> <span class="pre">Rᵀ</span> <span class="pre">=</span> <span class="pre">I</span></code>, where I is the 3x3
identity matrix. For this problem, closeness can also be measured by
forming the orthonormal matrix R whose elements minimize the
double-summation <code class="docutils literal notranslate"><span class="pre">∑ᵢ</span> <span class="pre">∑ⱼ</span> <span class="pre">(R(i,j)</span> <span class="pre">-</span> <span class="pre">M(i,j))²</span></code> where <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">=</span> <span class="pre">1:3,</span> <span class="pre">j</span> <span class="pre">=</span>
<span class="pre">1:3</span></code>, subject to <code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">*</span> <span class="pre">Rᵀ</span> <span class="pre">=</span> <span class="pre">I</span></code>. The square-root of this
double-summation is called the Frobenius norm.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M</span></code>:</dt><dd><p>a 3x3 matrix.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quality_factor</span></code>:</dt><dd><p>The quality of M as a rotation matrix. <code class="docutils literal notranslate"><span class="pre">quality_factor</span></code> = 1 is
perfect (M = R). <code class="docutils literal notranslate"><span class="pre">quality_factor</span></code> = 1.25 means that when M
multiplies a unit vector (magnitude 1), a vector of magnitude as
large as 1.25 may result. <code class="docutils literal notranslate"><span class="pre">quality_factor</span></code> = 0.8 means that when
M multiplies a unit vector, a vector of magnitude as small as 0.8
may result. <code class="docutils literal notranslate"><span class="pre">quality_factor</span></code> = 0 means M is singular, so at
least one of the bases related by matrix M does not span 3D space
(when M multiples a unit vector, a vector of magnitude as small as
0 may result).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>proper orthonormal matrix R that is closest to M.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>RuntimeError if R fails IsValid</strong><strong>(</strong><strong>R</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>William Kahan (UC Berkeley) and Hongkai Dai (Toyota Research
Institute) proved that for this problem, the same R that minimizes
the Frobenius norm also minimizes the matrix-2 norm (a.k.a an
induced-2 norm), which is defined [Dahleh, Section 4.2] as the
column matrix u which maximizes <code class="docutils literal notranslate"><span class="pre">‖(R</span> <span class="pre">-</span> <span class="pre">M)</span> <span class="pre">u‖</span> <span class="pre">/</span> <span class="pre">‖u‖</span></code>, where <code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">≠</span>
<span class="pre">0</span></code>. Since the matrix-2 norm of any matrix A is equal to the
maximum singular value of A, minimizing the matrix-2 norm of (R -
M) is equivalent to minimizing the maximum singular value of (R -
M).</p>
</div>
<ul class="simple">
<li><p>[Dahleh] “Lectures on Dynamic Systems and Controls: Electrical</p></li>
</ul>
<p>Engineering and Computer Science, Massachusetts Institute of Technology”
<a class="reference external" href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-241j-dynamic-systems-and-control-spring-2011/readings/MIT6_241JS11_chap04.pdf">https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-241j-dynamic-systems-and-control-spring-2011/readings/MIT6_241JS11_chap04.pdf</a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-AutoDiffXd-.row">
<span id="pydrake.math.RotationMatrix_[AutoDiffXd].row"></span><span class="sig-name descname"><span class="pre">row</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-AutoDiffXd-.row" title="Permalink to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> rotation matrix’s iᵗʰ row (i = 0, 1, 2). For <code class="docutils literal notranslate"><span class="pre">this</span></code>
rotation matrix R_AB (which relates right-handed sets of orthogonal
unit vectors Ax, Ay, Az to Bx, By, Bz), - row(0) returns Ax_B (Ax
expressed in terms of Bx, By, Bz). - row(1) returns Ay_B (Ay expressed
in terms of Bx, By, Bz). - row(2) returns Az_B (Az expressed in terms
of Bx, By, Bz).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">index</span></code>:</dt><dd><p>requested row index (0 &lt;= index &lt;= 2).</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>col(), matrix()</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>In Debug builds</strong><strong>, </strong><strong>asserts</strong><strong> (</strong><strong>0 &lt;= index &lt;= 2</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For efficiency and consistency with Eigen, this method returns the
same quantity returned by Eigen’s row() operator. The returned
quantity can be assigned in various ways, e.g., as <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">auto&amp;</span>
<span class="pre">Az_B</span> <span class="pre">=</span> <span class="pre">row(2);</span></code> or <code class="docutils literal notranslate"><span class="pre">RowVector3&lt;T&gt;</span> <span class="pre">Az_B</span> <span class="pre">=</span> <span class="pre">row(2);</span></code></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-AutoDiffXd-.set">
<span id="pydrake.math.RotationMatrix_[AutoDiffXd].set"></span><span class="sig-name descname"><span class="pre">set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-AutoDiffXd-.set" title="Permalink to this definition"></a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> RotationMatrix from a Matrix3.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R</span></code>:</dt><dd><p>an allegedly valid rotation matrix.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError in debug builds if R fails IsValid</strong><strong>(</strong><strong>R</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-AutoDiffXd-.ToAngleAxis">
<span id="pydrake.math.RotationMatrix_[AutoDiffXd].ToAngleAxis"></span><span class="sig-name descname"><span class="pre">ToAngleAxis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.common.eigen_geometry.html#pydrake.common.eigen_geometry.AngleAxis_" title="pydrake.common.eigen_geometry.AngleAxis_"><span class="pre">pydrake.common.eigen_geometry.AngleAxis_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-AutoDiffXd-.ToAngleAxis" title="Permalink to this definition"></a></dt>
<dd><p>Returns an AngleAxis <code class="docutils literal notranslate"><span class="pre">theta_lambda</span></code> containing an angle <code class="docutils literal notranslate"><span class="pre">theta</span></code>
and unit vector (axis direction) <code class="docutils literal notranslate"><span class="pre">lambda</span></code> that represents <code class="docutils literal notranslate"><span class="pre">this</span></code>
RotationMatrix.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The orientation and RotationMatrix associated with <code class="docutils literal notranslate"><span class="pre">theta</span> <span class="pre">*</span>
<span class="pre">lambda</span></code> is identical to that of <code class="docutils literal notranslate"><span class="pre">(-theta)</span> <span class="pre">*</span> <span class="pre">(-lambda)</span></code>. The
AngleAxis returned by this method chooses to have <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">theta</span> <span class="pre">&lt;=</span>
<span class="pre">pi</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>an AngleAxis with <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">theta</span> <span class="pre">&lt;=</span> <span class="pre">pi</span></code> and a unit vector
<code class="docutils literal notranslate"><span class="pre">lambda</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-AutoDiffXd-.ToQuaternion">
<span id="pydrake.math.RotationMatrix_[AutoDiffXd].ToQuaternion"></span><span class="sig-name descname"><span class="pre">ToQuaternion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.common.eigen_geometry.html#pydrake.common.eigen_geometry.Quaternion_" title="pydrake.common.eigen_geometry.Quaternion_"><span class="pre">pydrake.common.eigen_geometry.Quaternion_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-AutoDiffXd-.ToQuaternion" title="Permalink to this definition"></a></dt>
<dd><p>Returns a quaternion q that represents <code class="docutils literal notranslate"><span class="pre">this</span></code> RotationMatrix. Since
the quaternion <code class="docutils literal notranslate"><span class="pre">q</span></code> and <code class="docutils literal notranslate"><span class="pre">-q</span></code> represent the same RotationMatrix,
this method chooses to return a canonical quaternion, i.e., with q(0)
&gt;= 0.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-AutoDiffXd-.ToRollPitchYaw">
<span id="pydrake.math.RotationMatrix_[AutoDiffXd].ToRollPitchYaw"></span><span class="sig-name descname"><span class="pre">ToRollPitchYaw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RollPitchYaw_" title="pydrake.math.RollPitchYaw_"><span class="pre">pydrake.math.RollPitchYaw_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-AutoDiffXd-.ToRollPitchYaw" title="Permalink to this definition"></a></dt>
<dd><p>Returns a RollPitchYaw that represents <code class="docutils literal notranslate"><span class="pre">this</span></code> RotationMatrix, with
roll-pitch-yaw angles <code class="docutils literal notranslate"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code> in the range <code class="docutils literal notranslate"><span class="pre">-π</span> <span class="pre">&lt;=</span> <span class="pre">r</span> <span class="pre">&lt;=</span> <span class="pre">π</span></code>,
<cite>-π/2 &lt;= p &lt;= π/2</cite>, <code class="docutils literal notranslate"><span class="pre">-π</span> <span class="pre">&lt;=</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">π</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This new high-accuracy algorithm avoids numerical round-off issues
encountered by some algorithms when pitch is within 1E-6 of π/2 or
-π/2.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-AutoDiffXd-.transpose">
<span id="pydrake.math.RotationMatrix_[AutoDiffXd].transpose"></span><span class="sig-name descname"><span class="pre">transpose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-AutoDiffXd-.transpose" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-Expression">
<span id="pydrake.math.RotationMatrix_[Expression]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">RotationMatrix_[Expression]</span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-Expression" title="Permalink to this definition"></a></dt>
<dd><p>This class represents a 3x3 rotation matrix between two arbitrary
frames A and B and helps ensure users create valid rotation matrices.
This class relates right-handed orthogonal unit vectors Ax, Ay, Az
fixed in frame A to right-handed orthogonal unit vectors Bx, By, Bz
fixed in frame B. The monogram notation for the rotation matrix
relating A to B is <code class="docutils literal notranslate"><span class="pre">R_AB</span></code>. An example that gives context to this
rotation matrix is <code class="docutils literal notranslate"><span class="pre">v_A</span> <span class="pre">=</span> <span class="pre">R_AB</span> <span class="pre">*</span> <span class="pre">v_B</span></code>, where <code class="docutils literal notranslate"><span class="pre">v_B</span></code> denotes an
arbitrary vector v expressed in terms of Bx, By, Bz and <code class="docutils literal notranslate"><span class="pre">v_A</span></code>
denotes vector v expressed in terms of Ax, Ay, Az. See
multibody_quantities for monogram notation for dynamics. See
orientation_discussion “a discussion on rotation matrices”.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class does not store the frames associated with a rotation
matrix nor does it enforce strict proper usage of this class with
vectors.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When assertions are enabled, several methods in this class perform
a validity check and throw RuntimeError if the rotation matrix is
invalid. When assertions are disabled, many of these validity
checks are skipped (which helps improve speed). These validity
tests are only performed for scalar types for which
drake::scalar_predicate&lt;T&gt;::is_bool is <code class="docutils literal notranslate"><span class="pre">True</span></code>. For instance,
validity checks are not performed when T is symbolic::Expression.</p>
</div>
<dl class="simple">
<dt>Authors:</dt><dd><p>Paul Mitiguy (2018) Original author.</p>
</dd>
<dt>Authors:</dt><dd><p>Drake team (see <a class="reference external" href="https://drake.mit.edu/credits">https://drake.mit.edu/credits</a>).</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-Expression-.__init__">
<span id="pydrake.math.RotationMatrix_[Expression].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.RotationMatrix_-Expression-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.math.RotationMatrix_[Expression]) -&gt; None</p></li>
</ol>
<p>Constructs a 3x3 identity RotationMatrix – which corresponds to
aligning two frames (so that unit vectors Ax = Bx, Ay = By, Az = Bz).</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.math.RotationMatrix_[Expression], other: pydrake.math.RotationMatrix_[Expression]) -&gt; None</p></li>
<li><p>__init__(self: pydrake.math.RotationMatrix_[Expression], R: numpy.ndarray[object[3, 3]]) -&gt; None</p></li>
</ol>
<p>Constructs a RotationMatrix from a Matrix3.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R</span></code>:</dt><dd><p>an allegedly valid rotation matrix.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError in debug builds if R fails IsValid</strong><strong>(</strong><strong>R</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.math.RotationMatrix_[Expression], quaternion: pydrake.common.eigen_geometry.Quaternion_[Expression]) -&gt; None</p></li>
</ol>
<p>Constructs a RotationMatrix from an Eigen::Quaternion.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quaternion</span></code>:</dt><dd><p>a non-zero, finite quaternion which may or may not have unit
length [i.e., <code class="docutils literal notranslate"><span class="pre">quaternion.norm()</span></code> does not have to be 1].</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError in debug builds if the rotation matrix R that is</strong> – </p></li>
<li><p><strong>built from quaternion fails IsValid</strong><strong>(</strong><strong>R</strong><strong>)</strong><strong> For example</strong><strong>, </strong><strong>an</strong> – </p></li>
<li><p><strong>exception is thrown if quaternion is zero</strong><strong> or </strong><strong>contains a NaN or</strong> – </p></li>
<li><p><strong>infinity.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method has the effect of normalizing its <code class="docutils literal notranslate"><span class="pre">quaternion</span></code>
argument, without the inefficiency of the square-root associated
with normalization.</p>
</div>
<ol class="arabic simple" start="5">
<li><p>__init__(self: pydrake.math.RotationMatrix_[Expression], theta_lambda: pydrake.common.eigen_geometry.AngleAxis_[Expression]) -&gt; None</p></li>
</ol>
<p>Constructs a RotationMatrix from an Eigen::AngleAxis.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta_lambda</span></code>:</dt><dd><p>an Eigen::AngleAxis whose associated axis (vector direction herein
called <code class="docutils literal notranslate"><span class="pre">lambda</span></code>) is non-zero and finite, but which may or may
not have unit length [i.e., <code class="docutils literal notranslate"><span class="pre">lambda.norm()</span></code> does not have to be
1].</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError in debug builds if the rotation matrix R that is</strong> – </p></li>
<li><p><strong>built from theta_lambda fails IsValid</strong><strong>(</strong><strong>R</strong><strong>)</strong><strong> For example</strong><strong>, </strong><strong>an</strong> – </p></li>
<li><p><strong>exception is thrown if lambda is zero</strong><strong> or </strong><strong>contains a NaN or</strong> – </p></li>
<li><p><strong>infinity.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="6">
<li><p>__init__(self: pydrake.math.RotationMatrix_[Expression], rpy: pydrake.math.RollPitchYaw_[Expression]) -&gt; None</p></li>
</ol>
<p>Constructs a RotationMatrix from an RollPitchYaw. In other words,
makes the RotationMatrix for a Space-fixed (extrinsic) X-Y-Z rotation
by “roll-pitch-yaw” angles <code class="docutils literal notranslate"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code>, which is equivalent to a
Body-fixed (intrinsic) Z-Y-X rotation by “yaw-pitch-roll” angles <code class="docutils literal notranslate"><span class="pre">[y,</span>
<span class="pre">p,</span> <span class="pre">r]</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rpy</span></code>:</dt><dd><p>a RollPitchYaw which is a Space-fixed (extrinsic) X-Y-Z rotation
with “roll-pitch-yaw” angles <code class="docutils literal notranslate"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code> or equivalently a Body-
fixed (intrinsic) Z-Y-X rotation with “yaw-pitch-roll” angles
<code class="docutils literal notranslate"><span class="pre">[y,</span> <span class="pre">p,</span> <span class="pre">r]</span></code>.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">R_AD</span></code>:</dt><dd><p>, rotation matrix relating frame A to frame D.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Denoting roll <code class="docutils literal notranslate"><span class="pre">r</span></code>, pitch <code class="docutils literal notranslate"><span class="pre">p</span></code>, yaw <code class="docutils literal notranslate"><span class="pre">y</span></code>, this method returns a
rotation matrix <code class="docutils literal notranslate"><span class="pre">R_AD</span></code> equal to the matrix multiplication shown
below.</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>⎡cos(y) -sin(y)  0⎤   ⎡ cos(p)  0  sin(p)⎤   ⎡1      0        0 ⎤
R_AD = ⎢sin(y)  cos(y)  0⎥ * ⎢     0   1      0 ⎥ * ⎢0  cos(r)  -sin(r)⎥
       ⎣    0       0   1⎦   ⎣-sin(p)  0  cos(p)⎦   ⎣0  sin(r)   cos(r)⎦
     =       R_AB          *        R_BC          *        R_CD
</pre></div>
</div>
</details><div class="admonition note">
<p class="admonition-title">Note</p>
<p>In this discussion, A is the Space frame and D is the Body frame.
One way to visualize this rotation sequence is by introducing
intermediate frames B and C (useful constructs to understand this
rotation sequence). Initially, the frames are aligned so <code class="docutils literal notranslate"><span class="pre">Di</span> <span class="pre">=</span> <span class="pre">Ci</span>
<span class="pre">=</span> <span class="pre">Bi</span> <span class="pre">=</span> <span class="pre">Ai</span> <span class="pre">(i</span> <span class="pre">=</span> <span class="pre">x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code>. Then D is subjected to successive
right-handed rotations relative to A.</p>
</div>
<ul class="simple">
<li><p>1st rotation R_CD: Frame D rotates relative to frames C, B, A by a</p></li>
</ul>
<p>roll angle <code class="docutils literal notranslate"><span class="pre">r</span></code> about <code class="docutils literal notranslate"><span class="pre">Dx</span> <span class="pre">=</span> <span class="pre">Cx</span></code>.  Note: D and C are no longer aligned.</p>
<ul class="simple">
<li><p>2nd rotation R_BC: Frames D, C (collectively – as if welded together)</p></li>
</ul>
<p>rotate relative to frame B, A by a pitch angle <code class="docutils literal notranslate"><span class="pre">p</span></code> about <code class="docutils literal notranslate"><span class="pre">Cy</span> <span class="pre">=</span> <span class="pre">By</span></code>.
Note: C and B are no longer aligned.</p>
<ul class="simple">
<li><p>3rd rotation R_AB: Frames D, C, B (collectively – as if welded)</p></li>
</ul>
<p>rotate relative to frame A by a roll angle <code class="docutils literal notranslate"><span class="pre">y</span></code> about <code class="docutils literal notranslate"><span class="pre">Bz</span> <span class="pre">=</span> <span class="pre">Az</span></code>.
Note: B and A are no longer aligned.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method constructs a RotationMatrix from a RollPitchYaw.
Vice-versa, there are high-accuracy RollPitchYaw
constructor/methods that form a RollPitchYaw from a rotation
matrix.</p>
</div>
</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-Expression-.cast">
<span id="pydrake.math.RotationMatrix_[Expression].cast"></span><em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">cast</span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-Expression-.cast" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">cast[Expression]</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-Expression-.cast-Expression">
<span id="pydrake.math.RotationMatrix_[Expression].cast[Expression]"></span><span class="sig-name descname"><span class="pre">cast[Expression]</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-Expression-.cast-Expression" title="Permalink to this definition"></a></dt>
<dd><p>Creates a RotationMatrix templatized on a scalar type U from a
RotationMatrix templatized on scalar type T. For example,</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">Identity</span><span class="p">();</span><span class="w"></span>
<span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">source</span><span class="p">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">AutoDiffXd</span><span class="o">&gt;</span><span class="p">();</span><span class="w"></span>
</pre></div>
</div>
</details><dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">U</span></code>:</dt><dd><p>Scalar type on which the returned RotationMatrix is templated.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">RotationMatrix&lt;From&gt;::cast&lt;To&gt;()</span></code> creates a new
<code class="docutils literal notranslate"><span class="pre">RotationMatrix&lt;To&gt;</span></code> from a <code class="docutils literal notranslate"><span class="pre">RotationMatrix&lt;From&gt;</span></code> but only if
type <code class="docutils literal notranslate"><span class="pre">To</span></code> is constructible from type <code class="docutils literal notranslate"><span class="pre">From</span></code>. This cast method
works in accordance with Eigen’s cast method for Eigen’s Matrix3
that underlies this RotationMatrix. For example, Eigen currently
allows cast from type double to AutoDiffXd, but not vice-versa.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-Expression-.col">
<span id="pydrake.math.RotationMatrix_[Expression].col"></span><span class="sig-name descname"><span class="pre">col</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-Expression-.col" title="Permalink to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> rotation matrix’s iᵗʰ column (i = 0, 1, 2). For
<code class="docutils literal notranslate"><span class="pre">this</span></code> rotation matrix R_AB (which relates right-handed sets of
orthogonal unit vectors Ax, Ay, Az to Bx, By, Bz), - col(0) returns
Bx_A (Bx expressed in terms of Ax, Ay, Az). - col(1) returns By_A (By
expressed in terms of Ax, Ay, Az). - col(2) returns Bz_A (Bz expressed
in terms of Ax, Ay, Az).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">index</span></code>:</dt><dd><p>requested column index (0 &lt;= index &lt;= 2).</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>row(), matrix()</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>In Debug builds</strong><strong>, </strong><strong>asserts</strong><strong> (</strong><strong>0 &lt;= index &lt;= 2</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For efficiency and consistency with Eigen, this method returns the
same quantity returned by Eigen’s col() operator. The returned
quantity can be assigned in various ways, e.g., as <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">auto&amp;</span>
<span class="pre">Bz_A</span> <span class="pre">=</span> <span class="pre">col(2);</span></code> or <code class="docutils literal notranslate"><span class="pre">Vector3&lt;T&gt;</span> <span class="pre">Bz_A</span> <span class="pre">=</span> <span class="pre">col(2);</span></code></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-Expression-.Identity">
<span id="pydrake.math.RotationMatrix_[Expression].Identity"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Identity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-Expression-.Identity" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-Expression-.inverse">
<span id="pydrake.math.RotationMatrix_[Expression].inverse"></span><span class="sig-name descname"><span class="pre">inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-Expression-.inverse" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-Expression-.InvertAndCompose">
<span id="pydrake.math.RotationMatrix_[Expression].InvertAndCompose"></span><span class="sig-name descname"><span class="pre">InvertAndCompose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-Expression-.InvertAndCompose" title="Permalink to this definition"></a></dt>
<dd><p>Calculates the product of <code class="docutils literal notranslate"><span class="pre">this</span></code> inverted and another
RotationMatrix. If you consider <code class="docutils literal notranslate"><span class="pre">this</span></code> to be the rotation matrix
R_AB, and <code class="docutils literal notranslate"><span class="pre">other</span></code> to be R_AC, then this method returns R_BC = R_AB⁻¹
* R_AC. For T==double, this method can be <em>much</em> faster than inverting
first and then performing the composition because it can take
advantage of the orthogonality of rotation matrices. On some platforms
it can use SIMD instructions for further speedups.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other</span></code>:</dt><dd><p>RotationMatrix that post-multiplies <code class="docutils literal notranslate"><span class="pre">this</span></code> inverted.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">R_BC</span></code>:</dt><dd><p>where R_BC = this⁻¹ * other.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is possible (albeit improbable) to create an invalid rotation
matrix by accumulating round-off error with a large number of
multiplies.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-Expression-.IsExactlyIdentity">
<span id="pydrake.math.RotationMatrix_[Expression].IsExactlyIdentity"></span><span class="sig-name descname"><span class="pre">IsExactlyIdentity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Formula" title="pydrake.symbolic.Formula"><span class="pre">pydrake.symbolic.Formula</span></a></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-Expression-.IsExactlyIdentity" title="Permalink to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">this</span></code> is exactly equal to the identity matrix.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>IsNearlyIdentity().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-Expression-.IsNearlyIdentity">
<span id="pydrake.math.RotationMatrix_[Expression].IsNearlyIdentity"></span><span class="sig-name descname"><span class="pre">IsNearlyIdentity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">2.842170943040401e-14</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Formula" title="pydrake.symbolic.Formula"><span class="pre">pydrake.symbolic.Formula</span></a></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-Expression-.IsNearlyIdentity" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if <code class="docutils literal notranslate"><span class="pre">this</span></code> is within tolerance of the identity
RigidTransform.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">tolerance</span></code>:</dt><dd><p>non-negative number that is generally the default value, namely
RotationMatrix::get_internal_tolerance_for_orthonormality().</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>IsExactlyIdentity().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-Expression-.IsValid">
<span id="pydrake.math.RotationMatrix_[Expression].IsValid"></span><span class="sig-name descname"><span class="pre">IsValid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Formula" title="pydrake.symbolic.Formula"><span class="pre">pydrake.symbolic.Formula</span></a></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-Expression-.IsValid" title="Permalink to this definition"></a></dt>
<dd><p>Tests if <code class="docutils literal notranslate"><span class="pre">this</span></code> rotation matrix R is a proper orthonormal rotation
matrix to within the threshold of
get_internal_tolerance_for_orthonormality().</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">this</span></code> is a valid rotation matrix.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-Expression-.MakeFromOneVector">
<span id="pydrake.math.RotationMatrix_[Expression].MakeFromOneVector"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeFromOneVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">b_A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-Expression-.MakeFromOneVector" title="Permalink to this definition"></a></dt>
<dd><p>Creates a 3D right-handed orthonormal basis B from a given vector b_A,
returned as a rotation matrix R_AB. It consists of orthogonal unit
vectors u_A, v_A, w_A where u_A is the normalized b_A in the
axis_index column of R_AB and v_A has one element which is zero. If an
element of b_A is zero, then one element of w_A is 1 and the other two
elements are 0.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b_A</span></code>:</dt><dd><p>vector expressed in frame A that when normalized as u_A =
b_A.normalized() represents Bx, By, or Bz (depending on
axis_index).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">axis_index</span></code>:</dt><dd><p>The index ∈ {0, 1, 2} of the unit vector associated with u_A, 0
means u_A is Bx, 1 means u_A is By, and 2 means u_A is Bz.</p>
</dd>
<dt>Precondition:</dt><dd><p>axis_index is 0 or 1 or 2.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if b_A cannot be made into a unit vector because b_A</strong> – </p></li>
<li><p><strong>contains a NaN</strong><strong> or </strong><strong>infinity</strong><strong> or </strong><strong>b_A &lt; 1.0E-10.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MakeFromOneUnitVector() if b_A is known to already be unit length.</p>
</div>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">R_AB</span></code>:</dt><dd><p>the rotation matrix with properties as described above.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-Expression-.MakeUnchecked">
<span id="pydrake.math.RotationMatrix_[Expression].MakeUnchecked"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeUnchecked</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-Expression-.MakeUnchecked" title="Permalink to this definition"></a></dt>
<dd><p>(Advanced) Makes a RotationMatrix from a Matrix3. No check is
performed to test whether or not the parameter R is a valid rotation
matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-Expression-.MakeXRotation">
<span id="pydrake.math.RotationMatrix_[Expression].MakeXRotation"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeXRotation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-Expression-.MakeXRotation" title="Permalink to this definition"></a></dt>
<dd><p>Makes the RotationMatrix <code class="docutils literal notranslate"><span class="pre">R_AB</span></code> associated with rotating a frame B
relative to a frame A by an angle <code class="docutils literal notranslate"><span class="pre">theta</span></code> about unit vector <code class="docutils literal notranslate"><span class="pre">Ax</span> <span class="pre">=</span>
<span class="pre">Bx</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt><dd><p>radian measure of rotation angle about Ax.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Orientation is same as Eigen::AngleAxis&lt;T&gt;(theta,
Vector3d::UnitX().</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">R_AB</span></code> relates two frames A and B having unit vectors Ax, Ay, Az
and Bx, By, Bz. Initially, <code class="docutils literal notranslate"><span class="pre">Bx</span> <span class="pre">=</span> <span class="pre">Ax</span></code>, <cite>By = Ay</cite>, <code class="docutils literal notranslate"><span class="pre">Bz</span> <span class="pre">=</span> <span class="pre">Az</span></code>,
then B undergoes a right-handed rotation relative to A by an angle
<code class="docutils literal notranslate"><span class="pre">theta</span></code> about <code class="docutils literal notranslate"><span class="pre">Ax</span> <span class="pre">=</span> <span class="pre">Bx</span></code>.</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>⎡ 1       0                 0  ⎤
R_AB = ⎢ 0   cos(theta)   -sin(theta) ⎥
       ⎣ 0   sin(theta)    cos(theta) ⎦
</pre></div>
</div>
</details></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-Expression-.MakeYRotation">
<span id="pydrake.math.RotationMatrix_[Expression].MakeYRotation"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeYRotation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-Expression-.MakeYRotation" title="Permalink to this definition"></a></dt>
<dd><p>Makes the RotationMatrix <code class="docutils literal notranslate"><span class="pre">R_AB</span></code> associated with rotating a frame B
relative to a frame A by an angle <code class="docutils literal notranslate"><span class="pre">theta</span></code> about unit vector <code class="docutils literal notranslate"><span class="pre">Ay</span> <span class="pre">=</span>
<span class="pre">By</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt><dd><p>radian measure of rotation angle about Ay.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Orientation is same as Eigen::AngleAxis&lt;T&gt;(theta,
Vector3d::UnitY().</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">R_AB</span></code> relates two frames A and B having unit vectors Ax, Ay, Az
and Bx, By, Bz. Initially, <code class="docutils literal notranslate"><span class="pre">Bx</span> <span class="pre">=</span> <span class="pre">Ax</span></code>, <cite>By = Ay</cite>, <code class="docutils literal notranslate"><span class="pre">Bz</span> <span class="pre">=</span> <span class="pre">Az</span></code>,
then B undergoes a right-handed rotation relative to A by an angle
<code class="docutils literal notranslate"><span class="pre">theta</span></code> about <code class="docutils literal notranslate"><span class="pre">Ay</span> <span class="pre">=</span> <span class="pre">By</span></code>.</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>⎡  cos(theta)   0   sin(theta) ⎤
R_AB = ⎢          0    1           0  ⎥
       ⎣ -sin(theta)   0   cos(theta) ⎦
</pre></div>
</div>
</details></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-Expression-.MakeZRotation">
<span id="pydrake.math.RotationMatrix_[Expression].MakeZRotation"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeZRotation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">theta</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-Expression-.MakeZRotation" title="Permalink to this definition"></a></dt>
<dd><p>Makes the RotationMatrix <code class="docutils literal notranslate"><span class="pre">R_AB</span></code> associated with rotating a frame B
relative to a frame A by an angle <code class="docutils literal notranslate"><span class="pre">theta</span></code> about unit vector <code class="docutils literal notranslate"><span class="pre">Az</span> <span class="pre">=</span>
<span class="pre">Bz</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt><dd><p>radian measure of rotation angle about Az.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Orientation is same as Eigen::AngleAxis&lt;T&gt;(theta,
Vector3d::UnitZ().</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">R_AB</span></code> relates two frames A and B having unit vectors Ax, Ay, Az
and Bx, By, Bz. Initially, <code class="docutils literal notranslate"><span class="pre">Bx</span> <span class="pre">=</span> <span class="pre">Ax</span></code>, <cite>By = Ay</cite>, <code class="docutils literal notranslate"><span class="pre">Bz</span> <span class="pre">=</span> <span class="pre">Az</span></code>,
then B undergoes a right-handed rotation relative to A by an angle
<code class="docutils literal notranslate"><span class="pre">theta</span></code> about <code class="docutils literal notranslate"><span class="pre">Az</span> <span class="pre">=</span> <span class="pre">Bz</span></code>.</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span>⎡ cos(theta)  -sin(theta)   0 ⎤
R_AB = ⎢ sin(theta)   cos(theta)   0 ⎥
       ⎣         0            0    1 ⎦
</pre></div>
</div>
</details></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-Expression-.matrix">
<span id="pydrake.math.RotationMatrix_[Expression].matrix"></span><span class="sig-name descname"><span class="pre">matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-Expression-.matrix" title="Permalink to this definition"></a></dt>
<dd><p>Returns the Matrix3 underlying a RotationMatrix.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>col(), row()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-Expression-.multiply">
<span id="pydrake.math.RotationMatrix_[Expression].multiply"></span><span class="sig-name descname"><span class="pre">multiply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.RotationMatrix_-Expression-.multiply" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>multiply(self: pydrake.math.RotationMatrix_[Expression], other: pydrake.math.RotationMatrix_[Expression]) -&gt; pydrake.math.RotationMatrix_[Expression]</p></li>
</ol>
<p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> rotation matrix <code class="docutils literal notranslate"><span class="pre">R_AB</span></code> multiplied by <code class="docutils literal notranslate"><span class="pre">other</span></code>
rotation matrix <code class="docutils literal notranslate"><span class="pre">R_BC</span></code>, returning the composition <code class="docutils literal notranslate"><span class="pre">R_AB</span> <span class="pre">*</span> <span class="pre">R_BC</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other</span></code>:</dt><dd><p>RotationMatrix that post-multiplies <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>rotation matrix that results from <code class="docutils literal notranslate"><span class="pre">this</span></code> multiplied by
<code class="docutils literal notranslate"><span class="pre">other</span></code>.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is possible (albeit improbable) to create an invalid rotation
matrix by accumulating round-off error with a large number of
multiplies.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>multiply(self: pydrake.math.RotationMatrix_[Expression], v_B: numpy.ndarray[object[3, 1]]) -&gt; numpy.ndarray[object[3, 1]]</p></li>
</ol>
<p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> rotation matrix <code class="docutils literal notranslate"><span class="pre">R_AB</span></code> multiplied by an
arbitrary Vector3 expressed in the B frame.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v_B</span></code>:</dt><dd><p>3x1 vector that post-multiplies <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>3x1 vector <code class="docutils literal notranslate"><span class="pre">v_A</span> <span class="pre">=</span> <span class="pre">R_AB</span> <span class="pre">*</span> <span class="pre">v_B</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>multiply(self: pydrake.math.RotationMatrix_[Expression], v_B: numpy.ndarray[object[3, n]]) -&gt; numpy.ndarray[object[3, n]]</p></li>
</ol>
<p>Multiplies <code class="docutils literal notranslate"><span class="pre">this</span></code> RotationMatrix <code class="docutils literal notranslate"><span class="pre">R_AB</span></code> by the n vectors <code class="docutils literal notranslate"><span class="pre">v1</span></code>,
… <cite>vn</cite>, where each vector has 3 elements and is expressed in frame
B.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v_B</span></code>:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix whose n columns are regarded as arbitrary vectors
<code class="docutils literal notranslate"><span class="pre">v1</span></code>, … <cite>vn</cite> expressed in frame B.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">v_A</span></code>:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">3</span> <span class="pre">x</span> <span class="pre">n</span></code> matrix whose n columns are vectors <code class="docutils literal notranslate"><span class="pre">v1</span></code>, … <cite>vn</cite>
expressed in frame A.</p>
</dd>
</dl>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span><span class="w"> </span><span class="n">RollPitchYaw</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">rpy</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span><span class="w"> </span><span class="mf">0.2</span><span class="p">,</span><span class="w"> </span><span class="mf">0.3</span><span class="p">);</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">RotationMatrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">R_AB</span><span class="p">(</span><span class="n">rpy</span><span class="p">);</span><span class="w"></span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v_B</span><span class="p">;</span><span class="w"></span>
<span class="n">v_B</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Vector3d</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">);</span><span class="w"></span>
<span class="n">v_B</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Vector3d</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">);</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v_A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">R_AB</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v_B</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</details></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-Expression-.ProjectToRotationMatrix">
<span id="pydrake.math.RotationMatrix_[Expression].ProjectToRotationMatrix"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ProjectToRotationMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-Expression-.ProjectToRotationMatrix" title="Permalink to this definition"></a></dt>
<dd><p>Given an approximate rotation matrix M, finds the RotationMatrix R
closest to M. Closeness is measured with a matrix-2 norm (or
equivalently with a Frobenius norm). Hence, this method creates a
RotationMatrix R from a 3x3 matrix M by minimizing <code class="docutils literal notranslate"><span class="pre">‖R</span> <span class="pre">-</span> <span class="pre">M‖₂</span></code> (the
matrix-2 norm of (R-M)) subject to <code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">*</span> <span class="pre">Rᵀ</span> <span class="pre">=</span> <span class="pre">I</span></code>, where I is the 3x3
identity matrix. For this problem, closeness can also be measured by
forming the orthonormal matrix R whose elements minimize the
double-summation <code class="docutils literal notranslate"><span class="pre">∑ᵢ</span> <span class="pre">∑ⱼ</span> <span class="pre">(R(i,j)</span> <span class="pre">-</span> <span class="pre">M(i,j))²</span></code> where <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">=</span> <span class="pre">1:3,</span> <span class="pre">j</span> <span class="pre">=</span>
<span class="pre">1:3</span></code>, subject to <code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">*</span> <span class="pre">Rᵀ</span> <span class="pre">=</span> <span class="pre">I</span></code>. The square-root of this
double-summation is called the Frobenius norm.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M</span></code>:</dt><dd><p>a 3x3 matrix.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quality_factor</span></code>:</dt><dd><p>The quality of M as a rotation matrix. <code class="docutils literal notranslate"><span class="pre">quality_factor</span></code> = 1 is
perfect (M = R). <code class="docutils literal notranslate"><span class="pre">quality_factor</span></code> = 1.25 means that when M
multiplies a unit vector (magnitude 1), a vector of magnitude as
large as 1.25 may result. <code class="docutils literal notranslate"><span class="pre">quality_factor</span></code> = 0.8 means that when
M multiplies a unit vector, a vector of magnitude as small as 0.8
may result. <code class="docutils literal notranslate"><span class="pre">quality_factor</span></code> = 0 means M is singular, so at
least one of the bases related by matrix M does not span 3D space
(when M multiples a unit vector, a vector of magnitude as small as
0 may result).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>proper orthonormal matrix R that is closest to M.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>RuntimeError if R fails IsValid</strong><strong>(</strong><strong>R</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>William Kahan (UC Berkeley) and Hongkai Dai (Toyota Research
Institute) proved that for this problem, the same R that minimizes
the Frobenius norm also minimizes the matrix-2 norm (a.k.a an
induced-2 norm), which is defined [Dahleh, Section 4.2] as the
column matrix u which maximizes <code class="docutils literal notranslate"><span class="pre">‖(R</span> <span class="pre">-</span> <span class="pre">M)</span> <span class="pre">u‖</span> <span class="pre">/</span> <span class="pre">‖u‖</span></code>, where <code class="docutils literal notranslate"><span class="pre">u</span> <span class="pre">≠</span>
<span class="pre">0</span></code>. Since the matrix-2 norm of any matrix A is equal to the
maximum singular value of A, minimizing the matrix-2 norm of (R -
M) is equivalent to minimizing the maximum singular value of (R -
M).</p>
</div>
<ul class="simple">
<li><p>[Dahleh] “Lectures on Dynamic Systems and Controls: Electrical</p></li>
</ul>
<p>Engineering and Computer Science, Massachusetts Institute of Technology”
<a class="reference external" href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-241j-dynamic-systems-and-control-spring-2011/readings/MIT6_241JS11_chap04.pdf">https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-241j-dynamic-systems-and-control-spring-2011/readings/MIT6_241JS11_chap04.pdf</a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-Expression-.row">
<span id="pydrake.math.RotationMatrix_[Expression].row"></span><span class="sig-name descname"><span class="pre">row</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-Expression-.row" title="Permalink to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> rotation matrix’s iᵗʰ row (i = 0, 1, 2). For <code class="docutils literal notranslate"><span class="pre">this</span></code>
rotation matrix R_AB (which relates right-handed sets of orthogonal
unit vectors Ax, Ay, Az to Bx, By, Bz), - row(0) returns Ax_B (Ax
expressed in terms of Bx, By, Bz). - row(1) returns Ay_B (Ay expressed
in terms of Bx, By, Bz). - row(2) returns Az_B (Az expressed in terms
of Bx, By, Bz).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">index</span></code>:</dt><dd><p>requested row index (0 &lt;= index &lt;= 2).</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>col(), matrix()</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>In Debug builds</strong><strong>, </strong><strong>asserts</strong><strong> (</strong><strong>0 &lt;= index &lt;= 2</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For efficiency and consistency with Eigen, this method returns the
same quantity returned by Eigen’s row() operator. The returned
quantity can be assigned in various ways, e.g., as <code class="docutils literal notranslate"><span class="pre">const</span> <span class="pre">auto&amp;</span>
<span class="pre">Az_B</span> <span class="pre">=</span> <span class="pre">row(2);</span></code> or <code class="docutils literal notranslate"><span class="pre">RowVector3&lt;T&gt;</span> <span class="pre">Az_B</span> <span class="pre">=</span> <span class="pre">row(2);</span></code></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-Expression-.set">
<span id="pydrake.math.RotationMatrix_[Expression].set"></span><span class="sig-name descname"><span class="pre">set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-Expression-.set" title="Permalink to this definition"></a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> RotationMatrix from a Matrix3.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R</span></code>:</dt><dd><p>an allegedly valid rotation matrix.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError in debug builds if R fails IsValid</strong><strong>(</strong><strong>R</strong><strong>)</strong><strong></strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-Expression-.ToAngleAxis">
<span id="pydrake.math.RotationMatrix_[Expression].ToAngleAxis"></span><span class="sig-name descname"><span class="pre">ToAngleAxis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.common.eigen_geometry.html#pydrake.common.eigen_geometry.AngleAxis_" title="pydrake.common.eigen_geometry.AngleAxis_"><span class="pre">pydrake.common.eigen_geometry.AngleAxis_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-Expression-.ToAngleAxis" title="Permalink to this definition"></a></dt>
<dd><p>Returns an AngleAxis <code class="docutils literal notranslate"><span class="pre">theta_lambda</span></code> containing an angle <code class="docutils literal notranslate"><span class="pre">theta</span></code>
and unit vector (axis direction) <code class="docutils literal notranslate"><span class="pre">lambda</span></code> that represents <code class="docutils literal notranslate"><span class="pre">this</span></code>
RotationMatrix.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The orientation and RotationMatrix associated with <code class="docutils literal notranslate"><span class="pre">theta</span> <span class="pre">*</span>
<span class="pre">lambda</span></code> is identical to that of <code class="docutils literal notranslate"><span class="pre">(-theta)</span> <span class="pre">*</span> <span class="pre">(-lambda)</span></code>. The
AngleAxis returned by this method chooses to have <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">theta</span> <span class="pre">&lt;=</span>
<span class="pre">pi</span></code>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>an AngleAxis with <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">theta</span> <span class="pre">&lt;=</span> <span class="pre">pi</span></code> and a unit vector
<code class="docutils literal notranslate"><span class="pre">lambda</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-Expression-.ToQuaternion">
<span id="pydrake.math.RotationMatrix_[Expression].ToQuaternion"></span><span class="sig-name descname"><span class="pre">ToQuaternion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.common.eigen_geometry.html#pydrake.common.eigen_geometry.Quaternion_" title="pydrake.common.eigen_geometry.Quaternion_"><span class="pre">pydrake.common.eigen_geometry.Quaternion_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-Expression-.ToQuaternion" title="Permalink to this definition"></a></dt>
<dd><p>Returns a quaternion q that represents <code class="docutils literal notranslate"><span class="pre">this</span></code> RotationMatrix. Since
the quaternion <code class="docutils literal notranslate"><span class="pre">q</span></code> and <code class="docutils literal notranslate"><span class="pre">-q</span></code> represent the same RotationMatrix,
this method chooses to return a canonical quaternion, i.e., with q(0)
&gt;= 0.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-Expression-.ToRollPitchYaw">
<span id="pydrake.math.RotationMatrix_[Expression].ToRollPitchYaw"></span><span class="sig-name descname"><span class="pre">ToRollPitchYaw</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RollPitchYaw_" title="pydrake.math.RollPitchYaw_"><span class="pre">pydrake.math.RollPitchYaw_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-Expression-.ToRollPitchYaw" title="Permalink to this definition"></a></dt>
<dd><p>Returns a RollPitchYaw that represents <code class="docutils literal notranslate"><span class="pre">this</span></code> RotationMatrix, with
roll-pitch-yaw angles <code class="docutils literal notranslate"><span class="pre">[r,</span> <span class="pre">p,</span> <span class="pre">y]</span></code> in the range <code class="docutils literal notranslate"><span class="pre">-π</span> <span class="pre">&lt;=</span> <span class="pre">r</span> <span class="pre">&lt;=</span> <span class="pre">π</span></code>,
<cite>-π/2 &lt;= p &lt;= π/2</cite>, <code class="docutils literal notranslate"><span class="pre">-π</span> <span class="pre">&lt;=</span> <span class="pre">y</span> <span class="pre">&lt;=</span> <span class="pre">π</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This new high-accuracy algorithm avoids numerical round-off issues
encountered by some algorithms when pitch is within 1E-6 of π/2 or
-π/2.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.math.RotationMatrix_-Expression-.transpose">
<span id="pydrake.math.RotationMatrix_[Expression].transpose"></span><span class="sig-name descname"><span class="pre">transpose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RotationMatrix_" title="pydrake.math.RotationMatrix_"><span class="pre">pydrake.math.RotationMatrix_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.RotationMatrix_-Expression-.transpose" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.sin">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">sin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.sin" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>sin(arg0: float) -&gt; float</p></li>
<li><p>sin(arg0: pydrake.autodiffutils.AutoDiffXd) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
<li><p>sin(arg0: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</p></li>
</ol>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.sinh">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">sinh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.sinh" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>sinh(arg0: float) -&gt; float</p></li>
<li><p>sinh(arg0: pydrake.autodiffutils.AutoDiffXd) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
<li><p>sinh(arg0: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</p></li>
</ol>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.SoftOverMax">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">SoftOverMax</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.SoftOverMax" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SoftOverMax(x: list[float], alpha: float = 1.0) -&gt; float</p></li>
</ol>
<p>Computes a smooth over approximation of max function, namely
SoftOverMax(x) &gt;= max(x). Mathematically we compute this as (log (∑ᵢ
exp(αxᵢ))) / α.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">x</span></code>:</dt><dd><p>The vector for which we want to compute its soft max.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">alpha</span></code>:</dt><dd><p>α in the documentation above. Larger α makes the soft max more
similar to max, with a sharper corner. Must be strictly positive
and finite.</p>
</dd>
<dt><em>Default:</em> is 1.</dt><dd><p>$Raises:</p>
</dd>
</dl>
<p>RuntimeError if α &lt;= 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if α is non-finite.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SoftOverMax(x: list[pydrake.autodiffutils.AutoDiffXd], alpha: float = 1.0) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
</ol>
<p>Computes a smooth over approximation of max function, namely
SoftOverMax(x) &gt;= max(x). Mathematically we compute this as (log (∑ᵢ
exp(αxᵢ))) / α.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">x</span></code>:</dt><dd><p>The vector for which we want to compute its soft max.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">alpha</span></code>:</dt><dd><p>α in the documentation above. Larger α makes the soft max more
similar to max, with a sharper corner. Must be strictly positive
and finite.</p>
</dd>
<dt><em>Default:</em> is 1.</dt><dd><p>$Raises:</p>
</dd>
</dl>
<p>RuntimeError if α &lt;= 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if α is non-finite.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.SoftOverMin">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">SoftOverMin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.SoftOverMin" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SoftOverMin(x: list[float], alpha: float = 1.0) -&gt; float</p></li>
</ol>
<p>Computes a smooth over approximation of min function, namely
SoftOverMin(x) &gt;= min(x). Mathematically we compute this as ∑ᵢ
exp(-αxᵢ)*xᵢ / d, where d = ∑ⱼ exp(-αxⱼ)</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">x</span></code>:</dt><dd><p>The vector for which we want to compute its soft min.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">alpha</span></code>:</dt><dd><p>α in the documentation above. Larger α makes the soft min more
similar to min, with a sharper corner. Must be strictly positive
and finite.</p>
</dd>
<dt><em>Default:</em> is 1.</dt><dd><p>$Raises:</p>
</dd>
</dl>
<p>RuntimeError if α &lt;= 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if α is non-finite.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SoftOverMin(x: list[pydrake.autodiffutils.AutoDiffXd], alpha: float = 1.0) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
</ol>
<p>Computes a smooth over approximation of min function, namely
SoftOverMin(x) &gt;= min(x). Mathematically we compute this as ∑ᵢ
exp(-αxᵢ)*xᵢ / d, where d = ∑ⱼ exp(-αxⱼ)</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">x</span></code>:</dt><dd><p>The vector for which we want to compute its soft min.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">alpha</span></code>:</dt><dd><p>α in the documentation above. Larger α makes the soft min more
similar to min, with a sharper corner. Must be strictly positive
and finite.</p>
</dd>
<dt><em>Default:</em> is 1.</dt><dd><p>$Raises:</p>
</dd>
</dl>
<p>RuntimeError if α &lt;= 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if α is non-finite.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.SoftUnderMax">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">SoftUnderMax</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.SoftUnderMax" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SoftUnderMax(x: list[float], alpha: float = 1.0) -&gt; float</p></li>
</ol>
<p>Computes a smooth under approximation of max function, namely
SoftUnderMax(x) &lt;= max(x). Mathematically we compute this as ∑ᵢ
exp(αxᵢ)*xᵢ / d, where d = ∑ⱼ exp(αxⱼ)</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">x</span></code>:</dt><dd><p>The vector for which we want to compute its soft max.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">alpha</span></code>:</dt><dd><p>α in the documentation above. Larger α makes the soft max more
similar to max, with a sharper corner. Must be strictly positive
and finite.</p>
</dd>
<dt><em>Default:</em> is 1.</dt><dd><p>$Raises:</p>
</dd>
</dl>
<p>RuntimeError if α &lt;= 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if α is non-finite.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SoftUnderMax(x: list[pydrake.autodiffutils.AutoDiffXd], alpha: float = 1.0) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
</ol>
<p>Computes a smooth under approximation of max function, namely
SoftUnderMax(x) &lt;= max(x). Mathematically we compute this as ∑ᵢ
exp(αxᵢ)*xᵢ / d, where d = ∑ⱼ exp(αxⱼ)</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">x</span></code>:</dt><dd><p>The vector for which we want to compute its soft max.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">alpha</span></code>:</dt><dd><p>α in the documentation above. Larger α makes the soft max more
similar to max, with a sharper corner. Must be strictly positive
and finite.</p>
</dd>
<dt><em>Default:</em> is 1.</dt><dd><p>$Raises:</p>
</dd>
</dl>
<p>RuntimeError if α &lt;= 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if α is non-finite.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.SoftUnderMin">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">SoftUnderMin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.SoftUnderMin" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SoftUnderMin(x: list[float], alpha: float = 1.0) -&gt; float</p></li>
</ol>
<p>Computes a smooth under approximation of min function, namely
SoftUnderMin(x) &lt;= min(x). Mathematically we compute this as -(log (∑ᵢ
exp(-αxᵢ))) / α</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">x</span></code>:</dt><dd><p>The vector for which we want to compute its soft min.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">alpha</span></code>:</dt><dd><p>α in the documentation above. Larger α makes the soft min more
similar to min, with a sharper corner. Must be strictly positive
and finite.</p>
</dd>
<dt><em>Default:</em> is 1.</dt><dd><p>$Raises:</p>
</dd>
</dl>
<p>RuntimeError if α &lt;= 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if α is non-finite.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SoftUnderMin(x: list[pydrake.autodiffutils.AutoDiffXd], alpha: float = 1.0) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
</ol>
<p>Computes a smooth under approximation of min function, namely
SoftUnderMin(x) &lt;= min(x). Mathematically we compute this as -(log (∑ᵢ
exp(-αxᵢ))) / α</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">x</span></code>:</dt><dd><p>The vector for which we want to compute its soft min.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">alpha</span></code>:</dt><dd><p>α in the documentation above. Larger α makes the soft min more
similar to min, with a sharper corner. Must be strictly positive
and finite.</p>
</dd>
<dt><em>Default:</em> is 1.</dt><dd><p>$Raises:</p>
</dd>
</dl>
<p>RuntimeError if α &lt;= 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if α is non-finite.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.sqrt">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">sqrt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.sqrt" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>sqrt(arg0: float) -&gt; float</p></li>
<li><p>sqrt(arg0: pydrake.autodiffutils.AutoDiffXd) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
<li><p>sqrt(arg0: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</p></li>
</ol>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.tan">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">tan</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.tan" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>tan(arg0: float) -&gt; float</p></li>
<li><p>tan(arg0: pydrake.autodiffutils.AutoDiffXd) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
<li><p>tan(arg0: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</p></li>
</ol>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.tanh">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">tanh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.tanh" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>tanh(arg0: float) -&gt; float</p></li>
<li><p>tanh(arg0: pydrake.autodiffutils.AutoDiffXd) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
<li><p>tanh(arg0: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</p></li>
</ol>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.ToLowerTriangularColumnsFromMatrix">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">ToLowerTriangularColumnsFromMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.ToLowerTriangularColumnsFromMatrix" title="Permalink to this definition"></a></dt>
<dd><p>Given a square matrix, extract the lower triangular part as a stacked
column vector. This is a particularly useful operation when
vectorizing symmetric matrices.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.ToSymmetricMatrixFromLowerTriangularColumns">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">ToSymmetricMatrixFromLowerTriangularColumns</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lower_triangular_columns</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.ToSymmetricMatrixFromLowerTriangularColumns" title="Permalink to this definition"></a></dt>
<dd><p>Given a column vector containing the stacked columns of the lower
triangular part of a square matrix, returning a symmetric matrix whose
lower triangular part is the same as the original matrix.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.UniformlyRandomAngleAxis">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">UniformlyRandomAngleAxis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">generator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.common.html#pydrake.common.RandomGenerator" title="pydrake.common.RandomGenerator"><span class="pre">pydrake.common.RandomGenerator</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.common.eigen_geometry.html#pydrake.common.eigen_geometry.AngleAxis" title="pydrake.common.eigen_geometry.AngleAxis"><span class="pre">pydrake.common.eigen_geometry.AngleAxis</span></a></span></span><a class="headerlink" href="#pydrake.math.UniformlyRandomAngleAxis" title="Permalink to this definition"></a></dt>
<dd><p>Generates a rotation (in the axis-angle representation) that rotates a
point on the unit sphere to another point on the unit sphere with a
uniform distribution over the sphere.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.UniformlyRandomQuaternion">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">UniformlyRandomQuaternion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">generator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.common.html#pydrake.common.RandomGenerator" title="pydrake.common.RandomGenerator"><span class="pre">pydrake.common.RandomGenerator</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.common.eigen_geometry.html#pydrake.common.eigen_geometry.Quaternion" title="pydrake.common.eigen_geometry.Quaternion"><span class="pre">pydrake.common.eigen_geometry.Quaternion</span></a></span></span><a class="headerlink" href="#pydrake.math.UniformlyRandomQuaternion" title="Permalink to this definition"></a></dt>
<dd><p>Generates a rotation (in the quaternion representation) that rotates a
point on the unit sphere to another point on the unit sphere with a
uniform distribution over the sphere. This method is briefly explained
in <a class="reference external" href="http://planning.cs.uiuc.edu/node198.html">http://planning.cs.uiuc.edu/node198.html</a>, a full explanation can be
found in K. Shoemake. Uniform Random Rotations in D. Kirk, editor,
Graphics Gems III, pages 124-132. Academic, New York, 1992.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.UniformlyRandomRotationMatrix">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">UniformlyRandomRotationMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">generator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.common.html#pydrake.common.RandomGenerator" title="pydrake.common.RandomGenerator"><span class="pre">pydrake.common.RandomGenerator</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.math.RotationMatrix" title="pydrake.math.RotationMatrix"><span class="pre">pydrake.math.RotationMatrix</span></a></span></span><a class="headerlink" href="#pydrake.math.UniformlyRandomRotationMatrix" title="Permalink to this definition"></a></dt>
<dd><p>Generates a rotation (in the rotation matrix representation) that
rotates a point on the unit sphere to another point on the unit sphere
with a uniform distribution over the sphere.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.UniformlyRandomRPY">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">UniformlyRandomRPY</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">generator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.common.html#pydrake.common.RandomGenerator" title="pydrake.common.RandomGenerator"><span class="pre">pydrake.common.RandomGenerator</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.math.UniformlyRandomRPY" title="Permalink to this definition"></a></dt>
<dd><p>Generates a rotation (in the roll-pitch-yaw representation) that
rotates a point on the unit sphere to another point on the unit sphere
with a uniform distribution over the sphere.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.VectorToSkewSymmetric">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">VectorToSkewSymmetric</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.VectorToSkewSymmetric" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>VectorToSkewSymmetric(p: numpy.ndarray[numpy.float64[3, 1]]) -&gt; numpy.ndarray[numpy.float64[3, 3]]</p></li>
<li><p>VectorToSkewSymmetric(p: numpy.ndarray[object[3, 1]]) -&gt; numpy.ndarray[object[3, 3]]</p></li>
<li><p>VectorToSkewSymmetric(p: numpy.ndarray[object[3, 1]]) -&gt; numpy.ndarray[object[3, 3]]</p></li>
</ol>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.math.wrap_to">
<span class="sig-prename descclassname"><span class="pre">pydrake.math.</span></span><span class="sig-name descname"><span class="pre">wrap_to</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.math.wrap_to" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>wrap_to(value: float, low: float, high: float) -&gt; float</p></li>
</ol>
<p>For variables that are meant to be periodic, (e.g. over a 2π
interval), wraps <code class="docutils literal notranslate"><span class="pre">value</span></code> into the interval <code class="docutils literal notranslate"><span class="pre">[low,</span> <span class="pre">high)</span></code>.
Precisely, <code class="docutils literal notranslate"><span class="pre">wrap_to</span></code> returns: value + k*(high-low) for the unique
integer value <code class="docutils literal notranslate"><span class="pre">k</span></code> that lands the output in the desired interval.
<code class="docutils literal notranslate"><span class="pre">low</span></code> and <code class="docutils literal notranslate"><span class="pre">high</span></code> must be finite, and low &lt; high.</p>
<ol class="arabic simple" start="2">
<li><p>wrap_to(value: pydrake.autodiffutils.AutoDiffXd, low: pydrake.autodiffutils.AutoDiffXd, high: pydrake.autodiffutils.AutoDiffXd) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
</ol>
<p>For variables that are meant to be periodic, (e.g. over a 2π
interval), wraps <code class="docutils literal notranslate"><span class="pre">value</span></code> into the interval <code class="docutils literal notranslate"><span class="pre">[low,</span> <span class="pre">high)</span></code>.
Precisely, <code class="docutils literal notranslate"><span class="pre">wrap_to</span></code> returns: value + k*(high-low) for the unique
integer value <code class="docutils literal notranslate"><span class="pre">k</span></code> that lands the output in the desired interval.
<code class="docutils literal notranslate"><span class="pre">low</span></code> and <code class="docutils literal notranslate"><span class="pre">high</span></code> must be finite, and low &lt; high.</p>
<ol class="arabic simple" start="3">
<li><p>wrap_to(value: pydrake.symbolic.Expression, low: pydrake.symbolic.Expression, high: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</p></li>
</ol>
<p>For variables that are meant to be periodic, (e.g. over a 2π
interval), wraps <code class="docutils literal notranslate"><span class="pre">value</span></code> into the interval <code class="docutils literal notranslate"><span class="pre">[low,</span> <span class="pre">high)</span></code>.
Precisely, <code class="docutils literal notranslate"><span class="pre">wrap_to</span></code> returns: value + k*(high-low) for the unique
integer value <code class="docutils literal notranslate"><span class="pre">k</span></code> that lands the output in the desired interval.
<code class="docutils literal notranslate"><span class="pre">low</span></code> and <code class="docutils literal notranslate"><span class="pre">high</span></code> must be finite, and low &lt; high.</p>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="pydrake.manipulation.html" class="btn btn-neutral float-left" title="pydrake.manipulation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="pydrake.multibody.html" class="btn btn-neutral float-right" title="pydrake.multibody" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p></p>
  </div>

  
</footer>
<script>
  /* Enables clicking for the mobile "hamburger" (three-line) menu item. */
  const siteHeader = document.querySelector('.site-header')
  const mobileButton = document.querySelector('.menu-mobile-toggle')
  const body = document.querySelector('body')

  mobileButton.addEventListener('click', function(event) {
    siteHeader.classList.toggle('open');
    body.classList.toggle('overflow-hidden');
  })
</script>
<footer class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg">
    </a>
    <div class="footer-menu">
      <ul>
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"></a>
        </li>
      </ul>
    </div>
  </div>


</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>