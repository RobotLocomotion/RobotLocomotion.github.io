<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pydrake.systems.analysis &mdash; pydrake  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="pydrake.systems.controllers" href="pydrake.systems.controllers.html" />
    <link rel="prev" title="pydrake.systems.all" href="pydrake.systems.all.html" /> 
</head>

<body class="wy-body-for-nav">
<header class="site-header">
  <div class="site-header-inner contain">
    <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
    <div class="menu-mobile-toggle">
      <span></span>
    </div>
    <nav class="site-menu">
      <ul>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/">Home</a>
        </li>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/installation.html">Installation</a>
        </li>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/gallery.html">Gallery</a>
        </li>
        <li class="site-menu-item site-menu-item-main">API Documentation
          <div class="sub">
            <a class="site-menu-item" href="https://drake.mit.edu/doxygen_cxx/index.html">C++</a> <a class="site-menu-item" href="https://drake.mit.edu/pydrake/index.html">Python</a>
          </div>
        </li>
        <li class="site-menu-item site-menu-item-main">Resources
          <div class="sub">
            <a class="site-menu-item" href="/getting_help.html">Getting Help</a> <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/%2Findex.ipynb">Tutorials</a> <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a> <a class="site-menu-item" href="/developers.html">For Developers</a> <a class="site-menu-item" href="/credits.html">Credits</a>
          </div>
        </li>
        <li class="github-link">
          <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
        </li>
      </ul>
    </nav>
  </div>
</header>

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> pydrake
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search pydrake only…" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
  <form id="ddg-search-form" class="wy_form" action="https://duckduckgo.com/" method="get">
    <input type="text" name="q" placeholder="Search all of Drake…" />
    <input type="hidden" name="sites" value="drake.mit.edu" />
  </form>
</div>

        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="pydrake.all.html">pydrake.all</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.autodiffutils.html">pydrake.autodiffutils</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.common.html">pydrake.common</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.examples.html">pydrake.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.forwarddiff.html">pydrake.forwarddiff</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.geometry.html">pydrake.geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.lcm.html">pydrake.lcm</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.manipulation.html">pydrake.manipulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.math.html">pydrake.math</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.multibody.html">pydrake.multibody</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.perception.html">pydrake.perception</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.polynomial.html">pydrake.polynomial</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.html">pydrake.solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.symbolic.html">pydrake.symbolic</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="pydrake.systems.html">pydrake.systems</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.all.html">pydrake.systems.all</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">pydrake.systems.analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.controllers.html">pydrake.systems.controllers</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.drawing.html">pydrake.systems.drawing</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.framework.html">pydrake.systems.framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.lcm.html">pydrake.systems.lcm</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.perception.html">pydrake.systems.perception</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.planar_scenegraph_visualizer.html">pydrake.systems.planar_scenegraph_visualizer</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.primitives.html">pydrake.systems.primitives</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.pyplot_visualizer.html">pydrake.systems.pyplot_visualizer</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.rendering.html">pydrake.systems.rendering</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.scalar_conversion.html">pydrake.systems.scalar_conversion</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.sensors.html">pydrake.systems.sensors</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.trajectory_optimization.html">pydrake.systems.trajectory_optimization</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.trajectories.html">pydrake.trajectories</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.tutorials.html">pydrake.tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.visualization.html">pydrake.visualization</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pydrake</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="pydrake.systems.html">pydrake.systems</a> &raquo;</li>
      <li>pydrake.systems.analysis</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-pydrake.systems.analysis">
<span id="pydrake-systems-analysis"></span><h1>pydrake.systems.analysis<a class="headerlink" href="#module-pydrake.systems.analysis" title="Permalink to this headline"></a></h1>
<p>Bindings for the analysis portion of the Systems framework.</p>
<dl class="py function">
<dt class="sig sig-object py" id="pydrake.systems.analysis.ApplySimulatorConfig">
<span class="sig-prename descclassname"><span class="pre">pydrake.systems.analysis.</span></span><span class="sig-name descname"><span class="pre">ApplySimulatorConfig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.systems.analysis.ApplySimulatorConfig" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>ApplySimulatorConfig(config: pydrake.systems.analysis.SimulatorConfig, simulator: pydrake.systems.analysis.Simulator_[float]) -&gt; None</p></li>
</ol>
<p>Modifies the <code class="docutils literal notranslate"><span class="pre">simulator</span></code> based on the given <code class="docutils literal notranslate"><span class="pre">config</span></code>. (Always
replaces the Integrator with a new one; be careful not to keep old
references around.)</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">config</span></code>:</dt><dd><p>Configuration to be used. Contains values for both the integrator
and the simulator.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">simulator</span></code>:</dt><dd><p>On input, a valid pointer to a Simulator. On output the integrator
for <code class="docutils literal notranslate"><span class="pre">simulator</span></code> is reset according to the given <code class="docutils literal notranslate"><span class="pre">config</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>ApplySimulatorConfig(config: pydrake.systems.analysis.SimulatorConfig, simulator: pydrake.systems.analysis.Simulator_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Modifies the <code class="docutils literal notranslate"><span class="pre">simulator</span></code> based on the given <code class="docutils literal notranslate"><span class="pre">config</span></code>. (Always
replaces the Integrator with a new one; be careful not to keep old
references around.)</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">config</span></code>:</dt><dd><p>Configuration to be used. Contains values for both the integrator
and the simulator.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">simulator</span></code>:</dt><dd><p>On input, a valid pointer to a Simulator. On output the integrator
for <code class="docutils literal notranslate"><span class="pre">simulator</span></code> is reset according to the given <code class="docutils literal notranslate"><span class="pre">config</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.systems.analysis.ExtractSimulatorConfig">
<span class="sig-prename descclassname"><span class="pre">pydrake.systems.analysis.</span></span><span class="sig-name descname"><span class="pre">ExtractSimulatorConfig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.systems.analysis.ExtractSimulatorConfig" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>ExtractSimulatorConfig(simulator: pydrake.systems.analysis.Simulator_[float]) -&gt; pydrake.systems.analysis.SimulatorConfig</p></li>
</ol>
<p>Reports the simulator’s current configuration, including the
configuration of the integrator.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">simulator</span></code>:</dt><dd><p>The Simulator to extract the configuration from. $Note:</p>
</dd>
</dl>
<p>For non-double T (T=AutoDiffXd), doing ExtractSimulatorConfig will
discard the integrator’s scalar type’s extra information such as
gradients.</p>
<ol class="arabic simple" start="2">
<li><p>ExtractSimulatorConfig(simulator: pydrake.systems.analysis.Simulator_[AutoDiffXd]) -&gt; pydrake.systems.analysis.SimulatorConfig</p></li>
</ol>
<p>Reports the simulator’s current configuration, including the
configuration of the integrator.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">simulator</span></code>:</dt><dd><p>The Simulator to extract the configuration from. $Note:</p>
</dd>
</dl>
<p>For non-double T (T=AutoDiffXd), doing ExtractSimulatorConfig will
discard the integrator’s scalar type’s extra information such as
gradients.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.systems.analysis.GetIntegrationSchemes">
<span class="sig-prename descclassname"><span class="pre">pydrake.systems.analysis.</span></span><span class="sig-name descname"><span class="pre">GetIntegrationSchemes</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.systems.analysis.GetIntegrationSchemes" title="Permalink to this definition"></a></dt>
<dd><p>Returns the allowed string values for the <code class="docutils literal notranslate"><span class="pre">scheme</span></code> parameter in
ResetIntegratorFromFlags() and SimulatorConfig::integration_scheme.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.systems.analysis.InitializeParams">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.systems.analysis.</span></span><span class="sig-name descname"><span class="pre">InitializeParams</span></span><a class="headerlink" href="#pydrake.systems.analysis.InitializeParams" title="Permalink to this definition"></a></dt>
<dd><p>Parameters for fine control of simulator initialization.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Simulator&lt;T&gt;::Initialize().</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.InitializeParams.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.InitializeParams" title="pydrake.systems.analysis.InitializeParams"><span class="pre">pydrake.systems.analysis.InitializeParams</span></a></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.InitializeParams.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.systems.analysis.InitializeParams.suppress_initialization_events">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">suppress_initialization_events</span></span><a class="headerlink" href="#pydrake.systems.analysis.InitializeParams.suppress_initialization_events" title="Permalink to this definition"></a></dt>
<dd><p>Whether to trigger initialization events. Events are triggered by
default; it may be useful to suppress them when reusing a simulator.</p>
</dd></dl>

</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase">
<span class="sig-prename descclassname"><span class="pre">pydrake.systems.analysis.</span></span><span class="sig-name descname"><span class="pre">IntegratorBase</span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase" title="Permalink to this definition"></a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_-float" title="pydrake.systems.analysis.IntegratorBase_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.analysis.IntegratorBase_[float]</span></code></a></p>
</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.systems.analysis.</span></span><span class="sig-name descname"><span class="pre">IntegratorBase_</span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_-float" title="pydrake.systems.analysis.IntegratorBase_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntegratorBase_[float]</span></code></a>, <a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_-AutoDiffXd" title="pydrake.systems.analysis.IntegratorBase_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntegratorBase_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_-Expression" title="pydrake.systems.analysis.IntegratorBase_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntegratorBase_[Expression]</span></code></a></p>
<dl class="py class">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_-float">
<span id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">IntegratorBase_[float]</span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_.IntegratorBase_-float" title="Permalink to this definition"></a></dt>
<dd><p>An abstract class for an integrator for ODEs and DAEs as represented
by a Drake System. Integrators solve initial value problems of the
form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>ẋ(t) = f(t, x(t)) with f : ℝ × ℝⁿ → ℝⁿ
</pre></div>
</div>
<p>(i.e., <code class="docutils literal notranslate"><span class="pre">f()</span></code> is an ordinary differential equation) given initial
conditions (t₀, x₀). Thus, integrators advance the continuous state of
a dynamical system forward in time.</p>
<p>Drake’s subclasses of IntegratorBase&lt;T&gt; should follow the naming
pattern <code class="docutils literal notranslate"><span class="pre">FooIntegrator&lt;T&gt;</span></code> by convention.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_-float-.__init__">
<span id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_.IntegratorBase_-float-.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_-float-.get_dense_output">
<span id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float].get_dense_output"></span><span class="sig-name descname"><span class="pre">get_dense_output</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.trajectories.html#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_.IntegratorBase_-float-.get_dense_output" title="Permalink to this definition"></a></dt>
<dd><p>Returns a const pointer to the integrator’s current
PiecewisePolynomial instance, holding a representation of the
continuous state trajectory since the last StartDenseIntegration()
call. This is suitable to query the integrator’s current dense output,
if any (may be nullptr).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_-float-.get_fixed_step_mode">
<span id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float].get_fixed_step_mode"></span><span class="sig-name descname"><span class="pre">get_fixed_step_mode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_.IntegratorBase_-float-.get_fixed_step_mode" title="Permalink to this definition"></a></dt>
<dd><p>Gets whether an integrator is running in fixed step mode. If the
integrator does not support error estimation, this function will
always return <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>set_fixed_step_mode()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_-float-.get_maximum_step_size">
<span id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float].get_maximum_step_size"></span><span class="sig-name descname"><span class="pre">get_maximum_step_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_.IntegratorBase_-float-.get_maximum_step_size" title="Permalink to this definition"></a></dt>
<dd><p>Gets the maximum step size that may be taken by this integrator. This
is a soft maximum: the integrator may stretch it by as much as 1% to
hit a discrete event.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>set_requested_minimum_step_size()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_-float-.get_requested_minimum_step_size">
<span id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float].get_requested_minimum_step_size"></span><span class="sig-name descname"><span class="pre">get_requested_minimum_step_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_.IntegratorBase_-float-.get_requested_minimum_step_size" title="Permalink to this definition"></a></dt>
<dd><p>Gets the requested minimum step size <code class="docutils literal notranslate"><span class="pre">h_min</span></code> for this integrator.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>set_requested_minimum_step_size()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>get_working_minimum_step_size(T)</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_-float-.get_target_accuracy">
<span id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float].get_target_accuracy"></span><span class="sig-name descname"><span class="pre">get_target_accuracy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_.IntegratorBase_-float-.get_target_accuracy" title="Permalink to this definition"></a></dt>
<dd><p>Gets the target accuracy.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>get_accuracy_in_use()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_-float-.get_throw_on_minimum_step_size_violation">
<span id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float].get_throw_on_minimum_step_size_violation"></span><span class="sig-name descname"><span class="pre">get_throw_on_minimum_step_size_violation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_.IntegratorBase_-float-.get_throw_on_minimum_step_size_violation" title="Permalink to this definition"></a></dt>
<dd><p>Reports the current setting of the
throw_on_minimum_step_size_violation flag.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>set_throw_on_minimum_step_size_violation().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_-float-.set_fixed_step_mode">
<span id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float].set_fixed_step_mode"></span><span class="sig-name descname"><span class="pre">set_fixed_step_mode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_.IntegratorBase_-float-.set_fixed_step_mode" title="Permalink to this definition"></a></dt>
<dd><p>Sets an integrator with error control to fixed step mode. If the
integrator runs in fixed step mode, it will always take the maximum
step size directed (which may be that determined by
get_maximum_step_size(), or may be smaller, as directed by, e.g.,
Simulator for event handling purposes).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The error estimation process will still be active (so
get_error_estimate() will still return a correct result), meaning
that the additional (typically, but not necessarily small)
computation required for error estimation will still be performed.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if integrator does not support error estimation and</strong> – </p></li>
<li><p><strong>flag` is set to False</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_-float-.set_maximum_step_size">
<span id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float].set_maximum_step_size"></span><span class="sig-name descname"><span class="pre">set_maximum_step_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_.IntegratorBase_-float-.set_maximum_step_size" title="Permalink to this definition"></a></dt>
<dd><p>&#64;anchor integrator-maxstep &#64;name Methods related to maximum
integration step size</p>
<p>Sets the <em>nominal</em> maximum step size- the actual maximum step size
taken may be slightly larger (see set_maximum_step_size() and
get_stretch_factor())- that an integrator will take. Each integrator
has a default maximum step size, which might be infinite. Sets the
maximum step size that may be taken by this integrator. This setting
should be used if you know the maximum time scale of your problem. The
integrator may stretch the maximum step size by as much as 1% to reach
a discrete event. For fixed step integrators, all steps will be taken
at the maximum step size <em>unless</em> an event would be missed.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>See integrator-initial-step-size “Initial step size selection”</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_-float-.set_requested_minimum_step_size">
<span id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float].set_requested_minimum_step_size"></span><span class="sig-name descname"><span class="pre">set_requested_minimum_step_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_.IntegratorBase_-float-.set_requested_minimum_step_size" title="Permalink to this definition"></a></dt>
<dd><p>Sets the requested minimum step size <code class="docutils literal notranslate"><span class="pre">h_min</span></code> that may be taken by
this integrator. No step smaller than this will be taken except under
circumstances as described integrator-minstep “above”. This setting
will be ignored if it is smaller than the absolute minimum <code class="docutils literal notranslate"><span class="pre">h_floor</span></code>
also described above. Default value is zero.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">min_step_size</span></code>:</dt><dd><p>a non-negative value. Setting this value to zero will cause the
integrator to use a reasonable value instead (see
get_working_minimum_step_size()).</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>get_requested_minimum_step_size()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>get_working_minimum_step_size()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_-float-.set_target_accuracy">
<span id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float].set_target_accuracy"></span><span class="sig-name descname"><span class="pre">set_target_accuracy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_.IntegratorBase_-float-.set_target_accuracy" title="Permalink to this definition"></a></dt>
<dd><p>&#64;anchor integrator-accuracy &#64;name Methods for getting and setting
integrator accuracy The precise meaning of <em>accuracy</em> is a complicated
discussion, but it translates roughly to the number of significant
digits you want in the results. By convention it is supplied as
<code class="docutils literal notranslate"><span class="pre">10^-digits</span></code>, meaning that an accuracy of 1e-3 provides about three
significant digits. For more discussion of accuracy, see
accuracy_and_tolerance and ref. <a class="reference external" href="https://dx.doi.org/10.1016/j.piutam.2011.04.023">[1]</a>.</p>
<p>Integrators vary in the range of accuracy (loosest to tightest) that
they can support, and each integrator will choose a default accuracy
to be used that lies somewhere within this range and attempts to
balance computation and accuracy. If you request accuracy outside the
supported range for the chosen integrator it will be quietly adjusted
to be in range. You can find out the accuracy setting actually being
used using <code class="docutils literal notranslate"><span class="pre">get_accuracy_in_use()</span></code>.</p>
<p>Implicit integrators additionally use the accuracy setting for
determining when the underlying Newton-Raphson root finding process
has converged. For those integrators, the accuracy setting also limits
the allowable iteration error in the Newton-Raphson process. Looser
accuracy in that process certainly implies greater error in the ODE
solution and might impact the stability of the solution negatively as
well.</p>
<ul class="simple">
<li><p>[1] M. Sherman, A. Seth, S. Delp. Procedia IUTAM 2:241-261 (2011),</p></li>
</ul>
<p>Section 3.3. <a class="reference external" href="https://dx.doi.org/10.1016/j.piutam.2011.04.023">https://dx.doi.org/10.1016/j.piutam.2011.04.023</a></p>
<p>Request that the integrator attempt to achieve a particular accuracy
for the continuous portions of the simulation. Otherwise a default
accuracy is chosen for you. This may be ignored for fixed-step
integration since accuracy control requires variable step sizes. You
should call supports_error_estimation() to ensure that the integrator
supports this capability before calling this function; if the
integrator does not support it, this method will throw an exception.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if integrator does not support error estimation.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_-float-.set_throw_on_minimum_step_size_violation">
<span id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float].set_throw_on_minimum_step_size_violation"></span><span class="sig-name descname"><span class="pre">set_throw_on_minimum_step_size_violation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_.IntegratorBase_-float-.set_throw_on_minimum_step_size_violation" title="Permalink to this definition"></a></dt>
<dd><p>Sets whether the integrator should throw a RuntimeError when the
integrator’s step size selection algorithm determines that it must
take a step smaller than the minimum step size (for, e.g., purposes of
error control). Default is <code class="docutils literal notranslate"><span class="pre">True</span></code>. If <code class="docutils literal notranslate"><span class="pre">False</span></code>, the integrator will
advance time and state using the minimum specified step size in such
situations. See integrator-minstep “this section” for more detail.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_-float-.StartDenseIntegration">
<span id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float].StartDenseIntegration"></span><span class="sig-name descname"><span class="pre">StartDenseIntegration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_.IntegratorBase_-float-.StartDenseIntegration" title="Permalink to this definition"></a></dt>
<dd><p>Starts dense integration, allocating a new dense output for this
integrator to use.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>The integrator has been initialized.</p>
</dd>
<dt>Precondition:</dt><dd><p>The system being integrated has continuous state.</p>
</dd>
<dt>Precondition:</dt><dd><p>No dense integration is in progress (no dense output is held by
the integrator)</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if any of the preconditions is not met.</strong> – </p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Dense integration may incur significant overhead.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_-float-.StopDenseIntegration">
<span id="pydrake.systems.analysis.IntegratorBase_.IntegratorBase_[float].StopDenseIntegration"></span><span class="sig-name descname"><span class="pre">StopDenseIntegration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.trajectories.html#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_.IntegratorBase_-float-.StopDenseIntegration" title="Permalink to this definition"></a></dt>
<dd><p>Stops dense integration, yielding ownership of the current dense
output to the caller.</p>
<dl class="simple">
<dt>Remark:</dt><dd><p>This process is irreversible.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A PiecewisePolynomial instance, i.e. a representation of the
continuous state trajectory of the system being integrated that
can be evaluated at any time within its extension. This
representation is defined starting at the context time of the last
StartDenseIntegration() call and finishing at the current context
time.</p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Dense integration is in progress (a dense output is held by this
integrator, after a call to StartDenseIntegration()).</p>
</dd>
<dt>Postcondition:</dt><dd><p>Previously held dense output is not updated nor referenced by the
integrator anymore.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if any of the preconditions is not met.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-AutoDiffXd">
<span id="pydrake.systems.analysis.IntegratorBase_[AutoDiffXd]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.systems.analysis.</span></span><span class="sig-name descname"><span class="pre">IntegratorBase_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><p>An abstract class for an integrator for ODEs and DAEs as represented
by a Drake System. Integrators solve initial value problems of the
form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>ẋ(t) = f(t, x(t)) with f : ℝ × ℝⁿ → ℝⁿ
</pre></div>
</div>
<p>(i.e., <code class="docutils literal notranslate"><span class="pre">f()</span></code> is an ordinary differential equation) given initial
conditions (t₀, x₀). Thus, integrators advance the continuous state of
a dynamical system forward in time.</p>
<p>Drake’s subclasses of IntegratorBase&lt;T&gt; should follow the naming
pattern <code class="docutils literal notranslate"><span class="pre">FooIntegrator&lt;T&gt;</span></code> by convention.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-AutoDiffXd-.__init__">
<span id="pydrake.systems.analysis.IntegratorBase_[AutoDiffXd].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-AutoDiffXd-.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-AutoDiffXd-.get_dense_output">
<span id="pydrake.systems.analysis.IntegratorBase_[AutoDiffXd].get_dense_output"></span><span class="sig-name descname"><span class="pre">get_dense_output</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.trajectories.html#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-AutoDiffXd-.get_dense_output" title="Permalink to this definition"></a></dt>
<dd><p>Returns a const pointer to the integrator’s current
PiecewisePolynomial instance, holding a representation of the
continuous state trajectory since the last StartDenseIntegration()
call. This is suitable to query the integrator’s current dense output,
if any (may be nullptr).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-AutoDiffXd-.get_fixed_step_mode">
<span id="pydrake.systems.analysis.IntegratorBase_[AutoDiffXd].get_fixed_step_mode"></span><span class="sig-name descname"><span class="pre">get_fixed_step_mode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-AutoDiffXd-.get_fixed_step_mode" title="Permalink to this definition"></a></dt>
<dd><p>Gets whether an integrator is running in fixed step mode. If the
integrator does not support error estimation, this function will
always return <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>set_fixed_step_mode()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-AutoDiffXd-.get_maximum_step_size">
<span id="pydrake.systems.analysis.IntegratorBase_[AutoDiffXd].get_maximum_step_size"></span><span class="sig-name descname"><span class="pre">get_maximum_step_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-AutoDiffXd-.get_maximum_step_size" title="Permalink to this definition"></a></dt>
<dd><p>Gets the maximum step size that may be taken by this integrator. This
is a soft maximum: the integrator may stretch it by as much as 1% to
hit a discrete event.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>set_requested_minimum_step_size()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-AutoDiffXd-.get_requested_minimum_step_size">
<span id="pydrake.systems.analysis.IntegratorBase_[AutoDiffXd].get_requested_minimum_step_size"></span><span class="sig-name descname"><span class="pre">get_requested_minimum_step_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-AutoDiffXd-.get_requested_minimum_step_size" title="Permalink to this definition"></a></dt>
<dd><p>Gets the requested minimum step size <code class="docutils literal notranslate"><span class="pre">h_min</span></code> for this integrator.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>set_requested_minimum_step_size()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>get_working_minimum_step_size(T)</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-AutoDiffXd-.get_target_accuracy">
<span id="pydrake.systems.analysis.IntegratorBase_[AutoDiffXd].get_target_accuracy"></span><span class="sig-name descname"><span class="pre">get_target_accuracy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-AutoDiffXd-.get_target_accuracy" title="Permalink to this definition"></a></dt>
<dd><p>Gets the target accuracy.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>get_accuracy_in_use()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-AutoDiffXd-.get_throw_on_minimum_step_size_violation">
<span id="pydrake.systems.analysis.IntegratorBase_[AutoDiffXd].get_throw_on_minimum_step_size_violation"></span><span class="sig-name descname"><span class="pre">get_throw_on_minimum_step_size_violation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-AutoDiffXd-.get_throw_on_minimum_step_size_violation" title="Permalink to this definition"></a></dt>
<dd><p>Reports the current setting of the
throw_on_minimum_step_size_violation flag.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>set_throw_on_minimum_step_size_violation().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-AutoDiffXd-.set_fixed_step_mode">
<span id="pydrake.systems.analysis.IntegratorBase_[AutoDiffXd].set_fixed_step_mode"></span><span class="sig-name descname"><span class="pre">set_fixed_step_mode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-AutoDiffXd-.set_fixed_step_mode" title="Permalink to this definition"></a></dt>
<dd><p>Sets an integrator with error control to fixed step mode. If the
integrator runs in fixed step mode, it will always take the maximum
step size directed (which may be that determined by
get_maximum_step_size(), or may be smaller, as directed by, e.g.,
Simulator for event handling purposes).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The error estimation process will still be active (so
get_error_estimate() will still return a correct result), meaning
that the additional (typically, but not necessarily small)
computation required for error estimation will still be performed.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if integrator does not support error estimation and</strong> – </p></li>
<li><p><strong>flag` is set to False</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-AutoDiffXd-.set_maximum_step_size">
<span id="pydrake.systems.analysis.IntegratorBase_[AutoDiffXd].set_maximum_step_size"></span><span class="sig-name descname"><span class="pre">set_maximum_step_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-AutoDiffXd-.set_maximum_step_size" title="Permalink to this definition"></a></dt>
<dd><p>&#64;anchor integrator-maxstep &#64;name Methods related to maximum
integration step size</p>
<p>Sets the <em>nominal</em> maximum step size- the actual maximum step size
taken may be slightly larger (see set_maximum_step_size() and
get_stretch_factor())- that an integrator will take. Each integrator
has a default maximum step size, which might be infinite. Sets the
maximum step size that may be taken by this integrator. This setting
should be used if you know the maximum time scale of your problem. The
integrator may stretch the maximum step size by as much as 1% to reach
a discrete event. For fixed step integrators, all steps will be taken
at the maximum step size <em>unless</em> an event would be missed.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>See integrator-initial-step-size “Initial step size selection”</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-AutoDiffXd-.set_requested_minimum_step_size">
<span id="pydrake.systems.analysis.IntegratorBase_[AutoDiffXd].set_requested_minimum_step_size"></span><span class="sig-name descname"><span class="pre">set_requested_minimum_step_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-AutoDiffXd-.set_requested_minimum_step_size" title="Permalink to this definition"></a></dt>
<dd><p>Sets the requested minimum step size <code class="docutils literal notranslate"><span class="pre">h_min</span></code> that may be taken by
this integrator. No step smaller than this will be taken except under
circumstances as described integrator-minstep “above”. This setting
will be ignored if it is smaller than the absolute minimum <code class="docutils literal notranslate"><span class="pre">h_floor</span></code>
also described above. Default value is zero.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">min_step_size</span></code>:</dt><dd><p>a non-negative value. Setting this value to zero will cause the
integrator to use a reasonable value instead (see
get_working_minimum_step_size()).</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>get_requested_minimum_step_size()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>get_working_minimum_step_size()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-AutoDiffXd-.set_target_accuracy">
<span id="pydrake.systems.analysis.IntegratorBase_[AutoDiffXd].set_target_accuracy"></span><span class="sig-name descname"><span class="pre">set_target_accuracy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-AutoDiffXd-.set_target_accuracy" title="Permalink to this definition"></a></dt>
<dd><p>&#64;anchor integrator-accuracy &#64;name Methods for getting and setting
integrator accuracy The precise meaning of <em>accuracy</em> is a complicated
discussion, but it translates roughly to the number of significant
digits you want in the results. By convention it is supplied as
<code class="docutils literal notranslate"><span class="pre">10^-digits</span></code>, meaning that an accuracy of 1e-3 provides about three
significant digits. For more discussion of accuracy, see
accuracy_and_tolerance and ref. <a class="reference external" href="https://dx.doi.org/10.1016/j.piutam.2011.04.023">[1]</a>.</p>
<p>Integrators vary in the range of accuracy (loosest to tightest) that
they can support, and each integrator will choose a default accuracy
to be used that lies somewhere within this range and attempts to
balance computation and accuracy. If you request accuracy outside the
supported range for the chosen integrator it will be quietly adjusted
to be in range. You can find out the accuracy setting actually being
used using <code class="docutils literal notranslate"><span class="pre">get_accuracy_in_use()</span></code>.</p>
<p>Implicit integrators additionally use the accuracy setting for
determining when the underlying Newton-Raphson root finding process
has converged. For those integrators, the accuracy setting also limits
the allowable iteration error in the Newton-Raphson process. Looser
accuracy in that process certainly implies greater error in the ODE
solution and might impact the stability of the solution negatively as
well.</p>
<ul class="simple">
<li><p>[1] M. Sherman, A. Seth, S. Delp. Procedia IUTAM 2:241-261 (2011),</p></li>
</ul>
<p>Section 3.3. <a class="reference external" href="https://dx.doi.org/10.1016/j.piutam.2011.04.023">https://dx.doi.org/10.1016/j.piutam.2011.04.023</a></p>
<p>Request that the integrator attempt to achieve a particular accuracy
for the continuous portions of the simulation. Otherwise a default
accuracy is chosen for you. This may be ignored for fixed-step
integration since accuracy control requires variable step sizes. You
should call supports_error_estimation() to ensure that the integrator
supports this capability before calling this function; if the
integrator does not support it, this method will throw an exception.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if integrator does not support error estimation.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-AutoDiffXd-.set_throw_on_minimum_step_size_violation">
<span id="pydrake.systems.analysis.IntegratorBase_[AutoDiffXd].set_throw_on_minimum_step_size_violation"></span><span class="sig-name descname"><span class="pre">set_throw_on_minimum_step_size_violation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-AutoDiffXd-.set_throw_on_minimum_step_size_violation" title="Permalink to this definition"></a></dt>
<dd><p>Sets whether the integrator should throw a RuntimeError when the
integrator’s step size selection algorithm determines that it must
take a step smaller than the minimum step size (for, e.g., purposes of
error control). Default is <code class="docutils literal notranslate"><span class="pre">True</span></code>. If <code class="docutils literal notranslate"><span class="pre">False</span></code>, the integrator will
advance time and state using the minimum specified step size in such
situations. See integrator-minstep “this section” for more detail.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-AutoDiffXd-.StartDenseIntegration">
<span id="pydrake.systems.analysis.IntegratorBase_[AutoDiffXd].StartDenseIntegration"></span><span class="sig-name descname"><span class="pre">StartDenseIntegration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-AutoDiffXd-.StartDenseIntegration" title="Permalink to this definition"></a></dt>
<dd><p>Starts dense integration, allocating a new dense output for this
integrator to use.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>The integrator has been initialized.</p>
</dd>
<dt>Precondition:</dt><dd><p>The system being integrated has continuous state.</p>
</dd>
<dt>Precondition:</dt><dd><p>No dense integration is in progress (no dense output is held by
the integrator)</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if any of the preconditions is not met.</strong> – </p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Dense integration may incur significant overhead.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-AutoDiffXd-.StopDenseIntegration">
<span id="pydrake.systems.analysis.IntegratorBase_[AutoDiffXd].StopDenseIntegration"></span><span class="sig-name descname"><span class="pre">StopDenseIntegration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.trajectories.html#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-AutoDiffXd-.StopDenseIntegration" title="Permalink to this definition"></a></dt>
<dd><p>Stops dense integration, yielding ownership of the current dense
output to the caller.</p>
<dl class="simple">
<dt>Remark:</dt><dd><p>This process is irreversible.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A PiecewisePolynomial instance, i.e. a representation of the
continuous state trajectory of the system being integrated that
can be evaluated at any time within its extension. This
representation is defined starting at the context time of the last
StartDenseIntegration() call and finishing at the current context
time.</p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Dense integration is in progress (a dense output is held by this
integrator, after a call to StartDenseIntegration()).</p>
</dd>
<dt>Postcondition:</dt><dd><p>Previously held dense output is not updated nor referenced by the
integrator anymore.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if any of the preconditions is not met.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-Expression">
<span id="pydrake.systems.analysis.IntegratorBase_[Expression]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.systems.analysis.</span></span><span class="sig-name descname"><span class="pre">IntegratorBase_[Expression]</span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-Expression" title="Permalink to this definition"></a></dt>
<dd><p>An abstract class for an integrator for ODEs and DAEs as represented
by a Drake System. Integrators solve initial value problems of the
form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>ẋ(t) = f(t, x(t)) with f : ℝ × ℝⁿ → ℝⁿ
</pre></div>
</div>
<p>(i.e., <code class="docutils literal notranslate"><span class="pre">f()</span></code> is an ordinary differential equation) given initial
conditions (t₀, x₀). Thus, integrators advance the continuous state of
a dynamical system forward in time.</p>
<p>Drake’s subclasses of IntegratorBase&lt;T&gt; should follow the naming
pattern <code class="docutils literal notranslate"><span class="pre">FooIntegrator&lt;T&gt;</span></code> by convention.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-Expression-.__init__">
<span id="pydrake.systems.analysis.IntegratorBase_[Expression].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-Expression-.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-Expression-.get_dense_output">
<span id="pydrake.systems.analysis.IntegratorBase_[Expression].get_dense_output"></span><span class="sig-name descname"><span class="pre">get_dense_output</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.trajectories.html#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-Expression-.get_dense_output" title="Permalink to this definition"></a></dt>
<dd><p>Returns a const pointer to the integrator’s current
PiecewisePolynomial instance, holding a representation of the
continuous state trajectory since the last StartDenseIntegration()
call. This is suitable to query the integrator’s current dense output,
if any (may be nullptr).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-Expression-.get_fixed_step_mode">
<span id="pydrake.systems.analysis.IntegratorBase_[Expression].get_fixed_step_mode"></span><span class="sig-name descname"><span class="pre">get_fixed_step_mode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-Expression-.get_fixed_step_mode" title="Permalink to this definition"></a></dt>
<dd><p>Gets whether an integrator is running in fixed step mode. If the
integrator does not support error estimation, this function will
always return <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>set_fixed_step_mode()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-Expression-.get_maximum_step_size">
<span id="pydrake.systems.analysis.IntegratorBase_[Expression].get_maximum_step_size"></span><span class="sig-name descname"><span class="pre">get_maximum_step_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-Expression-.get_maximum_step_size" title="Permalink to this definition"></a></dt>
<dd><p>Gets the maximum step size that may be taken by this integrator. This
is a soft maximum: the integrator may stretch it by as much as 1% to
hit a discrete event.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>set_requested_minimum_step_size()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-Expression-.get_requested_minimum_step_size">
<span id="pydrake.systems.analysis.IntegratorBase_[Expression].get_requested_minimum_step_size"></span><span class="sig-name descname"><span class="pre">get_requested_minimum_step_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-Expression-.get_requested_minimum_step_size" title="Permalink to this definition"></a></dt>
<dd><p>Gets the requested minimum step size <code class="docutils literal notranslate"><span class="pre">h_min</span></code> for this integrator.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>set_requested_minimum_step_size()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>get_working_minimum_step_size(T)</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-Expression-.get_target_accuracy">
<span id="pydrake.systems.analysis.IntegratorBase_[Expression].get_target_accuracy"></span><span class="sig-name descname"><span class="pre">get_target_accuracy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-Expression-.get_target_accuracy" title="Permalink to this definition"></a></dt>
<dd><p>Gets the target accuracy.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>get_accuracy_in_use()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-Expression-.get_throw_on_minimum_step_size_violation">
<span id="pydrake.systems.analysis.IntegratorBase_[Expression].get_throw_on_minimum_step_size_violation"></span><span class="sig-name descname"><span class="pre">get_throw_on_minimum_step_size_violation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-Expression-.get_throw_on_minimum_step_size_violation" title="Permalink to this definition"></a></dt>
<dd><p>Reports the current setting of the
throw_on_minimum_step_size_violation flag.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>set_throw_on_minimum_step_size_violation().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-Expression-.set_fixed_step_mode">
<span id="pydrake.systems.analysis.IntegratorBase_[Expression].set_fixed_step_mode"></span><span class="sig-name descname"><span class="pre">set_fixed_step_mode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-Expression-.set_fixed_step_mode" title="Permalink to this definition"></a></dt>
<dd><p>Sets an integrator with error control to fixed step mode. If the
integrator runs in fixed step mode, it will always take the maximum
step size directed (which may be that determined by
get_maximum_step_size(), or may be smaller, as directed by, e.g.,
Simulator for event handling purposes).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The error estimation process will still be active (so
get_error_estimate() will still return a correct result), meaning
that the additional (typically, but not necessarily small)
computation required for error estimation will still be performed.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if integrator does not support error estimation and</strong> – </p></li>
<li><p><strong>flag` is set to False</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-Expression-.set_maximum_step_size">
<span id="pydrake.systems.analysis.IntegratorBase_[Expression].set_maximum_step_size"></span><span class="sig-name descname"><span class="pre">set_maximum_step_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-Expression-.set_maximum_step_size" title="Permalink to this definition"></a></dt>
<dd><p>&#64;anchor integrator-maxstep &#64;name Methods related to maximum
integration step size</p>
<p>Sets the <em>nominal</em> maximum step size- the actual maximum step size
taken may be slightly larger (see set_maximum_step_size() and
get_stretch_factor())- that an integrator will take. Each integrator
has a default maximum step size, which might be infinite. Sets the
maximum step size that may be taken by this integrator. This setting
should be used if you know the maximum time scale of your problem. The
integrator may stretch the maximum step size by as much as 1% to reach
a discrete event. For fixed step integrators, all steps will be taken
at the maximum step size <em>unless</em> an event would be missed.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>See integrator-initial-step-size “Initial step size selection”</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-Expression-.set_requested_minimum_step_size">
<span id="pydrake.systems.analysis.IntegratorBase_[Expression].set_requested_minimum_step_size"></span><span class="sig-name descname"><span class="pre">set_requested_minimum_step_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-Expression-.set_requested_minimum_step_size" title="Permalink to this definition"></a></dt>
<dd><p>Sets the requested minimum step size <code class="docutils literal notranslate"><span class="pre">h_min</span></code> that may be taken by
this integrator. No step smaller than this will be taken except under
circumstances as described integrator-minstep “above”. This setting
will be ignored if it is smaller than the absolute minimum <code class="docutils literal notranslate"><span class="pre">h_floor</span></code>
also described above. Default value is zero.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">min_step_size</span></code>:</dt><dd><p>a non-negative value. Setting this value to zero will cause the
integrator to use a reasonable value instead (see
get_working_minimum_step_size()).</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>get_requested_minimum_step_size()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>get_working_minimum_step_size()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-Expression-.set_target_accuracy">
<span id="pydrake.systems.analysis.IntegratorBase_[Expression].set_target_accuracy"></span><span class="sig-name descname"><span class="pre">set_target_accuracy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-Expression-.set_target_accuracy" title="Permalink to this definition"></a></dt>
<dd><p>&#64;anchor integrator-accuracy &#64;name Methods for getting and setting
integrator accuracy The precise meaning of <em>accuracy</em> is a complicated
discussion, but it translates roughly to the number of significant
digits you want in the results. By convention it is supplied as
<code class="docutils literal notranslate"><span class="pre">10^-digits</span></code>, meaning that an accuracy of 1e-3 provides about three
significant digits. For more discussion of accuracy, see
accuracy_and_tolerance and ref. <a class="reference external" href="https://dx.doi.org/10.1016/j.piutam.2011.04.023">[1]</a>.</p>
<p>Integrators vary in the range of accuracy (loosest to tightest) that
they can support, and each integrator will choose a default accuracy
to be used that lies somewhere within this range and attempts to
balance computation and accuracy. If you request accuracy outside the
supported range for the chosen integrator it will be quietly adjusted
to be in range. You can find out the accuracy setting actually being
used using <code class="docutils literal notranslate"><span class="pre">get_accuracy_in_use()</span></code>.</p>
<p>Implicit integrators additionally use the accuracy setting for
determining when the underlying Newton-Raphson root finding process
has converged. For those integrators, the accuracy setting also limits
the allowable iteration error in the Newton-Raphson process. Looser
accuracy in that process certainly implies greater error in the ODE
solution and might impact the stability of the solution negatively as
well.</p>
<ul class="simple">
<li><p>[1] M. Sherman, A. Seth, S. Delp. Procedia IUTAM 2:241-261 (2011),</p></li>
</ul>
<p>Section 3.3. <a class="reference external" href="https://dx.doi.org/10.1016/j.piutam.2011.04.023">https://dx.doi.org/10.1016/j.piutam.2011.04.023</a></p>
<p>Request that the integrator attempt to achieve a particular accuracy
for the continuous portions of the simulation. Otherwise a default
accuracy is chosen for you. This may be ignored for fixed-step
integration since accuracy control requires variable step sizes. You
should call supports_error_estimation() to ensure that the integrator
supports this capability before calling this function; if the
integrator does not support it, this method will throw an exception.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if integrator does not support error estimation.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-Expression-.set_throw_on_minimum_step_size_violation">
<span id="pydrake.systems.analysis.IntegratorBase_[Expression].set_throw_on_minimum_step_size_violation"></span><span class="sig-name descname"><span class="pre">set_throw_on_minimum_step_size_violation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-Expression-.set_throw_on_minimum_step_size_violation" title="Permalink to this definition"></a></dt>
<dd><p>Sets whether the integrator should throw a RuntimeError when the
integrator’s step size selection algorithm determines that it must
take a step smaller than the minimum step size (for, e.g., purposes of
error control). Default is <code class="docutils literal notranslate"><span class="pre">True</span></code>. If <code class="docutils literal notranslate"><span class="pre">False</span></code>, the integrator will
advance time and state using the minimum specified step size in such
situations. See integrator-minstep “this section” for more detail.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-Expression-.StartDenseIntegration">
<span id="pydrake.systems.analysis.IntegratorBase_[Expression].StartDenseIntegration"></span><span class="sig-name descname"><span class="pre">StartDenseIntegration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-Expression-.StartDenseIntegration" title="Permalink to this definition"></a></dt>
<dd><p>Starts dense integration, allocating a new dense output for this
integrator to use.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>The integrator has been initialized.</p>
</dd>
<dt>Precondition:</dt><dd><p>The system being integrated has continuous state.</p>
</dd>
<dt>Precondition:</dt><dd><p>No dense integration is in progress (no dense output is held by
the integrator)</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if any of the preconditions is not met.</strong> – </p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Dense integration may incur significant overhead.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-Expression-.StopDenseIntegration">
<span id="pydrake.systems.analysis.IntegratorBase_[Expression].StopDenseIntegration"></span><span class="sig-name descname"><span class="pre">StopDenseIntegration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.trajectories.html#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-Expression-.StopDenseIntegration" title="Permalink to this definition"></a></dt>
<dd><p>Stops dense integration, yielding ownership of the current dense
output to the caller.</p>
<dl class="simple">
<dt>Remark:</dt><dd><p>This process is irreversible.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A PiecewisePolynomial instance, i.e. a representation of the
continuous state trajectory of the system being integrated that
can be evaluated at any time within its extension. This
representation is defined starting at the context time of the last
StartDenseIntegration() call and finishing at the current context
time.</p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Dense integration is in progress (a dense output is held by this
integrator, after a call to StartDenseIntegration()).</p>
</dd>
<dt>Postcondition:</dt><dd><p>Previously held dense output is not updated nor referenced by the
integrator anymore.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if any of the preconditions is not met.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-float">
<span id="pydrake.systems.analysis.IntegratorBase_[float]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.systems.analysis.</span></span><span class="sig-name descname"><span class="pre">IntegratorBase_[float]</span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-float" title="Permalink to this definition"></a></dt>
<dd><p>An abstract class for an integrator for ODEs and DAEs as represented
by a Drake System. Integrators solve initial value problems of the
form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>ẋ(t) = f(t, x(t)) with f : ℝ × ℝⁿ → ℝⁿ
</pre></div>
</div>
<p>(i.e., <code class="docutils literal notranslate"><span class="pre">f()</span></code> is an ordinary differential equation) given initial
conditions (t₀, x₀). Thus, integrators advance the continuous state of
a dynamical system forward in time.</p>
<p>Drake’s subclasses of IntegratorBase&lt;T&gt; should follow the naming
pattern <code class="docutils literal notranslate"><span class="pre">FooIntegrator&lt;T&gt;</span></code> by convention.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-float-.__init__">
<span id="pydrake.systems.analysis.IntegratorBase_[float].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-float-.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-float-.get_dense_output">
<span id="pydrake.systems.analysis.IntegratorBase_[float].get_dense_output"></span><span class="sig-name descname"><span class="pre">get_dense_output</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.trajectories.html#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-float-.get_dense_output" title="Permalink to this definition"></a></dt>
<dd><p>Returns a const pointer to the integrator’s current
PiecewisePolynomial instance, holding a representation of the
continuous state trajectory since the last StartDenseIntegration()
call. This is suitable to query the integrator’s current dense output,
if any (may be nullptr).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-float-.get_fixed_step_mode">
<span id="pydrake.systems.analysis.IntegratorBase_[float].get_fixed_step_mode"></span><span class="sig-name descname"><span class="pre">get_fixed_step_mode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-float-.get_fixed_step_mode" title="Permalink to this definition"></a></dt>
<dd><p>Gets whether an integrator is running in fixed step mode. If the
integrator does not support error estimation, this function will
always return <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>set_fixed_step_mode()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-float-.get_maximum_step_size">
<span id="pydrake.systems.analysis.IntegratorBase_[float].get_maximum_step_size"></span><span class="sig-name descname"><span class="pre">get_maximum_step_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-float-.get_maximum_step_size" title="Permalink to this definition"></a></dt>
<dd><p>Gets the maximum step size that may be taken by this integrator. This
is a soft maximum: the integrator may stretch it by as much as 1% to
hit a discrete event.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>set_requested_minimum_step_size()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-float-.get_requested_minimum_step_size">
<span id="pydrake.systems.analysis.IntegratorBase_[float].get_requested_minimum_step_size"></span><span class="sig-name descname"><span class="pre">get_requested_minimum_step_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-float-.get_requested_minimum_step_size" title="Permalink to this definition"></a></dt>
<dd><p>Gets the requested minimum step size <code class="docutils literal notranslate"><span class="pre">h_min</span></code> for this integrator.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>set_requested_minimum_step_size()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>get_working_minimum_step_size(T)</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-float-.get_target_accuracy">
<span id="pydrake.systems.analysis.IntegratorBase_[float].get_target_accuracy"></span><span class="sig-name descname"><span class="pre">get_target_accuracy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-float-.get_target_accuracy" title="Permalink to this definition"></a></dt>
<dd><p>Gets the target accuracy.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>get_accuracy_in_use()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-float-.get_throw_on_minimum_step_size_violation">
<span id="pydrake.systems.analysis.IntegratorBase_[float].get_throw_on_minimum_step_size_violation"></span><span class="sig-name descname"><span class="pre">get_throw_on_minimum_step_size_violation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-float-.get_throw_on_minimum_step_size_violation" title="Permalink to this definition"></a></dt>
<dd><p>Reports the current setting of the
throw_on_minimum_step_size_violation flag.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>set_throw_on_minimum_step_size_violation().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-float-.set_fixed_step_mode">
<span id="pydrake.systems.analysis.IntegratorBase_[float].set_fixed_step_mode"></span><span class="sig-name descname"><span class="pre">set_fixed_step_mode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-float-.set_fixed_step_mode" title="Permalink to this definition"></a></dt>
<dd><p>Sets an integrator with error control to fixed step mode. If the
integrator runs in fixed step mode, it will always take the maximum
step size directed (which may be that determined by
get_maximum_step_size(), or may be smaller, as directed by, e.g.,
Simulator for event handling purposes).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The error estimation process will still be active (so
get_error_estimate() will still return a correct result), meaning
that the additional (typically, but not necessarily small)
computation required for error estimation will still be performed.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if integrator does not support error estimation and</strong> – </p></li>
<li><p><strong>flag` is set to False</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-float-.set_maximum_step_size">
<span id="pydrake.systems.analysis.IntegratorBase_[float].set_maximum_step_size"></span><span class="sig-name descname"><span class="pre">set_maximum_step_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-float-.set_maximum_step_size" title="Permalink to this definition"></a></dt>
<dd><p>&#64;anchor integrator-maxstep &#64;name Methods related to maximum
integration step size</p>
<p>Sets the <em>nominal</em> maximum step size- the actual maximum step size
taken may be slightly larger (see set_maximum_step_size() and
get_stretch_factor())- that an integrator will take. Each integrator
has a default maximum step size, which might be infinite. Sets the
maximum step size that may be taken by this integrator. This setting
should be used if you know the maximum time scale of your problem. The
integrator may stretch the maximum step size by as much as 1% to reach
a discrete event. For fixed step integrators, all steps will be taken
at the maximum step size <em>unless</em> an event would be missed.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>See integrator-initial-step-size “Initial step size selection”</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-float-.set_requested_minimum_step_size">
<span id="pydrake.systems.analysis.IntegratorBase_[float].set_requested_minimum_step_size"></span><span class="sig-name descname"><span class="pre">set_requested_minimum_step_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-float-.set_requested_minimum_step_size" title="Permalink to this definition"></a></dt>
<dd><p>Sets the requested minimum step size <code class="docutils literal notranslate"><span class="pre">h_min</span></code> that may be taken by
this integrator. No step smaller than this will be taken except under
circumstances as described integrator-minstep “above”. This setting
will be ignored if it is smaller than the absolute minimum <code class="docutils literal notranslate"><span class="pre">h_floor</span></code>
also described above. Default value is zero.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">min_step_size</span></code>:</dt><dd><p>a non-negative value. Setting this value to zero will cause the
integrator to use a reasonable value instead (see
get_working_minimum_step_size()).</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>get_requested_minimum_step_size()</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>get_working_minimum_step_size()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-float-.set_target_accuracy">
<span id="pydrake.systems.analysis.IntegratorBase_[float].set_target_accuracy"></span><span class="sig-name descname"><span class="pre">set_target_accuracy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-float-.set_target_accuracy" title="Permalink to this definition"></a></dt>
<dd><p>&#64;anchor integrator-accuracy &#64;name Methods for getting and setting
integrator accuracy The precise meaning of <em>accuracy</em> is a complicated
discussion, but it translates roughly to the number of significant
digits you want in the results. By convention it is supplied as
<code class="docutils literal notranslate"><span class="pre">10^-digits</span></code>, meaning that an accuracy of 1e-3 provides about three
significant digits. For more discussion of accuracy, see
accuracy_and_tolerance and ref. <a class="reference external" href="https://dx.doi.org/10.1016/j.piutam.2011.04.023">[1]</a>.</p>
<p>Integrators vary in the range of accuracy (loosest to tightest) that
they can support, and each integrator will choose a default accuracy
to be used that lies somewhere within this range and attempts to
balance computation and accuracy. If you request accuracy outside the
supported range for the chosen integrator it will be quietly adjusted
to be in range. You can find out the accuracy setting actually being
used using <code class="docutils literal notranslate"><span class="pre">get_accuracy_in_use()</span></code>.</p>
<p>Implicit integrators additionally use the accuracy setting for
determining when the underlying Newton-Raphson root finding process
has converged. For those integrators, the accuracy setting also limits
the allowable iteration error in the Newton-Raphson process. Looser
accuracy in that process certainly implies greater error in the ODE
solution and might impact the stability of the solution negatively as
well.</p>
<ul class="simple">
<li><p>[1] M. Sherman, A. Seth, S. Delp. Procedia IUTAM 2:241-261 (2011),</p></li>
</ul>
<p>Section 3.3. <a class="reference external" href="https://dx.doi.org/10.1016/j.piutam.2011.04.023">https://dx.doi.org/10.1016/j.piutam.2011.04.023</a></p>
<p>Request that the integrator attempt to achieve a particular accuracy
for the continuous portions of the simulation. Otherwise a default
accuracy is chosen for you. This may be ignored for fixed-step
integration since accuracy control requires variable step sizes. You
should call supports_error_estimation() to ensure that the integrator
supports this capability before calling this function; if the
integrator does not support it, this method will throw an exception.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if integrator does not support error estimation.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-float-.set_throw_on_minimum_step_size_violation">
<span id="pydrake.systems.analysis.IntegratorBase_[float].set_throw_on_minimum_step_size_violation"></span><span class="sig-name descname"><span class="pre">set_throw_on_minimum_step_size_violation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-float-.set_throw_on_minimum_step_size_violation" title="Permalink to this definition"></a></dt>
<dd><p>Sets whether the integrator should throw a RuntimeError when the
integrator’s step size selection algorithm determines that it must
take a step smaller than the minimum step size (for, e.g., purposes of
error control). Default is <code class="docutils literal notranslate"><span class="pre">True</span></code>. If <code class="docutils literal notranslate"><span class="pre">False</span></code>, the integrator will
advance time and state using the minimum specified step size in such
situations. See integrator-minstep “this section” for more detail.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-float-.StartDenseIntegration">
<span id="pydrake.systems.analysis.IntegratorBase_[float].StartDenseIntegration"></span><span class="sig-name descname"><span class="pre">StartDenseIntegration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-float-.StartDenseIntegration" title="Permalink to this definition"></a></dt>
<dd><p>Starts dense integration, allocating a new dense output for this
integrator to use.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>The integrator has been initialized.</p>
</dd>
<dt>Precondition:</dt><dd><p>The system being integrated has continuous state.</p>
</dd>
<dt>Precondition:</dt><dd><p>No dense integration is in progress (no dense output is held by
the integrator)</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if any of the preconditions is not met.</strong> – </p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Dense integration may incur significant overhead.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.IntegratorBase_-float-.StopDenseIntegration">
<span id="pydrake.systems.analysis.IntegratorBase_[float].StopDenseIntegration"></span><span class="sig-name descname"><span class="pre">StopDenseIntegration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.trajectories.html#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.systems.analysis.IntegratorBase_-float-.StopDenseIntegration" title="Permalink to this definition"></a></dt>
<dd><p>Stops dense integration, yielding ownership of the current dense
output to the caller.</p>
<dl class="simple">
<dt>Remark:</dt><dd><p>This process is irreversible.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A PiecewisePolynomial instance, i.e. a representation of the
continuous state trajectory of the system being integrated that
can be evaluated at any time within its extension. This
representation is defined starting at the context time of the last
StartDenseIntegration() call and finishing at the current context
time.</p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Dense integration is in progress (a dense output is held by this
integrator, after a call to StartDenseIntegration()).</p>
</dd>
<dt>Postcondition:</dt><dd><p>Previously held dense output is not updated nor referenced by the
integrator anymore.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if any of the preconditions is not met.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.systems.analysis.MonteCarloSimulation">
<span class="sig-prename descclassname"><span class="pre">pydrake.systems.analysis.</span></span><span class="sig-name descname"><span class="pre">MonteCarloSimulation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">make_simulator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">pydrake.common._module_py.RandomGenerator</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.System_" title="pydrake.systems.framework.System_"><span class="pre">pydrake.systems.framework.System_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">final_time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_samples</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">generator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.common._module_py.RandomGenerator</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#pydrake.systems.analysis.RandomSimulationResult" title="pydrake.systems.analysis.RandomSimulationResult"><span class="pre">pydrake.systems.analysis.RandomSimulationResult</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.systems.analysis.MonteCarloSimulation" title="Permalink to this definition"></a></dt>
<dd><p>Generates samples of a scalar random variable output by running many
random simulations drawn from independent samples of the distributions
governing the stochastic simulation.</p>
<p>In pseudo-code, this algorithm implements:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">:</span><span class="n">num_samples</span>
    <span class="n">const</span> <span class="n">generator_snapshot</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">generator</span><span class="p">)</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">RandomSimulation</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">generator</span><span class="p">)</span>
    <span class="n">data</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">std</span><span class="p">::</span><span class="n">pair</span><span class="p">(</span><span class="n">generator_snapshot</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">data</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RandomSimulation() for details about <code class="docutils literal notranslate"><span class="pre">make_simulator</span></code>,
<code class="docutils literal notranslate"><span class="pre">output</span></code>, and <code class="docutils literal notranslate"><span class="pre">final_time</span></code>.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_samples</span></code>:</dt><dd><p>Number of independent samples to draw from the distribution (and
equivalently, the number of simulations to run).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">generator</span></code>:</dt><dd><p>Random number generator to be used to generate the random samples.
If null, then a new RandomGenerator will be allocated and used
internally (and repeated calls to this method will return
identical results). To produce statistically “independent” samples
on a future call to MonteCarloSimulation, you should make repeated
uses of the same RandomGenerator object.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_parallel_executions</span></code>:</dt><dd><p>Specify number of parallel executions to use while performing
<code class="docutils literal notranslate"><span class="pre">num_samples</span></code> simulations. The default value, kNoConcurrency,
specifies that simulations should be executed in serial. To use
the default concurrency available on your hardware (equivalent to
num_parallel_executions=std::thread::hardware_concurrency()), use
value kUseHardwareConcurrency. Otherwise, num_parallel_executions
must be &gt;= 1.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a list of RandomSimulationResult’s.</p>
</dd>
</dl>
<p>Thread safety when parallel execution is specified: -
<code class="docutils literal notranslate"><span class="pre">make_simulator</span></code> and <code class="docutils literal notranslate"><span class="pre">generator</span></code> are only accessed from the main
thread.</p>
<ul class="simple">
<li><p>Each simulator created by <code class="docutils literal notranslate"><span class="pre">make_simulator</span></code> and its context are only
accessed from within a single worker thread; however, any resource shared
between these simulators must be safe for concurrent use.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">output</span></code> is called from within worker threads performing simulation with
the simulator and context belonging to each worker thread. It must be safe
to make concurrent calls to <code class="docutils literal notranslate"><span class="pre">output</span></code> (i.e. any mutable state inside the
function must be safe for concurrent use).</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.systems.analysis.PrintSimulatorStatistics">
<span class="sig-prename descclassname"><span class="pre">pydrake.systems.analysis.</span></span><span class="sig-name descname"><span class="pre">PrintSimulatorStatistics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.systems.analysis.PrintSimulatorStatistics" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>PrintSimulatorStatistics(arg0: pydrake.systems.analysis.Simulator_[float]) -&gt; None</p></li>
</ol>
<p>This method outputs to stdout relevant simulation statistics for a
simulator that advanced the state of a system forward in time.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">simulator</span></code>:</dt><dd><p>The simulator to output statistics for.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>PrintSimulatorStatistics(arg0: pydrake.systems.analysis.Simulator_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>This method outputs to stdout relevant simulation statistics for a
simulator that advanced the state of a system forward in time.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">simulator</span></code>:</dt><dd><p>The simulator to output statistics for.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.systems.analysis.RandomSimulation">
<span class="sig-prename descclassname"><span class="pre">pydrake.systems.analysis.</span></span><span class="sig-name descname"><span class="pre">RandomSimulation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">make_simulator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">pydrake.common._module_py.RandomGenerator</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.System_" title="pydrake.systems.framework.System_"><span class="pre">pydrake.systems.framework.System_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">final_time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">generator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">pydrake.common._module_py.RandomGenerator</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.RandomSimulation" title="Permalink to this definition"></a></dt>
<dd><p>Run a deterministic simulation of a (stochastic) System using the
<code class="docutils literal notranslate"><span class="pre">generator</span></code> to instantiate all “random” quantities.</p>
<p>In pseudo-code, this algorithm implements:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">simulator</span> <span class="o">=</span> <span class="n">make_simulator</span><span class="p">(</span><span class="n">generator</span><span class="p">)</span>
  <span class="n">simulator</span><span class="o">.</span><span class="n">get_system</span><span class="p">()</span><span class="o">.</span><span class="n">SetRandomContext</span><span class="p">(</span><span class="n">generator</span><span class="p">)</span>
  <span class="n">simulator</span><span class="o">.</span><span class="n">AdvanceTo</span><span class="p">(</span><span class="n">final_time</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">output</span><span class="p">(</span><span class="n">simulator</span><span class="o">.</span><span class="n">get_context</span><span class="p">())</span>
</pre></div>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">make_simulator</span></code>:</dt><dd><p>Callers to this method define a stochastic simulation by providing
the <code class="docutils literal notranslate"><span class="pre">make_simulator</span></code> factory method to return a Simulator using
the supplied RandomGenerator as the only source of randomness.
This interface was designed to support cases where the
System/Diagram is random (not only the Context), e.g. in the case
where are variable number of objects are added to a multibody
simulation.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">output</span></code>:</dt><dd><p>The scalar random variable output, denoted <code class="docutils literal notranslate"><span class="pre">output</span></code>, is defined
as a function of the Simulator’s System’s Context, evaluated at
the <code class="docutils literal notranslate"><span class="pre">final_time</span></code>. Monte-Carlo investigations that studying the
details of an entire trajectory can still use this interface, e.g.
by including a “runtime monitor” System that latches the
worst-case deviation of a specification into it’s Context to be
queried at the final time.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">final_time</span></code>:</dt><dd><p>The time that each instance of the Simulator is stepped to. In
many cases, this will be equivalent to the duration of the
simulation, but it need not be because SetRandomContext() could
initialize the time to a non-zero value, or an event could trigger
premature termination of the simulation (see #4447).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">generator</span></code>:</dt><dd><p>Random number generator to be used to generate the random samples.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>the <code class="docutils literal notranslate"><span class="pre">output</span></code> evaluated from the Context at <code class="docutils literal notranslate"><span class="pre">final_time</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.systems.analysis.RandomSimulationResult">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.systems.analysis.</span></span><span class="sig-name descname"><span class="pre">RandomSimulationResult</span></span><a class="headerlink" href="#pydrake.systems.analysis.RandomSimulationResult" title="Permalink to this definition"></a></dt>
<dd><p>A snapshot of the generator used to produce the random simulation.
Use, e.g.,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">RandomGenerator</span> <span class="n">generator</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">generator_snapshot</span><span class="p">)</span>
  <span class="n">RandomSimulation</span><span class="p">(</span><span class="n">make_simulator</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">final_time</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">generator</span><span class="p">)</span>
</pre></div>
</div>
<p>for a deterministic playback of the sampled simulation.
RandomNumberEngine concept&lt;/a&gt;, if you wish to serialize the results.
Note that performing any non-const operations on generator_snapshot
may advance the state of the generator and make it no longer capable
of reproducing the simulation.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.RandomSimulationResult.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.systems.analysis.RandomSimulationResult.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.systems.analysis.RandomSimulationResult.generator_snapshot">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">generator_snapshot</span></span><a class="headerlink" href="#pydrake.systems.analysis.RandomSimulationResult.generator_snapshot" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.systems.analysis.RandomSimulationResult.output">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">output</span></span><a class="headerlink" href="#pydrake.systems.analysis.RandomSimulationResult.output" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.systems.analysis.RegionOfAttraction">
<span class="sig-prename descclassname"><span class="pre">pydrake.systems.analysis.</span></span><span class="sig-name descname"><span class="pre">RegionOfAttraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">system</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.System_" title="pydrake.systems.framework.System_"><span class="pre">pydrake.systems.framework.System_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">options</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.RegionOfAttractionOptions" title="pydrake.systems.analysis.RegionOfAttractionOptions"><span class="pre">pydrake.systems.analysis.RegionOfAttractionOptions</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">RegionOfAttractionOptions(lyapunov_candidate=0,</span> <span class="pre">state_variables=[],</span> <span class="pre">use_implicit_dynamics=False)</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></span><a class="headerlink" href="#pydrake.systems.analysis.RegionOfAttraction" title="Permalink to this definition"></a></dt>
<dd><p>Estimates the region of attraction of the time-invariant <code class="docutils literal notranslate"><span class="pre">system</span></code> at
the fixed point defined by <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<p>This implementation only searches for the largest level set of the
<code class="docutils literal notranslate"><span class="pre">lyapunov_candidate</span></code> function from <code class="docutils literal notranslate"><span class="pre">options</span></code> (or a candidate
obtained from solving the Lyapunov equation on the linearization).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">system</span></code>:</dt><dd><p>a time-invariant continuous-time System that supports scalar-type
conversion to symbolic::Expression. The dynamics of the system
must be polynomial.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>a Context that defines the parameters of the system and the
fixed-point about which we are analyzing the regional stability.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">options</span></code>:</dt><dd><p>provides a variety of configuration options.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RegionOfAttractionOptions.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a symbolic::Expression representing a Lyapunov function using the
symbolic Variables named x0, x1…, where the order matches the
continuous state vector in the <code class="docutils literal notranslate"><span class="pre">context</span></code>, or the vector
state_variables passed in through the options structure (if it is
non-empty). The level set {x | V(x)&lt;=1} containing the fixed-point
in <code class="docutils literal notranslate"><span class="pre">context</span></code> represents the region of attraction.</p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>For the given <code class="docutils literal notranslate"><span class="pre">system</span></code> and <code class="docutils literal notranslate"><span class="pre">context</span></code>, any required input ports
on <code class="docutils literal notranslate"><span class="pre">system</span></code> must be “defined”, i.e., connected to other systems
in a larger diagram or holding fixed values; see
System::FixInputPortsFrom for possible caveats. Analyzing a
closed-loop system would typically be accomplished by having both
the plant and the controller in a diagram (which then has no input
ports), and passing the diagram into this method as <code class="docutils literal notranslate"><span class="pre">system</span></code>.</p>
</dd>
</dl>
<p>Note: There are more numerical recipes for region of attraction
analysis that could extend the current implementation. Do report an
issue if you discover a system for which this code does not perform
well.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.systems.analysis.RegionOfAttractionOptions">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.systems.analysis.</span></span><span class="sig-name descname"><span class="pre">RegionOfAttractionOptions</span></span><a class="headerlink" href="#pydrake.systems.analysis.RegionOfAttractionOptions" title="Permalink to this definition"></a></dt>
<dd><p>Consolidates the many possible options to be passed to the region of
attraction algorithm.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.RegionOfAttractionOptions.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.RegionOfAttractionOptions" title="pydrake.systems.analysis.RegionOfAttractionOptions"><span class="pre">pydrake.systems.analysis.RegionOfAttractionOptions</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.RegionOfAttractionOptions.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.systems.analysis.RegionOfAttractionOptions.lyapunov_candidate">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">lyapunov_candidate</span></span><a class="headerlink" href="#pydrake.systems.analysis.RegionOfAttractionOptions.lyapunov_candidate" title="Permalink to this definition"></a></dt>
<dd><p>A candidate Lyapunov function using the symbolic Variables named x0,
x1, …, where the order matches the continuous state vector of the
system being evaluated (or the vector state_variables).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.systems.analysis.RegionOfAttractionOptions.state_variables">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">state_variables</span></span><a class="headerlink" href="#pydrake.systems.analysis.RegionOfAttractionOptions.state_variables" title="Permalink to this definition"></a></dt>
<dd><p>If non-empty, a list of Variable that associates the variable name
with the elements of the System’s continuous state vector. Must be
empty or have size equal to the number of continuous state variables
in the system.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.systems.analysis.RegionOfAttractionOptions.use_implicit_dynamics">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">use_implicit_dynamics</span></span><a class="headerlink" href="#pydrake.systems.analysis.RegionOfAttractionOptions.use_implicit_dynamics" title="Permalink to this definition"></a></dt>
<dd><p>If true, the system dynamics will be evaluated using
CalcImplicitTimeDerivativesResidual instead of CalcTimeDerivatives to
obtain g(x,ẋ) = 0 (instead of ẋ = f(x)). The Lyapunov conditions
will also be evaluated in the implicit form. This is more expensive
than analysis in the explicit form, as it requires more
indeterminates, but it enables analysis of systems with rational
polynomial dynamics.</p>
<p>See <a class="reference external" href="https://underactuated.csail.mit.edu/lyapunov.html#ex:implicit">https://underactuated.csail.mit.edu/lyapunov.html#ex:implicit</a> for
more details.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pydrake.systems.analysis.ResetIntegratorFromFlags">
<span class="sig-prename descclassname"><span class="pre">pydrake.systems.analysis.</span></span><span class="sig-name descname"><span class="pre">ResetIntegratorFromFlags</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.systems.analysis.ResetIntegratorFromFlags" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>ResetIntegratorFromFlags(simulator: pydrake.systems.analysis.Simulator_[float], scheme: str, max_step_size: float) -&gt; pydrake.systems.analysis.IntegratorBase_[float]</p></li>
</ol>
<p>Resets the integrator used to advanced the continuous time dynamics of
the system associated with <code class="docutils literal notranslate"><span class="pre">simulator</span></code> according to the given
arguments.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">simulator</span></code>:</dt><dd><p>On input, a valid pointer to a Simulator. On output the integrator
for <code class="docutils literal notranslate"><span class="pre">simulator</span></code> is reset according to the given arguments.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">scheme</span></code>:</dt><dd><p>Integration scheme to be used, e.g., “runge_kutta2”. See
GetIntegrationSchemes() for a the list of valid options.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">max_step_size</span></code>:</dt><dd><p>The IntegratorBase::set_maximum_step_size() value.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A reference to the newly created integrator owned by
<code class="docutils literal notranslate"><span class="pre">simulator</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>ResetIntegratorFromFlags(simulator: pydrake.systems.analysis.Simulator_[AutoDiffXd], scheme: str, max_step_size: pydrake.autodiffutils.AutoDiffXd) -&gt; pydrake.systems.analysis.IntegratorBase_[AutoDiffXd]</p></li>
</ol>
<p>Resets the integrator used to advanced the continuous time dynamics of
the system associated with <code class="docutils literal notranslate"><span class="pre">simulator</span></code> according to the given
arguments.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">simulator</span></code>:</dt><dd><p>On input, a valid pointer to a Simulator. On output the integrator
for <code class="docutils literal notranslate"><span class="pre">simulator</span></code> is reset according to the given arguments.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">scheme</span></code>:</dt><dd><p>Integration scheme to be used, e.g., “runge_kutta2”. See
GetIntegrationSchemes() for a the list of valid options.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">max_step_size</span></code>:</dt><dd><p>The IntegratorBase::set_maximum_step_size() value.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A reference to the newly created integrator owned by
<code class="docutils literal notranslate"><span class="pre">simulator</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.systems.analysis.RungeKutta2Integrator">
<span class="sig-prename descclassname"><span class="pre">pydrake.systems.analysis.</span></span><span class="sig-name descname"><span class="pre">RungeKutta2Integrator</span></span><a class="headerlink" href="#pydrake.systems.analysis.RungeKutta2Integrator" title="Permalink to this definition"></a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.systems.analysis.RungeKutta2Integrator_-float" title="pydrake.systems.analysis.RungeKutta2Integrator_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.analysis.RungeKutta2Integrator_[float]</span></code></a></p>
</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.systems.analysis.RungeKutta2Integrator_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.systems.analysis.</span></span><span class="sig-name descname"><span class="pre">RungeKutta2Integrator_</span></span><a class="headerlink" href="#pydrake.systems.analysis.RungeKutta2Integrator_" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.systems.analysis.RungeKutta2Integrator_-float" title="pydrake.systems.analysis.RungeKutta2Integrator_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">RungeKutta2Integrator_[float]</span></code></a>, <a class="reference internal" href="#pydrake.systems.analysis.RungeKutta2Integrator_-AutoDiffXd" title="pydrake.systems.analysis.RungeKutta2Integrator_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">RungeKutta2Integrator_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.systems.analysis.RungeKutta2Integrator_-Expression" title="pydrake.systems.analysis.RungeKutta2Integrator_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">RungeKutta2Integrator_[Expression]</span></code></a></p>
<dl class="py class">
<dt class="sig sig-object py" id="pydrake.systems.analysis.RungeKutta2Integrator_.RungeKutta2Integrator_-float">
<span id="pydrake.systems.analysis.RungeKutta2Integrator_.RungeKutta2Integrator_[float]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RungeKutta2Integrator_[float]</span></span><a class="headerlink" href="#pydrake.systems.analysis.RungeKutta2Integrator_.RungeKutta2Integrator_-float" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_-float" title="pydrake.systems.analysis.IntegratorBase_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.analysis.IntegratorBase_[float]</span></code></a></p>
<p>A second-order, explicit Runge Kutta integrator.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.RungeKutta2Integrator_.RungeKutta2Integrator_-float-.__init__">
<span id="pydrake.systems.analysis.RungeKutta2Integrator_.RungeKutta2Integrator_[float].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.RungeKutta2Integrator_" title="pydrake.systems.analysis.RungeKutta2Integrator_"><span class="pre">pydrake.systems.analysis.RungeKutta2Integrator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">system</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.System_" title="pydrake.systems.framework.System_"><span class="pre">pydrake.systems.framework.System_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_step_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.RungeKutta2Integrator_.RungeKutta2Integrator_-float-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Constructs fixed-step integrator for a given system using the given
context for initial conditions.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">system</span></code>:</dt><dd><p>A reference to the system to be simulated</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">max_step_size</span></code>:</dt><dd><p>The maximum (fixed) step size; the integrator will not take larger
step sizes than this.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>pointer to the context (nullptr is ok, but the caller must set a
non-null context before Initialize()-ing the integrator).</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Initialize()</p>
</div>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.systems.analysis.RungeKutta2Integrator_-AutoDiffXd">
<span id="pydrake.systems.analysis.RungeKutta2Integrator_[AutoDiffXd]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.systems.analysis.</span></span><span class="sig-name descname"><span class="pre">RungeKutta2Integrator_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.systems.analysis.RungeKutta2Integrator_-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_-AutoDiffXd" title="pydrake.systems.analysis.IntegratorBase_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.analysis.IntegratorBase_[AutoDiffXd]</span></code></a></p>
<p>A second-order, explicit Runge Kutta integrator.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.RungeKutta2Integrator_-AutoDiffXd-.__init__">
<span id="pydrake.systems.analysis.RungeKutta2Integrator_[AutoDiffXd].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.RungeKutta2Integrator_" title="pydrake.systems.analysis.RungeKutta2Integrator_"><span class="pre">pydrake.systems.analysis.RungeKutta2Integrator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">system</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.System_" title="pydrake.systems.framework.System_"><span class="pre">pydrake.systems.framework.System_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_step_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.RungeKutta2Integrator_-AutoDiffXd-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Constructs fixed-step integrator for a given system using the given
context for initial conditions.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">system</span></code>:</dt><dd><p>A reference to the system to be simulated</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">max_step_size</span></code>:</dt><dd><p>The maximum (fixed) step size; the integrator will not take larger
step sizes than this.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>pointer to the context (nullptr is ok, but the caller must set a
non-null context before Initialize()-ing the integrator).</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Initialize()</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.systems.analysis.RungeKutta2Integrator_-Expression">
<span id="pydrake.systems.analysis.RungeKutta2Integrator_[Expression]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.systems.analysis.</span></span><span class="sig-name descname"><span class="pre">RungeKutta2Integrator_[Expression]</span></span><a class="headerlink" href="#pydrake.systems.analysis.RungeKutta2Integrator_-Expression" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_-Expression" title="pydrake.systems.analysis.IntegratorBase_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.analysis.IntegratorBase_[Expression]</span></code></a></p>
<p>A second-order, explicit Runge Kutta integrator.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.RungeKutta2Integrator_-Expression-.__init__">
<span id="pydrake.systems.analysis.RungeKutta2Integrator_[Expression].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.RungeKutta2Integrator_" title="pydrake.systems.analysis.RungeKutta2Integrator_"><span class="pre">pydrake.systems.analysis.RungeKutta2Integrator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">system</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.System_" title="pydrake.systems.framework.System_"><span class="pre">pydrake.systems.framework.System_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_step_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.RungeKutta2Integrator_-Expression-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Constructs fixed-step integrator for a given system using the given
context for initial conditions.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">system</span></code>:</dt><dd><p>A reference to the system to be simulated</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">max_step_size</span></code>:</dt><dd><p>The maximum (fixed) step size; the integrator will not take larger
step sizes than this.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>pointer to the context (nullptr is ok, but the caller must set a
non-null context before Initialize()-ing the integrator).</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Initialize()</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.systems.analysis.RungeKutta2Integrator_-float">
<span id="pydrake.systems.analysis.RungeKutta2Integrator_[float]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.systems.analysis.</span></span><span class="sig-name descname"><span class="pre">RungeKutta2Integrator_[float]</span></span><a class="headerlink" href="#pydrake.systems.analysis.RungeKutta2Integrator_-float" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_-float" title="pydrake.systems.analysis.IntegratorBase_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.analysis.IntegratorBase_[float]</span></code></a></p>
<p>A second-order, explicit Runge Kutta integrator.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.RungeKutta2Integrator_-float-.__init__">
<span id="pydrake.systems.analysis.RungeKutta2Integrator_[float].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.RungeKutta2Integrator_" title="pydrake.systems.analysis.RungeKutta2Integrator_"><span class="pre">pydrake.systems.analysis.RungeKutta2Integrator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">system</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.System_" title="pydrake.systems.framework.System_"><span class="pre">pydrake.systems.framework.System_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_step_size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.RungeKutta2Integrator_-float-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Constructs fixed-step integrator for a given system using the given
context for initial conditions.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">system</span></code>:</dt><dd><p>A reference to the system to be simulated</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">max_step_size</span></code>:</dt><dd><p>The maximum (fixed) step size; the integrator will not take larger
step sizes than this.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>pointer to the context (nullptr is ok, but the caller must set a
non-null context before Initialize()-ing the integrator).</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Initialize()</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.systems.analysis.RungeKutta3Integrator">
<span class="sig-prename descclassname"><span class="pre">pydrake.systems.analysis.</span></span><span class="sig-name descname"><span class="pre">RungeKutta3Integrator</span></span><a class="headerlink" href="#pydrake.systems.analysis.RungeKutta3Integrator" title="Permalink to this definition"></a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.systems.analysis.RungeKutta3Integrator_-float" title="pydrake.systems.analysis.RungeKutta3Integrator_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.analysis.RungeKutta3Integrator_[float]</span></code></a></p>
</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.systems.analysis.RungeKutta3Integrator_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.systems.analysis.</span></span><span class="sig-name descname"><span class="pre">RungeKutta3Integrator_</span></span><a class="headerlink" href="#pydrake.systems.analysis.RungeKutta3Integrator_" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.systems.analysis.RungeKutta3Integrator_-float" title="pydrake.systems.analysis.RungeKutta3Integrator_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">RungeKutta3Integrator_[float]</span></code></a>, <a class="reference internal" href="#pydrake.systems.analysis.RungeKutta3Integrator_-AutoDiffXd" title="pydrake.systems.analysis.RungeKutta3Integrator_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">RungeKutta3Integrator_[AutoDiffXd]</span></code></a></p>
<dl class="py class">
<dt class="sig sig-object py" id="pydrake.systems.analysis.RungeKutta3Integrator_.RungeKutta3Integrator_-float">
<span id="pydrake.systems.analysis.RungeKutta3Integrator_.RungeKutta3Integrator_[float]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">RungeKutta3Integrator_[float]</span></span><a class="headerlink" href="#pydrake.systems.analysis.RungeKutta3Integrator_.RungeKutta3Integrator_-float" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_-float" title="pydrake.systems.analysis.IntegratorBase_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.analysis.IntegratorBase_[float]</span></code></a></p>
<p>A third-order Runge Kutta integrator with a third order error
estimate.</p>
<p>For a discussion of this Runge-Kutta method, see [Butcher, 1987]. The
embedded error estimate was derived using the method mentioned in
[Hairer, 1993].</p>
<p>The Butcher tableau for this integrator follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span>
<span class="mi">0</span>      <span class="o">|</span>
<span class="mi">1</span><span class="o">/</span><span class="mi">2</span>    <span class="o">|</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span>
<span class="mi">1</span>      <span class="o">|</span> <span class="o">-</span><span class="mi">1</span>          <span class="mi">2</span>
<span class="o">---------------------------------------------------------------------------</span>
         <span class="mi">1</span><span class="o">/</span><span class="mi">6</span>         <span class="mi">2</span><span class="o">/</span><span class="mi">3</span>       <span class="mi">1</span><span class="o">/</span><span class="mi">6</span>
         <span class="mi">0</span>           <span class="mi">1</span>         <span class="mi">0</span>
</pre></div>
</div>
<p>where the second to last row is the 3rd-order propagated solution and
the last row is the 2nd-order midpoint used for the error estimate.</p>
<p>The following documentation is pulled from Simbody’s implementation of
this integrator: “This is a 3-stage, first-same-as-last (FSAL) 3rd
order method which gives us an embedded 2nd order method as well, so
we can extract a 3rd-order error estimate for the 2nd-order result,
which error estimate can then be used for step size control, since it
will behave as h^3. We then propagate the 3rd order result (whose
error is unknown), which Hairer calls ‘local extrapolation’. We call
the initial state (t0,y0) and want (t0+h,y1). We are given the initial
derivative f0=f(t0,y0), which most likely is left over from an
evaluation at the end of the last step.”</p>
<ul class="simple">
<li><p>[Butcher, 1987] J. C. Butcher. The Numerical Analysis of Ordinary
Differential Equations. John Wiley &amp; Sons, 1987. p. 325.</p></li>
<li><p>[Hairer, 1993] E. Hairer, S. Noersett, and G. Wanner. Solving ODEs I. 2nd
rev. ed. Springer, 1993. p. 166.</p></li>
</ul>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.RungeKutta3Integrator_.RungeKutta3Integrator_-float-.__init__">
<span id="pydrake.systems.analysis.RungeKutta3Integrator_.RungeKutta3Integrator_[float].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.RungeKutta3Integrator_" title="pydrake.systems.analysis.RungeKutta3Integrator_"><span class="pre">pydrake.systems.analysis.RungeKutta3Integrator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">system</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.System_" title="pydrake.systems.framework.System_"><span class="pre">pydrake.systems.framework.System_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.RungeKutta3Integrator_.RungeKutta3Integrator_-float-.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.systems.analysis.RungeKutta3Integrator_-AutoDiffXd">
<span id="pydrake.systems.analysis.RungeKutta3Integrator_[AutoDiffXd]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.systems.analysis.</span></span><span class="sig-name descname"><span class="pre">RungeKutta3Integrator_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.systems.analysis.RungeKutta3Integrator_-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_-AutoDiffXd" title="pydrake.systems.analysis.IntegratorBase_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.analysis.IntegratorBase_[AutoDiffXd]</span></code></a></p>
<p>A third-order Runge Kutta integrator with a third order error
estimate.</p>
<p>For a discussion of this Runge-Kutta method, see [Butcher, 1987]. The
embedded error estimate was derived using the method mentioned in
[Hairer, 1993].</p>
<p>The Butcher tableau for this integrator follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span>
<span class="mi">0</span>      <span class="o">|</span>
<span class="mi">1</span><span class="o">/</span><span class="mi">2</span>    <span class="o">|</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span>
<span class="mi">1</span>      <span class="o">|</span> <span class="o">-</span><span class="mi">1</span>          <span class="mi">2</span>
<span class="o">---------------------------------------------------------------------------</span>
         <span class="mi">1</span><span class="o">/</span><span class="mi">6</span>         <span class="mi">2</span><span class="o">/</span><span class="mi">3</span>       <span class="mi">1</span><span class="o">/</span><span class="mi">6</span>
         <span class="mi">0</span>           <span class="mi">1</span>         <span class="mi">0</span>
</pre></div>
</div>
<p>where the second to last row is the 3rd-order propagated solution and
the last row is the 2nd-order midpoint used for the error estimate.</p>
<p>The following documentation is pulled from Simbody’s implementation of
this integrator: “This is a 3-stage, first-same-as-last (FSAL) 3rd
order method which gives us an embedded 2nd order method as well, so
we can extract a 3rd-order error estimate for the 2nd-order result,
which error estimate can then be used for step size control, since it
will behave as h^3. We then propagate the 3rd order result (whose
error is unknown), which Hairer calls ‘local extrapolation’. We call
the initial state (t0,y0) and want (t0+h,y1). We are given the initial
derivative f0=f(t0,y0), which most likely is left over from an
evaluation at the end of the last step.”</p>
<ul class="simple">
<li><p>[Butcher, 1987] J. C. Butcher. The Numerical Analysis of Ordinary
Differential Equations. John Wiley &amp; Sons, 1987. p. 325.</p></li>
<li><p>[Hairer, 1993] E. Hairer, S. Noersett, and G. Wanner. Solving ODEs I. 2nd
rev. ed. Springer, 1993. p. 166.</p></li>
</ul>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.RungeKutta3Integrator_-AutoDiffXd-.__init__">
<span id="pydrake.systems.analysis.RungeKutta3Integrator_[AutoDiffXd].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.RungeKutta3Integrator_" title="pydrake.systems.analysis.RungeKutta3Integrator_"><span class="pre">pydrake.systems.analysis.RungeKutta3Integrator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">system</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.System_" title="pydrake.systems.framework.System_"><span class="pre">pydrake.systems.framework.System_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.RungeKutta3Integrator_-AutoDiffXd-.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.systems.analysis.RungeKutta3Integrator_-float">
<span id="pydrake.systems.analysis.RungeKutta3Integrator_[float]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.systems.analysis.</span></span><span class="sig-name descname"><span class="pre">RungeKutta3Integrator_[float]</span></span><a class="headerlink" href="#pydrake.systems.analysis.RungeKutta3Integrator_-float" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_-float" title="pydrake.systems.analysis.IntegratorBase_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.analysis.IntegratorBase_[float]</span></code></a></p>
<p>A third-order Runge Kutta integrator with a third order error
estimate.</p>
<p>For a discussion of this Runge-Kutta method, see [Butcher, 1987]. The
embedded error estimate was derived using the method mentioned in
[Hairer, 1993].</p>
<p>The Butcher tableau for this integrator follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span>
<span class="mi">0</span>      <span class="o">|</span>
<span class="mi">1</span><span class="o">/</span><span class="mi">2</span>    <span class="o">|</span> <span class="mi">1</span><span class="o">/</span><span class="mi">2</span>
<span class="mi">1</span>      <span class="o">|</span> <span class="o">-</span><span class="mi">1</span>          <span class="mi">2</span>
<span class="o">---------------------------------------------------------------------------</span>
         <span class="mi">1</span><span class="o">/</span><span class="mi">6</span>         <span class="mi">2</span><span class="o">/</span><span class="mi">3</span>       <span class="mi">1</span><span class="o">/</span><span class="mi">6</span>
         <span class="mi">0</span>           <span class="mi">1</span>         <span class="mi">0</span>
</pre></div>
</div>
<p>where the second to last row is the 3rd-order propagated solution and
the last row is the 2nd-order midpoint used for the error estimate.</p>
<p>The following documentation is pulled from Simbody’s implementation of
this integrator: “This is a 3-stage, first-same-as-last (FSAL) 3rd
order method which gives us an embedded 2nd order method as well, so
we can extract a 3rd-order error estimate for the 2nd-order result,
which error estimate can then be used for step size control, since it
will behave as h^3. We then propagate the 3rd order result (whose
error is unknown), which Hairer calls ‘local extrapolation’. We call
the initial state (t0,y0) and want (t0+h,y1). We are given the initial
derivative f0=f(t0,y0), which most likely is left over from an
evaluation at the end of the last step.”</p>
<ul class="simple">
<li><p>[Butcher, 1987] J. C. Butcher. The Numerical Analysis of Ordinary
Differential Equations. John Wiley &amp; Sons, 1987. p. 325.</p></li>
<li><p>[Hairer, 1993] E. Hairer, S. Noersett, and G. Wanner. Solving ODEs I. 2nd
rev. ed. Springer, 1993. p. 166.</p></li>
</ul>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.RungeKutta3Integrator_-float-.__init__">
<span id="pydrake.systems.analysis.RungeKutta3Integrator_[float].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.RungeKutta3Integrator_" title="pydrake.systems.analysis.RungeKutta3Integrator_"><span class="pre">pydrake.systems.analysis.RungeKutta3Integrator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">system</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.System_" title="pydrake.systems.framework.System_"><span class="pre">pydrake.systems.framework.System_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.RungeKutta3Integrator_-float-.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator">
<span class="sig-prename descclassname"><span class="pre">pydrake.systems.analysis.</span></span><span class="sig-name descname"><span class="pre">Simulator</span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator" title="Permalink to this definition"></a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.systems.analysis.Simulator_-float" title="pydrake.systems.analysis.Simulator_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.analysis.Simulator_[float]</span></code></a></p>
</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.systems.analysis.</span></span><span class="sig-name descname"><span class="pre">Simulator_</span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.systems.analysis.Simulator_-float" title="pydrake.systems.analysis.Simulator_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Simulator_[float]</span></code></a>, <a class="reference internal" href="#pydrake.systems.analysis.Simulator_-AutoDiffXd" title="pydrake.systems.analysis.Simulator_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Simulator_[AutoDiffXd]</span></code></a></p>
<dl class="py class">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_.Simulator_-float">
<span id="pydrake.systems.analysis.Simulator_.Simulator_[float]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Simulator_[float]</span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_.Simulator_-float" title="Permalink to this definition"></a></dt>
<dd><p>A class for advancing the state of hybrid dynamic systems, represented
by <code class="docutils literal notranslate"><span class="pre">System&lt;T&gt;</span></code> objects, forward in time. Starting with an initial
Context for a given System, Simulator advances time and produces a
series of Context values that forms a trajectory satisfying the
system’s dynamic equations to a specified accuracy. Only the Context
is modified by a Simulator; the System is const.</p>
<p>A Drake System is a continuous/discrete/hybrid dynamic system where
the continuous part is a DAE, that is, it is expected to consist of a
set of differential equations and bilateral algebraic constraints. The
set of active constraints may change as a result of particular events,
such as contact.</p>
<p>Given a current Context, we expect a System to provide us with -
derivatives for the continuous differential equations that already
satisfy the differentiated form of the constraints (typically,
acceleration constraints), - a projection method for least-squares
correction of violated higher-level constraints (position and velocity
level), - a time-of-next-update method that can be used to adjust the
integrator step size in preparation for a discrete update, - methods
that can update discrete variables when their update time is reached,
- witness (guard) functions for event isolation, - event handlers
(reset functions) for making appropriate changes to state and mode
variables when an event has been isolated.</p>
<p>The continuous parts of the trajectory are advanced using a numerical
integrator. Different integrators have different properties; you can
choose the one that is most appropriate for your application or use
the default which is adequate for most systems.</p>
<p>&lt;h3&gt;How the simulation is stepped: simulation mechanics for authors of
discrete and hybrid systems&lt;/h3&gt;</p>
<p>This section is targeted toward users who have created a LeafSystem
implementing a discrete or hybrid system. For authors of such systems,
it can be useful to understand the simulation details in order to
attain the desired state behavior over time. This behavior is
dependent on the ordering in which discrete events and continuous
updates are processed. (By “discrete events” we mean to include any of
Drake’s event handlers.) The basic issues and terminology are
introduced in the discrete_systems module; please look there first
before proceeding.</p>
<p>As pictured in discrete_systems, when a continuous-time system has
discrete events, the state x can have two significant values at the
event time t. These are - x⁻(t), the value of x <em>before</em> the discrete
update occurs (○ markers), and - x⁺(t), the value of x <em>after</em> the
discrete update occurs (● markers).</p>
<p>Thus the value of the Context, which contains both time and state,
advances from {t, x⁻(t)} to {t, x⁺(t)} as a result of the update.
While those Context values are user-visible, the details of stepping
here require an intermediate value which we’ll denote {t, x*(t)}.</p>
<p>Recall that Drake’s state x is partitioned into continuous, discrete,
and abstract partitions xc, xd, and xa, so <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">xc,</span> <span class="pre">xd,</span> <span class="pre">xa</span> <span class="pre">}</span></code>.
Within a single step, these are updated in three stages: -</p>
<p>Unrestricted update (can change x) -</p>
<p>Discrete update (can change only xd) -</p>
<p>Continuous update (changes t and xc)</p>
<p>Where needed, we extend the above notation to xc⁻, xa⁺, etc. to
indicate the value of an individual partition at a particular stage of
the stepping algorithm.</p>
<p>The following pseudocode uses the above notation to describe the
algorithm “Step()” that the Simulator uses to incrementally advance
the system trajectory (time t and state x). The Simulator’s
AdvanceTo() method will be defined in terms of Step below. In general,
the length of a step is not known a priori and is determined by the
Step() algorithm. Each step consists of zero or more unrestricted
updates, followed by zero or more discrete updates, followed by
(possibly zero-length) continuous time and state advancement, followed
by zero or more publishes, and then a call to the monitor() function
if one has been defined. Updates, publishes, and the monitor can
report errors or detect a termination condition; that is not shown in
the pseudocode below.</p>
<p>The pseudocode will clarify the effects on time and state of each of
the update stages above. This algorithm is given a starting Context
value <code class="docutils literal notranslate"><span class="pre">{tₛ,</span> <span class="pre">x⁻(tₛ)}</span></code> and returns an end Context value <code class="docutils literal notranslate"><span class="pre">{tₑ,</span>
<span class="pre">x⁻(tₑ)}</span></code>, where tₑ is <em>no later</em> than a given tₘₐₓ.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// Advance the trajectory (time and state) from start value {tₛ, x⁻(tₛ)} to an
// end value {tₑ, x⁻(tₑ)}, where tₛ ≤ tₑ ≤ tₘₐₓ.
procedure Step(tₛ, x⁻(tₛ), tₘₐₓ)

// Update any variables (no restrictions).
x*(tₛ) ← DoAnyUnrestrictedUpdates(tₛ, x⁻(tₛ))

// ----------------------------------
// Time and state are at {tₛ, x*(tₛ)}
// ----------------------------------

// Update discrete variables.
xd⁺(tₛ) ← DoAnyDiscreteUpdates(tₛ, x*(tₛ))

xc⁺(tₛ) ← xc*(tₛ)  // These values carry over from x*(tₛ).
xa⁺(tₛ) ← xa*(tₛ)

// ----------------------------------
// Time and state are at {tₛ, x⁺(tₛ)}
// ----------------------------------

// See how far it is safe to integrate without missing any events.
tₑᵥₑₙₜ ← CalcNextEventTime(tₛ, x⁺(tₛ))

// Integrate continuous variables forward in time. Integration may terminate
// before reaching tₛₜₒₚ due to witnessed events.
tₛₜₒₚ ← min(tₑᵥₑₙₜ, tₘₐₓ)
tₑ, xc⁻(tₑ) ← Integrate(tₛ, x⁺(tₛ), tₛₜₒₚ)

xd⁻(tₑ) ← xd⁺(tₛ)  // Discrete values are held from x⁺(tₛ).
xa⁻(tₑ) ← xa⁺(tₛ)

// ----------------------------------
// Time and state are at {tₑ, x⁻(tₑ)}
// ----------------------------------

DoAnyPublishes(tₑ, x⁻(tₑ))
CallMonitor(tₑ, x⁻(tₑ))

return {tₑ, x⁻(tₑ)}
</pre></div>
</div>
<p>We can use the notation and pseudocode to flesh out the AdvanceTo(),
AdvancePendingEvents(), and Initialize() functions. Termination and
error conditions detected by event handlers or the monitor are
reported as status returns from these methods.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// Advance the simulation until time tₘₐₓ.
procedure AdvanceTo(tₘₐₓ) → status
t ← current_time
while t &lt; tₘₐₓ
{tₑ, x⁻(tₑ)} ← Step(t, x⁻(t), tₘₐₓ)
{t, x⁻(t)} ← {tₑ, x⁻(tₑ)}
endwhile

// AdvancePendingEvents() is an advanced method, not commonly used.
// Perform just the start-of-step update to advance from x⁻(t) to x⁺(t).
procedure AdvancePendingEvents() → status
t ≜ current_time, x⁻(t) ≜ current_state
x⁺(t) ← DoAnyPendingUpdates(t, x⁻(t)) as in Step()
x(t) ← x⁺(t)  // No continuous update needed.
DoAnyPublishes(t, x(t))
CallMonitor(t, x(t))

// Update time and state to {t₀, x⁻(t₀)}, which is the starting value of the
// trajectory, and thus the value the Context should contain at the start of the
// first simulation step.
procedure Initialize(t₀, x₀) → status
// Initialization events can be optionally suppressed.
x⁺(t₀) ← DoAnyInitializationUpdates as in Step()
x⁻(t₀) ← x⁺(t₀)  // No continuous update needed.

// ----------------------------------
// Time and state are at {t₀, x⁻(t₀)}
// ----------------------------------

DoAnyPublishes(t₀, x⁻(t₀))
CallMonitor(t₀, x⁻(t₀))
</pre></div>
</div>
<p>Initialize() can be viewed as a “0ᵗʰ step” that occurs before the
first Step() call as described above. Like Step(), Initialize() first
performs pending updates (in this case only initialization events can
be “pending”, and even those may be optionally suppressed). Time
doesn’t advance so there is no continuous update phase and witnesses
cannot trigger. Finally, again like Step(), the initial trajectory
point <code class="docutils literal notranslate"><span class="pre">{t₀,</span> <span class="pre">x⁻(t₀)}</span></code> is provided to the handlers for any triggered
publish events. That includes initialization publish events (if not
suppressed), per-step publish events, and periodic or timed publish
events that trigger at t₀, followed by a call to the monitor()
function if one has been defined (a monitor is semantically identical
to a per-step publish).</p>
<p>Optionally, initialization events can be suppressed. This can be
useful when reusing the simulator over the same system and time span.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_.Simulator_-float-.__init__">
<span id="pydrake.systems.analysis.Simulator_.Simulator_[float].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">system</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.System_" title="pydrake.systems.framework.System_"><span class="pre">pydrake.systems.framework.System_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_.Simulator_-float-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Create a Simulator that can advance a given System through time to
produce a trajectory consisting of a sequence of Context values. The
System must not have unresolved input ports if the values of those
ports are necessary for computations performed during simulation (see
class documentation).</p>
<p>The Simulator holds an internal, non-owned reference to the System
object so you must ensure that <code class="docutils literal notranslate"><span class="pre">system</span></code> has a longer lifetime than
the Simulator. It also owns a compatible Context internally that takes
on each of the trajectory values. You may optionally provide a Context
that will be used as the initial condition for the simulation;
otherwise the Simulator will obtain a default Context from <code class="docutils literal notranslate"><span class="pre">system</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_.Simulator_-float-.AdvancePendingEvents">
<span id="pydrake.systems.analysis.Simulator_.Simulator_[float].AdvancePendingEvents"></span><span class="sig-name descname"><span class="pre">AdvancePendingEvents</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.systems.analysis.SimulatorStatus" title="pydrake.systems.analysis.SimulatorStatus"><span class="pre">pydrake.systems.analysis.SimulatorStatus</span></a></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_.Simulator_-float-.AdvancePendingEvents" title="Permalink to this definition"></a></dt>
<dd><p>(Advanced) Handles discrete and abstract state update events that are
pending from the previous AdvanceTo() call, without advancing time.
See the Simulator class description for details about how Simulator
advances time and handles events. In the terminology used there, this
method advances the internal Context from <code class="docutils literal notranslate"><span class="pre">{t,</span> <span class="pre">x⁻(t)}</span></code> to <code class="docutils literal notranslate"><span class="pre">{t,</span>
<span class="pre">x⁺(t)}</span></code>.</p>
<p>Normally, these update events would be handled at the start of the
next AdvanceTo() call, so this method is rarely needed. It can be
useful at the end of a simulation or to get intermediate results when
you are specifically interested in the <code class="docutils literal notranslate"><span class="pre">x⁺(t)</span></code> result.</p>
<p>This method is equivalent to <code class="docutils literal notranslate"><span class="pre">AdvanceTo(current_time)</span></code>, where
<code class="docutils literal notranslate"><span class="pre">current_time=simulator.get_context().get_time())</span></code>. If there are no
pending events, nothing happens except possibly a final per-step
publish call (if enabled) followed by a call to the monitor() function
(if one has been provided).</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">status</span></code>:</dt><dd><p>A SimulatorStatus object indicating success, termination, or an
error condition as reported by event handlers or the monitor
function.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AdvanceTo(), Initialize(), SimulatorStatus</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_.Simulator_-float-.AdvanceTo">
<span id="pydrake.systems.analysis.Simulator_.Simulator_[float].AdvanceTo"></span><span class="sig-name descname"><span class="pre">AdvanceTo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundary_time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.systems.analysis.SimulatorStatus" title="pydrake.systems.analysis.SimulatorStatus"><span class="pre">pydrake.systems.analysis.SimulatorStatus</span></a></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_.Simulator_-float-.AdvanceTo" title="Permalink to this definition"></a></dt>
<dd><p>Advances the System’s trajectory until <code class="docutils literal notranslate"><span class="pre">boundary_time</span></code> is reached in
the context or some other termination condition occurs. A variety of
<code class="docutils literal notranslate"><span class="pre">RuntimeError</span></code> conditions are possible here, as well as error
conditions that may be thrown by the System when it is asked to
perform computations. Be sure to enclose your simulation in a
<code class="docutils literal notranslate"><span class="pre">try-catch</span></code> block and display the <code class="docutils literal notranslate"><span class="pre">what()</span></code> message.</p>
<p>We recommend that you call Initialize() prior to making the first call
to AdvanceTo(). However, if you don’t it will be called for you the
first time that you attempt a step, possibly resulting in unexpected
error conditions. See documentation for <code class="docutils literal notranslate"><span class="pre">Initialize()</span></code> for the error
conditions it might produce.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>You should consider calling Initialize() if you alter the the
Context or Simulator options between successive AdvanceTo() calls.
See Initialize() for more information.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">boundary_time</span></code>:</dt><dd><p>The maximum time to which the trajectory will be advanced by this
call to AdvanceTo(). The method may return earlier if an event or
the monitor function requests termination or reports an error
condition.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">status</span></code>:</dt><dd><p>A SimulatorStatus object indicating success, termination, or an
error condition as reported by event handlers or the monitor
function. The time in the context will be set either to the
boundary_time or the time a termination or error was first
detected.</p>
</dd>
<dt>Precondition:</dt><dd><p>The internal Context satisfies all System constraints or will
after pending Context updates are performed.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Initialize(), AdvancePendingEvents(), SimulatorStatus</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_.Simulator_-float-.clear_monitor">
<span id="pydrake.systems.analysis.Simulator_.Simulator_[float].clear_monitor"></span><span class="sig-name descname"><span class="pre">clear_monitor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_.Simulator_-float-.clear_monitor" title="Permalink to this definition"></a></dt>
<dd><p>Removes the monitoring function if there is one.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>set_monitor()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_.Simulator_-float-.get_actual_realtime_rate">
<span id="pydrake.systems.analysis.Simulator_.Simulator_[float].get_actual_realtime_rate"></span><span class="sig-name descname"><span class="pre">get_actual_realtime_rate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_.Simulator_-float-.get_actual_realtime_rate" title="Permalink to this definition"></a></dt>
<dd><p>Return the rate that simulated time has progressed relative to real
time. A return of 1 means the simulation just matched real time, 2
means the simulation was twice as fast as real time, 0.5 means it was
running in 2X slow motion, etc.</p>
<p>The value returned here is calculated as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">simulated_time_now</span> <span class="o">-</span> <span class="n">initial_simulated_time</span>
  <span class="n">rate</span> <span class="o">=</span> <span class="o">-------------------------------------------</span>
               <span class="n">realtime_now</span> <span class="o">-</span> <span class="n">initial_realtime</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">initial</span></code> times are recorded when Initialize() or
ResetStatistics() is called. The returned rate is undefined if
Initialize() has not yet been called.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The rate achieved since the last Initialize() or ResetStatistics()
call.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>set_target_realtime_rate()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_.Simulator_-float-.get_context">
<span id="pydrake.systems.analysis.Simulator_.Simulator_[float].get_context"></span><span class="sig-name descname"><span class="pre">get_context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_.Simulator_-float-.get_context" title="Permalink to this definition"></a></dt>
<dd><p>Returns a const reference to the internally-maintained Context holding
the most recent step in the trajectory. This is suitable for
publishing or extracting information about this trajectory step. Do
not call this method if there is no Context.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_.Simulator_-float-.get_integrator">
<span id="pydrake.systems.analysis.Simulator_.Simulator_[float].get_integrator"></span><span class="sig-name descname"><span class="pre">get_integrator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_.Simulator_-float-.get_integrator" title="Permalink to this definition"></a></dt>
<dd><p>Gets a reference to the integrator used to advance the continuous
aspects of the system.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_.Simulator_-float-.get_monitor">
<span id="pydrake.systems.analysis.Simulator_.Simulator_[float].get_monitor"></span><span class="sig-name descname"><span class="pre">get_monitor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.EventStatus" title="pydrake.systems.framework.EventStatus"><span class="pre">pydrake.systems.framework.EventStatus</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_.Simulator_-float-.get_monitor" title="Permalink to this definition"></a></dt>
<dd><p>Obtains a reference to the monitoring function, which may be empty.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>set_monitor()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_.Simulator_-float-.get_mutable_context">
<span id="pydrake.systems.analysis.Simulator_.Simulator_[float].get_mutable_context"></span><span class="sig-name descname"><span class="pre">get_mutable_context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_.Simulator_-float-.get_mutable_context" title="Permalink to this definition"></a></dt>
<dd><p>Returns a mutable reference to the internally-maintained Context
holding the most recent step in the trajectory. This is suitable for
use in updates, sampling operations, event handlers, and constraint
projection. You can also modify this prior to calling Initialize() to
set initial conditions. Do not call this method if there is no
Context.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_.Simulator_-float-.get_mutable_integrator">
<span id="pydrake.systems.analysis.Simulator_.Simulator_[float].get_mutable_integrator"></span><span class="sig-name descname"><span class="pre">get_mutable_integrator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_.Simulator_-float-.get_mutable_integrator" title="Permalink to this definition"></a></dt>
<dd><p>Gets a reference to the mutable integrator used to advance the
continuous state of the system.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_.Simulator_-float-.get_system">
<span id="pydrake.systems.analysis.Simulator_.Simulator_[float].get_system"></span><span class="sig-name descname"><span class="pre">get_system</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.System_" title="pydrake.systems.framework.System_"><span class="pre">pydrake.systems.framework.System_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_.Simulator_-float-.get_system" title="Permalink to this definition"></a></dt>
<dd><p>Gets a constant reference to the system.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>a mutable reference is not available.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_.Simulator_-float-.get_target_realtime_rate">
<span id="pydrake.systems.analysis.Simulator_.Simulator_[float].get_target_realtime_rate"></span><span class="sig-name descname"><span class="pre">get_target_realtime_rate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_.Simulator_-float-.get_target_realtime_rate" title="Permalink to this definition"></a></dt>
<dd><p>Return the real time rate target currently in effect. The default is
zero, meaning the Simulator runs as fast as possible. You can change
the target with set_target_realtime_rate().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_.Simulator_-float-.has_context">
<span id="pydrake.systems.analysis.Simulator_.Simulator_[float].has_context"></span><span class="sig-name descname"><span class="pre">has_context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_.Simulator_-float-.has_context" title="Permalink to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if this Simulator has an internally-maintained
Context. This is always true unless <code class="docutils literal notranslate"><span class="pre">reset_context()</span></code> has been
called.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_.Simulator_-float-.Initialize">
<span id="pydrake.systems.analysis.Simulator_.Simulator_[float].Initialize"></span><span class="sig-name descname"><span class="pre">Initialize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.InitializeParams" title="pydrake.systems.analysis.InitializeParams"><span class="pre">pydrake.systems.analysis.InitializeParams</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">InitializeParams(suppress_initialization_events=False)</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.systems.analysis.SimulatorStatus" title="pydrake.systems.analysis.SimulatorStatus"><span class="pre">pydrake.systems.analysis.SimulatorStatus</span></a></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_.Simulator_-float-.Initialize" title="Permalink to this definition"></a></dt>
<dd><p>See the class documentation for more information. We recommend calling
Initialize() explicitly prior to beginning a simulation so that error
conditions will be discovered early. However, Initialize() will be
called automatically by the first AdvanceTo() call if it hasn’t
already been called.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you make a change to the Context or to Simulator options
between AdvanceTo() calls you should consider whether to call
Initialize() before resuming; AdvanceTo() will not do that
automatically for you. Whether to do so depends on whether you
want the above initialization operations performed.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In particular, if you changed the time you must call Initialize().
The time-triggered events must be recalculated in case one is due
at the new starting time. The AdvanceTo() call will throw an
exception if the Initialize() call is missing.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The only way to suppress initialization events is by calling
Initialize() explicitly. The most common scenario for this is when
reusing a Simulator object. In this case, the caller is
responsible for ensuring the correctness of the initial state.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Initialize() does not automatically attempt to satisfy System
constraints – it is up to you to make sure that constraints are
satisfied by the initial conditions.</p>
</div>
<p>This method will throw <code class="docutils literal notranslate"><span class="pre">RuntimeError</span></code> if the combination of options
doesn’t make sense. Other failures are possible from the System and
integrator in use.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">params</span></code>:</dt><dd><p>(optional) a parameter structure (</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>InitializeParams).</p>
</div>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">status</span></code>:</dt><dd><p>A SimulatorStatus object indicating success, termination, or an
error condition as reported by event handlers or the monitor
function.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AdvanceTo(), AdvancePendingEvents(), SimulatorStatus</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_.Simulator_-float-.reset_context">
<span id="pydrake.systems.analysis.Simulator_.Simulator_[float].reset_context"></span><span class="sig-name descname"><span class="pre">reset_context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_.Simulator_-float-.reset_context" title="Permalink to this definition"></a></dt>
<dd><p>Replace the internally-maintained Context with a different one. The
current Context is deleted. This is useful for supplying a new set of
initial conditions. You should invoke Initialize() after replacing the
Context.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The new context, which may be null. If the context is null, a new
context must be set before attempting to step the system forward.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_.Simulator_-float-.ResetStatistics">
<span id="pydrake.systems.analysis.Simulator_.Simulator_[float].ResetStatistics"></span><span class="sig-name descname"><span class="pre">ResetStatistics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_.Simulator_-float-.ResetStatistics" title="Permalink to this definition"></a></dt>
<dd><p>Forget accumulated statistics. Statistics are reset to the values they
have post construction or immediately after <code class="docutils literal notranslate"><span class="pre">Initialize()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_.Simulator_-float-.set_monitor">
<span id="pydrake.systems.analysis.Simulator_.Simulator_[float].set_monitor"></span><span class="sig-name descname"><span class="pre">set_monitor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">monitor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.EventStatus" title="pydrake.systems.framework.EventStatus"><span class="pre">pydrake.systems.framework.EventStatus</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_.Simulator_-float-.set_monitor" title="Permalink to this definition"></a></dt>
<dd><p>Provides a monitoring function that will be invoked at the end of
every step. (See the Simulator class documentation for a precise
definition of “step”.) A monitor() function can be used to capture the
trajectory, to terminate the simulation, or to detect error
conditions. The monitor() function is invoked by the Simulator with a
Context whose value is a point along the simulated trajectory. The
monitor can be any functor and should capture any System references it
needs to operate correctly.</p>
<p>A monitor() function behaves the same as would a per-step Publish
event handler included in the top-level System or Diagram being
simulated. As in the case of Publish(), the monitor is called at the
end of every step taken internally by AdvanceTo(), and also at the end
of Initialize() and AdvancePendingEvents(). (See the Simulator class
documentation for more detail about what happens when in these
methods.) The monitor receives the top-level (root) Context, from
which any sub-Context can be obtained using
<code class="docutils literal notranslate"><span class="pre">subsystem.GetMyContextFromRoot()</span></code>, provided the necessary subsystem
reference has been captured for use in the monitor.</p>
<p>** Examples Output time and continuous states whenever the trajectory
is advanced:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">simulator</span><span class="o">.</span><span class="n">set_monitor</span><span class="p">([](</span><span class="n">const</span> <span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">root_context</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">root_context</span><span class="o">.</span><span class="n">get_time</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot; &quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">root_context</span><span class="o">.</span><span class="n">get_continuous_state_vector</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">EventStatus</span><span class="p">::</span><span class="n">Succeeded</span><span class="p">();</span>
<span class="p">});</span>
</pre></div>
</div>
<p>Terminate early but successfully on a condition in a subsystem of the
System diagram being simulated:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">simulator</span><span class="o">.</span><span class="n">set_monitor</span><span class="p">([</span><span class="o">&amp;</span><span class="n">my_subsystem</span><span class="p">](</span><span class="n">const</span> <span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">root_context</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">const</span> <span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">subcontext</span> <span class="o">=</span>
      <span class="n">my_subsystem</span><span class="o">.</span><span class="n">GetMyContextFromRoot</span><span class="p">(</span><span class="n">root_context</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">my_subsystem</span><span class="o">.</span><span class="n">GoalReached</span><span class="p">(</span><span class="n">subcontext</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">EventStatus</span><span class="p">::</span><span class="n">ReachedTermination</span><span class="p">(</span><span class="n">my_subsystem</span><span class="p">,</span>
        <span class="s2">&quot;Simulation achieved the desired goal.&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">EventStatus</span><span class="p">::</span><span class="n">Succeeded</span><span class="p">();</span>
<span class="p">});</span>
</pre></div>
</div>
<p>In the above case, the Simulator’s AdvanceTo() method will return
early when the subsystem reports that it has reached its goal. The
returned status will indicate the termination reason, and a
human-readable termination message containing the message provided by
the monitor can be obtained with status.FormatMessage().</p>
<p>Failure due to plant center of mass falling below a threshold:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">simulator</span><span class="o">.</span><span class="n">set_monitor</span><span class="p">([</span><span class="o">&amp;</span><span class="n">plant</span><span class="p">](</span><span class="n">const</span> <span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">root_context</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">const</span> <span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">plant_context</span> <span class="o">=</span>
      <span class="n">plant</span><span class="o">.</span><span class="n">GetMyContextFromRoot</span><span class="p">(</span><span class="n">root_context</span><span class="p">);</span>
  <span class="n">const</span> <span class="n">Vector3</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">com</span> <span class="o">=</span>
      <span class="n">plant</span><span class="o">.</span><span class="n">CalcCenterOfMassPositionInWorld</span><span class="p">(</span><span class="n">plant_context</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.1</span><span class="p">)</span> <span class="p">{</span>  <span class="o">//</span> <span class="n">Check</span> <span class="n">z</span> <span class="n">height</span> <span class="n">of</span> <span class="n">com</span><span class="o">.</span>
    <span class="k">return</span> <span class="n">EventStatus</span><span class="p">::</span><span class="n">Failed</span><span class="p">(</span><span class="n">plant</span><span class="p">,</span> <span class="s2">&quot;System fell over.&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">EventStatus</span><span class="p">::</span><span class="n">Succeeded</span><span class="p">();</span>
<span class="p">});</span>
</pre></div>
</div>
<p>In the above case the Simulator’s AdvanceTo() method will throw an
RuntimeError containing a human-readable message including the text
provided in the monitor.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>monitor() is called every time the trajectory is advanced by a
step, which can mean it is called many times during a single
AdvanceTo() call.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The presence of a monitor has no effect on the step sizes taken,
so a termination or error condition will be discovered only when
first observed after a step is complete; it will not be further
localized. Use witness-triggered events instead if you need
precise isolation.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_.Simulator_-float-.set_publish_at_initialization">
<span id="pydrake.systems.analysis.Simulator_.Simulator_[float].set_publish_at_initialization"></span><span class="sig-name descname"><span class="pre">set_publish_at_initialization</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">publish</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_.Simulator_-float-.set_publish_at_initialization" title="Permalink to this definition"></a></dt>
<dd><p>Sets whether the simulation should trigger a forced-Publish at the end
of Initialize(). See set_publish_every_time_step() documentation for
more information.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_.Simulator_-float-.set_publish_every_time_step">
<span id="pydrake.systems.analysis.Simulator_.Simulator_[float].set_publish_every_time_step"></span><span class="sig-name descname"><span class="pre">set_publish_every_time_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">publish</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_.Simulator_-float-.set_publish_every_time_step" title="Permalink to this definition"></a></dt>
<dd><p>Sets whether the simulation should trigger a forced-Publish event on
the System under simulation at the end of every trajectory-advancing
step. Specifically, that means the System::Publish() event dispatcher
will be invoked on each subsystem of the System and passed the current
Context and a forced-publish Event. If a subsystem has declared a
forced-publish event handler, that will be called. Otherwise, nothing
will happen unless the DoPublish() dispatcher has been overridden.</p>
<p>Enabling this option does not cause a forced-publish to be triggered
at initialization; if you want that you should also call
<code class="docutils literal notranslate"><span class="pre">set_publish_at_initialization(true)</span></code>. If you want a forced-publish
at the end of every step, you will usually also want one at the end of
initialization, requiring both options to be enabled.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>LeafSystem::DeclareForcedPublishEvent()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_.Simulator_-float-.set_target_realtime_rate">
<span id="pydrake.systems.analysis.Simulator_.Simulator_[float].set_target_realtime_rate"></span><span class="sig-name descname"><span class="pre">set_target_realtime_rate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">realtime_rate</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_.Simulator_-float-.set_target_realtime_rate" title="Permalink to this definition"></a></dt>
<dd><p>Slow the simulation down to <em>approximately</em> synchronize with real time
when it would otherwise run too fast. Normally the Simulator takes
steps as quickly as it can. You can request that it slow down to
synchronize with real time by providing a realtime rate greater than
zero here.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>No guarantees can be made about how accurately the simulation can
be made to track real time, even if computation is fast enough.
That’s because the system utilities used to implement this do not
themselves provide such guarantees. So this is likely to work
nicely for visualization purposes where human perception is the
only concern. For any other uses you should consider whether
approximate real time is adequate for your purposes.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the full-speed simulation is already slower than real time you
can’t speed it up with this call! Instead consider requesting less
integration accuracy, using a faster integration method or fixed
time step, or using a simpler model.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">realtime_rate</span></code>:</dt><dd><p>Desired rate relative to real time. Set to 1 to track real time, 2
to run twice as fast as real time, 0.5 for half speed, etc. Zero
or negative restores the rate to its default of 0, meaning the
simulation will proceed as fast as possible.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_-AutoDiffXd">
<span id="pydrake.systems.analysis.Simulator_[AutoDiffXd]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.systems.analysis.</span></span><span class="sig-name descname"><span class="pre">Simulator_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><p>A class for advancing the state of hybrid dynamic systems, represented
by <code class="docutils literal notranslate"><span class="pre">System&lt;T&gt;</span></code> objects, forward in time. Starting with an initial
Context for a given System, Simulator advances time and produces a
series of Context values that forms a trajectory satisfying the
system’s dynamic equations to a specified accuracy. Only the Context
is modified by a Simulator; the System is const.</p>
<p>A Drake System is a continuous/discrete/hybrid dynamic system where
the continuous part is a DAE, that is, it is expected to consist of a
set of differential equations and bilateral algebraic constraints. The
set of active constraints may change as a result of particular events,
such as contact.</p>
<p>Given a current Context, we expect a System to provide us with -
derivatives for the continuous differential equations that already
satisfy the differentiated form of the constraints (typically,
acceleration constraints), - a projection method for least-squares
correction of violated higher-level constraints (position and velocity
level), - a time-of-next-update method that can be used to adjust the
integrator step size in preparation for a discrete update, - methods
that can update discrete variables when their update time is reached,
- witness (guard) functions for event isolation, - event handlers
(reset functions) for making appropriate changes to state and mode
variables when an event has been isolated.</p>
<p>The continuous parts of the trajectory are advanced using a numerical
integrator. Different integrators have different properties; you can
choose the one that is most appropriate for your application or use
the default which is adequate for most systems.</p>
<p>&lt;h3&gt;How the simulation is stepped: simulation mechanics for authors of
discrete and hybrid systems&lt;/h3&gt;</p>
<p>This section is targeted toward users who have created a LeafSystem
implementing a discrete or hybrid system. For authors of such systems,
it can be useful to understand the simulation details in order to
attain the desired state behavior over time. This behavior is
dependent on the ordering in which discrete events and continuous
updates are processed. (By “discrete events” we mean to include any of
Drake’s event handlers.) The basic issues and terminology are
introduced in the discrete_systems module; please look there first
before proceeding.</p>
<p>As pictured in discrete_systems, when a continuous-time system has
discrete events, the state x can have two significant values at the
event time t. These are - x⁻(t), the value of x <em>before</em> the discrete
update occurs (○ markers), and - x⁺(t), the value of x <em>after</em> the
discrete update occurs (● markers).</p>
<p>Thus the value of the Context, which contains both time and state,
advances from {t, x⁻(t)} to {t, x⁺(t)} as a result of the update.
While those Context values are user-visible, the details of stepping
here require an intermediate value which we’ll denote {t, x*(t)}.</p>
<p>Recall that Drake’s state x is partitioned into continuous, discrete,
and abstract partitions xc, xd, and xa, so <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">xc,</span> <span class="pre">xd,</span> <span class="pre">xa</span> <span class="pre">}</span></code>.
Within a single step, these are updated in three stages: -</p>
<p>Unrestricted update (can change x) -</p>
<p>Discrete update (can change only xd) -</p>
<p>Continuous update (changes t and xc)</p>
<p>Where needed, we extend the above notation to xc⁻, xa⁺, etc. to
indicate the value of an individual partition at a particular stage of
the stepping algorithm.</p>
<p>The following pseudocode uses the above notation to describe the
algorithm “Step()” that the Simulator uses to incrementally advance
the system trajectory (time t and state x). The Simulator’s
AdvanceTo() method will be defined in terms of Step below. In general,
the length of a step is not known a priori and is determined by the
Step() algorithm. Each step consists of zero or more unrestricted
updates, followed by zero or more discrete updates, followed by
(possibly zero-length) continuous time and state advancement, followed
by zero or more publishes, and then a call to the monitor() function
if one has been defined. Updates, publishes, and the monitor can
report errors or detect a termination condition; that is not shown in
the pseudocode below.</p>
<p>The pseudocode will clarify the effects on time and state of each of
the update stages above. This algorithm is given a starting Context
value <code class="docutils literal notranslate"><span class="pre">{tₛ,</span> <span class="pre">x⁻(tₛ)}</span></code> and returns an end Context value <code class="docutils literal notranslate"><span class="pre">{tₑ,</span>
<span class="pre">x⁻(tₑ)}</span></code>, where tₑ is <em>no later</em> than a given tₘₐₓ.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// Advance the trajectory (time and state) from start value {tₛ, x⁻(tₛ)} to an
// end value {tₑ, x⁻(tₑ)}, where tₛ ≤ tₑ ≤ tₘₐₓ.
procedure Step(tₛ, x⁻(tₛ), tₘₐₓ)

// Update any variables (no restrictions).
x*(tₛ) ← DoAnyUnrestrictedUpdates(tₛ, x⁻(tₛ))

// ----------------------------------
// Time and state are at {tₛ, x*(tₛ)}
// ----------------------------------

// Update discrete variables.
xd⁺(tₛ) ← DoAnyDiscreteUpdates(tₛ, x*(tₛ))

xc⁺(tₛ) ← xc*(tₛ)  // These values carry over from x*(tₛ).
xa⁺(tₛ) ← xa*(tₛ)

// ----------------------------------
// Time and state are at {tₛ, x⁺(tₛ)}
// ----------------------------------

// See how far it is safe to integrate without missing any events.
tₑᵥₑₙₜ ← CalcNextEventTime(tₛ, x⁺(tₛ))

// Integrate continuous variables forward in time. Integration may terminate
// before reaching tₛₜₒₚ due to witnessed events.
tₛₜₒₚ ← min(tₑᵥₑₙₜ, tₘₐₓ)
tₑ, xc⁻(tₑ) ← Integrate(tₛ, x⁺(tₛ), tₛₜₒₚ)

xd⁻(tₑ) ← xd⁺(tₛ)  // Discrete values are held from x⁺(tₛ).
xa⁻(tₑ) ← xa⁺(tₛ)

// ----------------------------------
// Time and state are at {tₑ, x⁻(tₑ)}
// ----------------------------------

DoAnyPublishes(tₑ, x⁻(tₑ))
CallMonitor(tₑ, x⁻(tₑ))

return {tₑ, x⁻(tₑ)}
</pre></div>
</div>
<p>We can use the notation and pseudocode to flesh out the AdvanceTo(),
AdvancePendingEvents(), and Initialize() functions. Termination and
error conditions detected by event handlers or the monitor are
reported as status returns from these methods.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// Advance the simulation until time tₘₐₓ.
procedure AdvanceTo(tₘₐₓ) → status
t ← current_time
while t &lt; tₘₐₓ
{tₑ, x⁻(tₑ)} ← Step(t, x⁻(t), tₘₐₓ)
{t, x⁻(t)} ← {tₑ, x⁻(tₑ)}
endwhile

// AdvancePendingEvents() is an advanced method, not commonly used.
// Perform just the start-of-step update to advance from x⁻(t) to x⁺(t).
procedure AdvancePendingEvents() → status
t ≜ current_time, x⁻(t) ≜ current_state
x⁺(t) ← DoAnyPendingUpdates(t, x⁻(t)) as in Step()
x(t) ← x⁺(t)  // No continuous update needed.
DoAnyPublishes(t, x(t))
CallMonitor(t, x(t))

// Update time and state to {t₀, x⁻(t₀)}, which is the starting value of the
// trajectory, and thus the value the Context should contain at the start of the
// first simulation step.
procedure Initialize(t₀, x₀) → status
// Initialization events can be optionally suppressed.
x⁺(t₀) ← DoAnyInitializationUpdates as in Step()
x⁻(t₀) ← x⁺(t₀)  // No continuous update needed.

// ----------------------------------
// Time and state are at {t₀, x⁻(t₀)}
// ----------------------------------

DoAnyPublishes(t₀, x⁻(t₀))
CallMonitor(t₀, x⁻(t₀))
</pre></div>
</div>
<p>Initialize() can be viewed as a “0ᵗʰ step” that occurs before the
first Step() call as described above. Like Step(), Initialize() first
performs pending updates (in this case only initialization events can
be “pending”, and even those may be optionally suppressed). Time
doesn’t advance so there is no continuous update phase and witnesses
cannot trigger. Finally, again like Step(), the initial trajectory
point <code class="docutils literal notranslate"><span class="pre">{t₀,</span> <span class="pre">x⁻(t₀)}</span></code> is provided to the handlers for any triggered
publish events. That includes initialization publish events (if not
suppressed), per-step publish events, and periodic or timed publish
events that trigger at t₀, followed by a call to the monitor()
function if one has been defined (a monitor is semantically identical
to a per-step publish).</p>
<p>Optionally, initialization events can be suppressed. This can be
useful when reusing the simulator over the same system and time span.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_-AutoDiffXd-.__init__">
<span id="pydrake.systems.analysis.Simulator_[AutoDiffXd].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">system</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.System_" title="pydrake.systems.framework.System_"><span class="pre">pydrake.systems.framework.System_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_-AutoDiffXd-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Create a Simulator that can advance a given System through time to
produce a trajectory consisting of a sequence of Context values. The
System must not have unresolved input ports if the values of those
ports are necessary for computations performed during simulation (see
class documentation).</p>
<p>The Simulator holds an internal, non-owned reference to the System
object so you must ensure that <code class="docutils literal notranslate"><span class="pre">system</span></code> has a longer lifetime than
the Simulator. It also owns a compatible Context internally that takes
on each of the trajectory values. You may optionally provide a Context
that will be used as the initial condition for the simulation;
otherwise the Simulator will obtain a default Context from <code class="docutils literal notranslate"><span class="pre">system</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_-AutoDiffXd-.AdvancePendingEvents">
<span id="pydrake.systems.analysis.Simulator_[AutoDiffXd].AdvancePendingEvents"></span><span class="sig-name descname"><span class="pre">AdvancePendingEvents</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.systems.analysis.SimulatorStatus" title="pydrake.systems.analysis.SimulatorStatus"><span class="pre">pydrake.systems.analysis.SimulatorStatus</span></a></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_-AutoDiffXd-.AdvancePendingEvents" title="Permalink to this definition"></a></dt>
<dd><p>(Advanced) Handles discrete and abstract state update events that are
pending from the previous AdvanceTo() call, without advancing time.
See the Simulator class description for details about how Simulator
advances time and handles events. In the terminology used there, this
method advances the internal Context from <code class="docutils literal notranslate"><span class="pre">{t,</span> <span class="pre">x⁻(t)}</span></code> to <code class="docutils literal notranslate"><span class="pre">{t,</span>
<span class="pre">x⁺(t)}</span></code>.</p>
<p>Normally, these update events would be handled at the start of the
next AdvanceTo() call, so this method is rarely needed. It can be
useful at the end of a simulation or to get intermediate results when
you are specifically interested in the <code class="docutils literal notranslate"><span class="pre">x⁺(t)</span></code> result.</p>
<p>This method is equivalent to <code class="docutils literal notranslate"><span class="pre">AdvanceTo(current_time)</span></code>, where
<code class="docutils literal notranslate"><span class="pre">current_time=simulator.get_context().get_time())</span></code>. If there are no
pending events, nothing happens except possibly a final per-step
publish call (if enabled) followed by a call to the monitor() function
(if one has been provided).</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">status</span></code>:</dt><dd><p>A SimulatorStatus object indicating success, termination, or an
error condition as reported by event handlers or the monitor
function.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AdvanceTo(), Initialize(), SimulatorStatus</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_-AutoDiffXd-.AdvanceTo">
<span id="pydrake.systems.analysis.Simulator_[AutoDiffXd].AdvanceTo"></span><span class="sig-name descname"><span class="pre">AdvanceTo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundary_time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.systems.analysis.SimulatorStatus" title="pydrake.systems.analysis.SimulatorStatus"><span class="pre">pydrake.systems.analysis.SimulatorStatus</span></a></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_-AutoDiffXd-.AdvanceTo" title="Permalink to this definition"></a></dt>
<dd><p>Advances the System’s trajectory until <code class="docutils literal notranslate"><span class="pre">boundary_time</span></code> is reached in
the context or some other termination condition occurs. A variety of
<code class="docutils literal notranslate"><span class="pre">RuntimeError</span></code> conditions are possible here, as well as error
conditions that may be thrown by the System when it is asked to
perform computations. Be sure to enclose your simulation in a
<code class="docutils literal notranslate"><span class="pre">try-catch</span></code> block and display the <code class="docutils literal notranslate"><span class="pre">what()</span></code> message.</p>
<p>We recommend that you call Initialize() prior to making the first call
to AdvanceTo(). However, if you don’t it will be called for you the
first time that you attempt a step, possibly resulting in unexpected
error conditions. See documentation for <code class="docutils literal notranslate"><span class="pre">Initialize()</span></code> for the error
conditions it might produce.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>You should consider calling Initialize() if you alter the the
Context or Simulator options between successive AdvanceTo() calls.
See Initialize() for more information.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">boundary_time</span></code>:</dt><dd><p>The maximum time to which the trajectory will be advanced by this
call to AdvanceTo(). The method may return earlier if an event or
the monitor function requests termination or reports an error
condition.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">status</span></code>:</dt><dd><p>A SimulatorStatus object indicating success, termination, or an
error condition as reported by event handlers or the monitor
function. The time in the context will be set either to the
boundary_time or the time a termination or error was first
detected.</p>
</dd>
<dt>Precondition:</dt><dd><p>The internal Context satisfies all System constraints or will
after pending Context updates are performed.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Initialize(), AdvancePendingEvents(), SimulatorStatus</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_-AutoDiffXd-.clear_monitor">
<span id="pydrake.systems.analysis.Simulator_[AutoDiffXd].clear_monitor"></span><span class="sig-name descname"><span class="pre">clear_monitor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_-AutoDiffXd-.clear_monitor" title="Permalink to this definition"></a></dt>
<dd><p>Removes the monitoring function if there is one.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>set_monitor()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_-AutoDiffXd-.get_actual_realtime_rate">
<span id="pydrake.systems.analysis.Simulator_[AutoDiffXd].get_actual_realtime_rate"></span><span class="sig-name descname"><span class="pre">get_actual_realtime_rate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_-AutoDiffXd-.get_actual_realtime_rate" title="Permalink to this definition"></a></dt>
<dd><p>Return the rate that simulated time has progressed relative to real
time. A return of 1 means the simulation just matched real time, 2
means the simulation was twice as fast as real time, 0.5 means it was
running in 2X slow motion, etc.</p>
<p>The value returned here is calculated as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">simulated_time_now</span> <span class="o">-</span> <span class="n">initial_simulated_time</span>
  <span class="n">rate</span> <span class="o">=</span> <span class="o">-------------------------------------------</span>
               <span class="n">realtime_now</span> <span class="o">-</span> <span class="n">initial_realtime</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">initial</span></code> times are recorded when Initialize() or
ResetStatistics() is called. The returned rate is undefined if
Initialize() has not yet been called.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The rate achieved since the last Initialize() or ResetStatistics()
call.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>set_target_realtime_rate()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_-AutoDiffXd-.get_context">
<span id="pydrake.systems.analysis.Simulator_[AutoDiffXd].get_context"></span><span class="sig-name descname"><span class="pre">get_context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_-AutoDiffXd-.get_context" title="Permalink to this definition"></a></dt>
<dd><p>Returns a const reference to the internally-maintained Context holding
the most recent step in the trajectory. This is suitable for
publishing or extracting information about this trajectory step. Do
not call this method if there is no Context.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_-AutoDiffXd-.get_integrator">
<span id="pydrake.systems.analysis.Simulator_[AutoDiffXd].get_integrator"></span><span class="sig-name descname"><span class="pre">get_integrator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_-AutoDiffXd-.get_integrator" title="Permalink to this definition"></a></dt>
<dd><p>Gets a reference to the integrator used to advance the continuous
aspects of the system.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_-AutoDiffXd-.get_monitor">
<span id="pydrake.systems.analysis.Simulator_[AutoDiffXd].get_monitor"></span><span class="sig-name descname"><span class="pre">get_monitor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.EventStatus" title="pydrake.systems.framework.EventStatus"><span class="pre">pydrake.systems.framework.EventStatus</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_-AutoDiffXd-.get_monitor" title="Permalink to this definition"></a></dt>
<dd><p>Obtains a reference to the monitoring function, which may be empty.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>set_monitor()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_-AutoDiffXd-.get_mutable_context">
<span id="pydrake.systems.analysis.Simulator_[AutoDiffXd].get_mutable_context"></span><span class="sig-name descname"><span class="pre">get_mutable_context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_-AutoDiffXd-.get_mutable_context" title="Permalink to this definition"></a></dt>
<dd><p>Returns a mutable reference to the internally-maintained Context
holding the most recent step in the trajectory. This is suitable for
use in updates, sampling operations, event handlers, and constraint
projection. You can also modify this prior to calling Initialize() to
set initial conditions. Do not call this method if there is no
Context.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_-AutoDiffXd-.get_mutable_integrator">
<span id="pydrake.systems.analysis.Simulator_[AutoDiffXd].get_mutable_integrator"></span><span class="sig-name descname"><span class="pre">get_mutable_integrator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_-AutoDiffXd-.get_mutable_integrator" title="Permalink to this definition"></a></dt>
<dd><p>Gets a reference to the mutable integrator used to advance the
continuous state of the system.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_-AutoDiffXd-.get_system">
<span id="pydrake.systems.analysis.Simulator_[AutoDiffXd].get_system"></span><span class="sig-name descname"><span class="pre">get_system</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.System_" title="pydrake.systems.framework.System_"><span class="pre">pydrake.systems.framework.System_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_-AutoDiffXd-.get_system" title="Permalink to this definition"></a></dt>
<dd><p>Gets a constant reference to the system.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>a mutable reference is not available.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_-AutoDiffXd-.get_target_realtime_rate">
<span id="pydrake.systems.analysis.Simulator_[AutoDiffXd].get_target_realtime_rate"></span><span class="sig-name descname"><span class="pre">get_target_realtime_rate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_-AutoDiffXd-.get_target_realtime_rate" title="Permalink to this definition"></a></dt>
<dd><p>Return the real time rate target currently in effect. The default is
zero, meaning the Simulator runs as fast as possible. You can change
the target with set_target_realtime_rate().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_-AutoDiffXd-.has_context">
<span id="pydrake.systems.analysis.Simulator_[AutoDiffXd].has_context"></span><span class="sig-name descname"><span class="pre">has_context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_-AutoDiffXd-.has_context" title="Permalink to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if this Simulator has an internally-maintained
Context. This is always true unless <code class="docutils literal notranslate"><span class="pre">reset_context()</span></code> has been
called.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_-AutoDiffXd-.Initialize">
<span id="pydrake.systems.analysis.Simulator_[AutoDiffXd].Initialize"></span><span class="sig-name descname"><span class="pre">Initialize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.InitializeParams" title="pydrake.systems.analysis.InitializeParams"><span class="pre">pydrake.systems.analysis.InitializeParams</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">InitializeParams(suppress_initialization_events=False)</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.systems.analysis.SimulatorStatus" title="pydrake.systems.analysis.SimulatorStatus"><span class="pre">pydrake.systems.analysis.SimulatorStatus</span></a></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_-AutoDiffXd-.Initialize" title="Permalink to this definition"></a></dt>
<dd><p>See the class documentation for more information. We recommend calling
Initialize() explicitly prior to beginning a simulation so that error
conditions will be discovered early. However, Initialize() will be
called automatically by the first AdvanceTo() call if it hasn’t
already been called.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you make a change to the Context or to Simulator options
between AdvanceTo() calls you should consider whether to call
Initialize() before resuming; AdvanceTo() will not do that
automatically for you. Whether to do so depends on whether you
want the above initialization operations performed.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In particular, if you changed the time you must call Initialize().
The time-triggered events must be recalculated in case one is due
at the new starting time. The AdvanceTo() call will throw an
exception if the Initialize() call is missing.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The only way to suppress initialization events is by calling
Initialize() explicitly. The most common scenario for this is when
reusing a Simulator object. In this case, the caller is
responsible for ensuring the correctness of the initial state.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Initialize() does not automatically attempt to satisfy System
constraints – it is up to you to make sure that constraints are
satisfied by the initial conditions.</p>
</div>
<p>This method will throw <code class="docutils literal notranslate"><span class="pre">RuntimeError</span></code> if the combination of options
doesn’t make sense. Other failures are possible from the System and
integrator in use.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">params</span></code>:</dt><dd><p>(optional) a parameter structure (</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>InitializeParams).</p>
</div>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">status</span></code>:</dt><dd><p>A SimulatorStatus object indicating success, termination, or an
error condition as reported by event handlers or the monitor
function.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AdvanceTo(), AdvancePendingEvents(), SimulatorStatus</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_-AutoDiffXd-.reset_context">
<span id="pydrake.systems.analysis.Simulator_[AutoDiffXd].reset_context"></span><span class="sig-name descname"><span class="pre">reset_context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_-AutoDiffXd-.reset_context" title="Permalink to this definition"></a></dt>
<dd><p>Replace the internally-maintained Context with a different one. The
current Context is deleted. This is useful for supplying a new set of
initial conditions. You should invoke Initialize() after replacing the
Context.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The new context, which may be null. If the context is null, a new
context must be set before attempting to step the system forward.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_-AutoDiffXd-.ResetStatistics">
<span id="pydrake.systems.analysis.Simulator_[AutoDiffXd].ResetStatistics"></span><span class="sig-name descname"><span class="pre">ResetStatistics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_-AutoDiffXd-.ResetStatistics" title="Permalink to this definition"></a></dt>
<dd><p>Forget accumulated statistics. Statistics are reset to the values they
have post construction or immediately after <code class="docutils literal notranslate"><span class="pre">Initialize()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_-AutoDiffXd-.set_monitor">
<span id="pydrake.systems.analysis.Simulator_[AutoDiffXd].set_monitor"></span><span class="sig-name descname"><span class="pre">set_monitor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">monitor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.EventStatus" title="pydrake.systems.framework.EventStatus"><span class="pre">pydrake.systems.framework.EventStatus</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_-AutoDiffXd-.set_monitor" title="Permalink to this definition"></a></dt>
<dd><p>Provides a monitoring function that will be invoked at the end of
every step. (See the Simulator class documentation for a precise
definition of “step”.) A monitor() function can be used to capture the
trajectory, to terminate the simulation, or to detect error
conditions. The monitor() function is invoked by the Simulator with a
Context whose value is a point along the simulated trajectory. The
monitor can be any functor and should capture any System references it
needs to operate correctly.</p>
<p>A monitor() function behaves the same as would a per-step Publish
event handler included in the top-level System or Diagram being
simulated. As in the case of Publish(), the monitor is called at the
end of every step taken internally by AdvanceTo(), and also at the end
of Initialize() and AdvancePendingEvents(). (See the Simulator class
documentation for more detail about what happens when in these
methods.) The monitor receives the top-level (root) Context, from
which any sub-Context can be obtained using
<code class="docutils literal notranslate"><span class="pre">subsystem.GetMyContextFromRoot()</span></code>, provided the necessary subsystem
reference has been captured for use in the monitor.</p>
<p>** Examples Output time and continuous states whenever the trajectory
is advanced:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">simulator</span><span class="o">.</span><span class="n">set_monitor</span><span class="p">([](</span><span class="n">const</span> <span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">root_context</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">root_context</span><span class="o">.</span><span class="n">get_time</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot; &quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">root_context</span><span class="o">.</span><span class="n">get_continuous_state_vector</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">EventStatus</span><span class="p">::</span><span class="n">Succeeded</span><span class="p">();</span>
<span class="p">});</span>
</pre></div>
</div>
<p>Terminate early but successfully on a condition in a subsystem of the
System diagram being simulated:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">simulator</span><span class="o">.</span><span class="n">set_monitor</span><span class="p">([</span><span class="o">&amp;</span><span class="n">my_subsystem</span><span class="p">](</span><span class="n">const</span> <span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">root_context</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">const</span> <span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">subcontext</span> <span class="o">=</span>
      <span class="n">my_subsystem</span><span class="o">.</span><span class="n">GetMyContextFromRoot</span><span class="p">(</span><span class="n">root_context</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">my_subsystem</span><span class="o">.</span><span class="n">GoalReached</span><span class="p">(</span><span class="n">subcontext</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">EventStatus</span><span class="p">::</span><span class="n">ReachedTermination</span><span class="p">(</span><span class="n">my_subsystem</span><span class="p">,</span>
        <span class="s2">&quot;Simulation achieved the desired goal.&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">EventStatus</span><span class="p">::</span><span class="n">Succeeded</span><span class="p">();</span>
<span class="p">});</span>
</pre></div>
</div>
<p>In the above case, the Simulator’s AdvanceTo() method will return
early when the subsystem reports that it has reached its goal. The
returned status will indicate the termination reason, and a
human-readable termination message containing the message provided by
the monitor can be obtained with status.FormatMessage().</p>
<p>Failure due to plant center of mass falling below a threshold:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">simulator</span><span class="o">.</span><span class="n">set_monitor</span><span class="p">([</span><span class="o">&amp;</span><span class="n">plant</span><span class="p">](</span><span class="n">const</span> <span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">root_context</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">const</span> <span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">plant_context</span> <span class="o">=</span>
      <span class="n">plant</span><span class="o">.</span><span class="n">GetMyContextFromRoot</span><span class="p">(</span><span class="n">root_context</span><span class="p">);</span>
  <span class="n">const</span> <span class="n">Vector3</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">com</span> <span class="o">=</span>
      <span class="n">plant</span><span class="o">.</span><span class="n">CalcCenterOfMassPositionInWorld</span><span class="p">(</span><span class="n">plant_context</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.1</span><span class="p">)</span> <span class="p">{</span>  <span class="o">//</span> <span class="n">Check</span> <span class="n">z</span> <span class="n">height</span> <span class="n">of</span> <span class="n">com</span><span class="o">.</span>
    <span class="k">return</span> <span class="n">EventStatus</span><span class="p">::</span><span class="n">Failed</span><span class="p">(</span><span class="n">plant</span><span class="p">,</span> <span class="s2">&quot;System fell over.&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">EventStatus</span><span class="p">::</span><span class="n">Succeeded</span><span class="p">();</span>
<span class="p">});</span>
</pre></div>
</div>
<p>In the above case the Simulator’s AdvanceTo() method will throw an
RuntimeError containing a human-readable message including the text
provided in the monitor.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>monitor() is called every time the trajectory is advanced by a
step, which can mean it is called many times during a single
AdvanceTo() call.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The presence of a monitor has no effect on the step sizes taken,
so a termination or error condition will be discovered only when
first observed after a step is complete; it will not be further
localized. Use witness-triggered events instead if you need
precise isolation.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_-AutoDiffXd-.set_publish_at_initialization">
<span id="pydrake.systems.analysis.Simulator_[AutoDiffXd].set_publish_at_initialization"></span><span class="sig-name descname"><span class="pre">set_publish_at_initialization</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">publish</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_-AutoDiffXd-.set_publish_at_initialization" title="Permalink to this definition"></a></dt>
<dd><p>Sets whether the simulation should trigger a forced-Publish at the end
of Initialize(). See set_publish_every_time_step() documentation for
more information.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_-AutoDiffXd-.set_publish_every_time_step">
<span id="pydrake.systems.analysis.Simulator_[AutoDiffXd].set_publish_every_time_step"></span><span class="sig-name descname"><span class="pre">set_publish_every_time_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">publish</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_-AutoDiffXd-.set_publish_every_time_step" title="Permalink to this definition"></a></dt>
<dd><p>Sets whether the simulation should trigger a forced-Publish event on
the System under simulation at the end of every trajectory-advancing
step. Specifically, that means the System::Publish() event dispatcher
will be invoked on each subsystem of the System and passed the current
Context and a forced-publish Event. If a subsystem has declared a
forced-publish event handler, that will be called. Otherwise, nothing
will happen unless the DoPublish() dispatcher has been overridden.</p>
<p>Enabling this option does not cause a forced-publish to be triggered
at initialization; if you want that you should also call
<code class="docutils literal notranslate"><span class="pre">set_publish_at_initialization(true)</span></code>. If you want a forced-publish
at the end of every step, you will usually also want one at the end of
initialization, requiring both options to be enabled.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>LeafSystem::DeclareForcedPublishEvent()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_-AutoDiffXd-.set_target_realtime_rate">
<span id="pydrake.systems.analysis.Simulator_[AutoDiffXd].set_target_realtime_rate"></span><span class="sig-name descname"><span class="pre">set_target_realtime_rate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">realtime_rate</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_-AutoDiffXd-.set_target_realtime_rate" title="Permalink to this definition"></a></dt>
<dd><p>Slow the simulation down to <em>approximately</em> synchronize with real time
when it would otherwise run too fast. Normally the Simulator takes
steps as quickly as it can. You can request that it slow down to
synchronize with real time by providing a realtime rate greater than
zero here.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>No guarantees can be made about how accurately the simulation can
be made to track real time, even if computation is fast enough.
That’s because the system utilities used to implement this do not
themselves provide such guarantees. So this is likely to work
nicely for visualization purposes where human perception is the
only concern. For any other uses you should consider whether
approximate real time is adequate for your purposes.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the full-speed simulation is already slower than real time you
can’t speed it up with this call! Instead consider requesting less
integration accuracy, using a faster integration method or fixed
time step, or using a simpler model.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">realtime_rate</span></code>:</dt><dd><p>Desired rate relative to real time. Set to 1 to track real time, 2
to run twice as fast as real time, 0.5 for half speed, etc. Zero
or negative restores the rate to its default of 0, meaning the
simulation will proceed as fast as possible.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_-float">
<span id="pydrake.systems.analysis.Simulator_[float]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.systems.analysis.</span></span><span class="sig-name descname"><span class="pre">Simulator_[float]</span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_-float" title="Permalink to this definition"></a></dt>
<dd><p>A class for advancing the state of hybrid dynamic systems, represented
by <code class="docutils literal notranslate"><span class="pre">System&lt;T&gt;</span></code> objects, forward in time. Starting with an initial
Context for a given System, Simulator advances time and produces a
series of Context values that forms a trajectory satisfying the
system’s dynamic equations to a specified accuracy. Only the Context
is modified by a Simulator; the System is const.</p>
<p>A Drake System is a continuous/discrete/hybrid dynamic system where
the continuous part is a DAE, that is, it is expected to consist of a
set of differential equations and bilateral algebraic constraints. The
set of active constraints may change as a result of particular events,
such as contact.</p>
<p>Given a current Context, we expect a System to provide us with -
derivatives for the continuous differential equations that already
satisfy the differentiated form of the constraints (typically,
acceleration constraints), - a projection method for least-squares
correction of violated higher-level constraints (position and velocity
level), - a time-of-next-update method that can be used to adjust the
integrator step size in preparation for a discrete update, - methods
that can update discrete variables when their update time is reached,
- witness (guard) functions for event isolation, - event handlers
(reset functions) for making appropriate changes to state and mode
variables when an event has been isolated.</p>
<p>The continuous parts of the trajectory are advanced using a numerical
integrator. Different integrators have different properties; you can
choose the one that is most appropriate for your application or use
the default which is adequate for most systems.</p>
<p>&lt;h3&gt;How the simulation is stepped: simulation mechanics for authors of
discrete and hybrid systems&lt;/h3&gt;</p>
<p>This section is targeted toward users who have created a LeafSystem
implementing a discrete or hybrid system. For authors of such systems,
it can be useful to understand the simulation details in order to
attain the desired state behavior over time. This behavior is
dependent on the ordering in which discrete events and continuous
updates are processed. (By “discrete events” we mean to include any of
Drake’s event handlers.) The basic issues and terminology are
introduced in the discrete_systems module; please look there first
before proceeding.</p>
<p>As pictured in discrete_systems, when a continuous-time system has
discrete events, the state x can have two significant values at the
event time t. These are - x⁻(t), the value of x <em>before</em> the discrete
update occurs (○ markers), and - x⁺(t), the value of x <em>after</em> the
discrete update occurs (● markers).</p>
<p>Thus the value of the Context, which contains both time and state,
advances from {t, x⁻(t)} to {t, x⁺(t)} as a result of the update.
While those Context values are user-visible, the details of stepping
here require an intermediate value which we’ll denote {t, x*(t)}.</p>
<p>Recall that Drake’s state x is partitioned into continuous, discrete,
and abstract partitions xc, xd, and xa, so <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">xc,</span> <span class="pre">xd,</span> <span class="pre">xa</span> <span class="pre">}</span></code>.
Within a single step, these are updated in three stages: -</p>
<p>Unrestricted update (can change x) -</p>
<p>Discrete update (can change only xd) -</p>
<p>Continuous update (changes t and xc)</p>
<p>Where needed, we extend the above notation to xc⁻, xa⁺, etc. to
indicate the value of an individual partition at a particular stage of
the stepping algorithm.</p>
<p>The following pseudocode uses the above notation to describe the
algorithm “Step()” that the Simulator uses to incrementally advance
the system trajectory (time t and state x). The Simulator’s
AdvanceTo() method will be defined in terms of Step below. In general,
the length of a step is not known a priori and is determined by the
Step() algorithm. Each step consists of zero or more unrestricted
updates, followed by zero or more discrete updates, followed by
(possibly zero-length) continuous time and state advancement, followed
by zero or more publishes, and then a call to the monitor() function
if one has been defined. Updates, publishes, and the monitor can
report errors or detect a termination condition; that is not shown in
the pseudocode below.</p>
<p>The pseudocode will clarify the effects on time and state of each of
the update stages above. This algorithm is given a starting Context
value <code class="docutils literal notranslate"><span class="pre">{tₛ,</span> <span class="pre">x⁻(tₛ)}</span></code> and returns an end Context value <code class="docutils literal notranslate"><span class="pre">{tₑ,</span>
<span class="pre">x⁻(tₑ)}</span></code>, where tₑ is <em>no later</em> than a given tₘₐₓ.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// Advance the trajectory (time and state) from start value {tₛ, x⁻(tₛ)} to an
// end value {tₑ, x⁻(tₑ)}, where tₛ ≤ tₑ ≤ tₘₐₓ.
procedure Step(tₛ, x⁻(tₛ), tₘₐₓ)

// Update any variables (no restrictions).
x*(tₛ) ← DoAnyUnrestrictedUpdates(tₛ, x⁻(tₛ))

// ----------------------------------
// Time and state are at {tₛ, x*(tₛ)}
// ----------------------------------

// Update discrete variables.
xd⁺(tₛ) ← DoAnyDiscreteUpdates(tₛ, x*(tₛ))

xc⁺(tₛ) ← xc*(tₛ)  // These values carry over from x*(tₛ).
xa⁺(tₛ) ← xa*(tₛ)

// ----------------------------------
// Time and state are at {tₛ, x⁺(tₛ)}
// ----------------------------------

// See how far it is safe to integrate without missing any events.
tₑᵥₑₙₜ ← CalcNextEventTime(tₛ, x⁺(tₛ))

// Integrate continuous variables forward in time. Integration may terminate
// before reaching tₛₜₒₚ due to witnessed events.
tₛₜₒₚ ← min(tₑᵥₑₙₜ, tₘₐₓ)
tₑ, xc⁻(tₑ) ← Integrate(tₛ, x⁺(tₛ), tₛₜₒₚ)

xd⁻(tₑ) ← xd⁺(tₛ)  // Discrete values are held from x⁺(tₛ).
xa⁻(tₑ) ← xa⁺(tₛ)

// ----------------------------------
// Time and state are at {tₑ, x⁻(tₑ)}
// ----------------------------------

DoAnyPublishes(tₑ, x⁻(tₑ))
CallMonitor(tₑ, x⁻(tₑ))

return {tₑ, x⁻(tₑ)}
</pre></div>
</div>
<p>We can use the notation and pseudocode to flesh out the AdvanceTo(),
AdvancePendingEvents(), and Initialize() functions. Termination and
error conditions detected by event handlers or the monitor are
reported as status returns from these methods.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>// Advance the simulation until time tₘₐₓ.
procedure AdvanceTo(tₘₐₓ) → status
t ← current_time
while t &lt; tₘₐₓ
{tₑ, x⁻(tₑ)} ← Step(t, x⁻(t), tₘₐₓ)
{t, x⁻(t)} ← {tₑ, x⁻(tₑ)}
endwhile

// AdvancePendingEvents() is an advanced method, not commonly used.
// Perform just the start-of-step update to advance from x⁻(t) to x⁺(t).
procedure AdvancePendingEvents() → status
t ≜ current_time, x⁻(t) ≜ current_state
x⁺(t) ← DoAnyPendingUpdates(t, x⁻(t)) as in Step()
x(t) ← x⁺(t)  // No continuous update needed.
DoAnyPublishes(t, x(t))
CallMonitor(t, x(t))

// Update time and state to {t₀, x⁻(t₀)}, which is the starting value of the
// trajectory, and thus the value the Context should contain at the start of the
// first simulation step.
procedure Initialize(t₀, x₀) → status
// Initialization events can be optionally suppressed.
x⁺(t₀) ← DoAnyInitializationUpdates as in Step()
x⁻(t₀) ← x⁺(t₀)  // No continuous update needed.

// ----------------------------------
// Time and state are at {t₀, x⁻(t₀)}
// ----------------------------------

DoAnyPublishes(t₀, x⁻(t₀))
CallMonitor(t₀, x⁻(t₀))
</pre></div>
</div>
<p>Initialize() can be viewed as a “0ᵗʰ step” that occurs before the
first Step() call as described above. Like Step(), Initialize() first
performs pending updates (in this case only initialization events can
be “pending”, and even those may be optionally suppressed). Time
doesn’t advance so there is no continuous update phase and witnesses
cannot trigger. Finally, again like Step(), the initial trajectory
point <code class="docutils literal notranslate"><span class="pre">{t₀,</span> <span class="pre">x⁻(t₀)}</span></code> is provided to the handlers for any triggered
publish events. That includes initialization publish events (if not
suppressed), per-step publish events, and periodic or timed publish
events that trigger at t₀, followed by a call to the monitor()
function if one has been defined (a monitor is semantically identical
to a per-step publish).</p>
<p>Optionally, initialization events can be suppressed. This can be
useful when reusing the simulator over the same system and time span.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_-float-.__init__">
<span id="pydrake.systems.analysis.Simulator_[float].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">system</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.System_" title="pydrake.systems.framework.System_"><span class="pre">pydrake.systems.framework.System_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_-float-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Create a Simulator that can advance a given System through time to
produce a trajectory consisting of a sequence of Context values. The
System must not have unresolved input ports if the values of those
ports are necessary for computations performed during simulation (see
class documentation).</p>
<p>The Simulator holds an internal, non-owned reference to the System
object so you must ensure that <code class="docutils literal notranslate"><span class="pre">system</span></code> has a longer lifetime than
the Simulator. It also owns a compatible Context internally that takes
on each of the trajectory values. You may optionally provide a Context
that will be used as the initial condition for the simulation;
otherwise the Simulator will obtain a default Context from <code class="docutils literal notranslate"><span class="pre">system</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_-float-.AdvancePendingEvents">
<span id="pydrake.systems.analysis.Simulator_[float].AdvancePendingEvents"></span><span class="sig-name descname"><span class="pre">AdvancePendingEvents</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.systems.analysis.SimulatorStatus" title="pydrake.systems.analysis.SimulatorStatus"><span class="pre">pydrake.systems.analysis.SimulatorStatus</span></a></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_-float-.AdvancePendingEvents" title="Permalink to this definition"></a></dt>
<dd><p>(Advanced) Handles discrete and abstract state update events that are
pending from the previous AdvanceTo() call, without advancing time.
See the Simulator class description for details about how Simulator
advances time and handles events. In the terminology used there, this
method advances the internal Context from <code class="docutils literal notranslate"><span class="pre">{t,</span> <span class="pre">x⁻(t)}</span></code> to <code class="docutils literal notranslate"><span class="pre">{t,</span>
<span class="pre">x⁺(t)}</span></code>.</p>
<p>Normally, these update events would be handled at the start of the
next AdvanceTo() call, so this method is rarely needed. It can be
useful at the end of a simulation or to get intermediate results when
you are specifically interested in the <code class="docutils literal notranslate"><span class="pre">x⁺(t)</span></code> result.</p>
<p>This method is equivalent to <code class="docutils literal notranslate"><span class="pre">AdvanceTo(current_time)</span></code>, where
<code class="docutils literal notranslate"><span class="pre">current_time=simulator.get_context().get_time())</span></code>. If there are no
pending events, nothing happens except possibly a final per-step
publish call (if enabled) followed by a call to the monitor() function
(if one has been provided).</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">status</span></code>:</dt><dd><p>A SimulatorStatus object indicating success, termination, or an
error condition as reported by event handlers or the monitor
function.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AdvanceTo(), Initialize(), SimulatorStatus</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_-float-.AdvanceTo">
<span id="pydrake.systems.analysis.Simulator_[float].AdvanceTo"></span><span class="sig-name descname"><span class="pre">AdvanceTo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundary_time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.systems.analysis.SimulatorStatus" title="pydrake.systems.analysis.SimulatorStatus"><span class="pre">pydrake.systems.analysis.SimulatorStatus</span></a></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_-float-.AdvanceTo" title="Permalink to this definition"></a></dt>
<dd><p>Advances the System’s trajectory until <code class="docutils literal notranslate"><span class="pre">boundary_time</span></code> is reached in
the context or some other termination condition occurs. A variety of
<code class="docutils literal notranslate"><span class="pre">RuntimeError</span></code> conditions are possible here, as well as error
conditions that may be thrown by the System when it is asked to
perform computations. Be sure to enclose your simulation in a
<code class="docutils literal notranslate"><span class="pre">try-catch</span></code> block and display the <code class="docutils literal notranslate"><span class="pre">what()</span></code> message.</p>
<p>We recommend that you call Initialize() prior to making the first call
to AdvanceTo(). However, if you don’t it will be called for you the
first time that you attempt a step, possibly resulting in unexpected
error conditions. See documentation for <code class="docutils literal notranslate"><span class="pre">Initialize()</span></code> for the error
conditions it might produce.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>You should consider calling Initialize() if you alter the the
Context or Simulator options between successive AdvanceTo() calls.
See Initialize() for more information.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">boundary_time</span></code>:</dt><dd><p>The maximum time to which the trajectory will be advanced by this
call to AdvanceTo(). The method may return earlier if an event or
the monitor function requests termination or reports an error
condition.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">status</span></code>:</dt><dd><p>A SimulatorStatus object indicating success, termination, or an
error condition as reported by event handlers or the monitor
function. The time in the context will be set either to the
boundary_time or the time a termination or error was first
detected.</p>
</dd>
<dt>Precondition:</dt><dd><p>The internal Context satisfies all System constraints or will
after pending Context updates are performed.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Initialize(), AdvancePendingEvents(), SimulatorStatus</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_-float-.clear_monitor">
<span id="pydrake.systems.analysis.Simulator_[float].clear_monitor"></span><span class="sig-name descname"><span class="pre">clear_monitor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_-float-.clear_monitor" title="Permalink to this definition"></a></dt>
<dd><p>Removes the monitoring function if there is one.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>set_monitor()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_-float-.get_actual_realtime_rate">
<span id="pydrake.systems.analysis.Simulator_[float].get_actual_realtime_rate"></span><span class="sig-name descname"><span class="pre">get_actual_realtime_rate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_-float-.get_actual_realtime_rate" title="Permalink to this definition"></a></dt>
<dd><p>Return the rate that simulated time has progressed relative to real
time. A return of 1 means the simulation just matched real time, 2
means the simulation was twice as fast as real time, 0.5 means it was
running in 2X slow motion, etc.</p>
<p>The value returned here is calculated as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">simulated_time_now</span> <span class="o">-</span> <span class="n">initial_simulated_time</span>
  <span class="n">rate</span> <span class="o">=</span> <span class="o">-------------------------------------------</span>
               <span class="n">realtime_now</span> <span class="o">-</span> <span class="n">initial_realtime</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">initial</span></code> times are recorded when Initialize() or
ResetStatistics() is called. The returned rate is undefined if
Initialize() has not yet been called.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The rate achieved since the last Initialize() or ResetStatistics()
call.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>set_target_realtime_rate()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_-float-.get_context">
<span id="pydrake.systems.analysis.Simulator_[float].get_context"></span><span class="sig-name descname"><span class="pre">get_context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_-float-.get_context" title="Permalink to this definition"></a></dt>
<dd><p>Returns a const reference to the internally-maintained Context holding
the most recent step in the trajectory. This is suitable for
publishing or extracting information about this trajectory step. Do
not call this method if there is no Context.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_-float-.get_integrator">
<span id="pydrake.systems.analysis.Simulator_[float].get_integrator"></span><span class="sig-name descname"><span class="pre">get_integrator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_-float-.get_integrator" title="Permalink to this definition"></a></dt>
<dd><p>Gets a reference to the integrator used to advance the continuous
aspects of the system.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_-float-.get_monitor">
<span id="pydrake.systems.analysis.Simulator_[float].get_monitor"></span><span class="sig-name descname"><span class="pre">get_monitor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.EventStatus" title="pydrake.systems.framework.EventStatus"><span class="pre">pydrake.systems.framework.EventStatus</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_-float-.get_monitor" title="Permalink to this definition"></a></dt>
<dd><p>Obtains a reference to the monitoring function, which may be empty.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>set_monitor()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_-float-.get_mutable_context">
<span id="pydrake.systems.analysis.Simulator_[float].get_mutable_context"></span><span class="sig-name descname"><span class="pre">get_mutable_context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_-float-.get_mutable_context" title="Permalink to this definition"></a></dt>
<dd><p>Returns a mutable reference to the internally-maintained Context
holding the most recent step in the trajectory. This is suitable for
use in updates, sampling operations, event handlers, and constraint
projection. You can also modify this prior to calling Initialize() to
set initial conditions. Do not call this method if there is no
Context.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_-float-.get_mutable_integrator">
<span id="pydrake.systems.analysis.Simulator_[float].get_mutable_integrator"></span><span class="sig-name descname"><span class="pre">get_mutable_integrator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.systems.analysis.IntegratorBase_" title="pydrake.systems.analysis.IntegratorBase_"><span class="pre">pydrake.systems.analysis.IntegratorBase_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_-float-.get_mutable_integrator" title="Permalink to this definition"></a></dt>
<dd><p>Gets a reference to the mutable integrator used to advance the
continuous state of the system.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_-float-.get_system">
<span id="pydrake.systems.analysis.Simulator_[float].get_system"></span><span class="sig-name descname"><span class="pre">get_system</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.System_" title="pydrake.systems.framework.System_"><span class="pre">pydrake.systems.framework.System_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_-float-.get_system" title="Permalink to this definition"></a></dt>
<dd><p>Gets a constant reference to the system.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>a mutable reference is not available.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_-float-.get_target_realtime_rate">
<span id="pydrake.systems.analysis.Simulator_[float].get_target_realtime_rate"></span><span class="sig-name descname"><span class="pre">get_target_realtime_rate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_-float-.get_target_realtime_rate" title="Permalink to this definition"></a></dt>
<dd><p>Return the real time rate target currently in effect. The default is
zero, meaning the Simulator runs as fast as possible. You can change
the target with set_target_realtime_rate().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_-float-.has_context">
<span id="pydrake.systems.analysis.Simulator_[float].has_context"></span><span class="sig-name descname"><span class="pre">has_context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_-float-.has_context" title="Permalink to this definition"></a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if this Simulator has an internally-maintained
Context. This is always true unless <code class="docutils literal notranslate"><span class="pre">reset_context()</span></code> has been
called.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_-float-.Initialize">
<span id="pydrake.systems.analysis.Simulator_[float].Initialize"></span><span class="sig-name descname"><span class="pre">Initialize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.InitializeParams" title="pydrake.systems.analysis.InitializeParams"><span class="pre">pydrake.systems.analysis.InitializeParams</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">InitializeParams(suppress_initialization_events=False)</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.systems.analysis.SimulatorStatus" title="pydrake.systems.analysis.SimulatorStatus"><span class="pre">pydrake.systems.analysis.SimulatorStatus</span></a></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_-float-.Initialize" title="Permalink to this definition"></a></dt>
<dd><p>See the class documentation for more information. We recommend calling
Initialize() explicitly prior to beginning a simulation so that error
conditions will be discovered early. However, Initialize() will be
called automatically by the first AdvanceTo() call if it hasn’t
already been called.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you make a change to the Context or to Simulator options
between AdvanceTo() calls you should consider whether to call
Initialize() before resuming; AdvanceTo() will not do that
automatically for you. Whether to do so depends on whether you
want the above initialization operations performed.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In particular, if you changed the time you must call Initialize().
The time-triggered events must be recalculated in case one is due
at the new starting time. The AdvanceTo() call will throw an
exception if the Initialize() call is missing.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The only way to suppress initialization events is by calling
Initialize() explicitly. The most common scenario for this is when
reusing a Simulator object. In this case, the caller is
responsible for ensuring the correctness of the initial state.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Initialize() does not automatically attempt to satisfy System
constraints – it is up to you to make sure that constraints are
satisfied by the initial conditions.</p>
</div>
<p>This method will throw <code class="docutils literal notranslate"><span class="pre">RuntimeError</span></code> if the combination of options
doesn’t make sense. Other failures are possible from the System and
integrator in use.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">params</span></code>:</dt><dd><p>(optional) a parameter structure (</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>InitializeParams).</p>
</div>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">status</span></code>:</dt><dd><p>A SimulatorStatus object indicating success, termination, or an
error condition as reported by event handlers or the monitor
function.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AdvanceTo(), AdvancePendingEvents(), SimulatorStatus</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_-float-.reset_context">
<span id="pydrake.systems.analysis.Simulator_[float].reset_context"></span><span class="sig-name descname"><span class="pre">reset_context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_-float-.reset_context" title="Permalink to this definition"></a></dt>
<dd><p>Replace the internally-maintained Context with a different one. The
current Context is deleted. This is useful for supplying a new set of
initial conditions. You should invoke Initialize() after replacing the
Context.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The new context, which may be null. If the context is null, a new
context must be set before attempting to step the system forward.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_-float-.ResetStatistics">
<span id="pydrake.systems.analysis.Simulator_[float].ResetStatistics"></span><span class="sig-name descname"><span class="pre">ResetStatistics</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_-float-.ResetStatistics" title="Permalink to this definition"></a></dt>
<dd><p>Forget accumulated statistics. Statistics are reset to the values they
have post construction or immediately after <code class="docutils literal notranslate"><span class="pre">Initialize()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_-float-.set_monitor">
<span id="pydrake.systems.analysis.Simulator_[float].set_monitor"></span><span class="sig-name descname"><span class="pre">set_monitor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">monitor</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.Context_" title="pydrake.systems.framework.Context_"><span class="pre">pydrake.systems.framework.Context_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.EventStatus" title="pydrake.systems.framework.EventStatus"><span class="pre">pydrake.systems.framework.EventStatus</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_-float-.set_monitor" title="Permalink to this definition"></a></dt>
<dd><p>Provides a monitoring function that will be invoked at the end of
every step. (See the Simulator class documentation for a precise
definition of “step”.) A monitor() function can be used to capture the
trajectory, to terminate the simulation, or to detect error
conditions. The monitor() function is invoked by the Simulator with a
Context whose value is a point along the simulated trajectory. The
monitor can be any functor and should capture any System references it
needs to operate correctly.</p>
<p>A monitor() function behaves the same as would a per-step Publish
event handler included in the top-level System or Diagram being
simulated. As in the case of Publish(), the monitor is called at the
end of every step taken internally by AdvanceTo(), and also at the end
of Initialize() and AdvancePendingEvents(). (See the Simulator class
documentation for more detail about what happens when in these
methods.) The monitor receives the top-level (root) Context, from
which any sub-Context can be obtained using
<code class="docutils literal notranslate"><span class="pre">subsystem.GetMyContextFromRoot()</span></code>, provided the necessary subsystem
reference has been captured for use in the monitor.</p>
<p>** Examples Output time and continuous states whenever the trajectory
is advanced:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">simulator</span><span class="o">.</span><span class="n">set_monitor</span><span class="p">([](</span><span class="n">const</span> <span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">root_context</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">root_context</span><span class="o">.</span><span class="n">get_time</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s2">&quot; &quot;</span>
            <span class="o">&lt;&lt;</span> <span class="n">root_context</span><span class="o">.</span><span class="n">get_continuous_state_vector</span><span class="p">()</span>
            <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">EventStatus</span><span class="p">::</span><span class="n">Succeeded</span><span class="p">();</span>
<span class="p">});</span>
</pre></div>
</div>
<p>Terminate early but successfully on a condition in a subsystem of the
System diagram being simulated:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">simulator</span><span class="o">.</span><span class="n">set_monitor</span><span class="p">([</span><span class="o">&amp;</span><span class="n">my_subsystem</span><span class="p">](</span><span class="n">const</span> <span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">root_context</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">const</span> <span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">subcontext</span> <span class="o">=</span>
      <span class="n">my_subsystem</span><span class="o">.</span><span class="n">GetMyContextFromRoot</span><span class="p">(</span><span class="n">root_context</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">my_subsystem</span><span class="o">.</span><span class="n">GoalReached</span><span class="p">(</span><span class="n">subcontext</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">EventStatus</span><span class="p">::</span><span class="n">ReachedTermination</span><span class="p">(</span><span class="n">my_subsystem</span><span class="p">,</span>
        <span class="s2">&quot;Simulation achieved the desired goal.&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">EventStatus</span><span class="p">::</span><span class="n">Succeeded</span><span class="p">();</span>
<span class="p">});</span>
</pre></div>
</div>
<p>In the above case, the Simulator’s AdvanceTo() method will return
early when the subsystem reports that it has reached its goal. The
returned status will indicate the termination reason, and a
human-readable termination message containing the message provided by
the monitor can be obtained with status.FormatMessage().</p>
<p>Failure due to plant center of mass falling below a threshold:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">simulator</span><span class="o">.</span><span class="n">set_monitor</span><span class="p">([</span><span class="o">&amp;</span><span class="n">plant</span><span class="p">](</span><span class="n">const</span> <span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">root_context</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">const</span> <span class="n">Context</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">plant_context</span> <span class="o">=</span>
      <span class="n">plant</span><span class="o">.</span><span class="n">GetMyContextFromRoot</span><span class="p">(</span><span class="n">root_context</span><span class="p">);</span>
  <span class="n">const</span> <span class="n">Vector3</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">com</span> <span class="o">=</span>
      <span class="n">plant</span><span class="o">.</span><span class="n">CalcCenterOfMassPositionInWorld</span><span class="p">(</span><span class="n">plant_context</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">com</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.1</span><span class="p">)</span> <span class="p">{</span>  <span class="o">//</span> <span class="n">Check</span> <span class="n">z</span> <span class="n">height</span> <span class="n">of</span> <span class="n">com</span><span class="o">.</span>
    <span class="k">return</span> <span class="n">EventStatus</span><span class="p">::</span><span class="n">Failed</span><span class="p">(</span><span class="n">plant</span><span class="p">,</span> <span class="s2">&quot;System fell over.&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">EventStatus</span><span class="p">::</span><span class="n">Succeeded</span><span class="p">();</span>
<span class="p">});</span>
</pre></div>
</div>
<p>In the above case the Simulator’s AdvanceTo() method will throw an
RuntimeError containing a human-readable message including the text
provided in the monitor.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>monitor() is called every time the trajectory is advanced by a
step, which can mean it is called many times during a single
AdvanceTo() call.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The presence of a monitor has no effect on the step sizes taken,
so a termination or error condition will be discovered only when
first observed after a step is complete; it will not be further
localized. Use witness-triggered events instead if you need
precise isolation.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_-float-.set_publish_at_initialization">
<span id="pydrake.systems.analysis.Simulator_[float].set_publish_at_initialization"></span><span class="sig-name descname"><span class="pre">set_publish_at_initialization</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">publish</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_-float-.set_publish_at_initialization" title="Permalink to this definition"></a></dt>
<dd><p>Sets whether the simulation should trigger a forced-Publish at the end
of Initialize(). See set_publish_every_time_step() documentation for
more information.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_-float-.set_publish_every_time_step">
<span id="pydrake.systems.analysis.Simulator_[float].set_publish_every_time_step"></span><span class="sig-name descname"><span class="pre">set_publish_every_time_step</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">publish</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_-float-.set_publish_every_time_step" title="Permalink to this definition"></a></dt>
<dd><p>Sets whether the simulation should trigger a forced-Publish event on
the System under simulation at the end of every trajectory-advancing
step. Specifically, that means the System::Publish() event dispatcher
will be invoked on each subsystem of the System and passed the current
Context and a forced-publish Event. If a subsystem has declared a
forced-publish event handler, that will be called. Otherwise, nothing
will happen unless the DoPublish() dispatcher has been overridden.</p>
<p>Enabling this option does not cause a forced-publish to be triggered
at initialization; if you want that you should also call
<code class="docutils literal notranslate"><span class="pre">set_publish_at_initialization(true)</span></code>. If you want a forced-publish
at the end of every step, you will usually also want one at the end of
initialization, requiring both options to be enabled.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>LeafSystem::DeclareForcedPublishEvent()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.Simulator_-float-.set_target_realtime_rate">
<span id="pydrake.systems.analysis.Simulator_[float].set_target_realtime_rate"></span><span class="sig-name descname"><span class="pre">set_target_realtime_rate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.Simulator_" title="pydrake.systems.analysis.Simulator_"><span class="pre">pydrake.systems.analysis.Simulator_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">realtime_rate</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.Simulator_-float-.set_target_realtime_rate" title="Permalink to this definition"></a></dt>
<dd><p>Slow the simulation down to <em>approximately</em> synchronize with real time
when it would otherwise run too fast. Normally the Simulator takes
steps as quickly as it can. You can request that it slow down to
synchronize with real time by providing a realtime rate greater than
zero here.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>No guarantees can be made about how accurately the simulation can
be made to track real time, even if computation is fast enough.
That’s because the system utilities used to implement this do not
themselves provide such guarantees. So this is likely to work
nicely for visualization purposes where human perception is the
only concern. For any other uses you should consider whether
approximate real time is adequate for your purposes.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the full-speed simulation is already slower than real time you
can’t speed it up with this call! Instead consider requesting less
integration accuracy, using a faster integration method or fixed
time step, or using a simpler model.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">realtime_rate</span></code>:</dt><dd><p>Desired rate relative to real time. Set to 1 to track real time, 2
to run twice as fast as real time, 0.5 for half speed, etc. Zero
or negative restores the rate to its default of 0, meaning the
simulation will proceed as fast as possible.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.systems.analysis.SimulatorConfig">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.systems.analysis.</span></span><span class="sig-name descname"><span class="pre">SimulatorConfig</span></span><a class="headerlink" href="#pydrake.systems.analysis.SimulatorConfig" title="Permalink to this definition"></a></dt>
<dd><p>The set of all configurable properties on a Simulator and
IntegratorBase.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.SimulatorConfig.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.SimulatorConfig" title="pydrake.systems.analysis.SimulatorConfig"><span class="pre">pydrake.systems.analysis.SimulatorConfig</span></a></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.SimulatorConfig.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.systems.analysis.SimulatorConfig.accuracy">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">accuracy</span></span><a class="headerlink" href="#pydrake.systems.analysis.SimulatorConfig.accuracy" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.systems.analysis.SimulatorConfig.integration_scheme">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">integration_scheme</span></span><a class="headerlink" href="#pydrake.systems.analysis.SimulatorConfig.integration_scheme" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.systems.analysis.SimulatorConfig.max_step_size">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_step_size</span></span><a class="headerlink" href="#pydrake.systems.analysis.SimulatorConfig.max_step_size" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.systems.analysis.SimulatorConfig.publish_every_time_step">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">publish_every_time_step</span></span><a class="headerlink" href="#pydrake.systems.analysis.SimulatorConfig.publish_every_time_step" title="Permalink to this definition"></a></dt>
<dd><p>Sets Simulator::set_publish_at_initialization() in addition to
Simulator::set_publish_every_time_step() when applied by
ApplySimulatorConfig().</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.systems.analysis.SimulatorConfig.target_realtime_rate">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">target_realtime_rate</span></span><a class="headerlink" href="#pydrake.systems.analysis.SimulatorConfig.target_realtime_rate" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.systems.analysis.SimulatorConfig.use_error_control">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">use_error_control</span></span><a class="headerlink" href="#pydrake.systems.analysis.SimulatorConfig.use_error_control" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.systems.analysis.SimulatorStatus">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.systems.analysis.</span></span><span class="sig-name descname"><span class="pre">SimulatorStatus</span></span><a class="headerlink" href="#pydrake.systems.analysis.SimulatorStatus" title="Permalink to this definition"></a></dt>
<dd><p>Holds the status return value from a call to Simulator::AdvanceTo()
and related methods. The argument t to AdvanceTo(t) is called the
boundary time, and represents the maximum time to which the simulation
trajectory will be advanced by a call to AdvanceTo(). (For methods
that don’t advance time, the current time is considered to be the
boundary time.) A normal, successful return means that simulated time
advanced successfully to the boundary time, without encountering a
termination condition or error condition. AdvanceTo() may return
earlier than the boundary time if one of those conditions is
encountered. In that case the return object holds a reference to the
subsystem that detected the condition and a human-friendly message
from that subsystem that hopefully explains what happened.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.SimulatorStatus.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.systems.analysis.SimulatorStatus.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.SimulatorStatus.boundary_time">
<span class="sig-name descname"><span class="pre">boundary_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.SimulatorStatus" title="pydrake.systems.analysis.SimulatorStatus"><span class="pre">pydrake.systems.analysis.SimulatorStatus</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.SimulatorStatus.boundary_time" title="Permalink to this definition"></a></dt>
<dd><p>Returns the maximum time we could have reached with this call; whether
we actually got there depends on the status. This is the time supplied
in an AdvanceTo() call or the current time for methods that don’t
advance time, that is, Initialize() and AdvancePendingEvents().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.SimulatorStatus.FormatMessage">
<span class="sig-name descname"><span class="pre">FormatMessage</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.SimulatorStatus" title="pydrake.systems.analysis.SimulatorStatus"><span class="pre">pydrake.systems.analysis.SimulatorStatus</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.SimulatorStatus.FormatMessage" title="Permalink to this definition"></a></dt>
<dd><p>Returns a human-readable message explaining the return result.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.SimulatorStatus.IsIdenticalStatus">
<span class="sig-name descname"><span class="pre">IsIdenticalStatus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.SimulatorStatus" title="pydrake.systems.analysis.SimulatorStatus"><span class="pre">pydrake.systems.analysis.SimulatorStatus</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.SimulatorStatus" title="pydrake.systems.analysis.SimulatorStatus"><span class="pre">pydrake.systems.analysis.SimulatorStatus</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.SimulatorStatus.IsIdenticalStatus" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if the <code class="docutils literal notranslate"><span class="pre">other</span></code> status contains exactly the same
information as <code class="docutils literal notranslate"><span class="pre">this</span></code> status. This is likely only useful for unit
testing of SimulatorStatus.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.SimulatorStatus.message">
<span class="sig-name descname"><span class="pre">message</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.SimulatorStatus" title="pydrake.systems.analysis.SimulatorStatus"><span class="pre">pydrake.systems.analysis.SimulatorStatus</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.SimulatorStatus.message" title="Permalink to this definition"></a></dt>
<dd><p>For termination or error conditions, returns a human-readable message
explaining what happened. This is the message from the subsystem that
detected the condition. FormatMessage() returns additional information
and also includes this message.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.SimulatorStatus.reason">
<span class="sig-name descname"><span class="pre">reason</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.SimulatorStatus" title="pydrake.systems.analysis.SimulatorStatus"><span class="pre">pydrake.systems.analysis.SimulatorStatus</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.systems.analysis.SimulatorStatus.ReturnReason" title="pydrake.systems.analysis.SimulatorStatus.ReturnReason"><span class="pre">pydrake.systems.analysis.SimulatorStatus.ReturnReason</span></a></span></span><a class="headerlink" href="#pydrake.systems.analysis.SimulatorStatus.reason" title="Permalink to this definition"></a></dt>
<dd><p>Returns the reason that a Simulator call returned.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.SimulatorStatus.return_time">
<span class="sig-name descname"><span class="pre">return_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.SimulatorStatus" title="pydrake.systems.analysis.SimulatorStatus"><span class="pre">pydrake.systems.analysis.SimulatorStatus</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.SimulatorStatus.return_time" title="Permalink to this definition"></a></dt>
<dd><p>Returns the time that was actually reached. This will be
boundary_time() if succeeded() returns true. Otherwise it is the time
at which a termination or error condition was detected and may be
earlier than boundary_time().</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.systems.analysis.SimulatorStatus.ReturnReason">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ReturnReason</span></span><a class="headerlink" href="#pydrake.systems.analysis.SimulatorStatus.ReturnReason" title="Permalink to this definition"></a></dt>
<dd><p>Members:</p>
<blockquote>
<div><p>kReachedBoundaryTime : This is the normal return: no termination or error condition was</p>
</div></blockquote>
<p>encountered before reaching the boundary time. There is no message and
no saved System.</p>
<blockquote>
<div><p>kReachedTerminationCondition : An event handler or monitor function returned with a “reached</p>
</div></blockquote>
<p>termination condition” EventStatus (has message with details). For
AdvanceTo() the return time may be earlier than the boundary time.</p>
<blockquote>
<div><p>kEventHandlerFailed : An event handler or monitor function returned with a “failed”</p>
</div></blockquote>
<p>EventStatus (has message with details). For AdvanceTo() the return
time may be earlier than the boundary time.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.SimulatorStatus.ReturnReason.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.SimulatorStatus.ReturnReason" title="pydrake.systems.analysis.SimulatorStatus.ReturnReason"><span class="pre">pydrake.systems.analysis.SimulatorStatus.ReturnReason</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.SimulatorStatus.ReturnReason.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.systems.analysis.SimulatorStatus.ReturnReason.kEventHandlerFailed">
<span class="sig-name descname"><span class="pre">kEventHandlerFailed</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;ReturnReason.kEventHandlerFailed:</span> <span class="pre">2&gt;</span></em><a class="headerlink" href="#pydrake.systems.analysis.SimulatorStatus.ReturnReason.kEventHandlerFailed" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.systems.analysis.SimulatorStatus.ReturnReason.kReachedBoundaryTime">
<span class="sig-name descname"><span class="pre">kReachedBoundaryTime</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;ReturnReason.kReachedBoundaryTime:</span> <span class="pre">0&gt;</span></em><a class="headerlink" href="#pydrake.systems.analysis.SimulatorStatus.ReturnReason.kReachedBoundaryTime" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.systems.analysis.SimulatorStatus.ReturnReason.kReachedTerminationCondition">
<span class="sig-name descname"><span class="pre">kReachedTerminationCondition</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;ReturnReason.kReachedTerminationCondition:</span> <span class="pre">1&gt;</span></em><a class="headerlink" href="#pydrake.systems.analysis.SimulatorStatus.ReturnReason.kReachedTerminationCondition" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.systems.analysis.SimulatorStatus.ReturnReason.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#pydrake.systems.analysis.SimulatorStatus.ReturnReason.name" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="pydrake.systems.analysis.SimulatorStatus.ReturnReason.value">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">value</span></span><a class="headerlink" href="#pydrake.systems.analysis.SimulatorStatus.ReturnReason.value" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.SimulatorStatus.succeeded">
<span class="sig-name descname"><span class="pre">succeeded</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.SimulatorStatus" title="pydrake.systems.analysis.SimulatorStatus"><span class="pre">pydrake.systems.analysis.SimulatorStatus</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.systems.analysis.SimulatorStatus.succeeded" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if we reached the boundary time with no surprises.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.systems.analysis.SimulatorStatus.system">
<span class="sig-name descname"><span class="pre">system</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.systems.analysis.SimulatorStatus" title="pydrake.systems.analysis.SimulatorStatus"><span class="pre">pydrake.systems.analysis.SimulatorStatus</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.systems.framework.html#pydrake.systems.framework.SystemBase" title="pydrake.systems.framework.SystemBase"><span class="pre">pydrake.systems.framework.SystemBase</span></a></span></span><a class="headerlink" href="#pydrake.systems.analysis.SimulatorStatus.system" title="Permalink to this definition"></a></dt>
<dd><p>Optionally, returns the subsystem to which the status and contained
message should be attributed. May be nullptr in which case the status
should be attributed to the System as a whole.</p>
</dd></dl>

</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="pydrake.systems.all.html" class="btn btn-neutral float-left" title="pydrake.systems.all" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="pydrake.systems.controllers.html" class="btn btn-neutral float-right" title="pydrake.systems.controllers" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p></p>
  </div>

  
</footer>
<script>
  /* Enables clicking for the mobile "hamburger" (three-line) menu item. */
  const siteHeader = document.querySelector('.site-header')
  const mobileButton = document.querySelector('.menu-mobile-toggle')
  const body = document.querySelector('body')

  mobileButton.addEventListener('click', function(event) {
    siteHeader.classList.toggle('open');
    body.classList.toggle('overflow-hidden');
  })
</script>
<footer class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg">
    </a>
    <div class="footer-menu">
      <ul>
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"></a>
        </li>
      </ul>
    </div>
  </div>


</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>