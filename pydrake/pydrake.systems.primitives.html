<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pydrake.systems.primitives &mdash; pydrake  documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=86f27845" />
      <link rel="stylesheet" type="text/css" href="_static/css/custom.css?v=6b576c25" />

  
  
        <script src="_static/jquery.js?v=8dae8fb0"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=7f41d439"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="pydrake.systems.pyplot_visualizer" href="pydrake.systems.pyplot_visualizer.html" />
    <link rel="prev" title="pydrake.systems.planar_scenegraph_visualizer" href="pydrake.systems.planar_scenegraph_visualizer.html" /> 
</head>

<body class="wy-body-for-nav">
<header class="site-header">
  <div class="site-header-inner contain">
    <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
    <div class="menu-mobile-toggle">
      <span></span>
    </div>
    <nav class="site-menu">
      <ul>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/">Home</a>
        </li>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/installation.html">Installation</a>
        </li>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/gallery.html">Gallery</a>
        </li>
        <li class="site-menu-item site-menu-item-main">API Documentation
          <div class="sub">
            <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a> <a class="site-menu-item" href="/pydrake/index.html">Python</a>
          </div>
        </li>
        <li class="site-menu-item site-menu-item-main">Resources
          <div class="sub">
            <a class="site-menu-item" href="/getting_help.html">Getting Help</a> <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/%2Findex.ipynb">Tutorials</a> <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a> <a class="site-menu-item" href="/developers.html">For Developers</a> <a class="site-menu-item" href="/credits.html">Credits</a>
          </div>
        </li>
        <li class="github-link">
          <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
        </li>
      </ul>
    </nav>
  </div>
</header>

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            pydrake
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search pydrake only…" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
    <input type="text" name="q" placeholder="Search all of Drake…" />
    <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu" />
  </form>
</div>

        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="pydrake.all.html">pydrake.all</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.autodiffutils.html">pydrake.autodiffutils</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.common.html">pydrake.common</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.examples.html">pydrake.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.forwarddiff.html">pydrake.forwarddiff</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.geometry.html">pydrake.geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.gym.html">pydrake.gym</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.lcm.html">pydrake.lcm</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.manipulation.html">pydrake.manipulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.math.html">pydrake.math</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.multibody.html">pydrake.multibody</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.perception.html">pydrake.perception</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.planning.html">pydrake.planning</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.polynomial.html">pydrake.polynomial</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.html">pydrake.solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.symbolic.html">pydrake.symbolic</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="pydrake.systems.html">pydrake.systems</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.all.html">pydrake.systems.all</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.analysis.html">pydrake.systems.analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.controllers.html">pydrake.systems.controllers</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.drawing.html">pydrake.systems.drawing</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.estimators.html">pydrake.systems.estimators</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.framework.html">pydrake.systems.framework</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.lcm.html">pydrake.systems.lcm</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.perception.html">pydrake.systems.perception</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.planar_scenegraph_visualizer.html">pydrake.systems.planar_scenegraph_visualizer</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">pydrake.systems.primitives</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.pyplot_visualizer.html">pydrake.systems.pyplot_visualizer</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.rendering.html">pydrake.systems.rendering</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.scalar_conversion.html">pydrake.systems.scalar_conversion</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.systems.sensors.html">pydrake.systems.sensors</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.trajectories.html">pydrake.trajectories</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.tutorials.html">pydrake.tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.visualization.html">pydrake.visualization</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pydrake</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="pydrake.systems.html">pydrake.systems</a></li>
      <li class="breadcrumb-item active">pydrake.systems.primitives</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-pydrake.systems.primitives">
<span id="pydrake-systems-primitives"></span><h1>pydrake.systems.primitives<a class="headerlink" href="#module-pydrake.systems.primitives" title="Link to this heading"></a></h1>
<p>Bindings for the primitives portion of the Systems framework.</p>
<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Adder</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></p>
<p>An adder for arbitrarily many inputs of equal size.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">...&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">u(N-1)&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Adder</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; sum</td></tr></table></td></tr></table><div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">Adder_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Adder.__init__(self:</span> <span class="pre">pydrake.systems.primitives.Adder,</span> <span class="pre">num_inputs:</span> <span class="pre">int,</span> <span class="pre">size:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Construct an Adder System.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_inputs</span></code>:</dt><dd><p>is the number of input ports to be added.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">size</span></code>:</dt><dd><p>number of elements in each input and output signal.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Adder_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">Adder_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Adder_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Adder_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Adder_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></code></p>
<p>An adder for arbitrarily many inputs of equal size.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">...&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">u(N-1)&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Adder</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; sum</td></tr></table></td></tr></table><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Adder_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.systems.primitives.Adder_[AutoDiffXd],</span> <span class="pre">num_inputs:</span> <span class="pre">int,</span> <span class="pre">size:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Construct an Adder System.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_inputs</span></code>:</dt><dd><p>is the number of input ports to be added.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">size</span></code>:</dt><dd><p>number of elements in each input and output signal.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Adder_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[Expression]</span></code></p>
<p>An adder for arbitrarily many inputs of equal size.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">...&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">u(N-1)&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Adder</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; sum</td></tr></table></td></tr></table><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Adder_[Expression].__init__(self:</span> <span class="pre">pydrake.systems.primitives.Adder_[Expression],</span> <span class="pre">num_inputs:</span> <span class="pre">int,</span> <span class="pre">size:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Construct an Adder System.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_inputs</span></code>:</dt><dd><p>is the number of input ports to be added.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">size</span></code>:</dt><dd><p>number of elements in each input and output signal.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AddRandomInputs(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddRandomInputs(sampling_interval_sec: float, builder: pydrake.systems.framework.DiagramBuilder) -&gt; int</p></li>
</ol>
<p>For each subsystem input port in <code class="docutils literal notranslate"><span class="pre">builder</span></code> that is (a) not yet
connected and (b) labeled as random in the InputPort, this method will
add a new RandomSource system of the appropriate type and connect it
to the subsystem input port.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">sampling_interval_sec</span></code>:</dt><dd><p>interval to be used for all new sources.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the total number of RandomSource systems added.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>stochastic_systems</p>
</div>
<ol class="arabic simple" start="2">
<li><p>AddRandomInputs(sampling_interval_sec: float, builder: pydrake.systems.framework.DiagramBuilder_[AutoDiffXd]) -&gt; int</p></li>
</ol>
<p>For each subsystem input port in <code class="docutils literal notranslate"><span class="pre">builder</span></code> that is (a) not yet
connected and (b) labeled as random in the InputPort, this method will
add a new RandomSource system of the appropriate type and connect it
to the subsystem input port.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">sampling_interval_sec</span></code>:</dt><dd><p>interval to be used for all new sources.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the total number of RandomSource systems added.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>stochastic_systems</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></p>
<p>A discrete OR continuous affine system (with constant coefficients).</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>AffineSystem</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><p>Let <code class="docutils literal notranslate"><span class="pre">u</span></code> denote the input vector, <code class="docutils literal notranslate"><span class="pre">x</span></code> denote the state vector, and
<code class="docutils literal notranslate"><span class="pre">y</span></code> denote the output vector.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">time_period</span> <span class="pre">&gt;</span> <span class="pre">0.0</span></code>, the affine system will have the following
discrete-time state update:</p>
<div class="math notranslate nohighlight">
\[x(t+h) = A x(t) + B u(t) + f_0,\]</div>
<p>where <code class="docutils literal notranslate"><span class="pre">h</span></code> is the time_period. If <code class="docutils literal notranslate"><span class="pre">time_period</span> <span class="pre">==</span> <span class="pre">0.0</span></code>, the affine
system will have the following continuous-time state update:</p>
<div class="math notranslate nohighlight">
\[\dot{x} = A x + B u + f_0.\]</div>
<p>In both cases, the system will have the output:</p>
<div class="math notranslate nohighlight">
\[y = C x + D u + y_0,\]</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>LinearSystem</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MatrixGain</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">AffineSystem_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem.__init__(self:</span> <span class="pre">pydrake.systems.primitives.AffineSystem,</span> <span class="pre">A:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">shape=(0,</span> <span class="pre">0),</span> <span class="pre">dtype=float64),</span> <span class="pre">B:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">shape=(0,</span> <span class="pre">0),</span> <span class="pre">dtype=float64),</span> <span class="pre">f0:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">dtype=float64),</span> <span class="pre">C:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">shape=(0,</span> <span class="pre">0),</span> <span class="pre">dtype=float64),</span> <span class="pre">D:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">shape=(0,</span> <span class="pre">0),</span> <span class="pre">dtype=float64),</span> <span class="pre">y0:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">dtype=float64),</span> <span class="pre">time_period:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0.0)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs an Affine system with a fixed set of coefficient matrices
<code class="docutils literal notranslate"><span class="pre">A</span></code>, <cite>B</cite>,``C``, and <code class="docutils literal notranslate"><span class="pre">D</span></code> as well as fixed initial velocity offset
<code class="docutils literal notranslate"><span class="pre">xDot0</span></code> and output offset <code class="docutils literal notranslate"><span class="pre">y0</span></code>. The coefficient matrices must obey
the following dimensions : | Matrix | Num Rows | Num Columns |
<a href="#id7"><span class="problematic" id="id8">|:-------:|</span></a>:———–:<a href="#id9"><span class="problematic" id="id10">|:-----------:|</span></a> | A | num states | num states
| | B | num states | num inputs | | f0 | num_states | 1 | | C | num
outputs | num states | | D | num outputs | num inputs | | y0 |
num_outputs | 1 |</p>
<p>Empty matrices are treated as zero matrices with the appropriate
number of rows and columns.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time_period</span></code>:</dt><dd><p>Defines the period of the discrete time system; use
time_period=0.0 to denote a continuous time system. $*Default:*
0.0</p>
</dd>
</dl>
<p>Subclasses must use the protected constructor, not this one.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem.A(self:</span> <span class="pre">pydrake.systems.primitives.AffineSystem)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>&#64;name Helper getter methods.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem.B(self:</span> <span class="pre">pydrake.systems.primitives.AffineSystem)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem.C(self:</span> <span class="pre">pydrake.systems.primitives.AffineSystem)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem.configure_default_state(self:</span> <span class="pre">pydrake.systems.primitives.AffineSystem,</span> <span class="pre">x0:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Configures the value that will be assigned to the state vector in
<code class="docutils literal notranslate"><span class="pre">SetDefaultContext</span></code>. <cite>x0</cite> must be a vector of length <code class="docutils literal notranslate"><span class="pre">num_states</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem.configure_random_state(self:</span> <span class="pre">pydrake.systems.primitives.AffineSystem,</span> <span class="pre">covariance:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Configures the Gaussian distribution over state vectors used in the
<code class="docutils literal notranslate"><span class="pre">SetRandomContext</span></code> methods. The mean of the distribution will be the
default state (</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>configure_default_state()). <code class="docutils literal notranslate"><span class="pre">covariance</span></code> must have size
<code class="docutils literal notranslate"><span class="pre">num_states</span></code> by <code class="docutils literal notranslate"><span class="pre">num_states</span></code> and must be symmetric and
positive semi-definite.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem.D(self:</span> <span class="pre">pydrake.systems.primitives.AffineSystem)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem.f0(self:</span> <span class="pre">pydrake.systems.primitives.AffineSystem)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem.num_inputs(self:</span> <span class="pre">pydrake.systems.primitives.AffineSystem)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem.num_outputs(self:</span> <span class="pre">pydrake.systems.primitives.AffineSystem)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem.num_states(self:</span> <span class="pre">pydrake.systems.primitives.AffineSystem)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem.time_period(self:</span> <span class="pre">pydrake.systems.primitives.AffineSystem)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem.UpdateCoefficients(self:</span> <span class="pre">pydrake.systems.primitives.AffineSystem,</span> <span class="pre">A:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">shape=(0,</span> <span class="pre">0),</span> <span class="pre">dtype=float64),</span> <span class="pre">B:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">shape=(0,</span> <span class="pre">0),</span> <span class="pre">dtype=float64),</span> <span class="pre">f0:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">dtype=float64),</span> <span class="pre">C:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">shape=(0,</span> <span class="pre">0),</span> <span class="pre">dtype=float64),</span> <span class="pre">D:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">shape=(0,</span> <span class="pre">0),</span> <span class="pre">dtype=float64),</span> <span class="pre">y0:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">dtype=float64))</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Updates the coefficients of the affine system. The new coefficients
must have the same size as existing coefficients.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem.y0(self:</span> <span class="pre">pydrake.systems.primitives.AffineSystem)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">AffineSystem_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">AffineSystem_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">AffineSystem_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></code></p>
<p>A discrete OR continuous affine system (with constant coefficients).</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>AffineSystem</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><p>Let <code class="docutils literal notranslate"><span class="pre">u</span></code> denote the input vector, <code class="docutils literal notranslate"><span class="pre">x</span></code> denote the state vector, and
<code class="docutils literal notranslate"><span class="pre">y</span></code> denote the output vector.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">time_period</span> <span class="pre">&gt;</span> <span class="pre">0.0</span></code>, the affine system will have the following
discrete-time state update:</p>
<div class="math notranslate nohighlight">
\[x(t+h) = A x(t) + B u(t) + f_0,\]</div>
<p>where <code class="docutils literal notranslate"><span class="pre">h</span></code> is the time_period. If <code class="docutils literal notranslate"><span class="pre">time_period</span> <span class="pre">==</span> <span class="pre">0.0</span></code>, the affine
system will have the following continuous-time state update:</p>
<div class="math notranslate nohighlight">
\[\dot{x} = A x + B u + f_0.\]</div>
<p>In both cases, the system will have the output:</p>
<div class="math notranslate nohighlight">
\[y = C x + D u + y_0,\]</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>LinearSystem</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MatrixGain</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.systems.primitives.AffineSystem_[AutoDiffXd],</span> <span class="pre">A:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">shape=(0,</span> <span class="pre">0),</span> <span class="pre">dtype=float64),</span> <span class="pre">B:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">shape=(0,</span> <span class="pre">0),</span> <span class="pre">dtype=float64),</span> <span class="pre">f0:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">dtype=float64),</span> <span class="pre">C:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">shape=(0,</span> <span class="pre">0),</span> <span class="pre">dtype=float64),</span> <span class="pre">D:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">shape=(0,</span> <span class="pre">0),</span> <span class="pre">dtype=float64),</span> <span class="pre">y0:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">dtype=float64),</span> <span class="pre">time_period:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0.0)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs an Affine system with a fixed set of coefficient matrices
<code class="docutils literal notranslate"><span class="pre">A</span></code>, <cite>B</cite>,``C``, and <code class="docutils literal notranslate"><span class="pre">D</span></code> as well as fixed initial velocity offset
<code class="docutils literal notranslate"><span class="pre">xDot0</span></code> and output offset <code class="docutils literal notranslate"><span class="pre">y0</span></code>. The coefficient matrices must obey
the following dimensions : | Matrix | Num Rows | Num Columns |
<a href="#id11"><span class="problematic" id="id12">|:-------:|</span></a>:———–:<a href="#id13"><span class="problematic" id="id14">|:-----------:|</span></a> | A | num states | num states
| | B | num states | num inputs | | f0 | num_states | 1 | | C | num
outputs | num states | | D | num outputs | num inputs | | y0 |
num_outputs | 1 |</p>
<p>Empty matrices are treated as zero matrices with the appropriate
number of rows and columns.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time_period</span></code>:</dt><dd><p>Defines the period of the discrete time system; use
time_period=0.0 to denote a continuous time system. $*Default:*
0.0</p>
</dd>
</dl>
<p>Subclasses must use the protected constructor, not this one.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem_[AutoDiffXd].A(self:</span> <span class="pre">pydrake.systems.primitives.AffineSystem_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>&#64;name Helper getter methods.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem_[AutoDiffXd].B(self:</span> <span class="pre">pydrake.systems.primitives.AffineSystem_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem_[AutoDiffXd].C(self:</span> <span class="pre">pydrake.systems.primitives.AffineSystem_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem_[AutoDiffXd].configure_default_state(self:</span> <span class="pre">pydrake.systems.primitives.AffineSystem_[AutoDiffXd],</span> <span class="pre">x0:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Configures the value that will be assigned to the state vector in
<code class="docutils literal notranslate"><span class="pre">SetDefaultContext</span></code>. <cite>x0</cite> must be a vector of length <code class="docutils literal notranslate"><span class="pre">num_states</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem_[AutoDiffXd].configure_random_state(self:</span> <span class="pre">pydrake.systems.primitives.AffineSystem_[AutoDiffXd],</span> <span class="pre">covariance:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Configures the Gaussian distribution over state vectors used in the
<code class="docutils literal notranslate"><span class="pre">SetRandomContext</span></code> methods. The mean of the distribution will be the
default state (</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>configure_default_state()). <code class="docutils literal notranslate"><span class="pre">covariance</span></code> must have size
<code class="docutils literal notranslate"><span class="pre">num_states</span></code> by <code class="docutils literal notranslate"><span class="pre">num_states</span></code> and must be symmetric and
positive semi-definite.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem_[AutoDiffXd].D(self:</span> <span class="pre">pydrake.systems.primitives.AffineSystem_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem_[AutoDiffXd].f0(self:</span> <span class="pre">pydrake.systems.primitives.AffineSystem_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem_[AutoDiffXd].num_inputs(self:</span> <span class="pre">pydrake.systems.primitives.AffineSystem_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem_[AutoDiffXd].num_outputs(self:</span> <span class="pre">pydrake.systems.primitives.AffineSystem_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem_[AutoDiffXd].num_states(self:</span> <span class="pre">pydrake.systems.primitives.AffineSystem_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem_[AutoDiffXd].time_period(self:</span> <span class="pre">pydrake.systems.primitives.AffineSystem_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem_[AutoDiffXd].UpdateCoefficients(self:</span> <span class="pre">pydrake.systems.primitives.AffineSystem_[AutoDiffXd],</span> <span class="pre">A:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">shape=(0,</span> <span class="pre">0),</span> <span class="pre">dtype=float64),</span> <span class="pre">B:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">shape=(0,</span> <span class="pre">0),</span> <span class="pre">dtype=float64),</span> <span class="pre">f0:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">dtype=float64),</span> <span class="pre">C:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">shape=(0,</span> <span class="pre">0),</span> <span class="pre">dtype=float64),</span> <span class="pre">D:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">shape=(0,</span> <span class="pre">0),</span> <span class="pre">dtype=float64),</span> <span class="pre">y0:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">dtype=float64))</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Updates the coefficients of the affine system. The new coefficients
must have the same size as existing coefficients.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem_[AutoDiffXd].y0(self:</span> <span class="pre">pydrake.systems.primitives.AffineSystem_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[Expression]</span></code></p>
<p>A discrete OR continuous affine system (with constant coefficients).</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>AffineSystem</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><p>Let <code class="docutils literal notranslate"><span class="pre">u</span></code> denote the input vector, <code class="docutils literal notranslate"><span class="pre">x</span></code> denote the state vector, and
<code class="docutils literal notranslate"><span class="pre">y</span></code> denote the output vector.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">time_period</span> <span class="pre">&gt;</span> <span class="pre">0.0</span></code>, the affine system will have the following
discrete-time state update:</p>
<div class="math notranslate nohighlight">
\[x(t+h) = A x(t) + B u(t) + f_0,\]</div>
<p>where <code class="docutils literal notranslate"><span class="pre">h</span></code> is the time_period. If <code class="docutils literal notranslate"><span class="pre">time_period</span> <span class="pre">==</span> <span class="pre">0.0</span></code>, the affine
system will have the following continuous-time state update:</p>
<div class="math notranslate nohighlight">
\[\dot{x} = A x + B u + f_0.\]</div>
<p>In both cases, the system will have the output:</p>
<div class="math notranslate nohighlight">
\[y = C x + D u + y_0,\]</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>LinearSystem</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MatrixGain</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem_[Expression].__init__(self:</span> <span class="pre">pydrake.systems.primitives.AffineSystem_[Expression],</span> <span class="pre">A:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">shape=(0,</span> <span class="pre">0),</span> <span class="pre">dtype=float64),</span> <span class="pre">B:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">shape=(0,</span> <span class="pre">0),</span> <span class="pre">dtype=float64),</span> <span class="pre">f0:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">dtype=float64),</span> <span class="pre">C:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">shape=(0,</span> <span class="pre">0),</span> <span class="pre">dtype=float64),</span> <span class="pre">D:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">shape=(0,</span> <span class="pre">0),</span> <span class="pre">dtype=float64),</span> <span class="pre">y0:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">dtype=float64),</span> <span class="pre">time_period:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0.0)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs an Affine system with a fixed set of coefficient matrices
<code class="docutils literal notranslate"><span class="pre">A</span></code>, <cite>B</cite>,``C``, and <code class="docutils literal notranslate"><span class="pre">D</span></code> as well as fixed initial velocity offset
<code class="docutils literal notranslate"><span class="pre">xDot0</span></code> and output offset <code class="docutils literal notranslate"><span class="pre">y0</span></code>. The coefficient matrices must obey
the following dimensions : | Matrix | Num Rows | Num Columns |
<a href="#id15"><span class="problematic" id="id16">|:-------:|</span></a>:———–:<a href="#id17"><span class="problematic" id="id18">|:-----------:|</span></a> | A | num states | num states
| | B | num states | num inputs | | f0 | num_states | 1 | | C | num
outputs | num states | | D | num outputs | num inputs | | y0 |
num_outputs | 1 |</p>
<p>Empty matrices are treated as zero matrices with the appropriate
number of rows and columns.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time_period</span></code>:</dt><dd><p>Defines the period of the discrete time system; use
time_period=0.0 to denote a continuous time system. $*Default:*
0.0</p>
</dd>
</dl>
<p>Subclasses must use the protected constructor, not this one.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem_[Expression].A(self:</span> <span class="pre">pydrake.systems.primitives.AffineSystem_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>&#64;name Helper getter methods.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem_[Expression].B(self:</span> <span class="pre">pydrake.systems.primitives.AffineSystem_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem_[Expression].C(self:</span> <span class="pre">pydrake.systems.primitives.AffineSystem_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem_[Expression].configure_default_state(self:</span> <span class="pre">pydrake.systems.primitives.AffineSystem_[Expression],</span> <span class="pre">x0:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Configures the value that will be assigned to the state vector in
<code class="docutils literal notranslate"><span class="pre">SetDefaultContext</span></code>. <cite>x0</cite> must be a vector of length <code class="docutils literal notranslate"><span class="pre">num_states</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem_[Expression].configure_random_state(self:</span> <span class="pre">pydrake.systems.primitives.AffineSystem_[Expression],</span> <span class="pre">covariance:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Configures the Gaussian distribution over state vectors used in the
<code class="docutils literal notranslate"><span class="pre">SetRandomContext</span></code> methods. The mean of the distribution will be the
default state (</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>configure_default_state()). <code class="docutils literal notranslate"><span class="pre">covariance</span></code> must have size
<code class="docutils literal notranslate"><span class="pre">num_states</span></code> by <code class="docutils literal notranslate"><span class="pre">num_states</span></code> and must be symmetric and
positive semi-definite.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem_[Expression].D(self:</span> <span class="pre">pydrake.systems.primitives.AffineSystem_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem_[Expression].f0(self:</span> <span class="pre">pydrake.systems.primitives.AffineSystem_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem_[Expression].num_inputs(self:</span> <span class="pre">pydrake.systems.primitives.AffineSystem_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem_[Expression].num_outputs(self:</span> <span class="pre">pydrake.systems.primitives.AffineSystem_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem_[Expression].num_states(self:</span> <span class="pre">pydrake.systems.primitives.AffineSystem_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem_[Expression].time_period(self:</span> <span class="pre">pydrake.systems.primitives.AffineSystem_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem_[Expression].UpdateCoefficients(self:</span> <span class="pre">pydrake.systems.primitives.AffineSystem_[Expression],</span> <span class="pre">A:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">shape=(0,</span> <span class="pre">0),</span> <span class="pre">dtype=float64),</span> <span class="pre">B:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">shape=(0,</span> <span class="pre">0),</span> <span class="pre">dtype=float64),</span> <span class="pre">f0:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">dtype=float64),</span> <span class="pre">C:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">shape=(0,</span> <span class="pre">0),</span> <span class="pre">dtype=float64),</span> <span class="pre">D:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">shape=(0,</span> <span class="pre">0),</span> <span class="pre">dtype=float64),</span> <span class="pre">y0:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">dtype=float64))</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Updates the coefficients of the affine system. The new coefficients
must have the same size as existing coefficients.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AffineSystem_[Expression].y0(self:</span> <span class="pre">pydrake.systems.primitives.AffineSystem_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BarycentricMeshSystem</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></p>
<p>A (stateless) vector system implemented as a multi-linear
(barycentric) interpolation on a mesh over the inputs.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>BarycentricMeshSystem</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><p>This has many potential uses, including representing the policies that
are generated by numerical control design methods like approximate
dynamic programming.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>math::BarycentricMesh</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BarycentricMeshSystem.__init__(self:</span> <span class="pre">pydrake.systems.primitives.BarycentricMeshSystem,</span> <span class="pre">arg0:</span> <span class="pre">pydrake.math.BarycentricMesh,</span> <span class="pre">arg1:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs the system from a mesh and the associated mesh values.
<code class="docutils literal notranslate"><span class="pre">output_values</span></code> is a matrix with each column representing the value
to output if the input is the associated mesh point. It must have the
same number of columns as mesh.get_num_mesh_points();
mesh.MeshValuesFrom(function) is one useful tool for creating it.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BarycentricMeshSystem.get_mesh(self:</span> <span class="pre">pydrake.systems.primitives.BarycentricMeshSystem)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.BarycentricMesh</span></span></dt>
<dd><p>Returns a reference to the mesh.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BarycentricMeshSystem.get_output_values(self:</span> <span class="pre">pydrake.systems.primitives.BarycentricMeshSystem)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>Returns a reference to the output values.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BusCreator</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></p>
<p>This system packs values from heterogeneous input ports into a single
output port of type BusValue.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">...&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">u(N-1)&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>BusCreator</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><p>The port names shown in the figure above are the defaults. Custom
names may be specified when setting up the BusCreator.</p>
<p>When an input port is not connected, it is not an error; its value
will simply not appear as part of the BusValue on the output port.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>BusSelector, BusValue</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">BusCreator_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BusCreator.__init__(self:</span> <span class="pre">pydrake.systems.primitives.BusCreator,</span> <span class="pre">output_port_name:</span> <span class="pre">Union[str,</span> <span class="pre">pydrake.systems.framework.UseDefaultName]</span> <span class="pre">=</span> <span class="pre">kUseDefaultName)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a BusCreator with no inputs, and the given output port
name. Use DeclareAbstractInputPort() and DeclareVectorInputPort() to
add ports.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BusCreator.DeclareAbstractInputPort(self:</span> <span class="pre">pydrake.systems.primitives.BusCreator,</span> <span class="pre">name:</span> <span class="pre">Union[str,</span> <span class="pre">pydrake.systems.framework.UseDefaultName],</span> <span class="pre">model_value:</span> <span class="pre">pydrake.common.value.AbstractValue)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.InputPort</span></span></dt>
<dd><p>Declares an abstract input port with the given attributes. The port
name will also be used as the name of this signal in the BusValue
output port.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BusCreator.DeclareVectorInputPort(self:</span> <span class="pre">pydrake.systems.primitives.BusCreator,</span> <span class="pre">name:</span> <span class="pre">Union[str,</span> <span class="pre">pydrake.systems.framework.UseDefaultName],</span> <span class="pre">size:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.InputPort</span></span></dt>
<dd><p>Declares a vector input port with the given attributes. The port name
will also be used as the name of this signal in the BusValue output
port. The type of the signal on the output bus will be
<code class="docutils literal notranslate"><span class="pre">BasicVector&lt;T&gt;</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BusCreator_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">BusCreator_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">BusCreator_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">BusCreator_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BusCreator_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></code></p>
<p>This system packs values from heterogeneous input ports into a single
output port of type BusValue.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">...&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">u(N-1)&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>BusCreator</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><p>The port names shown in the figure above are the defaults. Custom
names may be specified when setting up the BusCreator.</p>
<p>When an input port is not connected, it is not an error; its value
will simply not appear as part of the BusValue on the output port.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>BusSelector, BusValue</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BusCreator_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.systems.primitives.BusCreator_[AutoDiffXd],</span> <span class="pre">output_port_name:</span> <span class="pre">Union[str,</span> <span class="pre">pydrake.systems.framework.UseDefaultName]</span> <span class="pre">=</span> <span class="pre">kUseDefaultName)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a BusCreator with no inputs, and the given output port
name. Use DeclareAbstractInputPort() and DeclareVectorInputPort() to
add ports.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BusCreator_[AutoDiffXd].DeclareAbstractInputPort(self:</span> <span class="pre">pydrake.systems.primitives.BusCreator_[AutoDiffXd],</span> <span class="pre">name:</span> <span class="pre">Union[str,</span> <span class="pre">pydrake.systems.framework.UseDefaultName],</span> <span class="pre">model_value:</span> <span class="pre">pydrake.common.value.AbstractValue)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.InputPort_[AutoDiffXd]</span></span></dt>
<dd><p>Declares an abstract input port with the given attributes. The port
name will also be used as the name of this signal in the BusValue
output port.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BusCreator_[AutoDiffXd].DeclareVectorInputPort(self:</span> <span class="pre">pydrake.systems.primitives.BusCreator_[AutoDiffXd],</span> <span class="pre">name:</span> <span class="pre">Union[str,</span> <span class="pre">pydrake.systems.framework.UseDefaultName],</span> <span class="pre">size:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.InputPort_[AutoDiffXd]</span></span></dt>
<dd><p>Declares a vector input port with the given attributes. The port name
will also be used as the name of this signal in the BusValue output
port. The type of the signal on the output bus will be
<code class="docutils literal notranslate"><span class="pre">BasicVector&lt;T&gt;</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BusCreator_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[Expression]</span></code></p>
<p>This system packs values from heterogeneous input ports into a single
output port of type BusValue.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">...&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">u(N-1)&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>BusCreator</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><p>The port names shown in the figure above are the defaults. Custom
names may be specified when setting up the BusCreator.</p>
<p>When an input port is not connected, it is not an error; its value
will simply not appear as part of the BusValue on the output port.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>BusSelector, BusValue</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BusCreator_[Expression].__init__(self:</span> <span class="pre">pydrake.systems.primitives.BusCreator_[Expression],</span> <span class="pre">output_port_name:</span> <span class="pre">Union[str,</span> <span class="pre">pydrake.systems.framework.UseDefaultName]</span> <span class="pre">=</span> <span class="pre">kUseDefaultName)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a BusCreator with no inputs, and the given output port
name. Use DeclareAbstractInputPort() and DeclareVectorInputPort() to
add ports.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BusCreator_[Expression].DeclareAbstractInputPort(self:</span> <span class="pre">pydrake.systems.primitives.BusCreator_[Expression],</span> <span class="pre">name:</span> <span class="pre">Union[str,</span> <span class="pre">pydrake.systems.framework.UseDefaultName],</span> <span class="pre">model_value:</span> <span class="pre">pydrake.common.value.AbstractValue)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.InputPort_[Expression]</span></span></dt>
<dd><p>Declares an abstract input port with the given attributes. The port
name will also be used as the name of this signal in the BusValue
output port.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BusCreator_[Expression].DeclareVectorInputPort(self:</span> <span class="pre">pydrake.systems.primitives.BusCreator_[Expression],</span> <span class="pre">name:</span> <span class="pre">Union[str,</span> <span class="pre">pydrake.systems.framework.UseDefaultName],</span> <span class="pre">size:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.InputPort_[Expression]</span></span></dt>
<dd><p>Declares a vector input port with the given attributes. The port name
will also be used as the name of this signal in the BusValue output
port. The type of the signal on the output bus will be
<code class="docutils literal notranslate"><span class="pre">BasicVector&lt;T&gt;</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BusSelector</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></p>
<p>This system unpacks values from a single input port of type BusValue
onto heterogeneous output ports, where each output port’s value comes
from the same- named signal on the bus.</p>
<p>The value on input port may contain additional bus value entries which
are not selected (because there is no output port with that name);
this is not an error.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>BusSelector</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; ...</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y(N-1)</td></tr></table></td></tr></table><p>The port names shown in the figure above are the defaults. Custom
names may be specified when setting up the BusSelector.</p>
<p>When an output port is evaluated but the input port’s bus doesn’t
contain that signal name, it is an error.</p>
<p>Because of the all-encompassing nature of AbstractValue, a
vector-valued bus signal can be output on an abstract-valued port. Of
course, the vector value can still be retrieved from the
AbstractValue. However, we recommend declaring output ports as
vector-valued when the corresponding input signal is known to be
vector-valued to maximize utility and minimize surprise.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>BusCreator, BusValue</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">BusSelector_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BusSelector.__init__(self:</span> <span class="pre">pydrake.systems.primitives.BusSelector,</span> <span class="pre">input_port_name:</span> <span class="pre">Union[str,</span> <span class="pre">pydrake.systems.framework.UseDefaultName]</span> <span class="pre">=</span> <span class="pre">kUseDefaultName)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a BusSelector with the given input port name, and no
outputs. Use DeclareVectorOutputPort() and DeclareAbstractOutputPort()
to add ports.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BusSelector.DeclareAbstractOutputPort(self:</span> <span class="pre">pydrake.systems.primitives.BusSelector,</span> <span class="pre">name:</span> <span class="pre">Union[str,</span> <span class="pre">pydrake.systems.framework.UseDefaultName],</span> <span class="pre">model_value:</span> <span class="pre">pydrake.common.value.AbstractValue)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.OutputPort</span></span></dt>
<dd><p>Declares an abstract output port with the given attributes. The port
name will also be used as the name of the signal to find in the
BusValue input port.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BusSelector.DeclareVectorOutputPort(self:</span> <span class="pre">pydrake.systems.primitives.BusSelector,</span> <span class="pre">name:</span> <span class="pre">Union[str,</span> <span class="pre">pydrake.systems.framework.UseDefaultName],</span> <span class="pre">size:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.OutputPort</span></span></dt>
<dd><p>Declares a vector output port with the given attributes. The port name
will also be used as the name of the signal to find in the BusValue
input port. The type of the signal on the input bus must be
<code class="docutils literal notranslate"><span class="pre">BasicVector&lt;T&gt;</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BusSelector_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">BusSelector_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">BusSelector_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">BusSelector_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BusSelector_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></code></p>
<p>This system unpacks values from a single input port of type BusValue
onto heterogeneous output ports, where each output port’s value comes
from the same- named signal on the bus.</p>
<p>The value on input port may contain additional bus value entries which
are not selected (because there is no output port with that name);
this is not an error.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>BusSelector</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; ...</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y(N-1)</td></tr></table></td></tr></table><p>The port names shown in the figure above are the defaults. Custom
names may be specified when setting up the BusSelector.</p>
<p>When an output port is evaluated but the input port’s bus doesn’t
contain that signal name, it is an error.</p>
<p>Because of the all-encompassing nature of AbstractValue, a
vector-valued bus signal can be output on an abstract-valued port. Of
course, the vector value can still be retrieved from the
AbstractValue. However, we recommend declaring output ports as
vector-valued when the corresponding input signal is known to be
vector-valued to maximize utility and minimize surprise.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>BusCreator, BusValue</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BusSelector_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.systems.primitives.BusSelector_[AutoDiffXd],</span> <span class="pre">input_port_name:</span> <span class="pre">Union[str,</span> <span class="pre">pydrake.systems.framework.UseDefaultName]</span> <span class="pre">=</span> <span class="pre">kUseDefaultName)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a BusSelector with the given input port name, and no
outputs. Use DeclareVectorOutputPort() and DeclareAbstractOutputPort()
to add ports.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BusSelector_[AutoDiffXd].DeclareAbstractOutputPort(self:</span> <span class="pre">pydrake.systems.primitives.BusSelector_[AutoDiffXd],</span> <span class="pre">name:</span> <span class="pre">Union[str,</span> <span class="pre">pydrake.systems.framework.UseDefaultName],</span> <span class="pre">model_value:</span> <span class="pre">pydrake.common.value.AbstractValue)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.OutputPort_[AutoDiffXd]</span></span></dt>
<dd><p>Declares an abstract output port with the given attributes. The port
name will also be used as the name of the signal to find in the
BusValue input port.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BusSelector_[AutoDiffXd].DeclareVectorOutputPort(self:</span> <span class="pre">pydrake.systems.primitives.BusSelector_[AutoDiffXd],</span> <span class="pre">name:</span> <span class="pre">Union[str,</span> <span class="pre">pydrake.systems.framework.UseDefaultName],</span> <span class="pre">size:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.OutputPort_[AutoDiffXd]</span></span></dt>
<dd><p>Declares a vector output port with the given attributes. The port name
will also be used as the name of the signal to find in the BusValue
input port. The type of the signal on the input bus must be
<code class="docutils literal notranslate"><span class="pre">BasicVector&lt;T&gt;</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BusSelector_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[Expression]</span></code></p>
<p>This system unpacks values from a single input port of type BusValue
onto heterogeneous output ports, where each output port’s value comes
from the same- named signal on the bus.</p>
<p>The value on input port may contain additional bus value entries which
are not selected (because there is no output port with that name);
this is not an error.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>BusSelector</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; ...</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y(N-1)</td></tr></table></td></tr></table><p>The port names shown in the figure above are the defaults. Custom
names may be specified when setting up the BusSelector.</p>
<p>When an output port is evaluated but the input port’s bus doesn’t
contain that signal name, it is an error.</p>
<p>Because of the all-encompassing nature of AbstractValue, a
vector-valued bus signal can be output on an abstract-valued port. Of
course, the vector value can still be retrieved from the
AbstractValue. However, we recommend declaring output ports as
vector-valued when the corresponding input signal is known to be
vector-valued to maximize utility and minimize surprise.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>BusCreator, BusValue</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BusSelector_[Expression].__init__(self:</span> <span class="pre">pydrake.systems.primitives.BusSelector_[Expression],</span> <span class="pre">input_port_name:</span> <span class="pre">Union[str,</span> <span class="pre">pydrake.systems.framework.UseDefaultName]</span> <span class="pre">=</span> <span class="pre">kUseDefaultName)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a BusSelector with the given input port name, and no
outputs. Use DeclareVectorOutputPort() and DeclareAbstractOutputPort()
to add ports.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BusSelector_[Expression].DeclareAbstractOutputPort(self:</span> <span class="pre">pydrake.systems.primitives.BusSelector_[Expression],</span> <span class="pre">name:</span> <span class="pre">Union[str,</span> <span class="pre">pydrake.systems.framework.UseDefaultName],</span> <span class="pre">model_value:</span> <span class="pre">pydrake.common.value.AbstractValue)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.OutputPort_[Expression]</span></span></dt>
<dd><p>Declares an abstract output port with the given attributes. The port
name will also be used as the name of the signal to find in the
BusValue input port.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BusSelector_[Expression].DeclareVectorOutputPort(self:</span> <span class="pre">pydrake.systems.primitives.BusSelector_[Expression],</span> <span class="pre">name:</span> <span class="pre">Union[str,</span> <span class="pre">pydrake.systems.framework.UseDefaultName],</span> <span class="pre">size:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.OutputPort_[Expression]</span></span></dt>
<dd><p>Declares a vector output port with the given attributes. The port name
will also be used as the name of the signal to find in the BusValue
input port. The type of the signal on the input bus must be
<code class="docutils literal notranslate"><span class="pre">BasicVector&lt;T&gt;</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConstantValueSource</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></p>
<p>A source block that always outputs a constant value.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>ConstantValueSource</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">ConstantValueSource_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConstantValueSource.__init__(self:</span> <span class="pre">pydrake.systems.primitives.ConstantValueSource,</span> <span class="pre">value:</span> <span class="pre">pydrake.common.value.AbstractValue)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">value</span></code>:</dt><dd><p>The constant value to emit, which is copied by this system.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConstantValueSource_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">ConstantValueSource_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ConstantValueSource_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ConstantValueSource_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConstantValueSource_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></code></p>
<p>A source block that always outputs a constant value.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>ConstantValueSource</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConstantValueSource_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.systems.primitives.ConstantValueSource_[AutoDiffXd],</span> <span class="pre">value:</span> <span class="pre">pydrake.common.value.AbstractValue)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">value</span></code>:</dt><dd><p>The constant value to emit, which is copied by this system.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConstantValueSource_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[Expression]</span></code></p>
<p>A source block that always outputs a constant value.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>ConstantValueSource</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConstantValueSource_[Expression].__init__(self:</span> <span class="pre">pydrake.systems.primitives.ConstantValueSource_[Expression],</span> <span class="pre">value:</span> <span class="pre">pydrake.common.value.AbstractValue)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">value</span></code>:</dt><dd><p>The constant value to emit, which is copied by this system.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConstantVectorSource</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></p>
<p>A source block with a constant output port at all times. The value of
the output port is a parameter of the system (see Parameters).</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>ConstantVectorSource</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">ConstantVectorSource_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConstantVectorSource.__init__(self:</span> <span class="pre">pydrake.systems.primitives.ConstantVectorSource,</span> <span class="pre">source_value:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a system with a vector output that is constant and equals
the supplied <code class="docutils literal notranslate"><span class="pre">source_value</span></code> at all times.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">source_value</span></code>:</dt><dd><p>the constant value of the output so that <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">source_value</span></code> at
all times.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConstantVectorSource.get_mutable_source_value(self:</span> <span class="pre">pydrake.systems.primitives.ConstantVectorSource,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.BasicVector</span></span></dt>
<dd><p>Return a mutable reference to the source value of this block in the
given <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConstantVectorSource.get_source_value(self:</span> <span class="pre">pydrake.systems.primitives.ConstantVectorSource,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.BasicVector</span></span></dt>
<dd><p>Return a read-only reference to the source value of this block in the
given <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConstantVectorSource_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">ConstantVectorSource_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ConstantVectorSource_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ConstantVectorSource_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConstantVectorSource_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></code></p>
<p>A source block with a constant output port at all times. The value of
the output port is a parameter of the system (see Parameters).</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>ConstantVectorSource</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConstantVectorSource_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.systems.primitives.ConstantVectorSource_[AutoDiffXd],</span> <span class="pre">source_value:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a system with a vector output that is constant and equals
the supplied <code class="docutils literal notranslate"><span class="pre">source_value</span></code> at all times.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">source_value</span></code>:</dt><dd><p>the constant value of the output so that <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">source_value</span></code> at
all times.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConstantVectorSource_[AutoDiffXd].get_mutable_source_value(self:</span> <span class="pre">pydrake.systems.primitives.ConstantVectorSource_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.BasicVector_[AutoDiffXd]</span></span></dt>
<dd><p>Return a mutable reference to the source value of this block in the
given <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConstantVectorSource_[AutoDiffXd].get_source_value(self:</span> <span class="pre">pydrake.systems.primitives.ConstantVectorSource_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.BasicVector_[AutoDiffXd]</span></span></dt>
<dd><p>Return a read-only reference to the source value of this block in the
given <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConstantVectorSource_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[Expression]</span></code></p>
<p>A source block with a constant output port at all times. The value of
the output port is a parameter of the system (see Parameters).</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>ConstantVectorSource</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConstantVectorSource_[Expression].__init__(self:</span> <span class="pre">pydrake.systems.primitives.ConstantVectorSource_[Expression],</span> <span class="pre">source_value:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a system with a vector output that is constant and equals
the supplied <code class="docutils literal notranslate"><span class="pre">source_value</span></code> at all times.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">source_value</span></code>:</dt><dd><p>the constant value of the output so that <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">source_value</span></code> at
all times.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConstantVectorSource_[Expression].get_mutable_source_value(self:</span> <span class="pre">pydrake.systems.primitives.ConstantVectorSource_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.BasicVector_[Expression]</span></span></dt>
<dd><p>Return a mutable reference to the source value of this block in the
given <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ConstantVectorSource_[Expression].get_source_value(self:</span> <span class="pre">pydrake.systems.primitives.ConstantVectorSource_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.BasicVector_[Expression]</span></span></dt>
<dd><p>Return a read-only reference to the source value of this block in the
given <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ControllabilityMatrix(arg0:</span> <span class="pre">pydrake.systems.primitives.LinearSystem)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>Returns the controllability matrix: R = [B, AB, …, A^{n-1}B].</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Demultiplexer</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></p>
<p>This system splits a vector valued signal on its input into multiple
outputs.</p>
<p>The input to this system directly feeds through to its output.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Demultiplexer</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; ...</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y(N-1)</td></tr></table></td></tr></table><div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">Demultiplexer_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Demultiplexer.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.primitives.Demultiplexer, size: int, output_ports_size: int = 1) -&gt; None</p></li>
</ol>
<p>Constructs Demultiplexer with one vector valued input port of size
<code class="docutils literal notranslate"><span class="pre">size</span></code> and vector valued output ports of size <code class="docutils literal notranslate"><span class="pre">output_ports_size</span></code>.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Demultiplexer</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; ...</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y((size / output_ports_size) - 1)</td></tr></table></td></tr></table><dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if output_ports_sizes can not exactly divide</strong> – </p>
</dd>
</dl>
<p>:raises <cite>size`</cite>. The number of output ports is therefore <code class="docutils literal notranslate"><span class="pre">size</span> <span class="pre">:</span>
<span class="pre">:raises</span> <span class="pre">output_ports_size</span></code>.:</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">size</span></code>:</dt><dd><p>is the size of the input signal to be demultiplexed into its
individual components.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">output_ports_size</span></code>:</dt><dd><p>The size of the output ports. <code class="docutils literal notranslate"><span class="pre">size</span></code> must be a multiple of
<code class="docutils literal notranslate"><span class="pre">output_ports_size</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.primitives.Demultiplexer, output_ports_sizes: list[int]) -&gt; None</p></li>
</ol>
<p>Constructs Demultiplexer with one vector valued output ports with
sizes specified as the vector <code class="docutils literal notranslate"><span class="pre">output_ports_sizes</span></code>. The number of
output ports is the length of this vector. The size of each output
port is the value of the corresponding element of the vector
<code class="docutils literal notranslate"><span class="pre">output_ports_sizes</span></code>.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Demultiplexer</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; ...</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y(output_ports_sizes.size() - 1)</td></tr></table></td></tr></table><dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if output_ports_sizes is a zero length vector.</strong> – </p></li>
<li><p><strong>RuntimeError if any element</strong><strong> of </strong><strong>the output_ports_sizes is zero.</strong> – </p></li>
<li><p><strong>Therefore</strong><strong>, </strong><strong>the Demultiplexer does not allow zero size output</strong> – </p></li>
<li><p><strong>ports.</strong> – </p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">output_ports_sizes</span></code>:</dt><dd><p>Contains the sizes of each output port. The number of output ports
is determined by the length of <code class="docutils literal notranslate"><span class="pre">output_ports_sizes</span></code>. The
accumulative value of the all the values in <code class="docutils literal notranslate"><span class="pre">output_ports_sizes</span></code>
will be the size of the input port.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Demultiplexer.get_output_ports_sizes(self:</span> <span class="pre">pydrake.systems.primitives.Demultiplexer)</span> <span class="pre">-&gt;</span> <span class="pre">list[int]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Demultiplexer_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">Demultiplexer_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Demultiplexer_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Demultiplexer_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Demultiplexer_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></code></p>
<p>This system splits a vector valued signal on its input into multiple
outputs.</p>
<p>The input to this system directly feeds through to its output.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Demultiplexer</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; ...</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y(N-1)</td></tr></table></td></tr></table><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Demultiplexer_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.primitives.Demultiplexer_[AutoDiffXd], size: int, output_ports_size: int = 1) -&gt; None</p></li>
</ol>
<p>Constructs Demultiplexer with one vector valued input port of size
<code class="docutils literal notranslate"><span class="pre">size</span></code> and vector valued output ports of size <code class="docutils literal notranslate"><span class="pre">output_ports_size</span></code>.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Demultiplexer</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; ...</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y((size / output_ports_size) - 1)</td></tr></table></td></tr></table><dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if output_ports_sizes can not exactly divide</strong> – </p>
</dd>
</dl>
<p>:raises <cite>size`</cite>. The number of output ports is therefore <code class="docutils literal notranslate"><span class="pre">size</span> <span class="pre">:</span>
<span class="pre">:raises</span> <span class="pre">output_ports_size</span></code>.:</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">size</span></code>:</dt><dd><p>is the size of the input signal to be demultiplexed into its
individual components.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">output_ports_size</span></code>:</dt><dd><p>The size of the output ports. <code class="docutils literal notranslate"><span class="pre">size</span></code> must be a multiple of
<code class="docutils literal notranslate"><span class="pre">output_ports_size</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.primitives.Demultiplexer_[AutoDiffXd], output_ports_sizes: list[int]) -&gt; None</p></li>
</ol>
<p>Constructs Demultiplexer with one vector valued output ports with
sizes specified as the vector <code class="docutils literal notranslate"><span class="pre">output_ports_sizes</span></code>. The number of
output ports is the length of this vector. The size of each output
port is the value of the corresponding element of the vector
<code class="docutils literal notranslate"><span class="pre">output_ports_sizes</span></code>.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Demultiplexer</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; ...</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y(output_ports_sizes.size() - 1)</td></tr></table></td></tr></table><dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if output_ports_sizes is a zero length vector.</strong> – </p></li>
<li><p><strong>RuntimeError if any element</strong><strong> of </strong><strong>the output_ports_sizes is zero.</strong> – </p></li>
<li><p><strong>Therefore</strong><strong>, </strong><strong>the Demultiplexer does not allow zero size output</strong> – </p></li>
<li><p><strong>ports.</strong> – </p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">output_ports_sizes</span></code>:</dt><dd><p>Contains the sizes of each output port. The number of output ports
is determined by the length of <code class="docutils literal notranslate"><span class="pre">output_ports_sizes</span></code>. The
accumulative value of the all the values in <code class="docutils literal notranslate"><span class="pre">output_ports_sizes</span></code>
will be the size of the input port.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Demultiplexer_[AutoDiffXd].get_output_ports_sizes(self:</span> <span class="pre">pydrake.systems.primitives.Demultiplexer_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">list[int]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Demultiplexer_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[Expression]</span></code></p>
<p>This system splits a vector valued signal on its input into multiple
outputs.</p>
<p>The input to this system directly feeds through to its output.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Demultiplexer</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; ...</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y(N-1)</td></tr></table></td></tr></table><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Demultiplexer_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.primitives.Demultiplexer_[Expression], size: int, output_ports_size: int = 1) -&gt; None</p></li>
</ol>
<p>Constructs Demultiplexer with one vector valued input port of size
<code class="docutils literal notranslate"><span class="pre">size</span></code> and vector valued output ports of size <code class="docutils literal notranslate"><span class="pre">output_ports_size</span></code>.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Demultiplexer</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; ...</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y((size / output_ports_size) - 1)</td></tr></table></td></tr></table><dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if output_ports_sizes can not exactly divide</strong> – </p>
</dd>
</dl>
<p>:raises <cite>size`</cite>. The number of output ports is therefore <code class="docutils literal notranslate"><span class="pre">size</span> <span class="pre">:</span>
<span class="pre">:raises</span> <span class="pre">output_ports_size</span></code>.:</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">size</span></code>:</dt><dd><p>is the size of the input signal to be demultiplexed into its
individual components.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">output_ports_size</span></code>:</dt><dd><p>The size of the output ports. <code class="docutils literal notranslate"><span class="pre">size</span></code> must be a multiple of
<code class="docutils literal notranslate"><span class="pre">output_ports_size</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.primitives.Demultiplexer_[Expression], output_ports_sizes: list[int]) -&gt; None</p></li>
</ol>
<p>Constructs Demultiplexer with one vector valued output ports with
sizes specified as the vector <code class="docutils literal notranslate"><span class="pre">output_ports_sizes</span></code>. The number of
output ports is the length of this vector. The size of each output
port is the value of the corresponding element of the vector
<code class="docutils literal notranslate"><span class="pre">output_ports_sizes</span></code>.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Demultiplexer</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; ...</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y(output_ports_sizes.size() - 1)</td></tr></table></td></tr></table><dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if output_ports_sizes is a zero length vector.</strong> – </p></li>
<li><p><strong>RuntimeError if any element</strong><strong> of </strong><strong>the output_ports_sizes is zero.</strong> – </p></li>
<li><p><strong>Therefore</strong><strong>, </strong><strong>the Demultiplexer does not allow zero size output</strong> – </p></li>
<li><p><strong>ports.</strong> – </p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">output_ports_sizes</span></code>:</dt><dd><p>Contains the sizes of each output port. The number of output ports
is determined by the length of <code class="docutils literal notranslate"><span class="pre">output_ports_sizes</span></code>. The
accumulative value of the all the values in <code class="docutils literal notranslate"><span class="pre">output_ports_sizes</span></code>
will be the size of the input port.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Demultiplexer_[Expression].get_output_ports_sizes(self:</span> <span class="pre">pydrake.systems.primitives.Demultiplexer_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">list[int]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteDerivative</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></p>
<p>System that outputs the discrete-time derivative of its input: y(t) =
(u[n] - u[n-1])/h, where n = floor(t/h), where h is the time period.</p>
<p>This is implemented as the linear system</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">x₀</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
<span class="w">  </span><span class="n">x₁</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x₀</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
<span class="w">  </span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">x₀</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">-</span><span class="n">x₁</span><span class="p">[</span><span class="n">n</span><span class="p">])</span><span class="o">/</span><span class="n">h</span><span class="p">.</span>
<span class="w">  </span><span class="n">x₀</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">x₁</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">initialized</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">Context</span><span class="w"> </span><span class="p">(</span><span class="k">default</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">zeros</span><span class="p">).</span>
</pre></div>
</div>
</details><p>Alternatively, when <code class="docutils literal notranslate"><span class="pre">suppress_initial_transient</span> <span class="pre">=</span> <span class="pre">true</span></code> is passed to
the constructor, the output remains zero until u[n] has been sampled
twice.</p>
<p>This is implemented as the non-linear system</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">x₀</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
<span class="w">  </span><span class="n">x₁</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x₀</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
<span class="w">  </span><span class="n">x₂</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x₂</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">  </span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">0.0</span><span class="w">              </span><span class="k">if</span><span class="w"> </span><span class="n">x₂</span><span class="w"> </span><span class="o">&lt;</span><span class="w">  </span><span class="mi">2</span><span class="w"> </span><span class="p">}</span>
<span class="w">         </span><span class="p">{</span><span class="w"> </span><span class="p">(</span><span class="n">x₀</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">-</span><span class="n">x₁</span><span class="p">[</span><span class="n">n</span><span class="p">])</span><span class="o">/</span><span class="n">h</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">x₂</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="n">x₀</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">x₁</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">x₂</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">initialized</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">Context</span><span class="w"> </span><span class="p">(</span><span class="k">default</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">zeros</span><span class="p">).</span>
</pre></div>
</div>
</details><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calling set_input_history() effectively disables the transient
suppression by setting x_2 = 2.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For dynamical systems, a derivative should not be computed in
continuous-time, i.e. <code class="docutils literal notranslate"><span class="pre">y(t)</span> <span class="pre">=</span> <span class="pre">(u(t)</span> <span class="pre">-</span> <span class="pre">u[n])/(t-n*h)</span></code>. This is
numerically unstable since the time interval <code class="docutils literal notranslate"><span class="pre">t-n*h</span></code> could be
arbitrarily close to zero. Prefer the discrete-time implementation
for robustness.</p>
</div>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>DiscreteDerivative</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; dudt</td></tr></table></td></tr></table><div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">DiscreteDerivative_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteDerivative.__init__(self:</span> <span class="pre">pydrake.systems.primitives.DiscreteDerivative,</span> <span class="pre">num_inputs:</span> <span class="pre">int,</span> <span class="pre">time_step:</span> <span class="pre">float,</span> <span class="pre">suppress_initial_transient:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">True)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructor taking <code class="docutils literal notranslate"><span class="pre">num_inputs</span></code>, the size of the vector to be
differentiated, and <code class="docutils literal notranslate"><span class="pre">time_step</span></code>, the sampling interval. If
<code class="docutils literal notranslate"><span class="pre">suppress_initial_transient</span></code> is true (the default), then the output
will be zero for the first two time steps (see the class documentation
for details and exceptions).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteDerivative.suppress_initial_transient(self:</span> <span class="pre">pydrake.systems.primitives.DiscreteDerivative)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns the <code class="docutils literal notranslate"><span class="pre">suppress_initial_transient</span></code> passed to the constructor.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteDerivative.time_step(self:</span> <span class="pre">pydrake.systems.primitives.DiscreteDerivative)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteDerivative_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">DiscreteDerivative_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">DiscreteDerivative_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">DiscreteDerivative_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteDerivative_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></code></p>
<p>System that outputs the discrete-time derivative of its input: y(t) =
(u[n] - u[n-1])/h, where n = floor(t/h), where h is the time period.</p>
<p>This is implemented as the linear system</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">x₀</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
<span class="w">  </span><span class="n">x₁</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x₀</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
<span class="w">  </span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">x₀</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">-</span><span class="n">x₁</span><span class="p">[</span><span class="n">n</span><span class="p">])</span><span class="o">/</span><span class="n">h</span><span class="p">.</span>
<span class="w">  </span><span class="n">x₀</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">x₁</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">initialized</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">Context</span><span class="w"> </span><span class="p">(</span><span class="k">default</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">zeros</span><span class="p">).</span>
</pre></div>
</div>
</details><p>Alternatively, when <code class="docutils literal notranslate"><span class="pre">suppress_initial_transient</span> <span class="pre">=</span> <span class="pre">true</span></code> is passed to
the constructor, the output remains zero until u[n] has been sampled
twice.</p>
<p>This is implemented as the non-linear system</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">x₀</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
<span class="w">  </span><span class="n">x₁</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x₀</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
<span class="w">  </span><span class="n">x₂</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x₂</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">  </span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">0.0</span><span class="w">              </span><span class="k">if</span><span class="w"> </span><span class="n">x₂</span><span class="w"> </span><span class="o">&lt;</span><span class="w">  </span><span class="mi">2</span><span class="w"> </span><span class="p">}</span>
<span class="w">         </span><span class="p">{</span><span class="w"> </span><span class="p">(</span><span class="n">x₀</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">-</span><span class="n">x₁</span><span class="p">[</span><span class="n">n</span><span class="p">])</span><span class="o">/</span><span class="n">h</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">x₂</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="n">x₀</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">x₁</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">x₂</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">initialized</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">Context</span><span class="w"> </span><span class="p">(</span><span class="k">default</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">zeros</span><span class="p">).</span>
</pre></div>
</div>
</details><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calling set_input_history() effectively disables the transient
suppression by setting x_2 = 2.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For dynamical systems, a derivative should not be computed in
continuous-time, i.e. <code class="docutils literal notranslate"><span class="pre">y(t)</span> <span class="pre">=</span> <span class="pre">(u(t)</span> <span class="pre">-</span> <span class="pre">u[n])/(t-n*h)</span></code>. This is
numerically unstable since the time interval <code class="docutils literal notranslate"><span class="pre">t-n*h</span></code> could be
arbitrarily close to zero. Prefer the discrete-time implementation
for robustness.</p>
</div>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>DiscreteDerivative</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; dudt</td></tr></table></td></tr></table><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteDerivative_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.systems.primitives.DiscreteDerivative_[AutoDiffXd],</span> <span class="pre">num_inputs:</span> <span class="pre">int,</span> <span class="pre">time_step:</span> <span class="pre">float,</span> <span class="pre">suppress_initial_transient:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">True)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructor taking <code class="docutils literal notranslate"><span class="pre">num_inputs</span></code>, the size of the vector to be
differentiated, and <code class="docutils literal notranslate"><span class="pre">time_step</span></code>, the sampling interval. If
<code class="docutils literal notranslate"><span class="pre">suppress_initial_transient</span></code> is true (the default), then the output
will be zero for the first two time steps (see the class documentation
for details and exceptions).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteDerivative_[AutoDiffXd].suppress_initial_transient(self:</span> <span class="pre">pydrake.systems.primitives.DiscreteDerivative_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns the <code class="docutils literal notranslate"><span class="pre">suppress_initial_transient</span></code> passed to the constructor.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteDerivative_[AutoDiffXd].time_step(self:</span> <span class="pre">pydrake.systems.primitives.DiscreteDerivative_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteDerivative_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[Expression]</span></code></p>
<p>System that outputs the discrete-time derivative of its input: y(t) =
(u[n] - u[n-1])/h, where n = floor(t/h), where h is the time period.</p>
<p>This is implemented as the linear system</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">x₀</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
<span class="w">  </span><span class="n">x₁</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x₀</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
<span class="w">  </span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">x₀</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">-</span><span class="n">x₁</span><span class="p">[</span><span class="n">n</span><span class="p">])</span><span class="o">/</span><span class="n">h</span><span class="p">.</span>
<span class="w">  </span><span class="n">x₀</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">x₁</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">initialized</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">Context</span><span class="w"> </span><span class="p">(</span><span class="k">default</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">zeros</span><span class="p">).</span>
</pre></div>
</div>
</details><p>Alternatively, when <code class="docutils literal notranslate"><span class="pre">suppress_initial_transient</span> <span class="pre">=</span> <span class="pre">true</span></code> is passed to
the constructor, the output remains zero until u[n] has been sampled
twice.</p>
<p>This is implemented as the non-linear system</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">x₀</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">u</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
<span class="w">  </span><span class="n">x₁</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x₀</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
<span class="w">  </span><span class="n">x₂</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x₂</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">  </span><span class="n">y</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">0.0</span><span class="w">              </span><span class="k">if</span><span class="w"> </span><span class="n">x₂</span><span class="w"> </span><span class="o">&lt;</span><span class="w">  </span><span class="mi">2</span><span class="w"> </span><span class="p">}</span>
<span class="w">         </span><span class="p">{</span><span class="w"> </span><span class="p">(</span><span class="n">x₀</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">-</span><span class="n">x₁</span><span class="p">[</span><span class="n">n</span><span class="p">])</span><span class="o">/</span><span class="n">h</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">x₂</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">}</span>
<span class="w">  </span><span class="n">x₀</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">x₁</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">x₂</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">initialized</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">Context</span><span class="w"> </span><span class="p">(</span><span class="k">default</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">zeros</span><span class="p">).</span>
</pre></div>
</div>
</details><div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calling set_input_history() effectively disables the transient
suppression by setting x_2 = 2.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For dynamical systems, a derivative should not be computed in
continuous-time, i.e. <code class="docutils literal notranslate"><span class="pre">y(t)</span> <span class="pre">=</span> <span class="pre">(u(t)</span> <span class="pre">-</span> <span class="pre">u[n])/(t-n*h)</span></code>. This is
numerically unstable since the time interval <code class="docutils literal notranslate"><span class="pre">t-n*h</span></code> could be
arbitrarily close to zero. Prefer the discrete-time implementation
for robustness.</p>
</div>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>DiscreteDerivative</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; dudt</td></tr></table></td></tr></table><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteDerivative_[Expression].__init__(self:</span> <span class="pre">pydrake.systems.primitives.DiscreteDerivative_[Expression],</span> <span class="pre">num_inputs:</span> <span class="pre">int,</span> <span class="pre">time_step:</span> <span class="pre">float,</span> <span class="pre">suppress_initial_transient:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">True)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructor taking <code class="docutils literal notranslate"><span class="pre">num_inputs</span></code>, the size of the vector to be
differentiated, and <code class="docutils literal notranslate"><span class="pre">time_step</span></code>, the sampling interval. If
<code class="docutils literal notranslate"><span class="pre">suppress_initial_transient</span></code> is true (the default), then the output
will be zero for the first two time steps (see the class documentation
for details and exceptions).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteDerivative_[Expression].suppress_initial_transient(self:</span> <span class="pre">pydrake.systems.primitives.DiscreteDerivative_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns the <code class="docutils literal notranslate"><span class="pre">suppress_initial_transient</span></code> passed to the constructor.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteDerivative_[Expression].time_step(self:</span> <span class="pre">pydrake.systems.primitives.DiscreteDerivative_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteTimeApproximation(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>DiscreteTimeApproximation(system: pydrake.systems.primitives.LinearSystem, time_period: float) -&gt; pydrake.systems.primitives.LinearSystem</p></li>
</ol>
<p>The DiscreteTimeApproximation function defined in the pydrake.systems.primitives module is deprecated and will be removed on or after 2025-08-01. Instead, import the function from the pydrake.systems.analysis module.</p>
<ol class="arabic simple" start="2">
<li><p>DiscreteTimeApproximation(system: pydrake.systems.primitives.AffineSystem, time_period: float) -&gt; pydrake.systems.primitives.AffineSystem</p></li>
</ol>
<p>The DiscreteTimeApproximation function defined in the pydrake.systems.primitives module is deprecated and will be removed on or after 2025-08-01. Instead, import the function from the pydrake.systems.analysis module.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteTimeDelay</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></p>
<p>A discrete time delay block with input u, which is vector-valued
(discrete or continuous) or abstract, and output delayed_u which is
previously received input, delayed by the given amount. The initial
output will be a vector of zeros for vector-valued or a given value
for abstract-valued until the delay time has passed.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>DiscreteTimeDelay</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; delayed_u</td></tr></table></td></tr></table><p>Let t,z ∈ ℕ be the number of delay time steps and the input vector
size. For abstract-valued DiscreteTimeDelay, z is 1. The state x ∈
ℝ⁽ᵗ⁺¹⁾ᶻ is partitioned into t+1 blocks x[0] x[1] … x[t], each of
size z. The input and output are u,y ∈ ℝᶻ. The discrete state space
dynamics of DiscreteTimeDelay is:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">xₙ</span><span class="err">₊</span><span class="n">₁</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xₙ</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="n">xₙ</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">xₙ</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="w"> </span><span class="n">uₙ</span><span class="w">  </span><span class="c1">// update</span>
<span class="w">  </span><span class="n">yₙ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xₙ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">                       </span><span class="c1">// output</span>
<span class="w">  </span><span class="n">x₀</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xᵢₙᵢₜ</span><span class="w">                       </span><span class="c1">// initialize</span>
</pre></div>
</div>
</details><p>where xᵢₙᵢₜ = 0 for vector-valued DiscreteTimeDelay and xᵢₙᵢₜ is a
given value for abstract-valued DiscreteTimeDelay.</p>
<p>See discrete_systems “Discrete Systems” for general information about
discrete systems in Drake, including how they interact with continuous
systems.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>While the output port can be sampled at any continuous time, this
system does not interpolate.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">DiscreteTimeDelay_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteTimeDelay.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.primitives.DiscreteTimeDelay, update_sec: float, delay_time_steps: int, vector_size: int) -&gt; None</p></li>
</ol>
<p>Constructs a DiscreteTimeDelay system updating every <code class="docutils literal notranslate"><span class="pre">update_sec</span></code>
and delaying a vector-valued input of size <code class="docutils literal notranslate"><span class="pre">vector_size</span></code> for
<code class="docutils literal notranslate"><span class="pre">delay_time_steps</span></code> number of updates.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.primitives.DiscreteTimeDelay, update_sec: float, delay_time_steps: int, abstract_model_value: pydrake.common.value.AbstractValue) -&gt; None</p></li>
</ol>
<p>Constructs a DiscreteTimeDelay system updating every <code class="docutils literal notranslate"><span class="pre">update_sec</span></code>
and delaying an abstract-valued input of type <code class="docutils literal notranslate"><span class="pre">abstract_model_value</span></code>
for <code class="docutils literal notranslate"><span class="pre">delay_time_steps</span></code> number of updates.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteTimeDelay_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">DiscreteTimeDelay_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">DiscreteTimeDelay_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">DiscreteTimeDelay_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteTimeDelay_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></code></p>
<p>A discrete time delay block with input u, which is vector-valued
(discrete or continuous) or abstract, and output delayed_u which is
previously received input, delayed by the given amount. The initial
output will be a vector of zeros for vector-valued or a given value
for abstract-valued until the delay time has passed.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>DiscreteTimeDelay</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; delayed_u</td></tr></table></td></tr></table><p>Let t,z ∈ ℕ be the number of delay time steps and the input vector
size. For abstract-valued DiscreteTimeDelay, z is 1. The state x ∈
ℝ⁽ᵗ⁺¹⁾ᶻ is partitioned into t+1 blocks x[0] x[1] … x[t], each of
size z. The input and output are u,y ∈ ℝᶻ. The discrete state space
dynamics of DiscreteTimeDelay is:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">xₙ</span><span class="err">₊</span><span class="n">₁</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xₙ</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="n">xₙ</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">xₙ</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="w"> </span><span class="n">uₙ</span><span class="w">  </span><span class="c1">// update</span>
<span class="w">  </span><span class="n">yₙ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xₙ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">                       </span><span class="c1">// output</span>
<span class="w">  </span><span class="n">x₀</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xᵢₙᵢₜ</span><span class="w">                       </span><span class="c1">// initialize</span>
</pre></div>
</div>
</details><p>where xᵢₙᵢₜ = 0 for vector-valued DiscreteTimeDelay and xᵢₙᵢₜ is a
given value for abstract-valued DiscreteTimeDelay.</p>
<p>See discrete_systems “Discrete Systems” for general information about
discrete systems in Drake, including how they interact with continuous
systems.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>While the output port can be sampled at any continuous time, this
system does not interpolate.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteTimeDelay_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.primitives.DiscreteTimeDelay_[AutoDiffXd], update_sec: float, delay_time_steps: int, vector_size: int) -&gt; None</p></li>
</ol>
<p>Constructs a DiscreteTimeDelay system updating every <code class="docutils literal notranslate"><span class="pre">update_sec</span></code>
and delaying a vector-valued input of size <code class="docutils literal notranslate"><span class="pre">vector_size</span></code> for
<code class="docutils literal notranslate"><span class="pre">delay_time_steps</span></code> number of updates.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.primitives.DiscreteTimeDelay_[AutoDiffXd], update_sec: float, delay_time_steps: int, abstract_model_value: pydrake.common.value.AbstractValue) -&gt; None</p></li>
</ol>
<p>Constructs a DiscreteTimeDelay system updating every <code class="docutils literal notranslate"><span class="pre">update_sec</span></code>
and delaying an abstract-valued input of type <code class="docutils literal notranslate"><span class="pre">abstract_model_value</span></code>
for <code class="docutils literal notranslate"><span class="pre">delay_time_steps</span></code> number of updates.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteTimeDelay_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[Expression]</span></code></p>
<p>A discrete time delay block with input u, which is vector-valued
(discrete or continuous) or abstract, and output delayed_u which is
previously received input, delayed by the given amount. The initial
output will be a vector of zeros for vector-valued or a given value
for abstract-valued until the delay time has passed.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>DiscreteTimeDelay</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; delayed_u</td></tr></table></td></tr></table><p>Let t,z ∈ ℕ be the number of delay time steps and the input vector
size. For abstract-valued DiscreteTimeDelay, z is 1. The state x ∈
ℝ⁽ᵗ⁺¹⁾ᶻ is partitioned into t+1 blocks x[0] x[1] … x[t], each of
size z. The input and output are u,y ∈ ℝᶻ. The discrete state space
dynamics of DiscreteTimeDelay is:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">xₙ</span><span class="err">₊</span><span class="n">₁</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xₙ</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="n">xₙ</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">xₙ</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="w"> </span><span class="n">uₙ</span><span class="w">  </span><span class="c1">// update</span>
<span class="w">  </span><span class="n">yₙ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xₙ</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w">                       </span><span class="c1">// output</span>
<span class="w">  </span><span class="n">x₀</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xᵢₙᵢₜ</span><span class="w">                       </span><span class="c1">// initialize</span>
</pre></div>
</div>
</details><p>where xᵢₙᵢₜ = 0 for vector-valued DiscreteTimeDelay and xᵢₙᵢₜ is a
given value for abstract-valued DiscreteTimeDelay.</p>
<p>See discrete_systems “Discrete Systems” for general information about
discrete systems in Drake, including how they interact with continuous
systems.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>While the output port can be sampled at any continuous time, this
system does not interpolate.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteTimeDelay_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.primitives.DiscreteTimeDelay_[Expression], update_sec: float, delay_time_steps: int, vector_size: int) -&gt; None</p></li>
</ol>
<p>Constructs a DiscreteTimeDelay system updating every <code class="docutils literal notranslate"><span class="pre">update_sec</span></code>
and delaying a vector-valued input of size <code class="docutils literal notranslate"><span class="pre">vector_size</span></code> for
<code class="docutils literal notranslate"><span class="pre">delay_time_steps</span></code> number of updates.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.primitives.DiscreteTimeDelay_[Expression], update_sec: float, delay_time_steps: int, abstract_model_value: pydrake.common.value.AbstractValue) -&gt; None</p></li>
</ol>
<p>Constructs a DiscreteTimeDelay system updating every <code class="docutils literal notranslate"><span class="pre">update_sec</span></code>
and delaying an abstract-valued input of type <code class="docutils literal notranslate"><span class="pre">abstract_model_value</span></code>
for <code class="docutils literal notranslate"><span class="pre">delay_time_steps</span></code> number of updates.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteTimeIntegrator</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></p>
<p>A discrete-time integrator for a vector input, using explicit Euler
integration.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>DiscreteTimeIntegrator</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y</td></tr></table></td></tr></table><p>The discrete state space dynamics of DiscreteTimeIntegrator with time
step <code class="docutils literal notranslate"><span class="pre">h</span></code> is:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">xₙ</span><span class="err">₊</span><span class="n">₁</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xₙ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="n">uₙ</span><span class="w">  </span><span class="c1">// update</span>
<span class="n">yₙ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xₙ</span><span class="w">           </span><span class="c1">// output</span>
<span class="n">x₀</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xᵢₙᵢₜ</span><span class="w">        </span><span class="c1">// initialize</span>
</pre></div>
</div>
</details><p>where xᵢₙᵢₜ = 0 by default. Use set_integral_value() to set xₙ in the
context. The output at time <code class="docutils literal notranslate"><span class="pre">t</span></code> is <code class="docutils literal notranslate"><span class="pre">xₙ</span></code> where <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">ceil(t/h)</span></code>.
See discrete_systems.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">DiscreteTimeIntegrator_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteTimeIntegrator.__init__(self:</span> <span class="pre">pydrake.systems.primitives.DiscreteTimeIntegrator,</span> <span class="pre">size:</span> <span class="pre">int,</span> <span class="pre">time_step:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs an DiscreteTimeIntegrator system.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">size</span></code>:</dt><dd><p>number of elements in the signal to be processed.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time_step</span></code>:</dt><dd><p>the discrete time step.</p>
</dd>
<dt>Precondition:</dt><dd><p>size &gt; 0. time_step &gt; 0.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteTimeIntegrator.set_integral_value(self:</span> <span class="pre">pydrake.systems.primitives.DiscreteTimeIntegrator,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">value:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the value of the integral modifying the state in the context.
<code class="docutils literal notranslate"><span class="pre">value</span></code> must be a column vector of the appropriate size.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteTimeIntegrator.time_step(self:</span> <span class="pre">pydrake.systems.primitives.DiscreteTimeIntegrator)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the time_step used by the integrator.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteTimeIntegrator_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">DiscreteTimeIntegrator_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">DiscreteTimeIntegrator_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">DiscreteTimeIntegrator_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteTimeIntegrator_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></code></p>
<p>A discrete-time integrator for a vector input, using explicit Euler
integration.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>DiscreteTimeIntegrator</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y</td></tr></table></td></tr></table><p>The discrete state space dynamics of DiscreteTimeIntegrator with time
step <code class="docutils literal notranslate"><span class="pre">h</span></code> is:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">xₙ</span><span class="err">₊</span><span class="n">₁</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xₙ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="n">uₙ</span><span class="w">  </span><span class="c1">// update</span>
<span class="n">yₙ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xₙ</span><span class="w">           </span><span class="c1">// output</span>
<span class="n">x₀</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xᵢₙᵢₜ</span><span class="w">        </span><span class="c1">// initialize</span>
</pre></div>
</div>
</details><p>where xᵢₙᵢₜ = 0 by default. Use set_integral_value() to set xₙ in the
context. The output at time <code class="docutils literal notranslate"><span class="pre">t</span></code> is <code class="docutils literal notranslate"><span class="pre">xₙ</span></code> where <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">ceil(t/h)</span></code>.
See discrete_systems.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteTimeIntegrator_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.systems.primitives.DiscreteTimeIntegrator_[AutoDiffXd],</span> <span class="pre">size:</span> <span class="pre">int,</span> <span class="pre">time_step:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs an DiscreteTimeIntegrator system.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">size</span></code>:</dt><dd><p>number of elements in the signal to be processed.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time_step</span></code>:</dt><dd><p>the discrete time step.</p>
</dd>
<dt>Precondition:</dt><dd><p>size &gt; 0. time_step &gt; 0.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteTimeIntegrator_[AutoDiffXd].set_integral_value(self:</span> <span class="pre">pydrake.systems.primitives.DiscreteTimeIntegrator_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">value:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the value of the integral modifying the state in the context.
<code class="docutils literal notranslate"><span class="pre">value</span></code> must be a column vector of the appropriate size.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteTimeIntegrator_[AutoDiffXd].time_step(self:</span> <span class="pre">pydrake.systems.primitives.DiscreteTimeIntegrator_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the time_step used by the integrator.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteTimeIntegrator_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[Expression]</span></code></p>
<p>A discrete-time integrator for a vector input, using explicit Euler
integration.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>DiscreteTimeIntegrator</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y</td></tr></table></td></tr></table><p>The discrete state space dynamics of DiscreteTimeIntegrator with time
step <code class="docutils literal notranslate"><span class="pre">h</span></code> is:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">xₙ</span><span class="err">₊</span><span class="n">₁</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xₙ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="n">uₙ</span><span class="w">  </span><span class="c1">// update</span>
<span class="n">yₙ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xₙ</span><span class="w">           </span><span class="c1">// output</span>
<span class="n">x₀</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">xᵢₙᵢₜ</span><span class="w">        </span><span class="c1">// initialize</span>
</pre></div>
</div>
</details><p>where xᵢₙᵢₜ = 0 by default. Use set_integral_value() to set xₙ in the
context. The output at time <code class="docutils literal notranslate"><span class="pre">t</span></code> is <code class="docutils literal notranslate"><span class="pre">xₙ</span></code> where <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">=</span> <span class="pre">ceil(t/h)</span></code>.
See discrete_systems.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteTimeIntegrator_[Expression].__init__(self:</span> <span class="pre">pydrake.systems.primitives.DiscreteTimeIntegrator_[Expression],</span> <span class="pre">size:</span> <span class="pre">int,</span> <span class="pre">time_step:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs an DiscreteTimeIntegrator system.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">size</span></code>:</dt><dd><p>number of elements in the signal to be processed.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time_step</span></code>:</dt><dd><p>the discrete time step.</p>
</dd>
<dt>Precondition:</dt><dd><p>size &gt; 0. time_step &gt; 0.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteTimeIntegrator_[Expression].set_integral_value(self:</span> <span class="pre">pydrake.systems.primitives.DiscreteTimeIntegrator_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">value:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the value of the integral modifying the state in the context.
<code class="docutils literal notranslate"><span class="pre">value</span></code> must be a column vector of the appropriate size.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteTimeIntegrator_[Expression].time_step(self:</span> <span class="pre">pydrake.systems.primitives.DiscreteTimeIntegrator_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the time_step used by the integrator.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FirstOrderLowPassFilter</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></p>
<p>An element-wise first order low pass filter system that filters the
i-th input uᵢ into the i-th output zᵢ. This system has one continuous
state per filtered input signal. Therefore, the i-th state of the
system zᵢ evolves according to:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">z</span><span class="err">̇</span><span class="n">ᵢ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="o">/</span><span class="n">τᵢ</span><span class="w"> </span><span class="p">(</span><span class="n">zᵢ</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">uᵢ</span><span class="p">)</span>
</pre></div>
</div>
</details><p>where τᵢ is the time constant of the i-th filter. The i-th output of
the system is given by:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">yᵢ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zᵢ</span>
</pre></div>
</div>
</details><p>The transfer function for the i-th filter corresponds to:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">H</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">τᵢ</span><span class="w"> </span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
</details><p>The Bode plot for the i-th filter exhibits a cutoff frequency (angular
frequency) at 1/τᵢ and a gain of one. For frequencies higher than the
cutoff frequency, the Bode plot approaches a 20 dB per decade negative
slope. The Bode plot in phase exhibits a -90 degrees shift (lag) for
frequencies much larger than the cutoff frequency and a zero shift for
low frequencies.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>FirstOrderLowPassFilter</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">FirstOrderLowPassFilter_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FirstOrderLowPassFilter.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.primitives.FirstOrderLowPassFilter, time_constant: float, size: int = 1) -&gt; None</p></li>
</ol>
<p>Constructs a FirstOrderLowPassFilter system that filters all input
signals with the same time constant, i.e. τᵢ = τ, ∀ i.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time_constant</span></code>:</dt><dd><p>the time constant τ of the filter. It must be a positive number.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">size</span></code>:</dt><dd><p>number of elements in the signal to be processed.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.primitives.FirstOrderLowPassFilter, time_constants: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs a FirstOrderLowPassFilter so that the i-th component of the
input signal vector is low pass filtered with a time constant given in
the i-th component τᵢ of the input <code class="docutils literal notranslate"><span class="pre">time_constants</span></code> vector.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time_constants</span></code>:</dt><dd><p>Vector of time constants. Each entry in this vector must be
positive.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FirstOrderLowPassFilter.get_time_constant(self:</span> <span class="pre">pydrake.systems.primitives.FirstOrderLowPassFilter)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the time constant of the filter for filters that have the same
time constant τ for all signals. This method aborts if called on
filters if with different time constants per input signal.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>get_time_constants_vector().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FirstOrderLowPassFilter.get_time_constants_vector(self:</span> <span class="pre">pydrake.systems.primitives.FirstOrderLowPassFilter)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the vector of time constants for <code class="docutils literal notranslate"><span class="pre">this</span></code> filter.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FirstOrderLowPassFilter.set_initial_output_value(self:</span> <span class="pre">pydrake.systems.primitives.FirstOrderLowPassFilter,</span> <span class="pre">arg0:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">arg1:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the initial conditions on the output value of the filtered
signal.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The current system context.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">z0</span></code>:</dt><dd><p>The vector on initial conditions on the output value.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FirstOrderLowPassFilter_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">FirstOrderLowPassFilter_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">FirstOrderLowPassFilter_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">FirstOrderLowPassFilter_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FirstOrderLowPassFilter_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></code></p>
<p>An element-wise first order low pass filter system that filters the
i-th input uᵢ into the i-th output zᵢ. This system has one continuous
state per filtered input signal. Therefore, the i-th state of the
system zᵢ evolves according to:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">z</span><span class="err">̇</span><span class="n">ᵢ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="o">/</span><span class="n">τᵢ</span><span class="w"> </span><span class="p">(</span><span class="n">zᵢ</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">uᵢ</span><span class="p">)</span>
</pre></div>
</div>
</details><p>where τᵢ is the time constant of the i-th filter. The i-th output of
the system is given by:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">yᵢ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zᵢ</span>
</pre></div>
</div>
</details><p>The transfer function for the i-th filter corresponds to:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">H</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">τᵢ</span><span class="w"> </span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
</details><p>The Bode plot for the i-th filter exhibits a cutoff frequency (angular
frequency) at 1/τᵢ and a gain of one. For frequencies higher than the
cutoff frequency, the Bode plot approaches a 20 dB per decade negative
slope. The Bode plot in phase exhibits a -90 degrees shift (lag) for
frequencies much larger than the cutoff frequency and a zero shift for
low frequencies.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>FirstOrderLowPassFilter</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FirstOrderLowPassFilter_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.primitives.FirstOrderLowPassFilter_[AutoDiffXd], time_constant: float, size: int = 1) -&gt; None</p></li>
</ol>
<p>Constructs a FirstOrderLowPassFilter system that filters all input
signals with the same time constant, i.e. τᵢ = τ, ∀ i.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time_constant</span></code>:</dt><dd><p>the time constant τ of the filter. It must be a positive number.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">size</span></code>:</dt><dd><p>number of elements in the signal to be processed.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.primitives.FirstOrderLowPassFilter_[AutoDiffXd], time_constants: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs a FirstOrderLowPassFilter so that the i-th component of the
input signal vector is low pass filtered with a time constant given in
the i-th component τᵢ of the input <code class="docutils literal notranslate"><span class="pre">time_constants</span></code> vector.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time_constants</span></code>:</dt><dd><p>Vector of time constants. Each entry in this vector must be
positive.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FirstOrderLowPassFilter_[AutoDiffXd].get_time_constant(self:</span> <span class="pre">pydrake.systems.primitives.FirstOrderLowPassFilter_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the time constant of the filter for filters that have the same
time constant τ for all signals. This method aborts if called on
filters if with different time constants per input signal.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>get_time_constants_vector().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FirstOrderLowPassFilter_[AutoDiffXd].get_time_constants_vector(self:</span> <span class="pre">pydrake.systems.primitives.FirstOrderLowPassFilter_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the vector of time constants for <code class="docutils literal notranslate"><span class="pre">this</span></code> filter.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FirstOrderLowPassFilter_[AutoDiffXd].set_initial_output_value(self:</span> <span class="pre">pydrake.systems.primitives.FirstOrderLowPassFilter_[AutoDiffXd],</span> <span class="pre">arg0:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">arg1:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the initial conditions on the output value of the filtered
signal.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The current system context.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">z0</span></code>:</dt><dd><p>The vector on initial conditions on the output value.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FirstOrderLowPassFilter_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[Expression]</span></code></p>
<p>An element-wise first order low pass filter system that filters the
i-th input uᵢ into the i-th output zᵢ. This system has one continuous
state per filtered input signal. Therefore, the i-th state of the
system zᵢ evolves according to:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">z</span><span class="err">̇</span><span class="n">ᵢ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="o">/</span><span class="n">τᵢ</span><span class="w"> </span><span class="p">(</span><span class="n">zᵢ</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">uᵢ</span><span class="p">)</span>
</pre></div>
</div>
</details><p>where τᵢ is the time constant of the i-th filter. The i-th output of
the system is given by:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">yᵢ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zᵢ</span>
</pre></div>
</div>
</details><p>The transfer function for the i-th filter corresponds to:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">H</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">τᵢ</span><span class="w"> </span><span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
</details><p>The Bode plot for the i-th filter exhibits a cutoff frequency (angular
frequency) at 1/τᵢ and a gain of one. For frequencies higher than the
cutoff frequency, the Bode plot approaches a 20 dB per decade negative
slope. The Bode plot in phase exhibits a -90 degrees shift (lag) for
frequencies much larger than the cutoff frequency and a zero shift for
low frequencies.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>FirstOrderLowPassFilter</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FirstOrderLowPassFilter_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.primitives.FirstOrderLowPassFilter_[Expression], time_constant: float, size: int = 1) -&gt; None</p></li>
</ol>
<p>Constructs a FirstOrderLowPassFilter system that filters all input
signals with the same time constant, i.e. τᵢ = τ, ∀ i.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time_constant</span></code>:</dt><dd><p>the time constant τ of the filter. It must be a positive number.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">size</span></code>:</dt><dd><p>number of elements in the signal to be processed.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.primitives.FirstOrderLowPassFilter_[Expression], time_constants: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs a FirstOrderLowPassFilter so that the i-th component of the
input signal vector is low pass filtered with a time constant given in
the i-th component τᵢ of the input <code class="docutils literal notranslate"><span class="pre">time_constants</span></code> vector.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time_constants</span></code>:</dt><dd><p>Vector of time constants. Each entry in this vector must be
positive.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FirstOrderLowPassFilter_[Expression].get_time_constant(self:</span> <span class="pre">pydrake.systems.primitives.FirstOrderLowPassFilter_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the time constant of the filter for filters that have the same
time constant τ for all signals. This method aborts if called on
filters if with different time constants per input signal.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>get_time_constants_vector().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FirstOrderLowPassFilter_[Expression].get_time_constants_vector(self:</span> <span class="pre">pydrake.systems.primitives.FirstOrderLowPassFilter_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the vector of time constants for <code class="docutils literal notranslate"><span class="pre">this</span></code> filter.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FirstOrderLowPassFilter_[Expression].set_initial_output_value(self:</span> <span class="pre">pydrake.systems.primitives.FirstOrderLowPassFilter_[Expression],</span> <span class="pre">arg0:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">arg1:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the initial conditions on the output value of the filtered
signal.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The current system context.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">z0</span></code>:</dt><dd><p>The vector on initial conditions on the output value.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FirstOrderTaylorApproximation(system:</span> <span class="pre">pydrake.systems.framework.System,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">input_port_index:</span> <span class="pre">Union[pydrake.systems.framework.InputPortSelection,</span> <span class="pre">pydrake.systems.framework.InputPortIndex]</span> <span class="pre">=</span> <span class="pre">&lt;InputPortSelection.kUseFirstInputIfItExists:</span> <span class="pre">-2&gt;,</span> <span class="pre">output_port_index:</span> <span class="pre">Union[pydrake.systems.framework.OutputPortSelection,</span> <span class="pre">pydrake.systems.framework.OutputPortIndex]</span> <span class="pre">=</span> <span class="pre">&lt;OutputPortSelection.kUseFirstOutputIfItExists:</span> <span class="pre">-2&gt;)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.primitives.AffineSystem</span></span></dt>
<dd><p>A first-order Taylor series approximation to a <code class="docutils literal notranslate"><span class="pre">system</span></code> in the
neighborhood of an arbitrary point. When Taylor-expanding a system at
a non-equilibrium point, it may be represented either of the form:</p>
<div class="math notranslate nohighlight">
\[\dot{x} - \dot{x}_0 = A (x - x_0) + B (u - u_0),\]</div>
<p>for continuous time, or</p>
<div class="math notranslate nohighlight">
\[x[n+1] - x_0[n+1] = A (x[n] - x_0[n]) + B (u[n] - u_0[n]),\]</div>
<p>for discrete time. As above, we denote <span class="math notranslate nohighlight">\(x_0, u_0\)</span> to be the
nominal state and input at the provided <code class="docutils literal notranslate"><span class="pre">context</span></code>. The system
description is affine when the terms <span class="math notranslate nohighlight">\(\dot{x}_0 - A x_0 - B u_0\)</span>
and <span class="math notranslate nohighlight">\(x_0[n+1] - A x_0[n] - B u_0[n]\)</span> are nonzero.</p>
<p>More precisely, let x be a state and u be an input. This function
returns an AffineSystem of the form:</p>
<div class="math notranslate nohighlight">
\[\dot{x} = A x + B u + f_0,\]</div>
<p>(CT)</p>
<div class="math notranslate nohighlight">
\[x[n+1] = A x[n] + B u[n] + f_0,\]</div>
<p>(DT) where <span class="math notranslate nohighlight">\(f_0 = \dot{x}_0 - A x_0 - B u_0\)</span> (CT) and <span class="math notranslate nohighlight">\(f_0
= x_0[n+1] - A x[n] - B u[n]\)</span> (DT).</p>
<p>This method currently supports approximating around at most a single
vector input port and at most a single vector output port. For systems
with more ports, use <code class="docutils literal notranslate"><span class="pre">input_port_index</span></code> and <code class="docutils literal notranslate"><span class="pre">output_port_index</span></code> to
select the input for the newly constructed system. Any additional
input ports will be treated as constants (fixed at the value specified
in <code class="docutils literal notranslate"><span class="pre">context)</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">system</span></code>:</dt><dd><p>The system or subsystem to linearize.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Defines the nominal operating point about which the system should
be linearized.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">input_port_index</span></code>:</dt><dd><p>A valid input port index for <code class="docutils literal notranslate"><span class="pre">system</span></code> or InputPortSelection.
$*Default:* kUseFirstInputIfItExists.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">output_port_index</span></code>:</dt><dd><p>A valid output port index for <code class="docutils literal notranslate"><span class="pre">system</span></code> or OutputPortSelection.
$*Default:* kUseFirstOutputIfItExists.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>An AffineSystem at this linearization point.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>if any abstract inputs are connected</strong><strong>, </strong><strong>if any vector-valued inputs</strong> – </p></li>
<li><p><strong>are unconnected</strong><strong>, </strong><strong>if the system is not</strong><strong> (</strong><strong>only</strong><strong>) </strong><strong>continuous</strong><strong> or </strong><strong>not</strong> – </p></li>
<li><p><strong>(</strong><strong>only</strong><strong>) </strong><strong>discrete time with a single periodic update.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>x, u and y are in the same coordinate system as the original
<code class="docutils literal notranslate"><span class="pre">system</span></code>, since the terms involving <span class="math notranslate nohighlight">\(x_0, u_0\)</span> reside in
<span class="math notranslate nohighlight">\(f_0\)</span>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method does <em>not</em> (yet) set the initial conditions (default
nor random) of the AffineSystem based on <code class="docutils literal notranslate"><span class="pre">system</span></code>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Gain</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></p>
<p>An element-wise gain block with input <code class="docutils literal notranslate"><span class="pre">u</span></code> and output <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">k</span> <span class="pre">*</span> <span class="pre">u</span></code>
with <code class="docutils literal notranslate"><span class="pre">k</span></code> a constant vector. The input to this system directly feeds
through to its output.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Gain</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">Gain_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Gain.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.primitives.Gain, k: float, size: int) -&gt; None</p></li>
</ol>
<p>Constructs a Gain system where the same gain is applied to every input
value.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">k</span></code>:</dt><dd><p>the gain constant so that <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">k</span> <span class="pre">*</span> <span class="pre">u</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">size</span></code>:</dt><dd><p>number of elements in the signal to be processed.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.primitives.Gain, k: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs a Gain system where different gains can be applied to each
input value.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">k</span></code>:</dt><dd><p>the gain vector constants so that <code class="docutils literal notranslate"><span class="pre">y_i</span> <span class="pre">=</span> <span class="pre">k_i</span> <span class="pre">*</span> <span class="pre">u_i</span></code> where
subscript <code class="docutils literal notranslate"><span class="pre">i</span></code> indicates the i-th element of the vector.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Gain_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">Gain_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Gain_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Gain_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Gain_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></code></p>
<p>An element-wise gain block with input <code class="docutils literal notranslate"><span class="pre">u</span></code> and output <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">k</span> <span class="pre">*</span> <span class="pre">u</span></code>
with <code class="docutils literal notranslate"><span class="pre">k</span></code> a constant vector. The input to this system directly feeds
through to its output.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Gain</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Gain_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.primitives.Gain_[AutoDiffXd], k: float, size: int) -&gt; None</p></li>
</ol>
<p>Constructs a Gain system where the same gain is applied to every input
value.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">k</span></code>:</dt><dd><p>the gain constant so that <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">k</span> <span class="pre">*</span> <span class="pre">u</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">size</span></code>:</dt><dd><p>number of elements in the signal to be processed.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.primitives.Gain_[AutoDiffXd], k: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs a Gain system where different gains can be applied to each
input value.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">k</span></code>:</dt><dd><p>the gain vector constants so that <code class="docutils literal notranslate"><span class="pre">y_i</span> <span class="pre">=</span> <span class="pre">k_i</span> <span class="pre">*</span> <span class="pre">u_i</span></code> where
subscript <code class="docutils literal notranslate"><span class="pre">i</span></code> indicates the i-th element of the vector.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Gain_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[Expression]</span></code></p>
<p>An element-wise gain block with input <code class="docutils literal notranslate"><span class="pre">u</span></code> and output <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">k</span> <span class="pre">*</span> <span class="pre">u</span></code>
with <code class="docutils literal notranslate"><span class="pre">k</span></code> a constant vector. The input to this system directly feeds
through to its output.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Gain</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Gain_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.primitives.Gain_[Expression], k: float, size: int) -&gt; None</p></li>
</ol>
<p>Constructs a Gain system where the same gain is applied to every input
value.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">k</span></code>:</dt><dd><p>the gain constant so that <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">k</span> <span class="pre">*</span> <span class="pre">u</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">size</span></code>:</dt><dd><p>number of elements in the signal to be processed.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.primitives.Gain_[Expression], k: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs a Gain system where different gains can be applied to each
input value.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">k</span></code>:</dt><dd><p>the gain vector constants so that <code class="docutils literal notranslate"><span class="pre">y_i</span> <span class="pre">=</span> <span class="pre">k_i</span> <span class="pre">*</span> <span class="pre">u_i</span></code> where
subscript <code class="docutils literal notranslate"><span class="pre">i</span></code> indicates the i-th element of the vector.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Integrator</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></p>
<p>A continuous-time integrator for a vector input.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Integrator</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">Integrator_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Integrator.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.primitives.Integrator, size: int) -&gt; None</p></li>
</ol>
<p>Constructs an Integrator system. The initial output value will be
zero.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">size</span></code>:</dt><dd><p>number of elements in the signal to be processed.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.primitives.Integrator, initial_value: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs an Integrator system with a particular initial output
value. The size of both input and output are inferred from the given
<code class="docutils literal notranslate"><span class="pre">initial_value</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">initial_value</span></code>:</dt><dd><p>the initial output value.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Integrator.set_default_integral_value(self:</span> <span class="pre">pydrake.systems.primitives.Integrator,</span> <span class="pre">initial_value:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the initial value of the integral state variable that will be
present in a subsequently-created Context. Overrides any value that
was provided in the constructor or previous calls to this function.
However, the size of <code class="docutils literal notranslate"><span class="pre">value</span></code> must be the same as the size indicated
at construction.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>set_integral_value() to set the initial value in an
already-allocated Context.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if an attempt is made to change the state size.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Integrator.set_integral_value(self:</span> <span class="pre">pydrake.systems.primitives.Integrator,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">value:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the value of the integral modifying the state in the context.
<code class="docutils literal notranslate"><span class="pre">value</span></code> must be a column vector of the appropriate size.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>set_default_integral_value() to set the initial value that will be
present in a newly-allocated Context.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if an attempt is made to change the state size.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Integrator_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">Integrator_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Integrator_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Integrator_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Integrator_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></code></p>
<p>A continuous-time integrator for a vector input.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Integrator</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Integrator_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.primitives.Integrator_[AutoDiffXd], size: int) -&gt; None</p></li>
</ol>
<p>Constructs an Integrator system. The initial output value will be
zero.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">size</span></code>:</dt><dd><p>number of elements in the signal to be processed.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.primitives.Integrator_[AutoDiffXd], initial_value: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs an Integrator system with a particular initial output
value. The size of both input and output are inferred from the given
<code class="docutils literal notranslate"><span class="pre">initial_value</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">initial_value</span></code>:</dt><dd><p>the initial output value.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Integrator_[AutoDiffXd].set_default_integral_value(self:</span> <span class="pre">pydrake.systems.primitives.Integrator_[AutoDiffXd],</span> <span class="pre">initial_value:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the initial value of the integral state variable that will be
present in a subsequently-created Context. Overrides any value that
was provided in the constructor or previous calls to this function.
However, the size of <code class="docutils literal notranslate"><span class="pre">value</span></code> must be the same as the size indicated
at construction.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>set_integral_value() to set the initial value in an
already-allocated Context.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if an attempt is made to change the state size.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Integrator_[AutoDiffXd].set_integral_value(self:</span> <span class="pre">pydrake.systems.primitives.Integrator_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">value:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the value of the integral modifying the state in the context.
<code class="docutils literal notranslate"><span class="pre">value</span></code> must be a column vector of the appropriate size.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>set_default_integral_value() to set the initial value that will be
present in a newly-allocated Context.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if an attempt is made to change the state size.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Integrator_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[Expression]</span></code></p>
<p>A continuous-time integrator for a vector input.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Integrator</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Integrator_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.primitives.Integrator_[Expression], size: int) -&gt; None</p></li>
</ol>
<p>Constructs an Integrator system. The initial output value will be
zero.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">size</span></code>:</dt><dd><p>number of elements in the signal to be processed.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.primitives.Integrator_[Expression], initial_value: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs an Integrator system with a particular initial output
value. The size of both input and output are inferred from the given
<code class="docutils literal notranslate"><span class="pre">initial_value</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">initial_value</span></code>:</dt><dd><p>the initial output value.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Integrator_[Expression].set_default_integral_value(self:</span> <span class="pre">pydrake.systems.primitives.Integrator_[Expression],</span> <span class="pre">initial_value:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the initial value of the integral state variable that will be
present in a subsequently-created Context. Overrides any value that
was provided in the constructor or previous calls to this function.
However, the size of <code class="docutils literal notranslate"><span class="pre">value</span></code> must be the same as the size indicated
at construction.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>set_integral_value() to set the initial value in an
already-allocated Context.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if an attempt is made to change the state size.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Integrator_[Expression].set_integral_value(self:</span> <span class="pre">pydrake.systems.primitives.Integrator_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">value:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the value of the integral modifying the state in the context.
<code class="docutils literal notranslate"><span class="pre">value</span></code> must be a column vector of the appropriate size.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>set_default_integral_value() to set the initial value that will be
present in a newly-allocated Context.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if an attempt is made to change the state size.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IsControllable(sys:</span> <span class="pre">pydrake.systems.primitives.LinearSystem,</span> <span class="pre">threshold:</span> <span class="pre">Optional[float]</span> <span class="pre">=</span> <span class="pre">None)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff the controllability matrix is full row rank.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IsDetectable(sys:</span> <span class="pre">pydrake.systems.primitives.LinearSystem,</span> <span class="pre">threshold:</span> <span class="pre">Optional[float]</span> <span class="pre">=</span> <span class="pre">None)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff the system is detectable.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IsObservable(sys:</span> <span class="pre">pydrake.systems.primitives.LinearSystem,</span> <span class="pre">threshold:</span> <span class="pre">Optional[float]</span> <span class="pre">=</span> <span class="pre">None)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff the observability matrix is full column rank.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IsStabilizable(sys:</span> <span class="pre">pydrake.systems.primitives.LinearSystem,</span> <span class="pre">threshold:</span> <span class="pre">Optional[float]</span> <span class="pre">=</span> <span class="pre">None)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff the system is stabilizable.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Linearize(system:</span> <span class="pre">pydrake.systems.framework.System,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">input_port_index:</span> <span class="pre">Union[pydrake.systems.framework.InputPortSelection,</span> <span class="pre">pydrake.systems.framework.InputPortIndex]</span> <span class="pre">=</span> <span class="pre">&lt;InputPortSelection.kUseFirstInputIfItExists:</span> <span class="pre">-2&gt;,</span> <span class="pre">output_port_index:</span> <span class="pre">Union[pydrake.systems.framework.OutputPortSelection,</span> <span class="pre">pydrake.systems.framework.OutputPortIndex]</span> <span class="pre">=</span> <span class="pre">&lt;OutputPortSelection.kUseFirstOutputIfItExists:</span> <span class="pre">-2&gt;,</span> <span class="pre">equilibrium_check_tolerance:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">1e-06)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.primitives.LinearSystem</span></span></dt>
<dd><p>Takes the first-order Taylor expansion of a System around a nominal
operating point (defined by the Context).</p>
<p>This method currently supports linearizing around at most a single
vector input port and at most a single vector output port. For systems
with more ports, use <code class="docutils literal notranslate"><span class="pre">input_port_index</span></code> and <code class="docutils literal notranslate"><span class="pre">output_port_index</span></code> to
select the input for the newly constructed system. Any additional
<em>vector</em> input ports will be treated as constants (fixed at the value
specified in <code class="docutils literal notranslate"><span class="pre">context</span></code>). Abstract-valued input ports must be
unconnected (i.e., the system must treat the port as optional and it
must be unused).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">system</span></code>:</dt><dd><p>The system or subsystem to linearize.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Defines the nominal operating point about which the system should
be linearized. See note below.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">input_port_index</span></code>:</dt><dd><p>A valid input port index for <code class="docutils literal notranslate"><span class="pre">system</span></code> or InputPortSelection. All
other inputs are assumed to be fixed to the value described by the
<code class="docutils literal notranslate"><span class="pre">context</span></code>. $*Default:* kUseFirstInputIfItExists.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">output_port_index</span></code>:</dt><dd><p>A valid output port index for <code class="docutils literal notranslate"><span class="pre">system</span></code> or an
OutputPortSelection. $*Default:* kUseFirstOutputIfItExists.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">equilibrium_check_tolerance</span></code>:</dt><dd><p>Specifies the tolerance on ensuring that the derivative vector
isZero at the nominal operating point. $*Default:* 1e-6.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A LinearSystem that approximates the original system in the
vicinity of the operating point. See note below.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if the operating point is not an equilibrium point of</strong> – </p></li>
<li><p><strong>the system</strong><strong> (</strong><strong>within the specified tolerance</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if the system is not</strong><strong> (</strong><strong>only</strong><strong>) </strong><strong>continuous</strong><strong> or </strong><strong>(</strong><strong>only</strong><strong>)</strong> – </p></li>
<li><p><strong>discrete time with a single periodic update.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All <em>vector</em> inputs in the system must be connected, either to the
output of some upstream System within a Diagram (e.g., if system
is a reference to a subsystem in a Diagram), or to a constant
value using, e.g. <code class="docutils literal notranslate"><span class="pre">port.FixValue(context,</span> <span class="pre">default_input)</span></code>. Any
<em>abstract</em> inputs in the system must be unconnected (the port must
be both optional and unused).</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The inputs, states, and outputs of the returned system are NOT the
same as the original system. Denote x0,u0 as the nominal state and
input defined by the Context, and y0 as the value of the output at
(x0,u0), then the created systems inputs are (u-u0), states are
(x-x0), and outputs are (y-y0).</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method does <em>not</em> (yet) set the initial conditions (default
nor random) of the LinearSystem based on <code class="docutils literal notranslate"><span class="pre">system</span></code>.</p>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearSystem</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.primitives.AffineSystem</span></code></p>
<p>A discrete OR continuous linear system.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>LinearSystem</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><p>If time_period&gt;0.0, then the linear system will have the following
discrete- time state update:</p>
<div class="math notranslate nohighlight">
\[x[n+1] = A x[n] + B u[n],\]</div>
<p>or if time_period==0.0, then the linear system will have the following
continuous-time state update:</p>
<div class="math notranslate nohighlight">
\[\dot{x} = A x + B u.\]</div>
<p>In both cases, the system will have the output:</p>
<div class="math notranslate nohighlight">
\[y = C x + D u,\]</div>
<p>where <code class="docutils literal notranslate"><span class="pre">u</span></code> denotes the input vector, <code class="docutils literal notranslate"><span class="pre">x</span></code> denotes the state vector,
and <code class="docutils literal notranslate"><span class="pre">y</span></code> denotes the output vector.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AffineSystem</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MatrixGain</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">LinearSystem_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearSystem.__init__(self:</span> <span class="pre">pydrake.systems.primitives.LinearSystem,</span> <span class="pre">A:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">shape=(0,</span> <span class="pre">0),</span> <span class="pre">dtype=float64),</span> <span class="pre">B:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">shape=(0,</span> <span class="pre">0),</span> <span class="pre">dtype=float64),</span> <span class="pre">C:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">shape=(0,</span> <span class="pre">0),</span> <span class="pre">dtype=float64),</span> <span class="pre">D:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">shape=(0,</span> <span class="pre">0),</span> <span class="pre">dtype=float64),</span> <span class="pre">time_period:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0.0)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a LinearSystem with a fixed set of coefficient matrices
<code class="docutils literal notranslate"><span class="pre">A</span></code>, <cite>B</cite>,``C``, and <code class="docutils literal notranslate"><span class="pre">D</span></code>. The coefficient matrices must obey the
following dimensions: | Matrix | Num Rows | Num Columns |
<a href="#id19"><span class="problematic" id="id20">|:-------:|</span></a>:———–:<a href="#id21"><span class="problematic" id="id22">|:-----------:|</span></a> | A | num states | num states
| | B | num states | num inputs | | C | num outputs | num states | | D
| num outputs | num inputs |</p>
<p>Empty matrices are treated as zero matrices with the appropriate
number of rows and columns.</p>
<p>Subclasses must use the protected constructor, not this one.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearSystem_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">LinearSystem_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">LinearSystem_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">LinearSystem_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearSystem_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.primitives.AffineSystem_[AutoDiffXd]</span></code></p>
<p>A discrete OR continuous linear system.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>LinearSystem</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><p>If time_period&gt;0.0, then the linear system will have the following
discrete- time state update:</p>
<div class="math notranslate nohighlight">
\[x[n+1] = A x[n] + B u[n],\]</div>
<p>or if time_period==0.0, then the linear system will have the following
continuous-time state update:</p>
<div class="math notranslate nohighlight">
\[\dot{x} = A x + B u.\]</div>
<p>In both cases, the system will have the output:</p>
<div class="math notranslate nohighlight">
\[y = C x + D u,\]</div>
<p>where <code class="docutils literal notranslate"><span class="pre">u</span></code> denotes the input vector, <code class="docutils literal notranslate"><span class="pre">x</span></code> denotes the state vector,
and <code class="docutils literal notranslate"><span class="pre">y</span></code> denotes the output vector.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AffineSystem</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MatrixGain</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearSystem_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.systems.primitives.LinearSystem_[AutoDiffXd],</span> <span class="pre">A:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">shape=(0,</span> <span class="pre">0),</span> <span class="pre">dtype=float64),</span> <span class="pre">B:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">shape=(0,</span> <span class="pre">0),</span> <span class="pre">dtype=float64),</span> <span class="pre">C:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">shape=(0,</span> <span class="pre">0),</span> <span class="pre">dtype=float64),</span> <span class="pre">D:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">shape=(0,</span> <span class="pre">0),</span> <span class="pre">dtype=float64),</span> <span class="pre">time_period:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0.0)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a LinearSystem with a fixed set of coefficient matrices
<code class="docutils literal notranslate"><span class="pre">A</span></code>, <cite>B</cite>,``C``, and <code class="docutils literal notranslate"><span class="pre">D</span></code>. The coefficient matrices must obey the
following dimensions: | Matrix | Num Rows | Num Columns |
<a href="#id23"><span class="problematic" id="id24">|:-------:|</span></a>:———–:<a href="#id25"><span class="problematic" id="id26">|:-----------:|</span></a> | A | num states | num states
| | B | num states | num inputs | | C | num outputs | num states | | D
| num outputs | num inputs |</p>
<p>Empty matrices are treated as zero matrices with the appropriate
number of rows and columns.</p>
<p>Subclasses must use the protected constructor, not this one.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearSystem_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.primitives.AffineSystem_[Expression]</span></code></p>
<p>A discrete OR continuous linear system.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>LinearSystem</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><p>If time_period&gt;0.0, then the linear system will have the following
discrete- time state update:</p>
<div class="math notranslate nohighlight">
\[x[n+1] = A x[n] + B u[n],\]</div>
<p>or if time_period==0.0, then the linear system will have the following
continuous-time state update:</p>
<div class="math notranslate nohighlight">
\[\dot{x} = A x + B u.\]</div>
<p>In both cases, the system will have the output:</p>
<div class="math notranslate nohighlight">
\[y = C x + D u,\]</div>
<p>where <code class="docutils literal notranslate"><span class="pre">u</span></code> denotes the input vector, <code class="docutils literal notranslate"><span class="pre">x</span></code> denotes the state vector,
and <code class="docutils literal notranslate"><span class="pre">y</span></code> denotes the output vector.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AffineSystem</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MatrixGain</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearSystem_[Expression].__init__(self:</span> <span class="pre">pydrake.systems.primitives.LinearSystem_[Expression],</span> <span class="pre">A:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">shape=(0,</span> <span class="pre">0),</span> <span class="pre">dtype=float64),</span> <span class="pre">B:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">shape=(0,</span> <span class="pre">0),</span> <span class="pre">dtype=float64),</span> <span class="pre">C:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">shape=(0,</span> <span class="pre">0),</span> <span class="pre">dtype=float64),</span> <span class="pre">D:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous]</span> <span class="pre">=</span> <span class="pre">array([],</span> <span class="pre">shape=(0,</span> <span class="pre">0),</span> <span class="pre">dtype=float64),</span> <span class="pre">time_period:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0.0)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a LinearSystem with a fixed set of coefficient matrices
<code class="docutils literal notranslate"><span class="pre">A</span></code>, <cite>B</cite>,``C``, and <code class="docutils literal notranslate"><span class="pre">D</span></code>. The coefficient matrices must obey the
following dimensions: | Matrix | Num Rows | Num Columns |
<a href="#id27"><span class="problematic" id="id28">|:-------:|</span></a>:———–:<a href="#id29"><span class="problematic" id="id30">|:-----------:|</span></a> | A | num states | num states
| | B | num states | num inputs | | C | num outputs | num states | | D
| num outputs | num inputs |</p>
<p>Empty matrices are treated as zero matrices with the appropriate
number of rows and columns.</p>
<p>Subclasses must use the protected constructor, not this one.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearTransformDensity</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></p>
<p>Performs linear transformation on the random signal w_in as w_out =
A*w_in + b. The user can obtain the probability density of w_out. When
the class is instantiated with autodiff scalar, the user can also
obtain the gradient of the probability density of w_out.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">w_in&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">A&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">b&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>LinearTransformDensity</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; w_out</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; w_out_density</td></tr></table></td></tr></table><p>The <code class="docutils literal notranslate"><span class="pre">b</span></code> port can remain disconnected, in which case it defaults to
zero.</p>
<p><code class="docutils literal notranslate"><span class="pre">A</span></code> should be a matrix using a column-major order.</p>
<p>The user should make sure that the input port <code class="docutils literal notranslate"><span class="pre">w_in</span></code> is connected
from the output port of a RandomSource with the same distribution. A
recommended way is to use <code class="docutils literal notranslate"><span class="pre">AddRandomInputs()</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The code cannot verify that the distribution type of w_in matches
between where w_in comes from and the w_in input port of this
system. This class will quietly produce incorrect behavior if the
distribution types don’t match.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>stochastic_systems</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">LinearTransformDensity_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearTransformDensity.__init__(self:</span> <span class="pre">pydrake.systems.primitives.LinearTransformDensity,</span> <span class="pre">distribution:</span> <span class="pre">pydrake.common.RandomDistribution,</span> <span class="pre">input_size:</span> <span class="pre">int,</span> <span class="pre">output_size:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">distribution</span></code>:</dt><dd><p>The random input w_in should satisfy this distribution.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">input_size</span></code>:</dt><dd><p>The dimension of the input w_in.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">output_size</span></code>:</dt><dd><p>The dimension of the output w_out.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The matrix A will have <code class="docutils literal notranslate"><span class="pre">output_size</span></code> columns and <code class="docutils literal notranslate"><span class="pre">input_size</span></code>
rows. The vector b will have <code class="docutils literal notranslate"><span class="pre">output_size</span></code> columns.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearTransformDensity.CalcDensity(self:</span> <span class="pre">pydrake.systems.primitives.LinearTransformDensity,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Compute the density (pdf) of a sampled output w_out.</p>
<p>When T=AutoDiffXd, this function computes the gradient of the function
density(w_out_sample). Namely given an output sample, we want to know
how the probability of drawing this sample would change, when the
parameters of the distribution (like A and b) change. Such information
is locally expressed in the gradient. Note this is different from
computing the density of the input.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if A is not an invertible matrix.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearTransformDensity.FixConstantA(self:</span> <span class="pre">pydrake.systems.primitives.LinearTransformDensity,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">A:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.FixedInputPortValue</span></span></dt>
<dd><p>Fix the input port <code class="docutils literal notranslate"><span class="pre">A</span></code> to a constant value in a given context.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context into which A’s value is set.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">A</span></code>:</dt><dd><p>The value to which the port is fixed. The matrix A has num_output
rows and num_input columns, note that A is column-majored.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearTransformDensity.FixConstantB(self:</span> <span class="pre">pydrake.systems.primitives.LinearTransformDensity,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">b:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.FixedInputPortValue</span></span></dt>
<dd><p>Fix the input port <code class="docutils literal notranslate"><span class="pre">b</span></code> to a constant value in a given context.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context into which b’s value is set.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>:</dt><dd><p>The value to which the port is fixed. The vector b has num_output
rows.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearTransformDensity.get_distribution(self:</span> <span class="pre">pydrake.systems.primitives.LinearTransformDensity)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.RandomDistribution</span></span></dt>
<dd><p>Gets the random distribution type.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearTransformDensity.get_input_port_A(self:</span> <span class="pre">pydrake.systems.primitives.LinearTransformDensity)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.InputPort</span></span></dt>
<dd><p>Gets the input port for A.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearTransformDensity.get_input_port_b(self:</span> <span class="pre">pydrake.systems.primitives.LinearTransformDensity)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.InputPort</span></span></dt>
<dd><p>Gets the input port for b.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearTransformDensity.get_input_port_w_in(self:</span> <span class="pre">pydrake.systems.primitives.LinearTransformDensity)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.InputPort</span></span></dt>
<dd><p>Gets the input port for w_in.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearTransformDensity.get_output_port_w_out(self:</span> <span class="pre">pydrake.systems.primitives.LinearTransformDensity)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.OutputPort</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearTransformDensity.get_output_port_w_out_density(self:</span> <span class="pre">pydrake.systems.primitives.LinearTransformDensity)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.OutputPort</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearTransformDensity_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">LinearTransformDensity_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">LinearTransformDensity_[AutoDiffXd]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearTransformDensity_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></code></p>
<p>Performs linear transformation on the random signal w_in as w_out =
A*w_in + b. The user can obtain the probability density of w_out. When
the class is instantiated with autodiff scalar, the user can also
obtain the gradient of the probability density of w_out.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">w_in&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">A&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">b&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>LinearTransformDensity</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; w_out</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; w_out_density</td></tr></table></td></tr></table><p>The <code class="docutils literal notranslate"><span class="pre">b</span></code> port can remain disconnected, in which case it defaults to
zero.</p>
<p><code class="docutils literal notranslate"><span class="pre">A</span></code> should be a matrix using a column-major order.</p>
<p>The user should make sure that the input port <code class="docutils literal notranslate"><span class="pre">w_in</span></code> is connected
from the output port of a RandomSource with the same distribution. A
recommended way is to use <code class="docutils literal notranslate"><span class="pre">AddRandomInputs()</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The code cannot verify that the distribution type of w_in matches
between where w_in comes from and the w_in input port of this
system. This class will quietly produce incorrect behavior if the
distribution types don’t match.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>stochastic_systems</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearTransformDensity_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.systems.primitives.LinearTransformDensity_[AutoDiffXd],</span> <span class="pre">distribution:</span> <span class="pre">pydrake.common.RandomDistribution,</span> <span class="pre">input_size:</span> <span class="pre">int,</span> <span class="pre">output_size:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">distribution</span></code>:</dt><dd><p>The random input w_in should satisfy this distribution.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">input_size</span></code>:</dt><dd><p>The dimension of the input w_in.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">output_size</span></code>:</dt><dd><p>The dimension of the output w_out.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The matrix A will have <code class="docutils literal notranslate"><span class="pre">output_size</span></code> columns and <code class="docutils literal notranslate"><span class="pre">input_size</span></code>
rows. The vector b will have <code class="docutils literal notranslate"><span class="pre">output_size</span></code> columns.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearTransformDensity_[AutoDiffXd].CalcDensity(self:</span> <span class="pre">pydrake.systems.primitives.LinearTransformDensity_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd</span></span></dt>
<dd><p>Compute the density (pdf) of a sampled output w_out.</p>
<p>When T=AutoDiffXd, this function computes the gradient of the function
density(w_out_sample). Namely given an output sample, we want to know
how the probability of drawing this sample would change, when the
parameters of the distribution (like A and b) change. Such information
is locally expressed in the gradient. Note this is different from
computing the density of the input.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if A is not an invertible matrix.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearTransformDensity_[AutoDiffXd].FixConstantA(self:</span> <span class="pre">pydrake.systems.primitives.LinearTransformDensity_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">A:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.FixedInputPortValue</span></span></dt>
<dd><p>Fix the input port <code class="docutils literal notranslate"><span class="pre">A</span></code> to a constant value in a given context.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context into which A’s value is set.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">A</span></code>:</dt><dd><p>The value to which the port is fixed. The matrix A has num_output
rows and num_input columns, note that A is column-majored.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearTransformDensity_[AutoDiffXd].FixConstantB(self:</span> <span class="pre">pydrake.systems.primitives.LinearTransformDensity_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">b:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.FixedInputPortValue</span></span></dt>
<dd><p>Fix the input port <code class="docutils literal notranslate"><span class="pre">b</span></code> to a constant value in a given context.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context into which b’s value is set.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>:</dt><dd><p>The value to which the port is fixed. The vector b has num_output
rows.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearTransformDensity_[AutoDiffXd].get_distribution(self:</span> <span class="pre">pydrake.systems.primitives.LinearTransformDensity_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.RandomDistribution</span></span></dt>
<dd><p>Gets the random distribution type.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearTransformDensity_[AutoDiffXd].get_input_port_A(self:</span> <span class="pre">pydrake.systems.primitives.LinearTransformDensity_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.InputPort_[AutoDiffXd]</span></span></dt>
<dd><p>Gets the input port for A.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearTransformDensity_[AutoDiffXd].get_input_port_b(self:</span> <span class="pre">pydrake.systems.primitives.LinearTransformDensity_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.InputPort_[AutoDiffXd]</span></span></dt>
<dd><p>Gets the input port for b.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearTransformDensity_[AutoDiffXd].get_input_port_w_in(self:</span> <span class="pre">pydrake.systems.primitives.LinearTransformDensity_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.InputPort_[AutoDiffXd]</span></span></dt>
<dd><p>Gets the input port for w_in.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearTransformDensity_[AutoDiffXd].get_output_port_w_out(self:</span> <span class="pre">pydrake.systems.primitives.LinearTransformDensity_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.OutputPort_[AutoDiffXd]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearTransformDensity_[AutoDiffXd].get_output_port_w_out_density(self:</span> <span class="pre">pydrake.systems.primitives.LinearTransformDensity_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.OutputPort_[AutoDiffXd]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LogVectorOutput(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>LogVectorOutput(src: pydrake.systems.framework.OutputPort, builder: pydrake.systems.framework.DiagramBuilder, publish_period: float = 0.0) -&gt; pydrake.systems.primitives.VectorLogSink</p></li>
</ol>
<p>LogVectorOutput provides a convenience function for adding a
VectorLogSink, initialized to the correct size, and connected to an
output in a DiagramBuilder. This overload supports the default set of
publish triggers. See vector_log_sink_default_triggers “default
triggers description”.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">src</span></code>:</dt><dd><p>the output port to attach logging to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">builder</span></code>:</dt><dd><p>the diagram builder.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">publish_period</span></code>:</dt><dd><p>Period that messages will be published (optional). If the publish
period is zero, VectorLogSink will use per-step publishing
instead; see LeafSystem::DeclarePerStepPublishEvent().</p>
</dd>
<dt>Precondition:</dt><dd><p>publish_period is non-negative.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>LogVectorOutput(src: pydrake.systems.framework.OutputPort, builder: pydrake.systems.framework.DiagramBuilder, publish_triggers: set[pydrake.systems.framework.TriggerType], publish_period: float = 0.0) -&gt; pydrake.systems.primitives.VectorLogSink</p></li>
</ol>
<p>LogVectorOutput provides a convenience function for adding a
VectorLogSink, initialized to the correct size, and connected to an
output in a DiagramBuilder. This overload supports the full variety of
publish trigger behavior.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">src</span></code>:</dt><dd><p>the output port to attach logging to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">builder</span></code>:</dt><dd><p>the diagram builder.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">publish_triggers</span></code>:</dt><dd><p>Set of triggers that determine when messages will be published.
Supported TriggerTypes are {kForced, kPeriodic, kPerStep}. Will
throw an error if empty or if unsupported types are provided.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">publish_period</span></code>:</dt><dd><p>Period that messages will be published (optional). publish_period
should only be non-zero if one of the publish_triggers is
kPeriodic.</p>
</dd>
<dt>Precondition:</dt><dd><p>publish_period is non-negative.</p>
</dd>
<dt>Precondition:</dt><dd><p>publish_period &gt; 0 if and only if publish_triggers contains
kPeriodic.</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>LogVectorOutput(src: pydrake.systems.framework.OutputPort_[AutoDiffXd], builder: pydrake.systems.framework.DiagramBuilder_[AutoDiffXd], publish_period: float = 0.0) -&gt; pydrake.systems.primitives.VectorLogSink_[AutoDiffXd]</p></li>
</ol>
<p>LogVectorOutput provides a convenience function for adding a
VectorLogSink, initialized to the correct size, and connected to an
output in a DiagramBuilder. This overload supports the default set of
publish triggers. See vector_log_sink_default_triggers “default
triggers description”.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">src</span></code>:</dt><dd><p>the output port to attach logging to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">builder</span></code>:</dt><dd><p>the diagram builder.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">publish_period</span></code>:</dt><dd><p>Period that messages will be published (optional). If the publish
period is zero, VectorLogSink will use per-step publishing
instead; see LeafSystem::DeclarePerStepPublishEvent().</p>
</dd>
<dt>Precondition:</dt><dd><p>publish_period is non-negative.</p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>LogVectorOutput(src: pydrake.systems.framework.OutputPort_[AutoDiffXd], builder: pydrake.systems.framework.DiagramBuilder_[AutoDiffXd], publish_triggers: set[pydrake.systems.framework.TriggerType], publish_period: float = 0.0) -&gt; pydrake.systems.primitives.VectorLogSink_[AutoDiffXd]</p></li>
</ol>
<p>LogVectorOutput provides a convenience function for adding a
VectorLogSink, initialized to the correct size, and connected to an
output in a DiagramBuilder. This overload supports the full variety of
publish trigger behavior.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">src</span></code>:</dt><dd><p>the output port to attach logging to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">builder</span></code>:</dt><dd><p>the diagram builder.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">publish_triggers</span></code>:</dt><dd><p>Set of triggers that determine when messages will be published.
Supported TriggerTypes are {kForced, kPeriodic, kPerStep}. Will
throw an error if empty or if unsupported types are provided.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">publish_period</span></code>:</dt><dd><p>Period that messages will be published (optional). publish_period
should only be non-zero if one of the publish_triggers is
kPeriodic.</p>
</dd>
<dt>Precondition:</dt><dd><p>publish_period is non-negative.</p>
</dd>
<dt>Precondition:</dt><dd><p>publish_period &gt; 0 if and only if publish_triggers contains
kPeriodic.</p>
</dd>
</dl>
<ol class="arabic simple" start="5">
<li><p>LogVectorOutput(src: pydrake.systems.framework.OutputPort_[Expression], builder: pydrake.systems.framework.DiagramBuilder_[Expression], publish_period: float = 0.0) -&gt; pydrake.systems.primitives.VectorLogSink_[Expression]</p></li>
</ol>
<p>LogVectorOutput provides a convenience function for adding a
VectorLogSink, initialized to the correct size, and connected to an
output in a DiagramBuilder. This overload supports the default set of
publish triggers. See vector_log_sink_default_triggers “default
triggers description”.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">src</span></code>:</dt><dd><p>the output port to attach logging to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">builder</span></code>:</dt><dd><p>the diagram builder.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">publish_period</span></code>:</dt><dd><p>Period that messages will be published (optional). If the publish
period is zero, VectorLogSink will use per-step publishing
instead; see LeafSystem::DeclarePerStepPublishEvent().</p>
</dd>
<dt>Precondition:</dt><dd><p>publish_period is non-negative.</p>
</dd>
</dl>
<ol class="arabic simple" start="6">
<li><p>LogVectorOutput(src: pydrake.systems.framework.OutputPort_[Expression], builder: pydrake.systems.framework.DiagramBuilder_[Expression], publish_triggers: set[pydrake.systems.framework.TriggerType], publish_period: float = 0.0) -&gt; pydrake.systems.primitives.VectorLogSink_[Expression]</p></li>
</ol>
<p>LogVectorOutput provides a convenience function for adding a
VectorLogSink, initialized to the correct size, and connected to an
output in a DiagramBuilder. This overload supports the full variety of
publish trigger behavior.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">src</span></code>:</dt><dd><p>the output port to attach logging to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">builder</span></code>:</dt><dd><p>the diagram builder.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">publish_triggers</span></code>:</dt><dd><p>Set of triggers that determine when messages will be published.
Supported TriggerTypes are {kForced, kPeriodic, kPerStep}. Will
throw an error if empty or if unsupported types are provided.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">publish_period</span></code>:</dt><dd><p>Period that messages will be published (optional). publish_period
should only be non-zero if one of the publish_triggers is
kPeriodic.</p>
</dd>
<dt>Precondition:</dt><dd><p>publish_period is non-negative.</p>
</dd>
<dt>Precondition:</dt><dd><p>publish_period &gt; 0 if and only if publish_triggers contains
kPeriodic.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MatrixGain</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.primitives.LinearSystem</span></code></p>
<p>A system that specializes LinearSystem by setting coefficient matrices
<code class="docutils literal notranslate"><span class="pre">A</span></code>, <cite>B</cite>, and <code class="docutils literal notranslate"><span class="pre">C</span></code> to all be zero. Thus, the only non-zero
coefficient matrix is <code class="docutils literal notranslate"><span class="pre">D</span></code>. Specifically, given an input signal <code class="docutils literal notranslate"><span class="pre">u</span></code>
and a state <code class="docutils literal notranslate"><span class="pre">x</span></code>, the output of this system, <code class="docutils literal notranslate"><span class="pre">y</span></code>, is:</p>
<div class="math notranslate nohighlight">
\[y = D u\]</div>
<p>name: MatrixGain input_ports: - u0 output_ports: - y0</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AffineSystem</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>LinearSystem</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">MatrixGain_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MatrixGain.__init__(self:</span> <span class="pre">pydrake.systems.primitives.MatrixGain,</span> <span class="pre">D:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>A constructor where the gain matrix <code class="docutils literal notranslate"><span class="pre">D</span></code> is <code class="docutils literal notranslate"><span class="pre">D</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MatrixGain_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">MatrixGain_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">MatrixGain_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">MatrixGain_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MatrixGain_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.primitives.LinearSystem_[AutoDiffXd]</span></code></p>
<p>A system that specializes LinearSystem by setting coefficient matrices
<code class="docutils literal notranslate"><span class="pre">A</span></code>, <cite>B</cite>, and <code class="docutils literal notranslate"><span class="pre">C</span></code> to all be zero. Thus, the only non-zero
coefficient matrix is <code class="docutils literal notranslate"><span class="pre">D</span></code>. Specifically, given an input signal <code class="docutils literal notranslate"><span class="pre">u</span></code>
and a state <code class="docutils literal notranslate"><span class="pre">x</span></code>, the output of this system, <code class="docutils literal notranslate"><span class="pre">y</span></code>, is:</p>
<div class="math notranslate nohighlight">
\[y = D u\]</div>
<p>name: MatrixGain input_ports: - u0 output_ports: - y0</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AffineSystem</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>LinearSystem</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MatrixGain_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.systems.primitives.MatrixGain_[AutoDiffXd],</span> <span class="pre">D:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>A constructor where the gain matrix <code class="docutils literal notranslate"><span class="pre">D</span></code> is <code class="docutils literal notranslate"><span class="pre">D</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MatrixGain_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.primitives.LinearSystem_[Expression]</span></code></p>
<p>A system that specializes LinearSystem by setting coefficient matrices
<code class="docutils literal notranslate"><span class="pre">A</span></code>, <cite>B</cite>, and <code class="docutils literal notranslate"><span class="pre">C</span></code> to all be zero. Thus, the only non-zero
coefficient matrix is <code class="docutils literal notranslate"><span class="pre">D</span></code>. Specifically, given an input signal <code class="docutils literal notranslate"><span class="pre">u</span></code>
and a state <code class="docutils literal notranslate"><span class="pre">x</span></code>, the output of this system, <code class="docutils literal notranslate"><span class="pre">y</span></code>, is:</p>
<div class="math notranslate nohighlight">
\[y = D u\]</div>
<p>name: MatrixGain input_ports: - u0 output_ports: - y0</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AffineSystem</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>LinearSystem</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MatrixGain_[Expression].__init__(self:</span> <span class="pre">pydrake.systems.primitives.MatrixGain_[Expression],</span> <span class="pre">D:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>A constructor where the gain matrix <code class="docutils literal notranslate"><span class="pre">D</span></code> is <code class="docutils literal notranslate"><span class="pre">D</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></p>
<p>The MultilayerPerceptron (MLP) is one of the most common forms of
neural networks used in reinforcement learning (RL) today. This
implementation provides a System interface to distinguish between the
network’s inputs and outputs (via ports), and the parameters, which
are stored in the Context.</p>
<p>Each layer of the network is implemented as xₙ₊₁ = σ(Wₙxₙ+bₙ), where
xₙ is the output of the preceding layer, W are the weights, b are the
biases, and σ() is the activation function. We additionally use the
shorthand x to denote the input layer and y to denote the output
layer: y=xₘ for an m-layer network.</p>
<p>Note: For very large-scale neural network implementations, consider
using a GPU-accelerated machine learning library like PyTorch,
TensorFlow, or JAX. But most MLPs used in controls / RL are actually
quite small. For those networks, the cost of transferring
values/gradients from Drake to e.g. PyTorch is likely not worth the
benefits. Another possible workflow might be to train a network in
PyTorch, but then to copy the weights into an instance of this class
for simulation.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">x&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>MultilayerPerceptron</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y</td></tr></table></td></tr></table><div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">MultilayerPerceptron_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.primitives.MultilayerPerceptron, layers: list[int], activation_type: pydrake.systems.primitives.PerceptronActivationType = &lt;PerceptronActivationType.kTanh: 2&gt;) -&gt; None</p></li>
</ol>
<p>Constructs the MLP with the same activation type for every layer
(except the output).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">layers</span></code>:</dt><dd><p>is the number of elements in each layer of the network (the
activation function does <em>not</em> count as an additional layer). The
first element specifies the number of inputs, and the last layer
specifies the number of outputs.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">activation_type</span></code>:</dt><dd><p>specifies an activation function, σ(), used in <em>every</em> hidden
layer of the network. kIdentity will be used for the output.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.primitives.MultilayerPerceptron, layers: list[int], activation_types: list[pydrake.systems.primitives.PerceptronActivationType]) -&gt; None</p></li>
</ol>
<p>Constructs the MLP with an activation_type specified for each
non-input layer.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">layers</span></code>:</dt><dd><p>is the number of elements in each layer of the network (the
activation function does <em>not</em> count as an additional layer). The
first element specifies the number of inputs, and the last layer
specifies the number of outputs.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">activation_types</span></code>:</dt><dd><p>specifies the activation function, σ(), used in <em>each</em> non-input
layer of the network (including the last layer).</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">activation_types</span></code> should have one less element than <code class="docutils literal notranslate"><span class="pre">layers</span></code>.</p>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.systems.primitives.MultilayerPerceptron, use_sin_cos_for_input: list[bool], remaining_layers: list[int], activation_types: list[pydrake.systems.primitives.PerceptronActivationType]) -&gt; None</p></li>
</ol>
<p>Constructs the MLP with an additional option to transform the input
vector so that the function is periodic in 2π.</p>
<p>For instance, for a rotary joint on a robot, this could be used to
apply the transform [x, y] =&gt; [sin x, cos x, y]. This would be
accomplished by passing <code class="docutils literal notranslate"><span class="pre">use_sin_cos_for_input</span> <span class="pre">=</span> <span class="pre">[true,</span> <span class="pre">false]</span></code>.</p>
<p>Note that when this transformation is applied, <code class="docutils literal notranslate"><span class="pre">num_inputs()</span> <span class="pre">!=</span>
<span class="pre">layers()[0]</span></code>. <cite>num_inputs() == 2 != layers()[0] == 3</cite>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">use_sin_cos_for_input</span></code>:</dt><dd><p>is a boolean vector that determines whether the sin/cos transform
is applied to each element.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">remaining_layers</span></code>:</dt><dd><p>is the number of elements in each layer of the network (the
activation function does <em>not</em> count as an additional layer). The
first element specifies the size of the first hidden layer, and
the last layer specifies the number of outputs.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">activation_types</span></code>:</dt><dd><p>specifies the activation function, σ(), used in <em>each</em> non-input
layer of the network (including the last layer).</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">activation_types</span></code> should have the same number of elements as
<code class="docutils literal notranslate"><span class="pre">remaining_layers</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron.activation_type(self:</span> <span class="pre">pydrake.systems.primitives.MultilayerPerceptron,</span> <span class="pre">layer:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.primitives.PerceptronActivationType</span></span></dt>
<dd><p>Returns the type of the activation function, σ(), used in the MLP.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron.Backpropagation(self:</span> <span class="pre">pydrake.systems.primitives.MultilayerPerceptron,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">X:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous],</span> <span class="pre">loss:</span> <span class="pre">Callable[[numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous],</span> <span class="pre">Optional[numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.writeable,</span> <span class="pre">flags.f_contiguous]]],</span> <span class="pre">float],</span> <span class="pre">dloss_dparams:</span> <span class="pre">Optional[numpy.ndarray[numpy.float64[m,</span> <span class="pre">1],</span> <span class="pre">flags.writeable]])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Implements the Backpropagation algorithm for the MLP to compute the
gradients of a scalar loss function with respect to the network
parameters.</p>
<p>Note: The class uses the System Cache to minimize the number of
dynamic memory allocations for repeated calls to this function with
the same sized <code class="docutils literal notranslate"><span class="pre">X</span></code>. Changing the batch size between calls to this
method or BatchOutput requires memory allocations.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X</span></code>:</dt><dd><p>is a batch input, with one input per column.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">loss</span></code>:</dt><dd><p>is a scalar loss function, where <code class="docutils literal notranslate"><span class="pre">Y</span></code> is the columnwise batch
output of the network. It should return the scalar loss and set
<code class="docutils literal notranslate"><span class="pre">dloss_dY</span></code>, the derivatives of the loss with respect to <code class="docutils literal notranslate"><span class="pre">Y</span></code>,
which is pre-allocated to be the same size as <code class="docutils literal notranslate"><span class="pre">Y</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">dloss_dparams</span></code>:</dt><dd><p>are the gradients computed. We take the storage as an input
argument to avoid memory allocations inside the algorithm.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the calculated loss.</p>
</dd>
</dl>
<p>Note: It is expected that this algorithm will be used with T=double.
It uses analytical gradients; AutoDiffXd is not required.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron.BackpropagationMeanSquaredError(self:</span> <span class="pre">pydrake.systems.primitives.MultilayerPerceptron,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">X:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous],</span> <span class="pre">Y_desired:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous],</span> <span class="pre">dloss_dparams:</span> <span class="pre">Optional[numpy.ndarray[numpy.float64[m,</span> <span class="pre">1],</span> <span class="pre">flags.writeable]])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Calls Backpropagation with the mean-squared error loss function: loss
= 1/N ∑ᵢ <a href="#id1"><span class="problematic" id="id2">|</span></a>yᵢ−yᵢᵈ|², where yᵈ is the desired values for y. See
Backpropagation for details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron.BatchOutput(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>BatchOutput(self: pydrake.systems.primitives.MultilayerPerceptron, context: pydrake.systems.framework.Context, X: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], Y: Optional[numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.f_contiguous]], dYdX: Optional[numpy.ndarray[numpy.float64[m, n], flags.writeable, flags.f_contiguous]] = None) -&gt; None</p></li>
</ol>
<p>Evaluates the batch output for the MLP with a batch input vector. Each
column of <code class="docutils literal notranslate"><span class="pre">X</span></code> represents an input, and each column of <code class="docutils literal notranslate"><span class="pre">Y</span></code> will be
assigned the corresponding output.</p>
<p>If the output layer of the network has size 1 (scalar output), and
<code class="docutils literal notranslate"><span class="pre">dYdX</span> <span class="pre">!=</span> <span class="pre">nullptr</span></code>, then <code class="docutils literal notranslate"><span class="pre">dYdX</span></code> is populated with the batch
gradients of the scalar output <code class="docutils literal notranslate"><span class="pre">Y</span></code> relative to the input <code class="docutils literal notranslate"><span class="pre">X</span></code>: the
(i,j)th element represents the gradient dY(0,j) / dX(i,j).</p>
<p>Note: In python, use numpy.asfortranarray() to allocate the writeable
matrices <code class="docutils literal notranslate"><span class="pre">Y</span></code> and (if needed) <code class="docutils literal notranslate"><span class="pre">dYdX</span></code>.</p>
<p>This methods shares the cache with Backpropagation. If the size of X
changes here or in Backpropagation, it may force dynamic memory
allocations.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if dYdX != nullptr and the network has more than one</strong> – </p></li>
<li><p><strong>output.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>BatchOutput(self: pydrake.systems.primitives.MultilayerPerceptron, context: pydrake.systems.framework.Context, X: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]) -&gt; numpy.ndarray[numpy.float64[m, n]]</p></li>
</ol>
<p>Evaluates the batch output for the MLP with a batch input vector. See BatchOutput(context, X, Y) for a version that can avoid dynamic memory allocations of Y (e.g. if this is used inside an optimization loop).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron.GetBiases(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetBiases(self: pydrake.systems.primitives.MultilayerPerceptron, context: pydrake.systems.framework.Context, layer: int) -&gt; numpy.ndarray[numpy.float64[m, 1]]</p></li>
</ol>
<p>Returns the biases used in the mapping from <code class="docutils literal notranslate"><span class="pre">layer</span></code> to <code class="docutils literal notranslate"><span class="pre">layer+1</span></code>.</p>
<ol class="arabic simple" start="2">
<li><p>GetBiases(self: pydrake.systems.primitives.MultilayerPerceptron, params: numpy.ndarray[numpy.float64[m, 1]], layer: int) -&gt; numpy.ndarray[numpy.float64[m, 1]]</p></li>
</ol>
<p>Returns the biases in <code class="docutils literal notranslate"><span class="pre">params</span></code> used in the mapping from <code class="docutils literal notranslate"><span class="pre">layer</span></code> to
<code class="docutils literal notranslate"><span class="pre">layer+1</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron.GetMutableParameters(self:</span> <span class="pre">pydrake.systems.primitives.MultilayerPerceptron,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1],</span> <span class="pre">flags.writeable]</span></span></dt>
<dd><p>Returns a mutable reference to all of the parameters (weights and
biases) as a single vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron.GetParameters(self:</span> <span class="pre">pydrake.systems.primitives.MultilayerPerceptron,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns a reference to all of the parameters (weights and biases) as a
single vector. Use GetWeights and GetBiases to extract the components.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron.GetWeights(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetWeights(self: pydrake.systems.primitives.MultilayerPerceptron, context: pydrake.systems.framework.Context, layer: int) -&gt; numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]</p></li>
</ol>
<p>Returns the weights used in the mapping from <code class="docutils literal notranslate"><span class="pre">layer</span></code> to <code class="docutils literal notranslate"><span class="pre">layer+1</span></code>.</p>
<ol class="arabic simple" start="2">
<li><p>GetWeights(self: pydrake.systems.primitives.MultilayerPerceptron, params: numpy.ndarray[numpy.float64[m, 1]], layer: int) -&gt; numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]</p></li>
</ol>
<p>Returns the weights in <code class="docutils literal notranslate"><span class="pre">params</span></code> used in the mapping from <code class="docutils literal notranslate"><span class="pre">layer</span></code>
to <code class="docutils literal notranslate"><span class="pre">layer+1</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron.layers(self:</span> <span class="pre">pydrake.systems.primitives.MultilayerPerceptron)</span> <span class="pre">-&gt;</span> <span class="pre">list[int]</span></span></dt>
<dd><p>Returns the number of elements in each layer of the network.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron.num_parameters(self:</span> <span class="pre">pydrake.systems.primitives.MultilayerPerceptron)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the total number of parameters in the network, including all
weights and biases.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron.SetBiases(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetBiases(self: pydrake.systems.primitives.MultilayerPerceptron, context: pydrake.systems.framework.Context, layer: int, b: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the biases in the <code class="docutils literal notranslate"><span class="pre">context</span></code> used in the mapping from <code class="docutils literal notranslate"><span class="pre">layer</span></code>
to <code class="docutils literal notranslate"><span class="pre">layer+1</span></code>.</p>
<ol class="arabic simple" start="2">
<li><p>SetBiases(self: pydrake.systems.primitives.MultilayerPerceptron, params: Optional[numpy.ndarray[numpy.float64[m, 1], flags.writeable]], layer: int, b: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the biases in <code class="docutils literal notranslate"><span class="pre">params</span></code> used in the mapping from <code class="docutils literal notranslate"><span class="pre">layer</span></code> to
<code class="docutils literal notranslate"><span class="pre">layer+1</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron.SetParameters(self:</span> <span class="pre">pydrake.systems.primitives.MultilayerPerceptron,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">params:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets all of the parameters in the network (weights and biases) using a
single vector. Use SetWeights and SetBiases to extract the components.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron.SetWeights(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetWeights(self: pydrake.systems.primitives.MultilayerPerceptron, context: pydrake.systems.framework.Context, layer: int, W: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]) -&gt; None</p></li>
</ol>
<p>Sets the weights in the <code class="docutils literal notranslate"><span class="pre">context</span></code> used in the mapping from <code class="docutils literal notranslate"><span class="pre">layer</span></code>
to <code class="docutils literal notranslate"><span class="pre">layer+1</span></code>.</p>
<ol class="arabic simple" start="2">
<li><p>SetWeights(self: pydrake.systems.primitives.MultilayerPerceptron, params: Optional[numpy.ndarray[numpy.float64[m, 1], flags.writeable]], layer: int, W: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]) -&gt; None</p></li>
</ol>
<p>Sets the weights in <code class="docutils literal notranslate"><span class="pre">params</span></code> used in the mapping from <code class="docutils literal notranslate"><span class="pre">layer</span></code> to
<code class="docutils literal notranslate"><span class="pre">layer+1</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">MultilayerPerceptron_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">MultilayerPerceptron_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">MultilayerPerceptron_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></code></p>
<p>The MultilayerPerceptron (MLP) is one of the most common forms of
neural networks used in reinforcement learning (RL) today. This
implementation provides a System interface to distinguish between the
network’s inputs and outputs (via ports), and the parameters, which
are stored in the Context.</p>
<p>Each layer of the network is implemented as xₙ₊₁ = σ(Wₙxₙ+bₙ), where
xₙ is the output of the preceding layer, W are the weights, b are the
biases, and σ() is the activation function. We additionally use the
shorthand x to denote the input layer and y to denote the output
layer: y=xₘ for an m-layer network.</p>
<p>Note: For very large-scale neural network implementations, consider
using a GPU-accelerated machine learning library like PyTorch,
TensorFlow, or JAX. But most MLPs used in controls / RL are actually
quite small. For those networks, the cost of transferring
values/gradients from Drake to e.g. PyTorch is likely not worth the
benefits. Another possible workflow might be to train a network in
PyTorch, but then to copy the weights into an instance of this class
for simulation.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">x&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>MultilayerPerceptron</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y</td></tr></table></td></tr></table><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.primitives.MultilayerPerceptron_[AutoDiffXd], layers: list[int], activation_type: pydrake.systems.primitives.PerceptronActivationType = &lt;PerceptronActivationType.kTanh: 2&gt;) -&gt; None</p></li>
</ol>
<p>Constructs the MLP with the same activation type for every layer
(except the output).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">layers</span></code>:</dt><dd><p>is the number of elements in each layer of the network (the
activation function does <em>not</em> count as an additional layer). The
first element specifies the number of inputs, and the last layer
specifies the number of outputs.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">activation_type</span></code>:</dt><dd><p>specifies an activation function, σ(), used in <em>every</em> hidden
layer of the network. kIdentity will be used for the output.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.primitives.MultilayerPerceptron_[AutoDiffXd], layers: list[int], activation_types: list[pydrake.systems.primitives.PerceptronActivationType]) -&gt; None</p></li>
</ol>
<p>Constructs the MLP with an activation_type specified for each
non-input layer.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">layers</span></code>:</dt><dd><p>is the number of elements in each layer of the network (the
activation function does <em>not</em> count as an additional layer). The
first element specifies the number of inputs, and the last layer
specifies the number of outputs.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">activation_types</span></code>:</dt><dd><p>specifies the activation function, σ(), used in <em>each</em> non-input
layer of the network (including the last layer).</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">activation_types</span></code> should have one less element than <code class="docutils literal notranslate"><span class="pre">layers</span></code>.</p>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.systems.primitives.MultilayerPerceptron_[AutoDiffXd], use_sin_cos_for_input: list[bool], remaining_layers: list[int], activation_types: list[pydrake.systems.primitives.PerceptronActivationType]) -&gt; None</p></li>
</ol>
<p>Constructs the MLP with an additional option to transform the input
vector so that the function is periodic in 2π.</p>
<p>For instance, for a rotary joint on a robot, this could be used to
apply the transform [x, y] =&gt; [sin x, cos x, y]. This would be
accomplished by passing <code class="docutils literal notranslate"><span class="pre">use_sin_cos_for_input</span> <span class="pre">=</span> <span class="pre">[true,</span> <span class="pre">false]</span></code>.</p>
<p>Note that when this transformation is applied, <code class="docutils literal notranslate"><span class="pre">num_inputs()</span> <span class="pre">!=</span>
<span class="pre">layers()[0]</span></code>. <cite>num_inputs() == 2 != layers()[0] == 3</cite>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">use_sin_cos_for_input</span></code>:</dt><dd><p>is a boolean vector that determines whether the sin/cos transform
is applied to each element.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">remaining_layers</span></code>:</dt><dd><p>is the number of elements in each layer of the network (the
activation function does <em>not</em> count as an additional layer). The
first element specifies the size of the first hidden layer, and
the last layer specifies the number of outputs.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">activation_types</span></code>:</dt><dd><p>specifies the activation function, σ(), used in <em>each</em> non-input
layer of the network (including the last layer).</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">activation_types</span></code> should have the same number of elements as
<code class="docutils literal notranslate"><span class="pre">remaining_layers</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron_[AutoDiffXd].activation_type(self:</span> <span class="pre">pydrake.systems.primitives.MultilayerPerceptron_[AutoDiffXd],</span> <span class="pre">layer:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.primitives.PerceptronActivationType</span></span></dt>
<dd><p>Returns the type of the activation function, σ(), used in the MLP.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron_[AutoDiffXd].Backpropagation(self:</span> <span class="pre">pydrake.systems.primitives.MultilayerPerceptron_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">X:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous],</span> <span class="pre">loss:</span> <span class="pre">Callable[[numpy.ndarray[object[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous],</span> <span class="pre">Optional[numpy.ndarray[object[m,</span> <span class="pre">n],</span> <span class="pre">flags.writeable,</span> <span class="pre">flags.f_contiguous]]],</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd],</span> <span class="pre">dloss_dparams:</span> <span class="pre">Optional[numpy.ndarray[object[m,</span> <span class="pre">1],</span> <span class="pre">flags.writeable]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd</span></span></dt>
<dd><p>Implements the Backpropagation algorithm for the MLP to compute the
gradients of a scalar loss function with respect to the network
parameters.</p>
<p>Note: The class uses the System Cache to minimize the number of
dynamic memory allocations for repeated calls to this function with
the same sized <code class="docutils literal notranslate"><span class="pre">X</span></code>. Changing the batch size between calls to this
method or BatchOutput requires memory allocations.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X</span></code>:</dt><dd><p>is a batch input, with one input per column.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">loss</span></code>:</dt><dd><p>is a scalar loss function, where <code class="docutils literal notranslate"><span class="pre">Y</span></code> is the columnwise batch
output of the network. It should return the scalar loss and set
<code class="docutils literal notranslate"><span class="pre">dloss_dY</span></code>, the derivatives of the loss with respect to <code class="docutils literal notranslate"><span class="pre">Y</span></code>,
which is pre-allocated to be the same size as <code class="docutils literal notranslate"><span class="pre">Y</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">dloss_dparams</span></code>:</dt><dd><p>are the gradients computed. We take the storage as an input
argument to avoid memory allocations inside the algorithm.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the calculated loss.</p>
</dd>
</dl>
<p>Note: It is expected that this algorithm will be used with T=double.
It uses analytical gradients; AutoDiffXd is not required.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron_[AutoDiffXd].BackpropagationMeanSquaredError(self:</span> <span class="pre">pydrake.systems.primitives.MultilayerPerceptron_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">X:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous],</span> <span class="pre">Y_desired:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous],</span> <span class="pre">dloss_dparams:</span> <span class="pre">Optional[numpy.ndarray[object[m,</span> <span class="pre">1],</span> <span class="pre">flags.writeable]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd</span></span></dt>
<dd><p>Calls Backpropagation with the mean-squared error loss function: loss
= 1/N ∑ᵢ <a href="#id3"><span class="problematic" id="id4">|</span></a>yᵢ−yᵢᵈ|², where yᵈ is the desired values for y. See
Backpropagation for details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron_[AutoDiffXd].BatchOutput(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>BatchOutput(self: pydrake.systems.primitives.MultilayerPerceptron_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], X: numpy.ndarray[object[m, n], flags.f_contiguous], Y: Optional[numpy.ndarray[object[m, n], flags.writeable, flags.f_contiguous]], dYdX: Optional[numpy.ndarray[object[m, n], flags.writeable, flags.f_contiguous]] = None) -&gt; None</p></li>
</ol>
<p>Evaluates the batch output for the MLP with a batch input vector. Each
column of <code class="docutils literal notranslate"><span class="pre">X</span></code> represents an input, and each column of <code class="docutils literal notranslate"><span class="pre">Y</span></code> will be
assigned the corresponding output.</p>
<p>If the output layer of the network has size 1 (scalar output), and
<code class="docutils literal notranslate"><span class="pre">dYdX</span> <span class="pre">!=</span> <span class="pre">nullptr</span></code>, then <code class="docutils literal notranslate"><span class="pre">dYdX</span></code> is populated with the batch
gradients of the scalar output <code class="docutils literal notranslate"><span class="pre">Y</span></code> relative to the input <code class="docutils literal notranslate"><span class="pre">X</span></code>: the
(i,j)th element represents the gradient dY(0,j) / dX(i,j).</p>
<p>Note: In python, use numpy.asfortranarray() to allocate the writeable
matrices <code class="docutils literal notranslate"><span class="pre">Y</span></code> and (if needed) <code class="docutils literal notranslate"><span class="pre">dYdX</span></code>.</p>
<p>This methods shares the cache with Backpropagation. If the size of X
changes here or in Backpropagation, it may force dynamic memory
allocations.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if dYdX != nullptr and the network has more than one</strong> – </p></li>
<li><p><strong>output.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>BatchOutput(self: pydrake.systems.primitives.MultilayerPerceptron_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], X: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; numpy.ndarray[object[m, n]]</p></li>
</ol>
<p>Evaluates the batch output for the MLP with a batch input vector. See BatchOutput(context, X, Y) for a version that can avoid dynamic memory allocations of Y (e.g. if this is used inside an optimization loop).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron_[AutoDiffXd].GetBiases(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetBiases(self: pydrake.systems.primitives.MultilayerPerceptron_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], layer: int) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Returns the biases used in the mapping from <code class="docutils literal notranslate"><span class="pre">layer</span></code> to <code class="docutils literal notranslate"><span class="pre">layer+1</span></code>.</p>
<ol class="arabic simple" start="2">
<li><p>GetBiases(self: pydrake.systems.primitives.MultilayerPerceptron_[AutoDiffXd], params: numpy.ndarray[object[m, 1]], layer: int) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Returns the biases in <code class="docutils literal notranslate"><span class="pre">params</span></code> used in the mapping from <code class="docutils literal notranslate"><span class="pre">layer</span></code> to
<code class="docutils literal notranslate"><span class="pre">layer+1</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron_[AutoDiffXd].GetMutableParameters(self:</span> <span class="pre">pydrake.systems.primitives.MultilayerPerceptron_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1],</span> <span class="pre">flags.writeable]</span></span></dt>
<dd><p>Returns a mutable reference to all of the parameters (weights and
biases) as a single vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron_[AutoDiffXd].GetParameters(self:</span> <span class="pre">pydrake.systems.primitives.MultilayerPerceptron_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns a reference to all of the parameters (weights and biases) as a
single vector. Use GetWeights and GetBiases to extract the components.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron_[AutoDiffXd].GetWeights(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetWeights(self: pydrake.systems.primitives.MultilayerPerceptron_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], layer: int) -&gt; numpy.ndarray[object[m, n], flags.f_contiguous]</p></li>
</ol>
<p>Returns the weights used in the mapping from <code class="docutils literal notranslate"><span class="pre">layer</span></code> to <code class="docutils literal notranslate"><span class="pre">layer+1</span></code>.</p>
<ol class="arabic simple" start="2">
<li><p>GetWeights(self: pydrake.systems.primitives.MultilayerPerceptron_[AutoDiffXd], params: numpy.ndarray[object[m, 1]], layer: int) -&gt; numpy.ndarray[object[m, n], flags.f_contiguous]</p></li>
</ol>
<p>Returns the weights in <code class="docutils literal notranslate"><span class="pre">params</span></code> used in the mapping from <code class="docutils literal notranslate"><span class="pre">layer</span></code>
to <code class="docutils literal notranslate"><span class="pre">layer+1</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron_[AutoDiffXd].layers(self:</span> <span class="pre">pydrake.systems.primitives.MultilayerPerceptron_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">list[int]</span></span></dt>
<dd><p>Returns the number of elements in each layer of the network.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron_[AutoDiffXd].num_parameters(self:</span> <span class="pre">pydrake.systems.primitives.MultilayerPerceptron_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the total number of parameters in the network, including all
weights and biases.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron_[AutoDiffXd].SetBiases(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetBiases(self: pydrake.systems.primitives.MultilayerPerceptron_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], layer: int, b: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the biases in the <code class="docutils literal notranslate"><span class="pre">context</span></code> used in the mapping from <code class="docutils literal notranslate"><span class="pre">layer</span></code>
to <code class="docutils literal notranslate"><span class="pre">layer+1</span></code>.</p>
<ol class="arabic simple" start="2">
<li><p>SetBiases(self: pydrake.systems.primitives.MultilayerPerceptron_[AutoDiffXd], params: Optional[numpy.ndarray[object[m, 1], flags.writeable]], layer: int, b: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the biases in <code class="docutils literal notranslate"><span class="pre">params</span></code> used in the mapping from <code class="docutils literal notranslate"><span class="pre">layer</span></code> to
<code class="docutils literal notranslate"><span class="pre">layer+1</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron_[AutoDiffXd].SetParameters(self:</span> <span class="pre">pydrake.systems.primitives.MultilayerPerceptron_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">params:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets all of the parameters in the network (weights and biases) using a
single vector. Use SetWeights and SetBiases to extract the components.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron_[AutoDiffXd].SetWeights(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetWeights(self: pydrake.systems.primitives.MultilayerPerceptron_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], layer: int, W: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; None</p></li>
</ol>
<p>Sets the weights in the <code class="docutils literal notranslate"><span class="pre">context</span></code> used in the mapping from <code class="docutils literal notranslate"><span class="pre">layer</span></code>
to <code class="docutils literal notranslate"><span class="pre">layer+1</span></code>.</p>
<ol class="arabic simple" start="2">
<li><p>SetWeights(self: pydrake.systems.primitives.MultilayerPerceptron_[AutoDiffXd], params: Optional[numpy.ndarray[object[m, 1], flags.writeable]], layer: int, W: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; None</p></li>
</ol>
<p>Sets the weights in <code class="docutils literal notranslate"><span class="pre">params</span></code> used in the mapping from <code class="docutils literal notranslate"><span class="pre">layer</span></code> to
<code class="docutils literal notranslate"><span class="pre">layer+1</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[Expression]</span></code></p>
<p>The MultilayerPerceptron (MLP) is one of the most common forms of
neural networks used in reinforcement learning (RL) today. This
implementation provides a System interface to distinguish between the
network’s inputs and outputs (via ports), and the parameters, which
are stored in the Context.</p>
<p>Each layer of the network is implemented as xₙ₊₁ = σ(Wₙxₙ+bₙ), where
xₙ is the output of the preceding layer, W are the weights, b are the
biases, and σ() is the activation function. We additionally use the
shorthand x to denote the input layer and y to denote the output
layer: y=xₘ for an m-layer network.</p>
<p>Note: For very large-scale neural network implementations, consider
using a GPU-accelerated machine learning library like PyTorch,
TensorFlow, or JAX. But most MLPs used in controls / RL are actually
quite small. For those networks, the cost of transferring
values/gradients from Drake to e.g. PyTorch is likely not worth the
benefits. Another possible workflow might be to train a network in
PyTorch, but then to copy the weights into an instance of this class
for simulation.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">x&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>MultilayerPerceptron</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y</td></tr></table></td></tr></table><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.primitives.MultilayerPerceptron_[Expression], layers: list[int], activation_type: pydrake.systems.primitives.PerceptronActivationType = &lt;PerceptronActivationType.kTanh: 2&gt;) -&gt; None</p></li>
</ol>
<p>Constructs the MLP with the same activation type for every layer
(except the output).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">layers</span></code>:</dt><dd><p>is the number of elements in each layer of the network (the
activation function does <em>not</em> count as an additional layer). The
first element specifies the number of inputs, and the last layer
specifies the number of outputs.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">activation_type</span></code>:</dt><dd><p>specifies an activation function, σ(), used in <em>every</em> hidden
layer of the network. kIdentity will be used for the output.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.primitives.MultilayerPerceptron_[Expression], layers: list[int], activation_types: list[pydrake.systems.primitives.PerceptronActivationType]) -&gt; None</p></li>
</ol>
<p>Constructs the MLP with an activation_type specified for each
non-input layer.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">layers</span></code>:</dt><dd><p>is the number of elements in each layer of the network (the
activation function does <em>not</em> count as an additional layer). The
first element specifies the number of inputs, and the last layer
specifies the number of outputs.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">activation_types</span></code>:</dt><dd><p>specifies the activation function, σ(), used in <em>each</em> non-input
layer of the network (including the last layer).</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">activation_types</span></code> should have one less element than <code class="docutils literal notranslate"><span class="pre">layers</span></code>.</p>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.systems.primitives.MultilayerPerceptron_[Expression], use_sin_cos_for_input: list[bool], remaining_layers: list[int], activation_types: list[pydrake.systems.primitives.PerceptronActivationType]) -&gt; None</p></li>
</ol>
<p>Constructs the MLP with an additional option to transform the input
vector so that the function is periodic in 2π.</p>
<p>For instance, for a rotary joint on a robot, this could be used to
apply the transform [x, y] =&gt; [sin x, cos x, y]. This would be
accomplished by passing <code class="docutils literal notranslate"><span class="pre">use_sin_cos_for_input</span> <span class="pre">=</span> <span class="pre">[true,</span> <span class="pre">false]</span></code>.</p>
<p>Note that when this transformation is applied, <code class="docutils literal notranslate"><span class="pre">num_inputs()</span> <span class="pre">!=</span>
<span class="pre">layers()[0]</span></code>. <cite>num_inputs() == 2 != layers()[0] == 3</cite>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">use_sin_cos_for_input</span></code>:</dt><dd><p>is a boolean vector that determines whether the sin/cos transform
is applied to each element.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">remaining_layers</span></code>:</dt><dd><p>is the number of elements in each layer of the network (the
activation function does <em>not</em> count as an additional layer). The
first element specifies the size of the first hidden layer, and
the last layer specifies the number of outputs.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">activation_types</span></code>:</dt><dd><p>specifies the activation function, σ(), used in <em>each</em> non-input
layer of the network (including the last layer).</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">activation_types</span></code> should have the same number of elements as
<code class="docutils literal notranslate"><span class="pre">remaining_layers</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron_[Expression].activation_type(self:</span> <span class="pre">pydrake.systems.primitives.MultilayerPerceptron_[Expression],</span> <span class="pre">layer:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.primitives.PerceptronActivationType</span></span></dt>
<dd><p>Returns the type of the activation function, σ(), used in the MLP.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron_[Expression].Backpropagation(self:</span> <span class="pre">pydrake.systems.primitives.MultilayerPerceptron_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">X:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous],</span> <span class="pre">loss:</span> <span class="pre">Callable[[numpy.ndarray[object[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous],</span> <span class="pre">Optional[numpy.ndarray[object[m,</span> <span class="pre">n],</span> <span class="pre">flags.writeable,</span> <span class="pre">flags.f_contiguous]]],</span> <span class="pre">pydrake.symbolic.Expression],</span> <span class="pre">dloss_dparams:</span> <span class="pre">Optional[numpy.ndarray[object[m,</span> <span class="pre">1],</span> <span class="pre">flags.writeable]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd><p>Implements the Backpropagation algorithm for the MLP to compute the
gradients of a scalar loss function with respect to the network
parameters.</p>
<p>Note: The class uses the System Cache to minimize the number of
dynamic memory allocations for repeated calls to this function with
the same sized <code class="docutils literal notranslate"><span class="pre">X</span></code>. Changing the batch size between calls to this
method or BatchOutput requires memory allocations.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X</span></code>:</dt><dd><p>is a batch input, with one input per column.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">loss</span></code>:</dt><dd><p>is a scalar loss function, where <code class="docutils literal notranslate"><span class="pre">Y</span></code> is the columnwise batch
output of the network. It should return the scalar loss and set
<code class="docutils literal notranslate"><span class="pre">dloss_dY</span></code>, the derivatives of the loss with respect to <code class="docutils literal notranslate"><span class="pre">Y</span></code>,
which is pre-allocated to be the same size as <code class="docutils literal notranslate"><span class="pre">Y</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">dloss_dparams</span></code>:</dt><dd><p>are the gradients computed. We take the storage as an input
argument to avoid memory allocations inside the algorithm.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the calculated loss.</p>
</dd>
</dl>
<p>Note: It is expected that this algorithm will be used with T=double.
It uses analytical gradients; AutoDiffXd is not required.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron_[Expression].BackpropagationMeanSquaredError(self:</span> <span class="pre">pydrake.systems.primitives.MultilayerPerceptron_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">X:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous],</span> <span class="pre">Y_desired:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous],</span> <span class="pre">dloss_dparams:</span> <span class="pre">Optional[numpy.ndarray[object[m,</span> <span class="pre">1],</span> <span class="pre">flags.writeable]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd><p>Calls Backpropagation with the mean-squared error loss function: loss
= 1/N ∑ᵢ <a href="#id5"><span class="problematic" id="id6">|</span></a>yᵢ−yᵢᵈ|², where yᵈ is the desired values for y. See
Backpropagation for details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron_[Expression].BatchOutput(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>BatchOutput(self: pydrake.systems.primitives.MultilayerPerceptron_[Expression], context: pydrake.systems.framework.Context_[Expression], X: numpy.ndarray[object[m, n], flags.f_contiguous], Y: Optional[numpy.ndarray[object[m, n], flags.writeable, flags.f_contiguous]], dYdX: Optional[numpy.ndarray[object[m, n], flags.writeable, flags.f_contiguous]] = None) -&gt; None</p></li>
</ol>
<p>Evaluates the batch output for the MLP with a batch input vector. Each
column of <code class="docutils literal notranslate"><span class="pre">X</span></code> represents an input, and each column of <code class="docutils literal notranslate"><span class="pre">Y</span></code> will be
assigned the corresponding output.</p>
<p>If the output layer of the network has size 1 (scalar output), and
<code class="docutils literal notranslate"><span class="pre">dYdX</span> <span class="pre">!=</span> <span class="pre">nullptr</span></code>, then <code class="docutils literal notranslate"><span class="pre">dYdX</span></code> is populated with the batch
gradients of the scalar output <code class="docutils literal notranslate"><span class="pre">Y</span></code> relative to the input <code class="docutils literal notranslate"><span class="pre">X</span></code>: the
(i,j)th element represents the gradient dY(0,j) / dX(i,j).</p>
<p>Note: In python, use numpy.asfortranarray() to allocate the writeable
matrices <code class="docutils literal notranslate"><span class="pre">Y</span></code> and (if needed) <code class="docutils literal notranslate"><span class="pre">dYdX</span></code>.</p>
<p>This methods shares the cache with Backpropagation. If the size of X
changes here or in Backpropagation, it may force dynamic memory
allocations.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if dYdX != nullptr and the network has more than one</strong> – </p></li>
<li><p><strong>output.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>BatchOutput(self: pydrake.systems.primitives.MultilayerPerceptron_[Expression], context: pydrake.systems.framework.Context_[Expression], X: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; numpy.ndarray[object[m, n]]</p></li>
</ol>
<p>Evaluates the batch output for the MLP with a batch input vector. See BatchOutput(context, X, Y) for a version that can avoid dynamic memory allocations of Y (e.g. if this is used inside an optimization loop).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron_[Expression].GetBiases(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetBiases(self: pydrake.systems.primitives.MultilayerPerceptron_[Expression], context: pydrake.systems.framework.Context_[Expression], layer: int) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Returns the biases used in the mapping from <code class="docutils literal notranslate"><span class="pre">layer</span></code> to <code class="docutils literal notranslate"><span class="pre">layer+1</span></code>.</p>
<ol class="arabic simple" start="2">
<li><p>GetBiases(self: pydrake.systems.primitives.MultilayerPerceptron_[Expression], params: numpy.ndarray[object[m, 1]], layer: int) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Returns the biases in <code class="docutils literal notranslate"><span class="pre">params</span></code> used in the mapping from <code class="docutils literal notranslate"><span class="pre">layer</span></code> to
<code class="docutils literal notranslate"><span class="pre">layer+1</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron_[Expression].GetMutableParameters(self:</span> <span class="pre">pydrake.systems.primitives.MultilayerPerceptron_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1],</span> <span class="pre">flags.writeable]</span></span></dt>
<dd><p>Returns a mutable reference to all of the parameters (weights and
biases) as a single vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron_[Expression].GetParameters(self:</span> <span class="pre">pydrake.systems.primitives.MultilayerPerceptron_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns a reference to all of the parameters (weights and biases) as a
single vector. Use GetWeights and GetBiases to extract the components.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron_[Expression].GetWeights(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetWeights(self: pydrake.systems.primitives.MultilayerPerceptron_[Expression], context: pydrake.systems.framework.Context_[Expression], layer: int) -&gt; numpy.ndarray[object[m, n], flags.f_contiguous]</p></li>
</ol>
<p>Returns the weights used in the mapping from <code class="docutils literal notranslate"><span class="pre">layer</span></code> to <code class="docutils literal notranslate"><span class="pre">layer+1</span></code>.</p>
<ol class="arabic simple" start="2">
<li><p>GetWeights(self: pydrake.systems.primitives.MultilayerPerceptron_[Expression], params: numpy.ndarray[object[m, 1]], layer: int) -&gt; numpy.ndarray[object[m, n], flags.f_contiguous]</p></li>
</ol>
<p>Returns the weights in <code class="docutils literal notranslate"><span class="pre">params</span></code> used in the mapping from <code class="docutils literal notranslate"><span class="pre">layer</span></code>
to <code class="docutils literal notranslate"><span class="pre">layer+1</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron_[Expression].layers(self:</span> <span class="pre">pydrake.systems.primitives.MultilayerPerceptron_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">list[int]</span></span></dt>
<dd><p>Returns the number of elements in each layer of the network.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron_[Expression].num_parameters(self:</span> <span class="pre">pydrake.systems.primitives.MultilayerPerceptron_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the total number of parameters in the network, including all
weights and biases.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron_[Expression].SetBiases(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetBiases(self: pydrake.systems.primitives.MultilayerPerceptron_[Expression], context: pydrake.systems.framework.Context_[Expression], layer: int, b: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the biases in the <code class="docutils literal notranslate"><span class="pre">context</span></code> used in the mapping from <code class="docutils literal notranslate"><span class="pre">layer</span></code>
to <code class="docutils literal notranslate"><span class="pre">layer+1</span></code>.</p>
<ol class="arabic simple" start="2">
<li><p>SetBiases(self: pydrake.systems.primitives.MultilayerPerceptron_[Expression], params: Optional[numpy.ndarray[object[m, 1], flags.writeable]], layer: int, b: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Sets the biases in <code class="docutils literal notranslate"><span class="pre">params</span></code> used in the mapping from <code class="docutils literal notranslate"><span class="pre">layer</span></code> to
<code class="docutils literal notranslate"><span class="pre">layer+1</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron_[Expression].SetParameters(self:</span> <span class="pre">pydrake.systems.primitives.MultilayerPerceptron_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">params:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets all of the parameters in the network (weights and biases) using a
single vector. Use SetWeights and SetBiases to extract the components.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultilayerPerceptron_[Expression].SetWeights(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetWeights(self: pydrake.systems.primitives.MultilayerPerceptron_[Expression], context: pydrake.systems.framework.Context_[Expression], layer: int, W: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; None</p></li>
</ol>
<p>Sets the weights in the <code class="docutils literal notranslate"><span class="pre">context</span></code> used in the mapping from <code class="docutils literal notranslate"><span class="pre">layer</span></code>
to <code class="docutils literal notranslate"><span class="pre">layer+1</span></code>.</p>
<ol class="arabic simple" start="2">
<li><p>SetWeights(self: pydrake.systems.primitives.MultilayerPerceptron_[Expression], params: Optional[numpy.ndarray[object[m, 1], flags.writeable]], layer: int, W: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; None</p></li>
</ol>
<p>Sets the weights in <code class="docutils literal notranslate"><span class="pre">params</span></code> used in the mapping from <code class="docutils literal notranslate"><span class="pre">layer</span></code> to
<code class="docutils literal notranslate"><span class="pre">layer+1</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Multiplexer</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></p>
<p>This system combines multiple vector-valued inputs into a
vector-valued output. The input to this system directly feeds through
to its output.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">...&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">u(N-1)&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Multiplexer</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">Multiplexer_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Multiplexer.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.primitives.Multiplexer, num_scalar_inputs: int) -&gt; None</p></li>
</ol>
<p>Constructs a Multiplexer with <code class="docutils literal notranslate"><span class="pre">num_scalar_inputs</span></code> scalar-valued
input ports, and one vector-valued output port of size
<code class="docutils literal notranslate"><span class="pre">num_scalar_inputs</span></code>.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">...&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">u(num_scalar_inputs - 1)&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Multiplexer</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.primitives.Multiplexer, input_sizes: list[int]) -&gt; None</p></li>
</ol>
<p>Constructs a Multiplexer with <code class="docutils literal notranslate"><span class="pre">input_sizes.size()</span></code> vector-valued
input ports where the i-th input has size <code class="docutils literal notranslate"><span class="pre">input_sizes[i]</span></code>, and one
vector- valued output port of size <code class="docutils literal notranslate"><span class="pre">sum(input_sizes)</span></code>.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">...&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">u(input_sizes.size() - 1)&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Multiplexer</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.systems.primitives.Multiplexer, model_vector: pydrake.systems.framework.BasicVector) -&gt; None</p></li>
</ol>
<p>Constructs a Multiplexer with model_vector.size() scalar-valued inputs
and one vector-valued output port whose size equals the size of
<code class="docutils literal notranslate"><span class="pre">model_vector</span></code>. In addition, the output type derives from that of
<code class="docutils literal notranslate"><span class="pre">model_vector</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Objects created using this constructor overload do not support
system scalar conversion. See system_scalar_conversion.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Multiplexer_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">Multiplexer_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Multiplexer_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Multiplexer_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Multiplexer_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></code></p>
<p>This system combines multiple vector-valued inputs into a
vector-valued output. The input to this system directly feeds through
to its output.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">...&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">u(N-1)&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Multiplexer</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Multiplexer_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.primitives.Multiplexer_[AutoDiffXd], num_scalar_inputs: int) -&gt; None</p></li>
</ol>
<p>Constructs a Multiplexer with <code class="docutils literal notranslate"><span class="pre">num_scalar_inputs</span></code> scalar-valued
input ports, and one vector-valued output port of size
<code class="docutils literal notranslate"><span class="pre">num_scalar_inputs</span></code>.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">...&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">u(num_scalar_inputs - 1)&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Multiplexer</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.primitives.Multiplexer_[AutoDiffXd], input_sizes: list[int]) -&gt; None</p></li>
</ol>
<p>Constructs a Multiplexer with <code class="docutils literal notranslate"><span class="pre">input_sizes.size()</span></code> vector-valued
input ports where the i-th input has size <code class="docutils literal notranslate"><span class="pre">input_sizes[i]</span></code>, and one
vector- valued output port of size <code class="docutils literal notranslate"><span class="pre">sum(input_sizes)</span></code>.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">...&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">u(input_sizes.size() - 1)&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Multiplexer</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.systems.primitives.Multiplexer_[AutoDiffXd], model_vector: pydrake.systems.framework.BasicVector_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Constructs a Multiplexer with model_vector.size() scalar-valued inputs
and one vector-valued output port whose size equals the size of
<code class="docutils literal notranslate"><span class="pre">model_vector</span></code>. In addition, the output type derives from that of
<code class="docutils literal notranslate"><span class="pre">model_vector</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Objects created using this constructor overload do not support
system scalar conversion. See system_scalar_conversion.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Multiplexer_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[Expression]</span></code></p>
<p>This system combines multiple vector-valued inputs into a
vector-valued output. The input to this system directly feeds through
to its output.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">...&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">u(N-1)&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Multiplexer</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Multiplexer_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.primitives.Multiplexer_[Expression], num_scalar_inputs: int) -&gt; None</p></li>
</ol>
<p>Constructs a Multiplexer with <code class="docutils literal notranslate"><span class="pre">num_scalar_inputs</span></code> scalar-valued
input ports, and one vector-valued output port of size
<code class="docutils literal notranslate"><span class="pre">num_scalar_inputs</span></code>.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">...&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">u(num_scalar_inputs - 1)&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Multiplexer</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.primitives.Multiplexer_[Expression], input_sizes: list[int]) -&gt; None</p></li>
</ol>
<p>Constructs a Multiplexer with <code class="docutils literal notranslate"><span class="pre">input_sizes.size()</span></code> vector-valued
input ports where the i-th input has size <code class="docutils literal notranslate"><span class="pre">input_sizes[i]</span></code>, and one
vector- valued output port of size <code class="docutils literal notranslate"><span class="pre">sum(input_sizes)</span></code>.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">...&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">u(input_sizes.size() - 1)&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Multiplexer</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.systems.primitives.Multiplexer_[Expression], model_vector: pydrake.systems.framework.BasicVector_[Expression]) -&gt; None</p></li>
</ol>
<p>Constructs a Multiplexer with model_vector.size() scalar-valued inputs
and one vector-valued output port whose size equals the size of
<code class="docutils literal notranslate"><span class="pre">model_vector</span></code>. In addition, the output type derives from that of
<code class="docutils literal notranslate"><span class="pre">model_vector</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Objects created using this constructor overload do not support
system scalar conversion. See system_scalar_conversion.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ObservabilityMatrix(arg0:</span> <span class="pre">pydrake.systems.primitives.LinearSystem)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>Returns the observability matrix: O = [ C; CA; …; CA^{n-1} ].</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PassThrough</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></p>
<p>A pass through system with input <code class="docutils literal notranslate"><span class="pre">u</span></code> and output <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">u</span></code>. This is
mathematically equivalent to a Gain system with its gain equal to one.
However this system incurs no computational cost. The input to this
system directly feeds through to its output.</p>
<p>The system can also be used to provide default values for a port in
any diagram. If the input port does not have a value, then the default
value passed in the constructor is passed to the output.</p>
<p>This system is used, for instance, in PidController which is a Diagram
composed of simple framework primitives. In this case a PassThrough is
used to connect the exported input of the Diagram to the inputs of the
Gain systems for the proportional and integral constants of the
controller. This is necessary to provide an output port to which the
internal Gain subsystems connect. In this case the PassThrough is
effectively creating an output port that feeds through the input to
the Diagram and that can now be connected to the inputs of the inner
subsystems to the Diagram. A detailed discussion of the PidController
can be found at <a class="reference external" href="https://github.com/RobotLocomotion/drake/pull/3132">https://github.com/RobotLocomotion/drake/pull/3132</a>.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>PassThrough</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y</td></tr></table></td></tr></table><div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">PassThrough_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PassThrough.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.primitives.PassThrough, vector_size: int) -&gt; None</p></li>
</ol>
<p>Constructs a pass-through system.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">vector_size</span></code>:</dt><dd><p>number of elements in the signal to be processed. When no input is
connected, the output will be a vector of all zeros.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.primitives.PassThrough, value: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs a pass-through system with vector-valued input/output
ports.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">value</span></code>:</dt><dd><p>The model value, which defines the size of the ports and serves as
the default when no input is connected.</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.systems.primitives.PassThrough, abstract_model_value: pydrake.common.value.AbstractValue) -&gt; None</p></li>
</ol>
<p>Constructs a pass-through system with abstract-valued input/output
ports.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">abstract_model_value</span></code>:</dt><dd><p>A model value, which defines the type of the ports and serves as
the default when no input is connected.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PassThrough_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">PassThrough_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">PassThrough_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">PassThrough_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PassThrough_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></code></p>
<p>A pass through system with input <code class="docutils literal notranslate"><span class="pre">u</span></code> and output <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">u</span></code>. This is
mathematically equivalent to a Gain system with its gain equal to one.
However this system incurs no computational cost. The input to this
system directly feeds through to its output.</p>
<p>The system can also be used to provide default values for a port in
any diagram. If the input port does not have a value, then the default
value passed in the constructor is passed to the output.</p>
<p>This system is used, for instance, in PidController which is a Diagram
composed of simple framework primitives. In this case a PassThrough is
used to connect the exported input of the Diagram to the inputs of the
Gain systems for the proportional and integral constants of the
controller. This is necessary to provide an output port to which the
internal Gain subsystems connect. In this case the PassThrough is
effectively creating an output port that feeds through the input to
the Diagram and that can now be connected to the inputs of the inner
subsystems to the Diagram. A detailed discussion of the PidController
can be found at <a class="reference external" href="https://github.com/RobotLocomotion/drake/pull/3132">https://github.com/RobotLocomotion/drake/pull/3132</a>.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>PassThrough</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y</td></tr></table></td></tr></table><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PassThrough_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.primitives.PassThrough_[AutoDiffXd], vector_size: int) -&gt; None</p></li>
</ol>
<p>Constructs a pass-through system.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">vector_size</span></code>:</dt><dd><p>number of elements in the signal to be processed. When no input is
connected, the output will be a vector of all zeros.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.primitives.PassThrough_[AutoDiffXd], value: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs a pass-through system with vector-valued input/output
ports.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">value</span></code>:</dt><dd><p>The model value, which defines the size of the ports and serves as
the default when no input is connected.</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.systems.primitives.PassThrough_[AutoDiffXd], abstract_model_value: pydrake.common.value.AbstractValue) -&gt; None</p></li>
</ol>
<p>Constructs a pass-through system with abstract-valued input/output
ports.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">abstract_model_value</span></code>:</dt><dd><p>A model value, which defines the type of the ports and serves as
the default when no input is connected.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PassThrough_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[Expression]</span></code></p>
<p>A pass through system with input <code class="docutils literal notranslate"><span class="pre">u</span></code> and output <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">u</span></code>. This is
mathematically equivalent to a Gain system with its gain equal to one.
However this system incurs no computational cost. The input to this
system directly feeds through to its output.</p>
<p>The system can also be used to provide default values for a port in
any diagram. If the input port does not have a value, then the default
value passed in the constructor is passed to the output.</p>
<p>This system is used, for instance, in PidController which is a Diagram
composed of simple framework primitives. In this case a PassThrough is
used to connect the exported input of the Diagram to the inputs of the
Gain systems for the proportional and integral constants of the
controller. This is necessary to provide an output port to which the
internal Gain subsystems connect. In this case the PassThrough is
effectively creating an output port that feeds through the input to
the Diagram and that can now be connected to the inputs of the inner
subsystems to the Diagram. A detailed discussion of the PidController
can be found at <a class="reference external" href="https://github.com/RobotLocomotion/drake/pull/3132">https://github.com/RobotLocomotion/drake/pull/3132</a>.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>PassThrough</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y</td></tr></table></td></tr></table><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PassThrough_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.primitives.PassThrough_[Expression], vector_size: int) -&gt; None</p></li>
</ol>
<p>Constructs a pass-through system.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">vector_size</span></code>:</dt><dd><p>number of elements in the signal to be processed. When no input is
connected, the output will be a vector of all zeros.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.primitives.PassThrough_[Expression], value: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs a pass-through system with vector-valued input/output
ports.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">value</span></code>:</dt><dd><p>The model value, which defines the size of the ports and serves as
the default when no input is connected.</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.systems.primitives.PassThrough_[Expression], abstract_model_value: pydrake.common.value.AbstractValue) -&gt; None</p></li>
</ol>
<p>Constructs a pass-through system with abstract-valued input/output
ports.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">abstract_model_value</span></code>:</dt><dd><p>A model value, which defines the type of the ports and serves as
the default when no input is connected.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PerceptronActivationType</span></span></dt>
<dd><p>Specifies one of the common activation functions in a neural network.</p>
<p>Members:</p>
<blockquote>
<div><p>kIdentity :</p>
<p>kReLU :</p>
<p>kTanh :</p>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PerceptronActivationType.__init__(self:</span> <span class="pre">pydrake.systems.primitives.PerceptronActivationType,</span> <span class="pre">value:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PerceptronActivationType.kIdentity</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PerceptronActivationType.kReLU</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PerceptronActivationType.kTanh</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PerceptronActivationType.name</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PerceptronActivationType.value</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PortSwitch</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></p>
<p>A simple system that passes through the value from just one of its
input ports to the output. All inputs (except for the port_selector)
must have the same data type as the output.</p>
<p>This system only evaluates the port_selector port and the input port
that is indicated by port_selector at runtime. Because of the System
framework’s “pull architecture”, this means that entire sub-diagrams
can potentially be added with minimal runtime cost (their outputs will
not be evaluated until they are selected). Just remember that their
state dynamics <em>will</em> still be evaluated when the diagram’s dynamics
are evaluated (e.g. during simulation), and their output ports could
be evaluated via other connections.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">port_selector&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">(user assigned port name)&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">...&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">(user assigned port name)&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>PortSwitch</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; value</td></tr></table></td></tr></table><div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">PortSwitch_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PortSwitch.__init__(self:</span> <span class="pre">pydrake.systems.primitives.PortSwitch,</span> <span class="pre">vector_size:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a vector-valued PortSwitch. All input ports declared via
DeclareInputPort() will be vector-valued ports of size
<code class="docutils literal notranslate"><span class="pre">vector_size</span></code>, which must be greater than zero.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PortSwitch.DeclareInputPort(self:</span> <span class="pre">pydrake.systems.primitives.PortSwitch,</span> <span class="pre">name:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.InputPort</span></span></dt>
<dd><p>Declares a new input port to the switch with port name <code class="docutils literal notranslate"><span class="pre">name</span></code>. The
type of this port is already defined by the type of the output port.
This must be called before any Context is allocated.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PortSwitch.get_port_selector_input_port(self:</span> <span class="pre">pydrake.systems.primitives.PortSwitch)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.InputPort</span></span></dt>
<dd><p>Returns the port-selector input port, which is an abstract-valued port
of type InputPortIndex.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PortSwitch_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">PortSwitch_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">PortSwitch_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">PortSwitch_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PortSwitch_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></code></p>
<p>A simple system that passes through the value from just one of its
input ports to the output. All inputs (except for the port_selector)
must have the same data type as the output.</p>
<p>This system only evaluates the port_selector port and the input port
that is indicated by port_selector at runtime. Because of the System
framework’s “pull architecture”, this means that entire sub-diagrams
can potentially be added with minimal runtime cost (their outputs will
not be evaluated until they are selected). Just remember that their
state dynamics <em>will</em> still be evaluated when the diagram’s dynamics
are evaluated (e.g. during simulation), and their output ports could
be evaluated via other connections.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">port_selector&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">(user assigned port name)&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">...&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">(user assigned port name)&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>PortSwitch</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; value</td></tr></table></td></tr></table><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PortSwitch_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.systems.primitives.PortSwitch_[AutoDiffXd],</span> <span class="pre">vector_size:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a vector-valued PortSwitch. All input ports declared via
DeclareInputPort() will be vector-valued ports of size
<code class="docutils literal notranslate"><span class="pre">vector_size</span></code>, which must be greater than zero.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PortSwitch_[AutoDiffXd].DeclareInputPort(self:</span> <span class="pre">pydrake.systems.primitives.PortSwitch_[AutoDiffXd],</span> <span class="pre">name:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.InputPort_[AutoDiffXd]</span></span></dt>
<dd><p>Declares a new input port to the switch with port name <code class="docutils literal notranslate"><span class="pre">name</span></code>. The
type of this port is already defined by the type of the output port.
This must be called before any Context is allocated.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PortSwitch_[AutoDiffXd].get_port_selector_input_port(self:</span> <span class="pre">pydrake.systems.primitives.PortSwitch_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.InputPort_[AutoDiffXd]</span></span></dt>
<dd><p>Returns the port-selector input port, which is an abstract-valued port
of type InputPortIndex.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PortSwitch_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[Expression]</span></code></p>
<p>A simple system that passes through the value from just one of its
input ports to the output. All inputs (except for the port_selector)
must have the same data type as the output.</p>
<p>This system only evaluates the port_selector port and the input port
that is indicated by port_selector at runtime. Because of the System
framework’s “pull architecture”, this means that entire sub-diagrams
can potentially be added with minimal runtime cost (their outputs will
not be evaluated until they are selected). Just remember that their
state dynamics <em>will</em> still be evaluated when the diagram’s dynamics
are evaluated (e.g. during simulation), and their output ports could
be evaluated via other connections.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">port_selector&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">(user assigned port name)&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">...&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">(user assigned port name)&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>PortSwitch</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; value</td></tr></table></td></tr></table><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PortSwitch_[Expression].__init__(self:</span> <span class="pre">pydrake.systems.primitives.PortSwitch_[Expression],</span> <span class="pre">vector_size:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a vector-valued PortSwitch. All input ports declared via
DeclareInputPort() will be vector-valued ports of size
<code class="docutils literal notranslate"><span class="pre">vector_size</span></code>, which must be greater than zero.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PortSwitch_[Expression].DeclareInputPort(self:</span> <span class="pre">pydrake.systems.primitives.PortSwitch_[Expression],</span> <span class="pre">name:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.InputPort_[Expression]</span></span></dt>
<dd><p>Declares a new input port to the switch with port name <code class="docutils literal notranslate"><span class="pre">name</span></code>. The
type of this port is already defined by the type of the output port.
This must be called before any Context is allocated.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PortSwitch_[Expression].get_port_selector_input_port(self:</span> <span class="pre">pydrake.systems.primitives.PortSwitch_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.InputPort_[Expression]</span></span></dt>
<dd><p>Returns the port-selector input port, which is an abstract-valued port
of type InputPortIndex.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RandomSource</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></p>
<p>A source block which generates random numbers at a fixed sampling
interval, with a zero-order hold between samples. For continuous-time
systems, this can be interpreted as a band-limited approximation of
continuous white noise (with a power-spectral density of the form Ts *
sinc^2( omega * Ts ), where Ts is the sampling interval.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>RandomSource</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; output</td></tr></table></td></tr></table><p>This system exposes a parameter named <code class="docutils literal notranslate"><span class="pre">seed</span></code> for the pseudo-random
number generator that determines the noise output. The <code class="docutils literal notranslate"><span class="pre">seed</span></code>
parameter behaves as follows:</p>
<p>1. Each newly-created RandomSource chooses a new <code class="docutils literal notranslate"><span class="pre">per_instance_seed</span></code> member
field value for itself.  The value will be unique within the current
executable process.</p>
<p>2. By default, <code class="docutils literal notranslate"><span class="pre">source.CreateDefaultContext()</span></code> will set the returned
context’s <code class="docutils literal notranslate"><span class="pre">seed</span></code> parameter to <code class="docutils literal notranslate"><span class="pre">per_instance_seed</span></code>.  Therefore, for a given
instance of this system, the parameters, state, and outputs will be
identical for all simulations that start from a default context.</p>
<p>3. By default, <code class="docutils literal notranslate"><span class="pre">source.SetRandomContext()</span></code> will choose a new, arbitrary
value for the context’s <code class="docutils literal notranslate"><span class="pre">seed</span></code> parameter, which means that the system’s
parameters, state, and outputs will (almost certainly) differ from their
defaults.</p>
<p>4. The user may call <code class="docutils literal notranslate"><span class="pre">source.set_fixed_seed(new_seed)</span></code> on this system.
When a <code class="docutils literal notranslate"><span class="pre">new_seed</span></code> value is provided, it is used by both
<code class="docutils literal notranslate"><span class="pre">CreateDefaultContext</span></code> and <code class="docutils literal notranslate"><span class="pre">SetRandomContext</span></code>.  Therefore, the system’s
parameters, state, and outputs will be identical to any other instances
that share the same <code class="docutils literal notranslate"><span class="pre">new_seed</span></code> value for their <code class="docutils literal notranslate"><span class="pre">seed</span></code> context parameter.
Note that <code class="docutils literal notranslate"><span class="pre">set_fixed_seed</span></code> affects subsequently-created contexts; any
pre-existing contexts are unaffected.  The user may call
<code class="docutils literal notranslate"><span class="pre">source.set_fixed_seed(nullopt)</span></code> to revert to the default the behaviors
described in #2 and #3 again.</p>
<p>5. The context returned by <code class="docutils literal notranslate"><span class="pre">source.AllocateContext()</span></code> does not contain a
valid <code class="docutils literal notranslate"><span class="pre">seed</span></code> parameter; that context should not be used until its values
are populated via another Context.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This system is only defined for the double scalar type.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The exact distribution results may vary across multiple platforms
or revisions of Drake, but will be consistent for all compilations
on a given platform and Drake revision.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The hard-coding of (default) distribution parameters is imposed
intentionally to simplify analysis (by forcing systems taking
noise inputs to implement the shifting/scaling, the system itself
contains all of the necessary information for stochastic
analysis).</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>stochastic_systems</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RandomSource.__init__(self:</span> <span class="pre">pydrake.systems.primitives.RandomSource,</span> <span class="pre">distribution:</span> <span class="pre">pydrake.common.RandomDistribution,</span> <span class="pre">num_outputs:</span> <span class="pre">int,</span> <span class="pre">sampling_interval_sec:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs the RandomSource system.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">distribution</span></code>:</dt><dd><p>The RandomDistribution used for each of the outputs.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_outputs</span></code>:</dt><dd><p>The dimension of the (single) vector output port.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">sampling_interval_sec</span></code>:</dt><dd><p>The sampling interval in seconds.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Saturation</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></p>
<p>An element-wise hard saturation block with inputs signal <code class="docutils literal notranslate"><span class="pre">u</span></code>,
saturation values <span class="math notranslate nohighlight">\(u_{min}\)</span> and/or <span class="math notranslate nohighlight">\(u_{max}\)</span>, and output
<code class="docutils literal notranslate"><span class="pre">y</span></code> respectively as in:</p>
<div class="math notranslate nohighlight">
\[y = u, u_{min} &lt; u &lt; u_{max}\]</div>
<div class="math notranslate nohighlight">
\[y = u_{min}, u \le u_{min}\]</div>
<div class="math notranslate nohighlight">
\[y = u_{max}, u \ge u_{max}\]</div>
<p>The input to this system directly feeds through to its output.</p>
<p>Note that <span class="math notranslate nohighlight">\(u_{min}\)</span>, and <span class="math notranslate nohighlight">\(u_{max}\)</span>, and <span class="math notranslate nohighlight">\(u\)</span> are all
vectors of same dimension, and the following condition holds
elementwise in runtime.</p>
<div class="math notranslate nohighlight">
\[u_{min} &lt;=  u_{max}\]</div>
<p>The quantities <span class="math notranslate nohighlight">\(u_{min}\)</span>, and <span class="math notranslate nohighlight">\(u_{max}\)</span> can be supplied as
inputs in separate ports or be initialised as constants using the
appropriate constructor by passing their default value. If these
quantities are not defined as constants but they are not connected to
appropriate sources, their values are taken by default to be
<span class="math notranslate nohighlight">\(u_{min} = -\infty\)</span>, and <span class="math notranslate nohighlight">\(u_{max} = \infty\)</span> respectively.
In this “variable” configuration, at least one of the input ports must
be connected.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px"><span style="color:gray">u1</span>&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px"><span style="color:gray">u2</span>&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Saturation</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><p>Ports show in &lt;span style=”color:gray”&gt;gray&lt;/span&gt; may be absent,
depending on how the system is constructed.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">Saturation_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Saturation.__init__(self:</span> <span class="pre">pydrake.systems.primitives.Saturation,</span> <span class="pre">min_value:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">max_value:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a constant Saturation system where the upper and lower
values are represented by vectors of identical size supplied via this
constructor.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Saturation</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">min_value</span></code>:</dt><dd><p>the lower (vector) limit to the saturation.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">max_value</span></code>:</dt><dd><p>the upper (vector) limit to the saturation.</p>
</dd>
</dl>
<p>Please consult this class’s description for the requirements of
<code class="docutils literal notranslate"><span class="pre">min_value</span></code> and <code class="docutils literal notranslate"><span class="pre">max_value</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Saturation_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">Saturation_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Saturation_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Saturation_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Saturation_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></code></p>
<p>An element-wise hard saturation block with inputs signal <code class="docutils literal notranslate"><span class="pre">u</span></code>,
saturation values <span class="math notranslate nohighlight">\(u_{min}\)</span> and/or <span class="math notranslate nohighlight">\(u_{max}\)</span>, and output
<code class="docutils literal notranslate"><span class="pre">y</span></code> respectively as in:</p>
<div class="math notranslate nohighlight">
\[y = u, u_{min} &lt; u &lt; u_{max}\]</div>
<div class="math notranslate nohighlight">
\[y = u_{min}, u \le u_{min}\]</div>
<div class="math notranslate nohighlight">
\[y = u_{max}, u \ge u_{max}\]</div>
<p>The input to this system directly feeds through to its output.</p>
<p>Note that <span class="math notranslate nohighlight">\(u_{min}\)</span>, and <span class="math notranslate nohighlight">\(u_{max}\)</span>, and <span class="math notranslate nohighlight">\(u\)</span> are all
vectors of same dimension, and the following condition holds
elementwise in runtime.</p>
<div class="math notranslate nohighlight">
\[u_{min} &lt;=  u_{max}\]</div>
<p>The quantities <span class="math notranslate nohighlight">\(u_{min}\)</span>, and <span class="math notranslate nohighlight">\(u_{max}\)</span> can be supplied as
inputs in separate ports or be initialised as constants using the
appropriate constructor by passing their default value. If these
quantities are not defined as constants but they are not connected to
appropriate sources, their values are taken by default to be
<span class="math notranslate nohighlight">\(u_{min} = -\infty\)</span>, and <span class="math notranslate nohighlight">\(u_{max} = \infty\)</span> respectively.
In this “variable” configuration, at least one of the input ports must
be connected.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px"><span style="color:gray">u1</span>&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px"><span style="color:gray">u2</span>&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Saturation</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><p>Ports show in &lt;span style=”color:gray”&gt;gray&lt;/span&gt; may be absent,
depending on how the system is constructed.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Saturation_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.systems.primitives.Saturation_[AutoDiffXd],</span> <span class="pre">min_value:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]],</span> <span class="pre">max_value:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a constant Saturation system where the upper and lower
values are represented by vectors of identical size supplied via this
constructor.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Saturation</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">min_value</span></code>:</dt><dd><p>the lower (vector) limit to the saturation.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">max_value</span></code>:</dt><dd><p>the upper (vector) limit to the saturation.</p>
</dd>
</dl>
<p>Please consult this class’s description for the requirements of
<code class="docutils literal notranslate"><span class="pre">min_value</span></code> and <code class="docutils literal notranslate"><span class="pre">max_value</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Saturation_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[Expression]</span></code></p>
<p>An element-wise hard saturation block with inputs signal <code class="docutils literal notranslate"><span class="pre">u</span></code>,
saturation values <span class="math notranslate nohighlight">\(u_{min}\)</span> and/or <span class="math notranslate nohighlight">\(u_{max}\)</span>, and output
<code class="docutils literal notranslate"><span class="pre">y</span></code> respectively as in:</p>
<div class="math notranslate nohighlight">
\[y = u, u_{min} &lt; u &lt; u_{max}\]</div>
<div class="math notranslate nohighlight">
\[y = u_{min}, u \le u_{min}\]</div>
<div class="math notranslate nohighlight">
\[y = u_{max}, u \ge u_{max}\]</div>
<p>The input to this system directly feeds through to its output.</p>
<p>Note that <span class="math notranslate nohighlight">\(u_{min}\)</span>, and <span class="math notranslate nohighlight">\(u_{max}\)</span>, and <span class="math notranslate nohighlight">\(u\)</span> are all
vectors of same dimension, and the following condition holds
elementwise in runtime.</p>
<div class="math notranslate nohighlight">
\[u_{min} &lt;=  u_{max}\]</div>
<p>The quantities <span class="math notranslate nohighlight">\(u_{min}\)</span>, and <span class="math notranslate nohighlight">\(u_{max}\)</span> can be supplied as
inputs in separate ports or be initialised as constants using the
appropriate constructor by passing their default value. If these
quantities are not defined as constants but they are not connected to
appropriate sources, their values are taken by default to be
<span class="math notranslate nohighlight">\(u_{min} = -\infty\)</span>, and <span class="math notranslate nohighlight">\(u_{max} = \infty\)</span> respectively.
In this “variable” configuration, at least one of the input ports must
be connected.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px"><span style="color:gray">u1</span>&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px"><span style="color:gray">u2</span>&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Saturation</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><p>Ports show in &lt;span style=”color:gray”&gt;gray&lt;/span&gt; may be absent,
depending on how the system is constructed.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Saturation_[Expression].__init__(self:</span> <span class="pre">pydrake.systems.primitives.Saturation_[Expression],</span> <span class="pre">min_value:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]],</span> <span class="pre">max_value:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a constant Saturation system where the upper and lower
values are represented by vectors of identical size supplied via this
constructor.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Saturation</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">min_value</span></code>:</dt><dd><p>the lower (vector) limit to the saturation.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">max_value</span></code>:</dt><dd><p>the upper (vector) limit to the saturation.</p>
</dd>
</dl>
<p>Please consult this class’s description for the requirements of
<code class="docutils literal notranslate"><span class="pre">min_value</span></code> and <code class="docutils literal notranslate"><span class="pre">max_value</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Selector</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></p>
<p>This system combines multiple vector-valued inputs into multiple
vector- valued outputs. It operates at the level of individual
elements of the input and output vectors (i.e., an output port can
provide a mixture of data from multiple input ports). The inputs to
this system directly feed through to its outputs. Refer to
SelectorParams to understand how the selection is specified.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">...&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">u(N-1)&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Selector</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; ...</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y(M-1)</td></tr></table></td></tr></table><p>The port names shown in the figure above are the defaults. Custom
names may be specified in the SelectorParams.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">Selector_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Selector.__init__(self:</span> <span class="pre">pydrake.systems.primitives.Selector,</span> <span class="pre">params:</span> <span class="pre">pydrake.systems.primitives.SelectorParams)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a Selector with the given parameters.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Selector_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">Selector_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Selector_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Selector_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Selector_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></code></p>
<p>This system combines multiple vector-valued inputs into multiple
vector- valued outputs. It operates at the level of individual
elements of the input and output vectors (i.e., an output port can
provide a mixture of data from multiple input ports). The inputs to
this system directly feed through to its outputs. Refer to
SelectorParams to understand how the selection is specified.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">...&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">u(N-1)&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Selector</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; ...</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y(M-1)</td></tr></table></td></tr></table><p>The port names shown in the figure above are the defaults. Custom
names may be specified in the SelectorParams.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Selector_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.systems.primitives.Selector_[AutoDiffXd],</span> <span class="pre">params:</span> <span class="pre">pydrake.systems.primitives.SelectorParams)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a Selector with the given parameters.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Selector_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[Expression]</span></code></p>
<p>This system combines multiple vector-valued inputs into multiple
vector- valued outputs. It operates at the level of individual
elements of the input and output vectors (i.e., an output port can
provide a mixture of data from multiple input ports). The inputs to
this system directly feed through to its outputs. Refer to
SelectorParams to understand how the selection is specified.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">...&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">u(N-1)&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Selector</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; ...</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y(M-1)</td></tr></table></td></tr></table><p>The port names shown in the figure above are the defaults. Custom
names may be specified in the SelectorParams.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Selector_[Expression].__init__(self:</span> <span class="pre">pydrake.systems.primitives.Selector_[Expression],</span> <span class="pre">params:</span> <span class="pre">pydrake.systems.primitives.SelectorParams)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a Selector with the given parameters.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SelectorParams</span></span></dt>
<dd><p>The constructor arguments for a Selector.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SelectorParams.__init__(self:</span> <span class="pre">pydrake.systems.primitives.SelectorParams,</span> <span class="pre">**kwargs)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SelectorParams.InputPortParams</span></span></dt>
<dd><p>Helper struct for <code class="docutils literal notranslate"><span class="pre">inputs</span></code>.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SelectorParams.InputPortParams.__init__(self:</span> <span class="pre">pydrake.systems.primitives.SelectorParams.InputPortParams,</span> <span class="pre">**kwargs)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SelectorParams.InputPortParams.name</span></span></dt>
<dd><p>(Optional) Specifies a name for the port. When given, the name must be
a valid port name. When unset, the port will use kDefaultName.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SelectorParams.InputPortParams.size</span></span></dt>
<dd><p>Specifies the size of the port, which must be non-negative.</p>
</dd></dl>

</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SelectorParams.inputs</span></span></dt>
<dd><p>Specifies details of the input ports, and by implication the total
number of input ports. There will be <code class="docutils literal notranslate"><span class="pre">inputs.size()</span></code> ports in total.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SelectorParams.OutputPortParams</span></span></dt>
<dd><p>Helper struct for <code class="docutils literal notranslate"><span class="pre">outputs</span></code>.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SelectorParams.OutputPortParams.__init__(self:</span> <span class="pre">pydrake.systems.primitives.SelectorParams.OutputPortParams,</span> <span class="pre">**kwargs)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SelectorParams.OutputPortParams.name</span></span></dt>
<dd><p>(Optional) Specifies a name for the port. When given, the name must be
a valid port name. When unset, the port will use kDefaultName.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SelectorParams.OutputPortParams.selections</span></span></dt>
<dd><p>Specifies the values for the output port elements, and by implication
the port’s size. The port will have size <code class="docutils literal notranslate"><span class="pre">selections.size()</span></code>, and
its i’th output value will be determined by the (input_port_index,
input_offset) pair at <code class="docutils literal notranslate"><span class="pre">selections[i]</span></code>, i.e., for the m’th output
port we have:</p>
<div class="highlight-txt notranslate"><div class="highlight"><pre><span></span>n = selections[i].input_port_index
j = selections[i].input_offset
y_m[i] = u_n[j]
</pre></div>
</div>
<p>Output elements always come from some input element; it is not
possible to directly set an output to a constant. (If a constant is
necessary, connect a ConstantVectorSource to an input port.)</p>
</dd></dl>

</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SelectorParams.outputs</span></span></dt>
<dd><p>Specifies details of the output ports, and by implication the total
number of output ports. There will be <code class="docutils literal notranslate"><span class="pre">outputs.size()</span></code> ports in
total.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SelectorParams.OutputSelection</span></span></dt>
<dd><p>Helper struct for <code class="docutils literal notranslate"><span class="pre">output_selections</span></code>.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SelectorParams.OutputSelection.__init__(self:</span> <span class="pre">pydrake.systems.primitives.SelectorParams.OutputSelection,</span> <span class="pre">**kwargs)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SelectorParams.OutputSelection.input_offset</span></span></dt>
<dd><p>The element offset within the given input port to use for this single
output element.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SelectorParams.OutputSelection.input_port_index</span></span></dt>
<dd><p>The input port to use for this single output element.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SharedPointerSystem</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></p>
<p>SharedPointerSystem holds a single <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code> that will be
released at System deletion time (i.e., the end of a Diagram
lifespan). It has no input, output, state, nor parameters. This is
useful for storing objects that will be pointed-to by other systems
outside of the usual input/output port connections.</p>
<p>Scalar conversion is supported and will simply increment the reference
count for the contained object. The contained object will not be
scalar-converted, so should not depend on <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">SharedPointerSystem_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SharedPointerSystem.__init__(self:</span> <span class="pre">pydrake.systems.primitives.SharedPointerSystem,</span> <span class="pre">value_to_hold:</span> <span class="pre">object)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Creates a system holding the given value. The value is allowed to be
<code class="docutils literal notranslate"><span class="pre">nullptr</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To immediately give up ownership at the call site, remember to use
<code class="docutils literal notranslate"><span class="pre">std::move</span></code> on the <code class="docutils literal notranslate"><span class="pre">value_to_hold</span></code>.</p>
</div>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">Held</span></code>:</dt><dd><p>The type used to store the given value. Calls to get&lt;&gt;() must
provide the same type for retrieval.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SharedPointerSystem.AddToBuilder(builder:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder,</span> <span class="pre">value_to_hold:</span> <span class="pre">object)</span> <span class="pre">-&gt;</span> <span class="pre">object</span></span></dt>
<dd><p>Creates a system holding the given value and adds it to the builder.
The value is allowed to be <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>. Returns an alias to the value
(or <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> in case <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> was passed in as the
<code class="docutils literal notranslate"><span class="pre">value_to_hold</span></code>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To immediately give up ownership at the call site, remember to use
<code class="docutils literal notranslate"><span class="pre">std::move</span></code> on the <code class="docutils literal notranslate"><span class="pre">value_to_hold</span></code>.</p>
</div>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">Held</span></code>:</dt><dd><p>The type used to store the given value. Calls to get&lt;&gt;() must
provide the same type for retrieval.</p>
</dd>
<dt>Precondition:</dt><dd><p>builder is non-null</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SharedPointerSystem.get(self:</span> <span class="pre">pydrake.systems.primitives.SharedPointerSystem)</span> <span class="pre">-&gt;</span> <span class="pre">object</span></span></dt>
<dd><p>(Advanced) Retrieves an alias to the stored value. Returns <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>
in case <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> was passed in as the <code class="docutils literal notranslate"><span class="pre">value_to_hold</span></code>.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">Held</span></code>:</dt><dd><p>The type used to store the given value, per our constructor.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if Held doesn't match the type used at construction.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SharedPointerSystem_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">SharedPointerSystem_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">SharedPointerSystem_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">SharedPointerSystem_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SharedPointerSystem_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></code></p>
<p>SharedPointerSystem holds a single <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code> that will be
released at System deletion time (i.e., the end of a Diagram
lifespan). It has no input, output, state, nor parameters. This is
useful for storing objects that will be pointed-to by other systems
outside of the usual input/output port connections.</p>
<p>Scalar conversion is supported and will simply increment the reference
count for the contained object. The contained object will not be
scalar-converted, so should not depend on <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SharedPointerSystem_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.systems.primitives.SharedPointerSystem_[AutoDiffXd],</span> <span class="pre">value_to_hold:</span> <span class="pre">object)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Creates a system holding the given value. The value is allowed to be
<code class="docutils literal notranslate"><span class="pre">nullptr</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To immediately give up ownership at the call site, remember to use
<code class="docutils literal notranslate"><span class="pre">std::move</span></code> on the <code class="docutils literal notranslate"><span class="pre">value_to_hold</span></code>.</p>
</div>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">Held</span></code>:</dt><dd><p>The type used to store the given value. Calls to get&lt;&gt;() must
provide the same type for retrieval.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SharedPointerSystem_[AutoDiffXd].AddToBuilder(builder:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[AutoDiffXd],</span> <span class="pre">value_to_hold:</span> <span class="pre">object)</span> <span class="pre">-&gt;</span> <span class="pre">object</span></span></dt>
<dd><p>Creates a system holding the given value and adds it to the builder.
The value is allowed to be <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>. Returns an alias to the value
(or <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> in case <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> was passed in as the
<code class="docutils literal notranslate"><span class="pre">value_to_hold</span></code>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To immediately give up ownership at the call site, remember to use
<code class="docutils literal notranslate"><span class="pre">std::move</span></code> on the <code class="docutils literal notranslate"><span class="pre">value_to_hold</span></code>.</p>
</div>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">Held</span></code>:</dt><dd><p>The type used to store the given value. Calls to get&lt;&gt;() must
provide the same type for retrieval.</p>
</dd>
<dt>Precondition:</dt><dd><p>builder is non-null</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SharedPointerSystem_[AutoDiffXd].get(self:</span> <span class="pre">pydrake.systems.primitives.SharedPointerSystem_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">object</span></span></dt>
<dd><p>(Advanced) Retrieves an alias to the stored value. Returns <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>
in case <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> was passed in as the <code class="docutils literal notranslate"><span class="pre">value_to_hold</span></code>.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">Held</span></code>:</dt><dd><p>The type used to store the given value, per our constructor.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if Held doesn't match the type used at construction.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SharedPointerSystem_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[Expression]</span></code></p>
<p>SharedPointerSystem holds a single <code class="docutils literal notranslate"><span class="pre">shared_ptr</span></code> that will be
released at System deletion time (i.e., the end of a Diagram
lifespan). It has no input, output, state, nor parameters. This is
useful for storing objects that will be pointed-to by other systems
outside of the usual input/output port connections.</p>
<p>Scalar conversion is supported and will simply increment the reference
count for the contained object. The contained object will not be
scalar-converted, so should not depend on <code class="docutils literal notranslate"><span class="pre">T</span></code>.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SharedPointerSystem_[Expression].__init__(self:</span> <span class="pre">pydrake.systems.primitives.SharedPointerSystem_[Expression],</span> <span class="pre">value_to_hold:</span> <span class="pre">object)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Creates a system holding the given value. The value is allowed to be
<code class="docutils literal notranslate"><span class="pre">nullptr</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To immediately give up ownership at the call site, remember to use
<code class="docutils literal notranslate"><span class="pre">std::move</span></code> on the <code class="docutils literal notranslate"><span class="pre">value_to_hold</span></code>.</p>
</div>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">Held</span></code>:</dt><dd><p>The type used to store the given value. Calls to get&lt;&gt;() must
provide the same type for retrieval.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SharedPointerSystem_[Expression].AddToBuilder(builder:</span> <span class="pre">pydrake.systems.framework.DiagramBuilder_[Expression],</span> <span class="pre">value_to_hold:</span> <span class="pre">object)</span> <span class="pre">-&gt;</span> <span class="pre">object</span></span></dt>
<dd><p>Creates a system holding the given value and adds it to the builder.
The value is allowed to be <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>. Returns an alias to the value
(or <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> in case <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> was passed in as the
<code class="docutils literal notranslate"><span class="pre">value_to_hold</span></code>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To immediately give up ownership at the call site, remember to use
<code class="docutils literal notranslate"><span class="pre">std::move</span></code> on the <code class="docutils literal notranslate"><span class="pre">value_to_hold</span></code>.</p>
</div>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">Held</span></code>:</dt><dd><p>The type used to store the given value. Calls to get&lt;&gt;() must
provide the same type for retrieval.</p>
</dd>
<dt>Precondition:</dt><dd><p>builder is non-null</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SharedPointerSystem_[Expression].get(self:</span> <span class="pre">pydrake.systems.primitives.SharedPointerSystem_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">object</span></span></dt>
<dd><p>(Advanced) Retrieves an alias to the stored value. Returns <code class="docutils literal notranslate"><span class="pre">nullptr</span></code>
in case <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> was passed in as the <code class="docutils literal notranslate"><span class="pre">value_to_hold</span></code>.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">Held</span></code>:</dt><dd><p>The type used to store the given value, per our constructor.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if Held doesn't match the type used at construction.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Sine</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></p>
<p>A sine system which outputs <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">*</span> <span class="pre">sin(f</span> <span class="pre">*</span> <span class="pre">t</span> <span class="pre">+</span> <span class="pre">p)</span></code> and first and
second derivatives w.r.t. the time parameter <code class="docutils literal notranslate"><span class="pre">t</span></code>. The block
parameters are: <code class="docutils literal notranslate"><span class="pre">a</span></code> the amplitude, <code class="docutils literal notranslate"><span class="pre">f</span></code> the frequency
(radians/second), and <code class="docutils literal notranslate"><span class="pre">p</span></code> the phase (radians), all of which are
constant vectors provided at construction time. This system has one or
zero input ports and three vector valued output ports (<code class="docutils literal notranslate"><span class="pre">y</span></code> and its
first two derivatives). The user can specify whether to use simulation
time as the source of values for the time variable or an external
source. If an external time source is specified, the system is created
with an input port for the time source. Otherwise, the system is
created with zero input ports.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px"><span style="color:gray">u0</span>&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Sine</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y1</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y2</td></tr></table></td></tr></table><p>Port <code class="docutils literal notranslate"><span class="pre">u0</span></code> is present if and only if the constructor parameter
<code class="docutils literal notranslate"><span class="pre">is_time_based</span></code> is false.</p>
<p>Port <code class="docutils literal notranslate"><span class="pre">y0</span></code> emits the value <code class="docutils literal notranslate"><span class="pre">y</span></code>; port <code class="docutils literal notranslate"><span class="pre">y1</span></code> emits the first
derivative; port <code class="docutils literal notranslate"><span class="pre">y2</span></code> emits the second derivative.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">Sine_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Sine.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.primitives.Sine, amplitude: float, frequency: float, phase: float, size: int, is_time_based: bool = True) -&gt; None</p></li>
</ol>
<p>Constructs a Sine system where the amplitude, frequency, and phase is
applied to every input.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">amplitude</span></code>:</dt><dd><p>the sine wave amplitude</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frequency</span></code>:</dt><dd><p>the sine wave frequency (radians/second)</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">phase</span></code>:</dt><dd><p>the sine wave phase (radians)</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">size</span></code>:</dt><dd><p>number of elements in the output signal.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">is_time_based</span></code>:</dt><dd><p>indicates whether to use the simulation time as the source for the
sine wave time variable, or use an external source, in which case
an input port of size <code class="docutils literal notranslate"><span class="pre">size</span></code> is created.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.primitives.Sine, amplitudes: numpy.ndarray[numpy.float64[m, 1]], frequencies: numpy.ndarray[numpy.float64[m, 1]], phases: numpy.ndarray[numpy.float64[m, 1]], is_time_based: bool = True) -&gt; None</p></li>
</ol>
<p>Constructs a Sine system where different amplitudes, frequencies, and
phases can be applied to each sine wave.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">amplitudes</span></code>:</dt><dd><p>the sine wave amplitudes</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frequencies</span></code>:</dt><dd><p>the sine wave frequencies (radians/second)</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">phases</span></code>:</dt><dd><p>the sine wave phases (radians)</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">is_time_based</span></code>:</dt><dd><p>indicates whether to use the simulation time as the source for the
sine wave time variable, or use an external source, in which case
an input port is created.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Sine_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">Sine_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Sine_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Sine_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Sine_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></code></p>
<p>A sine system which outputs <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">*</span> <span class="pre">sin(f</span> <span class="pre">*</span> <span class="pre">t</span> <span class="pre">+</span> <span class="pre">p)</span></code> and first and
second derivatives w.r.t. the time parameter <code class="docutils literal notranslate"><span class="pre">t</span></code>. The block
parameters are: <code class="docutils literal notranslate"><span class="pre">a</span></code> the amplitude, <code class="docutils literal notranslate"><span class="pre">f</span></code> the frequency
(radians/second), and <code class="docutils literal notranslate"><span class="pre">p</span></code> the phase (radians), all of which are
constant vectors provided at construction time. This system has one or
zero input ports and three vector valued output ports (<code class="docutils literal notranslate"><span class="pre">y</span></code> and its
first two derivatives). The user can specify whether to use simulation
time as the source of values for the time variable or an external
source. If an external time source is specified, the system is created
with an input port for the time source. Otherwise, the system is
created with zero input ports.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px"><span style="color:gray">u0</span>&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Sine</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y1</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y2</td></tr></table></td></tr></table><p>Port <code class="docutils literal notranslate"><span class="pre">u0</span></code> is present if and only if the constructor parameter
<code class="docutils literal notranslate"><span class="pre">is_time_based</span></code> is false.</p>
<p>Port <code class="docutils literal notranslate"><span class="pre">y0</span></code> emits the value <code class="docutils literal notranslate"><span class="pre">y</span></code>; port <code class="docutils literal notranslate"><span class="pre">y1</span></code> emits the first
derivative; port <code class="docutils literal notranslate"><span class="pre">y2</span></code> emits the second derivative.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Sine_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.primitives.Sine_[AutoDiffXd], amplitude: float, frequency: float, phase: float, size: int, is_time_based: bool = True) -&gt; None</p></li>
</ol>
<p>Constructs a Sine system where the amplitude, frequency, and phase is
applied to every input.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">amplitude</span></code>:</dt><dd><p>the sine wave amplitude</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frequency</span></code>:</dt><dd><p>the sine wave frequency (radians/second)</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">phase</span></code>:</dt><dd><p>the sine wave phase (radians)</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">size</span></code>:</dt><dd><p>number of elements in the output signal.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">is_time_based</span></code>:</dt><dd><p>indicates whether to use the simulation time as the source for the
sine wave time variable, or use an external source, in which case
an input port of size <code class="docutils literal notranslate"><span class="pre">size</span></code> is created.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.primitives.Sine_[AutoDiffXd], amplitudes: numpy.ndarray[numpy.float64[m, 1]], frequencies: numpy.ndarray[numpy.float64[m, 1]], phases: numpy.ndarray[numpy.float64[m, 1]], is_time_based: bool = True) -&gt; None</p></li>
</ol>
<p>Constructs a Sine system where different amplitudes, frequencies, and
phases can be applied to each sine wave.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">amplitudes</span></code>:</dt><dd><p>the sine wave amplitudes</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frequencies</span></code>:</dt><dd><p>the sine wave frequencies (radians/second)</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">phases</span></code>:</dt><dd><p>the sine wave phases (radians)</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">is_time_based</span></code>:</dt><dd><p>indicates whether to use the simulation time as the source for the
sine wave time variable, or use an external source, in which case
an input port is created.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Sine_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[Expression]</span></code></p>
<p>A sine system which outputs <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">a</span> <span class="pre">*</span> <span class="pre">sin(f</span> <span class="pre">*</span> <span class="pre">t</span> <span class="pre">+</span> <span class="pre">p)</span></code> and first and
second derivatives w.r.t. the time parameter <code class="docutils literal notranslate"><span class="pre">t</span></code>. The block
parameters are: <code class="docutils literal notranslate"><span class="pre">a</span></code> the amplitude, <code class="docutils literal notranslate"><span class="pre">f</span></code> the frequency
(radians/second), and <code class="docutils literal notranslate"><span class="pre">p</span></code> the phase (radians), all of which are
constant vectors provided at construction time. This system has one or
zero input ports and three vector valued output ports (<code class="docutils literal notranslate"><span class="pre">y</span></code> and its
first two derivatives). The user can specify whether to use simulation
time as the source of values for the time variable or an external
source. If an external time source is specified, the system is created
with an input port for the time source. Otherwise, the system is
created with zero input ports.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px"><span style="color:gray">u0</span>&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>Sine</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y1</td></tr><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y2</td></tr></table></td></tr></table><p>Port <code class="docutils literal notranslate"><span class="pre">u0</span></code> is present if and only if the constructor parameter
<code class="docutils literal notranslate"><span class="pre">is_time_based</span></code> is false.</p>
<p>Port <code class="docutils literal notranslate"><span class="pre">y0</span></code> emits the value <code class="docutils literal notranslate"><span class="pre">y</span></code>; port <code class="docutils literal notranslate"><span class="pre">y1</span></code> emits the first
derivative; port <code class="docutils literal notranslate"><span class="pre">y2</span></code> emits the second derivative.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Sine_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.primitives.Sine_[Expression], amplitude: float, frequency: float, phase: float, size: int, is_time_based: bool = True) -&gt; None</p></li>
</ol>
<p>Constructs a Sine system where the amplitude, frequency, and phase is
applied to every input.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">amplitude</span></code>:</dt><dd><p>the sine wave amplitude</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frequency</span></code>:</dt><dd><p>the sine wave frequency (radians/second)</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">phase</span></code>:</dt><dd><p>the sine wave phase (radians)</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">size</span></code>:</dt><dd><p>number of elements in the output signal.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">is_time_based</span></code>:</dt><dd><p>indicates whether to use the simulation time as the source for the
sine wave time variable, or use an external source, in which case
an input port of size <code class="docutils literal notranslate"><span class="pre">size</span></code> is created.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.primitives.Sine_[Expression], amplitudes: numpy.ndarray[numpy.float64[m, 1]], frequencies: numpy.ndarray[numpy.float64[m, 1]], phases: numpy.ndarray[numpy.float64[m, 1]], is_time_based: bool = True) -&gt; None</p></li>
</ol>
<p>Constructs a Sine system where different amplitudes, frequencies, and
phases can be applied to each sine wave.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">amplitudes</span></code>:</dt><dd><p>the sine wave amplitudes</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frequencies</span></code>:</dt><dd><p>the sine wave frequencies (radians/second)</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">phases</span></code>:</dt><dd><p>the sine wave phases (radians)</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">is_time_based</span></code>:</dt><dd><p>indicates whether to use the simulation time as the source for the
sine wave time variable, or use an external source, in which case
an input port is created.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SparseMatrixGain</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></p>
<p>A variant of MatrixGain which supports multiplication by SparseMatrix,
<code class="docutils literal notranslate"><span class="pre">D</span></code>. Specifically, given an input signal <code class="docutils literal notranslate"><span class="pre">u</span></code> and a state <code class="docutils literal notranslate"><span class="pre">x</span></code>,
the output of this system, <code class="docutils literal notranslate"><span class="pre">y</span></code>, is:</p>
<div class="math notranslate nohighlight">
\[y = D u\]</div>
<p>Note that, unlike MatrixGain, this system is not derived from
LinearSystem (which does not yet support sparse matrices). However, we
use <code class="docutils literal notranslate"><span class="pre">D</span></code> as the name for the gain matrix here to be consistent.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>SparseMatrixGain</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y</td></tr></table></td></tr></table><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MatrixGain</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">SparseMatrixGain_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SparseMatrixGain.__init__(self:</span> <span class="pre">pydrake.systems.primitives.SparseMatrixGain,</span> <span class="pre">D:</span> <span class="pre">scipy.sparse.csc_matrix[numpy.float64])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>A constructor where the gain matrix <code class="docutils literal notranslate"><span class="pre">D</span></code> is <code class="docutils literal notranslate"><span class="pre">D</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SparseMatrixGain.D(self:</span> <span class="pre">pydrake.systems.primitives.SparseMatrixGain)</span> <span class="pre">-&gt;</span> <span class="pre">scipy.sparse.csc_matrix[numpy.float64]</span></span></dt>
<dd><p>Getter for the gain matrix <code class="docutils literal notranslate"><span class="pre">D</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SparseMatrixGain.set_D(self:</span> <span class="pre">pydrake.systems.primitives.SparseMatrixGain,</span> <span class="pre">D:</span> <span class="pre">scipy.sparse.csc_matrix[numpy.float64])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Setter for the gain matrix <code class="docutils literal notranslate"><span class="pre">D</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SparseMatrixGain_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">SparseMatrixGain_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">SparseMatrixGain_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">SparseMatrixGain_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SparseMatrixGain_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></code></p>
<p>A variant of MatrixGain which supports multiplication by SparseMatrix,
<code class="docutils literal notranslate"><span class="pre">D</span></code>. Specifically, given an input signal <code class="docutils literal notranslate"><span class="pre">u</span></code> and a state <code class="docutils literal notranslate"><span class="pre">x</span></code>,
the output of this system, <code class="docutils literal notranslate"><span class="pre">y</span></code>, is:</p>
<div class="math notranslate nohighlight">
\[y = D u\]</div>
<p>Note that, unlike MatrixGain, this system is not derived from
LinearSystem (which does not yet support sparse matrices). However, we
use <code class="docutils literal notranslate"><span class="pre">D</span></code> as the name for the gain matrix here to be consistent.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>SparseMatrixGain</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y</td></tr></table></td></tr></table><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MatrixGain</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SparseMatrixGain_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.systems.primitives.SparseMatrixGain_[AutoDiffXd],</span> <span class="pre">D:</span> <span class="pre">scipy.sparse.csc_matrix[numpy.float64])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>A constructor where the gain matrix <code class="docutils literal notranslate"><span class="pre">D</span></code> is <code class="docutils literal notranslate"><span class="pre">D</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SparseMatrixGain_[AutoDiffXd].D(self:</span> <span class="pre">pydrake.systems.primitives.SparseMatrixGain_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">scipy.sparse.csc_matrix[numpy.float64]</span></span></dt>
<dd><p>Getter for the gain matrix <code class="docutils literal notranslate"><span class="pre">D</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SparseMatrixGain_[AutoDiffXd].set_D(self:</span> <span class="pre">pydrake.systems.primitives.SparseMatrixGain_[AutoDiffXd],</span> <span class="pre">D:</span> <span class="pre">scipy.sparse.csc_matrix[numpy.float64])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Setter for the gain matrix <code class="docutils literal notranslate"><span class="pre">D</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SparseMatrixGain_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[Expression]</span></code></p>
<p>A variant of MatrixGain which supports multiplication by SparseMatrix,
<code class="docutils literal notranslate"><span class="pre">D</span></code>. Specifically, given an input signal <code class="docutils literal notranslate"><span class="pre">u</span></code> and a state <code class="docutils literal notranslate"><span class="pre">x</span></code>,
the output of this system, <code class="docutils literal notranslate"><span class="pre">y</span></code>, is:</p>
<div class="math notranslate nohighlight">
\[y = D u\]</div>
<p>Note that, unlike MatrixGain, this system is not derived from
LinearSystem (which does not yet support sparse matrices). However, we
use <code class="docutils literal notranslate"><span class="pre">D</span></code> as the name for the gain matrix here to be consistent.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>SparseMatrixGain</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y</td></tr></table></td></tr></table><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MatrixGain</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SparseMatrixGain_[Expression].__init__(self:</span> <span class="pre">pydrake.systems.primitives.SparseMatrixGain_[Expression],</span> <span class="pre">D:</span> <span class="pre">scipy.sparse.csc_matrix[numpy.float64])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>A constructor where the gain matrix <code class="docutils literal notranslate"><span class="pre">D</span></code> is <code class="docutils literal notranslate"><span class="pre">D</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SparseMatrixGain_[Expression].D(self:</span> <span class="pre">pydrake.systems.primitives.SparseMatrixGain_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">scipy.sparse.csc_matrix[numpy.float64]</span></span></dt>
<dd><p>Getter for the gain matrix <code class="docutils literal notranslate"><span class="pre">D</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SparseMatrixGain_[Expression].set_D(self:</span> <span class="pre">pydrake.systems.primitives.SparseMatrixGain_[Expression],</span> <span class="pre">D:</span> <span class="pre">scipy.sparse.csc_matrix[numpy.float64])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Setter for the gain matrix <code class="docutils literal notranslate"><span class="pre">D</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">StateInterpolatorWithDiscreteDerivative</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.Diagram</span></code></p>
<p>Supports the common pattern of combining a (feed-through) position
with a velocity estimated with the DiscreteDerivative into a single
output vector with positions and velocities stacked. This assumes that
the velocities are equal to the time derivative of the positions.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="err">┌─────┐</span>
<span class="n">position</span><span class="w"> </span><span class="err">───┬───────────────────</span><span class="o">&gt;</span><span class="err">│</span><span class="w">     </span><span class="err">│</span>
<span class="w">            </span><span class="err">│</span><span class="w">                    </span><span class="err">│</span><span class="w"> </span><span class="n">Mux</span><span class="w"> </span><span class="err">├──</span><span class="o">&gt;</span><span class="w"> </span><span class="n">state</span>
<span class="w">            </span><span class="err">│</span><span class="w">   </span><span class="err">┌────────────┐</span><span class="w">   </span><span class="err">│</span><span class="w">     </span><span class="err">│</span>
<span class="w">            </span><span class="err">└──</span><span class="o">&gt;</span><span class="err">│</span><span class="w">  </span><span class="n">Discrete</span><span class="w">  </span><span class="err">├──</span><span class="o">&gt;</span><span class="err">│</span><span class="w">     </span><span class="err">│</span>
<span class="w">                </span><span class="err">│</span><span class="w"> </span><span class="n">Derivative</span><span class="w"> </span><span class="err">│</span><span class="w">   </span><span class="err">└─────┘</span>
<span class="w">                </span><span class="err">└────────────┘</span>
</pre></div>
</div>
</details><table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">position&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>StateInterpolatorWithDiscreteDerivative</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; state</td></tr></table></td></tr></table><div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">StateInterpolatorWithDiscreteDerivative_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">StateInterpolatorWithDiscreteDerivative.__init__(self:</span> <span class="pre">pydrake.systems.primitives.StateInterpolatorWithDiscreteDerivative,</span> <span class="pre">num_positions:</span> <span class="pre">int,</span> <span class="pre">time_step:</span> <span class="pre">float,</span> <span class="pre">suppress_initial_transient:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">True)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructor taking <code class="docutils literal notranslate"><span class="pre">num_positions</span></code>, the size of the position vector
to be differentiated, and <code class="docutils literal notranslate"><span class="pre">time_step</span></code>, the sampling interval. If
<code class="docutils literal notranslate"><span class="pre">suppress_initial_transient</span></code> is true (the default), then the
velocity output will be zero for the first two time steps (see the
DiscreteDerivative class documentation for details and exceptions).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">StateInterpolatorWithDiscreteDerivative.set_initial_position(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>set_initial_position(self: pydrake.systems.primitives.StateInterpolatorWithDiscreteDerivative, context: pydrake.systems.framework.Context, position: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Convenience method that sets the entire position history for the
discrete-time derivative to a constant vector value (resulting in
velocity estimate of zero). This is useful during initialization to
avoid large derivative outputs. <code class="docutils literal notranslate"><span class="pre">position</span></code> must be the same size as
the input/output ports. If suppress_initial_transient() is true, then
also disables the suppression for this <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This only changes the position history used for the velocity half
of the output port; it has no effect on the feedthrough position.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>set_initial_position(self: pydrake.systems.primitives.StateInterpolatorWithDiscreteDerivative, state: pydrake.systems.framework.State, position: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Convenience method that sets the entire position history for the
discrete-time derivative to a constant vector value (resulting in
velocity estimate of zero). This is useful during initialization to
avoid large derivative outputs. <code class="docutils literal notranslate"><span class="pre">position</span></code> must be the same size as
the input/output ports. If suppress_initial_transient() is true, then
also disables the suppression for this <code class="docutils literal notranslate"><span class="pre">state</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This only changes the position history used for the velocity half
of the output port; it has no effect on the feedthrough position.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">StateInterpolatorWithDiscreteDerivative.suppress_initial_transient(self:</span> <span class="pre">pydrake.systems.primitives.StateInterpolatorWithDiscreteDerivative)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns the <code class="docutils literal notranslate"><span class="pre">suppress_initial_transient</span></code> passed to the constructor.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">StateInterpolatorWithDiscreteDerivative_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">StateInterpolatorWithDiscreteDerivative_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">StateInterpolatorWithDiscreteDerivative_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">StateInterpolatorWithDiscreteDerivative_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">StateInterpolatorWithDiscreteDerivative_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.Diagram_[AutoDiffXd]</span></code></p>
<p>Supports the common pattern of combining a (feed-through) position
with a velocity estimated with the DiscreteDerivative into a single
output vector with positions and velocities stacked. This assumes that
the velocities are equal to the time derivative of the positions.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="err">┌─────┐</span>
<span class="n">position</span><span class="w"> </span><span class="err">───┬───────────────────</span><span class="o">&gt;</span><span class="err">│</span><span class="w">     </span><span class="err">│</span>
<span class="w">            </span><span class="err">│</span><span class="w">                    </span><span class="err">│</span><span class="w"> </span><span class="n">Mux</span><span class="w"> </span><span class="err">├──</span><span class="o">&gt;</span><span class="w"> </span><span class="n">state</span>
<span class="w">            </span><span class="err">│</span><span class="w">   </span><span class="err">┌────────────┐</span><span class="w">   </span><span class="err">│</span><span class="w">     </span><span class="err">│</span>
<span class="w">            </span><span class="err">└──</span><span class="o">&gt;</span><span class="err">│</span><span class="w">  </span><span class="n">Discrete</span><span class="w">  </span><span class="err">├──</span><span class="o">&gt;</span><span class="err">│</span><span class="w">     </span><span class="err">│</span>
<span class="w">                </span><span class="err">│</span><span class="w"> </span><span class="n">Derivative</span><span class="w"> </span><span class="err">│</span><span class="w">   </span><span class="err">└─────┘</span>
<span class="w">                </span><span class="err">└────────────┘</span>
</pre></div>
</div>
</details><table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">position&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>StateInterpolatorWithDiscreteDerivative</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; state</td></tr></table></td></tr></table><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">StateInterpolatorWithDiscreteDerivative_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.systems.primitives.StateInterpolatorWithDiscreteDerivative_[AutoDiffXd],</span> <span class="pre">num_positions:</span> <span class="pre">int,</span> <span class="pre">time_step:</span> <span class="pre">float,</span> <span class="pre">suppress_initial_transient:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">True)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructor taking <code class="docutils literal notranslate"><span class="pre">num_positions</span></code>, the size of the position vector
to be differentiated, and <code class="docutils literal notranslate"><span class="pre">time_step</span></code>, the sampling interval. If
<code class="docutils literal notranslate"><span class="pre">suppress_initial_transient</span></code> is true (the default), then the
velocity output will be zero for the first two time steps (see the
DiscreteDerivative class documentation for details and exceptions).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">StateInterpolatorWithDiscreteDerivative_[AutoDiffXd].set_initial_position(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>set_initial_position(self: pydrake.systems.primitives.StateInterpolatorWithDiscreteDerivative_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], position: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Convenience method that sets the entire position history for the
discrete-time derivative to a constant vector value (resulting in
velocity estimate of zero). This is useful during initialization to
avoid large derivative outputs. <code class="docutils literal notranslate"><span class="pre">position</span></code> must be the same size as
the input/output ports. If suppress_initial_transient() is true, then
also disables the suppression for this <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This only changes the position history used for the velocity half
of the output port; it has no effect on the feedthrough position.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>set_initial_position(self: pydrake.systems.primitives.StateInterpolatorWithDiscreteDerivative_[AutoDiffXd], state: pydrake.systems.framework.State_[AutoDiffXd], position: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Convenience method that sets the entire position history for the
discrete-time derivative to a constant vector value (resulting in
velocity estimate of zero). This is useful during initialization to
avoid large derivative outputs. <code class="docutils literal notranslate"><span class="pre">position</span></code> must be the same size as
the input/output ports. If suppress_initial_transient() is true, then
also disables the suppression for this <code class="docutils literal notranslate"><span class="pre">state</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This only changes the position history used for the velocity half
of the output port; it has no effect on the feedthrough position.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">StateInterpolatorWithDiscreteDerivative_[AutoDiffXd].suppress_initial_transient(self:</span> <span class="pre">pydrake.systems.primitives.StateInterpolatorWithDiscreteDerivative_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns the <code class="docutils literal notranslate"><span class="pre">suppress_initial_transient</span></code> passed to the constructor.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">StateInterpolatorWithDiscreteDerivative_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.Diagram_[Expression]</span></code></p>
<p>Supports the common pattern of combining a (feed-through) position
with a velocity estimated with the DiscreteDerivative into a single
output vector with positions and velocities stacked. This assumes that
the velocities are equal to the time derivative of the positions.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="err">┌─────┐</span>
<span class="n">position</span><span class="w"> </span><span class="err">───┬───────────────────</span><span class="o">&gt;</span><span class="err">│</span><span class="w">     </span><span class="err">│</span>
<span class="w">            </span><span class="err">│</span><span class="w">                    </span><span class="err">│</span><span class="w"> </span><span class="n">Mux</span><span class="w"> </span><span class="err">├──</span><span class="o">&gt;</span><span class="w"> </span><span class="n">state</span>
<span class="w">            </span><span class="err">│</span><span class="w">   </span><span class="err">┌────────────┐</span><span class="w">   </span><span class="err">│</span><span class="w">     </span><span class="err">│</span>
<span class="w">            </span><span class="err">└──</span><span class="o">&gt;</span><span class="err">│</span><span class="w">  </span><span class="n">Discrete</span><span class="w">  </span><span class="err">├──</span><span class="o">&gt;</span><span class="err">│</span><span class="w">     </span><span class="err">│</span>
<span class="w">                </span><span class="err">│</span><span class="w"> </span><span class="n">Derivative</span><span class="w"> </span><span class="err">│</span><span class="w">   </span><span class="err">└─────┘</span>
<span class="w">                </span><span class="err">└────────────┘</span>
</pre></div>
</div>
</details><table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">position&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>StateInterpolatorWithDiscreteDerivative</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; state</td></tr></table></td></tr></table><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">StateInterpolatorWithDiscreteDerivative_[Expression].__init__(self:</span> <span class="pre">pydrake.systems.primitives.StateInterpolatorWithDiscreteDerivative_[Expression],</span> <span class="pre">num_positions:</span> <span class="pre">int,</span> <span class="pre">time_step:</span> <span class="pre">float,</span> <span class="pre">suppress_initial_transient:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">True)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructor taking <code class="docutils literal notranslate"><span class="pre">num_positions</span></code>, the size of the position vector
to be differentiated, and <code class="docutils literal notranslate"><span class="pre">time_step</span></code>, the sampling interval. If
<code class="docutils literal notranslate"><span class="pre">suppress_initial_transient</span></code> is true (the default), then the
velocity output will be zero for the first two time steps (see the
DiscreteDerivative class documentation for details and exceptions).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">StateInterpolatorWithDiscreteDerivative_[Expression].set_initial_position(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>set_initial_position(self: pydrake.systems.primitives.StateInterpolatorWithDiscreteDerivative_[Expression], context: pydrake.systems.framework.Context_[Expression], position: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Convenience method that sets the entire position history for the
discrete-time derivative to a constant vector value (resulting in
velocity estimate of zero). This is useful during initialization to
avoid large derivative outputs. <code class="docutils literal notranslate"><span class="pre">position</span></code> must be the same size as
the input/output ports. If suppress_initial_transient() is true, then
also disables the suppression for this <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This only changes the position history used for the velocity half
of the output port; it has no effect on the feedthrough position.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>set_initial_position(self: pydrake.systems.primitives.StateInterpolatorWithDiscreteDerivative_[Expression], state: pydrake.systems.framework.State_[Expression], position: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Convenience method that sets the entire position history for the
discrete-time derivative to a constant vector value (resulting in
velocity estimate of zero). This is useful during initialization to
avoid large derivative outputs. <code class="docutils literal notranslate"><span class="pre">position</span></code> must be the same size as
the input/output ports. If suppress_initial_transient() is true, then
also disables the suppression for this <code class="docutils literal notranslate"><span class="pre">state</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This only changes the position history used for the velocity half
of the output port; it has no effect on the feedthrough position.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">StateInterpolatorWithDiscreteDerivative_[Expression].suppress_initial_transient(self:</span> <span class="pre">pydrake.systems.primitives.StateInterpolatorWithDiscreteDerivative_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns the <code class="docutils literal notranslate"><span class="pre">suppress_initial_transient</span></code> passed to the constructor.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SymbolicVectorSystem</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></p>
<p>A LeafSystem that is defined by vectors of symbolic::Expression
representing the dynamics and output. The resulting system has only
zero or one vector input ports, zero or one vector of continuous or
discrete state (depending on the specified time_period), zero or one
vector of numeric parameters, and only zero or one vector output
ports.</p>
<p>See SymbolicVectorSystemBuilder to make the construction a little
nicer.</p>
<p>For example, to define the system: ẋ = -x + x³, y = x, we could write</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">symbolic</span><span class="o">::</span><span class="n">Variable</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="s">&quot;x&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">system</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SymbolicVectorSystemBuilder</span><span class="p">().</span><span class="n">state</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="w">                                             </span><span class="p">.</span><span class="n">dynamics</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="w">                                             </span><span class="p">.</span><span class="n">output</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="w">                                             </span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</pre></div>
</div>
</details><p>Note: This will not be as performant as writing your own LeafSystem.
It is meant primarily for rapid prototyping.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px"><span style="color:gray">u0</span>&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>SymbolicVectorSystem</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; <span style="color:gray">y0</span></td></tr></table></td></tr></table><p>Either port <code class="docutils literal notranslate"><span class="pre">u0</span></code> or port <code class="docutils literal notranslate"><span class="pre">y0</span></code> may be absent, depending on the
values supplied at construction.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">SymbolicVectorSystem_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SymbolicVectorSystem.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.primitives.SymbolicVectorSystem, time: Optional[pydrake.symbolic.Variable] = None, state: numpy.ndarray[object[m, 1]] = array([], dtype=object), input: numpy.ndarray[object[m, 1]] = array([], dtype=object), dynamics: numpy.ndarray[object[m, 1]] = array([], dtype=object), output: numpy.ndarray[object[m, 1]] = array([], dtype=object), time_period: float = 0.0) -&gt; None</p></li>
</ol>
<p>Construct the SymbolicVectorSystem.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time</span></code>:</dt><dd><p>an (optional) Variable used to represent time in the dynamics.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">state</span></code>:</dt><dd><p>an (optional) vector of Variables representing the state. The
order in this vector will determine the order of the elements in
the state vector. Each element must be unique.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">input</span></code>:</dt><dd><p>an (optional) vector of Variables representing the input. The
order in this vector will determine the order of the elements in
the vector-valued input port. Each element must be unique.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">dynamics</span></code>:</dt><dd><p>a vector of Expressions representing the dynamics of the system.
If <code class="docutils literal notranslate"><span class="pre">time_period</span></code> == 0, then this describes the continuous time
derivatives. If <code class="docutils literal notranslate"><span class="pre">time_period</span></code> &gt; 0, then it defines the updates
of the single discrete-valued state vector. The size of this
vector must match the number of state variables.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">output</span></code>:</dt><dd><p>a vector of Expressions representing the output of the system. If
empty, then no output port will be allocated.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time_period</span></code>:</dt><dd><p>a scalar representing the period of a periodic update. time_period
== 0.0 implies that the state variables will be declared as
continuous state and the dynamics will be implemented as time
derivatives. time_period &gt; 0.0 implies the state variables will be
declared as discrete state and the dynamics will be implemented as
a dicraete variable update.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.primitives.SymbolicVectorSystem, time: Optional[pydrake.symbolic.Variable] = None, state: numpy.ndarray[object[m, 1]] = array([], dtype=object), input: numpy.ndarray[object[m, 1]] = array([], dtype=object), parameter: numpy.ndarray[object[m, 1]] = array([], dtype=object), dynamics: numpy.ndarray[object[m, 1]] = array([], dtype=object), output: numpy.ndarray[object[m, 1]] = array([], dtype=object), time_period: float = 0.0) -&gt; None</p></li>
</ol>
<p>Construct the SymbolicVectorSystem.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time</span></code>:</dt><dd><p>an (optional) Variable used to represent time in the dynamics.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">state</span></code>:</dt><dd><p>an (optional) vector of Variables representing the state. The
order in this vector will determine the order of the elements in
the state vector. Each element must be unique.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">input</span></code>:</dt><dd><p>an (optional) vector of Variables representing the input. The
order in this vector will determine the order of the elements in
the vector-valued input port. Each element must be unique.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">parameter</span></code>:</dt><dd><p>an (optional) vector of Variables representing the numeric
parameter. The order in this vector will determine the order of
the elements in the vector-valued parameter. Each element must be
unique.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">dynamics</span></code>:</dt><dd><p>a vector of Expressions representing the dynamics of the system.
If <code class="docutils literal notranslate"><span class="pre">time_period</span></code> == 0, then this describes the continuous time
derivatives. If <code class="docutils literal notranslate"><span class="pre">time_period</span></code> &gt; 0, then it defines the updates
of the single discrete-valued state vector. The size of this
vector must match the number of state variables.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">output</span></code>:</dt><dd><p>a vector of Expressions representing the output of the system. If
empty, then no output port will be allocated.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time_period</span></code>:</dt><dd><p>a scalar representing the period of a periodic update. time_period
== 0.0 implies that the state variables will be declared as
continuous state and the dynamics will be implemented as time
derivatives. time_period &gt; 0.0 implies the state variables will be
declared as discrete state and the dynamics will be implemented as
a dicraete variable update.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SymbolicVectorSystem.dynamics_for_variable(self:</span> <span class="pre">pydrake.systems.primitives.SymbolicVectorSystem,</span> <span class="pre">var:</span> <span class="pre">pydrake.symbolic.Variable)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd><p>Returns the dynamics for the variable <code class="docutils literal notranslate"><span class="pre">var</span></code>. That is, it returns the
scalar expression corresponding to either <code class="docutils literal notranslate"><span class="pre">\dot{var}</span></code> (continuous
case) or <code class="docutils literal notranslate"><span class="pre">var[n+1]</span></code> (discrete case).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if this system has no corresponding dynamics for the</strong> – </p></li>
<li><p><strong>variable var.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SymbolicVectorSystem_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">SymbolicVectorSystem_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">SymbolicVectorSystem_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">SymbolicVectorSystem_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SymbolicVectorSystem_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></code></p>
<p>A LeafSystem that is defined by vectors of symbolic::Expression
representing the dynamics and output. The resulting system has only
zero or one vector input ports, zero or one vector of continuous or
discrete state (depending on the specified time_period), zero or one
vector of numeric parameters, and only zero or one vector output
ports.</p>
<p>See SymbolicVectorSystemBuilder to make the construction a little
nicer.</p>
<p>For example, to define the system: ẋ = -x + x³, y = x, we could write</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">symbolic</span><span class="o">::</span><span class="n">Variable</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="s">&quot;x&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">system</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SymbolicVectorSystemBuilder</span><span class="p">().</span><span class="n">state</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="w">                                             </span><span class="p">.</span><span class="n">dynamics</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="w">                                             </span><span class="p">.</span><span class="n">output</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="w">                                             </span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</pre></div>
</div>
</details><p>Note: This will not be as performant as writing your own LeafSystem.
It is meant primarily for rapid prototyping.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px"><span style="color:gray">u0</span>&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>SymbolicVectorSystem</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; <span style="color:gray">y0</span></td></tr></table></td></tr></table><p>Either port <code class="docutils literal notranslate"><span class="pre">u0</span></code> or port <code class="docutils literal notranslate"><span class="pre">y0</span></code> may be absent, depending on the
values supplied at construction.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SymbolicVectorSystem_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.primitives.SymbolicVectorSystem_[AutoDiffXd], time: Optional[pydrake.symbolic.Variable] = None, state: numpy.ndarray[object[m, 1]] = array([], dtype=object), input: numpy.ndarray[object[m, 1]] = array([], dtype=object), dynamics: numpy.ndarray[object[m, 1]] = array([], dtype=object), output: numpy.ndarray[object[m, 1]] = array([], dtype=object), time_period: float = 0.0) -&gt; None</p></li>
</ol>
<p>Construct the SymbolicVectorSystem.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time</span></code>:</dt><dd><p>an (optional) Variable used to represent time in the dynamics.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">state</span></code>:</dt><dd><p>an (optional) vector of Variables representing the state. The
order in this vector will determine the order of the elements in
the state vector. Each element must be unique.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">input</span></code>:</dt><dd><p>an (optional) vector of Variables representing the input. The
order in this vector will determine the order of the elements in
the vector-valued input port. Each element must be unique.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">dynamics</span></code>:</dt><dd><p>a vector of Expressions representing the dynamics of the system.
If <code class="docutils literal notranslate"><span class="pre">time_period</span></code> == 0, then this describes the continuous time
derivatives. If <code class="docutils literal notranslate"><span class="pre">time_period</span></code> &gt; 0, then it defines the updates
of the single discrete-valued state vector. The size of this
vector must match the number of state variables.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">output</span></code>:</dt><dd><p>a vector of Expressions representing the output of the system. If
empty, then no output port will be allocated.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time_period</span></code>:</dt><dd><p>a scalar representing the period of a periodic update. time_period
== 0.0 implies that the state variables will be declared as
continuous state and the dynamics will be implemented as time
derivatives. time_period &gt; 0.0 implies the state variables will be
declared as discrete state and the dynamics will be implemented as
a dicraete variable update.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.primitives.SymbolicVectorSystem_[AutoDiffXd], time: Optional[pydrake.symbolic.Variable] = None, state: numpy.ndarray[object[m, 1]] = array([], dtype=object), input: numpy.ndarray[object[m, 1]] = array([], dtype=object), parameter: numpy.ndarray[object[m, 1]] = array([], dtype=object), dynamics: numpy.ndarray[object[m, 1]] = array([], dtype=object), output: numpy.ndarray[object[m, 1]] = array([], dtype=object), time_period: float = 0.0) -&gt; None</p></li>
</ol>
<p>Construct the SymbolicVectorSystem.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time</span></code>:</dt><dd><p>an (optional) Variable used to represent time in the dynamics.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">state</span></code>:</dt><dd><p>an (optional) vector of Variables representing the state. The
order in this vector will determine the order of the elements in
the state vector. Each element must be unique.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">input</span></code>:</dt><dd><p>an (optional) vector of Variables representing the input. The
order in this vector will determine the order of the elements in
the vector-valued input port. Each element must be unique.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">parameter</span></code>:</dt><dd><p>an (optional) vector of Variables representing the numeric
parameter. The order in this vector will determine the order of
the elements in the vector-valued parameter. Each element must be
unique.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">dynamics</span></code>:</dt><dd><p>a vector of Expressions representing the dynamics of the system.
If <code class="docutils literal notranslate"><span class="pre">time_period</span></code> == 0, then this describes the continuous time
derivatives. If <code class="docutils literal notranslate"><span class="pre">time_period</span></code> &gt; 0, then it defines the updates
of the single discrete-valued state vector. The size of this
vector must match the number of state variables.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">output</span></code>:</dt><dd><p>a vector of Expressions representing the output of the system. If
empty, then no output port will be allocated.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time_period</span></code>:</dt><dd><p>a scalar representing the period of a periodic update. time_period
== 0.0 implies that the state variables will be declared as
continuous state and the dynamics will be implemented as time
derivatives. time_period &gt; 0.0 implies the state variables will be
declared as discrete state and the dynamics will be implemented as
a dicraete variable update.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SymbolicVectorSystem_[AutoDiffXd].dynamics_for_variable(self:</span> <span class="pre">pydrake.systems.primitives.SymbolicVectorSystem_[AutoDiffXd],</span> <span class="pre">var:</span> <span class="pre">pydrake.symbolic.Variable)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd><p>Returns the dynamics for the variable <code class="docutils literal notranslate"><span class="pre">var</span></code>. That is, it returns the
scalar expression corresponding to either <code class="docutils literal notranslate"><span class="pre">\dot{var}</span></code> (continuous
case) or <code class="docutils literal notranslate"><span class="pre">var[n+1]</span></code> (discrete case).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if this system has no corresponding dynamics for the</strong> – </p></li>
<li><p><strong>variable var.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SymbolicVectorSystem_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[Expression]</span></code></p>
<p>A LeafSystem that is defined by vectors of symbolic::Expression
representing the dynamics and output. The resulting system has only
zero or one vector input ports, zero or one vector of continuous or
discrete state (depending on the specified time_period), zero or one
vector of numeric parameters, and only zero or one vector output
ports.</p>
<p>See SymbolicVectorSystemBuilder to make the construction a little
nicer.</p>
<p>For example, to define the system: ẋ = -x + x³, y = x, we could write</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">symbolic</span><span class="o">::</span><span class="n">Variable</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="s">&quot;x&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">system</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SymbolicVectorSystemBuilder</span><span class="p">().</span><span class="n">state</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="w">                                             </span><span class="p">.</span><span class="n">dynamics</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="w">                                             </span><span class="p">.</span><span class="n">output</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="w">                                             </span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
</pre></div>
</div>
</details><p>Note: This will not be as performant as writing your own LeafSystem.
It is meant primarily for rapid prototyping.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px"><span style="color:gray">u0</span>&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>SymbolicVectorSystem</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; <span style="color:gray">y0</span></td></tr></table></td></tr></table><p>Either port <code class="docutils literal notranslate"><span class="pre">u0</span></code> or port <code class="docutils literal notranslate"><span class="pre">y0</span></code> may be absent, depending on the
values supplied at construction.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SymbolicVectorSystem_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.primitives.SymbolicVectorSystem_[Expression], time: Optional[pydrake.symbolic.Variable] = None, state: numpy.ndarray[object[m, 1]] = array([], dtype=object), input: numpy.ndarray[object[m, 1]] = array([], dtype=object), dynamics: numpy.ndarray[object[m, 1]] = array([], dtype=object), output: numpy.ndarray[object[m, 1]] = array([], dtype=object), time_period: float = 0.0) -&gt; None</p></li>
</ol>
<p>Construct the SymbolicVectorSystem.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time</span></code>:</dt><dd><p>an (optional) Variable used to represent time in the dynamics.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">state</span></code>:</dt><dd><p>an (optional) vector of Variables representing the state. The
order in this vector will determine the order of the elements in
the state vector. Each element must be unique.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">input</span></code>:</dt><dd><p>an (optional) vector of Variables representing the input. The
order in this vector will determine the order of the elements in
the vector-valued input port. Each element must be unique.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">dynamics</span></code>:</dt><dd><p>a vector of Expressions representing the dynamics of the system.
If <code class="docutils literal notranslate"><span class="pre">time_period</span></code> == 0, then this describes the continuous time
derivatives. If <code class="docutils literal notranslate"><span class="pre">time_period</span></code> &gt; 0, then it defines the updates
of the single discrete-valued state vector. The size of this
vector must match the number of state variables.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">output</span></code>:</dt><dd><p>a vector of Expressions representing the output of the system. If
empty, then no output port will be allocated.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time_period</span></code>:</dt><dd><p>a scalar representing the period of a periodic update. time_period
== 0.0 implies that the state variables will be declared as
continuous state and the dynamics will be implemented as time
derivatives. time_period &gt; 0.0 implies the state variables will be
declared as discrete state and the dynamics will be implemented as
a dicraete variable update.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.primitives.SymbolicVectorSystem_[Expression], time: Optional[pydrake.symbolic.Variable] = None, state: numpy.ndarray[object[m, 1]] = array([], dtype=object), input: numpy.ndarray[object[m, 1]] = array([], dtype=object), parameter: numpy.ndarray[object[m, 1]] = array([], dtype=object), dynamics: numpy.ndarray[object[m, 1]] = array([], dtype=object), output: numpy.ndarray[object[m, 1]] = array([], dtype=object), time_period: float = 0.0) -&gt; None</p></li>
</ol>
<p>Construct the SymbolicVectorSystem.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time</span></code>:</dt><dd><p>an (optional) Variable used to represent time in the dynamics.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">state</span></code>:</dt><dd><p>an (optional) vector of Variables representing the state. The
order in this vector will determine the order of the elements in
the state vector. Each element must be unique.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">input</span></code>:</dt><dd><p>an (optional) vector of Variables representing the input. The
order in this vector will determine the order of the elements in
the vector-valued input port. Each element must be unique.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">parameter</span></code>:</dt><dd><p>an (optional) vector of Variables representing the numeric
parameter. The order in this vector will determine the order of
the elements in the vector-valued parameter. Each element must be
unique.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">dynamics</span></code>:</dt><dd><p>a vector of Expressions representing the dynamics of the system.
If <code class="docutils literal notranslate"><span class="pre">time_period</span></code> == 0, then this describes the continuous time
derivatives. If <code class="docutils literal notranslate"><span class="pre">time_period</span></code> &gt; 0, then it defines the updates
of the single discrete-valued state vector. The size of this
vector must match the number of state variables.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">output</span></code>:</dt><dd><p>a vector of Expressions representing the output of the system. If
empty, then no output port will be allocated.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time_period</span></code>:</dt><dd><p>a scalar representing the period of a periodic update. time_period
== 0.0 implies that the state variables will be declared as
continuous state and the dynamics will be implemented as time
derivatives. time_period &gt; 0.0 implies the state variables will be
declared as discrete state and the dynamics will be implemented as
a dicraete variable update.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SymbolicVectorSystem_[Expression].dynamics_for_variable(self:</span> <span class="pre">pydrake.systems.primitives.SymbolicVectorSystem_[Expression],</span> <span class="pre">var:</span> <span class="pre">pydrake.symbolic.Variable)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd><p>Returns the dynamics for the variable <code class="docutils literal notranslate"><span class="pre">var</span></code>. That is, it returns the
scalar expression corresponding to either <code class="docutils literal notranslate"><span class="pre">\dot{var}</span></code> (continuous
case) or <code class="docutils literal notranslate"><span class="pre">var[n+1]</span></code> (discrete case).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if this system has no corresponding dynamics for the</strong> – </p></li>
<li><p><strong>variable var.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectoryAffineSystem</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></p>
<p>A continuous- or discrete-time Affine Time-Varying system with system
matrices described by trajectories.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>TrajectoryAffineSystem</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">TrajectoryAffineSystem_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectoryAffineSystem.__init__(self:</span> <span class="pre">pydrake.systems.primitives.TrajectoryAffineSystem,</span> <span class="pre">A:</span> <span class="pre">pydrake.trajectories.Trajectory,</span> <span class="pre">B:</span> <span class="pre">pydrake.trajectories.Trajectory,</span> <span class="pre">f0:</span> <span class="pre">pydrake.trajectories.Trajectory,</span> <span class="pre">C:</span> <span class="pre">pydrake.trajectories.Trajectory,</span> <span class="pre">D:</span> <span class="pre">pydrake.trajectories.Trajectory,</span> <span class="pre">y0:</span> <span class="pre">pydrake.trajectories.Trajectory,</span> <span class="pre">time_period:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0.0)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a TrajectoryAffineSystem from trajectories of matrices.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time_period</span></code>:</dt><dd><p>Defines the period of the discrete time system; use
time_period=0.0 to denote a continuous time system. $*Default:*
0.0</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectoryAffineSystem.A(self:</span> <span class="pre">pydrake.systems.primitives.TrajectoryAffineSystem,</span> <span class="pre">arg0:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>&#64;name Implementations of TimeVaryingAffineSystem&lt;T&gt;’s pure virtual
methods.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectoryAffineSystem.B(self:</span> <span class="pre">pydrake.systems.primitives.TrajectoryAffineSystem,</span> <span class="pre">arg0:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectoryAffineSystem.C(self:</span> <span class="pre">pydrake.systems.primitives.TrajectoryAffineSystem,</span> <span class="pre">arg0:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectoryAffineSystem.configure_default_state(self:</span> <span class="pre">pydrake.systems.primitives.TrajectoryAffineSystem,</span> <span class="pre">x0:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Configures the value that will be assigned to the state vector in
<code class="docutils literal notranslate"><span class="pre">SetDefaultContext</span></code>. <cite>x0</cite> must be a vector of length <code class="docutils literal notranslate"><span class="pre">num_states</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectoryAffineSystem.configure_random_state(self:</span> <span class="pre">pydrake.systems.primitives.TrajectoryAffineSystem,</span> <span class="pre">covariance:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Configures the Gaussian distribution over state vectors used in the
<code class="docutils literal notranslate"><span class="pre">SetRandomContext</span></code> methods. The mean of the distribution will be the
default state (</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>configure_default_state()). <code class="docutils literal notranslate"><span class="pre">covariance</span></code> must have size
<code class="docutils literal notranslate"><span class="pre">num_states</span></code> by <code class="docutils literal notranslate"><span class="pre">num_states</span></code> and must be symmetric and
positive semi-definite.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectoryAffineSystem.D(self:</span> <span class="pre">pydrake.systems.primitives.TrajectoryAffineSystem,</span> <span class="pre">arg0:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectoryAffineSystem.f0(self:</span> <span class="pre">pydrake.systems.primitives.TrajectoryAffineSystem,</span> <span class="pre">arg0:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectoryAffineSystem.time_period(self:</span> <span class="pre">pydrake.systems.primitives.TrajectoryAffineSystem)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectoryAffineSystem.y0(self:</span> <span class="pre">pydrake.systems.primitives.TrajectoryAffineSystem,</span> <span class="pre">arg0:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectoryAffineSystem_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">TrajectoryAffineSystem_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">TrajectoryAffineSystem_[AutoDiffXd]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectoryAffineSystem_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></code></p>
<p>A continuous- or discrete-time Affine Time-Varying system with system
matrices described by trajectories.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>TrajectoryAffineSystem</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectoryAffineSystem_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.systems.primitives.TrajectoryAffineSystem_[AutoDiffXd],</span> <span class="pre">A:</span> <span class="pre">pydrake.trajectories.Trajectory,</span> <span class="pre">B:</span> <span class="pre">pydrake.trajectories.Trajectory,</span> <span class="pre">f0:</span> <span class="pre">pydrake.trajectories.Trajectory,</span> <span class="pre">C:</span> <span class="pre">pydrake.trajectories.Trajectory,</span> <span class="pre">D:</span> <span class="pre">pydrake.trajectories.Trajectory,</span> <span class="pre">y0:</span> <span class="pre">pydrake.trajectories.Trajectory,</span> <span class="pre">time_period:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0.0)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a TrajectoryAffineSystem from trajectories of matrices.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time_period</span></code>:</dt><dd><p>Defines the period of the discrete time system; use
time_period=0.0 to denote a continuous time system. $*Default:*
0.0</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectoryAffineSystem_[AutoDiffXd].A(self:</span> <span class="pre">pydrake.systems.primitives.TrajectoryAffineSystem_[AutoDiffXd],</span> <span class="pre">arg0:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>&#64;name Implementations of TimeVaryingAffineSystem&lt;T&gt;’s pure virtual
methods.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectoryAffineSystem_[AutoDiffXd].B(self:</span> <span class="pre">pydrake.systems.primitives.TrajectoryAffineSystem_[AutoDiffXd],</span> <span class="pre">arg0:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectoryAffineSystem_[AutoDiffXd].C(self:</span> <span class="pre">pydrake.systems.primitives.TrajectoryAffineSystem_[AutoDiffXd],</span> <span class="pre">arg0:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectoryAffineSystem_[AutoDiffXd].configure_default_state(self:</span> <span class="pre">pydrake.systems.primitives.TrajectoryAffineSystem_[AutoDiffXd],</span> <span class="pre">x0:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Configures the value that will be assigned to the state vector in
<code class="docutils literal notranslate"><span class="pre">SetDefaultContext</span></code>. <cite>x0</cite> must be a vector of length <code class="docutils literal notranslate"><span class="pre">num_states</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectoryAffineSystem_[AutoDiffXd].configure_random_state(self:</span> <span class="pre">pydrake.systems.primitives.TrajectoryAffineSystem_[AutoDiffXd],</span> <span class="pre">covariance:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Configures the Gaussian distribution over state vectors used in the
<code class="docutils literal notranslate"><span class="pre">SetRandomContext</span></code> methods. The mean of the distribution will be the
default state (</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>configure_default_state()). <code class="docutils literal notranslate"><span class="pre">covariance</span></code> must have size
<code class="docutils literal notranslate"><span class="pre">num_states</span></code> by <code class="docutils literal notranslate"><span class="pre">num_states</span></code> and must be symmetric and
positive semi-definite.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectoryAffineSystem_[AutoDiffXd].D(self:</span> <span class="pre">pydrake.systems.primitives.TrajectoryAffineSystem_[AutoDiffXd],</span> <span class="pre">arg0:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectoryAffineSystem_[AutoDiffXd].f0(self:</span> <span class="pre">pydrake.systems.primitives.TrajectoryAffineSystem_[AutoDiffXd],</span> <span class="pre">arg0:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectoryAffineSystem_[AutoDiffXd].time_period(self:</span> <span class="pre">pydrake.systems.primitives.TrajectoryAffineSystem_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectoryAffineSystem_[AutoDiffXd].y0(self:</span> <span class="pre">pydrake.systems.primitives.TrajectoryAffineSystem_[AutoDiffXd],</span> <span class="pre">arg0:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectoryLinearSystem</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></p>
<p>A continuous- or discrete-time Linear Time-Varying system with system
matrices described by trajectories.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>TrajectoryLinearSystem</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">TrajectoryLinearSystem_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectoryLinearSystem.__init__(self:</span> <span class="pre">pydrake.systems.primitives.TrajectoryLinearSystem,</span> <span class="pre">A:</span> <span class="pre">pydrake.trajectories.Trajectory,</span> <span class="pre">B:</span> <span class="pre">pydrake.trajectories.Trajectory,</span> <span class="pre">C:</span> <span class="pre">pydrake.trajectories.Trajectory,</span> <span class="pre">D:</span> <span class="pre">pydrake.trajectories.Trajectory,</span> <span class="pre">time_period:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0.0)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a PiecewisePolynomialLinearSystem from a
LinearTimeVaryingData structure.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time_period</span></code>:</dt><dd><p>Defines the period of the discrete time system; use
time_period=0.0 to denote a continuous time system. $*Default:*
0.0</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectoryLinearSystem.A(self:</span> <span class="pre">pydrake.systems.primitives.TrajectoryLinearSystem,</span> <span class="pre">arg0:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>&#64;name Implementations of PiecewisePolynomialLinearSystem&lt;T&gt;’s pure
virtual methods.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectoryLinearSystem.B(self:</span> <span class="pre">pydrake.systems.primitives.TrajectoryLinearSystem,</span> <span class="pre">arg0:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectoryLinearSystem.C(self:</span> <span class="pre">pydrake.systems.primitives.TrajectoryLinearSystem,</span> <span class="pre">arg0:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectoryLinearSystem.configure_default_state(self:</span> <span class="pre">pydrake.systems.primitives.TrajectoryLinearSystem,</span> <span class="pre">x0:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Configures the value that will be assigned to the state vector in
<code class="docutils literal notranslate"><span class="pre">SetDefaultContext</span></code>. <cite>x0</cite> must be a vector of length <code class="docutils literal notranslate"><span class="pre">num_states</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectoryLinearSystem.configure_random_state(self:</span> <span class="pre">pydrake.systems.primitives.TrajectoryLinearSystem,</span> <span class="pre">covariance:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Configures the Gaussian distribution over state vectors used in the
<code class="docutils literal notranslate"><span class="pre">SetRandomContext</span></code> methods. The mean of the distribution will be the
default state (</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>configure_default_state()). <code class="docutils literal notranslate"><span class="pre">covariance</span></code> must have size
<code class="docutils literal notranslate"><span class="pre">num_states</span></code> by <code class="docutils literal notranslate"><span class="pre">num_states</span></code> and must be symmetric and
positive semi-definite.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectoryLinearSystem.D(self:</span> <span class="pre">pydrake.systems.primitives.TrajectoryLinearSystem,</span> <span class="pre">arg0:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectoryLinearSystem.time_period(self:</span> <span class="pre">pydrake.systems.primitives.TrajectoryLinearSystem)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectoryLinearSystem_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">TrajectoryLinearSystem_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">TrajectoryLinearSystem_[AutoDiffXd]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectoryLinearSystem_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></code></p>
<p>A continuous- or discrete-time Linear Time-Varying system with system
matrices described by trajectories.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>TrajectoryLinearSystem</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectoryLinearSystem_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.systems.primitives.TrajectoryLinearSystem_[AutoDiffXd],</span> <span class="pre">A:</span> <span class="pre">pydrake.trajectories.Trajectory,</span> <span class="pre">B:</span> <span class="pre">pydrake.trajectories.Trajectory,</span> <span class="pre">C:</span> <span class="pre">pydrake.trajectories.Trajectory,</span> <span class="pre">D:</span> <span class="pre">pydrake.trajectories.Trajectory,</span> <span class="pre">time_period:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0.0)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a PiecewisePolynomialLinearSystem from a
LinearTimeVaryingData structure.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time_period</span></code>:</dt><dd><p>Defines the period of the discrete time system; use
time_period=0.0 to denote a continuous time system. $*Default:*
0.0</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectoryLinearSystem_[AutoDiffXd].A(self:</span> <span class="pre">pydrake.systems.primitives.TrajectoryLinearSystem_[AutoDiffXd],</span> <span class="pre">arg0:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>&#64;name Implementations of PiecewisePolynomialLinearSystem&lt;T&gt;’s pure
virtual methods.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectoryLinearSystem_[AutoDiffXd].B(self:</span> <span class="pre">pydrake.systems.primitives.TrajectoryLinearSystem_[AutoDiffXd],</span> <span class="pre">arg0:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectoryLinearSystem_[AutoDiffXd].C(self:</span> <span class="pre">pydrake.systems.primitives.TrajectoryLinearSystem_[AutoDiffXd],</span> <span class="pre">arg0:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectoryLinearSystem_[AutoDiffXd].configure_default_state(self:</span> <span class="pre">pydrake.systems.primitives.TrajectoryLinearSystem_[AutoDiffXd],</span> <span class="pre">x0:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Configures the value that will be assigned to the state vector in
<code class="docutils literal notranslate"><span class="pre">SetDefaultContext</span></code>. <cite>x0</cite> must be a vector of length <code class="docutils literal notranslate"><span class="pre">num_states</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectoryLinearSystem_[AutoDiffXd].configure_random_state(self:</span> <span class="pre">pydrake.systems.primitives.TrajectoryLinearSystem_[AutoDiffXd],</span> <span class="pre">covariance:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Configures the Gaussian distribution over state vectors used in the
<code class="docutils literal notranslate"><span class="pre">SetRandomContext</span></code> methods. The mean of the distribution will be the
default state (</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>configure_default_state()). <code class="docutils literal notranslate"><span class="pre">covariance</span></code> must have size
<code class="docutils literal notranslate"><span class="pre">num_states</span></code> by <code class="docutils literal notranslate"><span class="pre">num_states</span></code> and must be symmetric and
positive semi-definite.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectoryLinearSystem_[AutoDiffXd].D(self:</span> <span class="pre">pydrake.systems.primitives.TrajectoryLinearSystem_[AutoDiffXd],</span> <span class="pre">arg0:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectoryLinearSystem_[AutoDiffXd].time_period(self:</span> <span class="pre">pydrake.systems.primitives.TrajectoryLinearSystem_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectorySource</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></p>
<p>Given a Trajectory, this System provides an output port with the value
of the trajectory evaluated at the current time.</p>
<p>If the particular Trajectory is not available at the time the System /
Diagram is being constructed, one can create a TrajectorySource with a
placeholder trajectory (e.g. PiecewisePolynomimal(Eigen::VectorXd))
with the correct number of rows, and then use UpdateTrajectory().</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>TrajectorySource</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><p>Note: Scalar conversion is supported from double to any other scalar,
but the stored Trajectory is not automatically scalar converted. You
must call UpdateTrajectory() with an updated Trajectory&lt;T&gt; in order to
fully enable scalar-type support on the trajectory parameters/values.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">TrajectorySource_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectorySource.__init__(self:</span> <span class="pre">pydrake.systems.primitives.TrajectorySource,</span> <span class="pre">trajectory:</span> <span class="pre">pydrake.trajectories.Trajectory,</span> <span class="pre">output_derivative_order:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">zero_derivatives_beyond_limits:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">True)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">trajectory</span></code>:</dt><dd><p>Trajectory used by the system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">output_derivative_order</span></code>:</dt><dd><p>The number of times to take the derivative. Must be greater than
or equal to zero.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">zero_derivatives_beyond_limits</span></code>:</dt><dd><p>All derivatives will be zero before the start time or after the
end time of <code class="docutils literal notranslate"><span class="pre">trajectory</span></code>. However, this clamping is ignored for
T=Expression.</p>
</dd>
<dt>Precondition:</dt><dd><p>The value of <code class="docutils literal notranslate"><span class="pre">trajectory</span></code> is a column vector. More precisely,
trajectory.cols() == 1.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectorySource.UpdateTrajectory(self:</span> <span class="pre">pydrake.systems.primitives.TrajectorySource,</span> <span class="pre">trajectory:</span> <span class="pre">pydrake.trajectories.Trajectory)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Updates the stored trajectory. <code class="docutils literal notranslate"><span class="pre">trajectory</span></code> must have the same
number of rows as the trajectory passed to the constructor.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectorySource_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">TrajectorySource_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">TrajectorySource_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">TrajectorySource_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectorySource_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></code></p>
<p>Given a Trajectory, this System provides an output port with the value
of the trajectory evaluated at the current time.</p>
<p>If the particular Trajectory is not available at the time the System /
Diagram is being constructed, one can create a TrajectorySource with a
placeholder trajectory (e.g. PiecewisePolynomimal(Eigen::VectorXd))
with the correct number of rows, and then use UpdateTrajectory().</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>TrajectorySource</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><p>Note: Scalar conversion is supported from double to any other scalar,
but the stored Trajectory is not automatically scalar converted. You
must call UpdateTrajectory() with an updated Trajectory&lt;T&gt; in order to
fully enable scalar-type support on the trajectory parameters/values.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectorySource_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.systems.primitives.TrajectorySource_[AutoDiffXd],</span> <span class="pre">trajectory:</span> <span class="pre">pydrake.trajectories.Trajectory_[AutoDiffXd],</span> <span class="pre">output_derivative_order:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">zero_derivatives_beyond_limits:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">True)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">trajectory</span></code>:</dt><dd><p>Trajectory used by the system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">output_derivative_order</span></code>:</dt><dd><p>The number of times to take the derivative. Must be greater than
or equal to zero.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">zero_derivatives_beyond_limits</span></code>:</dt><dd><p>All derivatives will be zero before the start time or after the
end time of <code class="docutils literal notranslate"><span class="pre">trajectory</span></code>. However, this clamping is ignored for
T=Expression.</p>
</dd>
<dt>Precondition:</dt><dd><p>The value of <code class="docutils literal notranslate"><span class="pre">trajectory</span></code> is a column vector. More precisely,
trajectory.cols() == 1.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectorySource_[AutoDiffXd].UpdateTrajectory(self:</span> <span class="pre">pydrake.systems.primitives.TrajectorySource_[AutoDiffXd],</span> <span class="pre">trajectory:</span> <span class="pre">pydrake.trajectories.Trajectory_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Updates the stored trajectory. <code class="docutils literal notranslate"><span class="pre">trajectory</span></code> must have the same
number of rows as the trajectory passed to the constructor.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectorySource_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[Expression]</span></code></p>
<p>Given a Trajectory, this System provides an output port with the value
of the trajectory evaluated at the current time.</p>
<p>If the particular Trajectory is not available at the time the System /
Diagram is being constructed, one can create a TrajectorySource with a
placeholder trajectory (e.g. PiecewisePolynomimal(Eigen::VectorXd))
with the correct number of rows, and then use UpdateTrajectory().</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>TrajectorySource</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><p>Note: Scalar conversion is supported from double to any other scalar,
but the stored Trajectory is not automatically scalar converted. You
must call UpdateTrajectory() with an updated Trajectory&lt;T&gt; in order to
fully enable scalar-type support on the trajectory parameters/values.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectorySource_[Expression].__init__(self:</span> <span class="pre">pydrake.systems.primitives.TrajectorySource_[Expression],</span> <span class="pre">trajectory:</span> <span class="pre">pydrake.trajectories.Trajectory_[Expression],</span> <span class="pre">output_derivative_order:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">zero_derivatives_beyond_limits:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">True)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">trajectory</span></code>:</dt><dd><p>Trajectory used by the system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">output_derivative_order</span></code>:</dt><dd><p>The number of times to take the derivative. Must be greater than
or equal to zero.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">zero_derivatives_beyond_limits</span></code>:</dt><dd><p>All derivatives will be zero before the start time or after the
end time of <code class="docutils literal notranslate"><span class="pre">trajectory</span></code>. However, this clamping is ignored for
T=Expression.</p>
</dd>
<dt>Precondition:</dt><dd><p>The value of <code class="docutils literal notranslate"><span class="pre">trajectory</span></code> is a column vector. More precisely,
trajectory.cols() == 1.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">TrajectorySource_[Expression].UpdateTrajectory(self:</span> <span class="pre">pydrake.systems.primitives.TrajectorySource_[Expression],</span> <span class="pre">trajectory:</span> <span class="pre">pydrake.trajectories.Trajectory_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Updates the stored trajectory. <code class="docutils literal notranslate"><span class="pre">trajectory</span></code> must have the same
number of rows as the trajectory passed to the constructor.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLog</span></span></dt>
<dd><p>This utility class serves as an in-memory cache of time-dependent
vector values. Note that this is a standalone class, not a Drake
System. It is primarily intended to support the Drake System primitive
VectorLogSink, but can be used independently.</p>
<p>When the log becomes full, adding more data will cause the allocated
space to double in size. If avoiding memory allocation during some
performance-critical phase is desired, clients can call Reserve() to
pre-allocate log storage.</p>
<p>This object imposes no constraints on the stored data. For example,
times passed to AddData() need not be increasing in order of
insertion, values are allowed to be infinite, NaN, etc.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">VectorLog_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLog.__init__(self:</span> <span class="pre">pydrake.systems.primitives.VectorLog,</span> <span class="pre">input_size:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs the vector log.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">input_size</span></code>:</dt><dd><p>Dimension of the per-time step data set.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLog.AddData(self:</span> <span class="pre">pydrake.systems.primitives.VectorLog,</span> <span class="pre">time:</span> <span class="pre">float,</span> <span class="pre">sample:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Adds a <code class="docutils literal notranslate"><span class="pre">sample</span></code> to the data set with the associated <code class="docutils literal notranslate"><span class="pre">time</span></code> value.
The new sample and time are added to the end of the log. No
constraints are imposed on the values of`time` or <code class="docutils literal notranslate"><span class="pre">sample</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time</span></code>:</dt><dd><p>The time value for this sample.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">sample</span></code>:</dt><dd><p>A vector of data of the declared size for this log.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLog.Clear(self:</span> <span class="pre">pydrake.systems.primitives.VectorLog)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Clears the logged data.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLog.data(self:</span> <span class="pre">pydrake.systems.primitives.VectorLog)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous]</span></span></dt>
<dd><p>Accesses the logged data.</p>
<p>The InnerPanel parameter of the return type indicates that the
compiler can assume aligned access to the data.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLog.get_input_size(self:</span> <span class="pre">pydrake.systems.primitives.VectorLog)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Reports the size of the log’s input vector.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLog.kDefaultCapacity</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLog.num_samples(self:</span> <span class="pre">pydrake.systems.primitives.VectorLog)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of samples taken since construction or last
Clear().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLog.Reserve(self:</span> <span class="pre">pydrake.systems.primitives.VectorLog,</span> <span class="pre">arg0:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Reserve storage for at least <code class="docutils literal notranslate"><span class="pre">capacity</span></code> samples. At construction,
there will be at least <code class="docutils literal notranslate"><span class="pre">kDefaultCapacity</span></code>; use this method to
reserve more.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLog.sample_times(self:</span> <span class="pre">pydrake.systems.primitives.VectorLog)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Accesses the logged time stamps.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLog_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">VectorLog_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">VectorLog_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">VectorLog_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLog_[AutoDiffXd]</span></span></dt>
<dd><p>This utility class serves as an in-memory cache of time-dependent
vector values. Note that this is a standalone class, not a Drake
System. It is primarily intended to support the Drake System primitive
VectorLogSink, but can be used independently.</p>
<p>When the log becomes full, adding more data will cause the allocated
space to double in size. If avoiding memory allocation during some
performance-critical phase is desired, clients can call Reserve() to
pre-allocate log storage.</p>
<p>This object imposes no constraints on the stored data. For example,
times passed to AddData() need not be increasing in order of
insertion, values are allowed to be infinite, NaN, etc.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLog_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.systems.primitives.VectorLog_[AutoDiffXd],</span> <span class="pre">input_size:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs the vector log.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">input_size</span></code>:</dt><dd><p>Dimension of the per-time step data set.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLog_[AutoDiffXd].AddData(self:</span> <span class="pre">pydrake.systems.primitives.VectorLog_[AutoDiffXd],</span> <span class="pre">time:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">sample:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Adds a <code class="docutils literal notranslate"><span class="pre">sample</span></code> to the data set with the associated <code class="docutils literal notranslate"><span class="pre">time</span></code> value.
The new sample and time are added to the end of the log. No
constraints are imposed on the values of`time` or <code class="docutils literal notranslate"><span class="pre">sample</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time</span></code>:</dt><dd><p>The time value for this sample.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">sample</span></code>:</dt><dd><p>A vector of data of the declared size for this log.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLog_[AutoDiffXd].Clear(self:</span> <span class="pre">pydrake.systems.primitives.VectorLog_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Clears the logged data.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLog_[AutoDiffXd].data(self:</span> <span class="pre">pydrake.systems.primitives.VectorLog_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>Accesses the logged data.</p>
<p>The InnerPanel parameter of the return type indicates that the
compiler can assume aligned access to the data.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLog_[AutoDiffXd].get_input_size(self:</span> <span class="pre">pydrake.systems.primitives.VectorLog_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Reports the size of the log’s input vector.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLog_[AutoDiffXd].kDefaultCapacity</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLog_[AutoDiffXd].num_samples(self:</span> <span class="pre">pydrake.systems.primitives.VectorLog_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of samples taken since construction or last
Clear().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLog_[AutoDiffXd].Reserve(self:</span> <span class="pre">pydrake.systems.primitives.VectorLog_[AutoDiffXd],</span> <span class="pre">arg0:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Reserve storage for at least <code class="docutils literal notranslate"><span class="pre">capacity</span></code> samples. At construction,
there will be at least <code class="docutils literal notranslate"><span class="pre">kDefaultCapacity</span></code>; use this method to
reserve more.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLog_[AutoDiffXd].sample_times(self:</span> <span class="pre">pydrake.systems.primitives.VectorLog_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Accesses the logged time stamps.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLog_[Expression]</span></span></dt>
<dd><p>This utility class serves as an in-memory cache of time-dependent
vector values. Note that this is a standalone class, not a Drake
System. It is primarily intended to support the Drake System primitive
VectorLogSink, but can be used independently.</p>
<p>When the log becomes full, adding more data will cause the allocated
space to double in size. If avoiding memory allocation during some
performance-critical phase is desired, clients can call Reserve() to
pre-allocate log storage.</p>
<p>This object imposes no constraints on the stored data. For example,
times passed to AddData() need not be increasing in order of
insertion, values are allowed to be infinite, NaN, etc.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLog_[Expression].__init__(self:</span> <span class="pre">pydrake.systems.primitives.VectorLog_[Expression],</span> <span class="pre">input_size:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs the vector log.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">input_size</span></code>:</dt><dd><p>Dimension of the per-time step data set.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLog_[Expression].AddData(self:</span> <span class="pre">pydrake.systems.primitives.VectorLog_[Expression],</span> <span class="pre">time:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">sample:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Adds a <code class="docutils literal notranslate"><span class="pre">sample</span></code> to the data set with the associated <code class="docutils literal notranslate"><span class="pre">time</span></code> value.
The new sample and time are added to the end of the log. No
constraints are imposed on the values of`time` or <code class="docutils literal notranslate"><span class="pre">sample</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time</span></code>:</dt><dd><p>The time value for this sample.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">sample</span></code>:</dt><dd><p>A vector of data of the declared size for this log.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLog_[Expression].Clear(self:</span> <span class="pre">pydrake.systems.primitives.VectorLog_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Clears the logged data.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLog_[Expression].data(self:</span> <span class="pre">pydrake.systems.primitives.VectorLog_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>Accesses the logged data.</p>
<p>The InnerPanel parameter of the return type indicates that the
compiler can assume aligned access to the data.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLog_[Expression].get_input_size(self:</span> <span class="pre">pydrake.systems.primitives.VectorLog_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Reports the size of the log’s input vector.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLog_[Expression].kDefaultCapacity</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLog_[Expression].num_samples(self:</span> <span class="pre">pydrake.systems.primitives.VectorLog_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of samples taken since construction or last
Clear().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLog_[Expression].Reserve(self:</span> <span class="pre">pydrake.systems.primitives.VectorLog_[Expression],</span> <span class="pre">arg0:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Reserve storage for at least <code class="docutils literal notranslate"><span class="pre">capacity</span></code> samples. At construction,
there will be at least <code class="docutils literal notranslate"><span class="pre">kDefaultCapacity</span></code>; use this method to
reserve more.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLog_[Expression].sample_times(self:</span> <span class="pre">pydrake.systems.primitives.VectorLog_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Accesses the logged time stamps.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLogSink</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></p>
<p>A discrete sink block which logs its vector-valued input to
per-context memory. This data is then retrievable outside of System
operation, e.g. after a simulation. See the warning below.</p>
<p>The stored log (a VectorLog) holds a large, Eigen matrix for data
storage, where each column corresponds to a data point. The
VectorLogSink saves a data point and the context time whenever it
samples its input.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The logged data MUST NOT be used to modify the behavior of a
simulation. In technical terms, the log is not stored as System
State, so should not be considered part of that state. This
distinction allows the implementation to use <code class="docutils literal notranslate"><span class="pre">Publish()</span></code> as the
event handler, rather than one of the state-modifying handlers.</p>
</div>
<p>By default, sampling is performed every time the Simulator completes a
trajectory-advancing substep (that is, via a per-step Publish event),
with the first sample occurring during Simulator::Initialize(). That
means the samples will generally be unevenly spaced in time. If you
prefer regular sampling, you may optionally specify a “publish period”
in which case sampling occurs periodically, with the first sample
occurring at time 0. Alternatively (not common), you can specify that
logging should only occur at “forced publish” events, meaning at
explicit calls to System::Publish(). The Simulator’s “publish every
time step” option also results in forced publish events, so should be
disabled (the default setting) if you want to control logging
yourself.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>LogVectorOutput() for a convenient way to add logging to a
Diagram.</p>
</div>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">data&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>VectorLogSink</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0></table></td></tr></table><div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">VectorLogSink_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLogSink.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.primitives.VectorLogSink, input_size: int, publish_period: float = 0.0) -&gt; None</p></li>
</ol>
<p>Constructs the vector log sink.</p>
<p>Sets the default set of publish triggers: if publish_period = 0,
publishes on forced events and per step, if publish_period &gt; 0,
publishes on forced events and periodically.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">input_size</span></code>:</dt><dd><p>Dimension of the (single) input port. This corresponds to the
number of rows of the data matrix.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">publish_period</span></code>:</dt><dd><p>Period that messages will be published (optional). If the publish
period is zero or not supplied, VectorLogSink will use per-step
publishing instead; see LeafSystem::DeclarePerStepPublishEvent().</p>
</dd>
<dt>Precondition:</dt><dd><p>publish_period is non-negative.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>LogVectorOutput() helper function for a convenient way to add
logging.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.primitives.VectorLogSink, input_size: int, publish_triggers: set[pydrake.systems.framework.TriggerType], publish_period: float = 0.0) -&gt; None</p></li>
</ol>
<p>Constructs the vector log sink with a specified set of publish
triggers.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">input_size</span></code>:</dt><dd><p>Dimension of the (single) input port. This corresponds to the
number of rows of the data matrix.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">publish_triggers</span></code>:</dt><dd><p>Set of triggers that determine when messages will be published.
Supported TriggerTypes are {kForced, kPeriodic, kPerStep}. Will
throw an error if empty or if unsupported types are provided.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">publish_period</span></code>:</dt><dd><p>Period that messages will be published (optional). publish_period
should only be non-zero if one of the publish_triggers is
kPeriodic.</p>
</dd>
<dt>Precondition:</dt><dd><p>publish_period is non-negative.</p>
</dd>
<dt>Precondition:</dt><dd><p>publish_period &gt; 0 if and only if publish_triggers contains
kPeriodic.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>LogVectorOutput() helper function for a convenient way to add
logging.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLogSink.FindLog(self:</span> <span class="pre">pydrake.systems.primitives.VectorLogSink,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.primitives.VectorLog</span></span></dt>
<dd><p>Access the log within a containing root context.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if supplied context is not a root context</strong><strong>, or </strong><strong>was not</strong> – </p></li>
<li><p><strong>created for the containing diagram.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLogSink.FindMutableLog(self:</span> <span class="pre">pydrake.systems.primitives.VectorLogSink,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.primitives.VectorLog</span></span></dt>
<dd><p>Access the log as a mutable object within a containing root context.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if supplied context is not a root context</strong><strong>, or </strong><strong>was not</strong> – </p></li>
<li><p><strong>created for the containing diagram.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLogSink.GetLog(self:</span> <span class="pre">pydrake.systems.primitives.VectorLogSink,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.primitives.VectorLog</span></span></dt>
<dd><p>Access the log within this component’s context.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if context was not created for this system.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLogSink.GetMutableLog(self:</span> <span class="pre">pydrake.systems.primitives.VectorLogSink,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.primitives.VectorLog</span></span></dt>
<dd><p>Access the log as a mutable object within this component’s context.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if context was not created for this system.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLogSink_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">VectorLogSink_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">VectorLogSink_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">VectorLogSink_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLogSink_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></code></p>
<p>A discrete sink block which logs its vector-valued input to
per-context memory. This data is then retrievable outside of System
operation, e.g. after a simulation. See the warning below.</p>
<p>The stored log (a VectorLog) holds a large, Eigen matrix for data
storage, where each column corresponds to a data point. The
VectorLogSink saves a data point and the context time whenever it
samples its input.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The logged data MUST NOT be used to modify the behavior of a
simulation. In technical terms, the log is not stored as System
State, so should not be considered part of that state. This
distinction allows the implementation to use <code class="docutils literal notranslate"><span class="pre">Publish()</span></code> as the
event handler, rather than one of the state-modifying handlers.</p>
</div>
<p>By default, sampling is performed every time the Simulator completes a
trajectory-advancing substep (that is, via a per-step Publish event),
with the first sample occurring during Simulator::Initialize(). That
means the samples will generally be unevenly spaced in time. If you
prefer regular sampling, you may optionally specify a “publish period”
in which case sampling occurs periodically, with the first sample
occurring at time 0. Alternatively (not common), you can specify that
logging should only occur at “forced publish” events, meaning at
explicit calls to System::Publish(). The Simulator’s “publish every
time step” option also results in forced publish events, so should be
disabled (the default setting) if you want to control logging
yourself.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>LogVectorOutput() for a convenient way to add logging to a
Diagram.</p>
</div>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">data&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>VectorLogSink</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0></table></td></tr></table><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLogSink_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.primitives.VectorLogSink_[AutoDiffXd], input_size: int, publish_period: float = 0.0) -&gt; None</p></li>
</ol>
<p>Constructs the vector log sink.</p>
<p>Sets the default set of publish triggers: if publish_period = 0,
publishes on forced events and per step, if publish_period &gt; 0,
publishes on forced events and periodically.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">input_size</span></code>:</dt><dd><p>Dimension of the (single) input port. This corresponds to the
number of rows of the data matrix.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">publish_period</span></code>:</dt><dd><p>Period that messages will be published (optional). If the publish
period is zero or not supplied, VectorLogSink will use per-step
publishing instead; see LeafSystem::DeclarePerStepPublishEvent().</p>
</dd>
<dt>Precondition:</dt><dd><p>publish_period is non-negative.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>LogVectorOutput() helper function for a convenient way to add
logging.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.primitives.VectorLogSink_[AutoDiffXd], input_size: int, publish_triggers: set[pydrake.systems.framework.TriggerType], publish_period: float = 0.0) -&gt; None</p></li>
</ol>
<p>Constructs the vector log sink with a specified set of publish
triggers.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">input_size</span></code>:</dt><dd><p>Dimension of the (single) input port. This corresponds to the
number of rows of the data matrix.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">publish_triggers</span></code>:</dt><dd><p>Set of triggers that determine when messages will be published.
Supported TriggerTypes are {kForced, kPeriodic, kPerStep}. Will
throw an error if empty or if unsupported types are provided.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">publish_period</span></code>:</dt><dd><p>Period that messages will be published (optional). publish_period
should only be non-zero if one of the publish_triggers is
kPeriodic.</p>
</dd>
<dt>Precondition:</dt><dd><p>publish_period is non-negative.</p>
</dd>
<dt>Precondition:</dt><dd><p>publish_period &gt; 0 if and only if publish_triggers contains
kPeriodic.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>LogVectorOutput() helper function for a convenient way to add
logging.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLogSink_[AutoDiffXd].FindLog(self:</span> <span class="pre">pydrake.systems.primitives.VectorLogSink_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.primitives.VectorLog_[AutoDiffXd]</span></span></dt>
<dd><p>Access the log within a containing root context.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if supplied context is not a root context</strong><strong>, or </strong><strong>was not</strong> – </p></li>
<li><p><strong>created for the containing diagram.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLogSink_[AutoDiffXd].FindMutableLog(self:</span> <span class="pre">pydrake.systems.primitives.VectorLogSink_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.primitives.VectorLog_[AutoDiffXd]</span></span></dt>
<dd><p>Access the log as a mutable object within a containing root context.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if supplied context is not a root context</strong><strong>, or </strong><strong>was not</strong> – </p></li>
<li><p><strong>created for the containing diagram.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLogSink_[AutoDiffXd].GetLog(self:</span> <span class="pre">pydrake.systems.primitives.VectorLogSink_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.primitives.VectorLog_[AutoDiffXd]</span></span></dt>
<dd><p>Access the log within this component’s context.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if context was not created for this system.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLogSink_[AutoDiffXd].GetMutableLog(self:</span> <span class="pre">pydrake.systems.primitives.VectorLogSink_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.primitives.VectorLog_[AutoDiffXd]</span></span></dt>
<dd><p>Access the log as a mutable object within this component’s context.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if context was not created for this system.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLogSink_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[Expression]</span></code></p>
<p>A discrete sink block which logs its vector-valued input to
per-context memory. This data is then retrievable outside of System
operation, e.g. after a simulation. See the warning below.</p>
<p>The stored log (a VectorLog) holds a large, Eigen matrix for data
storage, where each column corresponds to a data point. The
VectorLogSink saves a data point and the context time whenever it
samples its input.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The logged data MUST NOT be used to modify the behavior of a
simulation. In technical terms, the log is not stored as System
State, so should not be considered part of that state. This
distinction allows the implementation to use <code class="docutils literal notranslate"><span class="pre">Publish()</span></code> as the
event handler, rather than one of the state-modifying handlers.</p>
</div>
<p>By default, sampling is performed every time the Simulator completes a
trajectory-advancing substep (that is, via a per-step Publish event),
with the first sample occurring during Simulator::Initialize(). That
means the samples will generally be unevenly spaced in time. If you
prefer regular sampling, you may optionally specify a “publish period”
in which case sampling occurs periodically, with the first sample
occurring at time 0. Alternatively (not common), you can specify that
logging should only occur at “forced publish” events, meaning at
explicit calls to System::Publish(). The Simulator’s “publish every
time step” option also results in forced publish events, so should be
disabled (the default setting) if you want to control logging
yourself.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>LogVectorOutput() for a convenient way to add logging to a
Diagram.</p>
</div>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">data&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>VectorLogSink</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0></table></td></tr></table><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLogSink_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.primitives.VectorLogSink_[Expression], input_size: int, publish_period: float = 0.0) -&gt; None</p></li>
</ol>
<p>Constructs the vector log sink.</p>
<p>Sets the default set of publish triggers: if publish_period = 0,
publishes on forced events and per step, if publish_period &gt; 0,
publishes on forced events and periodically.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">input_size</span></code>:</dt><dd><p>Dimension of the (single) input port. This corresponds to the
number of rows of the data matrix.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">publish_period</span></code>:</dt><dd><p>Period that messages will be published (optional). If the publish
period is zero or not supplied, VectorLogSink will use per-step
publishing instead; see LeafSystem::DeclarePerStepPublishEvent().</p>
</dd>
<dt>Precondition:</dt><dd><p>publish_period is non-negative.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>LogVectorOutput() helper function for a convenient way to add
logging.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.primitives.VectorLogSink_[Expression], input_size: int, publish_triggers: set[pydrake.systems.framework.TriggerType], publish_period: float = 0.0) -&gt; None</p></li>
</ol>
<p>Constructs the vector log sink with a specified set of publish
triggers.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">input_size</span></code>:</dt><dd><p>Dimension of the (single) input port. This corresponds to the
number of rows of the data matrix.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">publish_triggers</span></code>:</dt><dd><p>Set of triggers that determine when messages will be published.
Supported TriggerTypes are {kForced, kPeriodic, kPerStep}. Will
throw an error if empty or if unsupported types are provided.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">publish_period</span></code>:</dt><dd><p>Period that messages will be published (optional). publish_period
should only be non-zero if one of the publish_triggers is
kPeriodic.</p>
</dd>
<dt>Precondition:</dt><dd><p>publish_period is non-negative.</p>
</dd>
<dt>Precondition:</dt><dd><p>publish_period &gt; 0 if and only if publish_triggers contains
kPeriodic.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>LogVectorOutput() helper function for a convenient way to add
logging.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLogSink_[Expression].FindLog(self:</span> <span class="pre">pydrake.systems.primitives.VectorLogSink_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.primitives.VectorLog_[Expression]</span></span></dt>
<dd><p>Access the log within a containing root context.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if supplied context is not a root context</strong><strong>, or </strong><strong>was not</strong> – </p></li>
<li><p><strong>created for the containing diagram.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLogSink_[Expression].FindMutableLog(self:</span> <span class="pre">pydrake.systems.primitives.VectorLogSink_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.primitives.VectorLog_[Expression]</span></span></dt>
<dd><p>Access the log as a mutable object within a containing root context.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if supplied context is not a root context</strong><strong>, or </strong><strong>was not</strong> – </p></li>
<li><p><strong>created for the containing diagram.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLogSink_[Expression].GetLog(self:</span> <span class="pre">pydrake.systems.primitives.VectorLogSink_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.primitives.VectorLog_[Expression]</span></span></dt>
<dd><p>Access the log within this component’s context.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if context was not created for this system.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VectorLogSink_[Expression].GetMutableLog(self:</span> <span class="pre">pydrake.systems.primitives.VectorLogSink_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.primitives.VectorLog_[Expression]</span></span></dt>
<dd><p>Access the log as a mutable object within this component’s context.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if context was not created for this system.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">WrapToSystem</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></p>
<p>An element-wise wrapping block that transforms the specified indices
of the input signal <code class="docutils literal notranslate"><span class="pre">u</span></code> into the interval <code class="docutils literal notranslate"><span class="pre">[low,</span> <span class="pre">high)</span></code>.
Precisely, the output element <code class="docutils literal notranslate"><span class="pre">i</span></code> is given the value:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">outputᵢ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inputᵢ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">kᵢ</span><span class="o">*</span><span class="p">(</span><span class="n">highᵢ</span><span class="o">-</span><span class="n">lowᵢ</span><span class="p">)</span>
</pre></div>
</div>
</details><p>for the unique integer value <code class="docutils literal notranslate"><span class="pre">kᵢ</span></code> that lands the output in the
desired interval.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>WrapToSystem</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">WrapToSystem_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">WrapToSystem.__init__(self:</span> <span class="pre">pydrake.systems.primitives.WrapToSystem,</span> <span class="pre">arg0:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a system to pass through a fixed-size input vector to the
output. Additional calls to set_interval() are required to produce any
wrapping behavior.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">WrapToSystem.set_interval(self:</span> <span class="pre">pydrake.systems.primitives.WrapToSystem,</span> <span class="pre">arg0:</span> <span class="pre">int,</span> <span class="pre">arg1:</span> <span class="pre">float,</span> <span class="pre">arg2:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the system to wrap the <code class="docutils literal notranslate"><span class="pre">index</span></code> element of the input vector to
the interval <code class="docutils literal notranslate"><span class="pre">[low,</span> <span class="pre">high)</span></code>. If this method is called multiple times
for the same index, then only the last interval will be used. <code class="docutils literal notranslate"><span class="pre">low</span></code>
and <code class="docutils literal notranslate"><span class="pre">high</span></code> should be finite, and low &lt; high.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">WrapToSystem_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">WrapToSystem_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">WrapToSystem_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">WrapToSystem_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">WrapToSystem_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></code></p>
<p>An element-wise wrapping block that transforms the specified indices
of the input signal <code class="docutils literal notranslate"><span class="pre">u</span></code> into the interval <code class="docutils literal notranslate"><span class="pre">[low,</span> <span class="pre">high)</span></code>.
Precisely, the output element <code class="docutils literal notranslate"><span class="pre">i</span></code> is given the value:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">outputᵢ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inputᵢ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">kᵢ</span><span class="o">*</span><span class="p">(</span><span class="n">highᵢ</span><span class="o">-</span><span class="n">lowᵢ</span><span class="p">)</span>
</pre></div>
</div>
</details><p>for the unique integer value <code class="docutils literal notranslate"><span class="pre">kᵢ</span></code> that lands the output in the
desired interval.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>WrapToSystem</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">WrapToSystem_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.systems.primitives.WrapToSystem_[AutoDiffXd],</span> <span class="pre">arg0:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a system to pass through a fixed-size input vector to the
output. Additional calls to set_interval() are required to produce any
wrapping behavior.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">WrapToSystem_[AutoDiffXd].set_interval(self:</span> <span class="pre">pydrake.systems.primitives.WrapToSystem_[AutoDiffXd],</span> <span class="pre">arg0:</span> <span class="pre">int,</span> <span class="pre">arg1:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">arg2:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the system to wrap the <code class="docutils literal notranslate"><span class="pre">index</span></code> element of the input vector to
the interval <code class="docutils literal notranslate"><span class="pre">[low,</span> <span class="pre">high)</span></code>. If this method is called multiple times
for the same index, then only the last interval will be used. <code class="docutils literal notranslate"><span class="pre">low</span></code>
and <code class="docutils literal notranslate"><span class="pre">high</span></code> should be finite, and low &lt; high.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">WrapToSystem_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[Expression]</span></code></p>
<p>An element-wise wrapping block that transforms the specified indices
of the input signal <code class="docutils literal notranslate"><span class="pre">u</span></code> into the interval <code class="docutils literal notranslate"><span class="pre">[low,</span> <span class="pre">high)</span></code>.
Precisely, the output element <code class="docutils literal notranslate"><span class="pre">i</span></code> is given the value:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">outputᵢ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">inputᵢ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">kᵢ</span><span class="o">*</span><span class="p">(</span><span class="n">highᵢ</span><span class="o">-</span><span class="n">lowᵢ</span><span class="p">)</span>
</pre></div>
</div>
</details><p>for the unique integer value <code class="docutils literal notranslate"><span class="pre">kᵢ</span></code> that lands the output in the
desired interval.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u0&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>WrapToSystem</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y0</td></tr></table></td></tr></table><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">WrapToSystem_[Expression].__init__(self:</span> <span class="pre">pydrake.systems.primitives.WrapToSystem_[Expression],</span> <span class="pre">arg0:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a system to pass through a fixed-size input vector to the
output. Additional calls to set_interval() are required to produce any
wrapping behavior.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">WrapToSystem_[Expression].set_interval(self:</span> <span class="pre">pydrake.systems.primitives.WrapToSystem_[Expression],</span> <span class="pre">arg0:</span> <span class="pre">int,</span> <span class="pre">arg1:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">arg2:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the system to wrap the <code class="docutils literal notranslate"><span class="pre">index</span></code> element of the input vector to
the interval <code class="docutils literal notranslate"><span class="pre">[low,</span> <span class="pre">high)</span></code>. If this method is called multiple times
for the same index, then only the last interval will be used. <code class="docutils literal notranslate"><span class="pre">low</span></code>
and <code class="docutils literal notranslate"><span class="pre">high</span></code> should be finite, and low &lt; high.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ZeroOrderHold</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></p>
<p>A zero order hold block with input u, which may be vector-valued
(discrete or continuous) or abstract, and discrete output y, where the
y is sampled from u with a fixed period (and optional offset).</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>ZeroOrderHold</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y</td></tr></table></td></tr></table><p>The discrete state space dynamics of ZeroOrderHold is:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">xₙ</span><span class="err">₊</span><span class="n">₁</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uₙ</span><span class="w">     </span><span class="c1">// update</span>
<span class="w">  </span><span class="n">yₙ</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">xₙ</span><span class="w">     </span><span class="c1">// output</span>
<span class="w">  </span><span class="n">x₀</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">xᵢₙᵢₜ</span><span class="w">  </span><span class="c1">// initialize</span>
</pre></div>
</div>
</details><p>where xᵢₙᵢₜ = 0 for vector-valued ZeroOrderHold, and xᵢₙᵢₜ is a given
value for abstract-valued ZeroOrderHold. Use SetVectorState() to set
xₙ in the context for vector-valued ZeroOrderHold.</p>
<p>See discrete_systems “Discrete Systems” for general information about
discrete systems in Drake, including how they interact with continuous
systems.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This system defaults to a periodic update with zero offset, in
which case the first update occurs at t=0. When used with a
Simulator, the output port is equal to xᵢₙᵢₜ after
simulator.Initialize(), but is immediately updated to u₀ at the
start of the first step. If you want to force that initial update,
use simulator.AdvanceTo(0.0).</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For an abstract-valued ZeroOrderHold, scalar-type conversion is
not supported since AbstractValue does not support it.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">ZeroOrderHold_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ZeroOrderHold.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.primitives.ZeroOrderHold, period_sec: float, vector_size: int, offset_sec: float = 0.0) -&gt; None</p></li>
</ol>
<p>Constructs a ZeroOrderHold system with the given <code class="docutils literal notranslate"><span class="pre">period_sec</span></code>, over
a vector-valued input of size <code class="docutils literal notranslate"><span class="pre">vector_size</span></code>. The default initial
value for this system will be zero. The first update occurs at
t=offset_sec, which must be &gt;= 0.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.primitives.ZeroOrderHold, period_sec: float, abstract_model_value: pydrake.common.value.AbstractValue, offset_sec: float = 0.0) -&gt; None</p></li>
</ol>
<p>Constructs a ZeroOrderHold system with the given <code class="docutils literal notranslate"><span class="pre">period_sec</span></code>, over
a abstract-valued input <code class="docutils literal notranslate"><span class="pre">abstract_model_value</span></code>. The default initial
value for this system will be <code class="docutils literal notranslate"><span class="pre">abstract_model_value</span></code>. The first
update occurs at t=offset_sec, which must be &gt;= 0.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ZeroOrderHold.offset(self:</span> <span class="pre">pydrake.systems.primitives.ZeroOrderHold)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Reports the first update time of this hold (in seconds).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ZeroOrderHold.period(self:</span> <span class="pre">pydrake.systems.primitives.ZeroOrderHold)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Reports the period of this hold (in seconds).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ZeroOrderHold.SetVectorState(self:</span> <span class="pre">pydrake.systems.primitives.ZeroOrderHold,</span> <span class="pre">arg0:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">arg1:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the value of the state by modifying it in the context. <code class="docutils literal notranslate"><span class="pre">value</span></code>
must be a column vector of the appropriate size. This can only be used
to initialize a vector-valued state.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ZeroOrderHold_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">ZeroOrderHold_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ZeroOrderHold_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ZeroOrderHold_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ZeroOrderHold_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></code></p>
<p>A zero order hold block with input u, which may be vector-valued
(discrete or continuous) or abstract, and discrete output y, where the
y is sampled from u with a fixed period (and optional offset).</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>ZeroOrderHold</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y</td></tr></table></td></tr></table><p>The discrete state space dynamics of ZeroOrderHold is:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">xₙ</span><span class="err">₊</span><span class="n">₁</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uₙ</span><span class="w">     </span><span class="c1">// update</span>
<span class="w">  </span><span class="n">yₙ</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">xₙ</span><span class="w">     </span><span class="c1">// output</span>
<span class="w">  </span><span class="n">x₀</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">xᵢₙᵢₜ</span><span class="w">  </span><span class="c1">// initialize</span>
</pre></div>
</div>
</details><p>where xᵢₙᵢₜ = 0 for vector-valued ZeroOrderHold, and xᵢₙᵢₜ is a given
value for abstract-valued ZeroOrderHold. Use SetVectorState() to set
xₙ in the context for vector-valued ZeroOrderHold.</p>
<p>See discrete_systems “Discrete Systems” for general information about
discrete systems in Drake, including how they interact with continuous
systems.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This system defaults to a periodic update with zero offset, in
which case the first update occurs at t=0. When used with a
Simulator, the output port is equal to xᵢₙᵢₜ after
simulator.Initialize(), but is immediately updated to u₀ at the
start of the first step. If you want to force that initial update,
use simulator.AdvanceTo(0.0).</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For an abstract-valued ZeroOrderHold, scalar-type conversion is
not supported since AbstractValue does not support it.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ZeroOrderHold_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.primitives.ZeroOrderHold_[AutoDiffXd], period_sec: float, vector_size: int, offset_sec: float = 0.0) -&gt; None</p></li>
</ol>
<p>Constructs a ZeroOrderHold system with the given <code class="docutils literal notranslate"><span class="pre">period_sec</span></code>, over
a vector-valued input of size <code class="docutils literal notranslate"><span class="pre">vector_size</span></code>. The default initial
value for this system will be zero. The first update occurs at
t=offset_sec, which must be &gt;= 0.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.primitives.ZeroOrderHold_[AutoDiffXd], period_sec: float, abstract_model_value: pydrake.common.value.AbstractValue, offset_sec: float = 0.0) -&gt; None</p></li>
</ol>
<p>Constructs a ZeroOrderHold system with the given <code class="docutils literal notranslate"><span class="pre">period_sec</span></code>, over
a abstract-valued input <code class="docutils literal notranslate"><span class="pre">abstract_model_value</span></code>. The default initial
value for this system will be <code class="docutils literal notranslate"><span class="pre">abstract_model_value</span></code>. The first
update occurs at t=offset_sec, which must be &gt;= 0.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ZeroOrderHold_[AutoDiffXd].offset(self:</span> <span class="pre">pydrake.systems.primitives.ZeroOrderHold_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Reports the first update time of this hold (in seconds).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ZeroOrderHold_[AutoDiffXd].period(self:</span> <span class="pre">pydrake.systems.primitives.ZeroOrderHold_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Reports the period of this hold (in seconds).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ZeroOrderHold_[AutoDiffXd].SetVectorState(self:</span> <span class="pre">pydrake.systems.primitives.ZeroOrderHold_[AutoDiffXd],</span> <span class="pre">arg0:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">arg1:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the value of the state by modifying it in the context. <code class="docutils literal notranslate"><span class="pre">value</span></code>
must be a column vector of the appropriate size. This can only be used
to initialize a vector-valued state.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ZeroOrderHold_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem_[Expression]</span></code></p>
<p>A zero order hold block with input u, which may be vector-valued
(discrete or continuous) or abstract, and discrete output y, where the
y is sampled from u with a fixed period (and optional offset).</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">u&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>ZeroOrderHold</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; y</td></tr></table></td></tr></table><p>The discrete state space dynamics of ZeroOrderHold is:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">xₙ</span><span class="err">₊</span><span class="n">₁</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">uₙ</span><span class="w">     </span><span class="c1">// update</span>
<span class="w">  </span><span class="n">yₙ</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">xₙ</span><span class="w">     </span><span class="c1">// output</span>
<span class="w">  </span><span class="n">x₀</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">xᵢₙᵢₜ</span><span class="w">  </span><span class="c1">// initialize</span>
</pre></div>
</div>
</details><p>where xᵢₙᵢₜ = 0 for vector-valued ZeroOrderHold, and xᵢₙᵢₜ is a given
value for abstract-valued ZeroOrderHold. Use SetVectorState() to set
xₙ in the context for vector-valued ZeroOrderHold.</p>
<p>See discrete_systems “Discrete Systems” for general information about
discrete systems in Drake, including how they interact with continuous
systems.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This system defaults to a periodic update with zero offset, in
which case the first update occurs at t=0. When used with a
Simulator, the output port is equal to xᵢₙᵢₜ after
simulator.Initialize(), but is immediately updated to u₀ at the
start of the first step. If you want to force that initial update,
use simulator.AdvanceTo(0.0).</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For an abstract-valued ZeroOrderHold, scalar-type conversion is
not supported since AbstractValue does not support it.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ZeroOrderHold_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.systems.primitives.ZeroOrderHold_[Expression], period_sec: float, vector_size: int, offset_sec: float = 0.0) -&gt; None</p></li>
</ol>
<p>Constructs a ZeroOrderHold system with the given <code class="docutils literal notranslate"><span class="pre">period_sec</span></code>, over
a vector-valued input of size <code class="docutils literal notranslate"><span class="pre">vector_size</span></code>. The default initial
value for this system will be zero. The first update occurs at
t=offset_sec, which must be &gt;= 0.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.systems.primitives.ZeroOrderHold_[Expression], period_sec: float, abstract_model_value: pydrake.common.value.AbstractValue, offset_sec: float = 0.0) -&gt; None</p></li>
</ol>
<p>Constructs a ZeroOrderHold system with the given <code class="docutils literal notranslate"><span class="pre">period_sec</span></code>, over
a abstract-valued input <code class="docutils literal notranslate"><span class="pre">abstract_model_value</span></code>. The default initial
value for this system will be <code class="docutils literal notranslate"><span class="pre">abstract_model_value</span></code>. The first
update occurs at t=offset_sec, which must be &gt;= 0.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ZeroOrderHold_[Expression].offset(self:</span> <span class="pre">pydrake.systems.primitives.ZeroOrderHold_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Reports the first update time of this hold (in seconds).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ZeroOrderHold_[Expression].period(self:</span> <span class="pre">pydrake.systems.primitives.ZeroOrderHold_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Reports the period of this hold (in seconds).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ZeroOrderHold_[Expression].SetVectorState(self:</span> <span class="pre">pydrake.systems.primitives.ZeroOrderHold_[Expression],</span> <span class="pre">arg0:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">arg1:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the value of the state by modifying it in the context. <code class="docutils literal notranslate"><span class="pre">value</span></code>
must be a column vector of the appropriate size. This can only be used
to initialize a vector-valued state.</p>
</dd></dl>

</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="pydrake.systems.planar_scenegraph_visualizer.html" class="btn btn-neutral float-left" title="pydrake.systems.planar_scenegraph_visualizer" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="pydrake.systems.pyplot_visualizer.html" class="btn btn-neutral float-right" title="pydrake.systems.pyplot_visualizer" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p></p>
  </div>

  
</footer>
<script>
  /* Enables clicking for the mobile "hamburger" (three-line) menu item. */
  const siteHeader = document.querySelector('.site-header')
  const mobileButton = document.querySelector('.menu-mobile-toggle')
  const body = document.querySelector('body')

  mobileButton.addEventListener('click', function(event) {
    siteHeader.classList.toggle('open');
    body.classList.toggle('overflow-hidden');
  })
</script>
<footer class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg">
    </a>
    <div class="footer-menu">
      <ul>
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"></a>
        </li>
      </ul>
    </div>
  </div>


</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>