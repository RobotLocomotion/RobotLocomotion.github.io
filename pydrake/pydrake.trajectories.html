<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pydrake.trajectories &mdash; pydrake  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="pydrake.tutorials" href="pydrake.tutorials.html" />
    <link rel="prev" title="pydrake.systems.sensors" href="pydrake.systems.sensors.html" /> 
</head>

<body class="wy-body-for-nav">
<header class="site-header">
  <div class="site-header-inner contain">
    <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
    <div class="menu-mobile-toggle">
      <span></span>
    </div>
    <nav class="site-menu">
      <ul>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/">Home</a>
        </li>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/installation.html">Installation</a>
        </li>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/gallery.html">Gallery</a>
        </li>
        <li class="site-menu-item site-menu-item-main">API Documentation
          <div class="sub">
            <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a> <a class="site-menu-item" href="/pydrake/index.html">Python</a>
          </div>
        </li>
        <li class="site-menu-item site-menu-item-main">Resources
          <div class="sub">
            <a class="site-menu-item" href="/getting_help.html">Getting Help</a> <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/%2Findex.ipynb">Tutorials</a> <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a> <a class="site-menu-item" href="/developers.html">For Developers</a> <a class="site-menu-item" href="/credits.html">Credits</a>
          </div>
        </li>
        <li class="github-link">
          <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
        </li>
      </ul>
    </nav>
  </div>
</header>

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> pydrake
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search pydrake only…" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
    <input type="text" name="q" placeholder="Search all of Drake…" />
    <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu" />
  </form>
</div>

        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="pydrake.all.html">pydrake.all</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.autodiffutils.html">pydrake.autodiffutils</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.common.html">pydrake.common</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.examples.html">pydrake.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.forwarddiff.html">pydrake.forwarddiff</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.geometry.html">pydrake.geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.gym.html">pydrake.gym</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.lcm.html">pydrake.lcm</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.manipulation.html">pydrake.manipulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.math.html">pydrake.math</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.multibody.html">pydrake.multibody</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.perception.html">pydrake.perception</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.planning.html">pydrake.planning</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.polynomial.html">pydrake.polynomial</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.html">pydrake.solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.symbolic.html">pydrake.symbolic</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.systems.html">pydrake.systems</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">pydrake.trajectories</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.tutorials.html">pydrake.tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.visualization.html">pydrake.visualization</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pydrake</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>pydrake.trajectories</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-pydrake.trajectories">
<span id="pydrake-trajectories"></span><h1>pydrake.trajectories<a class="headerlink" href="#module-pydrake.trajectories" title="Permalink to this headline"></a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.BezierCurve">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">BezierCurve</span></span><a class="headerlink" href="#pydrake.trajectories.BezierCurve" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.Trajectory" title="pydrake.trajectories.Trajectory"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory</span></code></a></p>
<p>A Bézier curve is defined by a set of control points p₀ through pₙ,
where n is called the order of the curve (n = 1 for linear, 2 for
quadratic, 3 for cubic, etc.). The first and last control points are
always the endpoints of the curve; however, the intermediate control
points (if any) generally do not lie on the curve, but the curve is
guaranteed to stay within the convex hull of the control points.</p>
<p>See also BsplineTrajectory. A B-spline can be thought of as a
composition of overlapping Bézier curves (where each evaluation only
depends on a local subset of the control points). In contrast,
evaluating a Bézier curve will use all of the control points.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <a class="reference internal" href="#pydrake.trajectories.BezierCurve_" title="pydrake.trajectories.BezierCurve_"><code class="xref py py-class docutils literal notranslate"><span class="pre">BezierCurve_</span></code></a>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BezierCurve.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.BezierCurve.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.BezierCurve) -&gt; None</p></li>
</ol>
<p>Default initializer. Constructs an empty Bézier curve over the
interval t ∈ [0, 1].</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.trajectories.BezierCurve, start_time: float, end_time: float, control_points: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]) -&gt; None</p></li>
</ol>
<p>Constructs a Bézier curve over the interval t ∈ [<cite>start_time</cite>,
<code class="docutils literal notranslate"><span class="pre">end_time`]</span> <span class="pre">with</span> <span class="pre">control</span> <span class="pre">points</span> <span class="pre">defined</span> <span class="pre">in</span> <span class="pre">the</span> <span class="pre">columns</span> <span class="pre">of</span>
<span class="pre">`control_points</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>end_time &gt;= start_time.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BezierCurve.AsLinearInControlPoints">
<span class="sig-name descname"><span class="pre">AsLinearInControlPoints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BezierCurve" title="pydrake.trajectories.BezierCurve"><span class="pre">pydrake.trajectories.BezierCurve</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">derivative_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">scipy.sparse.csc_matrix</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BezierCurve.AsLinearInControlPoints" title="Permalink to this definition"></a></dt>
<dd><p>Supports writing optimizations using the control points as decision
variables. This method returns the matrix, <code class="docutils literal notranslate"><span class="pre">M</span></code>, defining the control
points of the <code class="docutils literal notranslate"><span class="pre">order</span></code> derivative in the form:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">derivative</span><span class="p">.</span><span class="n">control_points</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">control_points</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">M</span><span class="w"></span>
</pre></div>
</div>
</details><p>For instance, since we have</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">derivative</span><span class="p">.</span><span class="n">control_points</span><span class="p">().</span><span class="n">col</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">control_points</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">M</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="n">k</span><span class="p">),</span><span class="w"></span>
</pre></div>
</div>
</details><p>constraining the kth control point of the <a href="#id1"><span class="problematic" id="id2">`</span></a>n`th derivative to be in
[ub, lb], could be done with:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">M</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curve</span><span class="p">.</span><span class="n">AsLinearInControlPoints</span><span class="p">(</span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">curve</span><span class="p">.</span><span class="n">rows</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">auto</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">solvers</span><span class="o">::</span><span class="n">LinearConstraint</span><span class="o">&gt;</span><span class="p">(</span><span class="w"></span>
<span class="n">M</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="n">k</span><span class="p">).</span><span class="n">transpose</span><span class="p">(),</span><span class="w"> </span><span class="n">Vector1d</span><span class="p">(</span><span class="n">lb</span><span class="p">(</span><span class="n">i</span><span class="p">)),</span><span class="w"> </span><span class="n">Vector1d</span><span class="p">(</span><span class="n">ub</span><span class="p">(</span><span class="n">i</span><span class="p">)));</span><span class="w"></span>
<span class="n">prog</span><span class="p">.</span><span class="n">AddConstraint</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">curve</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">transpose</span><span class="p">());</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</details><p>Iterating over the rows of the control points is the natural sparsity
pattern here (since <code class="docutils literal notranslate"><span class="pre">M</span></code> is the same for all rows). For instance, we
also have</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">derivative</span><span class="p">.</span><span class="n">control_points</span><span class="p">().</span><span class="n">row</span><span class="p">(</span><span class="n">k</span><span class="p">).</span><span class="n">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">M</span><span class="p">.</span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">control_points</span><span class="p">().</span><span class="n">row</span><span class="p">(</span><span class="n">k</span><span class="p">).</span><span class="n">T</span><span class="p">,</span><span class="w"></span>
</pre></div>
</div>
</details><p>or</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">vec</span><span class="p">(</span><span class="n">derivative</span><span class="p">.</span><span class="n">control_points</span><span class="p">().</span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockMT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">vec</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">control_points</span><span class="p">().</span><span class="n">T</span><span class="p">),</span><span class="w"></span>
<span class="n">blockMT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="n">M</span><span class="p">.</span><span class="n">T</span><span class="p">,</span><span class="w">   </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">....</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">]</span><span class="w"></span>
<span class="p">[</span><span class="w">   </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="p">.</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">]</span><span class="w"></span>
<span class="p">[</span><span class="w">      </span><span class="p">...</span><span class="w">         </span><span class="p">]</span><span class="w"></span>
<span class="p">[</span><span class="w">  </span><span class="p">...</span><span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="p">.</span><span class="n">T</span><span class="w"> </span><span class="p">].</span><span class="w"></span>
</pre></div>
</div>
</details><dl class="simple">
<dt>Precondition:</dt><dd><p>derivative_order &gt;= 0.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BezierCurve.BernsteinBasis">
<span class="sig-name descname"><span class="pre">BernsteinBasis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BezierCurve" title="pydrake.trajectories.BezierCurve"><span class="pre">pydrake.trajectories.BezierCurve</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.trajectories.BezierCurve.BernsteinBasis" title="Permalink to this definition"></a></dt>
<dd><p>Returns the value of the ith basis function of <code class="docutils literal notranslate"><span class="pre">order</span></code> (1 for
linear, 2 for quadratic, etc) evaluated at <code class="docutils literal notranslate"><span class="pre">time</span></code>. The default value
for the optional argument <code class="docutils literal notranslate"><span class="pre">order</span></code> is the <code class="docutils literal notranslate"><span class="pre">order()</span></code> of <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BezierCurve.control_points">
<span class="sig-name descname"><span class="pre">control_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BezierCurve" title="pydrake.trajectories.BezierCurve"><span class="pre">pydrake.trajectories.BezierCurve</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BezierCurve.control_points" title="Permalink to this definition"></a></dt>
<dd><p>Returns a const reference to the control points which define the
curve.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BezierCurve.ElevateOrder">
<span class="sig-name descname"><span class="pre">ElevateOrder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BezierCurve" title="pydrake.trajectories.BezierCurve"><span class="pre">pydrake.trajectories.BezierCurve</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.BezierCurve.ElevateOrder" title="Permalink to this definition"></a></dt>
<dd><p>Increases the order of the curve by 1. A Bézier curve of order n can
be converted into a Bézier curve of order n + 1 with the same shape.
The control points of <code class="docutils literal notranslate"><span class="pre">this</span></code> are modified to obtain the equivalent
curve.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BezierCurve.GetExpression">
<span class="sig-name descname"><span class="pre">GetExpression</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BezierCurve" title="pydrake.trajectories.BezierCurve"><span class="pre">pydrake.trajectories.BezierCurve</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Variable" title="pydrake.symbolic.Variable"><span class="pre">pydrake.symbolic.Variable</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">Variable('t',</span> <span class="pre">Continuous)</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BezierCurve.GetExpression" title="Permalink to this definition"></a></dt>
<dd><p>Extracts the expanded underlying polynomial expression of this curve
in terms of variable <code class="docutils literal notranslate"><span class="pre">time</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BezierCurve.order">
<span class="sig-name descname"><span class="pre">order</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BezierCurve" title="pydrake.trajectories.BezierCurve"><span class="pre">pydrake.trajectories.BezierCurve</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.BezierCurve.order" title="Permalink to this definition"></a></dt>
<dd><p>Returns the order of the curve (1 for linear, 2 for quadratic, etc.).</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.trajectories.BezierCurve_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">BezierCurve_</span></span><a class="headerlink" href="#pydrake.trajectories.BezierCurve_" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">BezierCurve_[float]</span></code>, <a class="reference internal" href="#pydrake.trajectories.BezierCurve_-AutoDiffXd" title="pydrake.trajectories.BezierCurve_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">BezierCurve_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.trajectories.BezierCurve_-Expression" title="pydrake.trajectories.BezierCurve_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">BezierCurve_[Expression]</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.BezierCurve_-AutoDiffXd">
<span id="pydrake.trajectories.BezierCurve_[AutoDiffXd]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">BezierCurve_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.trajectories.BezierCurve_-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.Trajectory_-AutoDiffXd" title="pydrake.trajectories.Trajectory_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[AutoDiffXd]</span></code></a></p>
<p>A Bézier curve is defined by a set of control points p₀ through pₙ,
where n is called the order of the curve (n = 1 for linear, 2 for
quadratic, 3 for cubic, etc.). The first and last control points are
always the endpoints of the curve; however, the intermediate control
points (if any) generally do not lie on the curve, but the curve is
guaranteed to stay within the convex hull of the control points.</p>
<p>See also BsplineTrajectory. A B-spline can be thought of as a
composition of overlapping Bézier curves (where each evaluation only
depends on a local subset of the control points). In contrast,
evaluating a Bézier curve will use all of the control points.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BezierCurve_-AutoDiffXd-.__init__">
<span id="pydrake.trajectories.BezierCurve_[AutoDiffXd].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.BezierCurve_-AutoDiffXd-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.BezierCurve_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Default initializer. Constructs an empty Bézier curve over the
interval t ∈ [0, 1].</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.trajectories.BezierCurve_[AutoDiffXd], start_time: float, end_time: float, control_points: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; None</p></li>
</ol>
<p>Constructs a Bézier curve over the interval t ∈ [<cite>start_time</cite>,
<code class="docutils literal notranslate"><span class="pre">end_time`]</span> <span class="pre">with</span> <span class="pre">control</span> <span class="pre">points</span> <span class="pre">defined</span> <span class="pre">in</span> <span class="pre">the</span> <span class="pre">columns</span> <span class="pre">of</span>
<span class="pre">`control_points</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>end_time &gt;= start_time.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BezierCurve_-AutoDiffXd-.AsLinearInControlPoints">
<span id="pydrake.trajectories.BezierCurve_[AutoDiffXd].AsLinearInControlPoints"></span><span class="sig-name descname"><span class="pre">AsLinearInControlPoints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BezierCurve_" title="pydrake.trajectories.BezierCurve_"><span class="pre">pydrake.trajectories.BezierCurve_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derivative_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">scipy.sparse.csc_matrix</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BezierCurve_-AutoDiffXd-.AsLinearInControlPoints" title="Permalink to this definition"></a></dt>
<dd><p>Supports writing optimizations using the control points as decision
variables. This method returns the matrix, <code class="docutils literal notranslate"><span class="pre">M</span></code>, defining the control
points of the <code class="docutils literal notranslate"><span class="pre">order</span></code> derivative in the form:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">derivative</span><span class="p">.</span><span class="n">control_points</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">control_points</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">M</span><span class="w"></span>
</pre></div>
</div>
</details><p>For instance, since we have</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">derivative</span><span class="p">.</span><span class="n">control_points</span><span class="p">().</span><span class="n">col</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">control_points</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">M</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="n">k</span><span class="p">),</span><span class="w"></span>
</pre></div>
</div>
</details><p>constraining the kth control point of the <a href="#id3"><span class="problematic" id="id4">`</span></a>n`th derivative to be in
[ub, lb], could be done with:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">M</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curve</span><span class="p">.</span><span class="n">AsLinearInControlPoints</span><span class="p">(</span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">curve</span><span class="p">.</span><span class="n">rows</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">auto</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">solvers</span><span class="o">::</span><span class="n">LinearConstraint</span><span class="o">&gt;</span><span class="p">(</span><span class="w"></span>
<span class="n">M</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="n">k</span><span class="p">).</span><span class="n">transpose</span><span class="p">(),</span><span class="w"> </span><span class="n">Vector1d</span><span class="p">(</span><span class="n">lb</span><span class="p">(</span><span class="n">i</span><span class="p">)),</span><span class="w"> </span><span class="n">Vector1d</span><span class="p">(</span><span class="n">ub</span><span class="p">(</span><span class="n">i</span><span class="p">)));</span><span class="w"></span>
<span class="n">prog</span><span class="p">.</span><span class="n">AddConstraint</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">curve</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">transpose</span><span class="p">());</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</details><p>Iterating over the rows of the control points is the natural sparsity
pattern here (since <code class="docutils literal notranslate"><span class="pre">M</span></code> is the same for all rows). For instance, we
also have</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">derivative</span><span class="p">.</span><span class="n">control_points</span><span class="p">().</span><span class="n">row</span><span class="p">(</span><span class="n">k</span><span class="p">).</span><span class="n">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">M</span><span class="p">.</span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">control_points</span><span class="p">().</span><span class="n">row</span><span class="p">(</span><span class="n">k</span><span class="p">).</span><span class="n">T</span><span class="p">,</span><span class="w"></span>
</pre></div>
</div>
</details><p>or</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">vec</span><span class="p">(</span><span class="n">derivative</span><span class="p">.</span><span class="n">control_points</span><span class="p">().</span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockMT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">vec</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">control_points</span><span class="p">().</span><span class="n">T</span><span class="p">),</span><span class="w"></span>
<span class="n">blockMT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="n">M</span><span class="p">.</span><span class="n">T</span><span class="p">,</span><span class="w">   </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">....</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">]</span><span class="w"></span>
<span class="p">[</span><span class="w">   </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="p">.</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">]</span><span class="w"></span>
<span class="p">[</span><span class="w">      </span><span class="p">...</span><span class="w">         </span><span class="p">]</span><span class="w"></span>
<span class="p">[</span><span class="w">  </span><span class="p">...</span><span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="p">.</span><span class="n">T</span><span class="w"> </span><span class="p">].</span><span class="w"></span>
</pre></div>
</div>
</details><dl class="simple">
<dt>Precondition:</dt><dd><p>derivative_order &gt;= 0.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BezierCurve_-AutoDiffXd-.BernsteinBasis">
<span id="pydrake.trajectories.BezierCurve_[AutoDiffXd].BernsteinBasis"></span><span class="sig-name descname"><span class="pre">BernsteinBasis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BezierCurve_" title="pydrake.trajectories.BezierCurve_"><span class="pre">pydrake.trajectories.BezierCurve_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></span><a class="headerlink" href="#pydrake.trajectories.BezierCurve_-AutoDiffXd-.BernsteinBasis" title="Permalink to this definition"></a></dt>
<dd><p>Returns the value of the ith basis function of <code class="docutils literal notranslate"><span class="pre">order</span></code> (1 for
linear, 2 for quadratic, etc) evaluated at <code class="docutils literal notranslate"><span class="pre">time</span></code>. The default value
for the optional argument <code class="docutils literal notranslate"><span class="pre">order</span></code> is the <code class="docutils literal notranslate"><span class="pre">order()</span></code> of <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BezierCurve_-AutoDiffXd-.control_points">
<span id="pydrake.trajectories.BezierCurve_[AutoDiffXd].control_points"></span><span class="sig-name descname"><span class="pre">control_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BezierCurve_" title="pydrake.trajectories.BezierCurve_"><span class="pre">pydrake.trajectories.BezierCurve_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BezierCurve_-AutoDiffXd-.control_points" title="Permalink to this definition"></a></dt>
<dd><p>Returns a const reference to the control points which define the
curve.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BezierCurve_-AutoDiffXd-.ElevateOrder">
<span id="pydrake.trajectories.BezierCurve_[AutoDiffXd].ElevateOrder"></span><span class="sig-name descname"><span class="pre">ElevateOrder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BezierCurve_" title="pydrake.trajectories.BezierCurve_"><span class="pre">pydrake.trajectories.BezierCurve_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.BezierCurve_-AutoDiffXd-.ElevateOrder" title="Permalink to this definition"></a></dt>
<dd><p>Increases the order of the curve by 1. A Bézier curve of order n can
be converted into a Bézier curve of order n + 1 with the same shape.
The control points of <code class="docutils literal notranslate"><span class="pre">this</span></code> are modified to obtain the equivalent
curve.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BezierCurve_-AutoDiffXd-.GetExpression">
<span id="pydrake.trajectories.BezierCurve_[AutoDiffXd].GetExpression"></span><span class="sig-name descname"><span class="pre">GetExpression</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BezierCurve_" title="pydrake.trajectories.BezierCurve_"><span class="pre">pydrake.trajectories.BezierCurve_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Variable" title="pydrake.symbolic.Variable"><span class="pre">pydrake.symbolic.Variable</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">Variable('t',</span> <span class="pre">Continuous)</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BezierCurve_-AutoDiffXd-.GetExpression" title="Permalink to this definition"></a></dt>
<dd><p>Extracts the expanded underlying polynomial expression of this curve
in terms of variable <code class="docutils literal notranslate"><span class="pre">time</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BezierCurve_-AutoDiffXd-.order">
<span id="pydrake.trajectories.BezierCurve_[AutoDiffXd].order"></span><span class="sig-name descname"><span class="pre">order</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BezierCurve_" title="pydrake.trajectories.BezierCurve_"><span class="pre">pydrake.trajectories.BezierCurve_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.BezierCurve_-AutoDiffXd-.order" title="Permalink to this definition"></a></dt>
<dd><p>Returns the order of the curve (1 for linear, 2 for quadratic, etc.).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.BezierCurve_-Expression">
<span id="pydrake.trajectories.BezierCurve_[Expression]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">BezierCurve_[Expression]</span></span><a class="headerlink" href="#pydrake.trajectories.BezierCurve_-Expression" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.Trajectory_-Expression" title="pydrake.trajectories.Trajectory_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[Expression]</span></code></a></p>
<p>A Bézier curve is defined by a set of control points p₀ through pₙ,
where n is called the order of the curve (n = 1 for linear, 2 for
quadratic, 3 for cubic, etc.). The first and last control points are
always the endpoints of the curve; however, the intermediate control
points (if any) generally do not lie on the curve, but the curve is
guaranteed to stay within the convex hull of the control points.</p>
<p>See also BsplineTrajectory. A B-spline can be thought of as a
composition of overlapping Bézier curves (where each evaluation only
depends on a local subset of the control points). In contrast,
evaluating a Bézier curve will use all of the control points.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BezierCurve_-Expression-.__init__">
<span id="pydrake.trajectories.BezierCurve_[Expression].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.BezierCurve_-Expression-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.BezierCurve_[Expression]) -&gt; None</p></li>
</ol>
<p>Default initializer. Constructs an empty Bézier curve over the
interval t ∈ [0, 1].</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.trajectories.BezierCurve_[Expression], start_time: float, end_time: float, control_points: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; None</p></li>
</ol>
<p>Constructs a Bézier curve over the interval t ∈ [<cite>start_time</cite>,
<code class="docutils literal notranslate"><span class="pre">end_time`]</span> <span class="pre">with</span> <span class="pre">control</span> <span class="pre">points</span> <span class="pre">defined</span> <span class="pre">in</span> <span class="pre">the</span> <span class="pre">columns</span> <span class="pre">of</span>
<span class="pre">`control_points</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>end_time &gt;= start_time.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BezierCurve_-Expression-.AsLinearInControlPoints">
<span id="pydrake.trajectories.BezierCurve_[Expression].AsLinearInControlPoints"></span><span class="sig-name descname"><span class="pre">AsLinearInControlPoints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BezierCurve_" title="pydrake.trajectories.BezierCurve_"><span class="pre">pydrake.trajectories.BezierCurve_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derivative_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">scipy.sparse.csc_matrix</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BezierCurve_-Expression-.AsLinearInControlPoints" title="Permalink to this definition"></a></dt>
<dd><p>Supports writing optimizations using the control points as decision
variables. This method returns the matrix, <code class="docutils literal notranslate"><span class="pre">M</span></code>, defining the control
points of the <code class="docutils literal notranslate"><span class="pre">order</span></code> derivative in the form:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">derivative</span><span class="p">.</span><span class="n">control_points</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">control_points</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">M</span><span class="w"></span>
</pre></div>
</div>
</details><p>For instance, since we have</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">derivative</span><span class="p">.</span><span class="n">control_points</span><span class="p">().</span><span class="n">col</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">control_points</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">M</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="n">k</span><span class="p">),</span><span class="w"></span>
</pre></div>
</div>
</details><p>constraining the kth control point of the <a href="#id5"><span class="problematic" id="id6">`</span></a>n`th derivative to be in
[ub, lb], could be done with:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">M</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curve</span><span class="p">.</span><span class="n">AsLinearInControlPoints</span><span class="p">(</span><span class="n">n</span><span class="p">);</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">curve</span><span class="p">.</span><span class="n">rows</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">auto</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">solvers</span><span class="o">::</span><span class="n">LinearConstraint</span><span class="o">&gt;</span><span class="p">(</span><span class="w"></span>
<span class="n">M</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="n">k</span><span class="p">).</span><span class="n">transpose</span><span class="p">(),</span><span class="w"> </span><span class="n">Vector1d</span><span class="p">(</span><span class="n">lb</span><span class="p">(</span><span class="n">i</span><span class="p">)),</span><span class="w"> </span><span class="n">Vector1d</span><span class="p">(</span><span class="n">ub</span><span class="p">(</span><span class="n">i</span><span class="p">)));</span><span class="w"></span>
<span class="n">prog</span><span class="p">.</span><span class="n">AddConstraint</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="n">curve</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">transpose</span><span class="p">());</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</details><p>Iterating over the rows of the control points is the natural sparsity
pattern here (since <code class="docutils literal notranslate"><span class="pre">M</span></code> is the same for all rows). For instance, we
also have</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">derivative</span><span class="p">.</span><span class="n">control_points</span><span class="p">().</span><span class="n">row</span><span class="p">(</span><span class="n">k</span><span class="p">).</span><span class="n">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">M</span><span class="p">.</span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">control_points</span><span class="p">().</span><span class="n">row</span><span class="p">(</span><span class="n">k</span><span class="p">).</span><span class="n">T</span><span class="p">,</span><span class="w"></span>
</pre></div>
</div>
</details><p>or</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">vec</span><span class="p">(</span><span class="n">derivative</span><span class="p">.</span><span class="n">control_points</span><span class="p">().</span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockMT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">vec</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">control_points</span><span class="p">().</span><span class="n">T</span><span class="p">),</span><span class="w"></span>
<span class="n">blockMT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="n">M</span><span class="p">.</span><span class="n">T</span><span class="p">,</span><span class="w">   </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">....</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">]</span><span class="w"></span>
<span class="p">[</span><span class="w">   </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="p">.</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">]</span><span class="w"></span>
<span class="p">[</span><span class="w">      </span><span class="p">...</span><span class="w">         </span><span class="p">]</span><span class="w"></span>
<span class="p">[</span><span class="w">  </span><span class="p">...</span><span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="p">.</span><span class="n">T</span><span class="w"> </span><span class="p">].</span><span class="w"></span>
</pre></div>
</div>
</details><dl class="simple">
<dt>Precondition:</dt><dd><p>derivative_order &gt;= 0.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BezierCurve_-Expression-.BernsteinBasis">
<span id="pydrake.trajectories.BezierCurve_[Expression].BernsteinBasis"></span><span class="sig-name descname"><span class="pre">BernsteinBasis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BezierCurve_" title="pydrake.trajectories.BezierCurve_"><span class="pre">pydrake.trajectories.BezierCurve_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></span><a class="headerlink" href="#pydrake.trajectories.BezierCurve_-Expression-.BernsteinBasis" title="Permalink to this definition"></a></dt>
<dd><p>Returns the value of the ith basis function of <code class="docutils literal notranslate"><span class="pre">order</span></code> (1 for
linear, 2 for quadratic, etc) evaluated at <code class="docutils literal notranslate"><span class="pre">time</span></code>. The default value
for the optional argument <code class="docutils literal notranslate"><span class="pre">order</span></code> is the <code class="docutils literal notranslate"><span class="pre">order()</span></code> of <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BezierCurve_-Expression-.control_points">
<span id="pydrake.trajectories.BezierCurve_[Expression].control_points"></span><span class="sig-name descname"><span class="pre">control_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BezierCurve_" title="pydrake.trajectories.BezierCurve_"><span class="pre">pydrake.trajectories.BezierCurve_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BezierCurve_-Expression-.control_points" title="Permalink to this definition"></a></dt>
<dd><p>Returns a const reference to the control points which define the
curve.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BezierCurve_-Expression-.ElevateOrder">
<span id="pydrake.trajectories.BezierCurve_[Expression].ElevateOrder"></span><span class="sig-name descname"><span class="pre">ElevateOrder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BezierCurve_" title="pydrake.trajectories.BezierCurve_"><span class="pre">pydrake.trajectories.BezierCurve_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.BezierCurve_-Expression-.ElevateOrder" title="Permalink to this definition"></a></dt>
<dd><p>Increases the order of the curve by 1. A Bézier curve of order n can
be converted into a Bézier curve of order n + 1 with the same shape.
The control points of <code class="docutils literal notranslate"><span class="pre">this</span></code> are modified to obtain the equivalent
curve.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BezierCurve_-Expression-.GetExpression">
<span id="pydrake.trajectories.BezierCurve_[Expression].GetExpression"></span><span class="sig-name descname"><span class="pre">GetExpression</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BezierCurve_" title="pydrake.trajectories.BezierCurve_"><span class="pre">pydrake.trajectories.BezierCurve_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Variable" title="pydrake.symbolic.Variable"><span class="pre">pydrake.symbolic.Variable</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">Variable('t',</span> <span class="pre">Continuous)</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BezierCurve_-Expression-.GetExpression" title="Permalink to this definition"></a></dt>
<dd><p>Extracts the expanded underlying polynomial expression of this curve
in terms of variable <code class="docutils literal notranslate"><span class="pre">time</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BezierCurve_-Expression-.order">
<span id="pydrake.trajectories.BezierCurve_[Expression].order"></span><span class="sig-name descname"><span class="pre">order</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BezierCurve_" title="pydrake.trajectories.BezierCurve_"><span class="pre">pydrake.trajectories.BezierCurve_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.BezierCurve_-Expression-.order" title="Permalink to this definition"></a></dt>
<dd><p>Returns the order of the curve (1 for linear, 2 for quadratic, etc.).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">BsplineTrajectory</span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.Trajectory" title="pydrake.trajectories.Trajectory"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory</span></code></a></p>
<p>Represents a B-spline curve using a given <code class="docutils literal notranslate"><span class="pre">basis</span></code> with ordered
<code class="docutils literal notranslate"><span class="pre">control_points</span></code> such that each control point is a matrix in ℝʳᵒʷˢ ˣ
ᶜᵒˡˢ.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>math::BsplineBasis</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><code class="xref py py-class docutils literal notranslate"><span class="pre">BsplineTrajectory_</span></code></a>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.BsplineTrajectory) -&gt; None</p></li>
<li><p>__init__(self: pydrake.trajectories.BsplineTrajectory, basis: pydrake.math.BsplineBasis, control_points: list[list[float]]) -&gt; None</p></li>
</ol>
<p>Constructs a B-spline trajectory with the given <code class="docutils literal notranslate"><span class="pre">basis</span></code> and
<code class="docutils literal notranslate"><span class="pre">control_points</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>control_points.size() == basis.num_basis_functions()</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.trajectories.BsplineTrajectory, basis: pydrake.math.BsplineBasis, control_points: list[numpy.ndarray[numpy.float64[m, n]]]) -&gt; None</p></li>
</ol>
<p>Constructs a B-spline trajectory with the given <code class="docutils literal notranslate"><span class="pre">basis</span></code> and
<code class="docutils literal notranslate"><span class="pre">control_points</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>control_points.size() == basis.num_basis_functions()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory.basis">
<span class="sig-name descname"><span class="pre">basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory" title="pydrake.trajectories.BsplineTrajectory"><span class="pre">pydrake.trajectories.BsplineTrajectory</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.math.html#pydrake.math.BsplineBasis" title="pydrake.math.BsplineBasis"><span class="pre">pydrake.math.BsplineBasis</span></a></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory.basis" title="Permalink to this definition"></a></dt>
<dd><p>Returns the basis of this curve.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory.control_points">
<span class="sig-name descname"><span class="pre">control_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory" title="pydrake.trajectories.BsplineTrajectory"><span class="pre">pydrake.trajectories.BsplineTrajectory</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory.control_points" title="Permalink to this definition"></a></dt>
<dd><p>Returns the control points of this curve.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory.CopyBlock">
<span class="sig-name descname"><span class="pre">CopyBlock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory" title="pydrake.trajectories.BsplineTrajectory"><span class="pre">pydrake.trajectories.BsplineTrajectory</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_row</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_rows</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_cols</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory" title="pydrake.trajectories.BsplineTrajectory"><span class="pre">pydrake.trajectories.BsplineTrajectory</span></a></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory.CopyBlock" title="Permalink to this definition"></a></dt>
<dd><p>Returns a new BsplineTrajectory that uses the same basis as <code class="docutils literal notranslate"><span class="pre">this</span></code>,
and whose control points are the result of calling
<code class="docutils literal notranslate"><span class="pre">point.block(start_row,</span> <span class="pre">start_col,</span> <span class="pre">block_rows,</span> <span class="pre">block_cols)</span></code> on each
<code class="docutils literal notranslate"><span class="pre">point</span></code> in <code class="docutils literal notranslate"><span class="pre">this-&gt;control_points()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory.CopyHead">
<span class="sig-name descname"><span class="pre">CopyHead</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory" title="pydrake.trajectories.BsplineTrajectory"><span class="pre">pydrake.trajectories.BsplineTrajectory</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory" title="pydrake.trajectories.BsplineTrajectory"><span class="pre">pydrake.trajectories.BsplineTrajectory</span></a></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory.CopyHead" title="Permalink to this definition"></a></dt>
<dd><p>Returns a new BsplineTrajectory that uses the same basis as <code class="docutils literal notranslate"><span class="pre">this</span></code>,
and whose control points are the result of calling <code class="docutils literal notranslate"><span class="pre">point.head(n)</span></code>
on each <code class="docutils literal notranslate"><span class="pre">point</span></code> in <code class="docutils literal notranslate"><span class="pre">this-&gt;control_points()</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>this-&gt;cols() == 1</p>
</dd>
<dt>Precondition:</dt><dd><p>control_points()[0].head(n) must be a valid operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory.FinalValue">
<span class="sig-name descname"><span class="pre">FinalValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory" title="pydrake.trajectories.BsplineTrajectory"><span class="pre">pydrake.trajectories.BsplineTrajectory</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory.FinalValue" title="Permalink to this definition"></a></dt>
<dd><p>Returns this-&gt;value(this-&gt;end_time())</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory.InitialValue">
<span class="sig-name descname"><span class="pre">InitialValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory" title="pydrake.trajectories.BsplineTrajectory"><span class="pre">pydrake.trajectories.BsplineTrajectory</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory.InitialValue" title="Permalink to this definition"></a></dt>
<dd><p>Returns this-&gt;value(this-&gt;start_time())</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory.InsertKnots">
<span class="sig-name descname"><span class="pre">InsertKnots</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory" title="pydrake.trajectories.BsplineTrajectory"><span class="pre">pydrake.trajectories.BsplineTrajectory</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">additional_knots</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory.InsertKnots" title="Permalink to this definition"></a></dt>
<dd><p>Adds new knots at the specified <code class="docutils literal notranslate"><span class="pre">additional_knots</span></code> without changing
the behavior of the trajectory. The basis and control points of the
trajectory are adjusted such that it produces the same value for any
valid time before and after this method is called. The resulting
trajectory is guaranteed to have the same level of continuity as the
original, even if knot values are duplicated. Note that
<code class="docutils literal notranslate"><span class="pre">additional_knots</span></code> need not be sorted.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>start_time() &lt;= t &lt;= end_time() for all t in <code class="docutils literal notranslate"><span class="pre">additional_knots</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory.num_control_points">
<span class="sig-name descname"><span class="pre">num_control_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory" title="pydrake.trajectories.BsplineTrajectory"><span class="pre">pydrake.trajectories.BsplineTrajectory</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory.num_control_points" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of control points in this curve.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">BsplineTrajectory_</span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">BsplineTrajectory_[float]</span></code>, <a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_-AutoDiffXd" title="pydrake.trajectories.BsplineTrajectory_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">BsplineTrajectory_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_-Expression" title="pydrake.trajectories.BsplineTrajectory_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">BsplineTrajectory_[Expression]</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-AutoDiffXd">
<span id="pydrake.trajectories.BsplineTrajectory_[AutoDiffXd]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">BsplineTrajectory_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.Trajectory_-AutoDiffXd" title="pydrake.trajectories.Trajectory_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[AutoDiffXd]</span></code></a></p>
<p>Represents a B-spline curve using a given <code class="docutils literal notranslate"><span class="pre">basis</span></code> with ordered
<code class="docutils literal notranslate"><span class="pre">control_points</span></code> such that each control point is a matrix in ℝʳᵒʷˢ ˣ
ᶜᵒˡˢ.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>math::BsplineBasis</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-AutoDiffXd-.__init__">
<span id="pydrake.trajectories.BsplineTrajectory_[AutoDiffXd].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-AutoDiffXd-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.BsplineTrajectory_[AutoDiffXd]) -&gt; None</p></li>
<li><p>__init__(self: pydrake.trajectories.BsplineTrajectory_[AutoDiffXd], basis: pydrake.math.BsplineBasis_[AutoDiffXd], control_points: list[list[pydrake.autodiffutils.AutoDiffXd]]) -&gt; None</p></li>
</ol>
<p>Constructs a B-spline trajectory with the given <code class="docutils literal notranslate"><span class="pre">basis</span></code> and
<code class="docutils literal notranslate"><span class="pre">control_points</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>control_points.size() == basis.num_basis_functions()</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.trajectories.BsplineTrajectory_[AutoDiffXd], basis: pydrake.math.BsplineBasis_[AutoDiffXd], control_points: list[numpy.ndarray[object[m, n]]]) -&gt; None</p></li>
</ol>
<p>Constructs a B-spline trajectory with the given <code class="docutils literal notranslate"><span class="pre">basis</span></code> and
<code class="docutils literal notranslate"><span class="pre">control_points</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>control_points.size() == basis.num_basis_functions()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-AutoDiffXd-.basis">
<span id="pydrake.trajectories.BsplineTrajectory_[AutoDiffXd].basis"></span><span class="sig-name descname"><span class="pre">basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.math.html#pydrake.math.BsplineBasis_" title="pydrake.math.BsplineBasis_"><span class="pre">pydrake.math.BsplineBasis_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-AutoDiffXd-.basis" title="Permalink to this definition"></a></dt>
<dd><p>Returns the basis of this curve.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-AutoDiffXd-.control_points">
<span id="pydrake.trajectories.BsplineTrajectory_[AutoDiffXd].control_points"></span><span class="sig-name descname"><span class="pre">control_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-AutoDiffXd-.control_points" title="Permalink to this definition"></a></dt>
<dd><p>Returns the control points of this curve.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-AutoDiffXd-.CopyBlock">
<span id="pydrake.trajectories.BsplineTrajectory_[AutoDiffXd].CopyBlock"></span><span class="sig-name descname"><span class="pre">CopyBlock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_row</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_rows</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_cols</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-AutoDiffXd-.CopyBlock" title="Permalink to this definition"></a></dt>
<dd><p>Returns a new BsplineTrajectory that uses the same basis as <code class="docutils literal notranslate"><span class="pre">this</span></code>,
and whose control points are the result of calling
<code class="docutils literal notranslate"><span class="pre">point.block(start_row,</span> <span class="pre">start_col,</span> <span class="pre">block_rows,</span> <span class="pre">block_cols)</span></code> on each
<code class="docutils literal notranslate"><span class="pre">point</span></code> in <code class="docutils literal notranslate"><span class="pre">this-&gt;control_points()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-AutoDiffXd-.CopyHead">
<span id="pydrake.trajectories.BsplineTrajectory_[AutoDiffXd].CopyHead"></span><span class="sig-name descname"><span class="pre">CopyHead</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-AutoDiffXd-.CopyHead" title="Permalink to this definition"></a></dt>
<dd><p>Returns a new BsplineTrajectory that uses the same basis as <code class="docutils literal notranslate"><span class="pre">this</span></code>,
and whose control points are the result of calling <code class="docutils literal notranslate"><span class="pre">point.head(n)</span></code>
on each <code class="docutils literal notranslate"><span class="pre">point</span></code> in <code class="docutils literal notranslate"><span class="pre">this-&gt;control_points()</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>this-&gt;cols() == 1</p>
</dd>
<dt>Precondition:</dt><dd><p>control_points()[0].head(n) must be a valid operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-AutoDiffXd-.FinalValue">
<span id="pydrake.trajectories.BsplineTrajectory_[AutoDiffXd].FinalValue"></span><span class="sig-name descname"><span class="pre">FinalValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-AutoDiffXd-.FinalValue" title="Permalink to this definition"></a></dt>
<dd><p>Returns this-&gt;value(this-&gt;end_time())</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-AutoDiffXd-.InitialValue">
<span id="pydrake.trajectories.BsplineTrajectory_[AutoDiffXd].InitialValue"></span><span class="sig-name descname"><span class="pre">InitialValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-AutoDiffXd-.InitialValue" title="Permalink to this definition"></a></dt>
<dd><p>Returns this-&gt;value(this-&gt;start_time())</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-AutoDiffXd-.InsertKnots">
<span id="pydrake.trajectories.BsplineTrajectory_[AutoDiffXd].InsertKnots"></span><span class="sig-name descname"><span class="pre">InsertKnots</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">additional_knots</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-AutoDiffXd-.InsertKnots" title="Permalink to this definition"></a></dt>
<dd><p>Adds new knots at the specified <code class="docutils literal notranslate"><span class="pre">additional_knots</span></code> without changing
the behavior of the trajectory. The basis and control points of the
trajectory are adjusted such that it produces the same value for any
valid time before and after this method is called. The resulting
trajectory is guaranteed to have the same level of continuity as the
original, even if knot values are duplicated. Note that
<code class="docutils literal notranslate"><span class="pre">additional_knots</span></code> need not be sorted.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>start_time() &lt;= t &lt;= end_time() for all t in <code class="docutils literal notranslate"><span class="pre">additional_knots</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-AutoDiffXd-.num_control_points">
<span id="pydrake.trajectories.BsplineTrajectory_[AutoDiffXd].num_control_points"></span><span class="sig-name descname"><span class="pre">num_control_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-AutoDiffXd-.num_control_points" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of control points in this curve.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-Expression">
<span id="pydrake.trajectories.BsplineTrajectory_[Expression]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">BsplineTrajectory_[Expression]</span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-Expression" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.Trajectory_-Expression" title="pydrake.trajectories.Trajectory_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[Expression]</span></code></a></p>
<p>Represents a B-spline curve using a given <code class="docutils literal notranslate"><span class="pre">basis</span></code> with ordered
<code class="docutils literal notranslate"><span class="pre">control_points</span></code> such that each control point is a matrix in ℝʳᵒʷˢ ˣ
ᶜᵒˡˢ.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>math::BsplineBasis</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-Expression-.__init__">
<span id="pydrake.trajectories.BsplineTrajectory_[Expression].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-Expression-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.BsplineTrajectory_[Expression]) -&gt; None</p></li>
<li><p>__init__(self: pydrake.trajectories.BsplineTrajectory_[Expression], basis: pydrake.math.BsplineBasis_[Expression], control_points: list[list[pydrake.symbolic.Expression]]) -&gt; None</p></li>
</ol>
<p>Constructs a B-spline trajectory with the given <code class="docutils literal notranslate"><span class="pre">basis</span></code> and
<code class="docutils literal notranslate"><span class="pre">control_points</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>control_points.size() == basis.num_basis_functions()</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.trajectories.BsplineTrajectory_[Expression], basis: pydrake.math.BsplineBasis_[Expression], control_points: list[numpy.ndarray[object[m, n]]]) -&gt; None</p></li>
</ol>
<p>Constructs a B-spline trajectory with the given <code class="docutils literal notranslate"><span class="pre">basis</span></code> and
<code class="docutils literal notranslate"><span class="pre">control_points</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>control_points.size() == basis.num_basis_functions()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-Expression-.basis">
<span id="pydrake.trajectories.BsplineTrajectory_[Expression].basis"></span><span class="sig-name descname"><span class="pre">basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.math.html#pydrake.math.BsplineBasis_" title="pydrake.math.BsplineBasis_"><span class="pre">pydrake.math.BsplineBasis_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-Expression-.basis" title="Permalink to this definition"></a></dt>
<dd><p>Returns the basis of this curve.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-Expression-.control_points">
<span id="pydrake.trajectories.BsplineTrajectory_[Expression].control_points"></span><span class="sig-name descname"><span class="pre">control_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-Expression-.control_points" title="Permalink to this definition"></a></dt>
<dd><p>Returns the control points of this curve.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-Expression-.CopyBlock">
<span id="pydrake.trajectories.BsplineTrajectory_[Expression].CopyBlock"></span><span class="sig-name descname"><span class="pre">CopyBlock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_row</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_rows</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_cols</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-Expression-.CopyBlock" title="Permalink to this definition"></a></dt>
<dd><p>Returns a new BsplineTrajectory that uses the same basis as <code class="docutils literal notranslate"><span class="pre">this</span></code>,
and whose control points are the result of calling
<code class="docutils literal notranslate"><span class="pre">point.block(start_row,</span> <span class="pre">start_col,</span> <span class="pre">block_rows,</span> <span class="pre">block_cols)</span></code> on each
<code class="docutils literal notranslate"><span class="pre">point</span></code> in <code class="docutils literal notranslate"><span class="pre">this-&gt;control_points()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-Expression-.CopyHead">
<span id="pydrake.trajectories.BsplineTrajectory_[Expression].CopyHead"></span><span class="sig-name descname"><span class="pre">CopyHead</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-Expression-.CopyHead" title="Permalink to this definition"></a></dt>
<dd><p>Returns a new BsplineTrajectory that uses the same basis as <code class="docutils literal notranslate"><span class="pre">this</span></code>,
and whose control points are the result of calling <code class="docutils literal notranslate"><span class="pre">point.head(n)</span></code>
on each <code class="docutils literal notranslate"><span class="pre">point</span></code> in <code class="docutils literal notranslate"><span class="pre">this-&gt;control_points()</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>this-&gt;cols() == 1</p>
</dd>
<dt>Precondition:</dt><dd><p>control_points()[0].head(n) must be a valid operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-Expression-.FinalValue">
<span id="pydrake.trajectories.BsplineTrajectory_[Expression].FinalValue"></span><span class="sig-name descname"><span class="pre">FinalValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-Expression-.FinalValue" title="Permalink to this definition"></a></dt>
<dd><p>Returns this-&gt;value(this-&gt;end_time())</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-Expression-.InitialValue">
<span id="pydrake.trajectories.BsplineTrajectory_[Expression].InitialValue"></span><span class="sig-name descname"><span class="pre">InitialValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-Expression-.InitialValue" title="Permalink to this definition"></a></dt>
<dd><p>Returns this-&gt;value(this-&gt;start_time())</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-Expression-.InsertKnots">
<span id="pydrake.trajectories.BsplineTrajectory_[Expression].InsertKnots"></span><span class="sig-name descname"><span class="pre">InsertKnots</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">additional_knots</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-Expression-.InsertKnots" title="Permalink to this definition"></a></dt>
<dd><p>Adds new knots at the specified <code class="docutils literal notranslate"><span class="pre">additional_knots</span></code> without changing
the behavior of the trajectory. The basis and control points of the
trajectory are adjusted such that it produces the same value for any
valid time before and after this method is called. The resulting
trajectory is guaranteed to have the same level of continuity as the
original, even if knot values are duplicated. Note that
<code class="docutils literal notranslate"><span class="pre">additional_knots</span></code> need not be sorted.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>start_time() &lt;= t &lt;= end_time() for all t in <code class="docutils literal notranslate"><span class="pre">additional_knots</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-Expression-.num_control_points">
<span id="pydrake.trajectories.BsplineTrajectory_[Expression].num_control_points"></span><span class="sig-name descname"><span class="pre">num_control_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-Expression-.num_control_points" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of control points in this curve.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.CompositeTrajectory">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">CompositeTrajectory</span></span><a class="headerlink" href="#pydrake.trajectories.CompositeTrajectory" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory" title="pydrake.trajectories.PiecewiseTrajectory"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PiecewiseTrajectory</span></code></a></p>
<p>A “composite trajectory” is a series of trajectories joined end to end
where the end time of one trajectory coincides with the starting time
of the next.</p>
<p>See also PiecewisePolynomial::ConcatenateInTime(), which might be
preferred if all of the segments are PiecewisePolynomial.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <a class="reference internal" href="#pydrake.trajectories.CompositeTrajectory_" title="pydrake.trajectories.CompositeTrajectory_"><code class="xref py py-class docutils literal notranslate"><span class="pre">CompositeTrajectory_</span></code></a>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.CompositeTrajectory.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.CompositeTrajectory" title="pydrake.trajectories.CompositeTrajectory"><span class="pre">pydrake.trajectories.CompositeTrajectory</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">segments</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#pydrake.trajectories.Trajectory" title="pydrake.trajectories.Trajectory"><span class="pre">pydrake.trajectories.Trajectory</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.CompositeTrajectory.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a composite trajectory from a list of Trajectories.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>∀i, <code class="docutils literal notranslate"><span class="pre">segments[i].get()</span> <span class="pre">!=</span> <span class="pre">nullptr</span></code>.</p>
</dd>
<dt>Precondition:</dt><dd><p>∀i, <code class="docutils literal notranslate"><span class="pre">segments[i+1].start_time()</span> <span class="pre">==</span> <span class="pre">segments[i].end_time()</span></code>.</p>
</dd>
<dt>Precondition:</dt><dd><p>∀i, <code class="docutils literal notranslate"><span class="pre">segments[i].rows()</span> <span class="pre">==</span> <span class="pre">segments[0].rows()</span></code> and
segments[i].cols() == segments[0].cols()`.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.CompositeTrajectory.AlignAndConcatenate">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">AlignAndConcatenate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">segments</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#pydrake.trajectories.Trajectory" title="pydrake.trajectories.Trajectory"><span class="pre">pydrake.trajectories.Trajectory</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.CompositeTrajectory" title="pydrake.trajectories.CompositeTrajectory"><span class="pre">pydrake.trajectories.CompositeTrajectory</span></a></span></span><a class="headerlink" href="#pydrake.trajectories.CompositeTrajectory.AlignAndConcatenate" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a composite trajectory from a list of trajectories whose
start and end times may not coincide, by translating their start and
end times.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>∀i, <code class="docutils literal notranslate"><span class="pre">segments[i].get()</span> <span class="pre">!=</span> <span class="pre">nullptr</span></code>.</p>
</dd>
<dt>Precondition:</dt><dd><p>∀i, <code class="docutils literal notranslate"><span class="pre">segments[i].rows()</span> <span class="pre">==</span> <span class="pre">segments[0].rows()</span></code> and
segments[i].cols() == segments[0].cols()`.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.CompositeTrajectory.segment">
<span class="sig-name descname"><span class="pre">segment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.CompositeTrajectory" title="pydrake.trajectories.CompositeTrajectory"><span class="pre">pydrake.trajectories.CompositeTrajectory</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory" title="pydrake.trajectories.Trajectory"><span class="pre">pydrake.trajectories.Trajectory</span></a></span></span><a class="headerlink" href="#pydrake.trajectories.CompositeTrajectory.segment" title="Permalink to this definition"></a></dt>
<dd><p>Returns a reference to the <code class="docutils literal notranslate"><span class="pre">segment_index</span></code> trajectory.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.trajectories.CompositeTrajectory_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">CompositeTrajectory_</span></span><a class="headerlink" href="#pydrake.trajectories.CompositeTrajectory_" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">CompositeTrajectory_[float]</span></code>, <a class="reference internal" href="#pydrake.trajectories.CompositeTrajectory_-AutoDiffXd" title="pydrake.trajectories.CompositeTrajectory_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">CompositeTrajectory_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.trajectories.CompositeTrajectory_-Expression" title="pydrake.trajectories.CompositeTrajectory_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">CompositeTrajectory_[Expression]</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.CompositeTrajectory_-AutoDiffXd">
<span id="pydrake.trajectories.CompositeTrajectory_[AutoDiffXd]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">CompositeTrajectory_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.trajectories.CompositeTrajectory_-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd" title="pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd]</span></code></a></p>
<p>A “composite trajectory” is a series of trajectories joined end to end
where the end time of one trajectory coincides with the starting time
of the next.</p>
<p>See also PiecewisePolynomial::ConcatenateInTime(), which might be
preferred if all of the segments are PiecewisePolynomial.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.CompositeTrajectory_-AutoDiffXd-.__init__">
<span id="pydrake.trajectories.CompositeTrajectory_[AutoDiffXd].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.CompositeTrajectory_" title="pydrake.trajectories.CompositeTrajectory_"><span class="pre">pydrake.trajectories.CompositeTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segments</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.CompositeTrajectory_-AutoDiffXd-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a composite trajectory from a list of Trajectories.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>∀i, <code class="docutils literal notranslate"><span class="pre">segments[i].get()</span> <span class="pre">!=</span> <span class="pre">nullptr</span></code>.</p>
</dd>
<dt>Precondition:</dt><dd><p>∀i, <code class="docutils literal notranslate"><span class="pre">segments[i+1].start_time()</span> <span class="pre">==</span> <span class="pre">segments[i].end_time()</span></code>.</p>
</dd>
<dt>Precondition:</dt><dd><p>∀i, <code class="docutils literal notranslate"><span class="pre">segments[i].rows()</span> <span class="pre">==</span> <span class="pre">segments[0].rows()</span></code> and
segments[i].cols() == segments[0].cols()`.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.CompositeTrajectory_-AutoDiffXd-.AlignAndConcatenate">
<span id="pydrake.trajectories.CompositeTrajectory_[AutoDiffXd].AlignAndConcatenate"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">AlignAndConcatenate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">segments</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.CompositeTrajectory_" title="pydrake.trajectories.CompositeTrajectory_"><span class="pre">pydrake.trajectories.CompositeTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.CompositeTrajectory_-AutoDiffXd-.AlignAndConcatenate" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a composite trajectory from a list of trajectories whose
start and end times may not coincide, by translating their start and
end times.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>∀i, <code class="docutils literal notranslate"><span class="pre">segments[i].get()</span> <span class="pre">!=</span> <span class="pre">nullptr</span></code>.</p>
</dd>
<dt>Precondition:</dt><dd><p>∀i, <code class="docutils literal notranslate"><span class="pre">segments[i].rows()</span> <span class="pre">==</span> <span class="pre">segments[0].rows()</span></code> and
segments[i].cols() == segments[0].cols()`.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.CompositeTrajectory_-AutoDiffXd-.segment">
<span id="pydrake.trajectories.CompositeTrajectory_[AutoDiffXd].segment"></span><span class="sig-name descname"><span class="pre">segment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.CompositeTrajectory_" title="pydrake.trajectories.CompositeTrajectory_"><span class="pre">pydrake.trajectories.CompositeTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.CompositeTrajectory_-AutoDiffXd-.segment" title="Permalink to this definition"></a></dt>
<dd><p>Returns a reference to the <code class="docutils literal notranslate"><span class="pre">segment_index</span></code> trajectory.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.CompositeTrajectory_-Expression">
<span id="pydrake.trajectories.CompositeTrajectory_[Expression]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">CompositeTrajectory_[Expression]</span></span><a class="headerlink" href="#pydrake.trajectories.CompositeTrajectory_-Expression" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_-Expression" title="pydrake.trajectories.PiecewiseTrajectory_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_[Expression]</span></code></a></p>
<p>A “composite trajectory” is a series of trajectories joined end to end
where the end time of one trajectory coincides with the starting time
of the next.</p>
<p>See also PiecewisePolynomial::ConcatenateInTime(), which might be
preferred if all of the segments are PiecewisePolynomial.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.CompositeTrajectory_-Expression-.__init__">
<span id="pydrake.trajectories.CompositeTrajectory_[Expression].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.CompositeTrajectory_" title="pydrake.trajectories.CompositeTrajectory_"><span class="pre">pydrake.trajectories.CompositeTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segments</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.CompositeTrajectory_-Expression-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a composite trajectory from a list of Trajectories.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>∀i, <code class="docutils literal notranslate"><span class="pre">segments[i].get()</span> <span class="pre">!=</span> <span class="pre">nullptr</span></code>.</p>
</dd>
<dt>Precondition:</dt><dd><p>∀i, <code class="docutils literal notranslate"><span class="pre">segments[i+1].start_time()</span> <span class="pre">==</span> <span class="pre">segments[i].end_time()</span></code>.</p>
</dd>
<dt>Precondition:</dt><dd><p>∀i, <code class="docutils literal notranslate"><span class="pre">segments[i].rows()</span> <span class="pre">==</span> <span class="pre">segments[0].rows()</span></code> and
segments[i].cols() == segments[0].cols()`.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.CompositeTrajectory_-Expression-.AlignAndConcatenate">
<span id="pydrake.trajectories.CompositeTrajectory_[Expression].AlignAndConcatenate"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">AlignAndConcatenate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">segments</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.CompositeTrajectory_" title="pydrake.trajectories.CompositeTrajectory_"><span class="pre">pydrake.trajectories.CompositeTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.CompositeTrajectory_-Expression-.AlignAndConcatenate" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a composite trajectory from a list of trajectories whose
start and end times may not coincide, by translating their start and
end times.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>∀i, <code class="docutils literal notranslate"><span class="pre">segments[i].get()</span> <span class="pre">!=</span> <span class="pre">nullptr</span></code>.</p>
</dd>
<dt>Precondition:</dt><dd><p>∀i, <code class="docutils literal notranslate"><span class="pre">segments[i].rows()</span> <span class="pre">==</span> <span class="pre">segments[0].rows()</span></code> and
segments[i].cols() == segments[0].cols()`.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.CompositeTrajectory_-Expression-.segment">
<span id="pydrake.trajectories.CompositeTrajectory_[Expression].segment"></span><span class="sig-name descname"><span class="pre">segment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.CompositeTrajectory_" title="pydrake.trajectories.CompositeTrajectory_"><span class="pre">pydrake.trajectories.CompositeTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.CompositeTrajectory_-Expression-.segment" title="Permalink to this definition"></a></dt>
<dd><p>Returns a reference to the <code class="docutils literal notranslate"><span class="pre">segment_index</span></code> trajectory.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.DerivativeTrajectory">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">DerivativeTrajectory</span></span><a class="headerlink" href="#pydrake.trajectories.DerivativeTrajectory" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.Trajectory" title="pydrake.trajectories.Trajectory"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory</span></code></a></p>
<p>Trajectory objects provide derivatives by implementing
<code class="docutils literal notranslate"><span class="pre">DoEvalDerivative</span></code> <em>and</em> <code class="docutils literal notranslate"><span class="pre">DoMakeDerivative</span></code>. <cite>DoEvalDerivative</cite>
evaluates the derivative value at a point in time.
<code class="docutils literal notranslate"><span class="pre">DoMakeDerivative</span></code> returns a new Trajectory object which represents
the derivative.</p>
<p>In some cases, it is easy to implement <code class="docutils literal notranslate"><span class="pre">DoEvalDerivative</span></code>, but
difficult or inefficient to implement <code class="docutils literal notranslate"><span class="pre">DoMakeDerivative</span></code> natively.
And it may be just as efficient to use <code class="docutils literal notranslate"><span class="pre">DoEvalDerivative</span></code> even in
repeated evaluations of the derivative. The DerivativeTrajectory class
helps with this case – given a <code class="docutils literal notranslate"><span class="pre">nominal</span></code> Trajectory, it provides a
Trajectory interface that calls <code class="docutils literal notranslate"><span class="pre">nominal.EvalDerivative()</span></code> to
implement <code class="docutils literal notranslate"><span class="pre">Trajectory::value()</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <a class="reference internal" href="#pydrake.trajectories.DerivativeTrajectory_" title="pydrake.trajectories.DerivativeTrajectory_"><code class="xref py py-class docutils literal notranslate"><span class="pre">DerivativeTrajectory_</span></code></a>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.DerivativeTrajectory.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.DerivativeTrajectory" title="pydrake.trajectories.DerivativeTrajectory"><span class="pre">pydrake.trajectories.DerivativeTrajectory</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">nominal</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory" title="pydrake.trajectories.Trajectory"><span class="pre">pydrake.trajectories.Trajectory</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">derivative_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.DerivativeTrajectory.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Creates a DerivativeTrajectory representing the <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code>
derivatives of <code class="docutils literal notranslate"><span class="pre">nominal</span></code>. This constructor makes a Clone() of
<code class="docutils literal notranslate"><span class="pre">nominal</span></code> and does not hold on to the reference.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if !nominal.has_derivative</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
<li><p><strong>RuntimeError if derivative_order &lt; 0.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.trajectories.DerivativeTrajectory_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">DerivativeTrajectory_</span></span><a class="headerlink" href="#pydrake.trajectories.DerivativeTrajectory_" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">DerivativeTrajectory_[float]</span></code>, <a class="reference internal" href="#pydrake.trajectories.DerivativeTrajectory_-AutoDiffXd" title="pydrake.trajectories.DerivativeTrajectory_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">DerivativeTrajectory_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.trajectories.DerivativeTrajectory_-Expression" title="pydrake.trajectories.DerivativeTrajectory_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">DerivativeTrajectory_[Expression]</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.DerivativeTrajectory_-AutoDiffXd">
<span id="pydrake.trajectories.DerivativeTrajectory_[AutoDiffXd]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">DerivativeTrajectory_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.trajectories.DerivativeTrajectory_-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.Trajectory_-AutoDiffXd" title="pydrake.trajectories.Trajectory_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[AutoDiffXd]</span></code></a></p>
<p>Trajectory objects provide derivatives by implementing
<code class="docutils literal notranslate"><span class="pre">DoEvalDerivative</span></code> <em>and</em> <code class="docutils literal notranslate"><span class="pre">DoMakeDerivative</span></code>. <cite>DoEvalDerivative</cite>
evaluates the derivative value at a point in time.
<code class="docutils literal notranslate"><span class="pre">DoMakeDerivative</span></code> returns a new Trajectory object which represents
the derivative.</p>
<p>In some cases, it is easy to implement <code class="docutils literal notranslate"><span class="pre">DoEvalDerivative</span></code>, but
difficult or inefficient to implement <code class="docutils literal notranslate"><span class="pre">DoMakeDerivative</span></code> natively.
And it may be just as efficient to use <code class="docutils literal notranslate"><span class="pre">DoEvalDerivative</span></code> even in
repeated evaluations of the derivative. The DerivativeTrajectory class
helps with this case – given a <code class="docutils literal notranslate"><span class="pre">nominal</span></code> Trajectory, it provides a
Trajectory interface that calls <code class="docutils literal notranslate"><span class="pre">nominal.EvalDerivative()</span></code> to
implement <code class="docutils literal notranslate"><span class="pre">Trajectory::value()</span></code>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.DerivativeTrajectory_-AutoDiffXd-.__init__">
<span id="pydrake.trajectories.DerivativeTrajectory_[AutoDiffXd].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.DerivativeTrajectory_" title="pydrake.trajectories.DerivativeTrajectory_"><span class="pre">pydrake.trajectories.DerivativeTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nominal</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derivative_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.DerivativeTrajectory_-AutoDiffXd-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Creates a DerivativeTrajectory representing the <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code>
derivatives of <code class="docutils literal notranslate"><span class="pre">nominal</span></code>. This constructor makes a Clone() of
<code class="docutils literal notranslate"><span class="pre">nominal</span></code> and does not hold on to the reference.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if !nominal.has_derivative</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
<li><p><strong>RuntimeError if derivative_order &lt; 0.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.DerivativeTrajectory_-Expression">
<span id="pydrake.trajectories.DerivativeTrajectory_[Expression]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">DerivativeTrajectory_[Expression]</span></span><a class="headerlink" href="#pydrake.trajectories.DerivativeTrajectory_-Expression" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.Trajectory_-Expression" title="pydrake.trajectories.Trajectory_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[Expression]</span></code></a></p>
<p>Trajectory objects provide derivatives by implementing
<code class="docutils literal notranslate"><span class="pre">DoEvalDerivative</span></code> <em>and</em> <code class="docutils literal notranslate"><span class="pre">DoMakeDerivative</span></code>. <cite>DoEvalDerivative</cite>
evaluates the derivative value at a point in time.
<code class="docutils literal notranslate"><span class="pre">DoMakeDerivative</span></code> returns a new Trajectory object which represents
the derivative.</p>
<p>In some cases, it is easy to implement <code class="docutils literal notranslate"><span class="pre">DoEvalDerivative</span></code>, but
difficult or inefficient to implement <code class="docutils literal notranslate"><span class="pre">DoMakeDerivative</span></code> natively.
And it may be just as efficient to use <code class="docutils literal notranslate"><span class="pre">DoEvalDerivative</span></code> even in
repeated evaluations of the derivative. The DerivativeTrajectory class
helps with this case – given a <code class="docutils literal notranslate"><span class="pre">nominal</span></code> Trajectory, it provides a
Trajectory interface that calls <code class="docutils literal notranslate"><span class="pre">nominal.EvalDerivative()</span></code> to
implement <code class="docutils literal notranslate"><span class="pre">Trajectory::value()</span></code>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.DerivativeTrajectory_-Expression-.__init__">
<span id="pydrake.trajectories.DerivativeTrajectory_[Expression].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.DerivativeTrajectory_" title="pydrake.trajectories.DerivativeTrajectory_"><span class="pre">pydrake.trajectories.DerivativeTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nominal</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derivative_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.DerivativeTrajectory_-Expression-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Creates a DerivativeTrajectory representing the <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code>
derivatives of <code class="docutils literal notranslate"><span class="pre">nominal</span></code>. This constructor makes a Clone() of
<code class="docutils literal notranslate"><span class="pre">nominal</span></code> and does not hold on to the reference.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if !nominal.has_derivative</strong><strong>(</strong><strong>)</strong><strong></strong> – </p></li>
<li><p><strong>RuntimeError if derivative_order &lt; 0.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.ExponentialPlusPiecewisePolynomial">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">ExponentialPlusPiecewisePolynomial</span></span><a class="headerlink" href="#pydrake.trajectories.ExponentialPlusPiecewisePolynomial" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory" title="pydrake.trajectories.PiecewiseTrajectory"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PiecewiseTrajectory</span></code></a></p>
<p>Represents a piecewise-trajectory with piece <span class="math notranslate nohighlight">\(j\)</span> given by:</p>
<div class="math notranslate nohighlight">
\[x(t) = K e^{A (t - t_j)} \alpha_j + \sum_{i=0}^k \beta_{j,i}(t-t_j)^i,\]</div>
<p>where <span class="math notranslate nohighlight">\(k\)</span> is the order of the <code class="docutils literal notranslate"><span class="pre">piecewise_polynomial_part</span></code> and
<span class="math notranslate nohighlight">\(t_j\)</span> is the start time of the <span class="math notranslate nohighlight">\(j\)</span>-th segment.</p>
<p>This particular form can represent the solution to a linear dynamical
system driven by a piecewise-polynomial input:</p>
<div class="math notranslate nohighlight">
\[\dot{x}(t) = A x(t) + B u(t),\]</div>
<p>where the input <span class="math notranslate nohighlight">\(u(t)\)</span> is a piecewise-polynomial function of
time. See [1] for details and a motivating use case.</p>
<p>[1] R. Tedrake, S. Kuindersma, R. Deits and K. Miura, “A closed-form
solution for real-time ZMP gait generation and feedback
stabilization,” 2015 IEEE-RAS 15th International Conference on
Humanoid Robots (Humanoids), Seoul, 2015, pp. 936-940.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <a class="reference internal" href="#pydrake.trajectories.ExponentialPlusPiecewisePolynomial_" title="pydrake.trajectories.ExponentialPlusPiecewisePolynomial_"><code class="xref py py-class docutils literal notranslate"><span class="pre">ExponentialPlusPiecewisePolynomial_</span></code></a>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.ExponentialPlusPiecewisePolynomial.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.ExponentialPlusPiecewisePolynomial" title="pydrake.trajectories.ExponentialPlusPiecewisePolynomial"><span class="pre">pydrake.trajectories.ExponentialPlusPiecewisePolynomial</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">K</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">piecewise_polynomial_part</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial" title="pydrake.trajectories.PiecewisePolynomial"><span class="pre">pydrake.trajectories.PiecewisePolynomial</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.ExponentialPlusPiecewisePolynomial.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.ExponentialPlusPiecewisePolynomial.shiftRight">
<span class="sig-name descname"><span class="pre">shiftRight</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.ExponentialPlusPiecewisePolynomial" title="pydrake.trajectories.ExponentialPlusPiecewisePolynomial"><span class="pre">pydrake.trajectories.ExponentialPlusPiecewisePolynomial</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.ExponentialPlusPiecewisePolynomial.shiftRight" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.trajectories.ExponentialPlusPiecewisePolynomial_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">ExponentialPlusPiecewisePolynomial_</span></span><a class="headerlink" href="#pydrake.trajectories.ExponentialPlusPiecewisePolynomial_" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">ExponentialPlusPiecewisePolynomial_[float]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.FunctionHandleTrajectory">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">FunctionHandleTrajectory</span></span><a class="headerlink" href="#pydrake.trajectories.FunctionHandleTrajectory" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.Trajectory" title="pydrake.trajectories.Trajectory"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory</span></code></a></p>
<p>FunctionHandleTrajectory takes a function, value = f(t), and provides
a Trajectory interface.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <a class="reference internal" href="#pydrake.trajectories.FunctionHandleTrajectory_" title="pydrake.trajectories.FunctionHandleTrajectory_"><code class="xref py py-class docutils literal notranslate"><span class="pre">FunctionHandleTrajectory_</span></code></a>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.FunctionHandleTrajectory.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.FunctionHandleTrajectory" title="pydrake.trajectories.FunctionHandleTrajectory"><span class="pre">pydrake.trajectories.FunctionHandleTrajectory</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rows</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cols</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-</span> <span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end_time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">inf</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.FunctionHandleTrajectory.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Creates the FunctionHandleTrajectory.</p>
<p>By default the created trajectory does not provide derivatives. If
trajectory derivatives are required, call <code class="docutils literal notranslate"><span class="pre">set_derivative</span></code> to
provide the function’s derivatives.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">func</span></code>:</dt><dd><p>The function to be used to evaluate the trajectory.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rows</span></code>:</dt><dd><p>The number of rows in the output of the function.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">cols</span></code>:</dt><dd><p>The number of columns in the output of the function.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">start_time</span></code>:</dt><dd><p>The start time of the trajectory.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">end_time</span></code>:</dt><dd><p>The end time of the trajectory.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if func == nullptr</strong><strong>, </strong><strong>rows &lt; 0</strong><strong>, </strong><strong>cols &lt; 0</strong><strong>, </strong><strong>start_time &gt;</strong> – </p></li>
<li><p><strong>end_time</strong><strong>, or </strong><strong>if the function returns a matrix of the wrong size.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.FunctionHandleTrajectory.set_derivative">
<span class="sig-name descname"><span class="pre">set_derivative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.FunctionHandleTrajectory" title="pydrake.trajectories.FunctionHandleTrajectory"><span class="pre">pydrake.trajectories.FunctionHandleTrajectory</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.FunctionHandleTrajectory.set_derivative" title="Permalink to this definition"></a></dt>
<dd><p>Sets a callback function that returns the derivative of the function.
<code class="docutils literal notranslate"><span class="pre">func(t,order)</span></code> will only be called with <code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>. It is
recommended that if the derivatives are not implemented for the
requested order, the callback should throw an exception.</p>
<p>The size of the output of <code class="docutils literal notranslate"><span class="pre">func</span></code> will be checked each time the
derivative is evaluated, and a RuntimeError will be thrown if the size
is incorrect.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.trajectories.FunctionHandleTrajectory_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">FunctionHandleTrajectory_</span></span><a class="headerlink" href="#pydrake.trajectories.FunctionHandleTrajectory_" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">FunctionHandleTrajectory_[float]</span></code>, <a class="reference internal" href="#pydrake.trajectories.FunctionHandleTrajectory_-AutoDiffXd" title="pydrake.trajectories.FunctionHandleTrajectory_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">FunctionHandleTrajectory_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.trajectories.FunctionHandleTrajectory_-Expression" title="pydrake.trajectories.FunctionHandleTrajectory_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">FunctionHandleTrajectory_[Expression]</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.FunctionHandleTrajectory_-AutoDiffXd">
<span id="pydrake.trajectories.FunctionHandleTrajectory_[AutoDiffXd]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">FunctionHandleTrajectory_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.trajectories.FunctionHandleTrajectory_-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.Trajectory_-AutoDiffXd" title="pydrake.trajectories.Trajectory_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[AutoDiffXd]</span></code></a></p>
<p>FunctionHandleTrajectory takes a function, value = f(t), and provides
a Trajectory interface.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.FunctionHandleTrajectory_-AutoDiffXd-.__init__">
<span id="pydrake.trajectories.FunctionHandleTrajectory_[AutoDiffXd].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.FunctionHandleTrajectory_" title="pydrake.trajectories.FunctionHandleTrajectory_"><span class="pre">pydrake.trajectories.FunctionHandleTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rows</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cols</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-</span> <span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end_time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">inf</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.FunctionHandleTrajectory_-AutoDiffXd-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Creates the FunctionHandleTrajectory.</p>
<p>By default the created trajectory does not provide derivatives. If
trajectory derivatives are required, call <code class="docutils literal notranslate"><span class="pre">set_derivative</span></code> to
provide the function’s derivatives.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">func</span></code>:</dt><dd><p>The function to be used to evaluate the trajectory.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rows</span></code>:</dt><dd><p>The number of rows in the output of the function.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">cols</span></code>:</dt><dd><p>The number of columns in the output of the function.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">start_time</span></code>:</dt><dd><p>The start time of the trajectory.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">end_time</span></code>:</dt><dd><p>The end time of the trajectory.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if func == nullptr</strong><strong>, </strong><strong>rows &lt; 0</strong><strong>, </strong><strong>cols &lt; 0</strong><strong>, </strong><strong>start_time &gt;</strong> – </p></li>
<li><p><strong>end_time</strong><strong>, or </strong><strong>if the function returns a matrix of the wrong size.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.FunctionHandleTrajectory_-AutoDiffXd-.set_derivative">
<span id="pydrake.trajectories.FunctionHandleTrajectory_[AutoDiffXd].set_derivative"></span><span class="sig-name descname"><span class="pre">set_derivative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.FunctionHandleTrajectory_" title="pydrake.trajectories.FunctionHandleTrajectory_"><span class="pre">pydrake.trajectories.FunctionHandleTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.FunctionHandleTrajectory_-AutoDiffXd-.set_derivative" title="Permalink to this definition"></a></dt>
<dd><p>Sets a callback function that returns the derivative of the function.
<code class="docutils literal notranslate"><span class="pre">func(t,order)</span></code> will only be called with <code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>. It is
recommended that if the derivatives are not implemented for the
requested order, the callback should throw an exception.</p>
<p>The size of the output of <code class="docutils literal notranslate"><span class="pre">func</span></code> will be checked each time the
derivative is evaluated, and a RuntimeError will be thrown if the size
is incorrect.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.FunctionHandleTrajectory_-Expression">
<span id="pydrake.trajectories.FunctionHandleTrajectory_[Expression]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">FunctionHandleTrajectory_[Expression]</span></span><a class="headerlink" href="#pydrake.trajectories.FunctionHandleTrajectory_-Expression" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.Trajectory_-Expression" title="pydrake.trajectories.Trajectory_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[Expression]</span></code></a></p>
<p>FunctionHandleTrajectory takes a function, value = f(t), and provides
a Trajectory interface.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.FunctionHandleTrajectory_-Expression-.__init__">
<span id="pydrake.trajectories.FunctionHandleTrajectory_[Expression].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.FunctionHandleTrajectory_" title="pydrake.trajectories.FunctionHandleTrajectory_"><span class="pre">pydrake.trajectories.FunctionHandleTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rows</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cols</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-</span> <span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end_time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">inf</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.FunctionHandleTrajectory_-Expression-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Creates the FunctionHandleTrajectory.</p>
<p>By default the created trajectory does not provide derivatives. If
trajectory derivatives are required, call <code class="docutils literal notranslate"><span class="pre">set_derivative</span></code> to
provide the function’s derivatives.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">func</span></code>:</dt><dd><p>The function to be used to evaluate the trajectory.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rows</span></code>:</dt><dd><p>The number of rows in the output of the function.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">cols</span></code>:</dt><dd><p>The number of columns in the output of the function.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">start_time</span></code>:</dt><dd><p>The start time of the trajectory.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">end_time</span></code>:</dt><dd><p>The end time of the trajectory.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if func == nullptr</strong><strong>, </strong><strong>rows &lt; 0</strong><strong>, </strong><strong>cols &lt; 0</strong><strong>, </strong><strong>start_time &gt;</strong> – </p></li>
<li><p><strong>end_time</strong><strong>, or </strong><strong>if the function returns a matrix of the wrong size.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.FunctionHandleTrajectory_-Expression-.set_derivative">
<span id="pydrake.trajectories.FunctionHandleTrajectory_[Expression].set_derivative"></span><span class="sig-name descname"><span class="pre">set_derivative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.FunctionHandleTrajectory_" title="pydrake.trajectories.FunctionHandleTrajectory_"><span class="pre">pydrake.trajectories.FunctionHandleTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.FunctionHandleTrajectory_-Expression-.set_derivative" title="Permalink to this definition"></a></dt>
<dd><p>Sets a callback function that returns the derivative of the function.
<code class="docutils literal notranslate"><span class="pre">func(t,order)</span></code> will only be called with <code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>. It is
recommended that if the derivatives are not implemented for the
requested order, the callback should throw an exception.</p>
<p>The size of the output of <code class="docutils literal notranslate"><span class="pre">func</span></code> will be checked each time the
derivative is evaluated, and a RuntimeError will be thrown if the size
is incorrect.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.PathParameterizedTrajectory">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PathParameterizedTrajectory</span></span><a class="headerlink" href="#pydrake.trajectories.PathParameterizedTrajectory" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.Trajectory" title="pydrake.trajectories.Trajectory"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory</span></code></a></p>
<p>A trajectory defined by a path and timing trajectory.</p>
<p>Using a path of form <code class="docutils literal notranslate"><span class="pre">r(s)</span></code> and a time_scaling of the form <code class="docutils literal notranslate"><span class="pre">s(t)</span></code>,
a full trajectory of form <code class="docutils literal notranslate"><span class="pre">q(t)</span> <span class="pre">=</span> <span class="pre">r(s(t))</span></code> is modeled.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <a class="reference internal" href="#pydrake.trajectories.PathParameterizedTrajectory_" title="pydrake.trajectories.PathParameterizedTrajectory_"><code class="xref py py-class docutils literal notranslate"><span class="pre">PathParameterizedTrajectory_</span></code></a>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PathParameterizedTrajectory.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PathParameterizedTrajectory" title="pydrake.trajectories.PathParameterizedTrajectory"><span class="pre">pydrake.trajectories.PathParameterizedTrajectory</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory" title="pydrake.trajectories.Trajectory"><span class="pre">pydrake.trajectories.Trajectory</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_scaling</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory" title="pydrake.trajectories.Trajectory"><span class="pre">pydrake.trajectories.Trajectory</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PathParameterizedTrajectory.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a trajectory with the given <code class="docutils literal notranslate"><span class="pre">path</span></code> and <code class="docutils literal notranslate"><span class="pre">time_scaling</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>time_scaling.rows() == time_scaling.cols() == 1</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PathParameterizedTrajectory.path">
<span class="sig-name descname"><span class="pre">path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PathParameterizedTrajectory" title="pydrake.trajectories.PathParameterizedTrajectory"><span class="pre">pydrake.trajectories.PathParameterizedTrajectory</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory" title="pydrake.trajectories.Trajectory"><span class="pre">pydrake.trajectories.Trajectory</span></a></span></span><a class="headerlink" href="#pydrake.trajectories.PathParameterizedTrajectory.path" title="Permalink to this definition"></a></dt>
<dd><p>Returns the path of this trajectory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PathParameterizedTrajectory.time_scaling">
<span class="sig-name descname"><span class="pre">time_scaling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PathParameterizedTrajectory" title="pydrake.trajectories.PathParameterizedTrajectory"><span class="pre">pydrake.trajectories.PathParameterizedTrajectory</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory" title="pydrake.trajectories.Trajectory"><span class="pre">pydrake.trajectories.Trajectory</span></a></span></span><a class="headerlink" href="#pydrake.trajectories.PathParameterizedTrajectory.time_scaling" title="Permalink to this definition"></a></dt>
<dd><p>Returns the time_scaling of this trajectory.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.trajectories.PathParameterizedTrajectory_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PathParameterizedTrajectory_</span></span><a class="headerlink" href="#pydrake.trajectories.PathParameterizedTrajectory_" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">PathParameterizedTrajectory_[float]</span></code>, <a class="reference internal" href="#pydrake.trajectories.PathParameterizedTrajectory_-AutoDiffXd" title="pydrake.trajectories.PathParameterizedTrajectory_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">PathParameterizedTrajectory_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.trajectories.PathParameterizedTrajectory_-Expression" title="pydrake.trajectories.PathParameterizedTrajectory_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">PathParameterizedTrajectory_[Expression]</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.PathParameterizedTrajectory_-AutoDiffXd">
<span id="pydrake.trajectories.PathParameterizedTrajectory_[AutoDiffXd]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PathParameterizedTrajectory_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.trajectories.PathParameterizedTrajectory_-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.Trajectory_-AutoDiffXd" title="pydrake.trajectories.Trajectory_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[AutoDiffXd]</span></code></a></p>
<p>A trajectory defined by a path and timing trajectory.</p>
<p>Using a path of form <code class="docutils literal notranslate"><span class="pre">r(s)</span></code> and a time_scaling of the form <code class="docutils literal notranslate"><span class="pre">s(t)</span></code>,
a full trajectory of form <code class="docutils literal notranslate"><span class="pre">q(t)</span> <span class="pre">=</span> <span class="pre">r(s(t))</span></code> is modeled.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PathParameterizedTrajectory_-AutoDiffXd-.__init__">
<span id="pydrake.trajectories.PathParameterizedTrajectory_[AutoDiffXd].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PathParameterizedTrajectory_" title="pydrake.trajectories.PathParameterizedTrajectory_"><span class="pre">pydrake.trajectories.PathParameterizedTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_scaling</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PathParameterizedTrajectory_-AutoDiffXd-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a trajectory with the given <code class="docutils literal notranslate"><span class="pre">path</span></code> and <code class="docutils literal notranslate"><span class="pre">time_scaling</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>time_scaling.rows() == time_scaling.cols() == 1</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PathParameterizedTrajectory_-AutoDiffXd-.path">
<span id="pydrake.trajectories.PathParameterizedTrajectory_[AutoDiffXd].path"></span><span class="sig-name descname"><span class="pre">path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PathParameterizedTrajectory_" title="pydrake.trajectories.PathParameterizedTrajectory_"><span class="pre">pydrake.trajectories.PathParameterizedTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PathParameterizedTrajectory_-AutoDiffXd-.path" title="Permalink to this definition"></a></dt>
<dd><p>Returns the path of this trajectory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PathParameterizedTrajectory_-AutoDiffXd-.time_scaling">
<span id="pydrake.trajectories.PathParameterizedTrajectory_[AutoDiffXd].time_scaling"></span><span class="sig-name descname"><span class="pre">time_scaling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PathParameterizedTrajectory_" title="pydrake.trajectories.PathParameterizedTrajectory_"><span class="pre">pydrake.trajectories.PathParameterizedTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PathParameterizedTrajectory_-AutoDiffXd-.time_scaling" title="Permalink to this definition"></a></dt>
<dd><p>Returns the time_scaling of this trajectory.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.PathParameterizedTrajectory_-Expression">
<span id="pydrake.trajectories.PathParameterizedTrajectory_[Expression]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PathParameterizedTrajectory_[Expression]</span></span><a class="headerlink" href="#pydrake.trajectories.PathParameterizedTrajectory_-Expression" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.Trajectory_-Expression" title="pydrake.trajectories.Trajectory_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[Expression]</span></code></a></p>
<p>A trajectory defined by a path and timing trajectory.</p>
<p>Using a path of form <code class="docutils literal notranslate"><span class="pre">r(s)</span></code> and a time_scaling of the form <code class="docutils literal notranslate"><span class="pre">s(t)</span></code>,
a full trajectory of form <code class="docutils literal notranslate"><span class="pre">q(t)</span> <span class="pre">=</span> <span class="pre">r(s(t))</span></code> is modeled.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PathParameterizedTrajectory_-Expression-.__init__">
<span id="pydrake.trajectories.PathParameterizedTrajectory_[Expression].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PathParameterizedTrajectory_" title="pydrake.trajectories.PathParameterizedTrajectory_"><span class="pre">pydrake.trajectories.PathParameterizedTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_scaling</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PathParameterizedTrajectory_-Expression-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a trajectory with the given <code class="docutils literal notranslate"><span class="pre">path</span></code> and <code class="docutils literal notranslate"><span class="pre">time_scaling</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>time_scaling.rows() == time_scaling.cols() == 1</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PathParameterizedTrajectory_-Expression-.path">
<span id="pydrake.trajectories.PathParameterizedTrajectory_[Expression].path"></span><span class="sig-name descname"><span class="pre">path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PathParameterizedTrajectory_" title="pydrake.trajectories.PathParameterizedTrajectory_"><span class="pre">pydrake.trajectories.PathParameterizedTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PathParameterizedTrajectory_-Expression-.path" title="Permalink to this definition"></a></dt>
<dd><p>Returns the path of this trajectory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PathParameterizedTrajectory_-Expression-.time_scaling">
<span id="pydrake.trajectories.PathParameterizedTrajectory_[Expression].time_scaling"></span><span class="sig-name descname"><span class="pre">time_scaling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PathParameterizedTrajectory_" title="pydrake.trajectories.PathParameterizedTrajectory_"><span class="pre">pydrake.trajectories.PathParameterizedTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PathParameterizedTrajectory_-Expression-.time_scaling" title="Permalink to this definition"></a></dt>
<dd><p>Returns the time_scaling of this trajectory.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PiecewisePolynomial</span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory" title="pydrake.trajectories.PiecewiseTrajectory"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PiecewiseTrajectory</span></code></a></p>
<p>A scalar multi-variate piecewise polynomial.</p>
<p>PiecewisePolynomial represents a list of contiguous segments in a
scalar independent variable (typically corresponding to time) with
Polynomials defined at each segment. We call the output from
evaluating the PiecewisePolynomial at the scalar independent variable
“the output”, and that output can be either a Eigen MatrixX&lt;T&gt; (if
evaluated using value()) or a scalar (if evaluated using
scalar_value()).</p>
<p>An example of a piecewise polynomial is a function of m segments in
time, where a different polynomial is defined for each segment. For a
specific example, consider the absolute value function over the
interval [-1, 1]. We can define a PiecewisePolynomial over this
interval using breaks at t = { -1.0, 0.0, 1.0 }, and “samples” of
abs(t).</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Construct the PiecewisePolynomial.</span>
<span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">breaks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">-1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span><span class="o">&gt;</span><span class="w"> </span><span class="n">samples</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">breaks</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">resize</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">breaks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">pp</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">     </span><span class="n">PiecewisePolynomial</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">FirstOrderHold</span><span class="p">(</span><span class="n">breaks</span><span class="p">,</span><span class="w"> </span><span class="n">samples</span><span class="p">);</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Evaluate the PiecewisePolynomial at some values.</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pp</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="mf">-.5</span><span class="p">)(</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w">    </span><span class="c1">// Outputs 0.5.</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pp</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)(</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w">    </span><span class="c1">// Outputs 0.0;</span>

<span class="c1">// Show how we can evaluate the first derivative (outputs -1.0).</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pp</span><span class="p">.</span><span class="n">derivative</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">value</span><span class="p">(</span><span class="mf">-.5</span><span class="p">)(</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</details><p>A note on terminology. For piecewise-polynomial interpolation, we use
<code class="docutils literal notranslate"><span class="pre">breaks</span></code> to indicate the scalar (e.g. times) which form the boundary
of each segment. We use <code class="docutils literal notranslate"><span class="pre">samples</span></code> to indicate the function value at
the <code class="docutils literal notranslate"><span class="pre">breaks</span></code>, e.g. <code class="docutils literal notranslate"><span class="pre">p(breaks[i])</span> <span class="pre">=</span> <span class="pre">samples[i]</span></code>. The term <code class="docutils literal notranslate"><span class="pre">knot</span></code>
should be reserved for the “(x,y)” coordinate, here <code class="docutils literal notranslate"><span class="pre">knot[i]</span> <span class="pre">=</span>
<span class="pre">(breaks[i],</span> <span class="pre">samples[i])</span></code>, though it is used inconsistently in the
interpolation literature (sometimes for <code class="docutils literal notranslate"><span class="pre">breaks</span></code>, sometimes for
<code class="docutils literal notranslate"><span class="pre">samples</span></code>), so we try to mostly avoid it here.</p>
<p>PiecewisePolynomial objects can be added, subtracted, and multiplied.
They cannot be divided because Polynomials are not closed under
division.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>PiecewisePolynomial silently clips input evaluations outside of
the range defined by the breaks. So <code class="docutils literal notranslate"><span class="pre">pp.value(-2.0,</span> <span class="pre">row,</span> <span class="pre">col)</span></code>
in the example above would evaluate to -1.0. See value().</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewisePolynomial_</span></code></a>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.PiecewisePolynomial) -&gt; None</p></li>
</ol>
<p>Constructs an empty piecewise polynomial.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.trajectories.PiecewisePolynomial, arg0: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]) -&gt; None</p></li>
</ol>
<p>Single segment, constant value constructor over the interval [-∞, ∞].
The constructed PiecewisePolynomial will return <code class="docutils literal notranslate"><span class="pre">constant_value</span></code> at
every evaluated point (i.e., <code class="docutils literal notranslate"><span class="pre">value(t)</span> <span class="pre">=</span> <span class="pre">constant_value</span></code> ∀t ∈ [-∞,
∞]).</p>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.trajectories.PiecewisePolynomial, arg0: list[numpy.ndarray[object[m, n]]], arg1: list[float]) -&gt; None</p></li>
</ol>
<p>Constructs a PiecewisePolynomial using matrix-output Polynomials
defined over each segment.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">polynomials.size()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span> <span class="pre">-</span> <span class="pre">1</span></code></p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.trajectories.PiecewisePolynomial, arg0: list[pydrake.polynomial.Polynomial], arg1: list[float]) -&gt; None</p></li>
</ol>
<p>Constructs a PiecewisePolynomial using scalar-output Polynomials
defined over each segment.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">polynomials.size()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span> <span class="pre">-</span> <span class="pre">1</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial.AppendCubicHermiteSegment">
<span class="sig-name descname"><span class="pre">AppendCubicHermiteSegment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial" title="pydrake.trajectories.PiecewisePolynomial"><span class="pre">pydrake.trajectories.PiecewisePolynomial</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_dot</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.AppendCubicHermiteSegment" title="Permalink to this definition"></a></dt>
<dd><p>The CubicHermite spline construction has a nice property of being
incremental (each segment can be solved independently). Given a new
sample and it’s derivative, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code> where the start sample and derivative are taken as the value
and derivative at the final break of <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> is not empty()</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">time</span></code> &gt; end_time()</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">sample</span></code> and <code class="docutils literal notranslate"><span class="pre">sample_dot</span></code> must have size rows() x cols().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial.AppendFirstOrderSegment">
<span class="sig-name descname"><span class="pre">AppendFirstOrderSegment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial" title="pydrake.trajectories.PiecewisePolynomial"><span class="pre">pydrake.trajectories.PiecewisePolynomial</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.AppendFirstOrderSegment" title="Permalink to this definition"></a></dt>
<dd><p>Given a new sample, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code> using a first-order hold, where the start sample is taken as
the value at the final break of <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial.Block">
<span class="sig-name descname"><span class="pre">Block</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial" title="pydrake.trajectories.PiecewisePolynomial"><span class="pre">pydrake.trajectories.PiecewisePolynomial</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_row</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_rows</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_cols</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial" title="pydrake.trajectories.PiecewisePolynomial"><span class="pre">pydrake.trajectories.PiecewisePolynomial</span></a></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.Block" title="Permalink to this definition"></a></dt>
<dd><p>Extracts a trajectory representing a block of size (block_rows,
block_cols) starting at (start_row, start_col) from the
PiecewisePolynomial.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a PiecewisePolynomial such that ret.value(t) =
this.value(t).block(i,j,p,q);</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial.ConcatenateInTime">
<span class="sig-name descname"><span class="pre">ConcatenateInTime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial" title="pydrake.trajectories.PiecewisePolynomial"><span class="pre">pydrake.trajectories.PiecewisePolynomial</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial" title="pydrake.trajectories.PiecewisePolynomial"><span class="pre">pydrake.trajectories.PiecewisePolynomial</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.ConcatenateInTime" title="Permalink to this definition"></a></dt>
<dd><p>Concatenates <code class="docutils literal notranslate"><span class="pre">other</span></code> to the end of <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The resulting PiecewisePolynomial will only be continuous to the
degree that the first Polynomial of <code class="docutils literal notranslate"><span class="pre">other</span></code> is continuous with
the last Polynomial of <code class="docutils literal notranslate"><span class="pre">this</span></code>. See warning about evaluating
discontinuous derivatives at breaks in derivative().</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other</span></code>:</dt><dd><p>PiecewisePolynomial instance to concatenate.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if trajectories' dimensions do not match each other</strong> – </p></li>
<li><p><strong>(</strong><strong>either rows</strong><strong>(</strong><strong>) or </strong><strong>cols</strong><strong>(</strong><strong>) </strong><strong>does not match between this and</strong> – </p></li>
<li><p><strong>other`</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if this-&gt;end_time</strong><strong>(</strong><strong>) </strong><strong>and other-&gt;start_time</strong><strong>(</strong><strong>)</strong> – </p></li>
<li><p><strong>are not within PiecewiseTrajectory&lt;T&gt;::kEpsilonTime from each</strong> – </p></li>
<li><p><strong>other.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial.CubicHermite">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">CubicHermite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.CubicHermite" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CubicHermite(breaks: list[float], samples: list[list[float]], samples_dot: list[list[float]]) -&gt; pydrake.trajectories.PiecewisePolynomial</p></li>
</ol>
<p>Version of CubicHermite(breaks, samples, samples_dot) that uses vector
samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Corresponding
columns of <code class="docutils literal notranslate"><span class="pre">samples</span></code> and <code class="docutils literal notranslate"><span class="pre">samples_dot</span></code> are used as the sample
point and independent variable derivative, respectively.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">samples_dot.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>CubicHermite(breaks: list[float], samples: list[numpy.ndarray[numpy.float64[m, n]]], samples_dot: list[numpy.ndarray[numpy.float64[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial</p></li>
</ol>
<p>Constructs a third order PiecewisePolynomial using matrix samples and
derivatives of samples (<code class="docutils literal notranslate"><span class="pre">samples_dot</span></code>); each matrix element of
<code class="docutils literal notranslate"><span class="pre">samples_dot</span></code> represents the derivative with respect to the
independent variable (e.g., the time derivative) of the corresponding
entry in <code class="docutils literal notranslate"><span class="pre">samples</span></code>. Each segment is fully specified by <code class="docutils literal notranslate"><span class="pre">samples</span></code>
and <code class="docutils literal notranslate"><span class="pre">sample_dot</span></code> at both ends. Second derivatives are not
continuous.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial.CubicShapePreserving">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">CubicShapePreserving</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.CubicShapePreserving" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CubicShapePreserving(breaks: list[float], samples: list[list[float]], zero_end_point_derivatives: bool = False) -&gt; pydrake.trajectories.PiecewisePolynomial</p></li>
</ol>
<p>Version of CubicShapePreserving(breaks, samples,
zero_end_point_derivatives) that uses vector samples and Eigen
VectorXd and MatrixX&lt;T&gt; arguments. Each column of <code class="docutils literal notranslate"><span class="pre">samples</span></code>
represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>CubicShapePreserving(breaks: list[float], samples: list[numpy.ndarray[numpy.float64[m, n]]], zero_end_point_derivatives: bool = False) -&gt; pydrake.trajectories.PiecewisePolynomial</p></li>
</ol>
<p>Constructs a third order PiecewisePolynomial using vector samples,
where each column of <code class="docutils literal notranslate"><span class="pre">samples</span></code> represents a sample point. First
derivatives are chosen to be “shape preserving”, i.e. if <code class="docutils literal notranslate"><span class="pre">samples</span></code>
is monotonic within some interval, the interpolated data will also be
monotonic. The second derivative is not guaranteed to be smooth across
the entire spline.</p>
<p>MATLAB calls this method “pchip” (short for “Piecewise Cubic Hermite
Interpolating Polynomial”), and provides a nice description in their
documentation.
<a class="reference external" href="http://home.uchicago.edu/~sctchoi/courses/cs138/interp.pdf">http://home.uchicago.edu/~sctchoi/courses/cs138/interp.pdf</a> is also a
good reference.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, the first and last
first derivative is chosen using a non-centered, shape-preserving
three-point formulae. See equation (2.10) in the following reference
for more details. <a class="reference external" href="http://www.mi.sanu.ac.rs/~gvm/radovi/mon.pdf">http://www.mi.sanu.ac.rs/~gvm/radovi/mon.pdf</a> If
<code class="docutils literal notranslate"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, they are set to zeros.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, <cite>breaks</cite> and
<code class="docutils literal notranslate"><span class="pre">samples</span></code> must have at least 3 elements for the algorithm to
determine the first derivatives.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, <cite>breaks</cite> and
<code class="docutils literal notranslate"><span class="pre">samples</span></code> may have 2 or more elements. For the 2 elements case, the
result is equivalent to computing a cubic polynomial whose values are
given by <code class="docutils literal notranslate"><span class="pre">samples</span></code>, and derivatives set to zero.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if</strong> – <ul>
<li><p><code class="docutils literal notranslate"><span class="pre">breaks</span></code> has length smaller than 3 and</p></li>
</ul>
</p></li>
<li><p><strong>zero_end_point_derivatives` is False</strong><strong>, </strong><strong>- breaks has lengt</strong> – </p></li>
<li><p><strong>smaller than 2 and zero_end_point_derivatives is true.</strong> – </p></li>
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial.CubicWithContinuousSecondDerivatives">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">CubicWithContinuousSecondDerivatives</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.CubicWithContinuousSecondDerivatives" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CubicWithContinuousSecondDerivatives(breaks: list[float], samples: list[list[float]], sample_dot_at_start: numpy.ndarray[numpy.float64[m, n]], sample_dot_at_end: numpy.ndarray[numpy.float64[m, n]]) -&gt; pydrake.trajectories.PiecewisePolynomial</p></li>
</ol>
<p>Version of CubicWithContinuousSecondDerivatives() that uses vector
samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each column of
<code class="docutils literal notranslate"><span class="pre">samples</span></code> represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>CubicWithContinuousSecondDerivatives(breaks: list[float], samples: list[numpy.ndarray[numpy.float64[m, n]]], sample_dot_at_start: numpy.ndarray[numpy.float64[m, n]], sample_dot_at_end: numpy.ndarray[numpy.float64[m, n]]) -&gt; pydrake.trajectories.PiecewisePolynomial</p></li>
</ol>
<p>Constructs a third order PiecewisePolynomial using matrix samples. The
PiecewisePolynomial is constructed such that the interior segments
have the same value, first and second derivatives at <code class="docutils literal notranslate"><span class="pre">breaks</span></code>.
<cite>sample_dot_at_start</cite> and <code class="docutils literal notranslate"><span class="pre">sample_dot_at_end</span></code> are used for the first
and last first derivatives.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if sample_dot_at_start</strong><strong> or </strong><strong>sample_dot_at_end</strong> – </p></li>
<li><p><strong>and samples have inconsistent dimensions.</strong> – </p></li>
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>CubicWithContinuousSecondDerivatives(breaks: list[float], samples: list[list[float]], periodic_end_condition: bool = False) -&gt; pydrake.trajectories.PiecewisePolynomial</p></li>
</ol>
<p>Version of CubicWithContinuousSecondDerivatives(breaks, samples) that
uses vector samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each
column of <code class="docutils literal notranslate"><span class="pre">samples</span></code> represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>CubicWithContinuousSecondDerivatives(breaks: list[float], samples: list[numpy.ndarray[numpy.float64[m, n]]], periodic_end: bool) -&gt; pydrake.trajectories.PiecewisePolynomial</p></li>
</ol>
<p>Constructs a third order PiecewisePolynomial using matrix samples. The
PiecewisePolynomial is constructed such that the interior segments
have the same value, first and second derivatives at <code class="docutils literal notranslate"><span class="pre">breaks</span></code>. If
<code class="docutils literal notranslate"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code> (default), then the
“Not-a-sample” end condition is used here, which means the third
derivatives are continuous for the first two and last two segments. If
<code class="docutils literal notranslate"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, then the first and second
derivatives between the end of the last segment and the beginning of
the first segment will be continuous. Note that the periodic end
condition does not require the first and last sample to be collocated,
nor does it add an additional sample to connect the first and last
segments. Only first and second derivative continuity is enforced. See
<a class="reference external" href="https://en.wikipedia.org/wiki/Spline_interpolation">https://en.wikipedia.org/wiki/Spline_interpolation</a> and
<a class="reference external" href="https://web.archive.org/web/20140125011904/https://www.math.uh.edu/~jingqiu/math4364/spline.pdf">https://web.archive.org/web/20140125011904/https://www.math.uh.edu/~jingqiu/math4364/spline.pdf</a>
for more about cubic splines and their end conditions. The MATLAB docs
for methods “spline” and “csape” are also good references.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">breaks</span></code> and <code class="docutils literal notranslate"><span class="pre">samples</span></code> must have at least 3 elements. If
<code class="docutils literal notranslate"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, then for two samples, it
would produce a straight line (use <code class="docutils literal notranslate"><span class="pre">FirstOrderHold</span></code> for this
instead), and if <code class="docutils literal notranslate"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code> the
problem is ill-defined.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial.derivative">
<span class="sig-name descname"><span class="pre">derivative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial" title="pydrake.trajectories.PiecewisePolynomial"><span class="pre">pydrake.trajectories.PiecewisePolynomial</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">derivative_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial" title="pydrake.trajectories.PiecewisePolynomial"><span class="pre">pydrake.trajectories.PiecewisePolynomial</span></a></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.derivative" title="Permalink to this definition"></a></dt>
<dd><p>Returns a PiecewisePolynomial where each segment is the specified
derivative of the corresponding segment in <code class="docutils literal notranslate"><span class="pre">this</span></code>. Any rules or
limitations of Polynomial::derivative() also apply to this function.</p>
<p>Derivatives evaluated at non-differentiable points return the value at
the left hand side of the interval.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code>:</dt><dd><p>The order of the derivative, namely, if <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code> = n,
the n’th derivative of the polynomial will be returned.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In the event of discontinuous derivatives evaluated at breaks, it
is not defined which polynomial (i.e., to the left or right of the
break) will be the one that is evaluated at the break.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial.FirstOrderHold">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">FirstOrderHold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.FirstOrderHold" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>FirstOrderHold(breaks: list[float], samples: list[list[float]]) -&gt; pydrake.trajectories.PiecewisePolynomial</p></li>
</ol>
<p>Version of FirstOrderHold(breaks, samples) that uses vector samples
and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each column of <code class="docutils literal notranslate"><span class="pre">samples</span></code>
represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>FirstOrderHold(breaks: list[float], samples: list[numpy.ndarray[numpy.float64[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial</p></li>
</ol>
<p>Constructs a piecewise linear PiecewisePolynomial using matrix
samples.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial.getPolynomial">
<span class="sig-name descname"><span class="pre">getPolynomial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial" title="pydrake.trajectories.PiecewisePolynomial"><span class="pre">pydrake.trajectories.PiecewisePolynomial</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.polynomial.html#pydrake.polynomial.Polynomial" title="pydrake.polynomial.Polynomial"><span class="pre">pydrake.polynomial.Polynomial</span></a></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.getPolynomial" title="Permalink to this definition"></a></dt>
<dd><p>Gets the Polynomial with the given matrix row and column index that
corresponds to the given segment index. Equivalent to
<code class="docutils literal notranslate"><span class="pre">getPolynomialMatrix(segment_index)(row,</span> <span class="pre">col)</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calls PiecewiseTrajectory&lt;T&gt;::segment_number_range_check() to
validate <code class="docutils literal notranslate"><span class="pre">segment_index</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial.getPolynomialMatrix">
<span class="sig-name descname"><span class="pre">getPolynomialMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial" title="pydrake.trajectories.PiecewisePolynomial"><span class="pre">pydrake.trajectories.PiecewisePolynomial</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.getPolynomialMatrix" title="Permalink to this definition"></a></dt>
<dd><p>Gets the matrix of Polynomials corresponding to the given segment
index.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><code class="docutils literal notranslate"><span class="pre">segment_index</span></code> is not checked for validity.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial.getSegmentPolynomialDegree">
<span class="sig-name descname"><span class="pre">getSegmentPolynomialDegree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial" title="pydrake.trajectories.PiecewisePolynomial"><span class="pre">pydrake.trajectories.PiecewisePolynomial</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.getSegmentPolynomialDegree" title="Permalink to this definition"></a></dt>
<dd><p>Gets the degree of the Polynomial with the given matrix row and column
index that corresponds to the given segment index. Equivalent to
<code class="docutils literal notranslate"><span class="pre">getPolynomial(segment_index,</span> <span class="pre">row,</span> <span class="pre">col).GetDegree()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial.isApprox">
<span class="sig-name descname"><span class="pre">isApprox</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol:</span> <span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol_type:</span> <span class="pre">pydrake.common.ToleranceType</span> <span class="pre">=</span> <span class="pre">&lt;ToleranceType.kRelative:</span> <span class="pre">1&gt;</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.isApprox" title="Permalink to this definition"></a></dt>
<dd><p>Checks whether a PiecewisePolynomial is approximately equal to this
one by calling Polynomial&lt;T&gt;::CoefficientsAlmostEqual() on every
element of every segment.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Polynomial&lt;T&gt;::CoefficientsAlmostEqual().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial.LagrangeInterpolatingPolynomial">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">LagrangeInterpolatingPolynomial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.LagrangeInterpolatingPolynomial" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>LagrangeInterpolatingPolynomial(times: list[float], samples: list[list[float]]) -&gt; pydrake.trajectories.PiecewisePolynomial</p></li>
</ol>
<p>Version of LagrangeInterpolatingPolynomial(times, samples) that uses
vector samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each column
of <code class="docutils literal notranslate"><span class="pre">samples</span></code> represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">times.size()</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>LagrangeInterpolatingPolynomial(times: list[float], samples: list[numpy.ndarray[numpy.float64[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial</p></li>
</ol>
<p>Constructs a polynomial with a <em>single segment</em> of the lowest possible
degree that passes through all of the sample points. See “polynomial
interpolation” and/or “Lagrange polynomial” on Wikipedia for more
information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">times</span></code> must be monotonically increasing.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.size()</span> <span class="pre">==</span> <span class="pre">times.size()</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial.RemoveFinalSegment">
<span class="sig-name descname"><span class="pre">RemoveFinalSegment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial" title="pydrake.trajectories.PiecewisePolynomial"><span class="pre">pydrake.trajectories.PiecewisePolynomial</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.RemoveFinalSegment" title="Permalink to this definition"></a></dt>
<dd><p>Removes the final segment from the trajectory, reducing the number of
segments by 1.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> is not empty()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial.Reshape">
<span class="sig-name descname"><span class="pre">Reshape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial" title="pydrake.trajectories.PiecewisePolynomial"><span class="pre">pydrake.trajectories.PiecewisePolynomial</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">rows</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cols</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.Reshape" title="Permalink to this definition"></a></dt>
<dd><p>Reshapes the dimensions of the Eigen::MatrixX&lt;T&gt; returned by value(),
EvalDerivative(), etc.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">rows</span></code> x <code class="docutils literal notranslate"><span class="pre">cols</span></code> must equal this.rows() * this.cols().</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Eigen::PlainObjectBase::resize().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial.ReverseTime">
<span class="sig-name descname"><span class="pre">ReverseTime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial" title="pydrake.trajectories.PiecewisePolynomial"><span class="pre">pydrake.trajectories.PiecewisePolynomial</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.ReverseTime" title="Permalink to this definition"></a></dt>
<dd><p>Modifies the trajectory so that pp_after(t) = pp_before(-t).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The new trajectory will evaluate differently at precisely the
break points if the original trajectory was discontinuous at the
break points. This is because the segments are defined on the
half-open intervals [breaks(i), breaks(i+1)), and the order of the
breaks have been reversed.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial.ScaleTime">
<span class="sig-name descname"><span class="pre">ScaleTime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial" title="pydrake.trajectories.PiecewisePolynomial"><span class="pre">pydrake.trajectories.PiecewisePolynomial</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.ScaleTime" title="Permalink to this definition"></a></dt>
<dd><p>Scales the time of the trajectory by non-negative <code class="docutils literal notranslate"><span class="pre">scale</span></code> (use
ReverseTime() if you want to also negate time). The resulting
polynomial evaluates to pp_after(t) = pp_before(t/scale).</p>
<p>As an example, <a href="#id7"><span class="problematic" id="id8">`</span></a>scale`=2 will result in a trajectory that is twice as
long (start_time() and end_time() have both doubled).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial.setPolynomialMatrixBlock">
<span class="sig-name descname"><span class="pre">setPolynomialMatrixBlock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial" title="pydrake.trajectories.PiecewisePolynomial"><span class="pre">pydrake.trajectories.PiecewisePolynomial</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">replacement</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row_start</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col_start</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.setPolynomialMatrixBlock" title="Permalink to this definition"></a></dt>
<dd><p>Replaces the specified block of the PolynomialMatrix at the given
segment index.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calls PiecewiseTrajectory&lt;T&gt;::segment_number_range_check() to
validate <code class="docutils literal notranslate"><span class="pre">segment_index</span></code>.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This code relies upon Eigen to verify that the replacement block
is not too large.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial.shiftRight">
<span class="sig-name descname"><span class="pre">shiftRight</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial" title="pydrake.trajectories.PiecewisePolynomial"><span class="pre">pydrake.trajectories.PiecewisePolynomial</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.shiftRight" title="Permalink to this definition"></a></dt>
<dd><p>Adds <code class="docutils literal notranslate"><span class="pre">offset</span></code> to all of the breaks. <code class="docutils literal notranslate"><span class="pre">offset</span></code> need not be a
non-negative number. The resulting polynomial will evaluate to
pp_after(t) = pp_before(t-offset).</p>
<p>As an example, <a href="#id9"><span class="problematic" id="id10">`</span></a>offset`=2 will result in the start_time() and
end_time() being 2 seconds later.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial.slice">
<span class="sig-name descname"><span class="pre">slice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial" title="pydrake.trajectories.PiecewisePolynomial"><span class="pre">pydrake.trajectories.PiecewisePolynomial</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_segments</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial" title="pydrake.trajectories.PiecewisePolynomial"><span class="pre">pydrake.trajectories.PiecewisePolynomial</span></a></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.slice" title="Permalink to this definition"></a></dt>
<dd><p>Returns the PiecewisePolynomial comprising the <code class="docutils literal notranslate"><span class="pre">num_segments</span></code>
segments starting at the specified <code class="docutils literal notranslate"><span class="pre">start_segment_index</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calls PiecewiseTrajectory&lt;T&gt;::segment_number_range_check() to
validate <code class="docutils literal notranslate"><span class="pre">segment_index</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial.Transpose">
<span class="sig-name descname"><span class="pre">Transpose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial" title="pydrake.trajectories.PiecewisePolynomial"><span class="pre">pydrake.trajectories.PiecewisePolynomial</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial" title="pydrake.trajectories.PiecewisePolynomial"><span class="pre">pydrake.trajectories.PiecewisePolynomial</span></a></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.Transpose" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a new PiecewisePolynomial for which value(t) ==
this.value(t).transpose().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial.ZeroOrderHold">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ZeroOrderHold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.ZeroOrderHold" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>ZeroOrderHold(breaks: list[float], samples: list[list[float]]) -&gt; pydrake.trajectories.PiecewisePolynomial</p></li>
</ol>
<p>Version of ZeroOrderHold(breaks, samples) that uses vector samples and
Eigen VectorXd/MatrixX&lt;T&gt; arguments. Each column of <code class="docutils literal notranslate"><span class="pre">samples</span></code>
represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>ZeroOrderHold(breaks: list[float], samples: list[numpy.ndarray[numpy.float64[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial</p></li>
</ol>
<p>Constructs a piecewise constant PiecewisePolynomial using matrix
samples. Note that constructing a PiecewisePolynomial requires at
least two sample points, although in this case, the second sample
point’s value is ignored, and only its break time is used.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PiecewisePolynomial_</span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewisePolynomial_[float]</span></code>, <a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd" title="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewisePolynomial_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_-Expression" title="pydrake.trajectories.PiecewisePolynomial_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewisePolynomial_[Expression]</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PiecewisePolynomial_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd" title="pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd]</span></code></a></p>
<p>A scalar multi-variate piecewise polynomial.</p>
<p>PiecewisePolynomial represents a list of contiguous segments in a
scalar independent variable (typically corresponding to time) with
Polynomials defined at each segment. We call the output from
evaluating the PiecewisePolynomial at the scalar independent variable
“the output”, and that output can be either a Eigen MatrixX&lt;T&gt; (if
evaluated using value()) or a scalar (if evaluated using
scalar_value()).</p>
<p>An example of a piecewise polynomial is a function of m segments in
time, where a different polynomial is defined for each segment. For a
specific example, consider the absolute value function over the
interval [-1, 1]. We can define a PiecewisePolynomial over this
interval using breaks at t = { -1.0, 0.0, 1.0 }, and “samples” of
abs(t).</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Construct the PiecewisePolynomial.</span>
<span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">breaks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">-1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span><span class="o">&gt;</span><span class="w"> </span><span class="n">samples</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">breaks</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">resize</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">breaks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">pp</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">     </span><span class="n">PiecewisePolynomial</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">FirstOrderHold</span><span class="p">(</span><span class="n">breaks</span><span class="p">,</span><span class="w"> </span><span class="n">samples</span><span class="p">);</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Evaluate the PiecewisePolynomial at some values.</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pp</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="mf">-.5</span><span class="p">)(</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w">    </span><span class="c1">// Outputs 0.5.</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pp</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)(</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w">    </span><span class="c1">// Outputs 0.0;</span>

<span class="c1">// Show how we can evaluate the first derivative (outputs -1.0).</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pp</span><span class="p">.</span><span class="n">derivative</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">value</span><span class="p">(</span><span class="mf">-.5</span><span class="p">)(</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</details><p>A note on terminology. For piecewise-polynomial interpolation, we use
<code class="docutils literal notranslate"><span class="pre">breaks</span></code> to indicate the scalar (e.g. times) which form the boundary
of each segment. We use <code class="docutils literal notranslate"><span class="pre">samples</span></code> to indicate the function value at
the <code class="docutils literal notranslate"><span class="pre">breaks</span></code>, e.g. <code class="docutils literal notranslate"><span class="pre">p(breaks[i])</span> <span class="pre">=</span> <span class="pre">samples[i]</span></code>. The term <code class="docutils literal notranslate"><span class="pre">knot</span></code>
should be reserved for the “(x,y)” coordinate, here <code class="docutils literal notranslate"><span class="pre">knot[i]</span> <span class="pre">=</span>
<span class="pre">(breaks[i],</span> <span class="pre">samples[i])</span></code>, though it is used inconsistently in the
interpolation literature (sometimes for <code class="docutils literal notranslate"><span class="pre">breaks</span></code>, sometimes for
<code class="docutils literal notranslate"><span class="pre">samples</span></code>), so we try to mostly avoid it here.</p>
<p>PiecewisePolynomial objects can be added, subtracted, and multiplied.
They cannot be divided because Polynomials are not closed under
division.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>PiecewisePolynomial silently clips input evaluations outside of
the range defined by the breaks. So <code class="docutils literal notranslate"><span class="pre">pp.value(-2.0,</span> <span class="pre">row,</span> <span class="pre">col)</span></code>
in the example above would evaluate to -1.0. See value().</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.__init__">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Constructs an empty piecewise polynomial.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd], arg0: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; None</p></li>
</ol>
<p>Single segment, constant value constructor over the interval [-∞, ∞].
The constructed PiecewisePolynomial will return <code class="docutils literal notranslate"><span class="pre">constant_value</span></code> at
every evaluated point (i.e., <code class="docutils literal notranslate"><span class="pre">value(t)</span> <span class="pre">=</span> <span class="pre">constant_value</span></code> ∀t ∈ [-∞,
∞]).</p>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd], arg0: list[numpy.ndarray[object[m, n]]], arg1: list[pydrake.autodiffutils.AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Constructs a PiecewisePolynomial using matrix-output Polynomials
defined over each segment.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">polynomials.size()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span> <span class="pre">-</span> <span class="pre">1</span></code></p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd], arg0: list[pydrake.polynomial.Polynomial_[AutoDiffXd]], arg1: list[pydrake.autodiffutils.AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Constructs a PiecewisePolynomial using scalar-output Polynomials
defined over each segment.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">polynomials.size()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span> <span class="pre">-</span> <span class="pre">1</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.AppendCubicHermiteSegment">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].AppendCubicHermiteSegment"></span><span class="sig-name descname"><span class="pre">AppendCubicHermiteSegment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_dot</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.AppendCubicHermiteSegment" title="Permalink to this definition"></a></dt>
<dd><p>The CubicHermite spline construction has a nice property of being
incremental (each segment can be solved independently). Given a new
sample and it’s derivative, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code> where the start sample and derivative are taken as the value
and derivative at the final break of <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> is not empty()</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">time</span></code> &gt; end_time()</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">sample</span></code> and <code class="docutils literal notranslate"><span class="pre">sample_dot</span></code> must have size rows() x cols().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.AppendFirstOrderSegment">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].AppendFirstOrderSegment"></span><span class="sig-name descname"><span class="pre">AppendFirstOrderSegment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.AppendFirstOrderSegment" title="Permalink to this definition"></a></dt>
<dd><p>Given a new sample, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code> using a first-order hold, where the start sample is taken as
the value at the final break of <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.Block">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].Block"></span><span class="sig-name descname"><span class="pre">Block</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_row</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_rows</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_cols</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.Block" title="Permalink to this definition"></a></dt>
<dd><p>Extracts a trajectory representing a block of size (block_rows,
block_cols) starting at (start_row, start_col) from the
PiecewisePolynomial.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a PiecewisePolynomial such that ret.value(t) =
this.value(t).block(i,j,p,q);</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.ConcatenateInTime">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].ConcatenateInTime"></span><span class="sig-name descname"><span class="pre">ConcatenateInTime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.ConcatenateInTime" title="Permalink to this definition"></a></dt>
<dd><p>Concatenates <code class="docutils literal notranslate"><span class="pre">other</span></code> to the end of <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The resulting PiecewisePolynomial will only be continuous to the
degree that the first Polynomial of <code class="docutils literal notranslate"><span class="pre">other</span></code> is continuous with
the last Polynomial of <code class="docutils literal notranslate"><span class="pre">this</span></code>. See warning about evaluating
discontinuous derivatives at breaks in derivative().</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other</span></code>:</dt><dd><p>PiecewisePolynomial instance to concatenate.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if trajectories' dimensions do not match each other</strong> – </p></li>
<li><p><strong>(</strong><strong>either rows</strong><strong>(</strong><strong>) or </strong><strong>cols</strong><strong>(</strong><strong>) </strong><strong>does not match between this and</strong> – </p></li>
<li><p><strong>other`</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if this-&gt;end_time</strong><strong>(</strong><strong>) </strong><strong>and other-&gt;start_time</strong><strong>(</strong><strong>)</strong> – </p></li>
<li><p><strong>are not within PiecewiseTrajectory&lt;T&gt;::kEpsilonTime from each</strong> – </p></li>
<li><p><strong>other.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.CubicHermite">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].CubicHermite"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">CubicHermite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.CubicHermite" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CubicHermite(breaks: list[pydrake.autodiffutils.AutoDiffXd], samples: list[list[pydrake.autodiffutils.AutoDiffXd]], samples_dot: list[list[pydrake.autodiffutils.AutoDiffXd]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</p></li>
</ol>
<p>Version of CubicHermite(breaks, samples, samples_dot) that uses vector
samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Corresponding
columns of <code class="docutils literal notranslate"><span class="pre">samples</span></code> and <code class="docutils literal notranslate"><span class="pre">samples_dot</span></code> are used as the sample
point and independent variable derivative, respectively.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">samples_dot.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>CubicHermite(breaks: list[pydrake.autodiffutils.AutoDiffXd], samples: list[numpy.ndarray[object[m, n]]], samples_dot: list[numpy.ndarray[object[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</p></li>
</ol>
<p>Constructs a third order PiecewisePolynomial using matrix samples and
derivatives of samples (<code class="docutils literal notranslate"><span class="pre">samples_dot</span></code>); each matrix element of
<code class="docutils literal notranslate"><span class="pre">samples_dot</span></code> represents the derivative with respect to the
independent variable (e.g., the time derivative) of the corresponding
entry in <code class="docutils literal notranslate"><span class="pre">samples</span></code>. Each segment is fully specified by <code class="docutils literal notranslate"><span class="pre">samples</span></code>
and <code class="docutils literal notranslate"><span class="pre">sample_dot</span></code> at both ends. Second derivatives are not
continuous.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.CubicShapePreserving">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].CubicShapePreserving"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">CubicShapePreserving</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.CubicShapePreserving" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CubicShapePreserving(breaks: list[pydrake.autodiffutils.AutoDiffXd], samples: list[list[pydrake.autodiffutils.AutoDiffXd]], zero_end_point_derivatives: bool = False) -&gt; pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</p></li>
</ol>
<p>Version of CubicShapePreserving(breaks, samples,
zero_end_point_derivatives) that uses vector samples and Eigen
VectorXd and MatrixX&lt;T&gt; arguments. Each column of <code class="docutils literal notranslate"><span class="pre">samples</span></code>
represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>CubicShapePreserving(breaks: list[pydrake.autodiffutils.AutoDiffXd], samples: list[numpy.ndarray[object[m, n]]], zero_end_point_derivatives: bool = False) -&gt; pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</p></li>
</ol>
<p>Constructs a third order PiecewisePolynomial using vector samples,
where each column of <code class="docutils literal notranslate"><span class="pre">samples</span></code> represents a sample point. First
derivatives are chosen to be “shape preserving”, i.e. if <code class="docutils literal notranslate"><span class="pre">samples</span></code>
is monotonic within some interval, the interpolated data will also be
monotonic. The second derivative is not guaranteed to be smooth across
the entire spline.</p>
<p>MATLAB calls this method “pchip” (short for “Piecewise Cubic Hermite
Interpolating Polynomial”), and provides a nice description in their
documentation.
<a class="reference external" href="http://home.uchicago.edu/~sctchoi/courses/cs138/interp.pdf">http://home.uchicago.edu/~sctchoi/courses/cs138/interp.pdf</a> is also a
good reference.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, the first and last
first derivative is chosen using a non-centered, shape-preserving
three-point formulae. See equation (2.10) in the following reference
for more details. <a class="reference external" href="http://www.mi.sanu.ac.rs/~gvm/radovi/mon.pdf">http://www.mi.sanu.ac.rs/~gvm/radovi/mon.pdf</a> If
<code class="docutils literal notranslate"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, they are set to zeros.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, <cite>breaks</cite> and
<code class="docutils literal notranslate"><span class="pre">samples</span></code> must have at least 3 elements for the algorithm to
determine the first derivatives.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, <cite>breaks</cite> and
<code class="docutils literal notranslate"><span class="pre">samples</span></code> may have 2 or more elements. For the 2 elements case, the
result is equivalent to computing a cubic polynomial whose values are
given by <code class="docutils literal notranslate"><span class="pre">samples</span></code>, and derivatives set to zero.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if</strong> – <ul>
<li><p><code class="docutils literal notranslate"><span class="pre">breaks</span></code> has length smaller than 3 and</p></li>
</ul>
</p></li>
<li><p><strong>zero_end_point_derivatives` is False</strong><strong>, </strong><strong>- breaks has lengt</strong> – </p></li>
<li><p><strong>smaller than 2 and zero_end_point_derivatives is true.</strong> – </p></li>
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.CubicWithContinuousSecondDerivatives">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].CubicWithContinuousSecondDerivatives"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">CubicWithContinuousSecondDerivatives</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.CubicWithContinuousSecondDerivatives" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CubicWithContinuousSecondDerivatives(breaks: list[pydrake.autodiffutils.AutoDiffXd], samples: list[list[pydrake.autodiffutils.AutoDiffXd]], sample_dot_at_start: numpy.ndarray[object[m, n]], sample_dot_at_end: numpy.ndarray[object[m, n]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</p></li>
</ol>
<p>Version of CubicWithContinuousSecondDerivatives() that uses vector
samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each column of
<code class="docutils literal notranslate"><span class="pre">samples</span></code> represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>CubicWithContinuousSecondDerivatives(breaks: list[pydrake.autodiffutils.AutoDiffXd], samples: list[numpy.ndarray[object[m, n]]], sample_dot_at_start: numpy.ndarray[object[m, n]], sample_dot_at_end: numpy.ndarray[object[m, n]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</p></li>
</ol>
<p>Constructs a third order PiecewisePolynomial using matrix samples. The
PiecewisePolynomial is constructed such that the interior segments
have the same value, first and second derivatives at <code class="docutils literal notranslate"><span class="pre">breaks</span></code>.
<cite>sample_dot_at_start</cite> and <code class="docutils literal notranslate"><span class="pre">sample_dot_at_end</span></code> are used for the first
and last first derivatives.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if sample_dot_at_start</strong><strong> or </strong><strong>sample_dot_at_end</strong> – </p></li>
<li><p><strong>and samples have inconsistent dimensions.</strong> – </p></li>
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>CubicWithContinuousSecondDerivatives(breaks: list[pydrake.autodiffutils.AutoDiffXd], samples: list[list[pydrake.autodiffutils.AutoDiffXd]], periodic_end_condition: bool = False) -&gt; pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</p></li>
</ol>
<p>Version of CubicWithContinuousSecondDerivatives(breaks, samples) that
uses vector samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each
column of <code class="docutils literal notranslate"><span class="pre">samples</span></code> represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>CubicWithContinuousSecondDerivatives(breaks: list[pydrake.autodiffutils.AutoDiffXd], samples: list[numpy.ndarray[object[m, n]]], periodic_end: bool) -&gt; pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</p></li>
</ol>
<p>Constructs a third order PiecewisePolynomial using matrix samples. The
PiecewisePolynomial is constructed such that the interior segments
have the same value, first and second derivatives at <code class="docutils literal notranslate"><span class="pre">breaks</span></code>. If
<code class="docutils literal notranslate"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code> (default), then the
“Not-a-sample” end condition is used here, which means the third
derivatives are continuous for the first two and last two segments. If
<code class="docutils literal notranslate"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, then the first and second
derivatives between the end of the last segment and the beginning of
the first segment will be continuous. Note that the periodic end
condition does not require the first and last sample to be collocated,
nor does it add an additional sample to connect the first and last
segments. Only first and second derivative continuity is enforced. See
<a class="reference external" href="https://en.wikipedia.org/wiki/Spline_interpolation">https://en.wikipedia.org/wiki/Spline_interpolation</a> and
<a class="reference external" href="https://web.archive.org/web/20140125011904/https://www.math.uh.edu/~jingqiu/math4364/spline.pdf">https://web.archive.org/web/20140125011904/https://www.math.uh.edu/~jingqiu/math4364/spline.pdf</a>
for more about cubic splines and their end conditions. The MATLAB docs
for methods “spline” and “csape” are also good references.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">breaks</span></code> and <code class="docutils literal notranslate"><span class="pre">samples</span></code> must have at least 3 elements. If
<code class="docutils literal notranslate"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, then for two samples, it
would produce a straight line (use <code class="docutils literal notranslate"><span class="pre">FirstOrderHold</span></code> for this
instead), and if <code class="docutils literal notranslate"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code> the
problem is ill-defined.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.derivative">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].derivative"></span><span class="sig-name descname"><span class="pre">derivative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derivative_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.derivative" title="Permalink to this definition"></a></dt>
<dd><p>Returns a PiecewisePolynomial where each segment is the specified
derivative of the corresponding segment in <code class="docutils literal notranslate"><span class="pre">this</span></code>. Any rules or
limitations of Polynomial::derivative() also apply to this function.</p>
<p>Derivatives evaluated at non-differentiable points return the value at
the left hand side of the interval.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code>:</dt><dd><p>The order of the derivative, namely, if <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code> = n,
the n’th derivative of the polynomial will be returned.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In the event of discontinuous derivatives evaluated at breaks, it
is not defined which polynomial (i.e., to the left or right of the
break) will be the one that is evaluated at the break.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.FirstOrderHold">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].FirstOrderHold"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">FirstOrderHold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.FirstOrderHold" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>FirstOrderHold(breaks: list[pydrake.autodiffutils.AutoDiffXd], samples: list[list[pydrake.autodiffutils.AutoDiffXd]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</p></li>
</ol>
<p>Version of FirstOrderHold(breaks, samples) that uses vector samples
and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each column of <code class="docutils literal notranslate"><span class="pre">samples</span></code>
represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>FirstOrderHold(breaks: list[pydrake.autodiffutils.AutoDiffXd], samples: list[numpy.ndarray[object[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</p></li>
</ol>
<p>Constructs a piecewise linear PiecewisePolynomial using matrix
samples.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.getPolynomial">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].getPolynomial"></span><span class="sig-name descname"><span class="pre">getPolynomial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.polynomial.html#pydrake.polynomial.Polynomial_" title="pydrake.polynomial.Polynomial_"><span class="pre">pydrake.polynomial.Polynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.getPolynomial" title="Permalink to this definition"></a></dt>
<dd><p>Gets the Polynomial with the given matrix row and column index that
corresponds to the given segment index. Equivalent to
<code class="docutils literal notranslate"><span class="pre">getPolynomialMatrix(segment_index)(row,</span> <span class="pre">col)</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calls PiecewiseTrajectory&lt;T&gt;::segment_number_range_check() to
validate <code class="docutils literal notranslate"><span class="pre">segment_index</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.getPolynomialMatrix">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].getPolynomialMatrix"></span><span class="sig-name descname"><span class="pre">getPolynomialMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.getPolynomialMatrix" title="Permalink to this definition"></a></dt>
<dd><p>Gets the matrix of Polynomials corresponding to the given segment
index.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><code class="docutils literal notranslate"><span class="pre">segment_index</span></code> is not checked for validity.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.getSegmentPolynomialDegree">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].getSegmentPolynomialDegree"></span><span class="sig-name descname"><span class="pre">getSegmentPolynomialDegree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.getSegmentPolynomialDegree" title="Permalink to this definition"></a></dt>
<dd><p>Gets the degree of the Polynomial with the given matrix row and column
index that corresponds to the given segment index. Equivalent to
<code class="docutils literal notranslate"><span class="pre">getPolynomial(segment_index,</span> <span class="pre">row,</span> <span class="pre">col).GetDegree()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.isApprox">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].isApprox"></span><span class="sig-name descname"><span class="pre">isApprox</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd],</span> <span class="pre">other:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd],</span> <span class="pre">tol:</span> <span class="pre">float,</span> <span class="pre">tol_type:</span> <span class="pre">pydrake.common.ToleranceType</span> <span class="pre">=</span> <span class="pre">&lt;ToleranceType.kRelative:</span> <span class="pre">1&gt;</span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.isApprox" title="Permalink to this definition"></a></dt>
<dd><p>Checks whether a PiecewisePolynomial is approximately equal to this
one by calling Polynomial&lt;T&gt;::CoefficientsAlmostEqual() on every
element of every segment.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Polynomial&lt;T&gt;::CoefficientsAlmostEqual().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.LagrangeInterpolatingPolynomial">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].LagrangeInterpolatingPolynomial"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">LagrangeInterpolatingPolynomial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.LagrangeInterpolatingPolynomial" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>LagrangeInterpolatingPolynomial(times: list[pydrake.autodiffutils.AutoDiffXd], samples: list[list[pydrake.autodiffutils.AutoDiffXd]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</p></li>
</ol>
<p>Version of LagrangeInterpolatingPolynomial(times, samples) that uses
vector samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each column
of <code class="docutils literal notranslate"><span class="pre">samples</span></code> represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">times.size()</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>LagrangeInterpolatingPolynomial(times: list[pydrake.autodiffutils.AutoDiffXd], samples: list[numpy.ndarray[object[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</p></li>
</ol>
<p>Constructs a polynomial with a <em>single segment</em> of the lowest possible
degree that passes through all of the sample points. See “polynomial
interpolation” and/or “Lagrange polynomial” on Wikipedia for more
information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">times</span></code> must be monotonically increasing.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.size()</span> <span class="pre">==</span> <span class="pre">times.size()</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.RemoveFinalSegment">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].RemoveFinalSegment"></span><span class="sig-name descname"><span class="pre">RemoveFinalSegment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.RemoveFinalSegment" title="Permalink to this definition"></a></dt>
<dd><p>Removes the final segment from the trajectory, reducing the number of
segments by 1.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> is not empty()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.Reshape">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].Reshape"></span><span class="sig-name descname"><span class="pre">Reshape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rows</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cols</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.Reshape" title="Permalink to this definition"></a></dt>
<dd><p>Reshapes the dimensions of the Eigen::MatrixX&lt;T&gt; returned by value(),
EvalDerivative(), etc.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">rows</span></code> x <code class="docutils literal notranslate"><span class="pre">cols</span></code> must equal this.rows() * this.cols().</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Eigen::PlainObjectBase::resize().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.ReverseTime">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].ReverseTime"></span><span class="sig-name descname"><span class="pre">ReverseTime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.ReverseTime" title="Permalink to this definition"></a></dt>
<dd><p>Modifies the trajectory so that pp_after(t) = pp_before(-t).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The new trajectory will evaluate differently at precisely the
break points if the original trajectory was discontinuous at the
break points. This is because the segments are defined on the
half-open intervals [breaks(i), breaks(i+1)), and the order of the
breaks have been reversed.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.ScaleTime">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].ScaleTime"></span><span class="sig-name descname"><span class="pre">ScaleTime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.ScaleTime" title="Permalink to this definition"></a></dt>
<dd><p>Scales the time of the trajectory by non-negative <code class="docutils literal notranslate"><span class="pre">scale</span></code> (use
ReverseTime() if you want to also negate time). The resulting
polynomial evaluates to pp_after(t) = pp_before(t/scale).</p>
<p>As an example, <a href="#id11"><span class="problematic" id="id12">`</span></a>scale`=2 will result in a trajectory that is twice as
long (start_time() and end_time() have both doubled).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.setPolynomialMatrixBlock">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].setPolynomialMatrixBlock"></span><span class="sig-name descname"><span class="pre">setPolynomialMatrixBlock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">replacement</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row_start</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col_start</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.setPolynomialMatrixBlock" title="Permalink to this definition"></a></dt>
<dd><p>Replaces the specified block of the PolynomialMatrix at the given
segment index.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calls PiecewiseTrajectory&lt;T&gt;::segment_number_range_check() to
validate <code class="docutils literal notranslate"><span class="pre">segment_index</span></code>.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This code relies upon Eigen to verify that the replacement block
is not too large.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.shiftRight">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].shiftRight"></span><span class="sig-name descname"><span class="pre">shiftRight</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.shiftRight" title="Permalink to this definition"></a></dt>
<dd><p>Adds <code class="docutils literal notranslate"><span class="pre">offset</span></code> to all of the breaks. <code class="docutils literal notranslate"><span class="pre">offset</span></code> need not be a
non-negative number. The resulting polynomial will evaluate to
pp_after(t) = pp_before(t-offset).</p>
<p>As an example, <a href="#id13"><span class="problematic" id="id14">`</span></a>offset`=2 will result in the start_time() and
end_time() being 2 seconds later.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.slice">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].slice"></span><span class="sig-name descname"><span class="pre">slice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_segments</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.slice" title="Permalink to this definition"></a></dt>
<dd><p>Returns the PiecewisePolynomial comprising the <code class="docutils literal notranslate"><span class="pre">num_segments</span></code>
segments starting at the specified <code class="docutils literal notranslate"><span class="pre">start_segment_index</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calls PiecewiseTrajectory&lt;T&gt;::segment_number_range_check() to
validate <code class="docutils literal notranslate"><span class="pre">segment_index</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.Transpose">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].Transpose"></span><span class="sig-name descname"><span class="pre">Transpose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.Transpose" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a new PiecewisePolynomial for which value(t) ==
this.value(t).transpose().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.ZeroOrderHold">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].ZeroOrderHold"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ZeroOrderHold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.ZeroOrderHold" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>ZeroOrderHold(breaks: list[pydrake.autodiffutils.AutoDiffXd], samples: list[list[pydrake.autodiffutils.AutoDiffXd]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</p></li>
</ol>
<p>Version of ZeroOrderHold(breaks, samples) that uses vector samples and
Eigen VectorXd/MatrixX&lt;T&gt; arguments. Each column of <code class="docutils literal notranslate"><span class="pre">samples</span></code>
represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>ZeroOrderHold(breaks: list[pydrake.autodiffutils.AutoDiffXd], samples: list[numpy.ndarray[object[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</p></li>
</ol>
<p>Constructs a piecewise constant PiecewisePolynomial using matrix
samples. Note that constructing a PiecewisePolynomial requires at
least two sample points, although in this case, the second sample
point’s value is ignored, and only its break time is used.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PiecewisePolynomial_[Expression]</span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_-Expression" title="pydrake.trajectories.PiecewiseTrajectory_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_[Expression]</span></code></a></p>
<p>A scalar multi-variate piecewise polynomial.</p>
<p>PiecewisePolynomial represents a list of contiguous segments in a
scalar independent variable (typically corresponding to time) with
Polynomials defined at each segment. We call the output from
evaluating the PiecewisePolynomial at the scalar independent variable
“the output”, and that output can be either a Eigen MatrixX&lt;T&gt; (if
evaluated using value()) or a scalar (if evaluated using
scalar_value()).</p>
<p>An example of a piecewise polynomial is a function of m segments in
time, where a different polynomial is defined for each segment. For a
specific example, consider the absolute value function over the
interval [-1, 1]. We can define a PiecewisePolynomial over this
interval using breaks at t = { -1.0, 0.0, 1.0 }, and “samples” of
abs(t).</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Construct the PiecewisePolynomial.</span>
<span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">breaks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">-1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="p">};</span><span class="w"></span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span><span class="o">&gt;</span><span class="w"> </span><span class="n">samples</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">breaks</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">  </span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">resize</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">  </span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">breaks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">pp</span><span class="w"> </span><span class="o">=</span><span class="w"></span>
<span class="w">     </span><span class="n">PiecewisePolynomial</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">FirstOrderHold</span><span class="p">(</span><span class="n">breaks</span><span class="p">,</span><span class="w"> </span><span class="n">samples</span><span class="p">);</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="c1">// Evaluate the PiecewisePolynomial at some values.</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pp</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="mf">-.5</span><span class="p">)(</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w">    </span><span class="c1">// Outputs 0.5.</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pp</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)(</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w">    </span><span class="c1">// Outputs 0.0;</span>

<span class="c1">// Show how we can evaluate the first derivative (outputs -1.0).</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pp</span><span class="p">.</span><span class="n">derivative</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">value</span><span class="p">(</span><span class="mf">-.5</span><span class="p">)(</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w"></span>
</pre></div>
</div>
</details><p>A note on terminology. For piecewise-polynomial interpolation, we use
<code class="docutils literal notranslate"><span class="pre">breaks</span></code> to indicate the scalar (e.g. times) which form the boundary
of each segment. We use <code class="docutils literal notranslate"><span class="pre">samples</span></code> to indicate the function value at
the <code class="docutils literal notranslate"><span class="pre">breaks</span></code>, e.g. <code class="docutils literal notranslate"><span class="pre">p(breaks[i])</span> <span class="pre">=</span> <span class="pre">samples[i]</span></code>. The term <code class="docutils literal notranslate"><span class="pre">knot</span></code>
should be reserved for the “(x,y)” coordinate, here <code class="docutils literal notranslate"><span class="pre">knot[i]</span> <span class="pre">=</span>
<span class="pre">(breaks[i],</span> <span class="pre">samples[i])</span></code>, though it is used inconsistently in the
interpolation literature (sometimes for <code class="docutils literal notranslate"><span class="pre">breaks</span></code>, sometimes for
<code class="docutils literal notranslate"><span class="pre">samples</span></code>), so we try to mostly avoid it here.</p>
<p>PiecewisePolynomial objects can be added, subtracted, and multiplied.
They cannot be divided because Polynomials are not closed under
division.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>PiecewisePolynomial silently clips input evaluations outside of
the range defined by the breaks. So <code class="docutils literal notranslate"><span class="pre">pp.value(-2.0,</span> <span class="pre">row,</span> <span class="pre">col)</span></code>
in the example above would evaluate to -1.0. See value().</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.__init__">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.PiecewisePolynomial_[Expression]) -&gt; None</p></li>
</ol>
<p>Constructs an empty piecewise polynomial.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.trajectories.PiecewisePolynomial_[Expression], arg0: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; None</p></li>
</ol>
<p>Single segment, constant value constructor over the interval [-∞, ∞].
The constructed PiecewisePolynomial will return <code class="docutils literal notranslate"><span class="pre">constant_value</span></code> at
every evaluated point (i.e., <code class="docutils literal notranslate"><span class="pre">value(t)</span> <span class="pre">=</span> <span class="pre">constant_value</span></code> ∀t ∈ [-∞,
∞]).</p>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.trajectories.PiecewisePolynomial_[Expression], arg0: list[numpy.ndarray[object[m, n]]], arg1: list[pydrake.symbolic.Expression]) -&gt; None</p></li>
</ol>
<p>Constructs a PiecewisePolynomial using matrix-output Polynomials
defined over each segment.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">polynomials.size()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span> <span class="pre">-</span> <span class="pre">1</span></code></p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.trajectories.PiecewisePolynomial_[Expression], arg0: list[pydrake.polynomial.Polynomial_[Expression]], arg1: list[pydrake.symbolic.Expression]) -&gt; None</p></li>
</ol>
<p>Constructs a PiecewisePolynomial using scalar-output Polynomials
defined over each segment.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">polynomials.size()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span> <span class="pre">-</span> <span class="pre">1</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.AppendCubicHermiteSegment">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].AppendCubicHermiteSegment"></span><span class="sig-name descname"><span class="pre">AppendCubicHermiteSegment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_dot</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.AppendCubicHermiteSegment" title="Permalink to this definition"></a></dt>
<dd><p>The CubicHermite spline construction has a nice property of being
incremental (each segment can be solved independently). Given a new
sample and it’s derivative, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code> where the start sample and derivative are taken as the value
and derivative at the final break of <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> is not empty()</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">time</span></code> &gt; end_time()</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">sample</span></code> and <code class="docutils literal notranslate"><span class="pre">sample_dot</span></code> must have size rows() x cols().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.AppendFirstOrderSegment">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].AppendFirstOrderSegment"></span><span class="sig-name descname"><span class="pre">AppendFirstOrderSegment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.AppendFirstOrderSegment" title="Permalink to this definition"></a></dt>
<dd><p>Given a new sample, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code> using a first-order hold, where the start sample is taken as
the value at the final break of <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.Block">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].Block"></span><span class="sig-name descname"><span class="pre">Block</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_row</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_rows</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_cols</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.Block" title="Permalink to this definition"></a></dt>
<dd><p>Extracts a trajectory representing a block of size (block_rows,
block_cols) starting at (start_row, start_col) from the
PiecewisePolynomial.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a PiecewisePolynomial such that ret.value(t) =
this.value(t).block(i,j,p,q);</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.ConcatenateInTime">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].ConcatenateInTime"></span><span class="sig-name descname"><span class="pre">ConcatenateInTime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.ConcatenateInTime" title="Permalink to this definition"></a></dt>
<dd><p>Concatenates <code class="docutils literal notranslate"><span class="pre">other</span></code> to the end of <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The resulting PiecewisePolynomial will only be continuous to the
degree that the first Polynomial of <code class="docutils literal notranslate"><span class="pre">other</span></code> is continuous with
the last Polynomial of <code class="docutils literal notranslate"><span class="pre">this</span></code>. See warning about evaluating
discontinuous derivatives at breaks in derivative().</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other</span></code>:</dt><dd><p>PiecewisePolynomial instance to concatenate.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if trajectories' dimensions do not match each other</strong> – </p></li>
<li><p><strong>(</strong><strong>either rows</strong><strong>(</strong><strong>) or </strong><strong>cols</strong><strong>(</strong><strong>) </strong><strong>does not match between this and</strong> – </p></li>
<li><p><strong>other`</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if this-&gt;end_time</strong><strong>(</strong><strong>) </strong><strong>and other-&gt;start_time</strong><strong>(</strong><strong>)</strong> – </p></li>
<li><p><strong>are not within PiecewiseTrajectory&lt;T&gt;::kEpsilonTime from each</strong> – </p></li>
<li><p><strong>other.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.CubicHermite">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].CubicHermite"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">CubicHermite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.CubicHermite" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CubicHermite(breaks: list[pydrake.symbolic.Expression], samples: list[list[pydrake.symbolic.Expression]], samples_dot: list[list[pydrake.symbolic.Expression]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[Expression]</p></li>
</ol>
<p>Version of CubicHermite(breaks, samples, samples_dot) that uses vector
samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Corresponding
columns of <code class="docutils literal notranslate"><span class="pre">samples</span></code> and <code class="docutils literal notranslate"><span class="pre">samples_dot</span></code> are used as the sample
point and independent variable derivative, respectively.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">samples_dot.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>CubicHermite(breaks: list[pydrake.symbolic.Expression], samples: list[numpy.ndarray[object[m, n]]], samples_dot: list[numpy.ndarray[object[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[Expression]</p></li>
</ol>
<p>Constructs a third order PiecewisePolynomial using matrix samples and
derivatives of samples (<code class="docutils literal notranslate"><span class="pre">samples_dot</span></code>); each matrix element of
<code class="docutils literal notranslate"><span class="pre">samples_dot</span></code> represents the derivative with respect to the
independent variable (e.g., the time derivative) of the corresponding
entry in <code class="docutils literal notranslate"><span class="pre">samples</span></code>. Each segment is fully specified by <code class="docutils literal notranslate"><span class="pre">samples</span></code>
and <code class="docutils literal notranslate"><span class="pre">sample_dot</span></code> at both ends. Second derivatives are not
continuous.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.CubicShapePreserving">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].CubicShapePreserving"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">CubicShapePreserving</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.CubicShapePreserving" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CubicShapePreserving(breaks: list[pydrake.symbolic.Expression], samples: list[list[pydrake.symbolic.Expression]], zero_end_point_derivatives: bool = False) -&gt; pydrake.trajectories.PiecewisePolynomial_[Expression]</p></li>
</ol>
<p>Version of CubicShapePreserving(breaks, samples,
zero_end_point_derivatives) that uses vector samples and Eigen
VectorXd and MatrixX&lt;T&gt; arguments. Each column of <code class="docutils literal notranslate"><span class="pre">samples</span></code>
represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>CubicShapePreserving(breaks: list[pydrake.symbolic.Expression], samples: list[numpy.ndarray[object[m, n]]], zero_end_point_derivatives: bool = False) -&gt; pydrake.trajectories.PiecewisePolynomial_[Expression]</p></li>
</ol>
<p>Constructs a third order PiecewisePolynomial using vector samples,
where each column of <code class="docutils literal notranslate"><span class="pre">samples</span></code> represents a sample point. First
derivatives are chosen to be “shape preserving”, i.e. if <code class="docutils literal notranslate"><span class="pre">samples</span></code>
is monotonic within some interval, the interpolated data will also be
monotonic. The second derivative is not guaranteed to be smooth across
the entire spline.</p>
<p>MATLAB calls this method “pchip” (short for “Piecewise Cubic Hermite
Interpolating Polynomial”), and provides a nice description in their
documentation.
<a class="reference external" href="http://home.uchicago.edu/~sctchoi/courses/cs138/interp.pdf">http://home.uchicago.edu/~sctchoi/courses/cs138/interp.pdf</a> is also a
good reference.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, the first and last
first derivative is chosen using a non-centered, shape-preserving
three-point formulae. See equation (2.10) in the following reference
for more details. <a class="reference external" href="http://www.mi.sanu.ac.rs/~gvm/radovi/mon.pdf">http://www.mi.sanu.ac.rs/~gvm/radovi/mon.pdf</a> If
<code class="docutils literal notranslate"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, they are set to zeros.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, <cite>breaks</cite> and
<code class="docutils literal notranslate"><span class="pre">samples</span></code> must have at least 3 elements for the algorithm to
determine the first derivatives.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, <cite>breaks</cite> and
<code class="docutils literal notranslate"><span class="pre">samples</span></code> may have 2 or more elements. For the 2 elements case, the
result is equivalent to computing a cubic polynomial whose values are
given by <code class="docutils literal notranslate"><span class="pre">samples</span></code>, and derivatives set to zero.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if</strong> – <ul>
<li><p><code class="docutils literal notranslate"><span class="pre">breaks</span></code> has length smaller than 3 and</p></li>
</ul>
</p></li>
<li><p><strong>zero_end_point_derivatives` is False</strong><strong>, </strong><strong>- breaks has lengt</strong> – </p></li>
<li><p><strong>smaller than 2 and zero_end_point_derivatives is true.</strong> – </p></li>
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.CubicWithContinuousSecondDerivatives">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].CubicWithContinuousSecondDerivatives"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">CubicWithContinuousSecondDerivatives</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.CubicWithContinuousSecondDerivatives" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CubicWithContinuousSecondDerivatives(breaks: list[pydrake.symbolic.Expression], samples: list[list[pydrake.symbolic.Expression]], sample_dot_at_start: numpy.ndarray[object[m, n]], sample_dot_at_end: numpy.ndarray[object[m, n]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[Expression]</p></li>
</ol>
<p>Version of CubicWithContinuousSecondDerivatives() that uses vector
samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each column of
<code class="docutils literal notranslate"><span class="pre">samples</span></code> represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>CubicWithContinuousSecondDerivatives(breaks: list[pydrake.symbolic.Expression], samples: list[numpy.ndarray[object[m, n]]], sample_dot_at_start: numpy.ndarray[object[m, n]], sample_dot_at_end: numpy.ndarray[object[m, n]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[Expression]</p></li>
</ol>
<p>Constructs a third order PiecewisePolynomial using matrix samples. The
PiecewisePolynomial is constructed such that the interior segments
have the same value, first and second derivatives at <code class="docutils literal notranslate"><span class="pre">breaks</span></code>.
<cite>sample_dot_at_start</cite> and <code class="docutils literal notranslate"><span class="pre">sample_dot_at_end</span></code> are used for the first
and last first derivatives.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if sample_dot_at_start</strong><strong> or </strong><strong>sample_dot_at_end</strong> – </p></li>
<li><p><strong>and samples have inconsistent dimensions.</strong> – </p></li>
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>CubicWithContinuousSecondDerivatives(breaks: list[pydrake.symbolic.Expression], samples: list[list[pydrake.symbolic.Expression]], periodic_end_condition: bool = False) -&gt; pydrake.trajectories.PiecewisePolynomial_[Expression]</p></li>
</ol>
<p>Version of CubicWithContinuousSecondDerivatives(breaks, samples) that
uses vector samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each
column of <code class="docutils literal notranslate"><span class="pre">samples</span></code> represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>CubicWithContinuousSecondDerivatives(breaks: list[pydrake.symbolic.Expression], samples: list[numpy.ndarray[object[m, n]]], periodic_end: bool) -&gt; pydrake.trajectories.PiecewisePolynomial_[Expression]</p></li>
</ol>
<p>Constructs a third order PiecewisePolynomial using matrix samples. The
PiecewisePolynomial is constructed such that the interior segments
have the same value, first and second derivatives at <code class="docutils literal notranslate"><span class="pre">breaks</span></code>. If
<code class="docutils literal notranslate"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code> (default), then the
“Not-a-sample” end condition is used here, which means the third
derivatives are continuous for the first two and last two segments. If
<code class="docutils literal notranslate"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, then the first and second
derivatives between the end of the last segment and the beginning of
the first segment will be continuous. Note that the periodic end
condition does not require the first and last sample to be collocated,
nor does it add an additional sample to connect the first and last
segments. Only first and second derivative continuity is enforced. See
<a class="reference external" href="https://en.wikipedia.org/wiki/Spline_interpolation">https://en.wikipedia.org/wiki/Spline_interpolation</a> and
<a class="reference external" href="https://web.archive.org/web/20140125011904/https://www.math.uh.edu/~jingqiu/math4364/spline.pdf">https://web.archive.org/web/20140125011904/https://www.math.uh.edu/~jingqiu/math4364/spline.pdf</a>
for more about cubic splines and their end conditions. The MATLAB docs
for methods “spline” and “csape” are also good references.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">breaks</span></code> and <code class="docutils literal notranslate"><span class="pre">samples</span></code> must have at least 3 elements. If
<code class="docutils literal notranslate"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, then for two samples, it
would produce a straight line (use <code class="docutils literal notranslate"><span class="pre">FirstOrderHold</span></code> for this
instead), and if <code class="docutils literal notranslate"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code> the
problem is ill-defined.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.derivative">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].derivative"></span><span class="sig-name descname"><span class="pre">derivative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derivative_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.derivative" title="Permalink to this definition"></a></dt>
<dd><p>Returns a PiecewisePolynomial where each segment is the specified
derivative of the corresponding segment in <code class="docutils literal notranslate"><span class="pre">this</span></code>. Any rules or
limitations of Polynomial::derivative() also apply to this function.</p>
<p>Derivatives evaluated at non-differentiable points return the value at
the left hand side of the interval.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code>:</dt><dd><p>The order of the derivative, namely, if <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code> = n,
the n’th derivative of the polynomial will be returned.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In the event of discontinuous derivatives evaluated at breaks, it
is not defined which polynomial (i.e., to the left or right of the
break) will be the one that is evaluated at the break.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.FirstOrderHold">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].FirstOrderHold"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">FirstOrderHold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.FirstOrderHold" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>FirstOrderHold(breaks: list[pydrake.symbolic.Expression], samples: list[list[pydrake.symbolic.Expression]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[Expression]</p></li>
</ol>
<p>Version of FirstOrderHold(breaks, samples) that uses vector samples
and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each column of <code class="docutils literal notranslate"><span class="pre">samples</span></code>
represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>FirstOrderHold(breaks: list[pydrake.symbolic.Expression], samples: list[numpy.ndarray[object[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[Expression]</p></li>
</ol>
<p>Constructs a piecewise linear PiecewisePolynomial using matrix
samples.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.getPolynomial">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].getPolynomial"></span><span class="sig-name descname"><span class="pre">getPolynomial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.polynomial.html#pydrake.polynomial.Polynomial_" title="pydrake.polynomial.Polynomial_"><span class="pre">pydrake.polynomial.Polynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.getPolynomial" title="Permalink to this definition"></a></dt>
<dd><p>Gets the Polynomial with the given matrix row and column index that
corresponds to the given segment index. Equivalent to
<code class="docutils literal notranslate"><span class="pre">getPolynomialMatrix(segment_index)(row,</span> <span class="pre">col)</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calls PiecewiseTrajectory&lt;T&gt;::segment_number_range_check() to
validate <code class="docutils literal notranslate"><span class="pre">segment_index</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.getPolynomialMatrix">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].getPolynomialMatrix"></span><span class="sig-name descname"><span class="pre">getPolynomialMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.getPolynomialMatrix" title="Permalink to this definition"></a></dt>
<dd><p>Gets the matrix of Polynomials corresponding to the given segment
index.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><code class="docutils literal notranslate"><span class="pre">segment_index</span></code> is not checked for validity.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.getSegmentPolynomialDegree">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].getSegmentPolynomialDegree"></span><span class="sig-name descname"><span class="pre">getSegmentPolynomialDegree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.getSegmentPolynomialDegree" title="Permalink to this definition"></a></dt>
<dd><p>Gets the degree of the Polynomial with the given matrix row and column
index that corresponds to the given segment index. Equivalent to
<code class="docutils literal notranslate"><span class="pre">getPolynomial(segment_index,</span> <span class="pre">row,</span> <span class="pre">col).GetDegree()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.isApprox">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].isApprox"></span><span class="sig-name descname"><span class="pre">isApprox</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[Expression],</span> <span class="pre">other:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[Expression],</span> <span class="pre">tol:</span> <span class="pre">float,</span> <span class="pre">tol_type:</span> <span class="pre">pydrake.common.ToleranceType</span> <span class="pre">=</span> <span class="pre">&lt;ToleranceType.kRelative:</span> <span class="pre">1&gt;</span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.isApprox" title="Permalink to this definition"></a></dt>
<dd><p>Checks whether a PiecewisePolynomial is approximately equal to this
one by calling Polynomial&lt;T&gt;::CoefficientsAlmostEqual() on every
element of every segment.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Polynomial&lt;T&gt;::CoefficientsAlmostEqual().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.LagrangeInterpolatingPolynomial">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].LagrangeInterpolatingPolynomial"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">LagrangeInterpolatingPolynomial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.LagrangeInterpolatingPolynomial" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>LagrangeInterpolatingPolynomial(times: list[pydrake.symbolic.Expression], samples: list[list[pydrake.symbolic.Expression]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[Expression]</p></li>
</ol>
<p>Version of LagrangeInterpolatingPolynomial(times, samples) that uses
vector samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each column
of <code class="docutils literal notranslate"><span class="pre">samples</span></code> represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">times.size()</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>LagrangeInterpolatingPolynomial(times: list[pydrake.symbolic.Expression], samples: list[numpy.ndarray[object[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[Expression]</p></li>
</ol>
<p>Constructs a polynomial with a <em>single segment</em> of the lowest possible
degree that passes through all of the sample points. See “polynomial
interpolation” and/or “Lagrange polynomial” on Wikipedia for more
information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">times</span></code> must be monotonically increasing.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.size()</span> <span class="pre">==</span> <span class="pre">times.size()</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.RemoveFinalSegment">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].RemoveFinalSegment"></span><span class="sig-name descname"><span class="pre">RemoveFinalSegment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.RemoveFinalSegment" title="Permalink to this definition"></a></dt>
<dd><p>Removes the final segment from the trajectory, reducing the number of
segments by 1.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> is not empty()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.Reshape">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].Reshape"></span><span class="sig-name descname"><span class="pre">Reshape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rows</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cols</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.Reshape" title="Permalink to this definition"></a></dt>
<dd><p>Reshapes the dimensions of the Eigen::MatrixX&lt;T&gt; returned by value(),
EvalDerivative(), etc.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">rows</span></code> x <code class="docutils literal notranslate"><span class="pre">cols</span></code> must equal this.rows() * this.cols().</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Eigen::PlainObjectBase::resize().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.ReverseTime">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].ReverseTime"></span><span class="sig-name descname"><span class="pre">ReverseTime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.ReverseTime" title="Permalink to this definition"></a></dt>
<dd><p>Modifies the trajectory so that pp_after(t) = pp_before(-t).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The new trajectory will evaluate differently at precisely the
break points if the original trajectory was discontinuous at the
break points. This is because the segments are defined on the
half-open intervals [breaks(i), breaks(i+1)), and the order of the
breaks have been reversed.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.ScaleTime">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].ScaleTime"></span><span class="sig-name descname"><span class="pre">ScaleTime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.ScaleTime" title="Permalink to this definition"></a></dt>
<dd><p>Scales the time of the trajectory by non-negative <code class="docutils literal notranslate"><span class="pre">scale</span></code> (use
ReverseTime() if you want to also negate time). The resulting
polynomial evaluates to pp_after(t) = pp_before(t/scale).</p>
<p>As an example, <a href="#id15"><span class="problematic" id="id16">`</span></a>scale`=2 will result in a trajectory that is twice as
long (start_time() and end_time() have both doubled).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.setPolynomialMatrixBlock">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].setPolynomialMatrixBlock"></span><span class="sig-name descname"><span class="pre">setPolynomialMatrixBlock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">replacement</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row_start</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col_start</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.setPolynomialMatrixBlock" title="Permalink to this definition"></a></dt>
<dd><p>Replaces the specified block of the PolynomialMatrix at the given
segment index.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calls PiecewiseTrajectory&lt;T&gt;::segment_number_range_check() to
validate <code class="docutils literal notranslate"><span class="pre">segment_index</span></code>.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This code relies upon Eigen to verify that the replacement block
is not too large.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.shiftRight">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].shiftRight"></span><span class="sig-name descname"><span class="pre">shiftRight</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.shiftRight" title="Permalink to this definition"></a></dt>
<dd><p>Adds <code class="docutils literal notranslate"><span class="pre">offset</span></code> to all of the breaks. <code class="docutils literal notranslate"><span class="pre">offset</span></code> need not be a
non-negative number. The resulting polynomial will evaluate to
pp_after(t) = pp_before(t-offset).</p>
<p>As an example, <a href="#id17"><span class="problematic" id="id18">`</span></a>offset`=2 will result in the start_time() and
end_time() being 2 seconds later.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.slice">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].slice"></span><span class="sig-name descname"><span class="pre">slice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_segments</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.slice" title="Permalink to this definition"></a></dt>
<dd><p>Returns the PiecewisePolynomial comprising the <code class="docutils literal notranslate"><span class="pre">num_segments</span></code>
segments starting at the specified <code class="docutils literal notranslate"><span class="pre">start_segment_index</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calls PiecewiseTrajectory&lt;T&gt;::segment_number_range_check() to
validate <code class="docutils literal notranslate"><span class="pre">segment_index</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.Transpose">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].Transpose"></span><span class="sig-name descname"><span class="pre">Transpose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.Transpose" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a new PiecewisePolynomial for which value(t) ==
this.value(t).transpose().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.ZeroOrderHold">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].ZeroOrderHold"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ZeroOrderHold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.ZeroOrderHold" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>ZeroOrderHold(breaks: list[pydrake.symbolic.Expression], samples: list[list[pydrake.symbolic.Expression]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[Expression]</p></li>
</ol>
<p>Version of ZeroOrderHold(breaks, samples) that uses vector samples and
Eigen VectorXd/MatrixX&lt;T&gt; arguments. Each column of <code class="docutils literal notranslate"><span class="pre">samples</span></code>
represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>ZeroOrderHold(breaks: list[pydrake.symbolic.Expression], samples: list[numpy.ndarray[object[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[Expression]</p></li>
</ol>
<p>Constructs a piecewise constant PiecewisePolynomial using matrix
samples. Note that constructing a PiecewisePolynomial requires at
least two sample points, although in this case, the second sample
point’s value is ignored, and only its break time is used.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PiecewisePose</span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory" title="pydrake.trajectories.PiecewiseTrajectory"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PiecewiseTrajectory</span></code></a></p>
<p>A wrapper class that represents a pose trajectory, whose rotation part
is a PiecewiseQuaternionSlerp and the translation part is a
PiecewisePolynomial.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewisePose_</span></code></a>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.PiecewisePose) -&gt; None</p></li>
</ol>
<p>Constructs an empty piecewise pose trajectory.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.trajectories.PiecewisePose, position_trajectory: pydrake.trajectories.PiecewisePolynomial, orientation_trajectory: pydrake.trajectories.PiecewiseQuaternionSlerp) -&gt; None</p></li>
</ol>
<p>Constructor.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pos_traj</span></code>:</dt><dd><p>Position trajectory.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rot_traj</span></code>:</dt><dd><p>Orientation trajectory.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose.get_orientation_trajectory">
<span class="sig-name descname"><span class="pre">get_orientation_trajectory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose" title="pydrake.trajectories.PiecewisePose"><span class="pre">pydrake.trajectories.PiecewisePose</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewiseQuaternionSlerp" title="pydrake.trajectories.PiecewiseQuaternionSlerp"><span class="pre">pydrake.trajectories.PiecewiseQuaternionSlerp</span></a></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose.get_orientation_trajectory" title="Permalink to this definition"></a></dt>
<dd><p>Returns the orientation trajectory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose.get_position_trajectory">
<span class="sig-name descname"><span class="pre">get_position_trajectory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose" title="pydrake.trajectories.PiecewisePose"><span class="pre">pydrake.trajectories.PiecewisePose</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial" title="pydrake.trajectories.PiecewisePolynomial"><span class="pre">pydrake.trajectories.PiecewisePolynomial</span></a></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose.get_position_trajectory" title="Permalink to this definition"></a></dt>
<dd><p>Returns the position trajectory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose.GetAcceleration">
<span class="sig-name descname"><span class="pre">GetAcceleration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose" title="pydrake.trajectories.PiecewisePose"><span class="pre">pydrake.trajectories.PiecewisePose</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">6</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose.GetAcceleration" title="Permalink to this definition"></a></dt>
<dd><p>Returns the interpolated acceleration at <code class="docutils literal notranslate"><span class="pre">time</span></code> or zero if <code class="docutils literal notranslate"><span class="pre">time</span></code>
is before this trajectory’s start time or after its end time.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose.GetPose">
<span class="sig-name descname"><span class="pre">GetPose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose" title="pydrake.trajectories.PiecewisePose"><span class="pre">pydrake.trajectories.PiecewisePose</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose.GetPose" title="Permalink to this definition"></a></dt>
<dd><p>Returns the interpolated pose at <code class="docutils literal notranslate"><span class="pre">time</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose.GetVelocity">
<span class="sig-name descname"><span class="pre">GetVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose" title="pydrake.trajectories.PiecewisePose"><span class="pre">pydrake.trajectories.PiecewisePose</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">6</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose.GetVelocity" title="Permalink to this definition"></a></dt>
<dd><p>Returns the interpolated velocity at <code class="docutils literal notranslate"><span class="pre">time</span></code> or zero if <code class="docutils literal notranslate"><span class="pre">time</span></code> is
before this trajectory’s start time or after its end time.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose.IsApprox">
<span class="sig-name descname"><span class="pre">IsApprox</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose" title="pydrake.trajectories.PiecewisePose"><span class="pre">pydrake.trajectories.PiecewisePose</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose" title="pydrake.trajectories.PiecewisePose"><span class="pre">pydrake.trajectories.PiecewisePose</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose.IsApprox" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if the position and orientation trajectories are both
within <code class="docutils literal notranslate"><span class="pre">tol</span></code> from the other’s.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose.MakeCubicLinearWithEndLinearVelocity">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeCubicLinearWithEndLinearVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">times</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poses</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_vel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([0.,</span> <span class="pre">0.,</span> <span class="pre">0.])</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end_vel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([0.,</span> <span class="pre">0.,</span> <span class="pre">0.])</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose" title="pydrake.trajectories.PiecewisePose"><span class="pre">pydrake.trajectories.PiecewisePose</span></a></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose.MakeCubicLinearWithEndLinearVelocity" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a PiecewisePose from given <code class="docutils literal notranslate"><span class="pre">times</span></code> and <code class="docutils literal notranslate"><span class="pre">poses</span></code>. A cubic
polynomial with given end velocities is used to construct the position
part. The rotational part is represented by a piecewise quaterion
trajectory. There must be at least two elements in <code class="docutils literal notranslate"><span class="pre">times</span></code> and
<code class="docutils literal notranslate"><span class="pre">poses</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">times</span></code>:</dt><dd><p>Breaks used to build the splines.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">poses</span></code>:</dt><dd><p>Knots used to build the splines.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">start_vel</span></code>:</dt><dd><p>Start linear velocity.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">end_vel</span></code>:</dt><dd><p>End linear velocity.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose.MakeLinear">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeLinear</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">times</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poses</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform" title="pydrake.math.RigidTransform"><span class="pre">pydrake.math.RigidTransform</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose" title="pydrake.trajectories.PiecewisePose"><span class="pre">pydrake.trajectories.PiecewisePose</span></a></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose.MakeLinear" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a PiecewisePose from given <code class="docutils literal notranslate"><span class="pre">times</span></code> and <code class="docutils literal notranslate"><span class="pre">poses</span></code>. The
positions trajectory is constructed as a first-order hold. The
orientation is constructed using the quaternion slerp. There must be
at least two elements in <code class="docutils literal notranslate"><span class="pre">times</span></code> and <code class="docutils literal notranslate"><span class="pre">poses</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">times</span></code>:</dt><dd><p>Breaks used to build the splines.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">poses</span></code>:</dt><dd><p>Knots used to build the splines.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PiecewisePose_</span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewisePose_[float]</span></code>, <a class="reference internal" href="#pydrake.trajectories.PiecewisePose_-AutoDiffXd" title="pydrake.trajectories.PiecewisePose_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewisePose_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.trajectories.PiecewisePose_-Expression" title="pydrake.trajectories.PiecewisePose_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewisePose_[Expression]</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-AutoDiffXd">
<span id="pydrake.trajectories.PiecewisePose_[AutoDiffXd]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PiecewisePose_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd" title="pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd]</span></code></a></p>
<p>A wrapper class that represents a pose trajectory, whose rotation part
is a PiecewiseQuaternionSlerp and the translation part is a
PiecewisePolynomial.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-AutoDiffXd-.__init__">
<span id="pydrake.trajectories.PiecewisePose_[AutoDiffXd].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-AutoDiffXd-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.PiecewisePose_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Constructs an empty piecewise pose trajectory.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.trajectories.PiecewisePose_[AutoDiffXd], position_trajectory: pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd], orientation_trajectory: pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Constructor.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pos_traj</span></code>:</dt><dd><p>Position trajectory.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rot_traj</span></code>:</dt><dd><p>Orientation trajectory.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-AutoDiffXd-.get_orientation_trajectory">
<span id="pydrake.trajectories.PiecewisePose_[AutoDiffXd].get_orientation_trajectory"></span><span class="sig-name descname"><span class="pre">get_orientation_trajectory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_" title="pydrake.trajectories.PiecewiseQuaternionSlerp_"><span class="pre">pydrake.trajectories.PiecewiseQuaternionSlerp_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-AutoDiffXd-.get_orientation_trajectory" title="Permalink to this definition"></a></dt>
<dd><p>Returns the orientation trajectory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-AutoDiffXd-.get_position_trajectory">
<span id="pydrake.trajectories.PiecewisePose_[AutoDiffXd].get_position_trajectory"></span><span class="sig-name descname"><span class="pre">get_position_trajectory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-AutoDiffXd-.get_position_trajectory" title="Permalink to this definition"></a></dt>
<dd><p>Returns the position trajectory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-AutoDiffXd-.GetAcceleration">
<span id="pydrake.trajectories.PiecewisePose_[AutoDiffXd].GetAcceleration"></span><span class="sig-name descname"><span class="pre">GetAcceleration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">6</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-AutoDiffXd-.GetAcceleration" title="Permalink to this definition"></a></dt>
<dd><p>Returns the interpolated acceleration at <code class="docutils literal notranslate"><span class="pre">time</span></code> or zero if <code class="docutils literal notranslate"><span class="pre">time</span></code>
is before this trajectory’s start time or after its end time.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-AutoDiffXd-.GetPose">
<span id="pydrake.trajectories.PiecewisePose_[AutoDiffXd].GetPose"></span><span class="sig-name descname"><span class="pre">GetPose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-AutoDiffXd-.GetPose" title="Permalink to this definition"></a></dt>
<dd><p>Returns the interpolated pose at <code class="docutils literal notranslate"><span class="pre">time</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-AutoDiffXd-.GetVelocity">
<span id="pydrake.trajectories.PiecewisePose_[AutoDiffXd].GetVelocity"></span><span class="sig-name descname"><span class="pre">GetVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">6</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-AutoDiffXd-.GetVelocity" title="Permalink to this definition"></a></dt>
<dd><p>Returns the interpolated velocity at <code class="docutils literal notranslate"><span class="pre">time</span></code> or zero if <code class="docutils literal notranslate"><span class="pre">time</span></code> is
before this trajectory’s start time or after its end time.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-AutoDiffXd-.IsApprox">
<span id="pydrake.trajectories.PiecewisePose_[AutoDiffXd].IsApprox"></span><span class="sig-name descname"><span class="pre">IsApprox</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-AutoDiffXd-.IsApprox" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if the position and orientation trajectories are both
within <code class="docutils literal notranslate"><span class="pre">tol</span></code> from the other’s.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-AutoDiffXd-.MakeCubicLinearWithEndLinearVelocity">
<span id="pydrake.trajectories.PiecewisePose_[AutoDiffXd].MakeCubicLinearWithEndLinearVelocity"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeCubicLinearWithEndLinearVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">times:</span> <span class="pre">list[pydrake.autodiffutils.AutoDiffXd],</span> <span class="pre">poses:</span> <span class="pre">list[pydrake.math.RigidTransform_[AutoDiffXd]],</span> <span class="pre">start_vel:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span> <span class="pre">=</span> <span class="pre">array([&lt;AutoDiffXd</span> <span class="pre">0.0</span> <span class="pre">nderiv=0&gt;,</span> <span class="pre">&lt;AutoDiffXd</span> <span class="pre">0.0</span> <span class="pre">nderiv=0&gt;,</span> <span class="pre">&lt;AutoDiffXd</span> <span class="pre">0.0</span> <span class="pre">nderiv=0&gt;],</span> <span class="pre">dtype=object),</span> <span class="pre">end_vel:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span> <span class="pre">=</span> <span class="pre">array([&lt;AutoDiffXd</span> <span class="pre">0.0</span> <span class="pre">nderiv=0&gt;,</span> <span class="pre">&lt;AutoDiffXd</span> <span class="pre">0.0</span> <span class="pre">nderiv=0&gt;,</span> <span class="pre">&lt;AutoDiffXd</span> <span class="pre">0.0</span> <span class="pre">nderiv=0&gt;],</span> <span class="pre">dtype=object)</span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-AutoDiffXd-.MakeCubicLinearWithEndLinearVelocity" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a PiecewisePose from given <code class="docutils literal notranslate"><span class="pre">times</span></code> and <code class="docutils literal notranslate"><span class="pre">poses</span></code>. A cubic
polynomial with given end velocities is used to construct the position
part. The rotational part is represented by a piecewise quaterion
trajectory. There must be at least two elements in <code class="docutils literal notranslate"><span class="pre">times</span></code> and
<code class="docutils literal notranslate"><span class="pre">poses</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">times</span></code>:</dt><dd><p>Breaks used to build the splines.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">poses</span></code>:</dt><dd><p>Knots used to build the splines.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">start_vel</span></code>:</dt><dd><p>Start linear velocity.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">end_vel</span></code>:</dt><dd><p>End linear velocity.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-AutoDiffXd-.MakeLinear">
<span id="pydrake.trajectories.PiecewisePose_[AutoDiffXd].MakeLinear"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeLinear</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">times</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poses</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-AutoDiffXd-.MakeLinear" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a PiecewisePose from given <code class="docutils literal notranslate"><span class="pre">times</span></code> and <code class="docutils literal notranslate"><span class="pre">poses</span></code>. The
positions trajectory is constructed as a first-order hold. The
orientation is constructed using the quaternion slerp. There must be
at least two elements in <code class="docutils literal notranslate"><span class="pre">times</span></code> and <code class="docutils literal notranslate"><span class="pre">poses</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">times</span></code>:</dt><dd><p>Breaks used to build the splines.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">poses</span></code>:</dt><dd><p>Knots used to build the splines.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-Expression">
<span id="pydrake.trajectories.PiecewisePose_[Expression]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PiecewisePose_[Expression]</span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-Expression" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_-Expression" title="pydrake.trajectories.PiecewiseTrajectory_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_[Expression]</span></code></a></p>
<p>A wrapper class that represents a pose trajectory, whose rotation part
is a PiecewiseQuaternionSlerp and the translation part is a
PiecewisePolynomial.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-Expression-.__init__">
<span id="pydrake.trajectories.PiecewisePose_[Expression].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-Expression-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.PiecewisePose_[Expression]) -&gt; None</p></li>
</ol>
<p>Constructs an empty piecewise pose trajectory.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.trajectories.PiecewisePose_[Expression], position_trajectory: pydrake.trajectories.PiecewisePolynomial_[Expression], orientation_trajectory: pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression]) -&gt; None</p></li>
</ol>
<p>Constructor.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pos_traj</span></code>:</dt><dd><p>Position trajectory.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rot_traj</span></code>:</dt><dd><p>Orientation trajectory.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-Expression-.get_orientation_trajectory">
<span id="pydrake.trajectories.PiecewisePose_[Expression].get_orientation_trajectory"></span><span class="sig-name descname"><span class="pre">get_orientation_trajectory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_" title="pydrake.trajectories.PiecewiseQuaternionSlerp_"><span class="pre">pydrake.trajectories.PiecewiseQuaternionSlerp_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-Expression-.get_orientation_trajectory" title="Permalink to this definition"></a></dt>
<dd><p>Returns the orientation trajectory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-Expression-.get_position_trajectory">
<span id="pydrake.trajectories.PiecewisePose_[Expression].get_position_trajectory"></span><span class="sig-name descname"><span class="pre">get_position_trajectory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-Expression-.get_position_trajectory" title="Permalink to this definition"></a></dt>
<dd><p>Returns the position trajectory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-Expression-.GetAcceleration">
<span id="pydrake.trajectories.PiecewisePose_[Expression].GetAcceleration"></span><span class="sig-name descname"><span class="pre">GetAcceleration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">6</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-Expression-.GetAcceleration" title="Permalink to this definition"></a></dt>
<dd><p>Returns the interpolated acceleration at <code class="docutils literal notranslate"><span class="pre">time</span></code> or zero if <code class="docutils literal notranslate"><span class="pre">time</span></code>
is before this trajectory’s start time or after its end time.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-Expression-.GetPose">
<span id="pydrake.trajectories.PiecewisePose_[Expression].GetPose"></span><span class="sig-name descname"><span class="pre">GetPose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-Expression-.GetPose" title="Permalink to this definition"></a></dt>
<dd><p>Returns the interpolated pose at <code class="docutils literal notranslate"><span class="pre">time</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-Expression-.GetVelocity">
<span id="pydrake.trajectories.PiecewisePose_[Expression].GetVelocity"></span><span class="sig-name descname"><span class="pre">GetVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">6</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-Expression-.GetVelocity" title="Permalink to this definition"></a></dt>
<dd><p>Returns the interpolated velocity at <code class="docutils literal notranslate"><span class="pre">time</span></code> or zero if <code class="docutils literal notranslate"><span class="pre">time</span></code> is
before this trajectory’s start time or after its end time.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-Expression-.IsApprox">
<span id="pydrake.trajectories.PiecewisePose_[Expression].IsApprox"></span><span class="sig-name descname"><span class="pre">IsApprox</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-Expression-.IsApprox" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if the position and orientation trajectories are both
within <code class="docutils literal notranslate"><span class="pre">tol</span></code> from the other’s.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-Expression-.MakeCubicLinearWithEndLinearVelocity">
<span id="pydrake.trajectories.PiecewisePose_[Expression].MakeCubicLinearWithEndLinearVelocity"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeCubicLinearWithEndLinearVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">times:</span> <span class="pre">list[pydrake.symbolic.Expression],</span> <span class="pre">poses:</span> <span class="pre">list[pydrake.math.RigidTransform_[Expression]],</span> <span class="pre">start_vel:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span> <span class="pre">=</span> <span class="pre">array([&lt;Expression</span> <span class="pre">&quot;0&quot;&gt;,</span> <span class="pre">&lt;Expression</span> <span class="pre">&quot;0&quot;&gt;,</span> <span class="pre">&lt;Expression</span> <span class="pre">&quot;0&quot;&gt;],</span> <span class="pre">dtype=object),</span> <span class="pre">end_vel:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span> <span class="pre">=</span> <span class="pre">array([&lt;Expression</span> <span class="pre">&quot;0&quot;&gt;,</span> <span class="pre">&lt;Expression</span> <span class="pre">&quot;0&quot;&gt;,</span> <span class="pre">&lt;Expression</span> <span class="pre">&quot;0&quot;&gt;],</span> <span class="pre">dtype=object)</span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-Expression-.MakeCubicLinearWithEndLinearVelocity" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a PiecewisePose from given <code class="docutils literal notranslate"><span class="pre">times</span></code> and <code class="docutils literal notranslate"><span class="pre">poses</span></code>. A cubic
polynomial with given end velocities is used to construct the position
part. The rotational part is represented by a piecewise quaterion
trajectory. There must be at least two elements in <code class="docutils literal notranslate"><span class="pre">times</span></code> and
<code class="docutils literal notranslate"><span class="pre">poses</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">times</span></code>:</dt><dd><p>Breaks used to build the splines.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">poses</span></code>:</dt><dd><p>Knots used to build the splines.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">start_vel</span></code>:</dt><dd><p>Start linear velocity.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">end_vel</span></code>:</dt><dd><p>End linear velocity.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-Expression-.MakeLinear">
<span id="pydrake.trajectories.PiecewisePose_[Expression].MakeLinear"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeLinear</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">times</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poses</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-Expression-.MakeLinear" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a PiecewisePose from given <code class="docutils literal notranslate"><span class="pre">times</span></code> and <code class="docutils literal notranslate"><span class="pre">poses</span></code>. The
positions trajectory is constructed as a first-order hold. The
orientation is constructed using the quaternion slerp. There must be
at least two elements in <code class="docutils literal notranslate"><span class="pre">times</span></code> and <code class="docutils literal notranslate"><span class="pre">poses</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">times</span></code>:</dt><dd><p>Breaks used to build the splines.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">poses</span></code>:</dt><dd><p>Knots used to build the splines.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PiecewiseQuaternionSlerp</span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory" title="pydrake.trajectories.PiecewiseTrajectory"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PiecewiseTrajectory</span></code></a></p>
<p>A class representing a trajectory for quaternions that are
interpolated using piecewise slerp (spherical linear interpolation).
All the orientation samples are expected to be with respect to the
same parent reference frame, i.e. q_i represents the rotation R_PBi
for the orientation of frame B at the ith sample in a fixed parent
frame P. The world frame is a common choice for the parent frame. The
angular velocity and acceleration are also relative to the parent
frame and expressed in the parent frame. Since there is a sign
ambiguity when using quaternions to represent orientation, namely q
and -q represent the same orientation, the internal quaternion
representations ensure that q_n.dot(q_{n+1}) &gt;= 0. Another intuitive
way to think about this is that consecutive quaternions have the
shortest geodesic distance on the unit sphere. Note that the
quarternion value is in w, x, y, z order when represented as a
Vector4.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <a class="reference internal" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_" title="pydrake.trajectories.PiecewiseQuaternionSlerp_"><code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewiseQuaternionSlerp_</span></code></a>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp) -&gt; None</p></li>
</ol>
<p>Builds an empty PiecewiseQuaternionSlerp.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp, breaks: list[float], quaternions: list[pydrake.common.eigen_geometry.Quaternion]) -&gt; None</p></li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if breaks and quaternions have different length</strong><strong>, </strong><strong>or</strong> – </p></li>
<li><p><strong>breaks have length &lt; 2.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp, breaks: list[float], rotation_matrices: list[numpy.ndarray[numpy.float64[3, 3]]]) -&gt; None</p></li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if breaks and rot_matrices have different length</strong><strong>, </strong><strong>or</strong> – </p></li>
<li><p><strong>breaks have length &lt; 2.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp, breaks: list[float], rotation_matrices: list[pydrake.math.RotationMatrix]) -&gt; None</p></li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if breaks and rot_matrices have different length</strong><strong>, </strong><strong>or</strong> – </p></li>
<li><p><strong>breaks have length &lt; 2.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="5">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp, breaks: list[float], angle_axes: list[pydrake.common.eigen_geometry.AngleAxis]) -&gt; None</p></li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if breaks and ang_axes have different length</strong><strong>, </strong><strong>or</strong> – </p></li>
<li><p><strong>breaks have length &lt; 2.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp.angular_acceleration">
<span class="sig-name descname"><span class="pre">angular_acceleration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseQuaternionSlerp" title="pydrake.trajectories.PiecewiseQuaternionSlerp"><span class="pre">pydrake.trajectories.PiecewiseQuaternionSlerp</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp.angular_acceleration" title="Permalink to this definition"></a></dt>
<dd><p>Interpolates angular acceleration.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time</span></code>:</dt><dd><p>Time for interpolation.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The interpolated angular acceleration at <code class="docutils literal notranslate"><span class="pre">time</span></code>, which is always
zero for slerp.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp.angular_velocity">
<span class="sig-name descname"><span class="pre">angular_velocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseQuaternionSlerp" title="pydrake.trajectories.PiecewiseQuaternionSlerp"><span class="pre">pydrake.trajectories.PiecewiseQuaternionSlerp</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp.angular_velocity" title="Permalink to this definition"></a></dt>
<dd><p>Interpolates angular velocity.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time</span></code>:</dt><dd><p>Time for interpolation.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The interpolated angular velocity at <code class="docutils literal notranslate"><span class="pre">time</span></code>, which is constant
per segment.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp.Append">
<span class="sig-name descname"><span class="pre">Append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp.Append" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>Append(self: pydrake.trajectories.PiecewiseQuaternionSlerp, time: float, quaternion: pydrake.common.eigen_geometry.Quaternion) -&gt; None</p></li>
</ol>
<p>Given a new Quaternion, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<ol class="arabic simple" start="2">
<li><p>Append(self: pydrake.trajectories.PiecewiseQuaternionSlerp, time: float, rotation_matrix: pydrake.math.RotationMatrix) -&gt; None</p></li>
</ol>
<p>Given a new RotationMatrix, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<ol class="arabic simple" start="3">
<li><p>Append(self: pydrake.trajectories.PiecewiseQuaternionSlerp, time: float, angle_axis: pydrake.common.eigen_geometry.AngleAxis) -&gt; None</p></li>
</ol>
<p>Given a new AngleAxis, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp.orientation">
<span class="sig-name descname"><span class="pre">orientation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseQuaternionSlerp" title="pydrake.trajectories.PiecewiseQuaternionSlerp"><span class="pre">pydrake.trajectories.PiecewiseQuaternionSlerp</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.common.eigen_geometry.html#pydrake.common.eigen_geometry.Quaternion" title="pydrake.common.eigen_geometry.Quaternion"><span class="pre">pydrake.common.eigen_geometry.Quaternion</span></a></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp.orientation" title="Permalink to this definition"></a></dt>
<dd><p>Interpolates orientation.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time</span></code>:</dt><dd><p>Time for interpolation.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The interpolated quaternion at <code class="docutils literal notranslate"><span class="pre">time</span></code>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PiecewiseQuaternionSlerp_</span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewiseQuaternionSlerp_[float]</span></code>, <a class="reference internal" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_-AutoDiffXd" title="pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewiseQuaternionSlerp_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_-Expression" title="pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewiseQuaternionSlerp_[Expression]</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp_-AutoDiffXd">
<span id="pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PiecewiseQuaternionSlerp_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd" title="pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd]</span></code></a></p>
<p>A class representing a trajectory for quaternions that are
interpolated using piecewise slerp (spherical linear interpolation).
All the orientation samples are expected to be with respect to the
same parent reference frame, i.e. q_i represents the rotation R_PBi
for the orientation of frame B at the ith sample in a fixed parent
frame P. The world frame is a common choice for the parent frame. The
angular velocity and acceleration are also relative to the parent
frame and expressed in the parent frame. Since there is a sign
ambiguity when using quaternions to represent orientation, namely q
and -q represent the same orientation, the internal quaternion
representations ensure that q_n.dot(q_{n+1}) &gt;= 0. Another intuitive
way to think about this is that consecutive quaternions have the
shortest geodesic distance on the unit sphere. Note that the
quarternion value is in w, x, y, z order when represented as a
Vector4.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp_-AutoDiffXd-.__init__">
<span id="pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_-AutoDiffXd-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Builds an empty PiecewiseQuaternionSlerp.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd], breaks: list[pydrake.autodiffutils.AutoDiffXd], quaternions: list[pydrake.common.eigen_geometry.Quaternion_[AutoDiffXd]]) -&gt; None</p></li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if breaks and quaternions have different length</strong><strong>, </strong><strong>or</strong> – </p></li>
<li><p><strong>breaks have length &lt; 2.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd], breaks: list[pydrake.autodiffutils.AutoDiffXd], rotation_matrices: list[numpy.ndarray[object[3, 3]]]) -&gt; None</p></li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if breaks and rot_matrices have different length</strong><strong>, </strong><strong>or</strong> – </p></li>
<li><p><strong>breaks have length &lt; 2.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd], breaks: list[pydrake.autodiffutils.AutoDiffXd], rotation_matrices: list[pydrake.math.RotationMatrix_[AutoDiffXd]]) -&gt; None</p></li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if breaks and rot_matrices have different length</strong><strong>, </strong><strong>or</strong> – </p></li>
<li><p><strong>breaks have length &lt; 2.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="5">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd], breaks: list[pydrake.autodiffutils.AutoDiffXd], angle_axes: list[pydrake.common.eigen_geometry.AngleAxis_[AutoDiffXd]]) -&gt; None</p></li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if breaks and ang_axes have different length</strong><strong>, </strong><strong>or</strong> – </p></li>
<li><p><strong>breaks have length &lt; 2.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp_-AutoDiffXd-.angular_acceleration">
<span id="pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd].angular_acceleration"></span><span class="sig-name descname"><span class="pre">angular_acceleration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_" title="pydrake.trajectories.PiecewiseQuaternionSlerp_"><span class="pre">pydrake.trajectories.PiecewiseQuaternionSlerp_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_-AutoDiffXd-.angular_acceleration" title="Permalink to this definition"></a></dt>
<dd><p>Interpolates angular acceleration.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time</span></code>:</dt><dd><p>Time for interpolation.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The interpolated angular acceleration at <code class="docutils literal notranslate"><span class="pre">time</span></code>, which is always
zero for slerp.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp_-AutoDiffXd-.angular_velocity">
<span id="pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd].angular_velocity"></span><span class="sig-name descname"><span class="pre">angular_velocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_" title="pydrake.trajectories.PiecewiseQuaternionSlerp_"><span class="pre">pydrake.trajectories.PiecewiseQuaternionSlerp_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_-AutoDiffXd-.angular_velocity" title="Permalink to this definition"></a></dt>
<dd><p>Interpolates angular velocity.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time</span></code>:</dt><dd><p>Time for interpolation.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The interpolated angular velocity at <code class="docutils literal notranslate"><span class="pre">time</span></code>, which is constant
per segment.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp_-AutoDiffXd-.Append">
<span id="pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd].Append"></span><span class="sig-name descname"><span class="pre">Append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_-AutoDiffXd-.Append" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>Append(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd], time: pydrake.autodiffutils.AutoDiffXd, quaternion: pydrake.common.eigen_geometry.Quaternion_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Given a new Quaternion, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<ol class="arabic simple" start="2">
<li><p>Append(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd], time: pydrake.autodiffutils.AutoDiffXd, rotation_matrix: pydrake.math.RotationMatrix_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Given a new RotationMatrix, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<ol class="arabic simple" start="3">
<li><p>Append(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd], time: pydrake.autodiffutils.AutoDiffXd, angle_axis: pydrake.common.eigen_geometry.AngleAxis_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Given a new AngleAxis, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp_-AutoDiffXd-.orientation">
<span id="pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd].orientation"></span><span class="sig-name descname"><span class="pre">orientation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_" title="pydrake.trajectories.PiecewiseQuaternionSlerp_"><span class="pre">pydrake.trajectories.PiecewiseQuaternionSlerp_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.common.eigen_geometry.html#pydrake.common.eigen_geometry.Quaternion_" title="pydrake.common.eigen_geometry.Quaternion_"><span class="pre">pydrake.common.eigen_geometry.Quaternion_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_-AutoDiffXd-.orientation" title="Permalink to this definition"></a></dt>
<dd><p>Interpolates orientation.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time</span></code>:</dt><dd><p>Time for interpolation.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The interpolated quaternion at <code class="docutils literal notranslate"><span class="pre">time</span></code>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp_-Expression">
<span id="pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PiecewiseQuaternionSlerp_[Expression]</span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_-Expression" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_-Expression" title="pydrake.trajectories.PiecewiseTrajectory_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_[Expression]</span></code></a></p>
<p>A class representing a trajectory for quaternions that are
interpolated using piecewise slerp (spherical linear interpolation).
All the orientation samples are expected to be with respect to the
same parent reference frame, i.e. q_i represents the rotation R_PBi
for the orientation of frame B at the ith sample in a fixed parent
frame P. The world frame is a common choice for the parent frame. The
angular velocity and acceleration are also relative to the parent
frame and expressed in the parent frame. Since there is a sign
ambiguity when using quaternions to represent orientation, namely q
and -q represent the same orientation, the internal quaternion
representations ensure that q_n.dot(q_{n+1}) &gt;= 0. Another intuitive
way to think about this is that consecutive quaternions have the
shortest geodesic distance on the unit sphere. Note that the
quarternion value is in w, x, y, z order when represented as a
Vector4.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp_-Expression-.__init__">
<span id="pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_-Expression-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression]) -&gt; None</p></li>
</ol>
<p>Builds an empty PiecewiseQuaternionSlerp.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression], breaks: list[pydrake.symbolic.Expression], quaternions: list[pydrake.common.eigen_geometry.Quaternion_[Expression]]) -&gt; None</p></li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if breaks and quaternions have different length</strong><strong>, </strong><strong>or</strong> – </p></li>
<li><p><strong>breaks have length &lt; 2.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression], breaks: list[pydrake.symbolic.Expression], rotation_matrices: list[numpy.ndarray[object[3, 3]]]) -&gt; None</p></li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if breaks and rot_matrices have different length</strong><strong>, </strong><strong>or</strong> – </p></li>
<li><p><strong>breaks have length &lt; 2.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression], breaks: list[pydrake.symbolic.Expression], rotation_matrices: list[pydrake.math.RotationMatrix_[Expression]]) -&gt; None</p></li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if breaks and rot_matrices have different length</strong><strong>, </strong><strong>or</strong> – </p></li>
<li><p><strong>breaks have length &lt; 2.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="5">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression], breaks: list[pydrake.symbolic.Expression], angle_axes: list[pydrake.common.eigen_geometry.AngleAxis_[Expression]]) -&gt; None</p></li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if breaks and ang_axes have different length</strong><strong>, </strong><strong>or</strong> – </p></li>
<li><p><strong>breaks have length &lt; 2.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp_-Expression-.angular_acceleration">
<span id="pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression].angular_acceleration"></span><span class="sig-name descname"><span class="pre">angular_acceleration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_" title="pydrake.trajectories.PiecewiseQuaternionSlerp_"><span class="pre">pydrake.trajectories.PiecewiseQuaternionSlerp_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_-Expression-.angular_acceleration" title="Permalink to this definition"></a></dt>
<dd><p>Interpolates angular acceleration.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time</span></code>:</dt><dd><p>Time for interpolation.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The interpolated angular acceleration at <code class="docutils literal notranslate"><span class="pre">time</span></code>, which is always
zero for slerp.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp_-Expression-.angular_velocity">
<span id="pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression].angular_velocity"></span><span class="sig-name descname"><span class="pre">angular_velocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_" title="pydrake.trajectories.PiecewiseQuaternionSlerp_"><span class="pre">pydrake.trajectories.PiecewiseQuaternionSlerp_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_-Expression-.angular_velocity" title="Permalink to this definition"></a></dt>
<dd><p>Interpolates angular velocity.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time</span></code>:</dt><dd><p>Time for interpolation.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The interpolated angular velocity at <code class="docutils literal notranslate"><span class="pre">time</span></code>, which is constant
per segment.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp_-Expression-.Append">
<span id="pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression].Append"></span><span class="sig-name descname"><span class="pre">Append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_-Expression-.Append" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>Append(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression], time: pydrake.symbolic.Expression, quaternion: pydrake.common.eigen_geometry.Quaternion_[Expression]) -&gt; None</p></li>
</ol>
<p>Given a new Quaternion, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<ol class="arabic simple" start="2">
<li><p>Append(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression], time: pydrake.symbolic.Expression, rotation_matrix: pydrake.math.RotationMatrix_[Expression]) -&gt; None</p></li>
</ol>
<p>Given a new RotationMatrix, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<ol class="arabic simple" start="3">
<li><p>Append(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression], time: pydrake.symbolic.Expression, angle_axis: pydrake.common.eigen_geometry.AngleAxis_[Expression]) -&gt; None</p></li>
</ol>
<p>Given a new AngleAxis, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp_-Expression-.orientation">
<span id="pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression].orientation"></span><span class="sig-name descname"><span class="pre">orientation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_" title="pydrake.trajectories.PiecewiseQuaternionSlerp_"><span class="pre">pydrake.trajectories.PiecewiseQuaternionSlerp_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.common.eigen_geometry.html#pydrake.common.eigen_geometry.Quaternion_" title="pydrake.common.eigen_geometry.Quaternion_"><span class="pre">pydrake.common.eigen_geometry.Quaternion_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_-Expression-.orientation" title="Permalink to this definition"></a></dt>
<dd><p>Interpolates orientation.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time</span></code>:</dt><dd><p>Time for interpolation.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The interpolated quaternion at <code class="docutils literal notranslate"><span class="pre">time</span></code>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PiecewiseTrajectory</span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.Trajectory" title="pydrake.trajectories.Trajectory"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory</span></code></a></p>
<p>Abstract class that implements the basic logic of maintaining
consequent segments of time (delimited by <code class="docutils literal notranslate"><span class="pre">breaks</span></code>) to implement a
trajectory that is represented by simpler logic in each segment or
“piece”.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_" title="pydrake.trajectories.PiecewiseTrajectory_"><code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewiseTrajectory_</span></code></a>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory.duration">
<span class="sig-name descname"><span class="pre">duration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory" title="pydrake.trajectories.PiecewiseTrajectory"><span class="pre">pydrake.trajectories.PiecewiseTrajectory</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory.duration" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory.end_time">
<span class="sig-name descname"><span class="pre">end_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory.end_time" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>end_time(self: pydrake.trajectories.PiecewiseTrajectory, segment_index: int) -&gt; float</p></li>
<li><p>end_time(self: pydrake.trajectories.PiecewiseTrajectory) -&gt; float</p></li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory.get_number_of_segments">
<span class="sig-name descname"><span class="pre">get_number_of_segments</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory" title="pydrake.trajectories.PiecewiseTrajectory"><span class="pre">pydrake.trajectories.PiecewiseTrajectory</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory.get_number_of_segments" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory.get_segment_index">
<span class="sig-name descname"><span class="pre">get_segment_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory" title="pydrake.trajectories.PiecewiseTrajectory"><span class="pre">pydrake.trajectories.PiecewiseTrajectory</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory.get_segment_index" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory.get_segment_times">
<span class="sig-name descname"><span class="pre">get_segment_times</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory" title="pydrake.trajectories.PiecewiseTrajectory"><span class="pre">pydrake.trajectories.PiecewiseTrajectory</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory.get_segment_times" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory.is_time_in_range">
<span class="sig-name descname"><span class="pre">is_time_in_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory" title="pydrake.trajectories.PiecewiseTrajectory"><span class="pre">pydrake.trajectories.PiecewiseTrajectory</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory.is_time_in_range" title="Permalink to this definition"></a></dt>
<dd><p>Returns true iff <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">&gt;=</span> <span class="pre">getStartTime()</span> <span class="pre">&amp;&amp;</span> <span class="pre">t</span> <span class="pre">&lt;=</span> <span class="pre">getEndTime()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory.start_time">
<span class="sig-name descname"><span class="pre">start_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory.start_time" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>start_time(self: pydrake.trajectories.PiecewiseTrajectory, segment_index: int) -&gt; float</p></li>
<li><p>start_time(self: pydrake.trajectories.PiecewiseTrajectory) -&gt; float</p></li>
</ol>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PiecewiseTrajectory_</span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewiseTrajectory_[float]</span></code>, <a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd" title="pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewiseTrajectory_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_-Expression" title="pydrake.trajectories.PiecewiseTrajectory_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewiseTrajectory_[Expression]</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd">
<span id="pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PiecewiseTrajectory_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.Trajectory_-AutoDiffXd" title="pydrake.trajectories.Trajectory_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[AutoDiffXd]</span></code></a></p>
<p>Abstract class that implements the basic logic of maintaining
consequent segments of time (delimited by <code class="docutils literal notranslate"><span class="pre">breaks</span></code>) to implement a
trajectory that is represented by simpler logic in each segment or
“piece”.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd-.__init__">
<span id="pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd-.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd-.duration">
<span id="pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd].duration"></span><span class="sig-name descname"><span class="pre">duration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_" title="pydrake.trajectories.PiecewiseTrajectory_"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd-.duration" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd-.end_time">
<span id="pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd].end_time"></span><span class="sig-name descname"><span class="pre">end_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd-.end_time" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>end_time(self: pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd], segment_index: int) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
<li><p>end_time(self: pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd]) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd-.get_number_of_segments">
<span id="pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd].get_number_of_segments"></span><span class="sig-name descname"><span class="pre">get_number_of_segments</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_" title="pydrake.trajectories.PiecewiseTrajectory_"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd-.get_number_of_segments" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd-.get_segment_index">
<span id="pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd].get_segment_index"></span><span class="sig-name descname"><span class="pre">get_segment_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_" title="pydrake.trajectories.PiecewiseTrajectory_"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd-.get_segment_index" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd-.get_segment_times">
<span id="pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd].get_segment_times"></span><span class="sig-name descname"><span class="pre">get_segment_times</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_" title="pydrake.trajectories.PiecewiseTrajectory_"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd-.get_segment_times" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd-.is_time_in_range">
<span id="pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd].is_time_in_range"></span><span class="sig-name descname"><span class="pre">is_time_in_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_" title="pydrake.trajectories.PiecewiseTrajectory_"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd-.is_time_in_range" title="Permalink to this definition"></a></dt>
<dd><p>Returns true iff <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">&gt;=</span> <span class="pre">getStartTime()</span> <span class="pre">&amp;&amp;</span> <span class="pre">t</span> <span class="pre">&lt;=</span> <span class="pre">getEndTime()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd-.start_time">
<span id="pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd].start_time"></span><span class="sig-name descname"><span class="pre">start_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd-.start_time" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>start_time(self: pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd], segment_index: int) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
<li><p>start_time(self: pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd]) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
</ol>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-Expression">
<span id="pydrake.trajectories.PiecewiseTrajectory_[Expression]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PiecewiseTrajectory_[Expression]</span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-Expression" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.Trajectory_-Expression" title="pydrake.trajectories.Trajectory_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[Expression]</span></code></a></p>
<p>Abstract class that implements the basic logic of maintaining
consequent segments of time (delimited by <code class="docutils literal notranslate"><span class="pre">breaks</span></code>) to implement a
trajectory that is represented by simpler logic in each segment or
“piece”.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-Expression-.__init__">
<span id="pydrake.trajectories.PiecewiseTrajectory_[Expression].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-Expression-.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-Expression-.duration">
<span id="pydrake.trajectories.PiecewiseTrajectory_[Expression].duration"></span><span class="sig-name descname"><span class="pre">duration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_" title="pydrake.trajectories.PiecewiseTrajectory_"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-Expression-.duration" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-Expression-.end_time">
<span id="pydrake.trajectories.PiecewiseTrajectory_[Expression].end_time"></span><span class="sig-name descname"><span class="pre">end_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-Expression-.end_time" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>end_time(self: pydrake.trajectories.PiecewiseTrajectory_[Expression], segment_index: int) -&gt; pydrake.symbolic.Expression</p></li>
<li><p>end_time(self: pydrake.trajectories.PiecewiseTrajectory_[Expression]) -&gt; pydrake.symbolic.Expression</p></li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-Expression-.get_number_of_segments">
<span id="pydrake.trajectories.PiecewiseTrajectory_[Expression].get_number_of_segments"></span><span class="sig-name descname"><span class="pre">get_number_of_segments</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_" title="pydrake.trajectories.PiecewiseTrajectory_"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-Expression-.get_number_of_segments" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-Expression-.get_segment_index">
<span id="pydrake.trajectories.PiecewiseTrajectory_[Expression].get_segment_index"></span><span class="sig-name descname"><span class="pre">get_segment_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_" title="pydrake.trajectories.PiecewiseTrajectory_"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-Expression-.get_segment_index" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-Expression-.get_segment_times">
<span id="pydrake.trajectories.PiecewiseTrajectory_[Expression].get_segment_times"></span><span class="sig-name descname"><span class="pre">get_segment_times</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_" title="pydrake.trajectories.PiecewiseTrajectory_"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-Expression-.get_segment_times" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-Expression-.is_time_in_range">
<span id="pydrake.trajectories.PiecewiseTrajectory_[Expression].is_time_in_range"></span><span class="sig-name descname"><span class="pre">is_time_in_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_" title="pydrake.trajectories.PiecewiseTrajectory_"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Formula" title="pydrake.symbolic.Formula"><span class="pre">pydrake.symbolic.Formula</span></a></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-Expression-.is_time_in_range" title="Permalink to this definition"></a></dt>
<dd><p>Returns true iff <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">&gt;=</span> <span class="pre">getStartTime()</span> <span class="pre">&amp;&amp;</span> <span class="pre">t</span> <span class="pre">&lt;=</span> <span class="pre">getEndTime()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-Expression-.start_time">
<span id="pydrake.trajectories.PiecewiseTrajectory_[Expression].start_time"></span><span class="sig-name descname"><span class="pre">start_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-Expression-.start_time" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>start_time(self: pydrake.trajectories.PiecewiseTrajectory_[Expression], segment_index: int) -&gt; pydrake.symbolic.Expression</p></li>
<li><p>start_time(self: pydrake.trajectories.PiecewiseTrajectory_[Expression]) -&gt; pydrake.symbolic.Expression</p></li>
</ol>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.StackedTrajectory">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">StackedTrajectory</span></span><a class="headerlink" href="#pydrake.trajectories.StackedTrajectory" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.Trajectory" title="pydrake.trajectories.Trajectory"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory</span></code></a></p>
<p>A StackedTrajectory stacks the values from one or more underlying
Trajectory objects into a single Trajectory, without changing the
<code class="docutils literal notranslate"><span class="pre">%start_time()</span></code> or <code class="docutils literal notranslate"><span class="pre">%end_time()</span></code>.</p>
<p>For sequencing trajectories in time instead, see CompositeTrajectory.</p>
<p>All of the underlying Trajectory objects must have the same
<code class="docutils literal notranslate"><span class="pre">%start_time()</span></code> and <code class="docutils literal notranslate"><span class="pre">%end_time()</span></code>.</p>
<p>When constructed with <code class="docutils literal notranslate"><span class="pre">rowwise</span></code> set to true, all of the underlying
Trajectory objects must have the same number of <code class="docutils literal notranslate"><span class="pre">%cols()</span></code> and the
<code class="docutils literal notranslate"><span class="pre">value()</span></code> matrix will be the <strong>vstack</strong> of the the trajectories in
the order they were added.</p>
<p>When constructed with <code class="docutils literal notranslate"><span class="pre">rowwise</span></code> set to false, all of the underlying
Trajectory objects must have the same number of <code class="docutils literal notranslate"><span class="pre">%rows()</span></code> and the
<code class="docutils literal notranslate"><span class="pre">value()</span></code> matrix will be the <strong>hstack</strong> of the the trajectories in
the order they were added.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <a class="reference internal" href="#pydrake.trajectories.StackedTrajectory_" title="pydrake.trajectories.StackedTrajectory_"><code class="xref py py-class docutils literal notranslate"><span class="pre">StackedTrajectory_</span></code></a>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.StackedTrajectory.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.StackedTrajectory" title="pydrake.trajectories.StackedTrajectory"><span class="pre">pydrake.trajectories.StackedTrajectory</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">rowwise</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.StackedTrajectory.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Creates an empty trajectory.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rowwise</span></code>:</dt><dd><p>governs the stacking order</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.StackedTrajectory.Append">
<span class="sig-name descname"><span class="pre">Append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.StackedTrajectory" title="pydrake.trajectories.StackedTrajectory"><span class="pre">pydrake.trajectories.StackedTrajectory</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory" title="pydrake.trajectories.Trajectory"><span class="pre">pydrake.trajectories.Trajectory</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.StackedTrajectory.Append" title="Permalink to this definition"></a></dt>
<dd><p>Stacks another sub-Trajectory onto this. Refer to the class overview
documentation for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the matrix dimension is incompatible.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.trajectories.StackedTrajectory_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">StackedTrajectory_</span></span><a class="headerlink" href="#pydrake.trajectories.StackedTrajectory_" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">StackedTrajectory_[float]</span></code>, <a class="reference internal" href="#pydrake.trajectories.StackedTrajectory_-AutoDiffXd" title="pydrake.trajectories.StackedTrajectory_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">StackedTrajectory_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.trajectories.StackedTrajectory_-Expression" title="pydrake.trajectories.StackedTrajectory_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">StackedTrajectory_[Expression]</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.StackedTrajectory_-AutoDiffXd">
<span id="pydrake.trajectories.StackedTrajectory_[AutoDiffXd]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">StackedTrajectory_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.trajectories.StackedTrajectory_-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.Trajectory_-AutoDiffXd" title="pydrake.trajectories.Trajectory_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[AutoDiffXd]</span></code></a></p>
<p>A StackedTrajectory stacks the values from one or more underlying
Trajectory objects into a single Trajectory, without changing the
<code class="docutils literal notranslate"><span class="pre">%start_time()</span></code> or <code class="docutils literal notranslate"><span class="pre">%end_time()</span></code>.</p>
<p>For sequencing trajectories in time instead, see CompositeTrajectory.</p>
<p>All of the underlying Trajectory objects must have the same
<code class="docutils literal notranslate"><span class="pre">%start_time()</span></code> and <code class="docutils literal notranslate"><span class="pre">%end_time()</span></code>.</p>
<p>When constructed with <code class="docutils literal notranslate"><span class="pre">rowwise</span></code> set to true, all of the underlying
Trajectory objects must have the same number of <code class="docutils literal notranslate"><span class="pre">%cols()</span></code> and the
<code class="docutils literal notranslate"><span class="pre">value()</span></code> matrix will be the <strong>vstack</strong> of the the trajectories in
the order they were added.</p>
<p>When constructed with <code class="docutils literal notranslate"><span class="pre">rowwise</span></code> set to false, all of the underlying
Trajectory objects must have the same number of <code class="docutils literal notranslate"><span class="pre">%rows()</span></code> and the
<code class="docutils literal notranslate"><span class="pre">value()</span></code> matrix will be the <strong>hstack</strong> of the the trajectories in
the order they were added.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.StackedTrajectory_-AutoDiffXd-.__init__">
<span id="pydrake.trajectories.StackedTrajectory_[AutoDiffXd].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.StackedTrajectory_" title="pydrake.trajectories.StackedTrajectory_"><span class="pre">pydrake.trajectories.StackedTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rowwise</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.StackedTrajectory_-AutoDiffXd-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Creates an empty trajectory.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rowwise</span></code>:</dt><dd><p>governs the stacking order</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.StackedTrajectory_-AutoDiffXd-.Append">
<span id="pydrake.trajectories.StackedTrajectory_[AutoDiffXd].Append"></span><span class="sig-name descname"><span class="pre">Append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.StackedTrajectory_" title="pydrake.trajectories.StackedTrajectory_"><span class="pre">pydrake.trajectories.StackedTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.StackedTrajectory_-AutoDiffXd-.Append" title="Permalink to this definition"></a></dt>
<dd><p>Stacks another sub-Trajectory onto this. Refer to the class overview
documentation for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the matrix dimension is incompatible.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.StackedTrajectory_-Expression">
<span id="pydrake.trajectories.StackedTrajectory_[Expression]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">StackedTrajectory_[Expression]</span></span><a class="headerlink" href="#pydrake.trajectories.StackedTrajectory_-Expression" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.Trajectory_-Expression" title="pydrake.trajectories.Trajectory_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[Expression]</span></code></a></p>
<p>A StackedTrajectory stacks the values from one or more underlying
Trajectory objects into a single Trajectory, without changing the
<code class="docutils literal notranslate"><span class="pre">%start_time()</span></code> or <code class="docutils literal notranslate"><span class="pre">%end_time()</span></code>.</p>
<p>For sequencing trajectories in time instead, see CompositeTrajectory.</p>
<p>All of the underlying Trajectory objects must have the same
<code class="docutils literal notranslate"><span class="pre">%start_time()</span></code> and <code class="docutils literal notranslate"><span class="pre">%end_time()</span></code>.</p>
<p>When constructed with <code class="docutils literal notranslate"><span class="pre">rowwise</span></code> set to true, all of the underlying
Trajectory objects must have the same number of <code class="docutils literal notranslate"><span class="pre">%cols()</span></code> and the
<code class="docutils literal notranslate"><span class="pre">value()</span></code> matrix will be the <strong>vstack</strong> of the the trajectories in
the order they were added.</p>
<p>When constructed with <code class="docutils literal notranslate"><span class="pre">rowwise</span></code> set to false, all of the underlying
Trajectory objects must have the same number of <code class="docutils literal notranslate"><span class="pre">%rows()</span></code> and the
<code class="docutils literal notranslate"><span class="pre">value()</span></code> matrix will be the <strong>hstack</strong> of the the trajectories in
the order they were added.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.StackedTrajectory_-Expression-.__init__">
<span id="pydrake.trajectories.StackedTrajectory_[Expression].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.StackedTrajectory_" title="pydrake.trajectories.StackedTrajectory_"><span class="pre">pydrake.trajectories.StackedTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rowwise</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.StackedTrajectory_-Expression-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Creates an empty trajectory.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rowwise</span></code>:</dt><dd><p>governs the stacking order</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.StackedTrajectory_-Expression-.Append">
<span id="pydrake.trajectories.StackedTrajectory_[Expression].Append"></span><span class="sig-name descname"><span class="pre">Append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.StackedTrajectory_" title="pydrake.trajectories.StackedTrajectory_"><span class="pre">pydrake.trajectories.StackedTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.StackedTrajectory_-Expression-.Append" title="Permalink to this definition"></a></dt>
<dd><p>Stacks another sub-Trajectory onto this. Refer to the class overview
documentation for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the matrix dimension is incompatible.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">Trajectory</span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory" title="Permalink to this definition"></a></dt>
<dd><p>A Trajectory represents a time-varying matrix, indexed by a single
scalar time.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><code class="xref py py-class docutils literal notranslate"><span class="pre">Trajectory_</span></code></a>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory" title="pydrake.trajectories.Trajectory"><span class="pre">pydrake.trajectories.Trajectory</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory.Clone">
<span class="sig-name descname"><span class="pre">Clone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory" title="pydrake.trajectories.Trajectory"><span class="pre">pydrake.trajectories.Trajectory</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory" title="pydrake.trajectories.Trajectory"><span class="pre">pydrake.trajectories.Trajectory</span></a></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory.Clone" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory.cols">
<span class="sig-name descname"><span class="pre">cols</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory" title="pydrake.trajectories.Trajectory"><span class="pre">pydrake.trajectories.Trajectory</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory.cols" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The number of columns in the matrix returned by value().</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Support for overriding this as a virtual function is deprecated
and will be removed on or after 2025-08-01. Subclasses should
override the protected function do_cols(), instead.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory.end_time">
<span class="sig-name descname"><span class="pre">end_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory" title="pydrake.trajectories.Trajectory"><span class="pre">pydrake.trajectories.Trajectory</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory.end_time" title="Permalink to this definition"></a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Support for overriding this as a virtual function is deprecated
and will be removed on or after 2025-08-01. Subclasses should
override the protected function do_end_time(), instead.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory.EvalDerivative">
<span class="sig-name descname"><span class="pre">EvalDerivative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory" title="pydrake.trajectories.Trajectory"><span class="pre">pydrake.trajectories.Trajectory</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derivative_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory.EvalDerivative" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates the derivative of <code class="docutils literal notranslate"><span class="pre">this</span></code> at the given time <code class="docutils literal notranslate"><span class="pre">t</span></code>. Returns
the nth derivative, where <code class="docutils literal notranslate"><span class="pre">n</span></code> is the value of <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if derivative_order is negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory.has_derivative">
<span class="sig-name descname"><span class="pre">has_derivative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory" title="pydrake.trajectories.Trajectory"><span class="pre">pydrake.trajectories.Trajectory</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory.has_derivative" title="Permalink to this definition"></a></dt>
<dd><p>Returns true iff the Trajectory provides and implementation for
EvalDerivative() and MakeDerivative(). The derivative need not be
continuous, but should return a result for all t for which value(t)
returns a result.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory.MakeDerivative">
<span class="sig-name descname"><span class="pre">MakeDerivative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory" title="pydrake.trajectories.Trajectory"><span class="pre">pydrake.trajectories.Trajectory</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">derivative_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory" title="pydrake.trajectories.Trajectory"><span class="pre">pydrake.trajectories.Trajectory</span></a></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory.MakeDerivative" title="Permalink to this definition"></a></dt>
<dd><p>Takes the derivative of this Trajectory.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code>:</dt><dd><p>The number of times to take the derivative before returning.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The nth derivative of this object.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>RuntimeError if derivative_order is negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory.rows">
<span class="sig-name descname"><span class="pre">rows</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory" title="pydrake.trajectories.Trajectory"><span class="pre">pydrake.trajectories.Trajectory</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory.rows" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The number of rows in the matrix returned by value().</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Support for overriding this as a virtual function is deprecated
and will be removed on or after 2025-08-01. Subclasses should
override the protected function do_rows(), instead.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory.start_time">
<span class="sig-name descname"><span class="pre">start_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory" title="pydrake.trajectories.Trajectory"><span class="pre">pydrake.trajectories.Trajectory</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory.start_time" title="Permalink to this definition"></a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Support for overriding this as a virtual function is deprecated
and will be removed on or after 2025-08-01. Subclasses should
override the protected function do_start_time(), instead.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory.value">
<span class="sig-name descname"><span class="pre">value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory" title="pydrake.trajectories.Trajectory"><span class="pre">pydrake.trajectories.Trajectory</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory.value" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates the trajectory at the given time <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">t</span></code>:</dt><dd><p>The time at which to evaluate the trajectory.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The matrix of evaluated values.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Support for overriding this as a virtual function is deprecated
and will be removed on or after 2025-08-01. Subclasses should
override the protected function do_value(), instead.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory.vector_values">
<span class="sig-name descname"><span class="pre">vector_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory" title="pydrake.trajectories.Trajectory"><span class="pre">pydrake.trajectories.Trajectory</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory.vector_values" title="Permalink to this definition"></a></dt>
<dd><p>If cols()==1, then evaluates the trajectory at each time <code class="docutils literal notranslate"><span class="pre">t</span></code>, and
returns the results as a Matrix with the ith column corresponding to
the ith time. Otherwise, if rows()==1, then evaluates the trajectory
at each time <code class="docutils literal notranslate"><span class="pre">t</span></code>, and returns the results as a Matrix with the ith
row corresponding to the ith time.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if both cols and rows are not equal to 1.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">Trajectory_</span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">Trajectory_[float]</span></code>, <a class="reference internal" href="#pydrake.trajectories.Trajectory_-AutoDiffXd" title="pydrake.trajectories.Trajectory_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Trajectory_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.trajectories.Trajectory_-Expression" title="pydrake.trajectories.Trajectory_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Trajectory_[Expression]</span></code></a></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-AutoDiffXd">
<span id="pydrake.trajectories.Trajectory_[AutoDiffXd]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">Trajectory_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><p>A Trajectory represents a time-varying matrix, indexed by a single
scalar time.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-AutoDiffXd-.__init__">
<span id="pydrake.trajectories.Trajectory_[AutoDiffXd].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-AutoDiffXd-.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-AutoDiffXd-.Clone">
<span id="pydrake.trajectories.Trajectory_[AutoDiffXd].Clone"></span><span class="sig-name descname"><span class="pre">Clone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-AutoDiffXd-.Clone" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-AutoDiffXd-.cols">
<span id="pydrake.trajectories.Trajectory_[AutoDiffXd].cols"></span><span class="sig-name descname"><span class="pre">cols</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-AutoDiffXd-.cols" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The number of columns in the matrix returned by value().</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Support for overriding this as a virtual function is deprecated
and will be removed on or after 2025-08-01. Subclasses should
override the protected function do_cols(), instead.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-AutoDiffXd-.end_time">
<span id="pydrake.trajectories.Trajectory_[AutoDiffXd].end_time"></span><span class="sig-name descname"><span class="pre">end_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-AutoDiffXd-.end_time" title="Permalink to this definition"></a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Support for overriding this as a virtual function is deprecated
and will be removed on or after 2025-08-01. Subclasses should
override the protected function do_end_time(), instead.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-AutoDiffXd-.EvalDerivative">
<span id="pydrake.trajectories.Trajectory_[AutoDiffXd].EvalDerivative"></span><span class="sig-name descname"><span class="pre">EvalDerivative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">derivative_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-AutoDiffXd-.EvalDerivative" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates the derivative of <code class="docutils literal notranslate"><span class="pre">this</span></code> at the given time <code class="docutils literal notranslate"><span class="pre">t</span></code>. Returns
the nth derivative, where <code class="docutils literal notranslate"><span class="pre">n</span></code> is the value of <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if derivative_order is negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-AutoDiffXd-.has_derivative">
<span id="pydrake.trajectories.Trajectory_[AutoDiffXd].has_derivative"></span><span class="sig-name descname"><span class="pre">has_derivative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-AutoDiffXd-.has_derivative" title="Permalink to this definition"></a></dt>
<dd><p>Returns true iff the Trajectory provides and implementation for
EvalDerivative() and MakeDerivative(). The derivative need not be
continuous, but should return a result for all t for which value(t)
returns a result.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-AutoDiffXd-.MakeDerivative">
<span id="pydrake.trajectories.Trajectory_[AutoDiffXd].MakeDerivative"></span><span class="sig-name descname"><span class="pre">MakeDerivative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derivative_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-AutoDiffXd-.MakeDerivative" title="Permalink to this definition"></a></dt>
<dd><p>Takes the derivative of this Trajectory.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code>:</dt><dd><p>The number of times to take the derivative before returning.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The nth derivative of this object.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>RuntimeError if derivative_order is negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-AutoDiffXd-.rows">
<span id="pydrake.trajectories.Trajectory_[AutoDiffXd].rows"></span><span class="sig-name descname"><span class="pre">rows</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-AutoDiffXd-.rows" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The number of rows in the matrix returned by value().</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Support for overriding this as a virtual function is deprecated
and will be removed on or after 2025-08-01. Subclasses should
override the protected function do_rows(), instead.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-AutoDiffXd-.start_time">
<span id="pydrake.trajectories.Trajectory_[AutoDiffXd].start_time"></span><span class="sig-name descname"><span class="pre">start_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-AutoDiffXd-.start_time" title="Permalink to this definition"></a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Support for overriding this as a virtual function is deprecated
and will be removed on or after 2025-08-01. Subclasses should
override the protected function do_start_time(), instead.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-AutoDiffXd-.value">
<span id="pydrake.trajectories.Trajectory_[AutoDiffXd].value"></span><span class="sig-name descname"><span class="pre">value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-AutoDiffXd-.value" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates the trajectory at the given time <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">t</span></code>:</dt><dd><p>The time at which to evaluate the trajectory.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The matrix of evaluated values.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Support for overriding this as a virtual function is deprecated
and will be removed on or after 2025-08-01. Subclasses should
override the protected function do_value(), instead.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-AutoDiffXd-.vector_values">
<span id="pydrake.trajectories.Trajectory_[AutoDiffXd].vector_values"></span><span class="sig-name descname"><span class="pre">vector_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-AutoDiffXd-.vector_values" title="Permalink to this definition"></a></dt>
<dd><p>If cols()==1, then evaluates the trajectory at each time <code class="docutils literal notranslate"><span class="pre">t</span></code>, and
returns the results as a Matrix with the ith column corresponding to
the ith time. Otherwise, if rows()==1, then evaluates the trajectory
at each time <code class="docutils literal notranslate"><span class="pre">t</span></code>, and returns the results as a Matrix with the ith
row corresponding to the ith time.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if both cols and rows are not equal to 1.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-Expression">
<span id="pydrake.trajectories.Trajectory_[Expression]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">Trajectory_[Expression]</span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-Expression" title="Permalink to this definition"></a></dt>
<dd><p>A Trajectory represents a time-varying matrix, indexed by a single
scalar time.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-Expression-.__init__">
<span id="pydrake.trajectories.Trajectory_[Expression].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-Expression-.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-Expression-.Clone">
<span id="pydrake.trajectories.Trajectory_[Expression].Clone"></span><span class="sig-name descname"><span class="pre">Clone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-Expression-.Clone" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-Expression-.cols">
<span id="pydrake.trajectories.Trajectory_[Expression].cols"></span><span class="sig-name descname"><span class="pre">cols</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-Expression-.cols" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The number of columns in the matrix returned by value().</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Support for overriding this as a virtual function is deprecated
and will be removed on or after 2025-08-01. Subclasses should
override the protected function do_cols(), instead.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-Expression-.end_time">
<span id="pydrake.trajectories.Trajectory_[Expression].end_time"></span><span class="sig-name descname"><span class="pre">end_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-Expression-.end_time" title="Permalink to this definition"></a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Support for overriding this as a virtual function is deprecated
and will be removed on or after 2025-08-01. Subclasses should
override the protected function do_end_time(), instead.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-Expression-.EvalDerivative">
<span id="pydrake.trajectories.Trajectory_[Expression].EvalDerivative"></span><span class="sig-name descname"><span class="pre">EvalDerivative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">derivative_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-Expression-.EvalDerivative" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates the derivative of <code class="docutils literal notranslate"><span class="pre">this</span></code> at the given time <code class="docutils literal notranslate"><span class="pre">t</span></code>. Returns
the nth derivative, where <code class="docutils literal notranslate"><span class="pre">n</span></code> is the value of <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if derivative_order is negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-Expression-.has_derivative">
<span id="pydrake.trajectories.Trajectory_[Expression].has_derivative"></span><span class="sig-name descname"><span class="pre">has_derivative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-Expression-.has_derivative" title="Permalink to this definition"></a></dt>
<dd><p>Returns true iff the Trajectory provides and implementation for
EvalDerivative() and MakeDerivative(). The derivative need not be
continuous, but should return a result for all t for which value(t)
returns a result.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-Expression-.MakeDerivative">
<span id="pydrake.trajectories.Trajectory_[Expression].MakeDerivative"></span><span class="sig-name descname"><span class="pre">MakeDerivative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derivative_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-Expression-.MakeDerivative" title="Permalink to this definition"></a></dt>
<dd><p>Takes the derivative of this Trajectory.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code>:</dt><dd><p>The number of times to take the derivative before returning.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The nth derivative of this object.</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>RuntimeError if derivative_order is negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-Expression-.rows">
<span id="pydrake.trajectories.Trajectory_[Expression].rows"></span><span class="sig-name descname"><span class="pre">rows</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-Expression-.rows" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The number of rows in the matrix returned by value().</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Support for overriding this as a virtual function is deprecated
and will be removed on or after 2025-08-01. Subclasses should
override the protected function do_rows(), instead.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-Expression-.start_time">
<span id="pydrake.trajectories.Trajectory_[Expression].start_time"></span><span class="sig-name descname"><span class="pre">start_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-Expression-.start_time" title="Permalink to this definition"></a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Support for overriding this as a virtual function is deprecated
and will be removed on or after 2025-08-01. Subclasses should
override the protected function do_start_time(), instead.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-Expression-.value">
<span id="pydrake.trajectories.Trajectory_[Expression].value"></span><span class="sig-name descname"><span class="pre">value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-Expression-.value" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates the trajectory at the given time <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">t</span></code>:</dt><dd><p>The time at which to evaluate the trajectory.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The matrix of evaluated values.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Support for overriding this as a virtual function is deprecated
and will be removed on or after 2025-08-01. Subclasses should
override the protected function do_value(), instead.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-Expression-.vector_values">
<span id="pydrake.trajectories.Trajectory_[Expression].vector_values"></span><span class="sig-name descname"><span class="pre">vector_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-Expression-.vector_values" title="Permalink to this definition"></a></dt>
<dd><p>If cols()==1, then evaluates the trajectory at each time <code class="docutils literal notranslate"><span class="pre">t</span></code>, and
returns the results as a Matrix with the ith column corresponding to
the ith time. Otherwise, if rows()==1, then evaluates the trajectory
at each time <code class="docutils literal notranslate"><span class="pre">t</span></code>, and returns the results as a Matrix with the ith
row corresponding to the ith time.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if both cols and rows are not equal to 1.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="pydrake.systems.sensors.html" class="btn btn-neutral float-left" title="pydrake.systems.sensors" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="pydrake.tutorials.html" class="btn btn-neutral float-right" title="pydrake.tutorials" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p></p>
  </div>

  
</footer>
<script>
  /* Enables clicking for the mobile "hamburger" (three-line) menu item. */
  const siteHeader = document.querySelector('.site-header')
  const mobileButton = document.querySelector('.menu-mobile-toggle')
  const body = document.querySelector('body')

  mobileButton.addEventListener('click', function(event) {
    siteHeader.classList.toggle('open');
    body.classList.toggle('overflow-hidden');
  })
</script>
<footer class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg">
    </a>
    <div class="footer-menu">
      <ul>
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"></a>
        </li>
      </ul>
    </div>
  </div>


</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>