<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pydrake.trajectories &mdash; pydrake  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="pydrake.tutorials" href="pydrake.tutorials.html" />
    <link rel="prev" title="pydrake.systems.trajectory_optimization" href="pydrake.systems.trajectory_optimization.html" /> 
</head>

<body class="wy-body-for-nav">
<header class="site-header">
  <div class="site-header-inner contain">
    <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
    <div class="menu-mobile-toggle">
      <span></span>
    </div>
    <nav class="site-menu">
      <ul>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/">Home</a>
        </li>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/installation.html">Installation</a>
        </li>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/gallery.html">Gallery</a>
        </li>
        <li class="site-menu-item site-menu-item-main">API Documentation
          <div class="sub">
            <a class="site-menu-item" href="https://drake.mit.edu/doxygen_cxx/index.html">C++</a> <a class="site-menu-item" href="https://drake.mit.edu/pydrake/index.html">Python</a>
          </div>
        </li>
        <li class="site-menu-item site-menu-item-main">Resources
          <div class="sub">
            <a class="site-menu-item" href="/getting_help.html">Getting Help</a> <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/%2Findex.ipynb">Tutorials</a> <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a> <a class="site-menu-item" href="/developers.html">For Developers</a> <a class="site-menu-item" href="/credits.html">Credits</a>
          </div>
        </li>
        <li class="github-link">
          <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
        </li>
      </ul>
    </nav>
  </div>
</header>

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> pydrake
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search pydrake only…" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
  <form id="ddg-search-form" class="wy_form" action="https://duckduckgo.com/" method="get">
    <input type="text" name="q" placeholder="Search all of Drake…" />
    <input type="hidden" name="sites" value="drake.mit.edu" />
  </form>
</div>

        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="pydrake.all.html">pydrake.all</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.autodiffutils.html">pydrake.autodiffutils</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.common.html">pydrake.common</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.examples.html">pydrake.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.forwarddiff.html">pydrake.forwarddiff</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.geometry.html">pydrake.geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.lcm.html">pydrake.lcm</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.manipulation.html">pydrake.manipulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.math.html">pydrake.math</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.multibody.html">pydrake.multibody</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.perception.html">pydrake.perception</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.polynomial.html">pydrake.polynomial</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.html">pydrake.solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.symbolic.html">pydrake.symbolic</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.systems.html">pydrake.systems</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">pydrake.trajectories</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.tutorials.html">pydrake.tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.visualization.html">pydrake.visualization</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pydrake</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>pydrake.trajectories</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-pydrake.trajectories">
<span id="pydrake-trajectories"></span><h1>pydrake.trajectories<a class="headerlink" href="#module-pydrake.trajectories" title="Permalink to this headline"></a></h1>
<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory">
<span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">BsplineTrajectory</span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory" title="Permalink to this definition"></a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_-float" title="pydrake.trajectories.BsplineTrajectory_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.BsplineTrajectory_[float]</span></code></a></p>
</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">BsplineTrajectory_</span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_-float" title="pydrake.trajectories.BsplineTrajectory_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">BsplineTrajectory_[float]</span></code></a>, <a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_-AutoDiffXd" title="pydrake.trajectories.BsplineTrajectory_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">BsplineTrajectory_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_-Expression" title="pydrake.trajectories.BsplineTrajectory_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">BsplineTrajectory_[Expression]</span></code></a></p>
<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_.BsplineTrajectory_-float">
<span id="pydrake.trajectories.BsplineTrajectory_.BsplineTrajectory_[float]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">BsplineTrajectory_[float]</span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_.BsplineTrajectory_-float" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.Trajectory_-float" title="pydrake.trajectories.Trajectory_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[float]</span></code></a></p>
<p>Represents a B-spline curve using a given <code class="docutils literal notranslate"><span class="pre">basis</span></code> with ordered
<code class="docutils literal notranslate"><span class="pre">control_points</span></code> such that each control point is a matrix in ℝʳᵒʷˢ ˣ
ᶜᵒˡˢ.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>math::BsplineBasis</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_.BsplineTrajectory_-float-.__init__">
<span id="pydrake.trajectories.BsplineTrajectory_.BsplineTrajectory_[float].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_.BsplineTrajectory_-float-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.BsplineTrajectory_[float]) -&gt; None</p></li>
<li><p>__init__(self: pydrake.trajectories.BsplineTrajectory_[float], basis: pydrake.math.BsplineBasis_[float], control_points: List[List[float]]) -&gt; None</p></li>
</ol>
<p>Constructs a B-spline trajectory with the given <code class="docutils literal notranslate"><span class="pre">basis</span></code> and
<code class="docutils literal notranslate"><span class="pre">control_points</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>control_points.size() == basis.num_basis_functions()</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.trajectories.BsplineTrajectory_[float], basis: pydrake.math.BsplineBasis_[float], control_points: List[numpy.ndarray[numpy.float64[m, n]]]) -&gt; None</p></li>
</ol>
<p>Constructs a B-spline trajectory with the given <code class="docutils literal notranslate"><span class="pre">basis</span></code> and
<code class="docutils literal notranslate"><span class="pre">control_points</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>control_points.size() == basis.num_basis_functions()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_.BsplineTrajectory_-float-.basis">
<span id="pydrake.trajectories.BsplineTrajectory_.BsplineTrajectory_[float].basis"></span><span class="sig-name descname"><span class="pre">basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.math.html#pydrake.math.BsplineBasis_" title="pydrake.math.BsplineBasis_"><span class="pre">pydrake.math.BsplineBasis_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_.BsplineTrajectory_-float-.basis" title="Permalink to this definition"></a></dt>
<dd><p>Returns the basis of this curve.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_.BsplineTrajectory_-float-.Clone">
<span id="pydrake.trajectories.BsplineTrajectory_.BsplineTrajectory_[float].Clone"></span><span class="sig-name descname"><span class="pre">Clone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_.BsplineTrajectory_-float-.Clone" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_.BsplineTrajectory_-float-.control_points">
<span id="pydrake.trajectories.BsplineTrajectory_.BsplineTrajectory_[float].control_points"></span><span class="sig-name descname"><span class="pre">control_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_.BsplineTrajectory_-float-.control_points" title="Permalink to this definition"></a></dt>
<dd><p>Returns the control points of this curve.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_.BsplineTrajectory_-float-.CopyBlock">
<span id="pydrake.trajectories.BsplineTrajectory_.BsplineTrajectory_[float].CopyBlock"></span><span class="sig-name descname"><span class="pre">CopyBlock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_row</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_rows</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_cols</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_.BsplineTrajectory_-float-.CopyBlock" title="Permalink to this definition"></a></dt>
<dd><p>Returns a new BsplineTrajectory that uses the same basis as <code class="docutils literal notranslate"><span class="pre">this</span></code>,
and whose control points are the result of calling
<code class="docutils literal notranslate"><span class="pre">point.block(start_row,</span> <span class="pre">start_col,</span> <span class="pre">block_rows,</span> <span class="pre">block_cols)</span></code> on each
<code class="docutils literal notranslate"><span class="pre">point</span></code> in <code class="docutils literal notranslate"><span class="pre">this-&gt;control_points()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_.BsplineTrajectory_-float-.CopyHead">
<span id="pydrake.trajectories.BsplineTrajectory_.BsplineTrajectory_[float].CopyHead"></span><span class="sig-name descname"><span class="pre">CopyHead</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_.BsplineTrajectory_-float-.CopyHead" title="Permalink to this definition"></a></dt>
<dd><p>Returns a new BsplineTrajectory that uses the same basis as <code class="docutils literal notranslate"><span class="pre">this</span></code>,
and whose control points are the result of calling <code class="docutils literal notranslate"><span class="pre">point.head(n)</span></code>
on each <code class="docutils literal notranslate"><span class="pre">point</span></code> in <code class="docutils literal notranslate"><span class="pre">this-&gt;control_points()</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>this-&gt;cols() == 1</p>
</dd>
<dt>Precondition:</dt><dd><p>control_points()[0].head(n) must be a valid operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_.BsplineTrajectory_-float-.FinalValue">
<span id="pydrake.trajectories.BsplineTrajectory_.BsplineTrajectory_[float].FinalValue"></span><span class="sig-name descname"><span class="pre">FinalValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_.BsplineTrajectory_-float-.FinalValue" title="Permalink to this definition"></a></dt>
<dd><p>Returns this-&gt;value(this-&gt;end_time())</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_.BsplineTrajectory_-float-.InitialValue">
<span id="pydrake.trajectories.BsplineTrajectory_.BsplineTrajectory_[float].InitialValue"></span><span class="sig-name descname"><span class="pre">InitialValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_.BsplineTrajectory_-float-.InitialValue" title="Permalink to this definition"></a></dt>
<dd><p>Returns this-&gt;value(this-&gt;start_time())</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_.BsplineTrajectory_-float-.InsertKnots">
<span id="pydrake.trajectories.BsplineTrajectory_.BsplineTrajectory_[float].InsertKnots"></span><span class="sig-name descname"><span class="pre">InsertKnots</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">additional_knots</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_.BsplineTrajectory_-float-.InsertKnots" title="Permalink to this definition"></a></dt>
<dd><p>Adds new knots at the specified <code class="docutils literal notranslate"><span class="pre">additional_knots</span></code> without changing
the behavior of the trajectory. The basis and control points of the
trajectory are adjusted such that it produces the same value for any
valid time before and after this method is called. The resulting
trajectory is guaranteed to have the same level of continuity as the
original, even if knot values are duplicated. Note that
<code class="docutils literal notranslate"><span class="pre">additional_knots</span></code> need not be sorted.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>start_time() &lt;= t &lt;= end_time() for all t in <code class="docutils literal notranslate"><span class="pre">additional_knots</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_.BsplineTrajectory_-float-.num_control_points">
<span id="pydrake.trajectories.BsplineTrajectory_.BsplineTrajectory_[float].num_control_points"></span><span class="sig-name descname"><span class="pre">num_control_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_.BsplineTrajectory_-float-.num_control_points" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of control points in this curve.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-AutoDiffXd">
<span id="pydrake.trajectories.BsplineTrajectory_[AutoDiffXd]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">BsplineTrajectory_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.Trajectory_-AutoDiffXd" title="pydrake.trajectories.Trajectory_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[AutoDiffXd]</span></code></a></p>
<p>Represents a B-spline curve using a given <code class="docutils literal notranslate"><span class="pre">basis</span></code> with ordered
<code class="docutils literal notranslate"><span class="pre">control_points</span></code> such that each control point is a matrix in ℝʳᵒʷˢ ˣ
ᶜᵒˡˢ.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>math::BsplineBasis</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-AutoDiffXd-.__init__">
<span id="pydrake.trajectories.BsplineTrajectory_[AutoDiffXd].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-AutoDiffXd-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.BsplineTrajectory_[AutoDiffXd]) -&gt; None</p></li>
<li><p>__init__(self: pydrake.trajectories.BsplineTrajectory_[AutoDiffXd], basis: pydrake.math.BsplineBasis_[AutoDiffXd], control_points: List[List[pydrake.autodiffutils.AutoDiffXd]]) -&gt; None</p></li>
</ol>
<p>Constructs a B-spline trajectory with the given <code class="docutils literal notranslate"><span class="pre">basis</span></code> and
<code class="docutils literal notranslate"><span class="pre">control_points</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>control_points.size() == basis.num_basis_functions()</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.trajectories.BsplineTrajectory_[AutoDiffXd], basis: pydrake.math.BsplineBasis_[AutoDiffXd], control_points: List[numpy.ndarray[object[m, n]]]) -&gt; None</p></li>
</ol>
<p>Constructs a B-spline trajectory with the given <code class="docutils literal notranslate"><span class="pre">basis</span></code> and
<code class="docutils literal notranslate"><span class="pre">control_points</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>control_points.size() == basis.num_basis_functions()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-AutoDiffXd-.basis">
<span id="pydrake.trajectories.BsplineTrajectory_[AutoDiffXd].basis"></span><span class="sig-name descname"><span class="pre">basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.math.html#pydrake.math.BsplineBasis_" title="pydrake.math.BsplineBasis_"><span class="pre">pydrake.math.BsplineBasis_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-AutoDiffXd-.basis" title="Permalink to this definition"></a></dt>
<dd><p>Returns the basis of this curve.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-AutoDiffXd-.Clone">
<span id="pydrake.trajectories.BsplineTrajectory_[AutoDiffXd].Clone"></span><span class="sig-name descname"><span class="pre">Clone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-AutoDiffXd-.Clone" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-AutoDiffXd-.control_points">
<span id="pydrake.trajectories.BsplineTrajectory_[AutoDiffXd].control_points"></span><span class="sig-name descname"><span class="pre">control_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-AutoDiffXd-.control_points" title="Permalink to this definition"></a></dt>
<dd><p>Returns the control points of this curve.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-AutoDiffXd-.CopyBlock">
<span id="pydrake.trajectories.BsplineTrajectory_[AutoDiffXd].CopyBlock"></span><span class="sig-name descname"><span class="pre">CopyBlock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_row</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_rows</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_cols</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-AutoDiffXd-.CopyBlock" title="Permalink to this definition"></a></dt>
<dd><p>Returns a new BsplineTrajectory that uses the same basis as <code class="docutils literal notranslate"><span class="pre">this</span></code>,
and whose control points are the result of calling
<code class="docutils literal notranslate"><span class="pre">point.block(start_row,</span> <span class="pre">start_col,</span> <span class="pre">block_rows,</span> <span class="pre">block_cols)</span></code> on each
<code class="docutils literal notranslate"><span class="pre">point</span></code> in <code class="docutils literal notranslate"><span class="pre">this-&gt;control_points()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-AutoDiffXd-.CopyHead">
<span id="pydrake.trajectories.BsplineTrajectory_[AutoDiffXd].CopyHead"></span><span class="sig-name descname"><span class="pre">CopyHead</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-AutoDiffXd-.CopyHead" title="Permalink to this definition"></a></dt>
<dd><p>Returns a new BsplineTrajectory that uses the same basis as <code class="docutils literal notranslate"><span class="pre">this</span></code>,
and whose control points are the result of calling <code class="docutils literal notranslate"><span class="pre">point.head(n)</span></code>
on each <code class="docutils literal notranslate"><span class="pre">point</span></code> in <code class="docutils literal notranslate"><span class="pre">this-&gt;control_points()</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>this-&gt;cols() == 1</p>
</dd>
<dt>Precondition:</dt><dd><p>control_points()[0].head(n) must be a valid operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-AutoDiffXd-.FinalValue">
<span id="pydrake.trajectories.BsplineTrajectory_[AutoDiffXd].FinalValue"></span><span class="sig-name descname"><span class="pre">FinalValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-AutoDiffXd-.FinalValue" title="Permalink to this definition"></a></dt>
<dd><p>Returns this-&gt;value(this-&gt;end_time())</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-AutoDiffXd-.InitialValue">
<span id="pydrake.trajectories.BsplineTrajectory_[AutoDiffXd].InitialValue"></span><span class="sig-name descname"><span class="pre">InitialValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-AutoDiffXd-.InitialValue" title="Permalink to this definition"></a></dt>
<dd><p>Returns this-&gt;value(this-&gt;start_time())</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-AutoDiffXd-.InsertKnots">
<span id="pydrake.trajectories.BsplineTrajectory_[AutoDiffXd].InsertKnots"></span><span class="sig-name descname"><span class="pre">InsertKnots</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">additional_knots</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-AutoDiffXd-.InsertKnots" title="Permalink to this definition"></a></dt>
<dd><p>Adds new knots at the specified <code class="docutils literal notranslate"><span class="pre">additional_knots</span></code> without changing
the behavior of the trajectory. The basis and control points of the
trajectory are adjusted such that it produces the same value for any
valid time before and after this method is called. The resulting
trajectory is guaranteed to have the same level of continuity as the
original, even if knot values are duplicated. Note that
<code class="docutils literal notranslate"><span class="pre">additional_knots</span></code> need not be sorted.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>start_time() &lt;= t &lt;= end_time() for all t in <code class="docutils literal notranslate"><span class="pre">additional_knots</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-AutoDiffXd-.num_control_points">
<span id="pydrake.trajectories.BsplineTrajectory_[AutoDiffXd].num_control_points"></span><span class="sig-name descname"><span class="pre">num_control_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-AutoDiffXd-.num_control_points" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of control points in this curve.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-Expression">
<span id="pydrake.trajectories.BsplineTrajectory_[Expression]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">BsplineTrajectory_[Expression]</span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-Expression" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.Trajectory_-Expression" title="pydrake.trajectories.Trajectory_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[Expression]</span></code></a></p>
<p>Represents a B-spline curve using a given <code class="docutils literal notranslate"><span class="pre">basis</span></code> with ordered
<code class="docutils literal notranslate"><span class="pre">control_points</span></code> such that each control point is a matrix in ℝʳᵒʷˢ ˣ
ᶜᵒˡˢ.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>math::BsplineBasis</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-Expression-.__init__">
<span id="pydrake.trajectories.BsplineTrajectory_[Expression].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-Expression-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.BsplineTrajectory_[Expression]) -&gt; None</p></li>
<li><p>__init__(self: pydrake.trajectories.BsplineTrajectory_[Expression], basis: pydrake.math.BsplineBasis_[Expression], control_points: List[List[pydrake.symbolic.Expression]]) -&gt; None</p></li>
</ol>
<p>Constructs a B-spline trajectory with the given <code class="docutils literal notranslate"><span class="pre">basis</span></code> and
<code class="docutils literal notranslate"><span class="pre">control_points</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>control_points.size() == basis.num_basis_functions()</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.trajectories.BsplineTrajectory_[Expression], basis: pydrake.math.BsplineBasis_[Expression], control_points: List[numpy.ndarray[object[m, n]]]) -&gt; None</p></li>
</ol>
<p>Constructs a B-spline trajectory with the given <code class="docutils literal notranslate"><span class="pre">basis</span></code> and
<code class="docutils literal notranslate"><span class="pre">control_points</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>control_points.size() == basis.num_basis_functions()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-Expression-.basis">
<span id="pydrake.trajectories.BsplineTrajectory_[Expression].basis"></span><span class="sig-name descname"><span class="pre">basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.math.html#pydrake.math.BsplineBasis_" title="pydrake.math.BsplineBasis_"><span class="pre">pydrake.math.BsplineBasis_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-Expression-.basis" title="Permalink to this definition"></a></dt>
<dd><p>Returns the basis of this curve.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-Expression-.Clone">
<span id="pydrake.trajectories.BsplineTrajectory_[Expression].Clone"></span><span class="sig-name descname"><span class="pre">Clone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-Expression-.Clone" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-Expression-.control_points">
<span id="pydrake.trajectories.BsplineTrajectory_[Expression].control_points"></span><span class="sig-name descname"><span class="pre">control_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-Expression-.control_points" title="Permalink to this definition"></a></dt>
<dd><p>Returns the control points of this curve.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-Expression-.CopyBlock">
<span id="pydrake.trajectories.BsplineTrajectory_[Expression].CopyBlock"></span><span class="sig-name descname"><span class="pre">CopyBlock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_row</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_rows</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_cols</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-Expression-.CopyBlock" title="Permalink to this definition"></a></dt>
<dd><p>Returns a new BsplineTrajectory that uses the same basis as <code class="docutils literal notranslate"><span class="pre">this</span></code>,
and whose control points are the result of calling
<code class="docutils literal notranslate"><span class="pre">point.block(start_row,</span> <span class="pre">start_col,</span> <span class="pre">block_rows,</span> <span class="pre">block_cols)</span></code> on each
<code class="docutils literal notranslate"><span class="pre">point</span></code> in <code class="docutils literal notranslate"><span class="pre">this-&gt;control_points()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-Expression-.CopyHead">
<span id="pydrake.trajectories.BsplineTrajectory_[Expression].CopyHead"></span><span class="sig-name descname"><span class="pre">CopyHead</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-Expression-.CopyHead" title="Permalink to this definition"></a></dt>
<dd><p>Returns a new BsplineTrajectory that uses the same basis as <code class="docutils literal notranslate"><span class="pre">this</span></code>,
and whose control points are the result of calling <code class="docutils literal notranslate"><span class="pre">point.head(n)</span></code>
on each <code class="docutils literal notranslate"><span class="pre">point</span></code> in <code class="docutils literal notranslate"><span class="pre">this-&gt;control_points()</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>this-&gt;cols() == 1</p>
</dd>
<dt>Precondition:</dt><dd><p>control_points()[0].head(n) must be a valid operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-Expression-.FinalValue">
<span id="pydrake.trajectories.BsplineTrajectory_[Expression].FinalValue"></span><span class="sig-name descname"><span class="pre">FinalValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-Expression-.FinalValue" title="Permalink to this definition"></a></dt>
<dd><p>Returns this-&gt;value(this-&gt;end_time())</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-Expression-.InitialValue">
<span id="pydrake.trajectories.BsplineTrajectory_[Expression].InitialValue"></span><span class="sig-name descname"><span class="pre">InitialValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-Expression-.InitialValue" title="Permalink to this definition"></a></dt>
<dd><p>Returns this-&gt;value(this-&gt;start_time())</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-Expression-.InsertKnots">
<span id="pydrake.trajectories.BsplineTrajectory_[Expression].InsertKnots"></span><span class="sig-name descname"><span class="pre">InsertKnots</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">additional_knots</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-Expression-.InsertKnots" title="Permalink to this definition"></a></dt>
<dd><p>Adds new knots at the specified <code class="docutils literal notranslate"><span class="pre">additional_knots</span></code> without changing
the behavior of the trajectory. The basis and control points of the
trajectory are adjusted such that it produces the same value for any
valid time before and after this method is called. The resulting
trajectory is guaranteed to have the same level of continuity as the
original, even if knot values are duplicated. Note that
<code class="docutils literal notranslate"><span class="pre">additional_knots</span></code> need not be sorted.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>start_time() &lt;= t &lt;= end_time() for all t in <code class="docutils literal notranslate"><span class="pre">additional_knots</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-Expression-.num_control_points">
<span id="pydrake.trajectories.BsplineTrajectory_[Expression].num_control_points"></span><span class="sig-name descname"><span class="pre">num_control_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-Expression-.num_control_points" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of control points in this curve.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-float">
<span id="pydrake.trajectories.BsplineTrajectory_[float]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">BsplineTrajectory_[float]</span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-float" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.Trajectory_-float" title="pydrake.trajectories.Trajectory_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[float]</span></code></a></p>
<p>Represents a B-spline curve using a given <code class="docutils literal notranslate"><span class="pre">basis</span></code> with ordered
<code class="docutils literal notranslate"><span class="pre">control_points</span></code> such that each control point is a matrix in ℝʳᵒʷˢ ˣ
ᶜᵒˡˢ.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>math::BsplineBasis</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-float-.__init__">
<span id="pydrake.trajectories.BsplineTrajectory_[float].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-float-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.BsplineTrajectory_[float]) -&gt; None</p></li>
<li><p>__init__(self: pydrake.trajectories.BsplineTrajectory_[float], basis: pydrake.math.BsplineBasis_[float], control_points: List[List[float]]) -&gt; None</p></li>
</ol>
<p>Constructs a B-spline trajectory with the given <code class="docutils literal notranslate"><span class="pre">basis</span></code> and
<code class="docutils literal notranslate"><span class="pre">control_points</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>control_points.size() == basis.num_basis_functions()</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.trajectories.BsplineTrajectory_[float], basis: pydrake.math.BsplineBasis_[float], control_points: List[numpy.ndarray[numpy.float64[m, n]]]) -&gt; None</p></li>
</ol>
<p>Constructs a B-spline trajectory with the given <code class="docutils literal notranslate"><span class="pre">basis</span></code> and
<code class="docutils literal notranslate"><span class="pre">control_points</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>control_points.size() == basis.num_basis_functions()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-float-.basis">
<span id="pydrake.trajectories.BsplineTrajectory_[float].basis"></span><span class="sig-name descname"><span class="pre">basis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.math.html#pydrake.math.BsplineBasis_" title="pydrake.math.BsplineBasis_"><span class="pre">pydrake.math.BsplineBasis_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-float-.basis" title="Permalink to this definition"></a></dt>
<dd><p>Returns the basis of this curve.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-float-.Clone">
<span id="pydrake.trajectories.BsplineTrajectory_[float].Clone"></span><span class="sig-name descname"><span class="pre">Clone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-float-.Clone" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-float-.control_points">
<span id="pydrake.trajectories.BsplineTrajectory_[float].control_points"></span><span class="sig-name descname"><span class="pre">control_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-float-.control_points" title="Permalink to this definition"></a></dt>
<dd><p>Returns the control points of this curve.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-float-.CopyBlock">
<span id="pydrake.trajectories.BsplineTrajectory_[float].CopyBlock"></span><span class="sig-name descname"><span class="pre">CopyBlock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_row</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_rows</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_cols</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-float-.CopyBlock" title="Permalink to this definition"></a></dt>
<dd><p>Returns a new BsplineTrajectory that uses the same basis as <code class="docutils literal notranslate"><span class="pre">this</span></code>,
and whose control points are the result of calling
<code class="docutils literal notranslate"><span class="pre">point.block(start_row,</span> <span class="pre">start_col,</span> <span class="pre">block_rows,</span> <span class="pre">block_cols)</span></code> on each
<code class="docutils literal notranslate"><span class="pre">point</span></code> in <code class="docutils literal notranslate"><span class="pre">this-&gt;control_points()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-float-.CopyHead">
<span id="pydrake.trajectories.BsplineTrajectory_[float].CopyHead"></span><span class="sig-name descname"><span class="pre">CopyHead</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-float-.CopyHead" title="Permalink to this definition"></a></dt>
<dd><p>Returns a new BsplineTrajectory that uses the same basis as <code class="docutils literal notranslate"><span class="pre">this</span></code>,
and whose control points are the result of calling <code class="docutils literal notranslate"><span class="pre">point.head(n)</span></code>
on each <code class="docutils literal notranslate"><span class="pre">point</span></code> in <code class="docutils literal notranslate"><span class="pre">this-&gt;control_points()</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>this-&gt;cols() == 1</p>
</dd>
<dt>Precondition:</dt><dd><p>control_points()[0].head(n) must be a valid operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-float-.FinalValue">
<span id="pydrake.trajectories.BsplineTrajectory_[float].FinalValue"></span><span class="sig-name descname"><span class="pre">FinalValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-float-.FinalValue" title="Permalink to this definition"></a></dt>
<dd><p>Returns this-&gt;value(this-&gt;end_time())</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-float-.InitialValue">
<span id="pydrake.trajectories.BsplineTrajectory_[float].InitialValue"></span><span class="sig-name descname"><span class="pre">InitialValue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-float-.InitialValue" title="Permalink to this definition"></a></dt>
<dd><p>Returns this-&gt;value(this-&gt;start_time())</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-float-.InsertKnots">
<span id="pydrake.trajectories.BsplineTrajectory_[float].InsertKnots"></span><span class="sig-name descname"><span class="pre">InsertKnots</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">additional_knots</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-float-.InsertKnots" title="Permalink to this definition"></a></dt>
<dd><p>Adds new knots at the specified <code class="docutils literal notranslate"><span class="pre">additional_knots</span></code> without changing
the behavior of the trajectory. The basis and control points of the
trajectory are adjusted such that it produces the same value for any
valid time before and after this method is called. The resulting
trajectory is guaranteed to have the same level of continuity as the
original, even if knot values are duplicated. Note that
<code class="docutils literal notranslate"><span class="pre">additional_knots</span></code> need not be sorted.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>start_time() &lt;= t &lt;= end_time() for all t in <code class="docutils literal notranslate"><span class="pre">additional_knots</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.BsplineTrajectory_-float-.num_control_points">
<span id="pydrake.trajectories.BsplineTrajectory_[float].num_control_points"></span><span class="sig-name descname"><span class="pre">num_control_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.BsplineTrajectory_" title="pydrake.trajectories.BsplineTrajectory_"><span class="pre">pydrake.trajectories.BsplineTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory_-float-.num_control_points" title="Permalink to this definition"></a></dt>
<dd><p>Returns the number of control points in this curve.</p>
</dd></dl>

</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.trajectories.PathParameterizedTrajectory">
<span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PathParameterizedTrajectory</span></span><a class="headerlink" href="#pydrake.trajectories.PathParameterizedTrajectory" title="Permalink to this definition"></a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.trajectories.PathParameterizedTrajectory_-float" title="pydrake.trajectories.PathParameterizedTrajectory_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PathParameterizedTrajectory_[float]</span></code></a></p>
</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.trajectories.PathParameterizedTrajectory_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PathParameterizedTrajectory_</span></span><a class="headerlink" href="#pydrake.trajectories.PathParameterizedTrajectory_" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.trajectories.PathParameterizedTrajectory_-float" title="pydrake.trajectories.PathParameterizedTrajectory_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">PathParameterizedTrajectory_[float]</span></code></a>, <a class="reference internal" href="#pydrake.trajectories.PathParameterizedTrajectory_-AutoDiffXd" title="pydrake.trajectories.PathParameterizedTrajectory_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">PathParameterizedTrajectory_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.trajectories.PathParameterizedTrajectory_-Expression" title="pydrake.trajectories.PathParameterizedTrajectory_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">PathParameterizedTrajectory_[Expression]</span></code></a></p>
<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.PathParameterizedTrajectory_.PathParameterizedTrajectory_-float">
<span id="pydrake.trajectories.PathParameterizedTrajectory_.PathParameterizedTrajectory_[float]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">PathParameterizedTrajectory_[float]</span></span><a class="headerlink" href="#pydrake.trajectories.PathParameterizedTrajectory_.PathParameterizedTrajectory_-float" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.Trajectory_-float" title="pydrake.trajectories.Trajectory_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[float]</span></code></a></p>
<p>A trajectory defined by a path and timing trajectory.</p>
<p>Using a path of form <code class="docutils literal notranslate"><span class="pre">q(s)</span></code> and a time_scaling of the form <code class="docutils literal notranslate"><span class="pre">s(t)</span></code>,
a full trajectory of form <code class="docutils literal notranslate"><span class="pre">q(t)</span> <span class="pre">=</span> <span class="pre">q(s(t))</span></code> is modeled.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PathParameterizedTrajectory_.PathParameterizedTrajectory_-float-.__init__">
<span id="pydrake.trajectories.PathParameterizedTrajectory_.PathParameterizedTrajectory_[float].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PathParameterizedTrajectory_" title="pydrake.trajectories.PathParameterizedTrajectory_"><span class="pre">pydrake.trajectories.PathParameterizedTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_scaling</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PathParameterizedTrajectory_.PathParameterizedTrajectory_-float-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a trajectory with the given <code class="docutils literal notranslate"><span class="pre">path</span></code> and <code class="docutils literal notranslate"><span class="pre">time_scaling</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>time_scaling.rows() == time_scaling.cols() == 1</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PathParameterizedTrajectory_.PathParameterizedTrajectory_-float-.Clone">
<span id="pydrake.trajectories.PathParameterizedTrajectory_.PathParameterizedTrajectory_[float].Clone"></span><span class="sig-name descname"><span class="pre">Clone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PathParameterizedTrajectory_" title="pydrake.trajectories.PathParameterizedTrajectory_"><span class="pre">pydrake.trajectories.PathParameterizedTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PathParameterizedTrajectory_.PathParameterizedTrajectory_-float-.Clone" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PathParameterizedTrajectory_.PathParameterizedTrajectory_-float-.path">
<span id="pydrake.trajectories.PathParameterizedTrajectory_.PathParameterizedTrajectory_[float].path"></span><span class="sig-name descname"><span class="pre">path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PathParameterizedTrajectory_" title="pydrake.trajectories.PathParameterizedTrajectory_"><span class="pre">pydrake.trajectories.PathParameterizedTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PathParameterizedTrajectory_.PathParameterizedTrajectory_-float-.path" title="Permalink to this definition"></a></dt>
<dd><p>Returns the path of this trajectory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PathParameterizedTrajectory_.PathParameterizedTrajectory_-float-.time_scaling">
<span id="pydrake.trajectories.PathParameterizedTrajectory_.PathParameterizedTrajectory_[float].time_scaling"></span><span class="sig-name descname"><span class="pre">time_scaling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PathParameterizedTrajectory_" title="pydrake.trajectories.PathParameterizedTrajectory_"><span class="pre">pydrake.trajectories.PathParameterizedTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PathParameterizedTrajectory_.PathParameterizedTrajectory_-float-.time_scaling" title="Permalink to this definition"></a></dt>
<dd><p>Returns the time_scaling of this trajectory.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.PathParameterizedTrajectory_-AutoDiffXd">
<span id="pydrake.trajectories.PathParameterizedTrajectory_[AutoDiffXd]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PathParameterizedTrajectory_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.trajectories.PathParameterizedTrajectory_-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.Trajectory_-AutoDiffXd" title="pydrake.trajectories.Trajectory_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[AutoDiffXd]</span></code></a></p>
<p>A trajectory defined by a path and timing trajectory.</p>
<p>Using a path of form <code class="docutils literal notranslate"><span class="pre">q(s)</span></code> and a time_scaling of the form <code class="docutils literal notranslate"><span class="pre">s(t)</span></code>,
a full trajectory of form <code class="docutils literal notranslate"><span class="pre">q(t)</span> <span class="pre">=</span> <span class="pre">q(s(t))</span></code> is modeled.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PathParameterizedTrajectory_-AutoDiffXd-.__init__">
<span id="pydrake.trajectories.PathParameterizedTrajectory_[AutoDiffXd].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PathParameterizedTrajectory_" title="pydrake.trajectories.PathParameterizedTrajectory_"><span class="pre">pydrake.trajectories.PathParameterizedTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_scaling</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PathParameterizedTrajectory_-AutoDiffXd-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a trajectory with the given <code class="docutils literal notranslate"><span class="pre">path</span></code> and <code class="docutils literal notranslate"><span class="pre">time_scaling</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>time_scaling.rows() == time_scaling.cols() == 1</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PathParameterizedTrajectory_-AutoDiffXd-.Clone">
<span id="pydrake.trajectories.PathParameterizedTrajectory_[AutoDiffXd].Clone"></span><span class="sig-name descname"><span class="pre">Clone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PathParameterizedTrajectory_" title="pydrake.trajectories.PathParameterizedTrajectory_"><span class="pre">pydrake.trajectories.PathParameterizedTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PathParameterizedTrajectory_-AutoDiffXd-.Clone" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PathParameterizedTrajectory_-AutoDiffXd-.path">
<span id="pydrake.trajectories.PathParameterizedTrajectory_[AutoDiffXd].path"></span><span class="sig-name descname"><span class="pre">path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PathParameterizedTrajectory_" title="pydrake.trajectories.PathParameterizedTrajectory_"><span class="pre">pydrake.trajectories.PathParameterizedTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PathParameterizedTrajectory_-AutoDiffXd-.path" title="Permalink to this definition"></a></dt>
<dd><p>Returns the path of this trajectory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PathParameterizedTrajectory_-AutoDiffXd-.time_scaling">
<span id="pydrake.trajectories.PathParameterizedTrajectory_[AutoDiffXd].time_scaling"></span><span class="sig-name descname"><span class="pre">time_scaling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PathParameterizedTrajectory_" title="pydrake.trajectories.PathParameterizedTrajectory_"><span class="pre">pydrake.trajectories.PathParameterizedTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PathParameterizedTrajectory_-AutoDiffXd-.time_scaling" title="Permalink to this definition"></a></dt>
<dd><p>Returns the time_scaling of this trajectory.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.PathParameterizedTrajectory_-Expression">
<span id="pydrake.trajectories.PathParameterizedTrajectory_[Expression]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PathParameterizedTrajectory_[Expression]</span></span><a class="headerlink" href="#pydrake.trajectories.PathParameterizedTrajectory_-Expression" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.Trajectory_-Expression" title="pydrake.trajectories.Trajectory_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[Expression]</span></code></a></p>
<p>A trajectory defined by a path and timing trajectory.</p>
<p>Using a path of form <code class="docutils literal notranslate"><span class="pre">q(s)</span></code> and a time_scaling of the form <code class="docutils literal notranslate"><span class="pre">s(t)</span></code>,
a full trajectory of form <code class="docutils literal notranslate"><span class="pre">q(t)</span> <span class="pre">=</span> <span class="pre">q(s(t))</span></code> is modeled.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PathParameterizedTrajectory_-Expression-.__init__">
<span id="pydrake.trajectories.PathParameterizedTrajectory_[Expression].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PathParameterizedTrajectory_" title="pydrake.trajectories.PathParameterizedTrajectory_"><span class="pre">pydrake.trajectories.PathParameterizedTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_scaling</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PathParameterizedTrajectory_-Expression-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a trajectory with the given <code class="docutils literal notranslate"><span class="pre">path</span></code> and <code class="docutils literal notranslate"><span class="pre">time_scaling</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>time_scaling.rows() == time_scaling.cols() == 1</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PathParameterizedTrajectory_-Expression-.Clone">
<span id="pydrake.trajectories.PathParameterizedTrajectory_[Expression].Clone"></span><span class="sig-name descname"><span class="pre">Clone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PathParameterizedTrajectory_" title="pydrake.trajectories.PathParameterizedTrajectory_"><span class="pre">pydrake.trajectories.PathParameterizedTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PathParameterizedTrajectory_-Expression-.Clone" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PathParameterizedTrajectory_-Expression-.path">
<span id="pydrake.trajectories.PathParameterizedTrajectory_[Expression].path"></span><span class="sig-name descname"><span class="pre">path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PathParameterizedTrajectory_" title="pydrake.trajectories.PathParameterizedTrajectory_"><span class="pre">pydrake.trajectories.PathParameterizedTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PathParameterizedTrajectory_-Expression-.path" title="Permalink to this definition"></a></dt>
<dd><p>Returns the path of this trajectory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PathParameterizedTrajectory_-Expression-.time_scaling">
<span id="pydrake.trajectories.PathParameterizedTrajectory_[Expression].time_scaling"></span><span class="sig-name descname"><span class="pre">time_scaling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PathParameterizedTrajectory_" title="pydrake.trajectories.PathParameterizedTrajectory_"><span class="pre">pydrake.trajectories.PathParameterizedTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PathParameterizedTrajectory_-Expression-.time_scaling" title="Permalink to this definition"></a></dt>
<dd><p>Returns the time_scaling of this trajectory.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.PathParameterizedTrajectory_-float">
<span id="pydrake.trajectories.PathParameterizedTrajectory_[float]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PathParameterizedTrajectory_[float]</span></span><a class="headerlink" href="#pydrake.trajectories.PathParameterizedTrajectory_-float" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.Trajectory_-float" title="pydrake.trajectories.Trajectory_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[float]</span></code></a></p>
<p>A trajectory defined by a path and timing trajectory.</p>
<p>Using a path of form <code class="docutils literal notranslate"><span class="pre">q(s)</span></code> and a time_scaling of the form <code class="docutils literal notranslate"><span class="pre">s(t)</span></code>,
a full trajectory of form <code class="docutils literal notranslate"><span class="pre">q(t)</span> <span class="pre">=</span> <span class="pre">q(s(t))</span></code> is modeled.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PathParameterizedTrajectory_-float-.__init__">
<span id="pydrake.trajectories.PathParameterizedTrajectory_[float].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PathParameterizedTrajectory_" title="pydrake.trajectories.PathParameterizedTrajectory_"><span class="pre">pydrake.trajectories.PathParameterizedTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_scaling</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PathParameterizedTrajectory_-float-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a trajectory with the given <code class="docutils literal notranslate"><span class="pre">path</span></code> and <code class="docutils literal notranslate"><span class="pre">time_scaling</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>time_scaling.rows() == time_scaling.cols() == 1</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PathParameterizedTrajectory_-float-.Clone">
<span id="pydrake.trajectories.PathParameterizedTrajectory_[float].Clone"></span><span class="sig-name descname"><span class="pre">Clone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PathParameterizedTrajectory_" title="pydrake.trajectories.PathParameterizedTrajectory_"><span class="pre">pydrake.trajectories.PathParameterizedTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PathParameterizedTrajectory_-float-.Clone" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PathParameterizedTrajectory_-float-.path">
<span id="pydrake.trajectories.PathParameterizedTrajectory_[float].path"></span><span class="sig-name descname"><span class="pre">path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PathParameterizedTrajectory_" title="pydrake.trajectories.PathParameterizedTrajectory_"><span class="pre">pydrake.trajectories.PathParameterizedTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PathParameterizedTrajectory_-float-.path" title="Permalink to this definition"></a></dt>
<dd><p>Returns the path of this trajectory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PathParameterizedTrajectory_-float-.time_scaling">
<span id="pydrake.trajectories.PathParameterizedTrajectory_[float].time_scaling"></span><span class="sig-name descname"><span class="pre">time_scaling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PathParameterizedTrajectory_" title="pydrake.trajectories.PathParameterizedTrajectory_"><span class="pre">pydrake.trajectories.PathParameterizedTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PathParameterizedTrajectory_-float-.time_scaling" title="Permalink to this definition"></a></dt>
<dd><p>Returns the time_scaling of this trajectory.</p>
</dd></dl>

</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial">
<span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PiecewisePolynomial</span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial" title="Permalink to this definition"></a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_-float" title="pydrake.trajectories.PiecewisePolynomial_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PiecewisePolynomial_[float]</span></code></a></p>
</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PiecewisePolynomial_</span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_-float" title="pydrake.trajectories.PiecewisePolynomial_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewisePolynomial_[float]</span></code></a>, <a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd" title="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewisePolynomial_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_-Expression" title="pydrake.trajectories.PiecewisePolynomial_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewisePolynomial_[Expression]</span></code></a></p>
<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float">
<span id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_[float]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">PiecewisePolynomial_[float]</span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_-float" title="pydrake.trajectories.PiecewiseTrajectory_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_[float]</span></code></a></p>
<p>A scalar multi-variate piecewise polynomial.</p>
<p>PiecewisePolynomial represents a list of contiguous segments in a
scalar independent variable (typically corresponding to time) with
Polynomials defined at each segment. We call the output from
evaluating the PiecewisePolynomial at the scalar independent variable
“the output”, and that output can be either a Eigen MatrixX&lt;T&gt; (if
evaluated using value()) or a scalar (if evaluated using
scalar_value()).</p>
<p>An example of a piecewise polynomial is a function of m segments in
time, where a different polynomial is defined for each segment. For a
specific example, consider the absolute value function over the
interval [-1, 1]. We can define a PiecewisePolynomial over this
interval using breaks at t = { -1.0, 0.0, 1.0 }, and “samples” of
abs(t).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Construct</span> <span class="n">the</span> <span class="n">PiecewisePolynomial</span><span class="o">.</span>
<span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">breaks</span> <span class="o">=</span> <span class="p">{</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span> <span class="p">};</span>
<span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="p">::</span><span class="n">MatrixXd</span><span class="o">&gt;</span> <span class="n">samples</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">breaks</span><span class="o">.</span><span class="n">size</span><span class="p">());</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">std</span><span class="p">::</span><span class="nb">abs</span><span class="p">(</span><span class="n">breaks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
<span class="n">const</span> <span class="n">auto</span> <span class="n">pp</span> <span class="o">=</span>
     <span class="n">PiecewisePolynomial</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">::</span><span class="n">FirstOrderHold</span><span class="p">(</span><span class="n">breaks</span><span class="p">,</span> <span class="n">samples</span><span class="p">);</span>
<span class="n">const</span> <span class="nb">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Evaluate</span> <span class="n">the</span> <span class="n">PiecewisePolynomial</span> <span class="n">at</span> <span class="n">some</span> <span class="n">values</span><span class="o">.</span>
<span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="o">-</span><span class="mf">.5</span><span class="p">)(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>    <span class="o">//</span> <span class="n">Outputs</span> <span class="mf">0.5</span><span class="o">.</span>
<span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>    <span class="o">//</span> <span class="n">Outputs</span> <span class="mf">0.0</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Show</span> <span class="n">how</span> <span class="n">we</span> <span class="n">can</span> <span class="n">evaluate</span> <span class="n">the</span> <span class="n">first</span> <span class="n">derivative</span> <span class="p">(</span><span class="n">outputs</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span><span class="o">.</span>
<span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="o">-</span><span class="mf">.5</span><span class="p">)(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>A note on terminology. For piecewise-polynomial interpolation, we use
<code class="docutils literal notranslate"><span class="pre">breaks</span></code> to indicate the scalar (e.g. times) which form the boundary
of each segment. We use <code class="docutils literal notranslate"><span class="pre">samples</span></code> to indicate the function value at
the <code class="docutils literal notranslate"><span class="pre">breaks</span></code>, e.g. <code class="docutils literal notranslate"><span class="pre">p(breaks[i])</span> <span class="pre">=</span> <span class="pre">samples[i]</span></code>. The term <code class="docutils literal notranslate"><span class="pre">knot</span></code>
should be reserved for the “(x,y)” coordinate, here <code class="docutils literal notranslate"><span class="pre">knot[i]</span> <span class="pre">=</span>
<span class="pre">(breaks[i],</span> <span class="pre">samples[i])</span></code>, though it is used inconsistently in the
interpolation literature (sometimes for <code class="docutils literal notranslate"><span class="pre">breaks</span></code>, sometimes for
<code class="docutils literal notranslate"><span class="pre">samples</span></code>), so we try to mostly avoid it here.</p>
<p>PiecewisePolynomial objects can be added, subtracted, and multiplied.
They cannot be divided because Polynomials are not closed under
division.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>PiecewisePolynomial silently clips input evaluations outside of
the range defined by the breaks. So <code class="docutils literal notranslate"><span class="pre">pp.value(-2.0,</span> <span class="pre">row,</span> <span class="pre">col)</span></code>
in the example above would evaluate to -1.0. See value().</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.__init__">
<span id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_[float].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.PiecewisePolynomial_[float]) -&gt; None</p></li>
</ol>
<p>Constructs an empty piecewise polynomial.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.trajectories.PiecewisePolynomial_[float], arg0: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]) -&gt; None</p></li>
</ol>
<p>Single segment, constant value constructor over the interval [-∞, ∞].
The constructed PiecewisePolynomial will return <code class="docutils literal notranslate"><span class="pre">constant_value</span></code> at
every evaluated point (i.e., <code class="docutils literal notranslate"><span class="pre">value(t)</span> <span class="pre">=</span> <span class="pre">constant_value</span></code> ∀t ∈ [-∞,
∞]).</p>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.trajectories.PiecewisePolynomial_[float], arg0: List[numpy.ndarray[object[m, n]]], arg1: List[float]) -&gt; None</p></li>
</ol>
<p>Constructs a PiecewisePolynomial using matrix-output Polynomials
defined over each segment.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">polynomials.size()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span> <span class="pre">-</span> <span class="pre">1</span></code></p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.trajectories.PiecewisePolynomial_[float], arg0: List[pydrake.polynomial.Polynomial_[float]], arg1: List[float]) -&gt; None</p></li>
</ol>
<p>Constructs a PiecewisePolynomial using scalar-output Polynomials
defined over each segment.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">polynomials.size()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span> <span class="pre">-</span> <span class="pre">1</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.AppendCubicHermiteSegment">
<span id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_[float].AppendCubicHermiteSegment"></span><span class="sig-name descname"><span class="pre">AppendCubicHermiteSegment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_dot</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.AppendCubicHermiteSegment" title="Permalink to this definition"></a></dt>
<dd><p>The CubicHermite spline construction has a nice property of being
incremental (each segment can be solved independently). Given a new
sample and it’s derivative, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code> where the start sample and derivative are taken as the value
and derivative at the final break of <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> is not empty()</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">time</span></code> &gt; end_time()</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">sample</span></code> and <code class="docutils literal notranslate"><span class="pre">sample_dot</span></code> must have size rows() x cols().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.AppendFirstOrderSegment">
<span id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_[float].AppendFirstOrderSegment"></span><span class="sig-name descname"><span class="pre">AppendFirstOrderSegment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.AppendFirstOrderSegment" title="Permalink to this definition"></a></dt>
<dd><p>Given a new sample, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code> using a first-order hold, where the start sample is taken as
the value at the final break of <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.Block">
<span id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_[float].Block"></span><span class="sig-name descname"><span class="pre">Block</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_row</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_rows</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_cols</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.Block" title="Permalink to this definition"></a></dt>
<dd><p>Extracts a trajectory representing a block of size (block_rows,
block_cols) starting at (start_row, start_col) from the
PiecewisePolynomial.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a PiecewisePolynomial such that ret.value(t) =
this.value(t).block(i,j,p,q);</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.Clone">
<span id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_[float].Clone"></span><span class="sig-name descname"><span class="pre">Clone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.Clone" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.ConcatenateInTime">
<span id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_[float].ConcatenateInTime"></span><span class="sig-name descname"><span class="pre">ConcatenateInTime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.ConcatenateInTime" title="Permalink to this definition"></a></dt>
<dd><p>Concatenates <code class="docutils literal notranslate"><span class="pre">other</span></code> to the end of <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The resulting PiecewisePolynomial will only be continuous to the
degree that the first Polynomial of <code class="docutils literal notranslate"><span class="pre">other</span></code> is continuous with
the last Polynomial of <code class="docutils literal notranslate"><span class="pre">this</span></code>. See warning about evaluating
discontinuous derivatives at breaks in derivative().</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other</span></code>:</dt><dd><p>PiecewisePolynomial instance to concatenate.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if trajectories' dimensions do not match each other</strong> – </p></li>
<li><p><strong>(</strong><strong>either rows</strong><strong>(</strong><strong>) or </strong><strong>cols</strong><strong>(</strong><strong>) </strong><strong>does not match between this and</strong> – </p></li>
<li><p><strong>other`</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if this-&gt;end_time</strong><strong>(</strong><strong>) </strong><strong>and other-&gt;start_time</strong><strong>(</strong><strong>)</strong> – </p></li>
<li><p><strong>are not within PiecewiseTrajectory&lt;T&gt;::kEpsilonTime from each</strong> – </p></li>
<li><p><strong>other.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.CubicHermite">
<span id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_[float].CubicHermite"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">CubicHermite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.CubicHermite" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CubicHermite(breaks: List[float], samples: List[List[float]], samples_dot: List[List[float]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[float]</p></li>
</ol>
<p>Version of CubicHermite(breaks, samples, samples_dot) that uses vector
samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Corresponding
columns of <code class="docutils literal notranslate"><span class="pre">samples</span></code> and <code class="docutils literal notranslate"><span class="pre">samples_dot</span></code> are used as the sample
point and independent variable derivative, respectively.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">samples_dot.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>CubicHermite(breaks: List[float], samples: List[numpy.ndarray[numpy.float64[m, n]]], samples_dot: List[numpy.ndarray[numpy.float64[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[float]</p></li>
</ol>
<p>Constructs a third order PiecewisePolynomial using matrix samples and
derivatives of samples (<code class="docutils literal notranslate"><span class="pre">samples_dot</span></code>); each matrix element of
<code class="docutils literal notranslate"><span class="pre">samples_dot</span></code> represents the derivative with respect to the
independent variable (e.g., the time derivative) of the corresponding
entry in <code class="docutils literal notranslate"><span class="pre">samples</span></code>. Each segment is fully specified by <code class="docutils literal notranslate"><span class="pre">samples</span></code>
and <code class="docutils literal notranslate"><span class="pre">sample_dot</span></code> at both ends. Second derivatives are not
continuous.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.CubicShapePreserving">
<span id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_[float].CubicShapePreserving"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">CubicShapePreserving</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.CubicShapePreserving" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CubicShapePreserving(breaks: List[float], samples: List[List[float]], zero_end_point_derivatives: bool = False) -&gt; pydrake.trajectories.PiecewisePolynomial_[float]</p></li>
</ol>
<p>Version of CubicShapePreserving(breaks, samples,
zero_end_point_derivatives) that uses vector samples and Eigen
VectorXd and MatrixX&lt;T&gt; arguments. Each column of <code class="docutils literal notranslate"><span class="pre">samples</span></code>
represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>CubicShapePreserving(breaks: List[float], samples: List[numpy.ndarray[numpy.float64[m, n]]], zero_end_point_derivatives: bool = False) -&gt; pydrake.trajectories.PiecewisePolynomial_[float]</p></li>
</ol>
<p>Constructs a third order PiecewisePolynomial using vector samples,
where each column of <code class="docutils literal notranslate"><span class="pre">samples</span></code> represents a sample point. First
derivatives are chosen to be “shape preserving”, i.e. if <code class="docutils literal notranslate"><span class="pre">samples</span></code>
is monotonic within some interval, the interpolated data will also be
monotonic. The second derivative is not guaranteed to be smooth across
the entire spline.</p>
<p>MATLAB calls this method “pchip” (short for “Piecewise Cubic Hermite
Interpolating Polynomial”), and provides a nice description in their
documentation.
<a class="reference external" href="http://home.uchicago.edu/~sctchoi/courses/cs138/interp.pdf">http://home.uchicago.edu/~sctchoi/courses/cs138/interp.pdf</a> is also a
good reference.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, the first and last
first derivative is chosen using a non-centered, shape-preserving
three-point formulae. See equation (2.10) in the following reference
for more details. <a class="reference external" href="http://www.mi.sanu.ac.rs/~gvm/radovi/mon.pdf">http://www.mi.sanu.ac.rs/~gvm/radovi/mon.pdf</a> If
<code class="docutils literal notranslate"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, they are set to zeros.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, <cite>breaks</cite> and
<code class="docutils literal notranslate"><span class="pre">samples</span></code> must have at least 3 elements for the algorithm to
determine the first derivatives.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, <cite>breaks</cite> and
<code class="docutils literal notranslate"><span class="pre">samples</span></code> may have 2 or more elements. For the 2 elements case, the
result is equivalent to computing a cubic polynomial whose values are
given by <code class="docutils literal notranslate"><span class="pre">samples</span></code>, and derivatives set to zero.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if</strong> – <ul>
<li><p><code class="docutils literal notranslate"><span class="pre">breaks</span></code> has length smaller than 3 and</p></li>
</ul>
</p></li>
<li><p><strong>zero_end_point_derivatives` is False</strong><strong>, </strong><strong>- breaks has lengt</strong> – </p></li>
<li><p><strong>smaller than 2 and zero_end_point_derivatives is true.</strong> – </p></li>
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.CubicWithContinuousSecondDerivatives">
<span id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_[float].CubicWithContinuousSecondDerivatives"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">CubicWithContinuousSecondDerivatives</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.CubicWithContinuousSecondDerivatives" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CubicWithContinuousSecondDerivatives(breaks: List[float], samples: List[List[float]], sample_dot_at_start: numpy.ndarray[numpy.float64[m, n]], sample_dot_at_end: numpy.ndarray[numpy.float64[m, n]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[float]</p></li>
</ol>
<p>Version of CubicWithContinuousSecondDerivatives() that uses vector
samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each column of
<code class="docutils literal notranslate"><span class="pre">samples</span></code> represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>CubicWithContinuousSecondDerivatives(breaks: List[float], samples: List[numpy.ndarray[numpy.float64[m, n]]], sample_dot_at_start: numpy.ndarray[numpy.float64[m, n]], sample_dot_at_end: numpy.ndarray[numpy.float64[m, n]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[float]</p></li>
</ol>
<p>Constructs a third order PiecewisePolynomial using matrix samples. The
PiecewisePolynomial is constructed such that the interior segments
have the same value, first and second derivatives at <code class="docutils literal notranslate"><span class="pre">breaks</span></code>.
<cite>sample_dot_at_start</cite> and <code class="docutils literal notranslate"><span class="pre">sample_dot_at_end</span></code> are used for the first
and last first derivatives.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if sample_dot_at_start</strong><strong> or </strong><strong>sample_dot_at_end</strong> – </p></li>
<li><p><strong>and samples have inconsistent dimensions.</strong> – </p></li>
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>CubicWithContinuousSecondDerivatives(breaks: List[float], samples: List[List[float]], periodic_end_condition: bool = False) -&gt; pydrake.trajectories.PiecewisePolynomial_[float]</p></li>
</ol>
<p>Version of CubicWithContinuousSecondDerivatives(breaks, samples) that
uses vector samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each
column of <code class="docutils literal notranslate"><span class="pre">samples</span></code> represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>CubicWithContinuousSecondDerivatives(breaks: List[float], samples: List[numpy.ndarray[numpy.float64[m, n]]], periodic_end: bool) -&gt; pydrake.trajectories.PiecewisePolynomial_[float]</p></li>
</ol>
<p>Constructs a third order PiecewisePolynomial using matrix samples. The
PiecewisePolynomial is constructed such that the interior segments
have the same value, first and second derivatives at <code class="docutils literal notranslate"><span class="pre">breaks</span></code>. If
<code class="docutils literal notranslate"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code> (default), then the
“Not-a-sample” end condition is used here, which means the third
derivatives are continuous for the first two and last two segments. If
<code class="docutils literal notranslate"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, then the first and second
derivatives between the end of the last segment and the beginning of
the first segment will be continuous. Note that the periodic end
condition does not require the first and last sample to be collocated,
nor does it add an additional sample to connect the first and last
segments. Only first and second derivative continuity is enforced. See
<a class="reference external" href="https://en.wikipedia.org/wiki/Spline_interpolation">https://en.wikipedia.org/wiki/Spline_interpolation</a> and
<a class="reference external" href="https://www.math.uh.edu/~jingqiu/math4364/spline.pdf">https://www.math.uh.edu/~jingqiu/math4364/spline.pdf</a> for more about
cubic splines and their end conditions. The MATLAB docs for methods
“spline” and “csape” are also good references.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">breaks</span></code> and <code class="docutils literal notranslate"><span class="pre">samples</span></code> must have at least 3 elements. If
<code class="docutils literal notranslate"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, then for two samples, it
would produce a straight line (use <code class="docutils literal notranslate"><span class="pre">FirstOrderHold</span></code> for this
instead), and if <code class="docutils literal notranslate"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code> the
problem is ill-defined.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.derivative">
<span id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_[float].derivative"></span><span class="sig-name descname"><span class="pre">derivative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derivative_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.derivative" title="Permalink to this definition"></a></dt>
<dd><p>Returns a PiecewisePolynomial where each segment is the specified
derivative of the corresponding segment in <code class="docutils literal notranslate"><span class="pre">this</span></code>. Any rules or
limitations of Polynomial::derivative() also apply to this function.</p>
<p>Derivatives evaluated at non-differentiable points return the value at
the left hand side of the interval.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code>:</dt><dd><p>The order of the derivative, namely, if <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code> = n,
the n’th derivative of the polynomial will be returned.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In the event of discontinuous derivatives evaluated at breaks, it
is not defined which polynomial (i.e., to the left or right of the
break) will be the one that is evaluated at the break.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.FirstOrderHold">
<span id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_[float].FirstOrderHold"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">FirstOrderHold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.FirstOrderHold" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>FirstOrderHold(breaks: List[float], samples: List[List[float]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[float]</p></li>
</ol>
<p>Version of FirstOrderHold(breaks, samples) that uses vector samples
and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each column of <code class="docutils literal notranslate"><span class="pre">samples</span></code>
represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>FirstOrderHold(breaks: List[float], samples: List[numpy.ndarray[numpy.float64[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[float]</p></li>
</ol>
<p>Constructs a piecewise linear PiecewisePolynomial using matrix
samples.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.getPolynomial">
<span id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_[float].getPolynomial"></span><span class="sig-name descname"><span class="pre">getPolynomial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.polynomial.html#pydrake.polynomial.Polynomial_" title="pydrake.polynomial.Polynomial_"><span class="pre">pydrake.polynomial.Polynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.getPolynomial" title="Permalink to this definition"></a></dt>
<dd><p>Gets the Polynomial with the given matrix row and column index that
corresponds to the given segment index. Equivalent to
<code class="docutils literal notranslate"><span class="pre">getPolynomialMatrix(segment_index)(row,</span> <span class="pre">col)</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calls PiecewiseTrajectory&lt;T&gt;::segment_number_range_check() to
validate <code class="docutils literal notranslate"><span class="pre">segment_index</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.getPolynomialMatrix">
<span id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_[float].getPolynomialMatrix"></span><span class="sig-name descname"><span class="pre">getPolynomialMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.getPolynomialMatrix" title="Permalink to this definition"></a></dt>
<dd><p>Gets the matrix of Polynomials corresponding to the given segment
index.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><code class="docutils literal notranslate"><span class="pre">segment_index</span></code> is not checked for validity.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.getSegmentPolynomialDegree">
<span id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_[float].getSegmentPolynomialDegree"></span><span class="sig-name descname"><span class="pre">getSegmentPolynomialDegree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.getSegmentPolynomialDegree" title="Permalink to this definition"></a></dt>
<dd><p>Gets the degree of the Polynomial with the given matrix row and column
index that corresponds to the given segment index. Equivalent to
<code class="docutils literal notranslate"><span class="pre">getPolynomial(segment_index,</span> <span class="pre">row,</span> <span class="pre">col).GetDegree()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.isApprox">
<span id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_[float].isApprox"></span><span class="sig-name descname"><span class="pre">isApprox</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[float],</span> <span class="pre">other:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[float],</span> <span class="pre">tol:</span> <span class="pre">float,</span> <span class="pre">tol_type:</span> <span class="pre">pydrake.common._module_py.ToleranceType</span> <span class="pre">=</span> <span class="pre">&lt;ToleranceType.kRelative:</span> <span class="pre">1&gt;</span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.isApprox" title="Permalink to this definition"></a></dt>
<dd><p>Checks whether a PiecewisePolynomial is approximately equal to this
one by calling Polynomial&lt;T&gt;::CoefficientsAlmostEqual() on every
element of every segment.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Polynomial&lt;T&gt;::CoefficientsAlmostEqual().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.LagrangeInterpolatingPolynomial">
<span id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_[float].LagrangeInterpolatingPolynomial"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">LagrangeInterpolatingPolynomial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.LagrangeInterpolatingPolynomial" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>LagrangeInterpolatingPolynomial(times: List[float], samples: List[List[float]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[float]</p></li>
</ol>
<p>Version of LagrangeInterpolatingPolynomial(times, samples) that uses
vector samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each column
of <code class="docutils literal notranslate"><span class="pre">samples</span></code> represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">times.size()</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>LagrangeInterpolatingPolynomial(times: List[float], samples: List[numpy.ndarray[numpy.float64[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[float]</p></li>
</ol>
<p>Constructs a polynomial with a <em>single segment</em> of the lowest possible
degree that passes through all of the sample points. See “polynomial
interpolation” and/or “Lagrange polynomial” on Wikipedia for more
information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">times</span></code> must be monotonically increasing.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.size()</span> <span class="pre">==</span> <span class="pre">times.size()</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.RemoveFinalSegment">
<span id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_[float].RemoveFinalSegment"></span><span class="sig-name descname"><span class="pre">RemoveFinalSegment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.RemoveFinalSegment" title="Permalink to this definition"></a></dt>
<dd><p>Removes the final segment from the trajectory, reducing the number of
segments by 1.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> is not empty()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.Reshape">
<span id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_[float].Reshape"></span><span class="sig-name descname"><span class="pre">Reshape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rows</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cols</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.Reshape" title="Permalink to this definition"></a></dt>
<dd><p>Reshapes the dimensions of the Eigen::MatrixX&lt;T&gt; returned by value(),
EvalDerivative(), etc.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">rows</span></code> x <code class="docutils literal notranslate"><span class="pre">cols</span></code> must equal this.rows() * this.cols().</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Eigen::PlainObjectBase::resize().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.ReverseTime">
<span id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_[float].ReverseTime"></span><span class="sig-name descname"><span class="pre">ReverseTime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.ReverseTime" title="Permalink to this definition"></a></dt>
<dd><p>Modifies the trajectory so that pp_after(t) = pp_before(-t).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The new trajectory will evaluate differently at precisely the
break points if the original trajectory was discontinuous at the
break points. This is because the segments are defined on the
half-open intervals [breaks(i), breaks(i+1)), and the order of the
breaks have been reversed.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.ScaleTime">
<span id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_[float].ScaleTime"></span><span class="sig-name descname"><span class="pre">ScaleTime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.ScaleTime" title="Permalink to this definition"></a></dt>
<dd><p>Scales the time of the trajectory by non-negative <code class="docutils literal notranslate"><span class="pre">scale</span></code> (use
ReverseTime() if you want to also negate time). The resulting
polynomial evaluates to pp_after(t) = pp_before(t/scale).</p>
<p>As an example, <a href="#id1"><span class="problematic" id="id2">`</span></a>scale`=2 will result in a trajectory that is twice as
long (start_time() and end_time() have both doubled).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.setPolynomialMatrixBlock">
<span id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_[float].setPolynomialMatrixBlock"></span><span class="sig-name descname"><span class="pre">setPolynomialMatrixBlock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">replacement</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row_start</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col_start</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.setPolynomialMatrixBlock" title="Permalink to this definition"></a></dt>
<dd><p>Replaces the specified block of the PolynomialMatrix at the given
segment index.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calls PiecewiseTrajectory&lt;T&gt;::segment_number_range_check() to
validate <code class="docutils literal notranslate"><span class="pre">segment_index</span></code>.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This code relies upon Eigen to verify that the replacement block
is not too large.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.shiftRight">
<span id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_[float].shiftRight"></span><span class="sig-name descname"><span class="pre">shiftRight</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.shiftRight" title="Permalink to this definition"></a></dt>
<dd><p>Adds <code class="docutils literal notranslate"><span class="pre">offset</span></code> to all of the breaks. <code class="docutils literal notranslate"><span class="pre">offset</span></code> need not be a
non-negative number. The resulting polynomial will evaluate to
pp_after(t) = pp_before(t-offset).</p>
<p>As an example, <a href="#id3"><span class="problematic" id="id4">`</span></a>offset`=2 will result in the start_time() and
end_time() being 2 seconds later.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.slice">
<span id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_[float].slice"></span><span class="sig-name descname"><span class="pre">slice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_segments</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.slice" title="Permalink to this definition"></a></dt>
<dd><p>Returns the PiecewisePolynomial comprising the <code class="docutils literal notranslate"><span class="pre">num_segments</span></code>
segments starting at the specified <code class="docutils literal notranslate"><span class="pre">start_segment_index</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calls PiecewiseTrajectory&lt;T&gt;::segment_number_range_check() to
validate <code class="docutils literal notranslate"><span class="pre">segment_index</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.Transpose">
<span id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_[float].Transpose"></span><span class="sig-name descname"><span class="pre">Transpose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.Transpose" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a new PiecewisePolynomial for which value(t) ==
this.value(t).transpose().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.ZeroOrderHold">
<span id="pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_[float].ZeroOrderHold"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ZeroOrderHold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_.PiecewisePolynomial_-float-.ZeroOrderHold" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>ZeroOrderHold(breaks: List[float], samples: List[List[float]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[float]</p></li>
</ol>
<p>Version of ZeroOrderHold(breaks, samples) that uses vector samples and
Eigen VectorXd/MatrixX&lt;T&gt; arguments. Each column of <code class="docutils literal notranslate"><span class="pre">samples</span></code>
represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>ZeroOrderHold(breaks: List[float], samples: List[numpy.ndarray[numpy.float64[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[float]</p></li>
</ol>
<p>Constructs a piecewise constant PiecewisePolynomial using matrix
samples. Note that constructing a PiecewisePolynomial requires at
least two sample points, although in this case, the second sample
point’s value is ignored, and only its break time is used.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PiecewisePolynomial_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd" title="pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd]</span></code></a></p>
<p>A scalar multi-variate piecewise polynomial.</p>
<p>PiecewisePolynomial represents a list of contiguous segments in a
scalar independent variable (typically corresponding to time) with
Polynomials defined at each segment. We call the output from
evaluating the PiecewisePolynomial at the scalar independent variable
“the output”, and that output can be either a Eigen MatrixX&lt;T&gt; (if
evaluated using value()) or a scalar (if evaluated using
scalar_value()).</p>
<p>An example of a piecewise polynomial is a function of m segments in
time, where a different polynomial is defined for each segment. For a
specific example, consider the absolute value function over the
interval [-1, 1]. We can define a PiecewisePolynomial over this
interval using breaks at t = { -1.0, 0.0, 1.0 }, and “samples” of
abs(t).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Construct</span> <span class="n">the</span> <span class="n">PiecewisePolynomial</span><span class="o">.</span>
<span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">breaks</span> <span class="o">=</span> <span class="p">{</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span> <span class="p">};</span>
<span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="p">::</span><span class="n">MatrixXd</span><span class="o">&gt;</span> <span class="n">samples</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">breaks</span><span class="o">.</span><span class="n">size</span><span class="p">());</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">std</span><span class="p">::</span><span class="nb">abs</span><span class="p">(</span><span class="n">breaks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
<span class="n">const</span> <span class="n">auto</span> <span class="n">pp</span> <span class="o">=</span>
     <span class="n">PiecewisePolynomial</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">::</span><span class="n">FirstOrderHold</span><span class="p">(</span><span class="n">breaks</span><span class="p">,</span> <span class="n">samples</span><span class="p">);</span>
<span class="n">const</span> <span class="nb">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Evaluate</span> <span class="n">the</span> <span class="n">PiecewisePolynomial</span> <span class="n">at</span> <span class="n">some</span> <span class="n">values</span><span class="o">.</span>
<span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="o">-</span><span class="mf">.5</span><span class="p">)(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>    <span class="o">//</span> <span class="n">Outputs</span> <span class="mf">0.5</span><span class="o">.</span>
<span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>    <span class="o">//</span> <span class="n">Outputs</span> <span class="mf">0.0</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Show</span> <span class="n">how</span> <span class="n">we</span> <span class="n">can</span> <span class="n">evaluate</span> <span class="n">the</span> <span class="n">first</span> <span class="n">derivative</span> <span class="p">(</span><span class="n">outputs</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span><span class="o">.</span>
<span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="o">-</span><span class="mf">.5</span><span class="p">)(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>A note on terminology. For piecewise-polynomial interpolation, we use
<code class="docutils literal notranslate"><span class="pre">breaks</span></code> to indicate the scalar (e.g. times) which form the boundary
of each segment. We use <code class="docutils literal notranslate"><span class="pre">samples</span></code> to indicate the function value at
the <code class="docutils literal notranslate"><span class="pre">breaks</span></code>, e.g. <code class="docutils literal notranslate"><span class="pre">p(breaks[i])</span> <span class="pre">=</span> <span class="pre">samples[i]</span></code>. The term <code class="docutils literal notranslate"><span class="pre">knot</span></code>
should be reserved for the “(x,y)” coordinate, here <code class="docutils literal notranslate"><span class="pre">knot[i]</span> <span class="pre">=</span>
<span class="pre">(breaks[i],</span> <span class="pre">samples[i])</span></code>, though it is used inconsistently in the
interpolation literature (sometimes for <code class="docutils literal notranslate"><span class="pre">breaks</span></code>, sometimes for
<code class="docutils literal notranslate"><span class="pre">samples</span></code>), so we try to mostly avoid it here.</p>
<p>PiecewisePolynomial objects can be added, subtracted, and multiplied.
They cannot be divided because Polynomials are not closed under
division.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>PiecewisePolynomial silently clips input evaluations outside of
the range defined by the breaks. So <code class="docutils literal notranslate"><span class="pre">pp.value(-2.0,</span> <span class="pre">row,</span> <span class="pre">col)</span></code>
in the example above would evaluate to -1.0. See value().</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.__init__">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Constructs an empty piecewise polynomial.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd], arg0: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; None</p></li>
</ol>
<p>Single segment, constant value constructor over the interval [-∞, ∞].
The constructed PiecewisePolynomial will return <code class="docutils literal notranslate"><span class="pre">constant_value</span></code> at
every evaluated point (i.e., <code class="docutils literal notranslate"><span class="pre">value(t)</span> <span class="pre">=</span> <span class="pre">constant_value</span></code> ∀t ∈ [-∞,
∞]).</p>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd], arg0: List[numpy.ndarray[object[m, n]]], arg1: List[pydrake.autodiffutils.AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Constructs a PiecewisePolynomial using matrix-output Polynomials
defined over each segment.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">polynomials.size()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span> <span class="pre">-</span> <span class="pre">1</span></code></p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd], arg0: List[pydrake.polynomial.Polynomial_[AutoDiffXd]], arg1: List[pydrake.autodiffutils.AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Constructs a PiecewisePolynomial using scalar-output Polynomials
defined over each segment.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">polynomials.size()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span> <span class="pre">-</span> <span class="pre">1</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.AppendCubicHermiteSegment">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].AppendCubicHermiteSegment"></span><span class="sig-name descname"><span class="pre">AppendCubicHermiteSegment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_dot</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.AppendCubicHermiteSegment" title="Permalink to this definition"></a></dt>
<dd><p>The CubicHermite spline construction has a nice property of being
incremental (each segment can be solved independently). Given a new
sample and it’s derivative, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code> where the start sample and derivative are taken as the value
and derivative at the final break of <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> is not empty()</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">time</span></code> &gt; end_time()</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">sample</span></code> and <code class="docutils literal notranslate"><span class="pre">sample_dot</span></code> must have size rows() x cols().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.AppendFirstOrderSegment">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].AppendFirstOrderSegment"></span><span class="sig-name descname"><span class="pre">AppendFirstOrderSegment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.AppendFirstOrderSegment" title="Permalink to this definition"></a></dt>
<dd><p>Given a new sample, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code> using a first-order hold, where the start sample is taken as
the value at the final break of <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.Block">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].Block"></span><span class="sig-name descname"><span class="pre">Block</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_row</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_rows</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_cols</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.Block" title="Permalink to this definition"></a></dt>
<dd><p>Extracts a trajectory representing a block of size (block_rows,
block_cols) starting at (start_row, start_col) from the
PiecewisePolynomial.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a PiecewisePolynomial such that ret.value(t) =
this.value(t).block(i,j,p,q);</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.Clone">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].Clone"></span><span class="sig-name descname"><span class="pre">Clone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.Clone" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.ConcatenateInTime">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].ConcatenateInTime"></span><span class="sig-name descname"><span class="pre">ConcatenateInTime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.ConcatenateInTime" title="Permalink to this definition"></a></dt>
<dd><p>Concatenates <code class="docutils literal notranslate"><span class="pre">other</span></code> to the end of <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The resulting PiecewisePolynomial will only be continuous to the
degree that the first Polynomial of <code class="docutils literal notranslate"><span class="pre">other</span></code> is continuous with
the last Polynomial of <code class="docutils literal notranslate"><span class="pre">this</span></code>. See warning about evaluating
discontinuous derivatives at breaks in derivative().</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other</span></code>:</dt><dd><p>PiecewisePolynomial instance to concatenate.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if trajectories' dimensions do not match each other</strong> – </p></li>
<li><p><strong>(</strong><strong>either rows</strong><strong>(</strong><strong>) or </strong><strong>cols</strong><strong>(</strong><strong>) </strong><strong>does not match between this and</strong> – </p></li>
<li><p><strong>other`</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if this-&gt;end_time</strong><strong>(</strong><strong>) </strong><strong>and other-&gt;start_time</strong><strong>(</strong><strong>)</strong> – </p></li>
<li><p><strong>are not within PiecewiseTrajectory&lt;T&gt;::kEpsilonTime from each</strong> – </p></li>
<li><p><strong>other.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.CubicHermite">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].CubicHermite"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">CubicHermite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.CubicHermite" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CubicHermite(breaks: List[pydrake.autodiffutils.AutoDiffXd], samples: List[List[pydrake.autodiffutils.AutoDiffXd]], samples_dot: List[List[pydrake.autodiffutils.AutoDiffXd]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</p></li>
</ol>
<p>Version of CubicHermite(breaks, samples, samples_dot) that uses vector
samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Corresponding
columns of <code class="docutils literal notranslate"><span class="pre">samples</span></code> and <code class="docutils literal notranslate"><span class="pre">samples_dot</span></code> are used as the sample
point and independent variable derivative, respectively.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">samples_dot.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>CubicHermite(breaks: List[pydrake.autodiffutils.AutoDiffXd], samples: List[numpy.ndarray[object[m, n]]], samples_dot: List[numpy.ndarray[object[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</p></li>
</ol>
<p>Constructs a third order PiecewisePolynomial using matrix samples and
derivatives of samples (<code class="docutils literal notranslate"><span class="pre">samples_dot</span></code>); each matrix element of
<code class="docutils literal notranslate"><span class="pre">samples_dot</span></code> represents the derivative with respect to the
independent variable (e.g., the time derivative) of the corresponding
entry in <code class="docutils literal notranslate"><span class="pre">samples</span></code>. Each segment is fully specified by <code class="docutils literal notranslate"><span class="pre">samples</span></code>
and <code class="docutils literal notranslate"><span class="pre">sample_dot</span></code> at both ends. Second derivatives are not
continuous.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.CubicShapePreserving">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].CubicShapePreserving"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">CubicShapePreserving</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.CubicShapePreserving" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CubicShapePreserving(breaks: List[pydrake.autodiffutils.AutoDiffXd], samples: List[List[pydrake.autodiffutils.AutoDiffXd]], zero_end_point_derivatives: bool = False) -&gt; pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</p></li>
</ol>
<p>Version of CubicShapePreserving(breaks, samples,
zero_end_point_derivatives) that uses vector samples and Eigen
VectorXd and MatrixX&lt;T&gt; arguments. Each column of <code class="docutils literal notranslate"><span class="pre">samples</span></code>
represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>CubicShapePreserving(breaks: List[pydrake.autodiffutils.AutoDiffXd], samples: List[numpy.ndarray[object[m, n]]], zero_end_point_derivatives: bool = False) -&gt; pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</p></li>
</ol>
<p>Constructs a third order PiecewisePolynomial using vector samples,
where each column of <code class="docutils literal notranslate"><span class="pre">samples</span></code> represents a sample point. First
derivatives are chosen to be “shape preserving”, i.e. if <code class="docutils literal notranslate"><span class="pre">samples</span></code>
is monotonic within some interval, the interpolated data will also be
monotonic. The second derivative is not guaranteed to be smooth across
the entire spline.</p>
<p>MATLAB calls this method “pchip” (short for “Piecewise Cubic Hermite
Interpolating Polynomial”), and provides a nice description in their
documentation.
<a class="reference external" href="http://home.uchicago.edu/~sctchoi/courses/cs138/interp.pdf">http://home.uchicago.edu/~sctchoi/courses/cs138/interp.pdf</a> is also a
good reference.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, the first and last
first derivative is chosen using a non-centered, shape-preserving
three-point formulae. See equation (2.10) in the following reference
for more details. <a class="reference external" href="http://www.mi.sanu.ac.rs/~gvm/radovi/mon.pdf">http://www.mi.sanu.ac.rs/~gvm/radovi/mon.pdf</a> If
<code class="docutils literal notranslate"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, they are set to zeros.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, <cite>breaks</cite> and
<code class="docutils literal notranslate"><span class="pre">samples</span></code> must have at least 3 elements for the algorithm to
determine the first derivatives.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, <cite>breaks</cite> and
<code class="docutils literal notranslate"><span class="pre">samples</span></code> may have 2 or more elements. For the 2 elements case, the
result is equivalent to computing a cubic polynomial whose values are
given by <code class="docutils literal notranslate"><span class="pre">samples</span></code>, and derivatives set to zero.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if</strong> – <ul>
<li><p><code class="docutils literal notranslate"><span class="pre">breaks</span></code> has length smaller than 3 and</p></li>
</ul>
</p></li>
<li><p><strong>zero_end_point_derivatives` is False</strong><strong>, </strong><strong>- breaks has lengt</strong> – </p></li>
<li><p><strong>smaller than 2 and zero_end_point_derivatives is true.</strong> – </p></li>
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.CubicWithContinuousSecondDerivatives">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].CubicWithContinuousSecondDerivatives"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">CubicWithContinuousSecondDerivatives</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.CubicWithContinuousSecondDerivatives" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CubicWithContinuousSecondDerivatives(breaks: List[pydrake.autodiffutils.AutoDiffXd], samples: List[List[pydrake.autodiffutils.AutoDiffXd]], sample_dot_at_start: numpy.ndarray[object[m, n]], sample_dot_at_end: numpy.ndarray[object[m, n]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</p></li>
</ol>
<p>Version of CubicWithContinuousSecondDerivatives() that uses vector
samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each column of
<code class="docutils literal notranslate"><span class="pre">samples</span></code> represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>CubicWithContinuousSecondDerivatives(breaks: List[pydrake.autodiffutils.AutoDiffXd], samples: List[numpy.ndarray[object[m, n]]], sample_dot_at_start: numpy.ndarray[object[m, n]], sample_dot_at_end: numpy.ndarray[object[m, n]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</p></li>
</ol>
<p>Constructs a third order PiecewisePolynomial using matrix samples. The
PiecewisePolynomial is constructed such that the interior segments
have the same value, first and second derivatives at <code class="docutils literal notranslate"><span class="pre">breaks</span></code>.
<cite>sample_dot_at_start</cite> and <code class="docutils literal notranslate"><span class="pre">sample_dot_at_end</span></code> are used for the first
and last first derivatives.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if sample_dot_at_start</strong><strong> or </strong><strong>sample_dot_at_end</strong> – </p></li>
<li><p><strong>and samples have inconsistent dimensions.</strong> – </p></li>
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>CubicWithContinuousSecondDerivatives(breaks: List[pydrake.autodiffutils.AutoDiffXd], samples: List[List[pydrake.autodiffutils.AutoDiffXd]], periodic_end_condition: bool = False) -&gt; pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</p></li>
</ol>
<p>Version of CubicWithContinuousSecondDerivatives(breaks, samples) that
uses vector samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each
column of <code class="docutils literal notranslate"><span class="pre">samples</span></code> represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>CubicWithContinuousSecondDerivatives(breaks: List[pydrake.autodiffutils.AutoDiffXd], samples: List[numpy.ndarray[object[m, n]]], periodic_end: bool) -&gt; pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</p></li>
</ol>
<p>Constructs a third order PiecewisePolynomial using matrix samples. The
PiecewisePolynomial is constructed such that the interior segments
have the same value, first and second derivatives at <code class="docutils literal notranslate"><span class="pre">breaks</span></code>. If
<code class="docutils literal notranslate"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code> (default), then the
“Not-a-sample” end condition is used here, which means the third
derivatives are continuous for the first two and last two segments. If
<code class="docutils literal notranslate"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, then the first and second
derivatives between the end of the last segment and the beginning of
the first segment will be continuous. Note that the periodic end
condition does not require the first and last sample to be collocated,
nor does it add an additional sample to connect the first and last
segments. Only first and second derivative continuity is enforced. See
<a class="reference external" href="https://en.wikipedia.org/wiki/Spline_interpolation">https://en.wikipedia.org/wiki/Spline_interpolation</a> and
<a class="reference external" href="https://www.math.uh.edu/~jingqiu/math4364/spline.pdf">https://www.math.uh.edu/~jingqiu/math4364/spline.pdf</a> for more about
cubic splines and their end conditions. The MATLAB docs for methods
“spline” and “csape” are also good references.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">breaks</span></code> and <code class="docutils literal notranslate"><span class="pre">samples</span></code> must have at least 3 elements. If
<code class="docutils literal notranslate"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, then for two samples, it
would produce a straight line (use <code class="docutils literal notranslate"><span class="pre">FirstOrderHold</span></code> for this
instead), and if <code class="docutils literal notranslate"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code> the
problem is ill-defined.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.derivative">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].derivative"></span><span class="sig-name descname"><span class="pre">derivative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derivative_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.derivative" title="Permalink to this definition"></a></dt>
<dd><p>Returns a PiecewisePolynomial where each segment is the specified
derivative of the corresponding segment in <code class="docutils literal notranslate"><span class="pre">this</span></code>. Any rules or
limitations of Polynomial::derivative() also apply to this function.</p>
<p>Derivatives evaluated at non-differentiable points return the value at
the left hand side of the interval.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code>:</dt><dd><p>The order of the derivative, namely, if <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code> = n,
the n’th derivative of the polynomial will be returned.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In the event of discontinuous derivatives evaluated at breaks, it
is not defined which polynomial (i.e., to the left or right of the
break) will be the one that is evaluated at the break.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.FirstOrderHold">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].FirstOrderHold"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">FirstOrderHold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.FirstOrderHold" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>FirstOrderHold(breaks: List[pydrake.autodiffutils.AutoDiffXd], samples: List[List[pydrake.autodiffutils.AutoDiffXd]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</p></li>
</ol>
<p>Version of FirstOrderHold(breaks, samples) that uses vector samples
and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each column of <code class="docutils literal notranslate"><span class="pre">samples</span></code>
represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>FirstOrderHold(breaks: List[pydrake.autodiffutils.AutoDiffXd], samples: List[numpy.ndarray[object[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</p></li>
</ol>
<p>Constructs a piecewise linear PiecewisePolynomial using matrix
samples.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.getPolynomial">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].getPolynomial"></span><span class="sig-name descname"><span class="pre">getPolynomial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.polynomial.html#pydrake.polynomial.Polynomial_" title="pydrake.polynomial.Polynomial_"><span class="pre">pydrake.polynomial.Polynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.getPolynomial" title="Permalink to this definition"></a></dt>
<dd><p>Gets the Polynomial with the given matrix row and column index that
corresponds to the given segment index. Equivalent to
<code class="docutils literal notranslate"><span class="pre">getPolynomialMatrix(segment_index)(row,</span> <span class="pre">col)</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calls PiecewiseTrajectory&lt;T&gt;::segment_number_range_check() to
validate <code class="docutils literal notranslate"><span class="pre">segment_index</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.getPolynomialMatrix">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].getPolynomialMatrix"></span><span class="sig-name descname"><span class="pre">getPolynomialMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.getPolynomialMatrix" title="Permalink to this definition"></a></dt>
<dd><p>Gets the matrix of Polynomials corresponding to the given segment
index.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><code class="docutils literal notranslate"><span class="pre">segment_index</span></code> is not checked for validity.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.getSegmentPolynomialDegree">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].getSegmentPolynomialDegree"></span><span class="sig-name descname"><span class="pre">getSegmentPolynomialDegree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.getSegmentPolynomialDegree" title="Permalink to this definition"></a></dt>
<dd><p>Gets the degree of the Polynomial with the given matrix row and column
index that corresponds to the given segment index. Equivalent to
<code class="docutils literal notranslate"><span class="pre">getPolynomial(segment_index,</span> <span class="pre">row,</span> <span class="pre">col).GetDegree()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.isApprox">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].isApprox"></span><span class="sig-name descname"><span class="pre">isApprox</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd],</span> <span class="pre">other:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd],</span> <span class="pre">tol:</span> <span class="pre">float,</span> <span class="pre">tol_type:</span> <span class="pre">pydrake.common._module_py.ToleranceType</span> <span class="pre">=</span> <span class="pre">&lt;ToleranceType.kRelative:</span> <span class="pre">1&gt;</span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.isApprox" title="Permalink to this definition"></a></dt>
<dd><p>Checks whether a PiecewisePolynomial is approximately equal to this
one by calling Polynomial&lt;T&gt;::CoefficientsAlmostEqual() on every
element of every segment.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Polynomial&lt;T&gt;::CoefficientsAlmostEqual().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.LagrangeInterpolatingPolynomial">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].LagrangeInterpolatingPolynomial"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">LagrangeInterpolatingPolynomial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.LagrangeInterpolatingPolynomial" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>LagrangeInterpolatingPolynomial(times: List[pydrake.autodiffutils.AutoDiffXd], samples: List[List[pydrake.autodiffutils.AutoDiffXd]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</p></li>
</ol>
<p>Version of LagrangeInterpolatingPolynomial(times, samples) that uses
vector samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each column
of <code class="docutils literal notranslate"><span class="pre">samples</span></code> represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">times.size()</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>LagrangeInterpolatingPolynomial(times: List[pydrake.autodiffutils.AutoDiffXd], samples: List[numpy.ndarray[object[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</p></li>
</ol>
<p>Constructs a polynomial with a <em>single segment</em> of the lowest possible
degree that passes through all of the sample points. See “polynomial
interpolation” and/or “Lagrange polynomial” on Wikipedia for more
information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">times</span></code> must be monotonically increasing.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.size()</span> <span class="pre">==</span> <span class="pre">times.size()</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.RemoveFinalSegment">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].RemoveFinalSegment"></span><span class="sig-name descname"><span class="pre">RemoveFinalSegment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.RemoveFinalSegment" title="Permalink to this definition"></a></dt>
<dd><p>Removes the final segment from the trajectory, reducing the number of
segments by 1.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> is not empty()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.Reshape">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].Reshape"></span><span class="sig-name descname"><span class="pre">Reshape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rows</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cols</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.Reshape" title="Permalink to this definition"></a></dt>
<dd><p>Reshapes the dimensions of the Eigen::MatrixX&lt;T&gt; returned by value(),
EvalDerivative(), etc.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">rows</span></code> x <code class="docutils literal notranslate"><span class="pre">cols</span></code> must equal this.rows() * this.cols().</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Eigen::PlainObjectBase::resize().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.ReverseTime">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].ReverseTime"></span><span class="sig-name descname"><span class="pre">ReverseTime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.ReverseTime" title="Permalink to this definition"></a></dt>
<dd><p>Modifies the trajectory so that pp_after(t) = pp_before(-t).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The new trajectory will evaluate differently at precisely the
break points if the original trajectory was discontinuous at the
break points. This is because the segments are defined on the
half-open intervals [breaks(i), breaks(i+1)), and the order of the
breaks have been reversed.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.ScaleTime">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].ScaleTime"></span><span class="sig-name descname"><span class="pre">ScaleTime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.ScaleTime" title="Permalink to this definition"></a></dt>
<dd><p>Scales the time of the trajectory by non-negative <code class="docutils literal notranslate"><span class="pre">scale</span></code> (use
ReverseTime() if you want to also negate time). The resulting
polynomial evaluates to pp_after(t) = pp_before(t/scale).</p>
<p>As an example, <a href="#id5"><span class="problematic" id="id6">`</span></a>scale`=2 will result in a trajectory that is twice as
long (start_time() and end_time() have both doubled).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.setPolynomialMatrixBlock">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].setPolynomialMatrixBlock"></span><span class="sig-name descname"><span class="pre">setPolynomialMatrixBlock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">replacement</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row_start</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col_start</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.setPolynomialMatrixBlock" title="Permalink to this definition"></a></dt>
<dd><p>Replaces the specified block of the PolynomialMatrix at the given
segment index.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calls PiecewiseTrajectory&lt;T&gt;::segment_number_range_check() to
validate <code class="docutils literal notranslate"><span class="pre">segment_index</span></code>.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This code relies upon Eigen to verify that the replacement block
is not too large.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.shiftRight">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].shiftRight"></span><span class="sig-name descname"><span class="pre">shiftRight</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.shiftRight" title="Permalink to this definition"></a></dt>
<dd><p>Adds <code class="docutils literal notranslate"><span class="pre">offset</span></code> to all of the breaks. <code class="docutils literal notranslate"><span class="pre">offset</span></code> need not be a
non-negative number. The resulting polynomial will evaluate to
pp_after(t) = pp_before(t-offset).</p>
<p>As an example, <a href="#id7"><span class="problematic" id="id8">`</span></a>offset`=2 will result in the start_time() and
end_time() being 2 seconds later.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.slice">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].slice"></span><span class="sig-name descname"><span class="pre">slice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_segments</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.slice" title="Permalink to this definition"></a></dt>
<dd><p>Returns the PiecewisePolynomial comprising the <code class="docutils literal notranslate"><span class="pre">num_segments</span></code>
segments starting at the specified <code class="docutils literal notranslate"><span class="pre">start_segment_index</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calls PiecewiseTrajectory&lt;T&gt;::segment_number_range_check() to
validate <code class="docutils literal notranslate"><span class="pre">segment_index</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.Transpose">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].Transpose"></span><span class="sig-name descname"><span class="pre">Transpose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.Transpose" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a new PiecewisePolynomial for which value(t) ==
this.value(t).transpose().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.ZeroOrderHold">
<span id="pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd].ZeroOrderHold"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ZeroOrderHold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-AutoDiffXd-.ZeroOrderHold" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>ZeroOrderHold(breaks: List[pydrake.autodiffutils.AutoDiffXd], samples: List[List[pydrake.autodiffutils.AutoDiffXd]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</p></li>
</ol>
<p>Version of ZeroOrderHold(breaks, samples) that uses vector samples and
Eigen VectorXd/MatrixX&lt;T&gt; arguments. Each column of <code class="docutils literal notranslate"><span class="pre">samples</span></code>
represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>ZeroOrderHold(breaks: List[pydrake.autodiffutils.AutoDiffXd], samples: List[numpy.ndarray[object[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</p></li>
</ol>
<p>Constructs a piecewise constant PiecewisePolynomial using matrix
samples. Note that constructing a PiecewisePolynomial requires at
least two sample points, although in this case, the second sample
point’s value is ignored, and only its break time is used.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PiecewisePolynomial_[Expression]</span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_-Expression" title="pydrake.trajectories.PiecewiseTrajectory_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_[Expression]</span></code></a></p>
<p>A scalar multi-variate piecewise polynomial.</p>
<p>PiecewisePolynomial represents a list of contiguous segments in a
scalar independent variable (typically corresponding to time) with
Polynomials defined at each segment. We call the output from
evaluating the PiecewisePolynomial at the scalar independent variable
“the output”, and that output can be either a Eigen MatrixX&lt;T&gt; (if
evaluated using value()) or a scalar (if evaluated using
scalar_value()).</p>
<p>An example of a piecewise polynomial is a function of m segments in
time, where a different polynomial is defined for each segment. For a
specific example, consider the absolute value function over the
interval [-1, 1]. We can define a PiecewisePolynomial over this
interval using breaks at t = { -1.0, 0.0, 1.0 }, and “samples” of
abs(t).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Construct</span> <span class="n">the</span> <span class="n">PiecewisePolynomial</span><span class="o">.</span>
<span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">breaks</span> <span class="o">=</span> <span class="p">{</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span> <span class="p">};</span>
<span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="p">::</span><span class="n">MatrixXd</span><span class="o">&gt;</span> <span class="n">samples</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">breaks</span><span class="o">.</span><span class="n">size</span><span class="p">());</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">std</span><span class="p">::</span><span class="nb">abs</span><span class="p">(</span><span class="n">breaks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
<span class="n">const</span> <span class="n">auto</span> <span class="n">pp</span> <span class="o">=</span>
     <span class="n">PiecewisePolynomial</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">::</span><span class="n">FirstOrderHold</span><span class="p">(</span><span class="n">breaks</span><span class="p">,</span> <span class="n">samples</span><span class="p">);</span>
<span class="n">const</span> <span class="nb">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Evaluate</span> <span class="n">the</span> <span class="n">PiecewisePolynomial</span> <span class="n">at</span> <span class="n">some</span> <span class="n">values</span><span class="o">.</span>
<span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="o">-</span><span class="mf">.5</span><span class="p">)(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>    <span class="o">//</span> <span class="n">Outputs</span> <span class="mf">0.5</span><span class="o">.</span>
<span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>    <span class="o">//</span> <span class="n">Outputs</span> <span class="mf">0.0</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Show</span> <span class="n">how</span> <span class="n">we</span> <span class="n">can</span> <span class="n">evaluate</span> <span class="n">the</span> <span class="n">first</span> <span class="n">derivative</span> <span class="p">(</span><span class="n">outputs</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span><span class="o">.</span>
<span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="o">-</span><span class="mf">.5</span><span class="p">)(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>A note on terminology. For piecewise-polynomial interpolation, we use
<code class="docutils literal notranslate"><span class="pre">breaks</span></code> to indicate the scalar (e.g. times) which form the boundary
of each segment. We use <code class="docutils literal notranslate"><span class="pre">samples</span></code> to indicate the function value at
the <code class="docutils literal notranslate"><span class="pre">breaks</span></code>, e.g. <code class="docutils literal notranslate"><span class="pre">p(breaks[i])</span> <span class="pre">=</span> <span class="pre">samples[i]</span></code>. The term <code class="docutils literal notranslate"><span class="pre">knot</span></code>
should be reserved for the “(x,y)” coordinate, here <code class="docutils literal notranslate"><span class="pre">knot[i]</span> <span class="pre">=</span>
<span class="pre">(breaks[i],</span> <span class="pre">samples[i])</span></code>, though it is used inconsistently in the
interpolation literature (sometimes for <code class="docutils literal notranslate"><span class="pre">breaks</span></code>, sometimes for
<code class="docutils literal notranslate"><span class="pre">samples</span></code>), so we try to mostly avoid it here.</p>
<p>PiecewisePolynomial objects can be added, subtracted, and multiplied.
They cannot be divided because Polynomials are not closed under
division.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>PiecewisePolynomial silently clips input evaluations outside of
the range defined by the breaks. So <code class="docutils literal notranslate"><span class="pre">pp.value(-2.0,</span> <span class="pre">row,</span> <span class="pre">col)</span></code>
in the example above would evaluate to -1.0. See value().</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.__init__">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.PiecewisePolynomial_[Expression]) -&gt; None</p></li>
</ol>
<p>Constructs an empty piecewise polynomial.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.trajectories.PiecewisePolynomial_[Expression], arg0: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; None</p></li>
</ol>
<p>Single segment, constant value constructor over the interval [-∞, ∞].
The constructed PiecewisePolynomial will return <code class="docutils literal notranslate"><span class="pre">constant_value</span></code> at
every evaluated point (i.e., <code class="docutils literal notranslate"><span class="pre">value(t)</span> <span class="pre">=</span> <span class="pre">constant_value</span></code> ∀t ∈ [-∞,
∞]).</p>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.trajectories.PiecewisePolynomial_[Expression], arg0: List[numpy.ndarray[object[m, n]]], arg1: List[pydrake.symbolic.Expression]) -&gt; None</p></li>
</ol>
<p>Constructs a PiecewisePolynomial using matrix-output Polynomials
defined over each segment.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">polynomials.size()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span> <span class="pre">-</span> <span class="pre">1</span></code></p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.trajectories.PiecewisePolynomial_[Expression], arg0: List[pydrake.polynomial.Polynomial_[Expression]], arg1: List[pydrake.symbolic.Expression]) -&gt; None</p></li>
</ol>
<p>Constructs a PiecewisePolynomial using scalar-output Polynomials
defined over each segment.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">polynomials.size()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span> <span class="pre">-</span> <span class="pre">1</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.AppendCubicHermiteSegment">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].AppendCubicHermiteSegment"></span><span class="sig-name descname"><span class="pre">AppendCubicHermiteSegment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_dot</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.AppendCubicHermiteSegment" title="Permalink to this definition"></a></dt>
<dd><p>The CubicHermite spline construction has a nice property of being
incremental (each segment can be solved independently). Given a new
sample and it’s derivative, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code> where the start sample and derivative are taken as the value
and derivative at the final break of <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> is not empty()</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">time</span></code> &gt; end_time()</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">sample</span></code> and <code class="docutils literal notranslate"><span class="pre">sample_dot</span></code> must have size rows() x cols().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.AppendFirstOrderSegment">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].AppendFirstOrderSegment"></span><span class="sig-name descname"><span class="pre">AppendFirstOrderSegment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.AppendFirstOrderSegment" title="Permalink to this definition"></a></dt>
<dd><p>Given a new sample, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code> using a first-order hold, where the start sample is taken as
the value at the final break of <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.Block">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].Block"></span><span class="sig-name descname"><span class="pre">Block</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_row</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_rows</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_cols</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.Block" title="Permalink to this definition"></a></dt>
<dd><p>Extracts a trajectory representing a block of size (block_rows,
block_cols) starting at (start_row, start_col) from the
PiecewisePolynomial.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a PiecewisePolynomial such that ret.value(t) =
this.value(t).block(i,j,p,q);</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.Clone">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].Clone"></span><span class="sig-name descname"><span class="pre">Clone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.Clone" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.ConcatenateInTime">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].ConcatenateInTime"></span><span class="sig-name descname"><span class="pre">ConcatenateInTime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.ConcatenateInTime" title="Permalink to this definition"></a></dt>
<dd><p>Concatenates <code class="docutils literal notranslate"><span class="pre">other</span></code> to the end of <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The resulting PiecewisePolynomial will only be continuous to the
degree that the first Polynomial of <code class="docutils literal notranslate"><span class="pre">other</span></code> is continuous with
the last Polynomial of <code class="docutils literal notranslate"><span class="pre">this</span></code>. See warning about evaluating
discontinuous derivatives at breaks in derivative().</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other</span></code>:</dt><dd><p>PiecewisePolynomial instance to concatenate.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if trajectories' dimensions do not match each other</strong> – </p></li>
<li><p><strong>(</strong><strong>either rows</strong><strong>(</strong><strong>) or </strong><strong>cols</strong><strong>(</strong><strong>) </strong><strong>does not match between this and</strong> – </p></li>
<li><p><strong>other`</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if this-&gt;end_time</strong><strong>(</strong><strong>) </strong><strong>and other-&gt;start_time</strong><strong>(</strong><strong>)</strong> – </p></li>
<li><p><strong>are not within PiecewiseTrajectory&lt;T&gt;::kEpsilonTime from each</strong> – </p></li>
<li><p><strong>other.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.CubicHermite">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].CubicHermite"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">CubicHermite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.CubicHermite" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CubicHermite(breaks: List[pydrake.symbolic.Expression], samples: List[List[pydrake.symbolic.Expression]], samples_dot: List[List[pydrake.symbolic.Expression]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[Expression]</p></li>
</ol>
<p>Version of CubicHermite(breaks, samples, samples_dot) that uses vector
samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Corresponding
columns of <code class="docutils literal notranslate"><span class="pre">samples</span></code> and <code class="docutils literal notranslate"><span class="pre">samples_dot</span></code> are used as the sample
point and independent variable derivative, respectively.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">samples_dot.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>CubicHermite(breaks: List[pydrake.symbolic.Expression], samples: List[numpy.ndarray[object[m, n]]], samples_dot: List[numpy.ndarray[object[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[Expression]</p></li>
</ol>
<p>Constructs a third order PiecewisePolynomial using matrix samples and
derivatives of samples (<code class="docutils literal notranslate"><span class="pre">samples_dot</span></code>); each matrix element of
<code class="docutils literal notranslate"><span class="pre">samples_dot</span></code> represents the derivative with respect to the
independent variable (e.g., the time derivative) of the corresponding
entry in <code class="docutils literal notranslate"><span class="pre">samples</span></code>. Each segment is fully specified by <code class="docutils literal notranslate"><span class="pre">samples</span></code>
and <code class="docutils literal notranslate"><span class="pre">sample_dot</span></code> at both ends. Second derivatives are not
continuous.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.CubicShapePreserving">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].CubicShapePreserving"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">CubicShapePreserving</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.CubicShapePreserving" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CubicShapePreserving(breaks: List[pydrake.symbolic.Expression], samples: List[List[pydrake.symbolic.Expression]], zero_end_point_derivatives: bool = False) -&gt; pydrake.trajectories.PiecewisePolynomial_[Expression]</p></li>
</ol>
<p>Version of CubicShapePreserving(breaks, samples,
zero_end_point_derivatives) that uses vector samples and Eigen
VectorXd and MatrixX&lt;T&gt; arguments. Each column of <code class="docutils literal notranslate"><span class="pre">samples</span></code>
represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>CubicShapePreserving(breaks: List[pydrake.symbolic.Expression], samples: List[numpy.ndarray[object[m, n]]], zero_end_point_derivatives: bool = False) -&gt; pydrake.trajectories.PiecewisePolynomial_[Expression]</p></li>
</ol>
<p>Constructs a third order PiecewisePolynomial using vector samples,
where each column of <code class="docutils literal notranslate"><span class="pre">samples</span></code> represents a sample point. First
derivatives are chosen to be “shape preserving”, i.e. if <code class="docutils literal notranslate"><span class="pre">samples</span></code>
is monotonic within some interval, the interpolated data will also be
monotonic. The second derivative is not guaranteed to be smooth across
the entire spline.</p>
<p>MATLAB calls this method “pchip” (short for “Piecewise Cubic Hermite
Interpolating Polynomial”), and provides a nice description in their
documentation.
<a class="reference external" href="http://home.uchicago.edu/~sctchoi/courses/cs138/interp.pdf">http://home.uchicago.edu/~sctchoi/courses/cs138/interp.pdf</a> is also a
good reference.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, the first and last
first derivative is chosen using a non-centered, shape-preserving
three-point formulae. See equation (2.10) in the following reference
for more details. <a class="reference external" href="http://www.mi.sanu.ac.rs/~gvm/radovi/mon.pdf">http://www.mi.sanu.ac.rs/~gvm/radovi/mon.pdf</a> If
<code class="docutils literal notranslate"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, they are set to zeros.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, <cite>breaks</cite> and
<code class="docutils literal notranslate"><span class="pre">samples</span></code> must have at least 3 elements for the algorithm to
determine the first derivatives.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, <cite>breaks</cite> and
<code class="docutils literal notranslate"><span class="pre">samples</span></code> may have 2 or more elements. For the 2 elements case, the
result is equivalent to computing a cubic polynomial whose values are
given by <code class="docutils literal notranslate"><span class="pre">samples</span></code>, and derivatives set to zero.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if</strong> – <ul>
<li><p><code class="docutils literal notranslate"><span class="pre">breaks</span></code> has length smaller than 3 and</p></li>
</ul>
</p></li>
<li><p><strong>zero_end_point_derivatives` is False</strong><strong>, </strong><strong>- breaks has lengt</strong> – </p></li>
<li><p><strong>smaller than 2 and zero_end_point_derivatives is true.</strong> – </p></li>
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.CubicWithContinuousSecondDerivatives">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].CubicWithContinuousSecondDerivatives"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">CubicWithContinuousSecondDerivatives</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.CubicWithContinuousSecondDerivatives" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CubicWithContinuousSecondDerivatives(breaks: List[pydrake.symbolic.Expression], samples: List[List[pydrake.symbolic.Expression]], sample_dot_at_start: numpy.ndarray[object[m, n]], sample_dot_at_end: numpy.ndarray[object[m, n]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[Expression]</p></li>
</ol>
<p>Version of CubicWithContinuousSecondDerivatives() that uses vector
samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each column of
<code class="docutils literal notranslate"><span class="pre">samples</span></code> represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>CubicWithContinuousSecondDerivatives(breaks: List[pydrake.symbolic.Expression], samples: List[numpy.ndarray[object[m, n]]], sample_dot_at_start: numpy.ndarray[object[m, n]], sample_dot_at_end: numpy.ndarray[object[m, n]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[Expression]</p></li>
</ol>
<p>Constructs a third order PiecewisePolynomial using matrix samples. The
PiecewisePolynomial is constructed such that the interior segments
have the same value, first and second derivatives at <code class="docutils literal notranslate"><span class="pre">breaks</span></code>.
<cite>sample_dot_at_start</cite> and <code class="docutils literal notranslate"><span class="pre">sample_dot_at_end</span></code> are used for the first
and last first derivatives.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if sample_dot_at_start</strong><strong> or </strong><strong>sample_dot_at_end</strong> – </p></li>
<li><p><strong>and samples have inconsistent dimensions.</strong> – </p></li>
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>CubicWithContinuousSecondDerivatives(breaks: List[pydrake.symbolic.Expression], samples: List[List[pydrake.symbolic.Expression]], periodic_end_condition: bool = False) -&gt; pydrake.trajectories.PiecewisePolynomial_[Expression]</p></li>
</ol>
<p>Version of CubicWithContinuousSecondDerivatives(breaks, samples) that
uses vector samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each
column of <code class="docutils literal notranslate"><span class="pre">samples</span></code> represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>CubicWithContinuousSecondDerivatives(breaks: List[pydrake.symbolic.Expression], samples: List[numpy.ndarray[object[m, n]]], periodic_end: bool) -&gt; pydrake.trajectories.PiecewisePolynomial_[Expression]</p></li>
</ol>
<p>Constructs a third order PiecewisePolynomial using matrix samples. The
PiecewisePolynomial is constructed such that the interior segments
have the same value, first and second derivatives at <code class="docutils literal notranslate"><span class="pre">breaks</span></code>. If
<code class="docutils literal notranslate"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code> (default), then the
“Not-a-sample” end condition is used here, which means the third
derivatives are continuous for the first two and last two segments. If
<code class="docutils literal notranslate"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, then the first and second
derivatives between the end of the last segment and the beginning of
the first segment will be continuous. Note that the periodic end
condition does not require the first and last sample to be collocated,
nor does it add an additional sample to connect the first and last
segments. Only first and second derivative continuity is enforced. See
<a class="reference external" href="https://en.wikipedia.org/wiki/Spline_interpolation">https://en.wikipedia.org/wiki/Spline_interpolation</a> and
<a class="reference external" href="https://www.math.uh.edu/~jingqiu/math4364/spline.pdf">https://www.math.uh.edu/~jingqiu/math4364/spline.pdf</a> for more about
cubic splines and their end conditions. The MATLAB docs for methods
“spline” and “csape” are also good references.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">breaks</span></code> and <code class="docutils literal notranslate"><span class="pre">samples</span></code> must have at least 3 elements. If
<code class="docutils literal notranslate"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, then for two samples, it
would produce a straight line (use <code class="docutils literal notranslate"><span class="pre">FirstOrderHold</span></code> for this
instead), and if <code class="docutils literal notranslate"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code> the
problem is ill-defined.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.derivative">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].derivative"></span><span class="sig-name descname"><span class="pre">derivative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derivative_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.derivative" title="Permalink to this definition"></a></dt>
<dd><p>Returns a PiecewisePolynomial where each segment is the specified
derivative of the corresponding segment in <code class="docutils literal notranslate"><span class="pre">this</span></code>. Any rules or
limitations of Polynomial::derivative() also apply to this function.</p>
<p>Derivatives evaluated at non-differentiable points return the value at
the left hand side of the interval.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code>:</dt><dd><p>The order of the derivative, namely, if <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code> = n,
the n’th derivative of the polynomial will be returned.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In the event of discontinuous derivatives evaluated at breaks, it
is not defined which polynomial (i.e., to the left or right of the
break) will be the one that is evaluated at the break.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.FirstOrderHold">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].FirstOrderHold"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">FirstOrderHold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.FirstOrderHold" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>FirstOrderHold(breaks: List[pydrake.symbolic.Expression], samples: List[List[pydrake.symbolic.Expression]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[Expression]</p></li>
</ol>
<p>Version of FirstOrderHold(breaks, samples) that uses vector samples
and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each column of <code class="docutils literal notranslate"><span class="pre">samples</span></code>
represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>FirstOrderHold(breaks: List[pydrake.symbolic.Expression], samples: List[numpy.ndarray[object[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[Expression]</p></li>
</ol>
<p>Constructs a piecewise linear PiecewisePolynomial using matrix
samples.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.getPolynomial">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].getPolynomial"></span><span class="sig-name descname"><span class="pre">getPolynomial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.polynomial.html#pydrake.polynomial.Polynomial_" title="pydrake.polynomial.Polynomial_"><span class="pre">pydrake.polynomial.Polynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.getPolynomial" title="Permalink to this definition"></a></dt>
<dd><p>Gets the Polynomial with the given matrix row and column index that
corresponds to the given segment index. Equivalent to
<code class="docutils literal notranslate"><span class="pre">getPolynomialMatrix(segment_index)(row,</span> <span class="pre">col)</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calls PiecewiseTrajectory&lt;T&gt;::segment_number_range_check() to
validate <code class="docutils literal notranslate"><span class="pre">segment_index</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.getPolynomialMatrix">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].getPolynomialMatrix"></span><span class="sig-name descname"><span class="pre">getPolynomialMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.getPolynomialMatrix" title="Permalink to this definition"></a></dt>
<dd><p>Gets the matrix of Polynomials corresponding to the given segment
index.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><code class="docutils literal notranslate"><span class="pre">segment_index</span></code> is not checked for validity.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.getSegmentPolynomialDegree">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].getSegmentPolynomialDegree"></span><span class="sig-name descname"><span class="pre">getSegmentPolynomialDegree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.getSegmentPolynomialDegree" title="Permalink to this definition"></a></dt>
<dd><p>Gets the degree of the Polynomial with the given matrix row and column
index that corresponds to the given segment index. Equivalent to
<code class="docutils literal notranslate"><span class="pre">getPolynomial(segment_index,</span> <span class="pre">row,</span> <span class="pre">col).GetDegree()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.isApprox">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].isApprox"></span><span class="sig-name descname"><span class="pre">isApprox</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[Expression],</span> <span class="pre">other:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[Expression],</span> <span class="pre">tol:</span> <span class="pre">float,</span> <span class="pre">tol_type:</span> <span class="pre">pydrake.common._module_py.ToleranceType</span> <span class="pre">=</span> <span class="pre">&lt;ToleranceType.kRelative:</span> <span class="pre">1&gt;</span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.isApprox" title="Permalink to this definition"></a></dt>
<dd><p>Checks whether a PiecewisePolynomial is approximately equal to this
one by calling Polynomial&lt;T&gt;::CoefficientsAlmostEqual() on every
element of every segment.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Polynomial&lt;T&gt;::CoefficientsAlmostEqual().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.LagrangeInterpolatingPolynomial">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].LagrangeInterpolatingPolynomial"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">LagrangeInterpolatingPolynomial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.LagrangeInterpolatingPolynomial" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>LagrangeInterpolatingPolynomial(times: List[pydrake.symbolic.Expression], samples: List[List[pydrake.symbolic.Expression]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[Expression]</p></li>
</ol>
<p>Version of LagrangeInterpolatingPolynomial(times, samples) that uses
vector samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each column
of <code class="docutils literal notranslate"><span class="pre">samples</span></code> represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">times.size()</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>LagrangeInterpolatingPolynomial(times: List[pydrake.symbolic.Expression], samples: List[numpy.ndarray[object[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[Expression]</p></li>
</ol>
<p>Constructs a polynomial with a <em>single segment</em> of the lowest possible
degree that passes through all of the sample points. See “polynomial
interpolation” and/or “Lagrange polynomial” on Wikipedia for more
information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">times</span></code> must be monotonically increasing.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.size()</span> <span class="pre">==</span> <span class="pre">times.size()</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.RemoveFinalSegment">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].RemoveFinalSegment"></span><span class="sig-name descname"><span class="pre">RemoveFinalSegment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.RemoveFinalSegment" title="Permalink to this definition"></a></dt>
<dd><p>Removes the final segment from the trajectory, reducing the number of
segments by 1.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> is not empty()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.Reshape">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].Reshape"></span><span class="sig-name descname"><span class="pre">Reshape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rows</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cols</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.Reshape" title="Permalink to this definition"></a></dt>
<dd><p>Reshapes the dimensions of the Eigen::MatrixX&lt;T&gt; returned by value(),
EvalDerivative(), etc.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">rows</span></code> x <code class="docutils literal notranslate"><span class="pre">cols</span></code> must equal this.rows() * this.cols().</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Eigen::PlainObjectBase::resize().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.ReverseTime">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].ReverseTime"></span><span class="sig-name descname"><span class="pre">ReverseTime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.ReverseTime" title="Permalink to this definition"></a></dt>
<dd><p>Modifies the trajectory so that pp_after(t) = pp_before(-t).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The new trajectory will evaluate differently at precisely the
break points if the original trajectory was discontinuous at the
break points. This is because the segments are defined on the
half-open intervals [breaks(i), breaks(i+1)), and the order of the
breaks have been reversed.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.ScaleTime">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].ScaleTime"></span><span class="sig-name descname"><span class="pre">ScaleTime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.ScaleTime" title="Permalink to this definition"></a></dt>
<dd><p>Scales the time of the trajectory by non-negative <code class="docutils literal notranslate"><span class="pre">scale</span></code> (use
ReverseTime() if you want to also negate time). The resulting
polynomial evaluates to pp_after(t) = pp_before(t/scale).</p>
<p>As an example, <a href="#id9"><span class="problematic" id="id10">`</span></a>scale`=2 will result in a trajectory that is twice as
long (start_time() and end_time() have both doubled).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.setPolynomialMatrixBlock">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].setPolynomialMatrixBlock"></span><span class="sig-name descname"><span class="pre">setPolynomialMatrixBlock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">replacement</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row_start</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col_start</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.setPolynomialMatrixBlock" title="Permalink to this definition"></a></dt>
<dd><p>Replaces the specified block of the PolynomialMatrix at the given
segment index.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calls PiecewiseTrajectory&lt;T&gt;::segment_number_range_check() to
validate <code class="docutils literal notranslate"><span class="pre">segment_index</span></code>.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This code relies upon Eigen to verify that the replacement block
is not too large.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.shiftRight">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].shiftRight"></span><span class="sig-name descname"><span class="pre">shiftRight</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.shiftRight" title="Permalink to this definition"></a></dt>
<dd><p>Adds <code class="docutils literal notranslate"><span class="pre">offset</span></code> to all of the breaks. <code class="docutils literal notranslate"><span class="pre">offset</span></code> need not be a
non-negative number. The resulting polynomial will evaluate to
pp_after(t) = pp_before(t-offset).</p>
<p>As an example, <a href="#id11"><span class="problematic" id="id12">`</span></a>offset`=2 will result in the start_time() and
end_time() being 2 seconds later.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.slice">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].slice"></span><span class="sig-name descname"><span class="pre">slice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_segments</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.slice" title="Permalink to this definition"></a></dt>
<dd><p>Returns the PiecewisePolynomial comprising the <code class="docutils literal notranslate"><span class="pre">num_segments</span></code>
segments starting at the specified <code class="docutils literal notranslate"><span class="pre">start_segment_index</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calls PiecewiseTrajectory&lt;T&gt;::segment_number_range_check() to
validate <code class="docutils literal notranslate"><span class="pre">segment_index</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.Transpose">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].Transpose"></span><span class="sig-name descname"><span class="pre">Transpose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.Transpose" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a new PiecewisePolynomial for which value(t) ==
this.value(t).transpose().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-Expression-.ZeroOrderHold">
<span id="pydrake.trajectories.PiecewisePolynomial_[Expression].ZeroOrderHold"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ZeroOrderHold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-Expression-.ZeroOrderHold" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>ZeroOrderHold(breaks: List[pydrake.symbolic.Expression], samples: List[List[pydrake.symbolic.Expression]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[Expression]</p></li>
</ol>
<p>Version of ZeroOrderHold(breaks, samples) that uses vector samples and
Eigen VectorXd/MatrixX&lt;T&gt; arguments. Each column of <code class="docutils literal notranslate"><span class="pre">samples</span></code>
represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>ZeroOrderHold(breaks: List[pydrake.symbolic.Expression], samples: List[numpy.ndarray[object[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[Expression]</p></li>
</ol>
<p>Constructs a piecewise constant PiecewisePolynomial using matrix
samples. Note that constructing a PiecewisePolynomial requires at
least two sample points, although in this case, the second sample
point’s value is ignored, and only its break time is used.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-float">
<span id="pydrake.trajectories.PiecewisePolynomial_[float]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PiecewisePolynomial_[float]</span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-float" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_-float" title="pydrake.trajectories.PiecewiseTrajectory_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_[float]</span></code></a></p>
<p>A scalar multi-variate piecewise polynomial.</p>
<p>PiecewisePolynomial represents a list of contiguous segments in a
scalar independent variable (typically corresponding to time) with
Polynomials defined at each segment. We call the output from
evaluating the PiecewisePolynomial at the scalar independent variable
“the output”, and that output can be either a Eigen MatrixX&lt;T&gt; (if
evaluated using value()) or a scalar (if evaluated using
scalar_value()).</p>
<p>An example of a piecewise polynomial is a function of m segments in
time, where a different polynomial is defined for each segment. For a
specific example, consider the absolute value function over the
interval [-1, 1]. We can define a PiecewisePolynomial over this
interval using breaks at t = { -1.0, 0.0, 1.0 }, and “samples” of
abs(t).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Construct</span> <span class="n">the</span> <span class="n">PiecewisePolynomial</span><span class="o">.</span>
<span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">breaks</span> <span class="o">=</span> <span class="p">{</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span> <span class="p">};</span>
<span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="p">::</span><span class="n">MatrixXd</span><span class="o">&gt;</span> <span class="n">samples</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">breaks</span><span class="o">.</span><span class="n">size</span><span class="p">());</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">std</span><span class="p">::</span><span class="nb">abs</span><span class="p">(</span><span class="n">breaks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
<span class="n">const</span> <span class="n">auto</span> <span class="n">pp</span> <span class="o">=</span>
     <span class="n">PiecewisePolynomial</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">::</span><span class="n">FirstOrderHold</span><span class="p">(</span><span class="n">breaks</span><span class="p">,</span> <span class="n">samples</span><span class="p">);</span>
<span class="n">const</span> <span class="nb">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Evaluate</span> <span class="n">the</span> <span class="n">PiecewisePolynomial</span> <span class="n">at</span> <span class="n">some</span> <span class="n">values</span><span class="o">.</span>
<span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="o">-</span><span class="mf">.5</span><span class="p">)(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>    <span class="o">//</span> <span class="n">Outputs</span> <span class="mf">0.5</span><span class="o">.</span>
<span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>    <span class="o">//</span> <span class="n">Outputs</span> <span class="mf">0.0</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Show</span> <span class="n">how</span> <span class="n">we</span> <span class="n">can</span> <span class="n">evaluate</span> <span class="n">the</span> <span class="n">first</span> <span class="n">derivative</span> <span class="p">(</span><span class="n">outputs</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span><span class="o">.</span>
<span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="o">-</span><span class="mf">.5</span><span class="p">)(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>A note on terminology. For piecewise-polynomial interpolation, we use
<code class="docutils literal notranslate"><span class="pre">breaks</span></code> to indicate the scalar (e.g. times) which form the boundary
of each segment. We use <code class="docutils literal notranslate"><span class="pre">samples</span></code> to indicate the function value at
the <code class="docutils literal notranslate"><span class="pre">breaks</span></code>, e.g. <code class="docutils literal notranslate"><span class="pre">p(breaks[i])</span> <span class="pre">=</span> <span class="pre">samples[i]</span></code>. The term <code class="docutils literal notranslate"><span class="pre">knot</span></code>
should be reserved for the “(x,y)” coordinate, here <code class="docutils literal notranslate"><span class="pre">knot[i]</span> <span class="pre">=</span>
<span class="pre">(breaks[i],</span> <span class="pre">samples[i])</span></code>, though it is used inconsistently in the
interpolation literature (sometimes for <code class="docutils literal notranslate"><span class="pre">breaks</span></code>, sometimes for
<code class="docutils literal notranslate"><span class="pre">samples</span></code>), so we try to mostly avoid it here.</p>
<p>PiecewisePolynomial objects can be added, subtracted, and multiplied.
They cannot be divided because Polynomials are not closed under
division.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>PiecewisePolynomial silently clips input evaluations outside of
the range defined by the breaks. So <code class="docutils literal notranslate"><span class="pre">pp.value(-2.0,</span> <span class="pre">row,</span> <span class="pre">col)</span></code>
in the example above would evaluate to -1.0. See value().</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-float-.__init__">
<span id="pydrake.trajectories.PiecewisePolynomial_[float].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-float-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.PiecewisePolynomial_[float]) -&gt; None</p></li>
</ol>
<p>Constructs an empty piecewise polynomial.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.trajectories.PiecewisePolynomial_[float], arg0: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]) -&gt; None</p></li>
</ol>
<p>Single segment, constant value constructor over the interval [-∞, ∞].
The constructed PiecewisePolynomial will return <code class="docutils literal notranslate"><span class="pre">constant_value</span></code> at
every evaluated point (i.e., <code class="docutils literal notranslate"><span class="pre">value(t)</span> <span class="pre">=</span> <span class="pre">constant_value</span></code> ∀t ∈ [-∞,
∞]).</p>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.trajectories.PiecewisePolynomial_[float], arg0: List[numpy.ndarray[object[m, n]]], arg1: List[float]) -&gt; None</p></li>
</ol>
<p>Constructs a PiecewisePolynomial using matrix-output Polynomials
defined over each segment.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">polynomials.size()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span> <span class="pre">-</span> <span class="pre">1</span></code></p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.trajectories.PiecewisePolynomial_[float], arg0: List[pydrake.polynomial.Polynomial_[float]], arg1: List[float]) -&gt; None</p></li>
</ol>
<p>Constructs a PiecewisePolynomial using scalar-output Polynomials
defined over each segment.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">polynomials.size()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span> <span class="pre">-</span> <span class="pre">1</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-float-.AppendCubicHermiteSegment">
<span id="pydrake.trajectories.PiecewisePolynomial_[float].AppendCubicHermiteSegment"></span><span class="sig-name descname"><span class="pre">AppendCubicHermiteSegment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_dot</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-float-.AppendCubicHermiteSegment" title="Permalink to this definition"></a></dt>
<dd><p>The CubicHermite spline construction has a nice property of being
incremental (each segment can be solved independently). Given a new
sample and it’s derivative, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code> where the start sample and derivative are taken as the value
and derivative at the final break of <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> is not empty()</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">time</span></code> &gt; end_time()</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">sample</span></code> and <code class="docutils literal notranslate"><span class="pre">sample_dot</span></code> must have size rows() x cols().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-float-.AppendFirstOrderSegment">
<span id="pydrake.trajectories.PiecewisePolynomial_[float].AppendFirstOrderSegment"></span><span class="sig-name descname"><span class="pre">AppendFirstOrderSegment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">flags.f_contiguous</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-float-.AppendFirstOrderSegment" title="Permalink to this definition"></a></dt>
<dd><p>Given a new sample, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code> using a first-order hold, where the start sample is taken as
the value at the final break of <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-float-.Block">
<span id="pydrake.trajectories.PiecewisePolynomial_[float].Block"></span><span class="sig-name descname"><span class="pre">Block</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_row</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_rows</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_cols</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-float-.Block" title="Permalink to this definition"></a></dt>
<dd><p>Extracts a trajectory representing a block of size (block_rows,
block_cols) starting at (start_row, start_col) from the
PiecewisePolynomial.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>a PiecewisePolynomial such that ret.value(t) =
this.value(t).block(i,j,p,q);</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-float-.Clone">
<span id="pydrake.trajectories.PiecewisePolynomial_[float].Clone"></span><span class="sig-name descname"><span class="pre">Clone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-float-.Clone" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-float-.ConcatenateInTime">
<span id="pydrake.trajectories.PiecewisePolynomial_[float].ConcatenateInTime"></span><span class="sig-name descname"><span class="pre">ConcatenateInTime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-float-.ConcatenateInTime" title="Permalink to this definition"></a></dt>
<dd><p>Concatenates <code class="docutils literal notranslate"><span class="pre">other</span></code> to the end of <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The resulting PiecewisePolynomial will only be continuous to the
degree that the first Polynomial of <code class="docutils literal notranslate"><span class="pre">other</span></code> is continuous with
the last Polynomial of <code class="docutils literal notranslate"><span class="pre">this</span></code>. See warning about evaluating
discontinuous derivatives at breaks in derivative().</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other</span></code>:</dt><dd><p>PiecewisePolynomial instance to concatenate.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if trajectories' dimensions do not match each other</strong> – </p></li>
<li><p><strong>(</strong><strong>either rows</strong><strong>(</strong><strong>) or </strong><strong>cols</strong><strong>(</strong><strong>) </strong><strong>does not match between this and</strong> – </p></li>
<li><p><strong>other`</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if this-&gt;end_time</strong><strong>(</strong><strong>) </strong><strong>and other-&gt;start_time</strong><strong>(</strong><strong>)</strong> – </p></li>
<li><p><strong>are not within PiecewiseTrajectory&lt;T&gt;::kEpsilonTime from each</strong> – </p></li>
<li><p><strong>other.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-float-.CubicHermite">
<span id="pydrake.trajectories.PiecewisePolynomial_[float].CubicHermite"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">CubicHermite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-float-.CubicHermite" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CubicHermite(breaks: List[float], samples: List[List[float]], samples_dot: List[List[float]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[float]</p></li>
</ol>
<p>Version of CubicHermite(breaks, samples, samples_dot) that uses vector
samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Corresponding
columns of <code class="docutils literal notranslate"><span class="pre">samples</span></code> and <code class="docutils literal notranslate"><span class="pre">samples_dot</span></code> are used as the sample
point and independent variable derivative, respectively.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">samples_dot.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>CubicHermite(breaks: List[float], samples: List[numpy.ndarray[numpy.float64[m, n]]], samples_dot: List[numpy.ndarray[numpy.float64[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[float]</p></li>
</ol>
<p>Constructs a third order PiecewisePolynomial using matrix samples and
derivatives of samples (<code class="docutils literal notranslate"><span class="pre">samples_dot</span></code>); each matrix element of
<code class="docutils literal notranslate"><span class="pre">samples_dot</span></code> represents the derivative with respect to the
independent variable (e.g., the time derivative) of the corresponding
entry in <code class="docutils literal notranslate"><span class="pre">samples</span></code>. Each segment is fully specified by <code class="docutils literal notranslate"><span class="pre">samples</span></code>
and <code class="docutils literal notranslate"><span class="pre">sample_dot</span></code> at both ends. Second derivatives are not
continuous.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-float-.CubicShapePreserving">
<span id="pydrake.trajectories.PiecewisePolynomial_[float].CubicShapePreserving"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">CubicShapePreserving</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-float-.CubicShapePreserving" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CubicShapePreserving(breaks: List[float], samples: List[List[float]], zero_end_point_derivatives: bool = False) -&gt; pydrake.trajectories.PiecewisePolynomial_[float]</p></li>
</ol>
<p>Version of CubicShapePreserving(breaks, samples,
zero_end_point_derivatives) that uses vector samples and Eigen
VectorXd and MatrixX&lt;T&gt; arguments. Each column of <code class="docutils literal notranslate"><span class="pre">samples</span></code>
represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>CubicShapePreserving(breaks: List[float], samples: List[numpy.ndarray[numpy.float64[m, n]]], zero_end_point_derivatives: bool = False) -&gt; pydrake.trajectories.PiecewisePolynomial_[float]</p></li>
</ol>
<p>Constructs a third order PiecewisePolynomial using vector samples,
where each column of <code class="docutils literal notranslate"><span class="pre">samples</span></code> represents a sample point. First
derivatives are chosen to be “shape preserving”, i.e. if <code class="docutils literal notranslate"><span class="pre">samples</span></code>
is monotonic within some interval, the interpolated data will also be
monotonic. The second derivative is not guaranteed to be smooth across
the entire spline.</p>
<p>MATLAB calls this method “pchip” (short for “Piecewise Cubic Hermite
Interpolating Polynomial”), and provides a nice description in their
documentation.
<a class="reference external" href="http://home.uchicago.edu/~sctchoi/courses/cs138/interp.pdf">http://home.uchicago.edu/~sctchoi/courses/cs138/interp.pdf</a> is also a
good reference.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, the first and last
first derivative is chosen using a non-centered, shape-preserving
three-point formulae. See equation (2.10) in the following reference
for more details. <a class="reference external" href="http://www.mi.sanu.ac.rs/~gvm/radovi/mon.pdf">http://www.mi.sanu.ac.rs/~gvm/radovi/mon.pdf</a> If
<code class="docutils literal notranslate"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, they are set to zeros.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, <cite>breaks</cite> and
<code class="docutils literal notranslate"><span class="pre">samples</span></code> must have at least 3 elements for the algorithm to
determine the first derivatives.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, <cite>breaks</cite> and
<code class="docutils literal notranslate"><span class="pre">samples</span></code> may have 2 or more elements. For the 2 elements case, the
result is equivalent to computing a cubic polynomial whose values are
given by <code class="docutils literal notranslate"><span class="pre">samples</span></code>, and derivatives set to zero.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if</strong> – <ul>
<li><p><code class="docutils literal notranslate"><span class="pre">breaks</span></code> has length smaller than 3 and</p></li>
</ul>
</p></li>
<li><p><strong>zero_end_point_derivatives` is False</strong><strong>, </strong><strong>- breaks has lengt</strong> – </p></li>
<li><p><strong>smaller than 2 and zero_end_point_derivatives is true.</strong> – </p></li>
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-float-.CubicWithContinuousSecondDerivatives">
<span id="pydrake.trajectories.PiecewisePolynomial_[float].CubicWithContinuousSecondDerivatives"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">CubicWithContinuousSecondDerivatives</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-float-.CubicWithContinuousSecondDerivatives" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CubicWithContinuousSecondDerivatives(breaks: List[float], samples: List[List[float]], sample_dot_at_start: numpy.ndarray[numpy.float64[m, n]], sample_dot_at_end: numpy.ndarray[numpy.float64[m, n]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[float]</p></li>
</ol>
<p>Version of CubicWithContinuousSecondDerivatives() that uses vector
samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each column of
<code class="docutils literal notranslate"><span class="pre">samples</span></code> represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>CubicWithContinuousSecondDerivatives(breaks: List[float], samples: List[numpy.ndarray[numpy.float64[m, n]]], sample_dot_at_start: numpy.ndarray[numpy.float64[m, n]], sample_dot_at_end: numpy.ndarray[numpy.float64[m, n]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[float]</p></li>
</ol>
<p>Constructs a third order PiecewisePolynomial using matrix samples. The
PiecewisePolynomial is constructed such that the interior segments
have the same value, first and second derivatives at <code class="docutils literal notranslate"><span class="pre">breaks</span></code>.
<cite>sample_dot_at_start</cite> and <code class="docutils literal notranslate"><span class="pre">sample_dot_at_end</span></code> are used for the first
and last first derivatives.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if sample_dot_at_start</strong><strong> or </strong><strong>sample_dot_at_end</strong> – </p></li>
<li><p><strong>and samples have inconsistent dimensions.</strong> – </p></li>
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>CubicWithContinuousSecondDerivatives(breaks: List[float], samples: List[List[float]], periodic_end_condition: bool = False) -&gt; pydrake.trajectories.PiecewisePolynomial_[float]</p></li>
</ol>
<p>Version of CubicWithContinuousSecondDerivatives(breaks, samples) that
uses vector samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each
column of <code class="docutils literal notranslate"><span class="pre">samples</span></code> represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>CubicWithContinuousSecondDerivatives(breaks: List[float], samples: List[numpy.ndarray[numpy.float64[m, n]]], periodic_end: bool) -&gt; pydrake.trajectories.PiecewisePolynomial_[float]</p></li>
</ol>
<p>Constructs a third order PiecewisePolynomial using matrix samples. The
PiecewisePolynomial is constructed such that the interior segments
have the same value, first and second derivatives at <code class="docutils literal notranslate"><span class="pre">breaks</span></code>. If
<code class="docutils literal notranslate"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code> (default), then the
“Not-a-sample” end condition is used here, which means the third
derivatives are continuous for the first two and last two segments. If
<code class="docutils literal notranslate"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, then the first and second
derivatives between the end of the last segment and the beginning of
the first segment will be continuous. Note that the periodic end
condition does not require the first and last sample to be collocated,
nor does it add an additional sample to connect the first and last
segments. Only first and second derivative continuity is enforced. See
<a class="reference external" href="https://en.wikipedia.org/wiki/Spline_interpolation">https://en.wikipedia.org/wiki/Spline_interpolation</a> and
<a class="reference external" href="https://www.math.uh.edu/~jingqiu/math4364/spline.pdf">https://www.math.uh.edu/~jingqiu/math4364/spline.pdf</a> for more about
cubic splines and their end conditions. The MATLAB docs for methods
“spline” and “csape” are also good references.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">breaks</span></code> and <code class="docutils literal notranslate"><span class="pre">samples</span></code> must have at least 3 elements. If
<code class="docutils literal notranslate"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, then for two samples, it
would produce a straight line (use <code class="docutils literal notranslate"><span class="pre">FirstOrderHold</span></code> for this
instead), and if <code class="docutils literal notranslate"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code> the
problem is ill-defined.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-float-.derivative">
<span id="pydrake.trajectories.PiecewisePolynomial_[float].derivative"></span><span class="sig-name descname"><span class="pre">derivative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derivative_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-float-.derivative" title="Permalink to this definition"></a></dt>
<dd><p>Returns a PiecewisePolynomial where each segment is the specified
derivative of the corresponding segment in <code class="docutils literal notranslate"><span class="pre">this</span></code>. Any rules or
limitations of Polynomial::derivative() also apply to this function.</p>
<p>Derivatives evaluated at non-differentiable points return the value at
the left hand side of the interval.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code>:</dt><dd><p>The order of the derivative, namely, if <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code> = n,
the n’th derivative of the polynomial will be returned.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In the event of discontinuous derivatives evaluated at breaks, it
is not defined which polynomial (i.e., to the left or right of the
break) will be the one that is evaluated at the break.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-float-.FirstOrderHold">
<span id="pydrake.trajectories.PiecewisePolynomial_[float].FirstOrderHold"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">FirstOrderHold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-float-.FirstOrderHold" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>FirstOrderHold(breaks: List[float], samples: List[List[float]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[float]</p></li>
</ol>
<p>Version of FirstOrderHold(breaks, samples) that uses vector samples
and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each column of <code class="docutils literal notranslate"><span class="pre">samples</span></code>
represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>FirstOrderHold(breaks: List[float], samples: List[numpy.ndarray[numpy.float64[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[float]</p></li>
</ol>
<p>Constructs a piecewise linear PiecewisePolynomial using matrix
samples.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-float-.getPolynomial">
<span id="pydrake.trajectories.PiecewisePolynomial_[float].getPolynomial"></span><span class="sig-name descname"><span class="pre">getPolynomial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.polynomial.html#pydrake.polynomial.Polynomial_" title="pydrake.polynomial.Polynomial_"><span class="pre">pydrake.polynomial.Polynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-float-.getPolynomial" title="Permalink to this definition"></a></dt>
<dd><p>Gets the Polynomial with the given matrix row and column index that
corresponds to the given segment index. Equivalent to
<code class="docutils literal notranslate"><span class="pre">getPolynomialMatrix(segment_index)(row,</span> <span class="pre">col)</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calls PiecewiseTrajectory&lt;T&gt;::segment_number_range_check() to
validate <code class="docutils literal notranslate"><span class="pre">segment_index</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-float-.getPolynomialMatrix">
<span id="pydrake.trajectories.PiecewisePolynomial_[float].getPolynomialMatrix"></span><span class="sig-name descname"><span class="pre">getPolynomialMatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-float-.getPolynomialMatrix" title="Permalink to this definition"></a></dt>
<dd><p>Gets the matrix of Polynomials corresponding to the given segment
index.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><code class="docutils literal notranslate"><span class="pre">segment_index</span></code> is not checked for validity.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-float-.getSegmentPolynomialDegree">
<span id="pydrake.trajectories.PiecewisePolynomial_[float].getSegmentPolynomialDegree"></span><span class="sig-name descname"><span class="pre">getSegmentPolynomialDegree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-float-.getSegmentPolynomialDegree" title="Permalink to this definition"></a></dt>
<dd><p>Gets the degree of the Polynomial with the given matrix row and column
index that corresponds to the given segment index. Equivalent to
<code class="docutils literal notranslate"><span class="pre">getPolynomial(segment_index,</span> <span class="pre">row,</span> <span class="pre">col).GetDegree()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-float-.isApprox">
<span id="pydrake.trajectories.PiecewisePolynomial_[float].isApprox"></span><span class="sig-name descname"><span class="pre">isApprox</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[float],</span> <span class="pre">other:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[float],</span> <span class="pre">tol:</span> <span class="pre">float,</span> <span class="pre">tol_type:</span> <span class="pre">pydrake.common._module_py.ToleranceType</span> <span class="pre">=</span> <span class="pre">&lt;ToleranceType.kRelative:</span> <span class="pre">1&gt;</span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-float-.isApprox" title="Permalink to this definition"></a></dt>
<dd><p>Checks whether a PiecewisePolynomial is approximately equal to this
one by calling Polynomial&lt;T&gt;::CoefficientsAlmostEqual() on every
element of every segment.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Polynomial&lt;T&gt;::CoefficientsAlmostEqual().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-float-.LagrangeInterpolatingPolynomial">
<span id="pydrake.trajectories.PiecewisePolynomial_[float].LagrangeInterpolatingPolynomial"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">LagrangeInterpolatingPolynomial</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-float-.LagrangeInterpolatingPolynomial" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>LagrangeInterpolatingPolynomial(times: List[float], samples: List[List[float]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[float]</p></li>
</ol>
<p>Version of LagrangeInterpolatingPolynomial(times, samples) that uses
vector samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each column
of <code class="docutils literal notranslate"><span class="pre">samples</span></code> represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">times.size()</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>LagrangeInterpolatingPolynomial(times: List[float], samples: List[numpy.ndarray[numpy.float64[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[float]</p></li>
</ol>
<p>Constructs a polynomial with a <em>single segment</em> of the lowest possible
degree that passes through all of the sample points. See “polynomial
interpolation” and/or “Lagrange polynomial” on Wikipedia for more
information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">times</span></code> must be monotonically increasing.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.size()</span> <span class="pre">==</span> <span class="pre">times.size()</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-float-.RemoveFinalSegment">
<span id="pydrake.trajectories.PiecewisePolynomial_[float].RemoveFinalSegment"></span><span class="sig-name descname"><span class="pre">RemoveFinalSegment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-float-.RemoveFinalSegment" title="Permalink to this definition"></a></dt>
<dd><p>Removes the final segment from the trajectory, reducing the number of
segments by 1.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> is not empty()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-float-.Reshape">
<span id="pydrake.trajectories.PiecewisePolynomial_[float].Reshape"></span><span class="sig-name descname"><span class="pre">Reshape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rows</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cols</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-float-.Reshape" title="Permalink to this definition"></a></dt>
<dd><p>Reshapes the dimensions of the Eigen::MatrixX&lt;T&gt; returned by value(),
EvalDerivative(), etc.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">rows</span></code> x <code class="docutils literal notranslate"><span class="pre">cols</span></code> must equal this.rows() * this.cols().</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Eigen::PlainObjectBase::resize().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-float-.ReverseTime">
<span id="pydrake.trajectories.PiecewisePolynomial_[float].ReverseTime"></span><span class="sig-name descname"><span class="pre">ReverseTime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-float-.ReverseTime" title="Permalink to this definition"></a></dt>
<dd><p>Modifies the trajectory so that pp_after(t) = pp_before(-t).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The new trajectory will evaluate differently at precisely the
break points if the original trajectory was discontinuous at the
break points. This is because the segments are defined on the
half-open intervals [breaks(i), breaks(i+1)), and the order of the
breaks have been reversed.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-float-.ScaleTime">
<span id="pydrake.trajectories.PiecewisePolynomial_[float].ScaleTime"></span><span class="sig-name descname"><span class="pre">ScaleTime</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-float-.ScaleTime" title="Permalink to this definition"></a></dt>
<dd><p>Scales the time of the trajectory by non-negative <code class="docutils literal notranslate"><span class="pre">scale</span></code> (use
ReverseTime() if you want to also negate time). The resulting
polynomial evaluates to pp_after(t) = pp_before(t/scale).</p>
<p>As an example, <a href="#id13"><span class="problematic" id="id14">`</span></a>scale`=2 will result in a trajectory that is twice as
long (start_time() and end_time() have both doubled).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-float-.setPolynomialMatrixBlock">
<span id="pydrake.trajectories.PiecewisePolynomial_[float].setPolynomialMatrixBlock"></span><span class="sig-name descname"><span class="pre">setPolynomialMatrixBlock</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">replacement</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">row_start</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">col_start</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-float-.setPolynomialMatrixBlock" title="Permalink to this definition"></a></dt>
<dd><p>Replaces the specified block of the PolynomialMatrix at the given
segment index.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calls PiecewiseTrajectory&lt;T&gt;::segment_number_range_check() to
validate <code class="docutils literal notranslate"><span class="pre">segment_index</span></code>.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This code relies upon Eigen to verify that the replacement block
is not too large.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-float-.shiftRight">
<span id="pydrake.trajectories.PiecewisePolynomial_[float].shiftRight"></span><span class="sig-name descname"><span class="pre">shiftRight</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-float-.shiftRight" title="Permalink to this definition"></a></dt>
<dd><p>Adds <code class="docutils literal notranslate"><span class="pre">offset</span></code> to all of the breaks. <code class="docutils literal notranslate"><span class="pre">offset</span></code> need not be a
non-negative number. The resulting polynomial will evaluate to
pp_after(t) = pp_before(t-offset).</p>
<p>As an example, <a href="#id15"><span class="problematic" id="id16">`</span></a>offset`=2 will result in the start_time() and
end_time() being 2 seconds later.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-float-.slice">
<span id="pydrake.trajectories.PiecewisePolynomial_[float].slice"></span><span class="sig-name descname"><span class="pre">slice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_segments</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-float-.slice" title="Permalink to this definition"></a></dt>
<dd><p>Returns the PiecewisePolynomial comprising the <code class="docutils literal notranslate"><span class="pre">num_segments</span></code>
segments starting at the specified <code class="docutils literal notranslate"><span class="pre">start_segment_index</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calls PiecewiseTrajectory&lt;T&gt;::segment_number_range_check() to
validate <code class="docutils literal notranslate"><span class="pre">segment_index</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-float-.Transpose">
<span id="pydrake.trajectories.PiecewisePolynomial_[float].Transpose"></span><span class="sig-name descname"><span class="pre">Transpose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-float-.Transpose" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a new PiecewisePolynomial for which value(t) ==
this.value(t).transpose().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePolynomial_-float-.ZeroOrderHold">
<span id="pydrake.trajectories.PiecewisePolynomial_[float].ZeroOrderHold"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ZeroOrderHold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial_-float-.ZeroOrderHold" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>ZeroOrderHold(breaks: List[float], samples: List[List[float]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[float]</p></li>
</ol>
<p>Version of ZeroOrderHold(breaks, samples) that uses vector samples and
Eigen VectorXd/MatrixX&lt;T&gt; arguments. Each column of <code class="docutils literal notranslate"><span class="pre">samples</span></code>
represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>ZeroOrderHold(breaks: List[float], samples: List[numpy.ndarray[numpy.float64[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[float]</p></li>
</ol>
<p>Constructs a piecewise constant PiecewisePolynomial using matrix
samples. Note that constructing a PiecewisePolynomial requires at
least two sample points, although in this case, the second sample
point’s value is ignored, and only its break time is used.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose">
<span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PiecewisePose</span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose" title="Permalink to this definition"></a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.trajectories.PiecewisePose_-float" title="pydrake.trajectories.PiecewisePose_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PiecewisePose_[float]</span></code></a></p>
</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PiecewisePose_</span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.trajectories.PiecewisePose_-float" title="pydrake.trajectories.PiecewisePose_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewisePose_[float]</span></code></a>, <a class="reference internal" href="#pydrake.trajectories.PiecewisePose_-AutoDiffXd" title="pydrake.trajectories.PiecewisePose_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewisePose_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.trajectories.PiecewisePose_-Expression" title="pydrake.trajectories.PiecewisePose_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewisePose_[Expression]</span></code></a></p>
<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_.PiecewisePose_-float">
<span id="pydrake.trajectories.PiecewisePose_.PiecewisePose_[float]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">PiecewisePose_[float]</span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_.PiecewisePose_-float" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_-float" title="pydrake.trajectories.PiecewiseTrajectory_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_[float]</span></code></a></p>
<p>A wrapper class that represents a pose trajectory, whose rotation part
is a PiecewiseQuaternionSlerp and the translation part is a
PiecewisePolynomial.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_.PiecewisePose_-float-.__init__">
<span id="pydrake.trajectories.PiecewisePose_.PiecewisePose_[float].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_.PiecewisePose_-float-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.PiecewisePose_[float]) -&gt; None</p></li>
</ol>
<p>Constructs an empty piecewise pose trajectory.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.trajectories.PiecewisePose_[float], position_trajectory: pydrake.trajectories.PiecewisePolynomial_[float], orientation_trajectory: pydrake.trajectories.PiecewiseQuaternionSlerp_[float]) -&gt; None</p></li>
</ol>
<p>Constructor.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pos_traj</span></code>:</dt><dd><p>Position trajectory.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rot_traj</span></code>:</dt><dd><p>Orientation trajectory.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_.PiecewisePose_-float-.get_orientation_trajectory">
<span id="pydrake.trajectories.PiecewisePose_.PiecewisePose_[float].get_orientation_trajectory"></span><span class="sig-name descname"><span class="pre">get_orientation_trajectory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_" title="pydrake.trajectories.PiecewiseQuaternionSlerp_"><span class="pre">pydrake.trajectories.PiecewiseQuaternionSlerp_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_.PiecewisePose_-float-.get_orientation_trajectory" title="Permalink to this definition"></a></dt>
<dd><p>Returns the orientation trajectory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_.PiecewisePose_-float-.get_position_trajectory">
<span id="pydrake.trajectories.PiecewisePose_.PiecewisePose_[float].get_position_trajectory"></span><span class="sig-name descname"><span class="pre">get_position_trajectory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_.PiecewisePose_-float-.get_position_trajectory" title="Permalink to this definition"></a></dt>
<dd><p>Returns the position trajectory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_.PiecewisePose_-float-.GetAcceleration">
<span id="pydrake.trajectories.PiecewisePose_.PiecewisePose_[float].GetAcceleration"></span><span class="sig-name descname"><span class="pre">GetAcceleration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">6</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_.PiecewisePose_-float-.GetAcceleration" title="Permalink to this definition"></a></dt>
<dd><p>Returns the interpolated acceleration at <code class="docutils literal notranslate"><span class="pre">time</span></code> or zero if <code class="docutils literal notranslate"><span class="pre">time</span></code>
is before this trajectory’s start time or after its end time.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_.PiecewisePose_-float-.GetPose">
<span id="pydrake.trajectories.PiecewisePose_.PiecewisePose_[float].GetPose"></span><span class="sig-name descname"><span class="pre">GetPose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_.PiecewisePose_-float-.GetPose" title="Permalink to this definition"></a></dt>
<dd><p>Returns the interpolated pose at <code class="docutils literal notranslate"><span class="pre">time</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_.PiecewisePose_-float-.GetVelocity">
<span id="pydrake.trajectories.PiecewisePose_.PiecewisePose_[float].GetVelocity"></span><span class="sig-name descname"><span class="pre">GetVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">6</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_.PiecewisePose_-float-.GetVelocity" title="Permalink to this definition"></a></dt>
<dd><p>Returns the interpolated velocity at <code class="docutils literal notranslate"><span class="pre">time</span></code> or zero if <code class="docutils literal notranslate"><span class="pre">time</span></code> is
before this trajectory’s start time or after its end time.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_.PiecewisePose_-float-.IsApprox">
<span id="pydrake.trajectories.PiecewisePose_.PiecewisePose_[float].IsApprox"></span><span class="sig-name descname"><span class="pre">IsApprox</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_.PiecewisePose_-float-.IsApprox" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if the position and orientation trajectories are both
within <code class="docutils literal notranslate"><span class="pre">tol</span></code> from the other’s.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_.PiecewisePose_-float-.MakeCubicLinearWithEndLinearVelocity">
<span id="pydrake.trajectories.PiecewisePose_.PiecewisePose_[float].MakeCubicLinearWithEndLinearVelocity"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeCubicLinearWithEndLinearVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">times</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poses</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_vel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([0.,</span> <span class="pre">0.,</span> <span class="pre">0.])</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end_vel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([0.,</span> <span class="pre">0.,</span> <span class="pre">0.])</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_.PiecewisePose_-float-.MakeCubicLinearWithEndLinearVelocity" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a PiecewisePose from given <code class="docutils literal notranslate"><span class="pre">times</span></code> and <code class="docutils literal notranslate"><span class="pre">poses</span></code>. A cubic
polynomial with given end velocities is used to construct the position
part. The rotational part is represented by a piecewise quaterion
trajectory. There must be at least two elements in <code class="docutils literal notranslate"><span class="pre">times</span></code> and
<code class="docutils literal notranslate"><span class="pre">poses</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">times</span></code>:</dt><dd><p>Breaks used to build the splines.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">poses</span></code>:</dt><dd><p>Knots used to build the splines.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">start_vel</span></code>:</dt><dd><p>Start linear velocity.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">end_vel</span></code>:</dt><dd><p>End linear velocity.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_.PiecewisePose_-float-.MakeLinear">
<span id="pydrake.trajectories.PiecewisePose_.PiecewisePose_[float].MakeLinear"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeLinear</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">times</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poses</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_.PiecewisePose_-float-.MakeLinear" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a PiecewisePose from given <code class="docutils literal notranslate"><span class="pre">times</span></code> and <code class="docutils literal notranslate"><span class="pre">poses</span></code>. The
positions trajectory is constructed as a first-order hold. The
orientation is constructed using the quaternion slerp. There must be
at least two elements in <code class="docutils literal notranslate"><span class="pre">times</span></code> and <code class="docutils literal notranslate"><span class="pre">poses</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">times</span></code>:</dt><dd><p>Breaks used to build the splines.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">poses</span></code>:</dt><dd><p>Knots used to build the splines.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-AutoDiffXd">
<span id="pydrake.trajectories.PiecewisePose_[AutoDiffXd]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PiecewisePose_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd" title="pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd]</span></code></a></p>
<p>A wrapper class that represents a pose trajectory, whose rotation part
is a PiecewiseQuaternionSlerp and the translation part is a
PiecewisePolynomial.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-AutoDiffXd-.__init__">
<span id="pydrake.trajectories.PiecewisePose_[AutoDiffXd].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-AutoDiffXd-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.PiecewisePose_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Constructs an empty piecewise pose trajectory.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.trajectories.PiecewisePose_[AutoDiffXd], position_trajectory: pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd], orientation_trajectory: pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Constructor.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pos_traj</span></code>:</dt><dd><p>Position trajectory.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rot_traj</span></code>:</dt><dd><p>Orientation trajectory.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-AutoDiffXd-.get_orientation_trajectory">
<span id="pydrake.trajectories.PiecewisePose_[AutoDiffXd].get_orientation_trajectory"></span><span class="sig-name descname"><span class="pre">get_orientation_trajectory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_" title="pydrake.trajectories.PiecewiseQuaternionSlerp_"><span class="pre">pydrake.trajectories.PiecewiseQuaternionSlerp_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-AutoDiffXd-.get_orientation_trajectory" title="Permalink to this definition"></a></dt>
<dd><p>Returns the orientation trajectory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-AutoDiffXd-.get_position_trajectory">
<span id="pydrake.trajectories.PiecewisePose_[AutoDiffXd].get_position_trajectory"></span><span class="sig-name descname"><span class="pre">get_position_trajectory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-AutoDiffXd-.get_position_trajectory" title="Permalink to this definition"></a></dt>
<dd><p>Returns the position trajectory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-AutoDiffXd-.GetAcceleration">
<span id="pydrake.trajectories.PiecewisePose_[AutoDiffXd].GetAcceleration"></span><span class="sig-name descname"><span class="pre">GetAcceleration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">6</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-AutoDiffXd-.GetAcceleration" title="Permalink to this definition"></a></dt>
<dd><p>Returns the interpolated acceleration at <code class="docutils literal notranslate"><span class="pre">time</span></code> or zero if <code class="docutils literal notranslate"><span class="pre">time</span></code>
is before this trajectory’s start time or after its end time.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-AutoDiffXd-.GetPose">
<span id="pydrake.trajectories.PiecewisePose_[AutoDiffXd].GetPose"></span><span class="sig-name descname"><span class="pre">GetPose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-AutoDiffXd-.GetPose" title="Permalink to this definition"></a></dt>
<dd><p>Returns the interpolated pose at <code class="docutils literal notranslate"><span class="pre">time</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-AutoDiffXd-.GetVelocity">
<span id="pydrake.trajectories.PiecewisePose_[AutoDiffXd].GetVelocity"></span><span class="sig-name descname"><span class="pre">GetVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">6</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-AutoDiffXd-.GetVelocity" title="Permalink to this definition"></a></dt>
<dd><p>Returns the interpolated velocity at <code class="docutils literal notranslate"><span class="pre">time</span></code> or zero if <code class="docutils literal notranslate"><span class="pre">time</span></code> is
before this trajectory’s start time or after its end time.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-AutoDiffXd-.IsApprox">
<span id="pydrake.trajectories.PiecewisePose_[AutoDiffXd].IsApprox"></span><span class="sig-name descname"><span class="pre">IsApprox</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-AutoDiffXd-.IsApprox" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if the position and orientation trajectories are both
within <code class="docutils literal notranslate"><span class="pre">tol</span></code> from the other’s.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-AutoDiffXd-.MakeCubicLinearWithEndLinearVelocity">
<span id="pydrake.trajectories.PiecewisePose_[AutoDiffXd].MakeCubicLinearWithEndLinearVelocity"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeCubicLinearWithEndLinearVelocity</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-AutoDiffXd-.MakeCubicLinearWithEndLinearVelocity" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>MakeCubicLinearWithEndLinearVelocity(times: List[pydrake.autodiffutils.AutoDiffXd], poses: List[pydrake.math.RigidTransform_[AutoDiffXd]], start_vel: numpy.ndarray[object[3, 1]] = array([&lt;AutoDiffXd 0.0 nderiv=0&gt;, &lt;AutoDiffXd 0.0 nderiv=0&gt;,</dt><dd><p>&lt;AutoDiffXd 0.0 nderiv=0&gt;], dtype=object), end_vel: numpy.ndarray[object[3, 1]] = array([&lt;AutoDiffXd 0.0 nderiv=0&gt;, &lt;AutoDiffXd 0.0 nderiv=0&gt;,
&lt;AutoDiffXd 0.0 nderiv=0&gt;], dtype=object)) -&gt; pydrake.trajectories.PiecewisePose_[AutoDiffXd]</p>
</dd>
</dl>
<p>Constructs a PiecewisePose from given <code class="docutils literal notranslate"><span class="pre">times</span></code> and <code class="docutils literal notranslate"><span class="pre">poses</span></code>. A cubic
polynomial with given end velocities is used to construct the position
part. The rotational part is represented by a piecewise quaterion
trajectory. There must be at least two elements in <code class="docutils literal notranslate"><span class="pre">times</span></code> and
<code class="docutils literal notranslate"><span class="pre">poses</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">times</span></code>:</dt><dd><p>Breaks used to build the splines.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">poses</span></code>:</dt><dd><p>Knots used to build the splines.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">start_vel</span></code>:</dt><dd><p>Start linear velocity.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">end_vel</span></code>:</dt><dd><p>End linear velocity.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-AutoDiffXd-.MakeLinear">
<span id="pydrake.trajectories.PiecewisePose_[AutoDiffXd].MakeLinear"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeLinear</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">times</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poses</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-AutoDiffXd-.MakeLinear" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a PiecewisePose from given <code class="docutils literal notranslate"><span class="pre">times</span></code> and <code class="docutils literal notranslate"><span class="pre">poses</span></code>. The
positions trajectory is constructed as a first-order hold. The
orientation is constructed using the quaternion slerp. There must be
at least two elements in <code class="docutils literal notranslate"><span class="pre">times</span></code> and <code class="docutils literal notranslate"><span class="pre">poses</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">times</span></code>:</dt><dd><p>Breaks used to build the splines.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">poses</span></code>:</dt><dd><p>Knots used to build the splines.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-Expression">
<span id="pydrake.trajectories.PiecewisePose_[Expression]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PiecewisePose_[Expression]</span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-Expression" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_-Expression" title="pydrake.trajectories.PiecewiseTrajectory_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_[Expression]</span></code></a></p>
<p>A wrapper class that represents a pose trajectory, whose rotation part
is a PiecewiseQuaternionSlerp and the translation part is a
PiecewisePolynomial.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-Expression-.__init__">
<span id="pydrake.trajectories.PiecewisePose_[Expression].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-Expression-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.PiecewisePose_[Expression]) -&gt; None</p></li>
</ol>
<p>Constructs an empty piecewise pose trajectory.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.trajectories.PiecewisePose_[Expression], position_trajectory: pydrake.trajectories.PiecewisePolynomial_[Expression], orientation_trajectory: pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression]) -&gt; None</p></li>
</ol>
<p>Constructor.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pos_traj</span></code>:</dt><dd><p>Position trajectory.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rot_traj</span></code>:</dt><dd><p>Orientation trajectory.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-Expression-.get_orientation_trajectory">
<span id="pydrake.trajectories.PiecewisePose_[Expression].get_orientation_trajectory"></span><span class="sig-name descname"><span class="pre">get_orientation_trajectory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_" title="pydrake.trajectories.PiecewiseQuaternionSlerp_"><span class="pre">pydrake.trajectories.PiecewiseQuaternionSlerp_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-Expression-.get_orientation_trajectory" title="Permalink to this definition"></a></dt>
<dd><p>Returns the orientation trajectory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-Expression-.get_position_trajectory">
<span id="pydrake.trajectories.PiecewisePose_[Expression].get_position_trajectory"></span><span class="sig-name descname"><span class="pre">get_position_trajectory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-Expression-.get_position_trajectory" title="Permalink to this definition"></a></dt>
<dd><p>Returns the position trajectory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-Expression-.GetAcceleration">
<span id="pydrake.trajectories.PiecewisePose_[Expression].GetAcceleration"></span><span class="sig-name descname"><span class="pre">GetAcceleration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">6</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-Expression-.GetAcceleration" title="Permalink to this definition"></a></dt>
<dd><p>Returns the interpolated acceleration at <code class="docutils literal notranslate"><span class="pre">time</span></code> or zero if <code class="docutils literal notranslate"><span class="pre">time</span></code>
is before this trajectory’s start time or after its end time.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-Expression-.GetPose">
<span id="pydrake.trajectories.PiecewisePose_[Expression].GetPose"></span><span class="sig-name descname"><span class="pre">GetPose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-Expression-.GetPose" title="Permalink to this definition"></a></dt>
<dd><p>Returns the interpolated pose at <code class="docutils literal notranslate"><span class="pre">time</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-Expression-.GetVelocity">
<span id="pydrake.trajectories.PiecewisePose_[Expression].GetVelocity"></span><span class="sig-name descname"><span class="pre">GetVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">6</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-Expression-.GetVelocity" title="Permalink to this definition"></a></dt>
<dd><p>Returns the interpolated velocity at <code class="docutils literal notranslate"><span class="pre">time</span></code> or zero if <code class="docutils literal notranslate"><span class="pre">time</span></code> is
before this trajectory’s start time or after its end time.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-Expression-.IsApprox">
<span id="pydrake.trajectories.PiecewisePose_[Expression].IsApprox"></span><span class="sig-name descname"><span class="pre">IsApprox</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-Expression-.IsApprox" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if the position and orientation trajectories are both
within <code class="docutils literal notranslate"><span class="pre">tol</span></code> from the other’s.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-Expression-.MakeCubicLinearWithEndLinearVelocity">
<span id="pydrake.trajectories.PiecewisePose_[Expression].MakeCubicLinearWithEndLinearVelocity"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeCubicLinearWithEndLinearVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">times:</span> <span class="pre">List[pydrake.symbolic.Expression],</span> <span class="pre">poses:</span> <span class="pre">List[pydrake.math.RigidTransform_[Expression]],</span> <span class="pre">start_vel:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span> <span class="pre">=</span> <span class="pre">array([&lt;Expression</span> <span class="pre">&quot;0&quot;&gt;,</span> <span class="pre">&lt;Expression</span> <span class="pre">&quot;0&quot;&gt;,</span> <span class="pre">&lt;Expression</span> <span class="pre">&quot;0&quot;&gt;],</span> <span class="pre">dtype=object),</span> <span class="pre">end_vel:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span> <span class="pre">=</span> <span class="pre">array([&lt;Expression</span> <span class="pre">&quot;0&quot;&gt;,</span> <span class="pre">&lt;Expression</span> <span class="pre">&quot;0&quot;&gt;,</span> <span class="pre">&lt;Expression</span> <span class="pre">&quot;0&quot;&gt;],</span> <span class="pre">dtype=object)</span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-Expression-.MakeCubicLinearWithEndLinearVelocity" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a PiecewisePose from given <code class="docutils literal notranslate"><span class="pre">times</span></code> and <code class="docutils literal notranslate"><span class="pre">poses</span></code>. A cubic
polynomial with given end velocities is used to construct the position
part. The rotational part is represented by a piecewise quaterion
trajectory. There must be at least two elements in <code class="docutils literal notranslate"><span class="pre">times</span></code> and
<code class="docutils literal notranslate"><span class="pre">poses</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">times</span></code>:</dt><dd><p>Breaks used to build the splines.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">poses</span></code>:</dt><dd><p>Knots used to build the splines.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">start_vel</span></code>:</dt><dd><p>Start linear velocity.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">end_vel</span></code>:</dt><dd><p>End linear velocity.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-Expression-.MakeLinear">
<span id="pydrake.trajectories.PiecewisePose_[Expression].MakeLinear"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeLinear</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">times</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poses</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-Expression-.MakeLinear" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a PiecewisePose from given <code class="docutils literal notranslate"><span class="pre">times</span></code> and <code class="docutils literal notranslate"><span class="pre">poses</span></code>. The
positions trajectory is constructed as a first-order hold. The
orientation is constructed using the quaternion slerp. There must be
at least two elements in <code class="docutils literal notranslate"><span class="pre">times</span></code> and <code class="docutils literal notranslate"><span class="pre">poses</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">times</span></code>:</dt><dd><p>Breaks used to build the splines.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">poses</span></code>:</dt><dd><p>Knots used to build the splines.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-float">
<span id="pydrake.trajectories.PiecewisePose_[float]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PiecewisePose_[float]</span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-float" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_-float" title="pydrake.trajectories.PiecewiseTrajectory_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_[float]</span></code></a></p>
<p>A wrapper class that represents a pose trajectory, whose rotation part
is a PiecewiseQuaternionSlerp and the translation part is a
PiecewisePolynomial.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-float-.__init__">
<span id="pydrake.trajectories.PiecewisePose_[float].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-float-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.PiecewisePose_[float]) -&gt; None</p></li>
</ol>
<p>Constructs an empty piecewise pose trajectory.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.trajectories.PiecewisePose_[float], position_trajectory: pydrake.trajectories.PiecewisePolynomial_[float], orientation_trajectory: pydrake.trajectories.PiecewiseQuaternionSlerp_[float]) -&gt; None</p></li>
</ol>
<p>Constructor.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pos_traj</span></code>:</dt><dd><p>Position trajectory.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rot_traj</span></code>:</dt><dd><p>Orientation trajectory.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-float-.get_orientation_trajectory">
<span id="pydrake.trajectories.PiecewisePose_[float].get_orientation_trajectory"></span><span class="sig-name descname"><span class="pre">get_orientation_trajectory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_" title="pydrake.trajectories.PiecewiseQuaternionSlerp_"><span class="pre">pydrake.trajectories.PiecewiseQuaternionSlerp_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-float-.get_orientation_trajectory" title="Permalink to this definition"></a></dt>
<dd><p>Returns the orientation trajectory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-float-.get_position_trajectory">
<span id="pydrake.trajectories.PiecewisePose_[float].get_position_trajectory"></span><span class="sig-name descname"><span class="pre">get_position_trajectory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePolynomial_" title="pydrake.trajectories.PiecewisePolynomial_"><span class="pre">pydrake.trajectories.PiecewisePolynomial_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-float-.get_position_trajectory" title="Permalink to this definition"></a></dt>
<dd><p>Returns the position trajectory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-float-.GetAcceleration">
<span id="pydrake.trajectories.PiecewisePose_[float].GetAcceleration"></span><span class="sig-name descname"><span class="pre">GetAcceleration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">6</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-float-.GetAcceleration" title="Permalink to this definition"></a></dt>
<dd><p>Returns the interpolated acceleration at <code class="docutils literal notranslate"><span class="pre">time</span></code> or zero if <code class="docutils literal notranslate"><span class="pre">time</span></code>
is before this trajectory’s start time or after its end time.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-float-.GetPose">
<span id="pydrake.trajectories.PiecewisePose_[float].GetPose"></span><span class="sig-name descname"><span class="pre">GetPose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-float-.GetPose" title="Permalink to this definition"></a></dt>
<dd><p>Returns the interpolated pose at <code class="docutils literal notranslate"><span class="pre">time</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-float-.GetVelocity">
<span id="pydrake.trajectories.PiecewisePose_[float].GetVelocity"></span><span class="sig-name descname"><span class="pre">GetVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">6</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-float-.GetVelocity" title="Permalink to this definition"></a></dt>
<dd><p>Returns the interpolated velocity at <code class="docutils literal notranslate"><span class="pre">time</span></code> or zero if <code class="docutils literal notranslate"><span class="pre">time</span></code> is
before this trajectory’s start time or after its end time.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-float-.IsApprox">
<span id="pydrake.trajectories.PiecewisePose_[float].IsApprox"></span><span class="sig-name descname"><span class="pre">IsApprox</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-float-.IsApprox" title="Permalink to this definition"></a></dt>
<dd><p>Returns true if the position and orientation trajectories are both
within <code class="docutils literal notranslate"><span class="pre">tol</span></code> from the other’s.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-float-.MakeCubicLinearWithEndLinearVelocity">
<span id="pydrake.trajectories.PiecewisePose_[float].MakeCubicLinearWithEndLinearVelocity"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeCubicLinearWithEndLinearVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">times</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poses</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_vel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([0.,</span> <span class="pre">0.,</span> <span class="pre">0.])</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end_vel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([0.,</span> <span class="pre">0.,</span> <span class="pre">0.])</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-float-.MakeCubicLinearWithEndLinearVelocity" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a PiecewisePose from given <code class="docutils literal notranslate"><span class="pre">times</span></code> and <code class="docutils literal notranslate"><span class="pre">poses</span></code>. A cubic
polynomial with given end velocities is used to construct the position
part. The rotational part is represented by a piecewise quaterion
trajectory. There must be at least two elements in <code class="docutils literal notranslate"><span class="pre">times</span></code> and
<code class="docutils literal notranslate"><span class="pre">poses</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">times</span></code>:</dt><dd><p>Breaks used to build the splines.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">poses</span></code>:</dt><dd><p>Knots used to build the splines.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">start_vel</span></code>:</dt><dd><p>Start linear velocity.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">end_vel</span></code>:</dt><dd><p>End linear velocity.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewisePose_-float-.MakeLinear">
<span id="pydrake.trajectories.PiecewisePose_[float].MakeLinear"></span><em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">MakeLinear</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">times</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poses</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.math.html#pydrake.math.RigidTransform_" title="pydrake.math.RigidTransform_"><span class="pre">pydrake.math.RigidTransform_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.PiecewisePose_" title="pydrake.trajectories.PiecewisePose_"><span class="pre">pydrake.trajectories.PiecewisePose_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose_-float-.MakeLinear" title="Permalink to this definition"></a></dt>
<dd><p>Constructs a PiecewisePose from given <code class="docutils literal notranslate"><span class="pre">times</span></code> and <code class="docutils literal notranslate"><span class="pre">poses</span></code>. The
positions trajectory is constructed as a first-order hold. The
orientation is constructed using the quaternion slerp. There must be
at least two elements in <code class="docutils literal notranslate"><span class="pre">times</span></code> and <code class="docutils literal notranslate"><span class="pre">poses</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">times</span></code>:</dt><dd><p>Breaks used to build the splines.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">poses</span></code>:</dt><dd><p>Knots used to build the splines.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp">
<span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PiecewiseQuaternionSlerp</span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp" title="Permalink to this definition"></a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_-float" title="pydrake.trajectories.PiecewiseQuaternionSlerp_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PiecewiseQuaternionSlerp_[float]</span></code></a></p>
</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PiecewiseQuaternionSlerp_</span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_-float" title="pydrake.trajectories.PiecewiseQuaternionSlerp_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewiseQuaternionSlerp_[float]</span></code></a>, <a class="reference internal" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_-AutoDiffXd" title="pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewiseQuaternionSlerp_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_-Expression" title="pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewiseQuaternionSlerp_[Expression]</span></code></a></p>
<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp_.PiecewiseQuaternionSlerp_-float">
<span id="pydrake.trajectories.PiecewiseQuaternionSlerp_.PiecewiseQuaternionSlerp_[float]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">PiecewiseQuaternionSlerp_[float]</span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_.PiecewiseQuaternionSlerp_-float" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_-float" title="pydrake.trajectories.PiecewiseTrajectory_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_[float]</span></code></a></p>
<p>A class representing a trajectory for quaternions that are
interpolated using piecewise slerp (spherical linear interpolation).
All the orientation samples are expected to be with respect to the
same parent reference frame, i.e. q_i represents the rotation R_PBi
for the orientation of frame B at the ith sample in a fixed parent
frame P. The world frame is a common choice for the parent frame. The
angular velocity and acceleration are also relative to the parent
frame and expressed in the parent frame. Since there is a sign
ambiguity when using quaternions to represent orientation, namely q
and -q represent the same orientation, the internal quaternion
representations ensure that q_n.dot(q_{n+1}) &gt;= 0. Another intuitive
way to think about this is that consecutive quaternions have the
shortest geodesic distance on the unit sphere. Note that the
quarternion value is in w, x, y, z order when represented as a
Vector4.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp_.PiecewiseQuaternionSlerp_-float-.__init__">
<span id="pydrake.trajectories.PiecewiseQuaternionSlerp_.PiecewiseQuaternionSlerp_[float].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_.PiecewiseQuaternionSlerp_-float-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[float]) -&gt; None</p></li>
</ol>
<p>Builds an empty PiecewiseQuaternionSlerp.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[float], breaks: List[float], quaternions: List[pydrake.common.eigen_geometry.Quaternion_[float]]) -&gt; None</p></li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if breaks and quaternions have different length</strong><strong>, </strong><strong>or</strong> – </p></li>
<li><p><strong>breaks have length &lt; 2.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[float], breaks: List[float], rotation_matrices: List[numpy.ndarray[numpy.float64[3, 3]]]) -&gt; None</p></li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if breaks and rot_matrices have different length</strong><strong>, </strong><strong>or</strong> – </p></li>
<li><p><strong>breaks have length &lt; 2.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[float], breaks: List[float], rotation_matrices: List[pydrake.math.RotationMatrix_[float]]) -&gt; None</p></li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if breaks and rot_matrices have different length</strong><strong>, </strong><strong>or</strong> – </p></li>
<li><p><strong>breaks have length &lt; 2.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="5">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[float], breaks: List[float], angle_axes: List[pydrake.common.eigen_geometry.AngleAxis_[float]]) -&gt; None</p></li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if breaks and ang_axes have different length</strong><strong>, </strong><strong>or</strong> – </p></li>
<li><p><strong>breaks have length &lt; 2.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp_.PiecewiseQuaternionSlerp_-float-.angular_acceleration">
<span id="pydrake.trajectories.PiecewiseQuaternionSlerp_.PiecewiseQuaternionSlerp_[float].angular_acceleration"></span><span class="sig-name descname"><span class="pre">angular_acceleration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_" title="pydrake.trajectories.PiecewiseQuaternionSlerp_"><span class="pre">pydrake.trajectories.PiecewiseQuaternionSlerp_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_.PiecewiseQuaternionSlerp_-float-.angular_acceleration" title="Permalink to this definition"></a></dt>
<dd><p>Interpolates angular acceleration.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time</span></code>:</dt><dd><p>Time for interpolation.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The interpolated angular acceleration at <code class="docutils literal notranslate"><span class="pre">time</span></code>, which is always
zero for slerp.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp_.PiecewiseQuaternionSlerp_-float-.angular_velocity">
<span id="pydrake.trajectories.PiecewiseQuaternionSlerp_.PiecewiseQuaternionSlerp_[float].angular_velocity"></span><span class="sig-name descname"><span class="pre">angular_velocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_" title="pydrake.trajectories.PiecewiseQuaternionSlerp_"><span class="pre">pydrake.trajectories.PiecewiseQuaternionSlerp_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_.PiecewiseQuaternionSlerp_-float-.angular_velocity" title="Permalink to this definition"></a></dt>
<dd><p>Interpolates angular velocity.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time</span></code>:</dt><dd><p>Time for interpolation.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The interpolated angular velocity at <code class="docutils literal notranslate"><span class="pre">time</span></code>, which is constant
per segment.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp_.PiecewiseQuaternionSlerp_-float-.Append">
<span id="pydrake.trajectories.PiecewiseQuaternionSlerp_.PiecewiseQuaternionSlerp_[float].Append"></span><span class="sig-name descname"><span class="pre">Append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_.PiecewiseQuaternionSlerp_-float-.Append" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>Append(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[float], time: float, quaternion: pydrake.common.eigen_geometry.Quaternion_[float]) -&gt; None</p></li>
</ol>
<p>Given a new Quaternion, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<ol class="arabic simple" start="2">
<li><p>Append(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[float], time: float, rotation_matrix: pydrake.math.RotationMatrix_[float]) -&gt; None</p></li>
</ol>
<p>Given a new RotationMatrix, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<ol class="arabic simple" start="3">
<li><p>Append(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[float], time: float, angle_axis: pydrake.common.eigen_geometry.AngleAxis_[float]) -&gt; None</p></li>
</ol>
<p>Given a new AngleAxis, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp_.PiecewiseQuaternionSlerp_-float-.orientation">
<span id="pydrake.trajectories.PiecewiseQuaternionSlerp_.PiecewiseQuaternionSlerp_[float].orientation"></span><span class="sig-name descname"><span class="pre">orientation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_" title="pydrake.trajectories.PiecewiseQuaternionSlerp_"><span class="pre">pydrake.trajectories.PiecewiseQuaternionSlerp_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.common.eigen_geometry.html#pydrake.common.eigen_geometry.Quaternion_" title="pydrake.common.eigen_geometry.Quaternion_"><span class="pre">pydrake.common.eigen_geometry.Quaternion_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_.PiecewiseQuaternionSlerp_-float-.orientation" title="Permalink to this definition"></a></dt>
<dd><p>Interpolates orientation.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time</span></code>:</dt><dd><p>Time for interpolation.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The interpolated quaternion at <code class="docutils literal notranslate"><span class="pre">time</span></code>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp_-AutoDiffXd">
<span id="pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PiecewiseQuaternionSlerp_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd" title="pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd]</span></code></a></p>
<p>A class representing a trajectory for quaternions that are
interpolated using piecewise slerp (spherical linear interpolation).
All the orientation samples are expected to be with respect to the
same parent reference frame, i.e. q_i represents the rotation R_PBi
for the orientation of frame B at the ith sample in a fixed parent
frame P. The world frame is a common choice for the parent frame. The
angular velocity and acceleration are also relative to the parent
frame and expressed in the parent frame. Since there is a sign
ambiguity when using quaternions to represent orientation, namely q
and -q represent the same orientation, the internal quaternion
representations ensure that q_n.dot(q_{n+1}) &gt;= 0. Another intuitive
way to think about this is that consecutive quaternions have the
shortest geodesic distance on the unit sphere. Note that the
quarternion value is in w, x, y, z order when represented as a
Vector4.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp_-AutoDiffXd-.__init__">
<span id="pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_-AutoDiffXd-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Builds an empty PiecewiseQuaternionSlerp.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd], breaks: List[pydrake.autodiffutils.AutoDiffXd], quaternions: List[pydrake.common.eigen_geometry.Quaternion_[AutoDiffXd]]) -&gt; None</p></li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if breaks and quaternions have different length</strong><strong>, </strong><strong>or</strong> – </p></li>
<li><p><strong>breaks have length &lt; 2.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd], breaks: List[pydrake.autodiffutils.AutoDiffXd], rotation_matrices: List[numpy.ndarray[object[3, 3]]]) -&gt; None</p></li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if breaks and rot_matrices have different length</strong><strong>, </strong><strong>or</strong> – </p></li>
<li><p><strong>breaks have length &lt; 2.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd], breaks: List[pydrake.autodiffutils.AutoDiffXd], rotation_matrices: List[pydrake.math.RotationMatrix_[AutoDiffXd]]) -&gt; None</p></li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if breaks and rot_matrices have different length</strong><strong>, </strong><strong>or</strong> – </p></li>
<li><p><strong>breaks have length &lt; 2.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="5">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd], breaks: List[pydrake.autodiffutils.AutoDiffXd], angle_axes: List[pydrake.common.eigen_geometry.AngleAxis_[AutoDiffXd]]) -&gt; None</p></li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if breaks and ang_axes have different length</strong><strong>, </strong><strong>or</strong> – </p></li>
<li><p><strong>breaks have length &lt; 2.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp_-AutoDiffXd-.angular_acceleration">
<span id="pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd].angular_acceleration"></span><span class="sig-name descname"><span class="pre">angular_acceleration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_" title="pydrake.trajectories.PiecewiseQuaternionSlerp_"><span class="pre">pydrake.trajectories.PiecewiseQuaternionSlerp_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_-AutoDiffXd-.angular_acceleration" title="Permalink to this definition"></a></dt>
<dd><p>Interpolates angular acceleration.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time</span></code>:</dt><dd><p>Time for interpolation.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The interpolated angular acceleration at <code class="docutils literal notranslate"><span class="pre">time</span></code>, which is always
zero for slerp.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp_-AutoDiffXd-.angular_velocity">
<span id="pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd].angular_velocity"></span><span class="sig-name descname"><span class="pre">angular_velocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_" title="pydrake.trajectories.PiecewiseQuaternionSlerp_"><span class="pre">pydrake.trajectories.PiecewiseQuaternionSlerp_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_-AutoDiffXd-.angular_velocity" title="Permalink to this definition"></a></dt>
<dd><p>Interpolates angular velocity.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time</span></code>:</dt><dd><p>Time for interpolation.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The interpolated angular velocity at <code class="docutils literal notranslate"><span class="pre">time</span></code>, which is constant
per segment.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp_-AutoDiffXd-.Append">
<span id="pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd].Append"></span><span class="sig-name descname"><span class="pre">Append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_-AutoDiffXd-.Append" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>Append(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd], time: pydrake.autodiffutils.AutoDiffXd, quaternion: pydrake.common.eigen_geometry.Quaternion_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Given a new Quaternion, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<ol class="arabic simple" start="2">
<li><p>Append(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd], time: pydrake.autodiffutils.AutoDiffXd, rotation_matrix: pydrake.math.RotationMatrix_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Given a new RotationMatrix, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<ol class="arabic simple" start="3">
<li><p>Append(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd], time: pydrake.autodiffutils.AutoDiffXd, angle_axis: pydrake.common.eigen_geometry.AngleAxis_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Given a new AngleAxis, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp_-AutoDiffXd-.orientation">
<span id="pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd].orientation"></span><span class="sig-name descname"><span class="pre">orientation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_" title="pydrake.trajectories.PiecewiseQuaternionSlerp_"><span class="pre">pydrake.trajectories.PiecewiseQuaternionSlerp_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.common.eigen_geometry.html#pydrake.common.eigen_geometry.Quaternion_" title="pydrake.common.eigen_geometry.Quaternion_"><span class="pre">pydrake.common.eigen_geometry.Quaternion_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_-AutoDiffXd-.orientation" title="Permalink to this definition"></a></dt>
<dd><p>Interpolates orientation.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time</span></code>:</dt><dd><p>Time for interpolation.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The interpolated quaternion at <code class="docutils literal notranslate"><span class="pre">time</span></code>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp_-Expression">
<span id="pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PiecewiseQuaternionSlerp_[Expression]</span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_-Expression" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_-Expression" title="pydrake.trajectories.PiecewiseTrajectory_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_[Expression]</span></code></a></p>
<p>A class representing a trajectory for quaternions that are
interpolated using piecewise slerp (spherical linear interpolation).
All the orientation samples are expected to be with respect to the
same parent reference frame, i.e. q_i represents the rotation R_PBi
for the orientation of frame B at the ith sample in a fixed parent
frame P. The world frame is a common choice for the parent frame. The
angular velocity and acceleration are also relative to the parent
frame and expressed in the parent frame. Since there is a sign
ambiguity when using quaternions to represent orientation, namely q
and -q represent the same orientation, the internal quaternion
representations ensure that q_n.dot(q_{n+1}) &gt;= 0. Another intuitive
way to think about this is that consecutive quaternions have the
shortest geodesic distance on the unit sphere. Note that the
quarternion value is in w, x, y, z order when represented as a
Vector4.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp_-Expression-.__init__">
<span id="pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_-Expression-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression]) -&gt; None</p></li>
</ol>
<p>Builds an empty PiecewiseQuaternionSlerp.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression], breaks: List[pydrake.symbolic.Expression], quaternions: List[pydrake.common.eigen_geometry.Quaternion_[Expression]]) -&gt; None</p></li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if breaks and quaternions have different length</strong><strong>, </strong><strong>or</strong> – </p></li>
<li><p><strong>breaks have length &lt; 2.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression], breaks: List[pydrake.symbolic.Expression], rotation_matrices: List[numpy.ndarray[object[3, 3]]]) -&gt; None</p></li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if breaks and rot_matrices have different length</strong><strong>, </strong><strong>or</strong> – </p></li>
<li><p><strong>breaks have length &lt; 2.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression], breaks: List[pydrake.symbolic.Expression], rotation_matrices: List[pydrake.math.RotationMatrix_[Expression]]) -&gt; None</p></li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if breaks and rot_matrices have different length</strong><strong>, </strong><strong>or</strong> – </p></li>
<li><p><strong>breaks have length &lt; 2.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="5">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression], breaks: List[pydrake.symbolic.Expression], angle_axes: List[pydrake.common.eigen_geometry.AngleAxis_[Expression]]) -&gt; None</p></li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if breaks and ang_axes have different length</strong><strong>, </strong><strong>or</strong> – </p></li>
<li><p><strong>breaks have length &lt; 2.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp_-Expression-.angular_acceleration">
<span id="pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression].angular_acceleration"></span><span class="sig-name descname"><span class="pre">angular_acceleration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_" title="pydrake.trajectories.PiecewiseQuaternionSlerp_"><span class="pre">pydrake.trajectories.PiecewiseQuaternionSlerp_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_-Expression-.angular_acceleration" title="Permalink to this definition"></a></dt>
<dd><p>Interpolates angular acceleration.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time</span></code>:</dt><dd><p>Time for interpolation.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The interpolated angular acceleration at <code class="docutils literal notranslate"><span class="pre">time</span></code>, which is always
zero for slerp.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp_-Expression-.angular_velocity">
<span id="pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression].angular_velocity"></span><span class="sig-name descname"><span class="pre">angular_velocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_" title="pydrake.trajectories.PiecewiseQuaternionSlerp_"><span class="pre">pydrake.trajectories.PiecewiseQuaternionSlerp_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_-Expression-.angular_velocity" title="Permalink to this definition"></a></dt>
<dd><p>Interpolates angular velocity.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time</span></code>:</dt><dd><p>Time for interpolation.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The interpolated angular velocity at <code class="docutils literal notranslate"><span class="pre">time</span></code>, which is constant
per segment.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp_-Expression-.Append">
<span id="pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression].Append"></span><span class="sig-name descname"><span class="pre">Append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_-Expression-.Append" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>Append(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression], time: pydrake.symbolic.Expression, quaternion: pydrake.common.eigen_geometry.Quaternion_[Expression]) -&gt; None</p></li>
</ol>
<p>Given a new Quaternion, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<ol class="arabic simple" start="2">
<li><p>Append(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression], time: pydrake.symbolic.Expression, rotation_matrix: pydrake.math.RotationMatrix_[Expression]) -&gt; None</p></li>
</ol>
<p>Given a new RotationMatrix, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<ol class="arabic simple" start="3">
<li><p>Append(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression], time: pydrake.symbolic.Expression, angle_axis: pydrake.common.eigen_geometry.AngleAxis_[Expression]) -&gt; None</p></li>
</ol>
<p>Given a new AngleAxis, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp_-Expression-.orientation">
<span id="pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression].orientation"></span><span class="sig-name descname"><span class="pre">orientation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_" title="pydrake.trajectories.PiecewiseQuaternionSlerp_"><span class="pre">pydrake.trajectories.PiecewiseQuaternionSlerp_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.common.eigen_geometry.html#pydrake.common.eigen_geometry.Quaternion_" title="pydrake.common.eigen_geometry.Quaternion_"><span class="pre">pydrake.common.eigen_geometry.Quaternion_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_-Expression-.orientation" title="Permalink to this definition"></a></dt>
<dd><p>Interpolates orientation.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time</span></code>:</dt><dd><p>Time for interpolation.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The interpolated quaternion at <code class="docutils literal notranslate"><span class="pre">time</span></code>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp_-float">
<span id="pydrake.trajectories.PiecewiseQuaternionSlerp_[float]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PiecewiseQuaternionSlerp_[float]</span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_-float" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_-float" title="pydrake.trajectories.PiecewiseTrajectory_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_[float]</span></code></a></p>
<p>A class representing a trajectory for quaternions that are
interpolated using piecewise slerp (spherical linear interpolation).
All the orientation samples are expected to be with respect to the
same parent reference frame, i.e. q_i represents the rotation R_PBi
for the orientation of frame B at the ith sample in a fixed parent
frame P. The world frame is a common choice for the parent frame. The
angular velocity and acceleration are also relative to the parent
frame and expressed in the parent frame. Since there is a sign
ambiguity when using quaternions to represent orientation, namely q
and -q represent the same orientation, the internal quaternion
representations ensure that q_n.dot(q_{n+1}) &gt;= 0. Another intuitive
way to think about this is that consecutive quaternions have the
shortest geodesic distance on the unit sphere. Note that the
quarternion value is in w, x, y, z order when represented as a
Vector4.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp_-float-.__init__">
<span id="pydrake.trajectories.PiecewiseQuaternionSlerp_[float].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_-float-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[float]) -&gt; None</p></li>
</ol>
<p>Builds an empty PiecewiseQuaternionSlerp.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[float], breaks: List[float], quaternions: List[pydrake.common.eigen_geometry.Quaternion_[float]]) -&gt; None</p></li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if breaks and quaternions have different length</strong><strong>, </strong><strong>or</strong> – </p></li>
<li><p><strong>breaks have length &lt; 2.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[float], breaks: List[float], rotation_matrices: List[numpy.ndarray[numpy.float64[3, 3]]]) -&gt; None</p></li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if breaks and rot_matrices have different length</strong><strong>, </strong><strong>or</strong> – </p></li>
<li><p><strong>breaks have length &lt; 2.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[float], breaks: List[float], rotation_matrices: List[pydrake.math.RotationMatrix_[float]]) -&gt; None</p></li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if breaks and rot_matrices have different length</strong><strong>, </strong><strong>or</strong> – </p></li>
<li><p><strong>breaks have length &lt; 2.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="5">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[float], breaks: List[float], angle_axes: List[pydrake.common.eigen_geometry.AngleAxis_[float]]) -&gt; None</p></li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if breaks and ang_axes have different length</strong><strong>, </strong><strong>or</strong> – </p></li>
<li><p><strong>breaks have length &lt; 2.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp_-float-.angular_acceleration">
<span id="pydrake.trajectories.PiecewiseQuaternionSlerp_[float].angular_acceleration"></span><span class="sig-name descname"><span class="pre">angular_acceleration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_" title="pydrake.trajectories.PiecewiseQuaternionSlerp_"><span class="pre">pydrake.trajectories.PiecewiseQuaternionSlerp_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_-float-.angular_acceleration" title="Permalink to this definition"></a></dt>
<dd><p>Interpolates angular acceleration.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time</span></code>:</dt><dd><p>Time for interpolation.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The interpolated angular acceleration at <code class="docutils literal notranslate"><span class="pre">time</span></code>, which is always
zero for slerp.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp_-float-.angular_velocity">
<span id="pydrake.trajectories.PiecewiseQuaternionSlerp_[float].angular_velocity"></span><span class="sig-name descname"><span class="pre">angular_velocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_" title="pydrake.trajectories.PiecewiseQuaternionSlerp_"><span class="pre">pydrake.trajectories.PiecewiseQuaternionSlerp_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="m"><span class="pre">3</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="m"><span class="pre">1</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_-float-.angular_velocity" title="Permalink to this definition"></a></dt>
<dd><p>Interpolates angular velocity.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time</span></code>:</dt><dd><p>Time for interpolation.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The interpolated angular velocity at <code class="docutils literal notranslate"><span class="pre">time</span></code>, which is constant
per segment.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp_-float-.Append">
<span id="pydrake.trajectories.PiecewiseQuaternionSlerp_[float].Append"></span><span class="sig-name descname"><span class="pre">Append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_-float-.Append" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>Append(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[float], time: float, quaternion: pydrake.common.eigen_geometry.Quaternion_[float]) -&gt; None</p></li>
</ol>
<p>Given a new Quaternion, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<ol class="arabic simple" start="2">
<li><p>Append(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[float], time: float, rotation_matrix: pydrake.math.RotationMatrix_[float]) -&gt; None</p></li>
</ol>
<p>Given a new RotationMatrix, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<ol class="arabic simple" start="3">
<li><p>Append(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[float], time: float, angle_axis: pydrake.common.eigen_geometry.AngleAxis_[float]) -&gt; None</p></li>
</ol>
<p>Given a new AngleAxis, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseQuaternionSlerp_-float-.orientation">
<span id="pydrake.trajectories.PiecewiseQuaternionSlerp_[float].orientation"></span><span class="sig-name descname"><span class="pre">orientation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_" title="pydrake.trajectories.PiecewiseQuaternionSlerp_"><span class="pre">pydrake.trajectories.PiecewiseQuaternionSlerp_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.common.eigen_geometry.html#pydrake.common.eigen_geometry.Quaternion_" title="pydrake.common.eigen_geometry.Quaternion_"><span class="pre">pydrake.common.eigen_geometry.Quaternion_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp_-float-.orientation" title="Permalink to this definition"></a></dt>
<dd><p>Interpolates orientation.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time</span></code>:</dt><dd><p>Time for interpolation.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The interpolated quaternion at <code class="docutils literal notranslate"><span class="pre">time</span></code>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory">
<span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PiecewiseTrajectory</span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory" title="Permalink to this definition"></a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_-float" title="pydrake.trajectories.PiecewiseTrajectory_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_[float]</span></code></a></p>
</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PiecewiseTrajectory_</span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_-float" title="pydrake.trajectories.PiecewiseTrajectory_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewiseTrajectory_[float]</span></code></a>, <a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd" title="pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewiseTrajectory_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_-Expression" title="pydrake.trajectories.PiecewiseTrajectory_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewiseTrajectory_[Expression]</span></code></a></p>
<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_.PiecewiseTrajectory_-float">
<span id="pydrake.trajectories.PiecewiseTrajectory_.PiecewiseTrajectory_[float]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">PiecewiseTrajectory_[float]</span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_.PiecewiseTrajectory_-float" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.Trajectory_-float" title="pydrake.trajectories.Trajectory_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[float]</span></code></a></p>
<p>Abstract class that implements the basic logic of maintaining
consequent segments of time (delimited by <code class="docutils literal notranslate"><span class="pre">breaks</span></code>) to implement a
trajectory that is represented by simpler logic in each segment or
“piece”.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_.PiecewiseTrajectory_-float-.__init__">
<span id="pydrake.trajectories.PiecewiseTrajectory_.PiecewiseTrajectory_[float].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_.PiecewiseTrajectory_-float-.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_.PiecewiseTrajectory_-float-.duration">
<span id="pydrake.trajectories.PiecewiseTrajectory_.PiecewiseTrajectory_[float].duration"></span><span class="sig-name descname"><span class="pre">duration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_" title="pydrake.trajectories.PiecewiseTrajectory_"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_.PiecewiseTrajectory_-float-.duration" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_.PiecewiseTrajectory_-float-.end_time">
<span id="pydrake.trajectories.PiecewiseTrajectory_.PiecewiseTrajectory_[float].end_time"></span><span class="sig-name descname"><span class="pre">end_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_.PiecewiseTrajectory_-float-.end_time" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>end_time(self: pydrake.trajectories.PiecewiseTrajectory_[float], segment_index: int) -&gt; float</p></li>
<li><p>end_time(self: pydrake.trajectories.PiecewiseTrajectory_[float]) -&gt; float</p></li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_.PiecewiseTrajectory_-float-.get_number_of_segments">
<span id="pydrake.trajectories.PiecewiseTrajectory_.PiecewiseTrajectory_[float].get_number_of_segments"></span><span class="sig-name descname"><span class="pre">get_number_of_segments</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_" title="pydrake.trajectories.PiecewiseTrajectory_"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_.PiecewiseTrajectory_-float-.get_number_of_segments" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_.PiecewiseTrajectory_-float-.get_segment_index">
<span id="pydrake.trajectories.PiecewiseTrajectory_.PiecewiseTrajectory_[float].get_segment_index"></span><span class="sig-name descname"><span class="pre">get_segment_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_" title="pydrake.trajectories.PiecewiseTrajectory_"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_.PiecewiseTrajectory_-float-.get_segment_index" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_.PiecewiseTrajectory_-float-.get_segment_times">
<span id="pydrake.trajectories.PiecewiseTrajectory_.PiecewiseTrajectory_[float].get_segment_times"></span><span class="sig-name descname"><span class="pre">get_segment_times</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_" title="pydrake.trajectories.PiecewiseTrajectory_"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_.PiecewiseTrajectory_-float-.get_segment_times" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_.PiecewiseTrajectory_-float-.is_time_in_range">
<span id="pydrake.trajectories.PiecewiseTrajectory_.PiecewiseTrajectory_[float].is_time_in_range"></span><span class="sig-name descname"><span class="pre">is_time_in_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_" title="pydrake.trajectories.PiecewiseTrajectory_"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_.PiecewiseTrajectory_-float-.is_time_in_range" title="Permalink to this definition"></a></dt>
<dd><p>Returns true iff <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">&gt;=</span> <span class="pre">getStartTime()</span> <span class="pre">&amp;&amp;</span> <span class="pre">t</span> <span class="pre">&lt;=</span> <span class="pre">getEndTime()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_.PiecewiseTrajectory_-float-.start_time">
<span id="pydrake.trajectories.PiecewiseTrajectory_.PiecewiseTrajectory_[float].start_time"></span><span class="sig-name descname"><span class="pre">start_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_.PiecewiseTrajectory_-float-.start_time" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>start_time(self: pydrake.trajectories.PiecewiseTrajectory_[float], segment_index: int) -&gt; float</p></li>
<li><p>start_time(self: pydrake.trajectories.PiecewiseTrajectory_[float]) -&gt; float</p></li>
</ol>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd">
<span id="pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PiecewiseTrajectory_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.Trajectory_-AutoDiffXd" title="pydrake.trajectories.Trajectory_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[AutoDiffXd]</span></code></a></p>
<p>Abstract class that implements the basic logic of maintaining
consequent segments of time (delimited by <code class="docutils literal notranslate"><span class="pre">breaks</span></code>) to implement a
trajectory that is represented by simpler logic in each segment or
“piece”.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd-.__init__">
<span id="pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd-.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd-.duration">
<span id="pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd].duration"></span><span class="sig-name descname"><span class="pre">duration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_" title="pydrake.trajectories.PiecewiseTrajectory_"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd-.duration" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd-.end_time">
<span id="pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd].end_time"></span><span class="sig-name descname"><span class="pre">end_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd-.end_time" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>end_time(self: pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd], segment_index: int) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
<li><p>end_time(self: pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd]) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd-.get_number_of_segments">
<span id="pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd].get_number_of_segments"></span><span class="sig-name descname"><span class="pre">get_number_of_segments</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_" title="pydrake.trajectories.PiecewiseTrajectory_"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd-.get_number_of_segments" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd-.get_segment_index">
<span id="pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd].get_segment_index"></span><span class="sig-name descname"><span class="pre">get_segment_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_" title="pydrake.trajectories.PiecewiseTrajectory_"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd-.get_segment_index" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd-.get_segment_times">
<span id="pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd].get_segment_times"></span><span class="sig-name descname"><span class="pre">get_segment_times</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_" title="pydrake.trajectories.PiecewiseTrajectory_"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd-.get_segment_times" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd-.is_time_in_range">
<span id="pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd].is_time_in_range"></span><span class="sig-name descname"><span class="pre">is_time_in_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_" title="pydrake.trajectories.PiecewiseTrajectory_"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd-.is_time_in_range" title="Permalink to this definition"></a></dt>
<dd><p>Returns true iff <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">&gt;=</span> <span class="pre">getStartTime()</span> <span class="pre">&amp;&amp;</span> <span class="pre">t</span> <span class="pre">&lt;=</span> <span class="pre">getEndTime()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd-.start_time">
<span id="pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd].start_time"></span><span class="sig-name descname"><span class="pre">start_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-AutoDiffXd-.start_time" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>start_time(self: pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd], segment_index: int) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
<li><p>start_time(self: pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd]) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
</ol>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-Expression">
<span id="pydrake.trajectories.PiecewiseTrajectory_[Expression]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PiecewiseTrajectory_[Expression]</span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-Expression" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.Trajectory_-Expression" title="pydrake.trajectories.Trajectory_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[Expression]</span></code></a></p>
<p>Abstract class that implements the basic logic of maintaining
consequent segments of time (delimited by <code class="docutils literal notranslate"><span class="pre">breaks</span></code>) to implement a
trajectory that is represented by simpler logic in each segment or
“piece”.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-Expression-.__init__">
<span id="pydrake.trajectories.PiecewiseTrajectory_[Expression].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-Expression-.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-Expression-.duration">
<span id="pydrake.trajectories.PiecewiseTrajectory_[Expression].duration"></span><span class="sig-name descname"><span class="pre">duration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_" title="pydrake.trajectories.PiecewiseTrajectory_"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-Expression-.duration" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-Expression-.end_time">
<span id="pydrake.trajectories.PiecewiseTrajectory_[Expression].end_time"></span><span class="sig-name descname"><span class="pre">end_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-Expression-.end_time" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>end_time(self: pydrake.trajectories.PiecewiseTrajectory_[Expression], segment_index: int) -&gt; pydrake.symbolic.Expression</p></li>
<li><p>end_time(self: pydrake.trajectories.PiecewiseTrajectory_[Expression]) -&gt; pydrake.symbolic.Expression</p></li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-Expression-.get_number_of_segments">
<span id="pydrake.trajectories.PiecewiseTrajectory_[Expression].get_number_of_segments"></span><span class="sig-name descname"><span class="pre">get_number_of_segments</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_" title="pydrake.trajectories.PiecewiseTrajectory_"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-Expression-.get_number_of_segments" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-Expression-.get_segment_index">
<span id="pydrake.trajectories.PiecewiseTrajectory_[Expression].get_segment_index"></span><span class="sig-name descname"><span class="pre">get_segment_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_" title="pydrake.trajectories.PiecewiseTrajectory_"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-Expression-.get_segment_index" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-Expression-.get_segment_times">
<span id="pydrake.trajectories.PiecewiseTrajectory_[Expression].get_segment_times"></span><span class="sig-name descname"><span class="pre">get_segment_times</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_" title="pydrake.trajectories.PiecewiseTrajectory_"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-Expression-.get_segment_times" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-Expression-.is_time_in_range">
<span id="pydrake.trajectories.PiecewiseTrajectory_[Expression].is_time_in_range"></span><span class="sig-name descname"><span class="pre">is_time_in_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_" title="pydrake.trajectories.PiecewiseTrajectory_"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Formula" title="pydrake.symbolic.Formula"><span class="pre">pydrake.symbolic.Formula</span></a></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-Expression-.is_time_in_range" title="Permalink to this definition"></a></dt>
<dd><p>Returns true iff <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">&gt;=</span> <span class="pre">getStartTime()</span> <span class="pre">&amp;&amp;</span> <span class="pre">t</span> <span class="pre">&lt;=</span> <span class="pre">getEndTime()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-Expression-.start_time">
<span id="pydrake.trajectories.PiecewiseTrajectory_[Expression].start_time"></span><span class="sig-name descname"><span class="pre">start_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-Expression-.start_time" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>start_time(self: pydrake.trajectories.PiecewiseTrajectory_[Expression], segment_index: int) -&gt; pydrake.symbolic.Expression</p></li>
<li><p>start_time(self: pydrake.trajectories.PiecewiseTrajectory_[Expression]) -&gt; pydrake.symbolic.Expression</p></li>
</ol>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-float">
<span id="pydrake.trajectories.PiecewiseTrajectory_[float]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">PiecewiseTrajectory_[float]</span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-float" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.Trajectory_-float" title="pydrake.trajectories.Trajectory_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[float]</span></code></a></p>
<p>Abstract class that implements the basic logic of maintaining
consequent segments of time (delimited by <code class="docutils literal notranslate"><span class="pre">breaks</span></code>) to implement a
trajectory that is represented by simpler logic in each segment or
“piece”.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-float-.__init__">
<span id="pydrake.trajectories.PiecewiseTrajectory_[float].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-float-.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-float-.duration">
<span id="pydrake.trajectories.PiecewiseTrajectory_[float].duration"></span><span class="sig-name descname"><span class="pre">duration</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_" title="pydrake.trajectories.PiecewiseTrajectory_"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment_index</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-float-.duration" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-float-.end_time">
<span id="pydrake.trajectories.PiecewiseTrajectory_[float].end_time"></span><span class="sig-name descname"><span class="pre">end_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-float-.end_time" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>end_time(self: pydrake.trajectories.PiecewiseTrajectory_[float], segment_index: int) -&gt; float</p></li>
<li><p>end_time(self: pydrake.trajectories.PiecewiseTrajectory_[float]) -&gt; float</p></li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-float-.get_number_of_segments">
<span id="pydrake.trajectories.PiecewiseTrajectory_[float].get_number_of_segments"></span><span class="sig-name descname"><span class="pre">get_number_of_segments</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_" title="pydrake.trajectories.PiecewiseTrajectory_"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-float-.get_number_of_segments" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-float-.get_segment_index">
<span id="pydrake.trajectories.PiecewiseTrajectory_[float].get_segment_index"></span><span class="sig-name descname"><span class="pre">get_segment_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_" title="pydrake.trajectories.PiecewiseTrajectory_"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-float-.get_segment_index" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-float-.get_segment_times">
<span id="pydrake.trajectories.PiecewiseTrajectory_[float].get_segment_times"></span><span class="sig-name descname"><span class="pre">get_segment_times</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_" title="pydrake.trajectories.PiecewiseTrajectory_"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-float-.get_segment_times" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-float-.is_time_in_range">
<span id="pydrake.trajectories.PiecewiseTrajectory_[float].is_time_in_range"></span><span class="sig-name descname"><span class="pre">is_time_in_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory_" title="pydrake.trajectories.PiecewiseTrajectory_"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-float-.is_time_in_range" title="Permalink to this definition"></a></dt>
<dd><p>Returns true iff <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">&gt;=</span> <span class="pre">getStartTime()</span> <span class="pre">&amp;&amp;</span> <span class="pre">t</span> <span class="pre">&lt;=</span> <span class="pre">getEndTime()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.PiecewiseTrajectory_-float-.start_time">
<span id="pydrake.trajectories.PiecewiseTrajectory_[float].start_time"></span><span class="sig-name descname"><span class="pre">start_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory_-float-.start_time" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>start_time(self: pydrake.trajectories.PiecewiseTrajectory_[float], segment_index: int) -&gt; float</p></li>
<li><p>start_time(self: pydrake.trajectories.PiecewiseTrajectory_[float]) -&gt; float</p></li>
</ol>
</dd></dl>

</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.trajectories.StackedTrajectory">
<span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">StackedTrajectory</span></span><a class="headerlink" href="#pydrake.trajectories.StackedTrajectory" title="Permalink to this definition"></a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.trajectories.StackedTrajectory_-float" title="pydrake.trajectories.StackedTrajectory_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.StackedTrajectory_[float]</span></code></a></p>
</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.trajectories.StackedTrajectory_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">StackedTrajectory_</span></span><a class="headerlink" href="#pydrake.trajectories.StackedTrajectory_" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.trajectories.StackedTrajectory_-float" title="pydrake.trajectories.StackedTrajectory_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">StackedTrajectory_[float]</span></code></a>, <a class="reference internal" href="#pydrake.trajectories.StackedTrajectory_-AutoDiffXd" title="pydrake.trajectories.StackedTrajectory_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">StackedTrajectory_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.trajectories.StackedTrajectory_-Expression" title="pydrake.trajectories.StackedTrajectory_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">StackedTrajectory_[Expression]</span></code></a></p>
<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.StackedTrajectory_.StackedTrajectory_-float">
<span id="pydrake.trajectories.StackedTrajectory_.StackedTrajectory_[float]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">StackedTrajectory_[float]</span></span><a class="headerlink" href="#pydrake.trajectories.StackedTrajectory_.StackedTrajectory_-float" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.Trajectory_-float" title="pydrake.trajectories.Trajectory_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[float]</span></code></a></p>
<p>A StackedTrajectory stacks the values from one or more underlying
Trajectory objects into a single Trajectory, without changing the
<code class="docutils literal notranslate"><span class="pre">%start_time()</span></code> or <code class="docutils literal notranslate"><span class="pre">%end_time()</span></code>.</p>
<p>For sequencing trajectories in time instead, see PiecewiseTrajectory.</p>
<p>All of the underlying Trajectory objects must have the same
<code class="docutils literal notranslate"><span class="pre">%start_time()</span></code> and <code class="docutils literal notranslate"><span class="pre">%end_time()</span></code>.</p>
<p>When constructed with <code class="docutils literal notranslate"><span class="pre">rowwise</span></code> set to true, all of the underlying
Trajectory objects must have the same number of <code class="docutils literal notranslate"><span class="pre">%cols()</span></code> and the
<code class="docutils literal notranslate"><span class="pre">value()</span></code> matrix will be the <strong>vstack</strong> of the the trajectories in
the order they were added.</p>
<p>When constructed with <code class="docutils literal notranslate"><span class="pre">rowwise</span></code> set to false, all of the underlying
Trajectory objects must have the same number of <code class="docutils literal notranslate"><span class="pre">%rows()</span></code> and the
<code class="docutils literal notranslate"><span class="pre">value()</span></code> matrix will be the <strong>hstack</strong> of the the trajectories in
the order they were added.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.StackedTrajectory_.StackedTrajectory_-float-.__init__">
<span id="pydrake.trajectories.StackedTrajectory_.StackedTrajectory_[float].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.StackedTrajectory_" title="pydrake.trajectories.StackedTrajectory_"><span class="pre">pydrake.trajectories.StackedTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rowwise</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.StackedTrajectory_.StackedTrajectory_-float-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Creates an empty trajectory.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rowwise</span></code>:</dt><dd><p>governs the stacking order</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.StackedTrajectory_.StackedTrajectory_-float-.Append">
<span id="pydrake.trajectories.StackedTrajectory_.StackedTrajectory_[float].Append"></span><span class="sig-name descname"><span class="pre">Append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.StackedTrajectory_" title="pydrake.trajectories.StackedTrajectory_"><span class="pre">pydrake.trajectories.StackedTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.StackedTrajectory_.StackedTrajectory_-float-.Append" title="Permalink to this definition"></a></dt>
<dd><p>Stacks another sub-Trajectory onto this. Refer to the class overview
documentation for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the matrix dimension is incompatible.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.StackedTrajectory_.StackedTrajectory_-float-.Clone">
<span id="pydrake.trajectories.StackedTrajectory_.StackedTrajectory_[float].Clone"></span><span class="sig-name descname"><span class="pre">Clone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.StackedTrajectory_" title="pydrake.trajectories.StackedTrajectory_"><span class="pre">pydrake.trajectories.StackedTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.StackedTrajectory_.StackedTrajectory_-float-.Clone" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.StackedTrajectory_-AutoDiffXd">
<span id="pydrake.trajectories.StackedTrajectory_[AutoDiffXd]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">StackedTrajectory_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.trajectories.StackedTrajectory_-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.Trajectory_-AutoDiffXd" title="pydrake.trajectories.Trajectory_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[AutoDiffXd]</span></code></a></p>
<p>A StackedTrajectory stacks the values from one or more underlying
Trajectory objects into a single Trajectory, without changing the
<code class="docutils literal notranslate"><span class="pre">%start_time()</span></code> or <code class="docutils literal notranslate"><span class="pre">%end_time()</span></code>.</p>
<p>For sequencing trajectories in time instead, see PiecewiseTrajectory.</p>
<p>All of the underlying Trajectory objects must have the same
<code class="docutils literal notranslate"><span class="pre">%start_time()</span></code> and <code class="docutils literal notranslate"><span class="pre">%end_time()</span></code>.</p>
<p>When constructed with <code class="docutils literal notranslate"><span class="pre">rowwise</span></code> set to true, all of the underlying
Trajectory objects must have the same number of <code class="docutils literal notranslate"><span class="pre">%cols()</span></code> and the
<code class="docutils literal notranslate"><span class="pre">value()</span></code> matrix will be the <strong>vstack</strong> of the the trajectories in
the order they were added.</p>
<p>When constructed with <code class="docutils literal notranslate"><span class="pre">rowwise</span></code> set to false, all of the underlying
Trajectory objects must have the same number of <code class="docutils literal notranslate"><span class="pre">%rows()</span></code> and the
<code class="docutils literal notranslate"><span class="pre">value()</span></code> matrix will be the <strong>hstack</strong> of the the trajectories in
the order they were added.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.StackedTrajectory_-AutoDiffXd-.__init__">
<span id="pydrake.trajectories.StackedTrajectory_[AutoDiffXd].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.StackedTrajectory_" title="pydrake.trajectories.StackedTrajectory_"><span class="pre">pydrake.trajectories.StackedTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rowwise</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.StackedTrajectory_-AutoDiffXd-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Creates an empty trajectory.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rowwise</span></code>:</dt><dd><p>governs the stacking order</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.StackedTrajectory_-AutoDiffXd-.Append">
<span id="pydrake.trajectories.StackedTrajectory_[AutoDiffXd].Append"></span><span class="sig-name descname"><span class="pre">Append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.StackedTrajectory_" title="pydrake.trajectories.StackedTrajectory_"><span class="pre">pydrake.trajectories.StackedTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.StackedTrajectory_-AutoDiffXd-.Append" title="Permalink to this definition"></a></dt>
<dd><p>Stacks another sub-Trajectory onto this. Refer to the class overview
documentation for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the matrix dimension is incompatible.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.StackedTrajectory_-AutoDiffXd-.Clone">
<span id="pydrake.trajectories.StackedTrajectory_[AutoDiffXd].Clone"></span><span class="sig-name descname"><span class="pre">Clone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.StackedTrajectory_" title="pydrake.trajectories.StackedTrajectory_"><span class="pre">pydrake.trajectories.StackedTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.StackedTrajectory_-AutoDiffXd-.Clone" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.StackedTrajectory_-Expression">
<span id="pydrake.trajectories.StackedTrajectory_[Expression]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">StackedTrajectory_[Expression]</span></span><a class="headerlink" href="#pydrake.trajectories.StackedTrajectory_-Expression" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.Trajectory_-Expression" title="pydrake.trajectories.Trajectory_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[Expression]</span></code></a></p>
<p>A StackedTrajectory stacks the values from one or more underlying
Trajectory objects into a single Trajectory, without changing the
<code class="docutils literal notranslate"><span class="pre">%start_time()</span></code> or <code class="docutils literal notranslate"><span class="pre">%end_time()</span></code>.</p>
<p>For sequencing trajectories in time instead, see PiecewiseTrajectory.</p>
<p>All of the underlying Trajectory objects must have the same
<code class="docutils literal notranslate"><span class="pre">%start_time()</span></code> and <code class="docutils literal notranslate"><span class="pre">%end_time()</span></code>.</p>
<p>When constructed with <code class="docutils literal notranslate"><span class="pre">rowwise</span></code> set to true, all of the underlying
Trajectory objects must have the same number of <code class="docutils literal notranslate"><span class="pre">%cols()</span></code> and the
<code class="docutils literal notranslate"><span class="pre">value()</span></code> matrix will be the <strong>vstack</strong> of the the trajectories in
the order they were added.</p>
<p>When constructed with <code class="docutils literal notranslate"><span class="pre">rowwise</span></code> set to false, all of the underlying
Trajectory objects must have the same number of <code class="docutils literal notranslate"><span class="pre">%rows()</span></code> and the
<code class="docutils literal notranslate"><span class="pre">value()</span></code> matrix will be the <strong>hstack</strong> of the the trajectories in
the order they were added.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.StackedTrajectory_-Expression-.__init__">
<span id="pydrake.trajectories.StackedTrajectory_[Expression].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.StackedTrajectory_" title="pydrake.trajectories.StackedTrajectory_"><span class="pre">pydrake.trajectories.StackedTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rowwise</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.StackedTrajectory_-Expression-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Creates an empty trajectory.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rowwise</span></code>:</dt><dd><p>governs the stacking order</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.StackedTrajectory_-Expression-.Append">
<span id="pydrake.trajectories.StackedTrajectory_[Expression].Append"></span><span class="sig-name descname"><span class="pre">Append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.StackedTrajectory_" title="pydrake.trajectories.StackedTrajectory_"><span class="pre">pydrake.trajectories.StackedTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.StackedTrajectory_-Expression-.Append" title="Permalink to this definition"></a></dt>
<dd><p>Stacks another sub-Trajectory onto this. Refer to the class overview
documentation for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the matrix dimension is incompatible.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.StackedTrajectory_-Expression-.Clone">
<span id="pydrake.trajectories.StackedTrajectory_[Expression].Clone"></span><span class="sig-name descname"><span class="pre">Clone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.StackedTrajectory_" title="pydrake.trajectories.StackedTrajectory_"><span class="pre">pydrake.trajectories.StackedTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.StackedTrajectory_-Expression-.Clone" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.StackedTrajectory_-float">
<span id="pydrake.trajectories.StackedTrajectory_[float]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">StackedTrajectory_[float]</span></span><a class="headerlink" href="#pydrake.trajectories.StackedTrajectory_-float" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.Trajectory_-float" title="pydrake.trajectories.Trajectory_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[float]</span></code></a></p>
<p>A StackedTrajectory stacks the values from one or more underlying
Trajectory objects into a single Trajectory, without changing the
<code class="docutils literal notranslate"><span class="pre">%start_time()</span></code> or <code class="docutils literal notranslate"><span class="pre">%end_time()</span></code>.</p>
<p>For sequencing trajectories in time instead, see PiecewiseTrajectory.</p>
<p>All of the underlying Trajectory objects must have the same
<code class="docutils literal notranslate"><span class="pre">%start_time()</span></code> and <code class="docutils literal notranslate"><span class="pre">%end_time()</span></code>.</p>
<p>When constructed with <code class="docutils literal notranslate"><span class="pre">rowwise</span></code> set to true, all of the underlying
Trajectory objects must have the same number of <code class="docutils literal notranslate"><span class="pre">%cols()</span></code> and the
<code class="docutils literal notranslate"><span class="pre">value()</span></code> matrix will be the <strong>vstack</strong> of the the trajectories in
the order they were added.</p>
<p>When constructed with <code class="docutils literal notranslate"><span class="pre">rowwise</span></code> set to false, all of the underlying
Trajectory objects must have the same number of <code class="docutils literal notranslate"><span class="pre">%rows()</span></code> and the
<code class="docutils literal notranslate"><span class="pre">value()</span></code> matrix will be the <strong>hstack</strong> of the the trajectories in
the order they were added.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.StackedTrajectory_-float-.__init__">
<span id="pydrake.trajectories.StackedTrajectory_[float].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.StackedTrajectory_" title="pydrake.trajectories.StackedTrajectory_"><span class="pre">pydrake.trajectories.StackedTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rowwise</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.StackedTrajectory_-float-.__init__" title="Permalink to this definition"></a></dt>
<dd><p>Creates an empty trajectory.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rowwise</span></code>:</dt><dd><p>governs the stacking order</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.StackedTrajectory_-float-.Append">
<span id="pydrake.trajectories.StackedTrajectory_[float].Append"></span><span class="sig-name descname"><span class="pre">Append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.StackedTrajectory_" title="pydrake.trajectories.StackedTrajectory_"><span class="pre">pydrake.trajectories.StackedTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.StackedTrajectory_-float-.Append" title="Permalink to this definition"></a></dt>
<dd><p>Stacks another sub-Trajectory onto this. Refer to the class overview
documentation for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if the matrix dimension is incompatible.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.StackedTrajectory_-float-.Clone">
<span id="pydrake.trajectories.StackedTrajectory_[float].Clone"></span><span class="sig-name descname"><span class="pre">Clone</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.StackedTrajectory_" title="pydrake.trajectories.StackedTrajectory_"><span class="pre">pydrake.trajectories.StackedTrajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.StackedTrajectory_-float-.Clone" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory">
<span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">Trajectory</span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory" title="Permalink to this definition"></a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.trajectories.Trajectory_-float" title="pydrake.trajectories.Trajectory_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[float]</span></code></a></p>
</dd></dl>

<dl class="py template">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_">
<em class="property"><span class="pre">template</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">Trajectory_</span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_" title="Permalink to this definition"></a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.trajectories.Trajectory_-float" title="pydrake.trajectories.Trajectory_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Trajectory_[float]</span></code></a>, <a class="reference internal" href="#pydrake.trajectories.Trajectory_-AutoDiffXd" title="pydrake.trajectories.Trajectory_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Trajectory_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.trajectories.Trajectory_-Expression" title="pydrake.trajectories.Trajectory_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Trajectory_[Expression]</span></code></a></p>
<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_.Trajectory_-float">
<span id="pydrake.trajectories.Trajectory_.Trajectory_[float]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">Trajectory_[float]</span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_.Trajectory_-float" title="Permalink to this definition"></a></dt>
<dd><p>A Trajectory represents a time-varying matrix, indexed by a single
scalar time.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_.Trajectory_-float-.__init__">
<span id="pydrake.trajectories.Trajectory_.Trajectory_[float].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_.Trajectory_-float-.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_.Trajectory_-float-.cols">
<span id="pydrake.trajectories.Trajectory_.Trajectory_[float].cols"></span><span class="sig-name descname"><span class="pre">cols</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_.Trajectory_-float-.cols" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The number of columns in the matrix returned by value().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_.Trajectory_-float-.end_time">
<span id="pydrake.trajectories.Trajectory_.Trajectory_[float].end_time"></span><span class="sig-name descname"><span class="pre">end_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_.Trajectory_-float-.end_time" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_.Trajectory_-float-.EvalDerivative">
<span id="pydrake.trajectories.Trajectory_.Trajectory_[float].EvalDerivative"></span><span class="sig-name descname"><span class="pre">EvalDerivative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derivative_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_.Trajectory_-float-.EvalDerivative" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates the derivative of <code class="docutils literal notranslate"><span class="pre">this</span></code> at the given time <code class="docutils literal notranslate"><span class="pre">t</span></code>. Returns
the nth derivative, where <code class="docutils literal notranslate"><span class="pre">n</span></code> is the value of <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>derivative_order must be non-negative.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_.Trajectory_-float-.has_derivative">
<span id="pydrake.trajectories.Trajectory_.Trajectory_[float].has_derivative"></span><span class="sig-name descname"><span class="pre">has_derivative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_.Trajectory_-float-.has_derivative" title="Permalink to this definition"></a></dt>
<dd><p>Returns true iff the Trajectory provides and implementation for
EvalDerivative() and MakeDerivative(). The derivative need not be
continuous, but should return a result for all t for which value(t)
returns a result.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_.Trajectory_-float-.MakeDerivative">
<span id="pydrake.trajectories.Trajectory_.Trajectory_[float].MakeDerivative"></span><span class="sig-name descname"><span class="pre">MakeDerivative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derivative_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_.Trajectory_-float-.MakeDerivative" title="Permalink to this definition"></a></dt>
<dd><p>Takes the derivative of this Trajectory.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code>:</dt><dd><p>The number of times to take the derivative before returning.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The nth derivative of this object.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_.Trajectory_-float-.rows">
<span id="pydrake.trajectories.Trajectory_.Trajectory_[float].rows"></span><span class="sig-name descname"><span class="pre">rows</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_.Trajectory_-float-.rows" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The number of rows in the matrix returned by value().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_.Trajectory_-float-.start_time">
<span id="pydrake.trajectories.Trajectory_.Trajectory_[float].start_time"></span><span class="sig-name descname"><span class="pre">start_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_.Trajectory_-float-.start_time" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_.Trajectory_-float-.value">
<span id="pydrake.trajectories.Trajectory_.Trajectory_[float].value"></span><span class="sig-name descname"><span class="pre">value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_.Trajectory_-float-.value" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates the trajectory at the given time <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">t</span></code>:</dt><dd><p>The time at which to evaluate the trajectory.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The matrix of evaluated values.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_.Trajectory_-float-.vector_values">
<span id="pydrake.trajectories.Trajectory_.Trajectory_[float].vector_values"></span><span class="sig-name descname"><span class="pre">vector_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_.Trajectory_-float-.vector_values" title="Permalink to this definition"></a></dt>
<dd><p>If cols()==1, then evaluates the trajectory at each time <code class="docutils literal notranslate"><span class="pre">t</span></code>, and
returns the results as a Matrix with the ith column corresponding to
the ith time. Otherwise, if rows()==1, then evaluates the trajectory
at each time <code class="docutils literal notranslate"><span class="pre">t</span></code>, and returns the results as a Matrix with the ith
row corresponding to the ith time.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if both cols and rows are not equal to 1.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-AutoDiffXd">
<span id="pydrake.trajectories.Trajectory_[AutoDiffXd]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">Trajectory_[AutoDiffXd]</span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-AutoDiffXd" title="Permalink to this definition"></a></dt>
<dd><p>A Trajectory represents a time-varying matrix, indexed by a single
scalar time.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-AutoDiffXd-.__init__">
<span id="pydrake.trajectories.Trajectory_[AutoDiffXd].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-AutoDiffXd-.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-AutoDiffXd-.cols">
<span id="pydrake.trajectories.Trajectory_[AutoDiffXd].cols"></span><span class="sig-name descname"><span class="pre">cols</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-AutoDiffXd-.cols" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The number of columns in the matrix returned by value().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-AutoDiffXd-.end_time">
<span id="pydrake.trajectories.Trajectory_[AutoDiffXd].end_time"></span><span class="sig-name descname"><span class="pre">end_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-AutoDiffXd-.end_time" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-AutoDiffXd-.EvalDerivative">
<span id="pydrake.trajectories.Trajectory_[AutoDiffXd].EvalDerivative"></span><span class="sig-name descname"><span class="pre">EvalDerivative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">derivative_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-AutoDiffXd-.EvalDerivative" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates the derivative of <code class="docutils literal notranslate"><span class="pre">this</span></code> at the given time <code class="docutils literal notranslate"><span class="pre">t</span></code>. Returns
the nth derivative, where <code class="docutils literal notranslate"><span class="pre">n</span></code> is the value of <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>derivative_order must be non-negative.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-AutoDiffXd-.has_derivative">
<span id="pydrake.trajectories.Trajectory_[AutoDiffXd].has_derivative"></span><span class="sig-name descname"><span class="pre">has_derivative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-AutoDiffXd-.has_derivative" title="Permalink to this definition"></a></dt>
<dd><p>Returns true iff the Trajectory provides and implementation for
EvalDerivative() and MakeDerivative(). The derivative need not be
continuous, but should return a result for all t for which value(t)
returns a result.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-AutoDiffXd-.MakeDerivative">
<span id="pydrake.trajectories.Trajectory_[AutoDiffXd].MakeDerivative"></span><span class="sig-name descname"><span class="pre">MakeDerivative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derivative_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-AutoDiffXd-.MakeDerivative" title="Permalink to this definition"></a></dt>
<dd><p>Takes the derivative of this Trajectory.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code>:</dt><dd><p>The number of times to take the derivative before returning.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The nth derivative of this object.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-AutoDiffXd-.rows">
<span id="pydrake.trajectories.Trajectory_[AutoDiffXd].rows"></span><span class="sig-name descname"><span class="pre">rows</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-AutoDiffXd-.rows" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The number of rows in the matrix returned by value().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-AutoDiffXd-.start_time">
<span id="pydrake.trajectories.Trajectory_[AutoDiffXd].start_time"></span><span class="sig-name descname"><span class="pre">start_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-AutoDiffXd-.start_time" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-AutoDiffXd-.value">
<span id="pydrake.trajectories.Trajectory_[AutoDiffXd].value"></span><span class="sig-name descname"><span class="pre">value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-AutoDiffXd-.value" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates the trajectory at the given time <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">t</span></code>:</dt><dd><p>The time at which to evaluate the trajectory.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The matrix of evaluated values.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-AutoDiffXd-.vector_values">
<span id="pydrake.trajectories.Trajectory_[AutoDiffXd].vector_values"></span><span class="sig-name descname"><span class="pre">vector_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">AutoDiffXd</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.autodiffutils.html#pydrake.autodiffutils.AutoDiffXd" title="pydrake.autodiffutils.AutoDiffXd"><span class="pre">pydrake.autodiffutils.AutoDiffXd</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-AutoDiffXd-.vector_values" title="Permalink to this definition"></a></dt>
<dd><p>If cols()==1, then evaluates the trajectory at each time <code class="docutils literal notranslate"><span class="pre">t</span></code>, and
returns the results as a Matrix with the ith column corresponding to
the ith time. Otherwise, if rows()==1, then evaluates the trajectory
at each time <code class="docutils literal notranslate"><span class="pre">t</span></code>, and returns the results as a Matrix with the ith
row corresponding to the ith time.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if both cols and rows are not equal to 1.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-Expression">
<span id="pydrake.trajectories.Trajectory_[Expression]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">Trajectory_[Expression]</span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-Expression" title="Permalink to this definition"></a></dt>
<dd><p>A Trajectory represents a time-varying matrix, indexed by a single
scalar time.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-Expression-.__init__">
<span id="pydrake.trajectories.Trajectory_[Expression].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-Expression-.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-Expression-.cols">
<span id="pydrake.trajectories.Trajectory_[Expression].cols"></span><span class="sig-name descname"><span class="pre">cols</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-Expression-.cols" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The number of columns in the matrix returned by value().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-Expression-.end_time">
<span id="pydrake.trajectories.Trajectory_[Expression].end_time"></span><span class="sig-name descname"><span class="pre">end_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-Expression-.end_time" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-Expression-.EvalDerivative">
<span id="pydrake.trajectories.Trajectory_[Expression].EvalDerivative"></span><span class="sig-name descname"><span class="pre">EvalDerivative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">derivative_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-Expression-.EvalDerivative" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates the derivative of <code class="docutils literal notranslate"><span class="pre">this</span></code> at the given time <code class="docutils literal notranslate"><span class="pre">t</span></code>. Returns
the nth derivative, where <code class="docutils literal notranslate"><span class="pre">n</span></code> is the value of <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>derivative_order must be non-negative.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-Expression-.has_derivative">
<span id="pydrake.trajectories.Trajectory_[Expression].has_derivative"></span><span class="sig-name descname"><span class="pre">has_derivative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-Expression-.has_derivative" title="Permalink to this definition"></a></dt>
<dd><p>Returns true iff the Trajectory provides and implementation for
EvalDerivative() and MakeDerivative(). The derivative need not be
continuous, but should return a result for all t for which value(t)
returns a result.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-Expression-.MakeDerivative">
<span id="pydrake.trajectories.Trajectory_[Expression].MakeDerivative"></span><span class="sig-name descname"><span class="pre">MakeDerivative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derivative_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-Expression-.MakeDerivative" title="Permalink to this definition"></a></dt>
<dd><p>Takes the derivative of this Trajectory.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code>:</dt><dd><p>The number of times to take the derivative before returning.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The nth derivative of this object.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-Expression-.rows">
<span id="pydrake.trajectories.Trajectory_[Expression].rows"></span><span class="sig-name descname"><span class="pre">rows</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-Expression-.rows" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The number of rows in the matrix returned by value().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-Expression-.start_time">
<span id="pydrake.trajectories.Trajectory_[Expression].start_time"></span><span class="sig-name descname"><span class="pre">start_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-Expression-.start_time" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-Expression-.value">
<span id="pydrake.trajectories.Trajectory_[Expression].value"></span><span class="sig-name descname"><span class="pre">value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-Expression-.value" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates the trajectory at the given time <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">t</span></code>:</dt><dd><p>The time at which to evaluate the trajectory.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The matrix of evaluated values.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-Expression-.vector_values">
<span id="pydrake.trajectories.Trajectory_[Expression].vector_values"></span><span class="sig-name descname"><span class="pre">vector_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">Expression</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="pydrake.symbolic.html#pydrake.symbolic.Expression" title="pydrake.symbolic.Expression"><span class="pre">pydrake.symbolic.Expression</span></a><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">object</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-Expression-.vector_values" title="Permalink to this definition"></a></dt>
<dd><p>If cols()==1, then evaluates the trajectory at each time <code class="docutils literal notranslate"><span class="pre">t</span></code>, and
returns the results as a Matrix with the ith column corresponding to
the ith time. Otherwise, if rows()==1, then evaluates the trajectory
at each time <code class="docutils literal notranslate"><span class="pre">t</span></code>, and returns the results as a Matrix with the ith
row corresponding to the ith time.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if both cols and rows are not equal to 1.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-float">
<span id="pydrake.trajectories.Trajectory_[float]"></span><em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pydrake.trajectories.</span></span><span class="sig-name descname"><span class="pre">Trajectory_[float]</span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-float" title="Permalink to this definition"></a></dt>
<dd><p>A Trajectory represents a time-varying matrix, indexed by a single
scalar time.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-float-.__init__">
<span id="pydrake.trajectories.Trajectory_[float].__init__"></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-float-.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-float-.cols">
<span id="pydrake.trajectories.Trajectory_[float].cols"></span><span class="sig-name descname"><span class="pre">cols</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-float-.cols" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The number of columns in the matrix returned by value().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-float-.end_time">
<span id="pydrake.trajectories.Trajectory_[float].end_time"></span><span class="sig-name descname"><span class="pre">end_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-float-.end_time" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-float-.EvalDerivative">
<span id="pydrake.trajectories.Trajectory_[float].EvalDerivative"></span><span class="sig-name descname"><span class="pre">EvalDerivative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derivative_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-float-.EvalDerivative" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates the derivative of <code class="docutils literal notranslate"><span class="pre">this</span></code> at the given time <code class="docutils literal notranslate"><span class="pre">t</span></code>. Returns
the nth derivative, where <code class="docutils literal notranslate"><span class="pre">n</span></code> is the value of <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>derivative_order must be non-negative.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-float-.has_derivative">
<span id="pydrake.trajectories.Trajectory_[float].has_derivative"></span><span class="sig-name descname"><span class="pre">has_derivative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-float-.has_derivative" title="Permalink to this definition"></a></dt>
<dd><p>Returns true iff the Trajectory provides and implementation for
EvalDerivative() and MakeDerivative(). The derivative need not be
continuous, but should return a result for all t for which value(t)
returns a result.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-float-.MakeDerivative">
<span id="pydrake.trajectories.Trajectory_[float].MakeDerivative"></span><span class="sig-name descname"><span class="pre">MakeDerivative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derivative_order</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-float-.MakeDerivative" title="Permalink to this definition"></a></dt>
<dd><p>Takes the derivative of this Trajectory.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code>:</dt><dd><p>The number of times to take the derivative before returning.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The nth derivative of this object.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-float-.rows">
<span id="pydrake.trajectories.Trajectory_[float].rows"></span><span class="sig-name descname"><span class="pre">rows</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-float-.rows" title="Permalink to this definition"></a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The number of rows in the matrix returned by value().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-float-.start_time">
<span id="pydrake.trajectories.Trajectory_[float].start_time"></span><span class="sig-name descname"><span class="pre">start_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">float</span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-float-.start_time" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-float-.value">
<span id="pydrake.trajectories.Trajectory_[float].value"></span><span class="sig-name descname"><span class="pre">value</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-float-.value" title="Permalink to this definition"></a></dt>
<dd><p>Evaluates the trajectory at the given time <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">t</span></code>:</dt><dd><p>The time at which to evaluate the trajectory.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The matrix of evaluated values.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pydrake.trajectories.Trajectory_-float-.vector_values">
<span id="pydrake.trajectories.Trajectory_[float].vector_values"></span><span class="sig-name descname"><span class="pre">vector_values</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#pydrake.trajectories.Trajectory_" title="pydrake.trajectories.Trajectory_"><span class="pre">pydrake.trajectories.Trajectory_</span></a><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><span class="pre">float</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.float64</span><span class="p"><span class="pre">[</span></span><span class="pre">m</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">n</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#pydrake.trajectories.Trajectory_-float-.vector_values" title="Permalink to this definition"></a></dt>
<dd><p>If cols()==1, then evaluates the trajectory at each time <code class="docutils literal notranslate"><span class="pre">t</span></code>, and
returns the results as a Matrix with the ith column corresponding to
the ith time. Otherwise, if rows()==1, then evaluates the trajectory
at each time <code class="docutils literal notranslate"><span class="pre">t</span></code>, and returns the results as a Matrix with the ith
row corresponding to the ith time.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>RuntimeError if both cols and rows are not equal to 1.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="pydrake.systems.trajectory_optimization.html" class="btn btn-neutral float-left" title="pydrake.systems.trajectory_optimization" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="pydrake.tutorials.html" class="btn btn-neutral float-right" title="pydrake.tutorials" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p></p>
  </div>

  
</footer>
<script>
  /* Enables clicking for the mobile "hamburger" (three-line) menu item. */
  const siteHeader = document.querySelector('.site-header')
  const mobileButton = document.querySelector('.menu-mobile-toggle')
  const body = document.querySelector('body')

  mobileButton.addEventListener('click', function(event) {
    siteHeader.classList.toggle('open');
    body.classList.toggle('overflow-hidden');
  })
</script>
<footer class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg">
    </a>
    <div class="footer-menu">
      <ul>
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"></a>
        </li>
      </ul>
    </div>
  </div>


</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>