<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pydrake.trajectories &mdash; pydrake  documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=86f27845" />
      <link rel="stylesheet" type="text/css" href="_static/css/custom.css?v=6b576c25" />

  
  
        <script src="_static/jquery.js?v=8dae8fb0"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=7f41d439"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="pydrake.tutorials" href="pydrake.tutorials.html" />
    <link rel="prev" title="pydrake.systems.sensors" href="pydrake.systems.sensors.html" /> 
</head>

<body class="wy-body-for-nav">
<header class="site-header">
  <div class="site-header-inner contain">
    <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
    <div class="menu-mobile-toggle">
      <span></span>
    </div>
    <nav class="site-menu">
      <ul>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/">Home</a>
        </li>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/installation.html">Installation</a>
        </li>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/gallery.html">Gallery</a>
        </li>
        <li class="site-menu-item site-menu-item-main">API Documentation
          <div class="sub">
            <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a> <a class="site-menu-item" href="/pydrake/index.html">Python</a>
          </div>
        </li>
        <li class="site-menu-item site-menu-item-main">Resources
          <div class="sub">
            <a class="site-menu-item" href="/getting_help.html">Getting Help</a> <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/notebook/index-753e3c9d261247ba9f0eb1d7868c18c8">Tutorials</a> <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a> <a class="site-menu-item" href="/developers.html">For Developers</a> <a class="site-menu-item" href="/credits.html">Credits</a>
          </div>
        </li>
        <li class="github-link">
          <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
        </li>
      </ul>
    </nav>
  </div>
</header>

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            pydrake
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search pydrake only…" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
    <input type="text" name="q" placeholder="Search all of Drake…" />
    <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu" />
  </form>
</div>

        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="pydrake.all.html">pydrake.all</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.autodiffutils.html">pydrake.autodiffutils</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.common.html">pydrake.common</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.examples.html">pydrake.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.forwarddiff.html">pydrake.forwarddiff</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.geometry.html">pydrake.geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.gym.html">pydrake.gym</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.lcm.html">pydrake.lcm</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.manipulation.html">pydrake.manipulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.math.html">pydrake.math</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.multibody.html">pydrake.multibody</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.perception.html">pydrake.perception</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.planning.html">pydrake.planning</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.polynomial.html">pydrake.polynomial</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.html">pydrake.solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.symbolic.html">pydrake.symbolic</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.systems.html">pydrake.systems</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">pydrake.trajectories</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.tutorials.html">pydrake.tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.visualization.html">pydrake.visualization</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pydrake</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">pydrake.trajectories</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-pydrake.trajectories">
<span id="pydrake-trajectories"></span><h1>pydrake.trajectories<a class="headerlink" href="#module-pydrake.trajectories" title="Link to this heading"></a></h1>
<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BezierCurve</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory</span></code></p>
<p>A Bézier curve is defined by a set of control points p₀ through pₙ,
where n is called the order of the curve (n = 1 for linear, 2 for
quadratic, 3 for cubic, etc.). The first and last control points are
always the endpoints of the curve; however, the intermediate control
points (if any) generally do not lie on the curve, but the curve is
guaranteed to stay within the convex hull of the control points.</p>
<p>See also BsplineTrajectory. A B-spline can be thought of as a
composition of overlapping Bézier curves (where each evaluation only
depends on a local subset of the control points). In contrast,
evaluating a Bézier curve will use all of the control points.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">BezierCurve_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BezierCurve.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.BezierCurve) -&gt; None</p></li>
</ol>
<p>Default initializer. Constructs an empty Bézier curve over the
interval t ∈ [0, 1].</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.trajectories.BezierCurve, start_time: float, end_time: float, control_points: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]) -&gt; None</p></li>
</ol>
<p>Constructs a Bézier curve over the interval t ∈ [<cite>start_time</cite>,
<code class="docutils literal notranslate"><span class="pre">end_time`]</span> <span class="pre">with</span> <span class="pre">control</span> <span class="pre">points</span> <span class="pre">defined</span> <span class="pre">in</span> <span class="pre">the</span> <span class="pre">columns</span> <span class="pre">of</span>
<span class="pre">`control_points</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>end_time &gt;= start_time.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BezierCurve.AsLinearInControlPoints(self:</span> <span class="pre">pydrake.trajectories.BezierCurve,</span> <span class="pre">derivative_order:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">1)</span> <span class="pre">-&gt;</span> <span class="pre">scipy.sparse.csc_matrix[numpy.float64]</span></span></dt>
<dd><p>Supports writing optimizations using the control points as decision
variables. This method returns the matrix, <code class="docutils literal notranslate"><span class="pre">M</span></code>, defining the control
points of the <code class="docutils literal notranslate"><span class="pre">order</span></code> derivative in the form:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">derivative</span><span class="p">.</span><span class="n">control_points</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">control_points</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">M</span>
</pre></div>
</div>
</details><p>For instance, since we have</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">derivative</span><span class="p">.</span><span class="n">control_points</span><span class="p">().</span><span class="n">col</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">control_points</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">M</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="n">k</span><span class="p">),</span>
</pre></div>
</div>
</details><p>constraining the kth control point of the <a href="#id1"><span class="problematic" id="id2">`</span></a>n`th derivative to be in
[ub, lb], could be done with:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">M</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">curve</span><span class="p">.</span><span class="n">AsLinearInControlPoints</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">curve</span><span class="p">.</span><span class="n">rows</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="n">prog</span><span class="p">.</span><span class="n">AddLinearConstraint</span><span class="p">(</span><span class="n">M</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">transpose</span><span class="p">(),</span>
<span class="n">Vector1d</span><span class="p">(</span><span class="n">lb</span><span class="p">(</span><span class="n">i</span><span class="p">)),</span>
<span class="n">Vector1d</span><span class="p">(</span><span class="n">ub</span><span class="p">(</span><span class="n">i</span><span class="p">)),</span>
<span class="n">curve</span><span class="p">.</span><span class="n">row</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">transpose</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
</details><p>Iterating over the rows of the control points is the natural sparsity
pattern here (since <code class="docutils literal notranslate"><span class="pre">M</span></code> is the same for all rows). For instance, we
also have</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">derivative</span><span class="p">.</span><span class="n">control_points</span><span class="p">().</span><span class="n">row</span><span class="p">(</span><span class="n">k</span><span class="p">).</span><span class="n">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">M</span><span class="p">.</span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">control_points</span><span class="p">().</span><span class="n">row</span><span class="p">(</span><span class="n">k</span><span class="p">).</span><span class="n">T</span><span class="p">,</span>
</pre></div>
</div>
</details><p>or</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">vec</span><span class="p">(</span><span class="n">derivative</span><span class="p">.</span><span class="n">control_points</span><span class="p">().</span><span class="n">T</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">blockMT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">vec</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">control_points</span><span class="p">().</span><span class="n">T</span><span class="p">),</span>
<span class="n">blockMT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="n">M</span><span class="p">.</span><span class="n">T</span><span class="p">,</span><span class="w">   </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">....</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">]</span>
<span class="p">[</span><span class="w">   </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="p">.</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">]</span>
<span class="p">[</span><span class="w">      </span><span class="p">...</span><span class="w">         </span><span class="p">]</span>
<span class="p">[</span><span class="w">  </span><span class="p">...</span><span class="w">    </span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">M</span><span class="p">.</span><span class="n">T</span><span class="w"> </span><span class="p">].</span>
</pre></div>
</div>
</details><dl class="simple">
<dt>Precondition:</dt><dd><p>derivative_order &gt;= 0.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BezierCurve.BernsteinBasis(self:</span> <span class="pre">pydrake.trajectories.BezierCurve,</span> <span class="pre">i:</span> <span class="pre">int,</span> <span class="pre">time:</span> <span class="pre">float,</span> <span class="pre">order:</span> <span class="pre">Optional[int]</span> <span class="pre">=</span> <span class="pre">None)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the value of the ith basis function of <code class="docutils literal notranslate"><span class="pre">order</span></code> (1 for
linear, 2 for quadratic, etc) evaluated at <code class="docutils literal notranslate"><span class="pre">time</span></code>. The default value
for the optional argument <code class="docutils literal notranslate"><span class="pre">order</span></code> is the <code class="docutils literal notranslate"><span class="pre">order()</span></code> of <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BezierCurve.control_points(self:</span> <span class="pre">pydrake.trajectories.BezierCurve)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>Returns a const reference to the control points which define the
curve.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BezierCurve.ElevateOrder(self:</span> <span class="pre">pydrake.trajectories.BezierCurve)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Increases the order of the curve by 1. A Bézier curve of order n can
be converted into a Bézier curve of order n + 1 with the same shape.
The control points of <code class="docutils literal notranslate"><span class="pre">this</span></code> are modified to obtain the equivalent
curve.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BezierCurve.GetExpression(self:</span> <span class="pre">pydrake.trajectories.BezierCurve,</span> <span class="pre">time:</span> <span class="pre">pydrake.symbolic.Variable</span> <span class="pre">=</span> <span class="pre">Variable('t',</span> <span class="pre">Continuous))</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Extracts the expanded underlying polynomial expression of this curve
in terms of variable <code class="docutils literal notranslate"><span class="pre">time</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BezierCurve.order(self:</span> <span class="pre">pydrake.trajectories.BezierCurve)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the order of the curve (1 for linear, 2 for quadratic, etc.).</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BezierCurve_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">BezierCurve_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">BezierCurve_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">BezierCurve_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BezierCurve_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[AutoDiffXd]</span></code></p>
<p>A Bézier curve is defined by a set of control points p₀ through pₙ,
where n is called the order of the curve (n = 1 for linear, 2 for
quadratic, 3 for cubic, etc.). The first and last control points are
always the endpoints of the curve; however, the intermediate control
points (if any) generally do not lie on the curve, but the curve is
guaranteed to stay within the convex hull of the control points.</p>
<p>See also BsplineTrajectory. A B-spline can be thought of as a
composition of overlapping Bézier curves (where each evaluation only
depends on a local subset of the control points). In contrast,
evaluating a Bézier curve will use all of the control points.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BezierCurve_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.BezierCurve_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Default initializer. Constructs an empty Bézier curve over the
interval t ∈ [0, 1].</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.trajectories.BezierCurve_[AutoDiffXd], start_time: float, end_time: float, control_points: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; None</p></li>
</ol>
<p>Constructs a Bézier curve over the interval t ∈ [<cite>start_time</cite>,
<code class="docutils literal notranslate"><span class="pre">end_time`]</span> <span class="pre">with</span> <span class="pre">control</span> <span class="pre">points</span> <span class="pre">defined</span> <span class="pre">in</span> <span class="pre">the</span> <span class="pre">columns</span> <span class="pre">of</span>
<span class="pre">`control_points</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>end_time &gt;= start_time.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BezierCurve_[AutoDiffXd].BernsteinBasis(self:</span> <span class="pre">pydrake.trajectories.BezierCurve_[AutoDiffXd],</span> <span class="pre">i:</span> <span class="pre">int,</span> <span class="pre">time:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">order:</span> <span class="pre">Optional[int]</span> <span class="pre">=</span> <span class="pre">None)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd</span></span></dt>
<dd><p>Returns the value of the ith basis function of <code class="docutils literal notranslate"><span class="pre">order</span></code> (1 for
linear, 2 for quadratic, etc) evaluated at <code class="docutils literal notranslate"><span class="pre">time</span></code>. The default value
for the optional argument <code class="docutils literal notranslate"><span class="pre">order</span></code> is the <code class="docutils literal notranslate"><span class="pre">order()</span></code> of <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BezierCurve_[AutoDiffXd].control_points(self:</span> <span class="pre">pydrake.trajectories.BezierCurve_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>Returns a const reference to the control points which define the
curve.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BezierCurve_[AutoDiffXd].ElevateOrder(self:</span> <span class="pre">pydrake.trajectories.BezierCurve_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Increases the order of the curve by 1. A Bézier curve of order n can
be converted into a Bézier curve of order n + 1 with the same shape.
The control points of <code class="docutils literal notranslate"><span class="pre">this</span></code> are modified to obtain the equivalent
curve.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BezierCurve_[AutoDiffXd].GetExpression(self:</span> <span class="pre">pydrake.trajectories.BezierCurve_[AutoDiffXd],</span> <span class="pre">time:</span> <span class="pre">pydrake.symbolic.Variable</span> <span class="pre">=</span> <span class="pre">Variable('t',</span> <span class="pre">Continuous))</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Extracts the expanded underlying polynomial expression of this curve
in terms of variable <code class="docutils literal notranslate"><span class="pre">time</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BezierCurve_[AutoDiffXd].order(self:</span> <span class="pre">pydrake.trajectories.BezierCurve_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the order of the curve (1 for linear, 2 for quadratic, etc.).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BezierCurve_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[Expression]</span></code></p>
<p>A Bézier curve is defined by a set of control points p₀ through pₙ,
where n is called the order of the curve (n = 1 for linear, 2 for
quadratic, 3 for cubic, etc.). The first and last control points are
always the endpoints of the curve; however, the intermediate control
points (if any) generally do not lie on the curve, but the curve is
guaranteed to stay within the convex hull of the control points.</p>
<p>See also BsplineTrajectory. A B-spline can be thought of as a
composition of overlapping Bézier curves (where each evaluation only
depends on a local subset of the control points). In contrast,
evaluating a Bézier curve will use all of the control points.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BezierCurve_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.BezierCurve_[Expression]) -&gt; None</p></li>
</ol>
<p>Default initializer. Constructs an empty Bézier curve over the
interval t ∈ [0, 1].</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.trajectories.BezierCurve_[Expression], start_time: float, end_time: float, control_points: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; None</p></li>
</ol>
<p>Constructs a Bézier curve over the interval t ∈ [<cite>start_time</cite>,
<code class="docutils literal notranslate"><span class="pre">end_time`]</span> <span class="pre">with</span> <span class="pre">control</span> <span class="pre">points</span> <span class="pre">defined</span> <span class="pre">in</span> <span class="pre">the</span> <span class="pre">columns</span> <span class="pre">of</span>
<span class="pre">`control_points</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>end_time &gt;= start_time.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BezierCurve_[Expression].BernsteinBasis(self:</span> <span class="pre">pydrake.trajectories.BezierCurve_[Expression],</span> <span class="pre">i:</span> <span class="pre">int,</span> <span class="pre">time:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">order:</span> <span class="pre">Optional[int]</span> <span class="pre">=</span> <span class="pre">None)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd><p>Returns the value of the ith basis function of <code class="docutils literal notranslate"><span class="pre">order</span></code> (1 for
linear, 2 for quadratic, etc) evaluated at <code class="docutils literal notranslate"><span class="pre">time</span></code>. The default value
for the optional argument <code class="docutils literal notranslate"><span class="pre">order</span></code> is the <code class="docutils literal notranslate"><span class="pre">order()</span></code> of <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BezierCurve_[Expression].control_points(self:</span> <span class="pre">pydrake.trajectories.BezierCurve_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>Returns a const reference to the control points which define the
curve.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BezierCurve_[Expression].ElevateOrder(self:</span> <span class="pre">pydrake.trajectories.BezierCurve_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Increases the order of the curve by 1. A Bézier curve of order n can
be converted into a Bézier curve of order n + 1 with the same shape.
The control points of <code class="docutils literal notranslate"><span class="pre">this</span></code> are modified to obtain the equivalent
curve.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BezierCurve_[Expression].GetExpression(self:</span> <span class="pre">pydrake.trajectories.BezierCurve_[Expression],</span> <span class="pre">time:</span> <span class="pre">pydrake.symbolic.Variable</span> <span class="pre">=</span> <span class="pre">Variable('t',</span> <span class="pre">Continuous))</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Extracts the expanded underlying polynomial expression of this curve
in terms of variable <code class="docutils literal notranslate"><span class="pre">time</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BezierCurve_[Expression].order(self:</span> <span class="pre">pydrake.trajectories.BezierCurve_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the order of the curve (1 for linear, 2 for quadratic, etc.).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BsplineTrajectory</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory</span></code></p>
<p>Represents a B-spline curve using a given <code class="docutils literal notranslate"><span class="pre">basis</span></code> with ordered
<code class="docutils literal notranslate"><span class="pre">control_points</span></code> such that each control point is a matrix in ℝʳᵒʷˢ ˣ
ᶜᵒˡˢ.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>math::BsplineBasis</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">BsplineTrajectory_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BsplineTrajectory.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.BsplineTrajectory) -&gt; None</p></li>
<li><p>__init__(self: pydrake.trajectories.BsplineTrajectory, basis: pydrake.math.BsplineBasis, control_points: list[list[float]]) -&gt; None</p></li>
</ol>
<p>Constructs a B-spline trajectory with the given <code class="docutils literal notranslate"><span class="pre">basis</span></code> and
<code class="docutils literal notranslate"><span class="pre">control_points</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>control_points.size() == basis.num_basis_functions()</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.trajectories.BsplineTrajectory, basis: pydrake.math.BsplineBasis, control_points: list[numpy.ndarray[numpy.float64[m, n]]]) -&gt; None</p></li>
</ol>
<p>Constructs a B-spline trajectory with the given <code class="docutils literal notranslate"><span class="pre">basis</span></code> and
<code class="docutils literal notranslate"><span class="pre">control_points</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>control_points.size() == basis.num_basis_functions()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BsplineTrajectory.AsLinearInControlPoints(self:</span> <span class="pre">pydrake.trajectories.BsplineTrajectory,</span> <span class="pre">derivative_order:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">1)</span> <span class="pre">-&gt;</span> <span class="pre">scipy.sparse.csc_matrix[numpy.float64]</span></span></dt>
<dd><p>Supports writing optimizations using the control points as decision
variables. This method returns the matrix, <code class="docutils literal notranslate"><span class="pre">M</span></code>, defining the control
points of the <code class="docutils literal notranslate"><span class="pre">order</span></code> derivative in the form:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">derivative</span><span class="p">.</span><span class="n">control_points</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="n">control_points</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">M</span>
</pre></div>
</div>
</details><p>See <code class="docutils literal notranslate"><span class="pre">BezierCurve::AsLinearInControlPoints()</span></code> for more details.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>derivative_order &gt;= 0.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BsplineTrajectory.basis(self:</span> <span class="pre">pydrake.trajectories.BsplineTrajectory)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.BsplineBasis</span></span></dt>
<dd><p>Returns the basis of this curve.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BsplineTrajectory.control_points(self:</span> <span class="pre">pydrake.trajectories.BsplineTrajectory)</span> <span class="pre">-&gt;</span> <span class="pre">list[numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]]</span></span></dt>
<dd><p>Returns the control points of this curve.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BsplineTrajectory.CopyBlock(self:</span> <span class="pre">pydrake.trajectories.BsplineTrajectory,</span> <span class="pre">start_row:</span> <span class="pre">int,</span> <span class="pre">start_col:</span> <span class="pre">int,</span> <span class="pre">block_rows:</span> <span class="pre">int,</span> <span class="pre">block_cols:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.BsplineTrajectory</span></span></dt>
<dd><p>Returns a new BsplineTrajectory that uses the same basis as <code class="docutils literal notranslate"><span class="pre">this</span></code>,
and whose control points are the result of calling
<code class="docutils literal notranslate"><span class="pre">point.block(start_row,</span> <span class="pre">start_col,</span> <span class="pre">block_rows,</span> <span class="pre">block_cols)</span></code> on each
<code class="docutils literal notranslate"><span class="pre">point</span></code> in <code class="docutils literal notranslate"><span class="pre">this-&gt;control_points()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BsplineTrajectory.CopyHead(self:</span> <span class="pre">pydrake.trajectories.BsplineTrajectory,</span> <span class="pre">n:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.BsplineTrajectory</span></span></dt>
<dd><p>Returns a new BsplineTrajectory that uses the same basis as <code class="docutils literal notranslate"><span class="pre">this</span></code>,
and whose control points are the result of calling <code class="docutils literal notranslate"><span class="pre">point.head(n)</span></code>
on each <code class="docutils literal notranslate"><span class="pre">point</span></code> in <code class="docutils literal notranslate"><span class="pre">this-&gt;control_points()</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>this-&gt;cols() == 1</p>
</dd>
<dt>Precondition:</dt><dd><p>control_points()[0].head(n) must be a valid operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BsplineTrajectory.EvaluateLinearInControlPoints(self:</span> <span class="pre">pydrake.trajectories.BsplineTrajectory,</span> <span class="pre">parameter_value:</span> <span class="pre">float,</span> <span class="pre">derivative_order:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the vector, M, such that</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EvalDerivative</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">derivative_order</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">control_points</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">M</span>
</pre></div>
</div>
</details><p>where cols()==1 (so control_points() is a matrix). This is useful for
writing linear constraints on the control points. Note that if the
derivative order is greater than or equal to the order of the basis,
then the result is a zero vector.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>t ≥ start_time()</p>
</dd>
<dt>Precondition:</dt><dd><p>t ≤ end_time()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BsplineTrajectory.FinalValue(self:</span> <span class="pre">pydrake.trajectories.BsplineTrajectory)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>Returns this-&gt;value(this-&gt;end_time())</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BsplineTrajectory.InitialValue(self:</span> <span class="pre">pydrake.trajectories.BsplineTrajectory)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>Returns this-&gt;value(this-&gt;start_time())</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BsplineTrajectory.InsertKnots(self:</span> <span class="pre">pydrake.trajectories.BsplineTrajectory,</span> <span class="pre">additional_knots:</span> <span class="pre">list[float])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Adds new knots at the specified <code class="docutils literal notranslate"><span class="pre">additional_knots</span></code> without changing
the behavior of the trajectory. The basis and control points of the
trajectory are adjusted such that it produces the same value for any
valid time before and after this method is called. The resulting
trajectory is guaranteed to have the same level of continuity as the
original, even if knot values are duplicated. Note that
<code class="docutils literal notranslate"><span class="pre">additional_knots</span></code> need not be sorted.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>start_time() &lt;= t &lt;= end_time() for all t in <code class="docutils literal notranslate"><span class="pre">additional_knots</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BsplineTrajectory.num_control_points(self:</span> <span class="pre">pydrake.trajectories.BsplineTrajectory)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of control points in this curve.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BsplineTrajectory_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">BsplineTrajectory_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">BsplineTrajectory_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">BsplineTrajectory_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BsplineTrajectory_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[AutoDiffXd]</span></code></p>
<p>Represents a B-spline curve using a given <code class="docutils literal notranslate"><span class="pre">basis</span></code> with ordered
<code class="docutils literal notranslate"><span class="pre">control_points</span></code> such that each control point is a matrix in ℝʳᵒʷˢ ˣ
ᶜᵒˡˢ.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>math::BsplineBasis</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BsplineTrajectory_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.BsplineTrajectory_[AutoDiffXd]) -&gt; None</p></li>
<li><p>__init__(self: pydrake.trajectories.BsplineTrajectory_[AutoDiffXd], basis: pydrake.math.BsplineBasis_[AutoDiffXd], control_points: list[list[pydrake.autodiffutils.AutoDiffXd]]) -&gt; None</p></li>
</ol>
<p>Constructs a B-spline trajectory with the given <code class="docutils literal notranslate"><span class="pre">basis</span></code> and
<code class="docutils literal notranslate"><span class="pre">control_points</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>control_points.size() == basis.num_basis_functions()</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.trajectories.BsplineTrajectory_[AutoDiffXd], basis: pydrake.math.BsplineBasis_[AutoDiffXd], control_points: list[numpy.ndarray[object[m, n]]]) -&gt; None</p></li>
</ol>
<p>Constructs a B-spline trajectory with the given <code class="docutils literal notranslate"><span class="pre">basis</span></code> and
<code class="docutils literal notranslate"><span class="pre">control_points</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>control_points.size() == basis.num_basis_functions()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BsplineTrajectory_[AutoDiffXd].basis(self:</span> <span class="pre">pydrake.trajectories.BsplineTrajectory_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.BsplineBasis_[AutoDiffXd]</span></span></dt>
<dd><p>Returns the basis of this curve.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BsplineTrajectory_[AutoDiffXd].control_points(self:</span> <span class="pre">pydrake.trajectories.BsplineTrajectory_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">list[numpy.ndarray[object[m,</span> <span class="pre">n]]]</span></span></dt>
<dd><p>Returns the control points of this curve.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BsplineTrajectory_[AutoDiffXd].CopyBlock(self:</span> <span class="pre">pydrake.trajectories.BsplineTrajectory_[AutoDiffXd],</span> <span class="pre">start_row:</span> <span class="pre">int,</span> <span class="pre">start_col:</span> <span class="pre">int,</span> <span class="pre">block_rows:</span> <span class="pre">int,</span> <span class="pre">block_cols:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.BsplineTrajectory_[AutoDiffXd]</span></span></dt>
<dd><p>Returns a new BsplineTrajectory that uses the same basis as <code class="docutils literal notranslate"><span class="pre">this</span></code>,
and whose control points are the result of calling
<code class="docutils literal notranslate"><span class="pre">point.block(start_row,</span> <span class="pre">start_col,</span> <span class="pre">block_rows,</span> <span class="pre">block_cols)</span></code> on each
<code class="docutils literal notranslate"><span class="pre">point</span></code> in <code class="docutils literal notranslate"><span class="pre">this-&gt;control_points()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BsplineTrajectory_[AutoDiffXd].CopyHead(self:</span> <span class="pre">pydrake.trajectories.BsplineTrajectory_[AutoDiffXd],</span> <span class="pre">n:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.BsplineTrajectory_[AutoDiffXd]</span></span></dt>
<dd><p>Returns a new BsplineTrajectory that uses the same basis as <code class="docutils literal notranslate"><span class="pre">this</span></code>,
and whose control points are the result of calling <code class="docutils literal notranslate"><span class="pre">point.head(n)</span></code>
on each <code class="docutils literal notranslate"><span class="pre">point</span></code> in <code class="docutils literal notranslate"><span class="pre">this-&gt;control_points()</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>this-&gt;cols() == 1</p>
</dd>
<dt>Precondition:</dt><dd><p>control_points()[0].head(n) must be a valid operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BsplineTrajectory_[AutoDiffXd].EvaluateLinearInControlPoints(self:</span> <span class="pre">pydrake.trajectories.BsplineTrajectory_[AutoDiffXd],</span> <span class="pre">parameter_value:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">derivative_order:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the vector, M, such that</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EvalDerivative</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">derivative_order</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">control_points</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">M</span>
</pre></div>
</div>
</details><p>where cols()==1 (so control_points() is a matrix). This is useful for
writing linear constraints on the control points. Note that if the
derivative order is greater than or equal to the order of the basis,
then the result is a zero vector.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>t ≥ start_time()</p>
</dd>
<dt>Precondition:</dt><dd><p>t ≤ end_time()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BsplineTrajectory_[AutoDiffXd].FinalValue(self:</span> <span class="pre">pydrake.trajectories.BsplineTrajectory_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>Returns this-&gt;value(this-&gt;end_time())</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BsplineTrajectory_[AutoDiffXd].InitialValue(self:</span> <span class="pre">pydrake.trajectories.BsplineTrajectory_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>Returns this-&gt;value(this-&gt;start_time())</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BsplineTrajectory_[AutoDiffXd].InsertKnots(self:</span> <span class="pre">pydrake.trajectories.BsplineTrajectory_[AutoDiffXd],</span> <span class="pre">additional_knots:</span> <span class="pre">list[pydrake.autodiffutils.AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Adds new knots at the specified <code class="docutils literal notranslate"><span class="pre">additional_knots</span></code> without changing
the behavior of the trajectory. The basis and control points of the
trajectory are adjusted such that it produces the same value for any
valid time before and after this method is called. The resulting
trajectory is guaranteed to have the same level of continuity as the
original, even if knot values are duplicated. Note that
<code class="docutils literal notranslate"><span class="pre">additional_knots</span></code> need not be sorted.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>start_time() &lt;= t &lt;= end_time() for all t in <code class="docutils literal notranslate"><span class="pre">additional_knots</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BsplineTrajectory_[AutoDiffXd].num_control_points(self:</span> <span class="pre">pydrake.trajectories.BsplineTrajectory_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of control points in this curve.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BsplineTrajectory_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[Expression]</span></code></p>
<p>Represents a B-spline curve using a given <code class="docutils literal notranslate"><span class="pre">basis</span></code> with ordered
<code class="docutils literal notranslate"><span class="pre">control_points</span></code> such that each control point is a matrix in ℝʳᵒʷˢ ˣ
ᶜᵒˡˢ.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>math::BsplineBasis</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BsplineTrajectory_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.BsplineTrajectory_[Expression]) -&gt; None</p></li>
<li><p>__init__(self: pydrake.trajectories.BsplineTrajectory_[Expression], basis: pydrake.math.BsplineBasis_[Expression], control_points: list[list[pydrake.symbolic.Expression]]) -&gt; None</p></li>
</ol>
<p>Constructs a B-spline trajectory with the given <code class="docutils literal notranslate"><span class="pre">basis</span></code> and
<code class="docutils literal notranslate"><span class="pre">control_points</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>control_points.size() == basis.num_basis_functions()</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.trajectories.BsplineTrajectory_[Expression], basis: pydrake.math.BsplineBasis_[Expression], control_points: list[numpy.ndarray[object[m, n]]]) -&gt; None</p></li>
</ol>
<p>Constructs a B-spline trajectory with the given <code class="docutils literal notranslate"><span class="pre">basis</span></code> and
<code class="docutils literal notranslate"><span class="pre">control_points</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>control_points.size() == basis.num_basis_functions()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BsplineTrajectory_[Expression].basis(self:</span> <span class="pre">pydrake.trajectories.BsplineTrajectory_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.BsplineBasis_[Expression]</span></span></dt>
<dd><p>Returns the basis of this curve.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BsplineTrajectory_[Expression].control_points(self:</span> <span class="pre">pydrake.trajectories.BsplineTrajectory_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">list[numpy.ndarray[object[m,</span> <span class="pre">n]]]</span></span></dt>
<dd><p>Returns the control points of this curve.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BsplineTrajectory_[Expression].CopyBlock(self:</span> <span class="pre">pydrake.trajectories.BsplineTrajectory_[Expression],</span> <span class="pre">start_row:</span> <span class="pre">int,</span> <span class="pre">start_col:</span> <span class="pre">int,</span> <span class="pre">block_rows:</span> <span class="pre">int,</span> <span class="pre">block_cols:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.BsplineTrajectory_[Expression]</span></span></dt>
<dd><p>Returns a new BsplineTrajectory that uses the same basis as <code class="docutils literal notranslate"><span class="pre">this</span></code>,
and whose control points are the result of calling
<code class="docutils literal notranslate"><span class="pre">point.block(start_row,</span> <span class="pre">start_col,</span> <span class="pre">block_rows,</span> <span class="pre">block_cols)</span></code> on each
<code class="docutils literal notranslate"><span class="pre">point</span></code> in <code class="docutils literal notranslate"><span class="pre">this-&gt;control_points()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BsplineTrajectory_[Expression].CopyHead(self:</span> <span class="pre">pydrake.trajectories.BsplineTrajectory_[Expression],</span> <span class="pre">n:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.BsplineTrajectory_[Expression]</span></span></dt>
<dd><p>Returns a new BsplineTrajectory that uses the same basis as <code class="docutils literal notranslate"><span class="pre">this</span></code>,
and whose control points are the result of calling <code class="docutils literal notranslate"><span class="pre">point.head(n)</span></code>
on each <code class="docutils literal notranslate"><span class="pre">point</span></code> in <code class="docutils literal notranslate"><span class="pre">this-&gt;control_points()</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>this-&gt;cols() == 1</p>
</dd>
<dt>Precondition:</dt><dd><p>control_points()[0].head(n) must be a valid operation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BsplineTrajectory_[Expression].EvaluateLinearInControlPoints(self:</span> <span class="pre">pydrake.trajectories.BsplineTrajectory_[Expression],</span> <span class="pre">parameter_value:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">derivative_order:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the vector, M, such that</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">EvalDerivative</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">derivative_order</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">control_points</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">M</span>
</pre></div>
</div>
</details><p>where cols()==1 (so control_points() is a matrix). This is useful for
writing linear constraints on the control points. Note that if the
derivative order is greater than or equal to the order of the basis,
then the result is a zero vector.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>t ≥ start_time()</p>
</dd>
<dt>Precondition:</dt><dd><p>t ≤ end_time()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BsplineTrajectory_[Expression].FinalValue(self:</span> <span class="pre">pydrake.trajectories.BsplineTrajectory_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>Returns this-&gt;value(this-&gt;end_time())</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BsplineTrajectory_[Expression].InitialValue(self:</span> <span class="pre">pydrake.trajectories.BsplineTrajectory_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>Returns this-&gt;value(this-&gt;start_time())</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BsplineTrajectory_[Expression].InsertKnots(self:</span> <span class="pre">pydrake.trajectories.BsplineTrajectory_[Expression],</span> <span class="pre">additional_knots:</span> <span class="pre">list[pydrake.symbolic.Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Adds new knots at the specified <code class="docutils literal notranslate"><span class="pre">additional_knots</span></code> without changing
the behavior of the trajectory. The basis and control points of the
trajectory are adjusted such that it produces the same value for any
valid time before and after this method is called. The resulting
trajectory is guaranteed to have the same level of continuity as the
original, even if knot values are duplicated. Note that
<code class="docutils literal notranslate"><span class="pre">additional_knots</span></code> need not be sorted.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>start_time() &lt;= t &lt;= end_time() for all t in <code class="docutils literal notranslate"><span class="pre">additional_knots</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BsplineTrajectory_[Expression].num_control_points(self:</span> <span class="pre">pydrake.trajectories.BsplineTrajectory_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of control points in this curve.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CompositeTrajectory</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PiecewiseTrajectory</span></code></p>
<p>A “composite trajectory” is a series of trajectories joined end to end
where the end time of one trajectory coincides with the starting time
of the next.</p>
<p>See also PiecewisePolynomial::ConcatenateInTime(), which might be
preferred if all of the segments are PiecewisePolynomial.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">CompositeTrajectory_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CompositeTrajectory.__init__(self:</span> <span class="pre">pydrake.trajectories.CompositeTrajectory,</span> <span class="pre">segments:</span> <span class="pre">list[pydrake.trajectories.Trajectory])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a composite trajectory from a list of Trajectories.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>∀i, <code class="docutils literal notranslate"><span class="pre">segments[i].get()</span> <span class="pre">!=</span> <span class="pre">nullptr</span></code>.</p>
</dd>
<dt>Precondition:</dt><dd><p>∀i, <code class="docutils literal notranslate"><span class="pre">segments[i+1].start_time()</span> <span class="pre">==</span> <span class="pre">segments[i].end_time()</span></code>.</p>
</dd>
<dt>Precondition:</dt><dd><p>∀i, <code class="docutils literal notranslate"><span class="pre">segments[i].rows()</span> <span class="pre">==</span> <span class="pre">segments[0].rows()</span></code> and
segments[i].cols() == segments[0].cols()`.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CompositeTrajectory.AlignAndConcatenate(segments:</span> <span class="pre">list[pydrake.trajectories.Trajectory])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.CompositeTrajectory</span></span></dt>
<dd><p>Constructs a composite trajectory from a list of trajectories whose
start and end times may not coincide, by translating their start and
end times.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>∀i, <code class="docutils literal notranslate"><span class="pre">segments[i].get()</span> <span class="pre">!=</span> <span class="pre">nullptr</span></code>.</p>
</dd>
<dt>Precondition:</dt><dd><p>∀i, <code class="docutils literal notranslate"><span class="pre">segments[i].rows()</span> <span class="pre">==</span> <span class="pre">segments[0].rows()</span></code> and
segments[i].cols() == segments[0].cols()`.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CompositeTrajectory.segment(self:</span> <span class="pre">pydrake.trajectories.CompositeTrajectory,</span> <span class="pre">segment_index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.Trajectory</span></span></dt>
<dd><p>Returns a reference to the <code class="docutils literal notranslate"><span class="pre">segment_index</span></code> trajectory.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CompositeTrajectory_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">CompositeTrajectory_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">CompositeTrajectory_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">CompositeTrajectory_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CompositeTrajectory_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd]</span></code></p>
<p>A “composite trajectory” is a series of trajectories joined end to end
where the end time of one trajectory coincides with the starting time
of the next.</p>
<p>See also PiecewisePolynomial::ConcatenateInTime(), which might be
preferred if all of the segments are PiecewisePolynomial.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CompositeTrajectory_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.trajectories.CompositeTrajectory_[AutoDiffXd],</span> <span class="pre">segments:</span> <span class="pre">list[pydrake.trajectories.Trajectory_[AutoDiffXd]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a composite trajectory from a list of Trajectories.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>∀i, <code class="docutils literal notranslate"><span class="pre">segments[i].get()</span> <span class="pre">!=</span> <span class="pre">nullptr</span></code>.</p>
</dd>
<dt>Precondition:</dt><dd><p>∀i, <code class="docutils literal notranslate"><span class="pre">segments[i+1].start_time()</span> <span class="pre">==</span> <span class="pre">segments[i].end_time()</span></code>.</p>
</dd>
<dt>Precondition:</dt><dd><p>∀i, <code class="docutils literal notranslate"><span class="pre">segments[i].rows()</span> <span class="pre">==</span> <span class="pre">segments[0].rows()</span></code> and
segments[i].cols() == segments[0].cols()`.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CompositeTrajectory_[AutoDiffXd].AlignAndConcatenate(segments:</span> <span class="pre">list[pydrake.trajectories.Trajectory_[AutoDiffXd]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.CompositeTrajectory_[AutoDiffXd]</span></span></dt>
<dd><p>Constructs a composite trajectory from a list of trajectories whose
start and end times may not coincide, by translating their start and
end times.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>∀i, <code class="docutils literal notranslate"><span class="pre">segments[i].get()</span> <span class="pre">!=</span> <span class="pre">nullptr</span></code>.</p>
</dd>
<dt>Precondition:</dt><dd><p>∀i, <code class="docutils literal notranslate"><span class="pre">segments[i].rows()</span> <span class="pre">==</span> <span class="pre">segments[0].rows()</span></code> and
segments[i].cols() == segments[0].cols()`.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CompositeTrajectory_[AutoDiffXd].segment(self:</span> <span class="pre">pydrake.trajectories.CompositeTrajectory_[AutoDiffXd],</span> <span class="pre">segment_index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.Trajectory_[AutoDiffXd]</span></span></dt>
<dd><p>Returns a reference to the <code class="docutils literal notranslate"><span class="pre">segment_index</span></code> trajectory.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CompositeTrajectory_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_[Expression]</span></code></p>
<p>A “composite trajectory” is a series of trajectories joined end to end
where the end time of one trajectory coincides with the starting time
of the next.</p>
<p>See also PiecewisePolynomial::ConcatenateInTime(), which might be
preferred if all of the segments are PiecewisePolynomial.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CompositeTrajectory_[Expression].__init__(self:</span> <span class="pre">pydrake.trajectories.CompositeTrajectory_[Expression],</span> <span class="pre">segments:</span> <span class="pre">list[pydrake.trajectories.Trajectory_[Expression]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a composite trajectory from a list of Trajectories.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>∀i, <code class="docutils literal notranslate"><span class="pre">segments[i].get()</span> <span class="pre">!=</span> <span class="pre">nullptr</span></code>.</p>
</dd>
<dt>Precondition:</dt><dd><p>∀i, <code class="docutils literal notranslate"><span class="pre">segments[i+1].start_time()</span> <span class="pre">==</span> <span class="pre">segments[i].end_time()</span></code>.</p>
</dd>
<dt>Precondition:</dt><dd><p>∀i, <code class="docutils literal notranslate"><span class="pre">segments[i].rows()</span> <span class="pre">==</span> <span class="pre">segments[0].rows()</span></code> and
segments[i].cols() == segments[0].cols()`.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CompositeTrajectory_[Expression].AlignAndConcatenate(segments:</span> <span class="pre">list[pydrake.trajectories.Trajectory_[Expression]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.CompositeTrajectory_[Expression]</span></span></dt>
<dd><p>Constructs a composite trajectory from a list of trajectories whose
start and end times may not coincide, by translating their start and
end times.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>∀i, <code class="docutils literal notranslate"><span class="pre">segments[i].get()</span> <span class="pre">!=</span> <span class="pre">nullptr</span></code>.</p>
</dd>
<dt>Precondition:</dt><dd><p>∀i, <code class="docutils literal notranslate"><span class="pre">segments[i].rows()</span> <span class="pre">==</span> <span class="pre">segments[0].rows()</span></code> and
segments[i].cols() == segments[0].cols()`.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CompositeTrajectory_[Expression].segment(self:</span> <span class="pre">pydrake.trajectories.CompositeTrajectory_[Expression],</span> <span class="pre">segment_index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.Trajectory_[Expression]</span></span></dt>
<dd><p>Returns a reference to the <code class="docutils literal notranslate"><span class="pre">segment_index</span></code> trajectory.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DerivativeTrajectory</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory</span></code></p>
<p>Trajectory objects provide derivatives by implementing
<code class="docutils literal notranslate"><span class="pre">DoEvalDerivative</span></code> <em>and</em> <code class="docutils literal notranslate"><span class="pre">DoMakeDerivative</span></code>. <cite>DoEvalDerivative</cite>
evaluates the derivative value at a point in time.
<code class="docutils literal notranslate"><span class="pre">DoMakeDerivative</span></code> returns a new Trajectory object which represents
the derivative.</p>
<p>In some cases, it is easy to implement <code class="docutils literal notranslate"><span class="pre">DoEvalDerivative</span></code>, but
difficult or inefficient to implement <code class="docutils literal notranslate"><span class="pre">DoMakeDerivative</span></code> natively.
And it may be just as efficient to use <code class="docutils literal notranslate"><span class="pre">DoEvalDerivative</span></code> even in
repeated evaluations of the derivative. The DerivativeTrajectory class
helps with this case – given a <code class="docutils literal notranslate"><span class="pre">nominal</span></code> Trajectory, it provides a
Trajectory interface that calls <code class="docutils literal notranslate"><span class="pre">nominal.EvalDerivative()</span></code> to
implement <code class="docutils literal notranslate"><span class="pre">Trajectory::value()</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">DerivativeTrajectory_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DerivativeTrajectory.__init__(self:</span> <span class="pre">pydrake.trajectories.DerivativeTrajectory,</span> <span class="pre">nominal:</span> <span class="pre">pydrake.trajectories.Trajectory,</span> <span class="pre">derivative_order:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">1)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Creates a DerivativeTrajectory representing the <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code>
derivatives of <code class="docutils literal notranslate"><span class="pre">nominal</span></code>. This constructor makes a Clone() of
<code class="docutils literal notranslate"><span class="pre">nominal</span></code> and does not hold on to the reference.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if !nominal.has_derivative</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if derivative_order &lt; 0.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DerivativeTrajectory_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">DerivativeTrajectory_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">DerivativeTrajectory_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">DerivativeTrajectory_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DerivativeTrajectory_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[AutoDiffXd]</span></code></p>
<p>Trajectory objects provide derivatives by implementing
<code class="docutils literal notranslate"><span class="pre">DoEvalDerivative</span></code> <em>and</em> <code class="docutils literal notranslate"><span class="pre">DoMakeDerivative</span></code>. <cite>DoEvalDerivative</cite>
evaluates the derivative value at a point in time.
<code class="docutils literal notranslate"><span class="pre">DoMakeDerivative</span></code> returns a new Trajectory object which represents
the derivative.</p>
<p>In some cases, it is easy to implement <code class="docutils literal notranslate"><span class="pre">DoEvalDerivative</span></code>, but
difficult or inefficient to implement <code class="docutils literal notranslate"><span class="pre">DoMakeDerivative</span></code> natively.
And it may be just as efficient to use <code class="docutils literal notranslate"><span class="pre">DoEvalDerivative</span></code> even in
repeated evaluations of the derivative. The DerivativeTrajectory class
helps with this case – given a <code class="docutils literal notranslate"><span class="pre">nominal</span></code> Trajectory, it provides a
Trajectory interface that calls <code class="docutils literal notranslate"><span class="pre">nominal.EvalDerivative()</span></code> to
implement <code class="docutils literal notranslate"><span class="pre">Trajectory::value()</span></code>.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DerivativeTrajectory_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.trajectories.DerivativeTrajectory_[AutoDiffXd],</span> <span class="pre">nominal:</span> <span class="pre">pydrake.trajectories.Trajectory_[AutoDiffXd],</span> <span class="pre">derivative_order:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">1)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Creates a DerivativeTrajectory representing the <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code>
derivatives of <code class="docutils literal notranslate"><span class="pre">nominal</span></code>. This constructor makes a Clone() of
<code class="docutils literal notranslate"><span class="pre">nominal</span></code> and does not hold on to the reference.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if !nominal.has_derivative</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if derivative_order &lt; 0.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DerivativeTrajectory_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[Expression]</span></code></p>
<p>Trajectory objects provide derivatives by implementing
<code class="docutils literal notranslate"><span class="pre">DoEvalDerivative</span></code> <em>and</em> <code class="docutils literal notranslate"><span class="pre">DoMakeDerivative</span></code>. <cite>DoEvalDerivative</cite>
evaluates the derivative value at a point in time.
<code class="docutils literal notranslate"><span class="pre">DoMakeDerivative</span></code> returns a new Trajectory object which represents
the derivative.</p>
<p>In some cases, it is easy to implement <code class="docutils literal notranslate"><span class="pre">DoEvalDerivative</span></code>, but
difficult or inefficient to implement <code class="docutils literal notranslate"><span class="pre">DoMakeDerivative</span></code> natively.
And it may be just as efficient to use <code class="docutils literal notranslate"><span class="pre">DoEvalDerivative</span></code> even in
repeated evaluations of the derivative. The DerivativeTrajectory class
helps with this case – given a <code class="docutils literal notranslate"><span class="pre">nominal</span></code> Trajectory, it provides a
Trajectory interface that calls <code class="docutils literal notranslate"><span class="pre">nominal.EvalDerivative()</span></code> to
implement <code class="docutils literal notranslate"><span class="pre">Trajectory::value()</span></code>.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DerivativeTrajectory_[Expression].__init__(self:</span> <span class="pre">pydrake.trajectories.DerivativeTrajectory_[Expression],</span> <span class="pre">nominal:</span> <span class="pre">pydrake.trajectories.Trajectory_[Expression],</span> <span class="pre">derivative_order:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">1)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Creates a DerivativeTrajectory representing the <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code>
derivatives of <code class="docutils literal notranslate"><span class="pre">nominal</span></code>. This constructor makes a Clone() of
<code class="docutils literal notranslate"><span class="pre">nominal</span></code> and does not hold on to the reference.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if !nominal.has_derivative</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if derivative_order &lt; 0.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteTimeTrajectory</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory</span></code></p>
<p>A DiscreteTimeTrajectory is a Trajectory whose value is only defined
at discrete time points. Calling <code class="docutils literal notranslate"><span class="pre">value()</span></code> at a time that is not
equal to one of those times (up to a tolerance) will throw. This
trajectory does <em>not</em> have well-defined time-derivatives.</p>
<p>In some applications, it may be preferable to use
PiecewisePolynomial&lt;T&gt;::ZeroOrderHold instead of a
DiscreteTimeTrajectory (and we offer a method here to easily convert).
Note if the breaks are periodic, then one can also achieve a similar
result in a Diagram by using the DiscreteTimeTrajectory in a
TrajectorySource and connecting a ZeroOrderHold system to the output
port, but remember that this will add discrete state to your diagram.</p>
<p>So why not always use the zero-order hold (ZOH) trajectory? This class
forces us to be more precise in our implementations. For instance,
consider the case of a solution to a discrete-time finite-horizon
linear quadratic regulator (LQR) problem. In this case, the solution
to the Riccati equation is a DiscreteTimeTrajectory, K(t).
Implementing</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">MatrixGain</span><span class="p">(</span><span class="o">-</span><span class="n">K</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
</details><p>in a block diagram is perfectly correct, and if the u(t) is only
connected to the original system that it was designed for, then K(t)
will only get evaluated at the defined sample times, and all is well.
But if you wire it up to a continuous-time system, then K(t) may be
evaluated at arbitrary times, and may throw. If one wishes to use the
K(t) solution on a continuous-time system, then we can use</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">MatrixGain</span><span class="p">(</span><span class="o">-</span><span class="n">K</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">ZOH</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">).</span>
</pre></div>
</div>
</details><p>This is different, and <em>more correct</em> than implementing K(t) as a
zero-order hold trajectory, because in this version, both K(t) and the
inputs x(t) will only be evaluated at the discrete-time input. If
<code class="docutils literal notranslate"><span class="pre">t_s</span></code> was the most recent discrete sample time, then this means u(t)
= -K(t_s)*x(t_s) instead of u(t) = -K(t_s)*x(t). Using x(t_s) and
having a true zero-order hold on u(t) is the correct model for the
discrete-time LQR result.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">DiscreteTimeTrajectory_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteTimeTrajectory.__init__(self:</span> <span class="pre">pydrake.trajectories.DiscreteTimeTrajectory,</span> <span class="pre">times:</span> <span class="pre">list[float],</span> <span class="pre">values:</span> <span class="pre">list[numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]],</span> <span class="pre">time_comparison_tolerance:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">2.220446049250313e-16)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a trajectory of matrix <code class="docutils literal notranslate"><span class="pre">values</span></code> at the specified
<code class="docutils literal notranslate"><span class="pre">times</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">times</span></code> should differ by more than <code class="docutils literal notranslate"><span class="pre">time_comparison_tolerance</span></code>
and be monotonically increasing.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">values</span></code> must have times.size() elements, each with the same
number of rows and columns.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">time_comparison_tolerance</span></code> must be &gt;= 0.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>if T=symbolic</strong> – Expression and <code class="docutils literal notranslate"><span class="pre">times</span></code> are not constants.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteTimeTrajectory.get_times(self:</span> <span class="pre">pydrake.trajectories.DiscreteTimeTrajectory)</span> <span class="pre">-&gt;</span> <span class="pre">list[float]</span></span></dt>
<dd><p>Returns the times where the trajectory value is defined.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteTimeTrajectory.num_times(self:</span> <span class="pre">pydrake.trajectories.DiscreteTimeTrajectory)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of discrete times where the trajectory value is
defined.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteTimeTrajectory.time_comparison_tolerance(self:</span> <span class="pre">pydrake.trajectories.DiscreteTimeTrajectory)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>The trajectory is only defined at finite sample times. This method
returns the tolerance used determine which time sample (if any)
matches a query time on calls to value(t).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteTimeTrajectory.ToZeroOrderHold(self:</span> <span class="pre">pydrake.trajectories.DiscreteTimeTrajectory)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial</span></span></dt>
<dd><p>Converts the discrete-time trajectory using
PiecewisePolynomial&lt;T&gt;::ZeroOrderHold().</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteTimeTrajectory_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">DiscreteTimeTrajectory_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">DiscreteTimeTrajectory_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">DiscreteTimeTrajectory_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteTimeTrajectory_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[AutoDiffXd]</span></code></p>
<p>A DiscreteTimeTrajectory is a Trajectory whose value is only defined
at discrete time points. Calling <code class="docutils literal notranslate"><span class="pre">value()</span></code> at a time that is not
equal to one of those times (up to a tolerance) will throw. This
trajectory does <em>not</em> have well-defined time-derivatives.</p>
<p>In some applications, it may be preferable to use
PiecewisePolynomial&lt;T&gt;::ZeroOrderHold instead of a
DiscreteTimeTrajectory (and we offer a method here to easily convert).
Note if the breaks are periodic, then one can also achieve a similar
result in a Diagram by using the DiscreteTimeTrajectory in a
TrajectorySource and connecting a ZeroOrderHold system to the output
port, but remember that this will add discrete state to your diagram.</p>
<p>So why not always use the zero-order hold (ZOH) trajectory? This class
forces us to be more precise in our implementations. For instance,
consider the case of a solution to a discrete-time finite-horizon
linear quadratic regulator (LQR) problem. In this case, the solution
to the Riccati equation is a DiscreteTimeTrajectory, K(t).
Implementing</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">MatrixGain</span><span class="p">(</span><span class="o">-</span><span class="n">K</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
</details><p>in a block diagram is perfectly correct, and if the u(t) is only
connected to the original system that it was designed for, then K(t)
will only get evaluated at the defined sample times, and all is well.
But if you wire it up to a continuous-time system, then K(t) may be
evaluated at arbitrary times, and may throw. If one wishes to use the
K(t) solution on a continuous-time system, then we can use</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">MatrixGain</span><span class="p">(</span><span class="o">-</span><span class="n">K</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">ZOH</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">).</span>
</pre></div>
</div>
</details><p>This is different, and <em>more correct</em> than implementing K(t) as a
zero-order hold trajectory, because in this version, both K(t) and the
inputs x(t) will only be evaluated at the discrete-time input. If
<code class="docutils literal notranslate"><span class="pre">t_s</span></code> was the most recent discrete sample time, then this means u(t)
= -K(t_s)*x(t_s) instead of u(t) = -K(t_s)*x(t). Using x(t_s) and
having a true zero-order hold on u(t) is the correct model for the
discrete-time LQR result.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteTimeTrajectory_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.trajectories.DiscreteTimeTrajectory_[AutoDiffXd],</span> <span class="pre">times:</span> <span class="pre">list[pydrake.autodiffutils.AutoDiffXd],</span> <span class="pre">values:</span> <span class="pre">list[numpy.ndarray[object[m,</span> <span class="pre">n]]],</span> <span class="pre">time_comparison_tolerance:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">2.220446049250313e-16)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a trajectory of matrix <code class="docutils literal notranslate"><span class="pre">values</span></code> at the specified
<code class="docutils literal notranslate"><span class="pre">times</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">times</span></code> should differ by more than <code class="docutils literal notranslate"><span class="pre">time_comparison_tolerance</span></code>
and be monotonically increasing.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">values</span></code> must have times.size() elements, each with the same
number of rows and columns.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">time_comparison_tolerance</span></code> must be &gt;= 0.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>if T=symbolic</strong> – Expression and <code class="docutils literal notranslate"><span class="pre">times</span></code> are not constants.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteTimeTrajectory_[AutoDiffXd].get_times(self:</span> <span class="pre">pydrake.trajectories.DiscreteTimeTrajectory_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.autodiffutils.AutoDiffXd]</span></span></dt>
<dd><p>Returns the times where the trajectory value is defined.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteTimeTrajectory_[AutoDiffXd].num_times(self:</span> <span class="pre">pydrake.trajectories.DiscreteTimeTrajectory_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of discrete times where the trajectory value is
defined.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteTimeTrajectory_[AutoDiffXd].time_comparison_tolerance(self:</span> <span class="pre">pydrake.trajectories.DiscreteTimeTrajectory_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>The trajectory is only defined at finite sample times. This method
returns the tolerance used determine which time sample (if any)
matches a query time on calls to value(t).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteTimeTrajectory_[AutoDiffXd].ToZeroOrderHold(self:</span> <span class="pre">pydrake.trajectories.DiscreteTimeTrajectory_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</span></span></dt>
<dd><p>Converts the discrete-time trajectory using
PiecewisePolynomial&lt;T&gt;::ZeroOrderHold().</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteTimeTrajectory_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[Expression]</span></code></p>
<p>A DiscreteTimeTrajectory is a Trajectory whose value is only defined
at discrete time points. Calling <code class="docutils literal notranslate"><span class="pre">value()</span></code> at a time that is not
equal to one of those times (up to a tolerance) will throw. This
trajectory does <em>not</em> have well-defined time-derivatives.</p>
<p>In some applications, it may be preferable to use
PiecewisePolynomial&lt;T&gt;::ZeroOrderHold instead of a
DiscreteTimeTrajectory (and we offer a method here to easily convert).
Note if the breaks are periodic, then one can also achieve a similar
result in a Diagram by using the DiscreteTimeTrajectory in a
TrajectorySource and connecting a ZeroOrderHold system to the output
port, but remember that this will add discrete state to your diagram.</p>
<p>So why not always use the zero-order hold (ZOH) trajectory? This class
forces us to be more precise in our implementations. For instance,
consider the case of a solution to a discrete-time finite-horizon
linear quadratic regulator (LQR) problem. In this case, the solution
to the Riccati equation is a DiscreteTimeTrajectory, K(t).
Implementing</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">MatrixGain</span><span class="p">(</span><span class="o">-</span><span class="n">K</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
</pre></div>
</div>
</details><p>in a block diagram is perfectly correct, and if the u(t) is only
connected to the original system that it was designed for, then K(t)
will only get evaluated at the defined sample times, and all is well.
But if you wire it up to a continuous-time system, then K(t) may be
evaluated at arbitrary times, and may throw. If one wishes to use the
K(t) solution on a continuous-time system, then we can use</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">MatrixGain</span><span class="p">(</span><span class="o">-</span><span class="n">K</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">ZOH</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">u</span><span class="p">(</span><span class="n">t</span><span class="p">).</span>
</pre></div>
</div>
</details><p>This is different, and <em>more correct</em> than implementing K(t) as a
zero-order hold trajectory, because in this version, both K(t) and the
inputs x(t) will only be evaluated at the discrete-time input. If
<code class="docutils literal notranslate"><span class="pre">t_s</span></code> was the most recent discrete sample time, then this means u(t)
= -K(t_s)*x(t_s) instead of u(t) = -K(t_s)*x(t). Using x(t_s) and
having a true zero-order hold on u(t) is the correct model for the
discrete-time LQR result.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteTimeTrajectory_[Expression].__init__(self:</span> <span class="pre">pydrake.trajectories.DiscreteTimeTrajectory_[Expression],</span> <span class="pre">times:</span> <span class="pre">list[pydrake.symbolic.Expression],</span> <span class="pre">values:</span> <span class="pre">list[numpy.ndarray[object[m,</span> <span class="pre">n]]],</span> <span class="pre">time_comparison_tolerance:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">2.220446049250313e-16)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a trajectory of matrix <code class="docutils literal notranslate"><span class="pre">values</span></code> at the specified
<code class="docutils literal notranslate"><span class="pre">times</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">times</span></code> should differ by more than <code class="docutils literal notranslate"><span class="pre">time_comparison_tolerance</span></code>
and be monotonically increasing.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">values</span></code> must have times.size() elements, each with the same
number of rows and columns.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">time_comparison_tolerance</span></code> must be &gt;= 0.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>if T=symbolic</strong> – Expression and <code class="docutils literal notranslate"><span class="pre">times</span></code> are not constants.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteTimeTrajectory_[Expression].get_times(self:</span> <span class="pre">pydrake.trajectories.DiscreteTimeTrajectory_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.symbolic.Expression]</span></span></dt>
<dd><p>Returns the times where the trajectory value is defined.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteTimeTrajectory_[Expression].num_times(self:</span> <span class="pre">pydrake.trajectories.DiscreteTimeTrajectory_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of discrete times where the trajectory value is
defined.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteTimeTrajectory_[Expression].time_comparison_tolerance(self:</span> <span class="pre">pydrake.trajectories.DiscreteTimeTrajectory_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>The trajectory is only defined at finite sample times. This method
returns the tolerance used determine which time sample (if any)
matches a query time on calls to value(t).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DiscreteTimeTrajectory_[Expression].ToZeroOrderHold(self:</span> <span class="pre">pydrake.trajectories.DiscreteTimeTrajectory_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[Expression]</span></span></dt>
<dd><p>Converts the discrete-time trajectory using
PiecewisePolynomial&lt;T&gt;::ZeroOrderHold().</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ExponentialPlusPiecewisePolynomial</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PiecewiseTrajectory</span></code></p>
<p>Represents a piecewise-trajectory with piece <span class="math notranslate nohighlight">\(j\)</span> given by:</p>
<div class="math notranslate nohighlight">
\[x(t) = K e^{A (t - t_j)} \alpha_j + \sum_{i=0}^k \beta_{j,i}(t-t_j)^i,\]</div>
<p>where <span class="math notranslate nohighlight">\(k\)</span> is the order of the <code class="docutils literal notranslate"><span class="pre">piecewise_polynomial_part</span></code> and
<span class="math notranslate nohighlight">\(t_j\)</span> is the start time of the <span class="math notranslate nohighlight">\(j\)</span>-th segment.</p>
<p>This particular form can represent the solution to a linear dynamical
system driven by a piecewise-polynomial input:</p>
<div class="math notranslate nohighlight">
\[\dot{x}(t) = A x(t) + B u(t),\]</div>
<p>where the input <span class="math notranslate nohighlight">\(u(t)\)</span> is a piecewise-polynomial function of
time. See [1] for details and a motivating use case.</p>
<p>[1] R. Tedrake, S. Kuindersma, R. Deits and K. Miura, “A closed-form
solution for real-time ZMP gait generation and feedback
stabilization,” 2015 IEEE-RAS 15th International Conference on
Humanoid Robots (Humanoids), Seoul, 2015, pp. 936-940.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">ExponentialPlusPiecewisePolynomial_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ExponentialPlusPiecewisePolynomial.__init__(self:</span> <span class="pre">pydrake.trajectories.ExponentialPlusPiecewisePolynomial,</span> <span class="pre">K:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]],</span> <span class="pre">A:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]],</span> <span class="pre">alpha:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]],</span> <span class="pre">piecewise_polynomial_part:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ExponentialPlusPiecewisePolynomial.shiftRight(self:</span> <span class="pre">pydrake.trajectories.ExponentialPlusPiecewisePolynomial,</span> <span class="pre">offset:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ExponentialPlusPiecewisePolynomial_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">ExponentialPlusPiecewisePolynomial_[float]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FunctionHandleTrajectory</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory</span></code></p>
<p>FunctionHandleTrajectory takes a function, value = f(t), and provides
a Trajectory interface.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">FunctionHandleTrajectory_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FunctionHandleTrajectory.__init__(self:</span> <span class="pre">pydrake.trajectories.FunctionHandleTrajectory,</span> <span class="pre">func:</span> <span class="pre">Callable[[float],</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]],</span> <span class="pre">rows:</span> <span class="pre">int,</span> <span class="pre">cols:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">start_time:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">-inf,</span> <span class="pre">end_time:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">inf)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Creates the FunctionHandleTrajectory.</p>
<p>By default the created trajectory does not provide derivatives. If
trajectory derivatives are required, call <code class="docutils literal notranslate"><span class="pre">set_derivative</span></code> to
provide the function’s derivatives.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">func</span></code>:</dt><dd><p>The function to be used to evaluate the trajectory.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rows</span></code>:</dt><dd><p>The number of rows in the output of the function.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">cols</span></code>:</dt><dd><p>The number of columns in the output of the function.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">start_time</span></code>:</dt><dd><p>The start time of the trajectory.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">end_time</span></code>:</dt><dd><p>The end time of the trajectory.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if func == nullptr</strong><strong>, </strong><strong>rows &lt; 0</strong><strong>, </strong><strong>cols &lt; 0</strong><strong>, </strong><strong>start_time &gt;</strong> – </p></li>
<li><p><strong>end_time</strong><strong>, or </strong><strong>if the function returns a matrix</strong><strong> of </strong><strong>the wrong size.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FunctionHandleTrajectory.set_derivative(self:</span> <span class="pre">pydrake.trajectories.FunctionHandleTrajectory,</span> <span class="pre">func:</span> <span class="pre">Callable[[float,</span> <span class="pre">int],</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets a callback function that returns the derivative of the function.
<code class="docutils literal notranslate"><span class="pre">func(t,order)</span></code> will only be called with <code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>. It is
recommended that if the derivatives are not implemented for the
requested order, the callback should throw an exception.</p>
<p>The size of the output of <code class="docutils literal notranslate"><span class="pre">func</span></code> will be checked each time the
derivative is evaluated, and a RuntimeError will be thrown if the size
is incorrect.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FunctionHandleTrajectory_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">FunctionHandleTrajectory_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">FunctionHandleTrajectory_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">FunctionHandleTrajectory_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FunctionHandleTrajectory_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[AutoDiffXd]</span></code></p>
<p>FunctionHandleTrajectory takes a function, value = f(t), and provides
a Trajectory interface.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FunctionHandleTrajectory_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.trajectories.FunctionHandleTrajectory_[AutoDiffXd],</span> <span class="pre">func:</span> <span class="pre">Callable[[pydrake.autodiffutils.AutoDiffXd],</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]]],</span> <span class="pre">rows:</span> <span class="pre">int,</span> <span class="pre">cols:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">start_time:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">-inf,</span> <span class="pre">end_time:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">inf)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Creates the FunctionHandleTrajectory.</p>
<p>By default the created trajectory does not provide derivatives. If
trajectory derivatives are required, call <code class="docutils literal notranslate"><span class="pre">set_derivative</span></code> to
provide the function’s derivatives.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">func</span></code>:</dt><dd><p>The function to be used to evaluate the trajectory.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rows</span></code>:</dt><dd><p>The number of rows in the output of the function.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">cols</span></code>:</dt><dd><p>The number of columns in the output of the function.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">start_time</span></code>:</dt><dd><p>The start time of the trajectory.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">end_time</span></code>:</dt><dd><p>The end time of the trajectory.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if func == nullptr</strong><strong>, </strong><strong>rows &lt; 0</strong><strong>, </strong><strong>cols &lt; 0</strong><strong>, </strong><strong>start_time &gt;</strong> – </p></li>
<li><p><strong>end_time</strong><strong>, or </strong><strong>if the function returns a matrix</strong><strong> of </strong><strong>the wrong size.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FunctionHandleTrajectory_[AutoDiffXd].set_derivative(self:</span> <span class="pre">pydrake.trajectories.FunctionHandleTrajectory_[AutoDiffXd],</span> <span class="pre">func:</span> <span class="pre">Callable[[pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">int],</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets a callback function that returns the derivative of the function.
<code class="docutils literal notranslate"><span class="pre">func(t,order)</span></code> will only be called with <code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>. It is
recommended that if the derivatives are not implemented for the
requested order, the callback should throw an exception.</p>
<p>The size of the output of <code class="docutils literal notranslate"><span class="pre">func</span></code> will be checked each time the
derivative is evaluated, and a RuntimeError will be thrown if the size
is incorrect.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FunctionHandleTrajectory_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[Expression]</span></code></p>
<p>FunctionHandleTrajectory takes a function, value = f(t), and provides
a Trajectory interface.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FunctionHandleTrajectory_[Expression].__init__(self:</span> <span class="pre">pydrake.trajectories.FunctionHandleTrajectory_[Expression],</span> <span class="pre">func:</span> <span class="pre">Callable[[pydrake.symbolic.Expression],</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]]],</span> <span class="pre">rows:</span> <span class="pre">int,</span> <span class="pre">cols:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">start_time:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">-inf,</span> <span class="pre">end_time:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">inf)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Creates the FunctionHandleTrajectory.</p>
<p>By default the created trajectory does not provide derivatives. If
trajectory derivatives are required, call <code class="docutils literal notranslate"><span class="pre">set_derivative</span></code> to
provide the function’s derivatives.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">func</span></code>:</dt><dd><p>The function to be used to evaluate the trajectory.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rows</span></code>:</dt><dd><p>The number of rows in the output of the function.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">cols</span></code>:</dt><dd><p>The number of columns in the output of the function.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">start_time</span></code>:</dt><dd><p>The start time of the trajectory.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">end_time</span></code>:</dt><dd><p>The end time of the trajectory.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if func == nullptr</strong><strong>, </strong><strong>rows &lt; 0</strong><strong>, </strong><strong>cols &lt; 0</strong><strong>, </strong><strong>start_time &gt;</strong> – </p></li>
<li><p><strong>end_time</strong><strong>, or </strong><strong>if the function returns a matrix</strong><strong> of </strong><strong>the wrong size.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FunctionHandleTrajectory_[Expression].set_derivative(self:</span> <span class="pre">pydrake.trajectories.FunctionHandleTrajectory_[Expression],</span> <span class="pre">func:</span> <span class="pre">Callable[[pydrake.symbolic.Expression,</span> <span class="pre">int],</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets a callback function that returns the derivative of the function.
<code class="docutils literal notranslate"><span class="pre">func(t,order)</span></code> will only be called with <code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>. It is
recommended that if the derivatives are not implemented for the
requested order, the callback should throw an exception.</p>
<p>The size of the output of <code class="docutils literal notranslate"><span class="pre">func</span></code> will be checked each time the
derivative is evaluated, and a RuntimeError will be thrown if the size
is incorrect.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PathParameterizedTrajectory</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory</span></code></p>
<p>A trajectory defined by a path and timing trajectory.</p>
<p>Using a path of form <code class="docutils literal notranslate"><span class="pre">r(s)</span></code> and a time_scaling of the form <code class="docutils literal notranslate"><span class="pre">s(t)</span></code>,
a full trajectory of form <code class="docutils literal notranslate"><span class="pre">q(t)</span> <span class="pre">=</span> <span class="pre">r(s(t))</span></code> is modeled.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">PathParameterizedTrajectory_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PathParameterizedTrajectory.__init__(self:</span> <span class="pre">pydrake.trajectories.PathParameterizedTrajectory,</span> <span class="pre">path:</span> <span class="pre">pydrake.trajectories.Trajectory,</span> <span class="pre">time_scaling:</span> <span class="pre">pydrake.trajectories.Trajectory)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a trajectory with the given <code class="docutils literal notranslate"><span class="pre">path</span></code> and <code class="docutils literal notranslate"><span class="pre">time_scaling</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>time_scaling.rows() == time_scaling.cols() == 1</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PathParameterizedTrajectory.path(self:</span> <span class="pre">pydrake.trajectories.PathParameterizedTrajectory)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.Trajectory</span></span></dt>
<dd><p>Returns the path of this trajectory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PathParameterizedTrajectory.time_scaling(self:</span> <span class="pre">pydrake.trajectories.PathParameterizedTrajectory)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.Trajectory</span></span></dt>
<dd><p>Returns the time_scaling of this trajectory.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PathParameterizedTrajectory_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">PathParameterizedTrajectory_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">PathParameterizedTrajectory_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">PathParameterizedTrajectory_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PathParameterizedTrajectory_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[AutoDiffXd]</span></code></p>
<p>A trajectory defined by a path and timing trajectory.</p>
<p>Using a path of form <code class="docutils literal notranslate"><span class="pre">r(s)</span></code> and a time_scaling of the form <code class="docutils literal notranslate"><span class="pre">s(t)</span></code>,
a full trajectory of form <code class="docutils literal notranslate"><span class="pre">q(t)</span> <span class="pre">=</span> <span class="pre">r(s(t))</span></code> is modeled.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PathParameterizedTrajectory_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.trajectories.PathParameterizedTrajectory_[AutoDiffXd],</span> <span class="pre">path:</span> <span class="pre">pydrake.trajectories.Trajectory_[AutoDiffXd],</span> <span class="pre">time_scaling:</span> <span class="pre">pydrake.trajectories.Trajectory_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a trajectory with the given <code class="docutils literal notranslate"><span class="pre">path</span></code> and <code class="docutils literal notranslate"><span class="pre">time_scaling</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>time_scaling.rows() == time_scaling.cols() == 1</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PathParameterizedTrajectory_[AutoDiffXd].path(self:</span> <span class="pre">pydrake.trajectories.PathParameterizedTrajectory_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.Trajectory_[AutoDiffXd]</span></span></dt>
<dd><p>Returns the path of this trajectory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PathParameterizedTrajectory_[AutoDiffXd].time_scaling(self:</span> <span class="pre">pydrake.trajectories.PathParameterizedTrajectory_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.Trajectory_[AutoDiffXd]</span></span></dt>
<dd><p>Returns the time_scaling of this trajectory.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PathParameterizedTrajectory_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[Expression]</span></code></p>
<p>A trajectory defined by a path and timing trajectory.</p>
<p>Using a path of form <code class="docutils literal notranslate"><span class="pre">r(s)</span></code> and a time_scaling of the form <code class="docutils literal notranslate"><span class="pre">s(t)</span></code>,
a full trajectory of form <code class="docutils literal notranslate"><span class="pre">q(t)</span> <span class="pre">=</span> <span class="pre">r(s(t))</span></code> is modeled.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PathParameterizedTrajectory_[Expression].__init__(self:</span> <span class="pre">pydrake.trajectories.PathParameterizedTrajectory_[Expression],</span> <span class="pre">path:</span> <span class="pre">pydrake.trajectories.Trajectory_[Expression],</span> <span class="pre">time_scaling:</span> <span class="pre">pydrake.trajectories.Trajectory_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a trajectory with the given <code class="docutils literal notranslate"><span class="pre">path</span></code> and <code class="docutils literal notranslate"><span class="pre">time_scaling</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>time_scaling.rows() == time_scaling.cols() == 1</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PathParameterizedTrajectory_[Expression].path(self:</span> <span class="pre">pydrake.trajectories.PathParameterizedTrajectory_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.Trajectory_[Expression]</span></span></dt>
<dd><p>Returns the path of this trajectory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PathParameterizedTrajectory_[Expression].time_scaling(self:</span> <span class="pre">pydrake.trajectories.PathParameterizedTrajectory_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.Trajectory_[Expression]</span></span></dt>
<dd><p>Returns the time_scaling of this trajectory.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PiecewiseTrajectory</span></code></p>
<p>A scalar multi-variate piecewise polynomial.</p>
<p>PiecewisePolynomial represents a list of contiguous segments in a
scalar independent variable (typically corresponding to time) with
Polynomials defined at each segment. We call the output from
evaluating the PiecewisePolynomial at the scalar independent variable
“the output”, and that output can be either a Eigen MatrixX&lt;T&gt; (if
evaluated using value()) or a scalar (if evaluated using
scalar_value()).</p>
<p>An example of a piecewise polynomial is a function of m segments in
time, where a different polynomial is defined for each segment. For a
specific example, consider the absolute value function over the
interval [-1, 1]. We can define a PiecewisePolynomial over this
interval using breaks at t = { -1.0, 0.0, 1.0 }, and “samples” of
abs(t).</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Construct the PiecewisePolynomial.</span>
<span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">breaks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">-1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span><span class="o">&gt;</span><span class="w"> </span><span class="n">samples</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">breaks</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">resize</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">  </span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">breaks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">pp</span><span class="w"> </span><span class="o">=</span>
<span class="w">     </span><span class="n">PiecewisePolynomial</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">FirstOrderHold</span><span class="p">(</span><span class="n">breaks</span><span class="p">,</span><span class="w"> </span><span class="n">samples</span><span class="p">);</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="c1">// Evaluate the PiecewisePolynomial at some values.</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pp</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="mf">-.5</span><span class="p">)(</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w">    </span><span class="c1">// Outputs 0.5.</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pp</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)(</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w">    </span><span class="c1">// Outputs 0.0;</span>

<span class="c1">// Show how we can evaluate the first derivative (outputs -1.0).</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pp</span><span class="p">.</span><span class="n">derivative</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">value</span><span class="p">(</span><span class="mf">-.5</span><span class="p">)(</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
</details><p>A note on terminology. For piecewise-polynomial interpolation, we use
<code class="docutils literal notranslate"><span class="pre">breaks</span></code> to indicate the scalar (e.g. times) which form the boundary
of each segment. We use <code class="docutils literal notranslate"><span class="pre">samples</span></code> to indicate the function value at
the <code class="docutils literal notranslate"><span class="pre">breaks</span></code>, e.g. <code class="docutils literal notranslate"><span class="pre">p(breaks[i])</span> <span class="pre">=</span> <span class="pre">samples[i]</span></code>. The term <code class="docutils literal notranslate"><span class="pre">knot</span></code>
should be reserved for the “(x,y)” coordinate, here <code class="docutils literal notranslate"><span class="pre">knot[i]</span> <span class="pre">=</span>
<span class="pre">(breaks[i],</span> <span class="pre">samples[i])</span></code>, though it is used inconsistently in the
interpolation literature (sometimes for <code class="docutils literal notranslate"><span class="pre">breaks</span></code>, sometimes for
<code class="docutils literal notranslate"><span class="pre">samples</span></code>), so we try to mostly avoid it here.</p>
<p>PiecewisePolynomial objects can be added, subtracted, and multiplied.
They cannot be divided because Polynomials are not closed under
division.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>PiecewisePolynomial silently clips input evaluations outside of
the range defined by the breaks. So <code class="docutils literal notranslate"><span class="pre">pp.value(-2.0,</span> <span class="pre">row,</span> <span class="pre">col)</span></code>
in the example above would evaluate to -1.0. See value().</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewisePolynomial_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.PiecewisePolynomial) -&gt; None</p></li>
</ol>
<p>Constructs an empty piecewise polynomial.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.trajectories.PiecewisePolynomial, arg0: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]) -&gt; None</p></li>
</ol>
<p>Single segment, constant value constructor over the interval [-∞, ∞].
The constructed PiecewisePolynomial will return <code class="docutils literal notranslate"><span class="pre">constant_value</span></code> at
every evaluated point (i.e., <code class="docutils literal notranslate"><span class="pre">value(t)</span> <span class="pre">=</span> <span class="pre">constant_value</span></code> ∀t ∈ [-∞,
∞]).</p>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.trajectories.PiecewisePolynomial, arg0: list[numpy.ndarray[object[m, n]]], arg1: list[float]) -&gt; None</p></li>
</ol>
<p>Constructs a PiecewisePolynomial using matrix-output Polynomials
defined over each segment.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">polynomials.size()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span> <span class="pre">-</span> <span class="pre">1</span></code></p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.trajectories.PiecewisePolynomial, arg0: list[pydrake.polynomial.Polynomial], arg1: list[float]) -&gt; None</p></li>
</ol>
<p>Constructs a PiecewisePolynomial using scalar-output Polynomials
defined over each segment.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">polynomials.size()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span> <span class="pre">-</span> <span class="pre">1</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial.AppendCubicHermiteSegment(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial,</span> <span class="pre">time:</span> <span class="pre">float,</span> <span class="pre">sample:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous],</span> <span class="pre">sample_dot:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>The CubicHermite spline construction has a nice property of being
incremental (each segment can be solved independently). Given a new
sample and it’s derivative, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code> where the start sample and derivative are taken as the value
and derivative at the final break of <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> is not empty()</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">time</span></code> &gt; end_time()</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">sample</span></code> and <code class="docutils literal notranslate"><span class="pre">sample_dot</span></code> must have size rows() x cols().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial.AppendFirstOrderSegment(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial,</span> <span class="pre">time:</span> <span class="pre">float,</span> <span class="pre">sample:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Given a new sample, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code> using a first-order hold, where the start sample is taken as
the value at the final break of <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial.Block(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial,</span> <span class="pre">start_row:</span> <span class="pre">int,</span> <span class="pre">start_col:</span> <span class="pre">int,</span> <span class="pre">block_rows:</span> <span class="pre">int,</span> <span class="pre">block_cols:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial</span></span></dt>
<dd><p>Extracts a trajectory representing a block of size (block_rows,
block_cols) starting at (start_row, start_col) from the
PiecewisePolynomial.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a PiecewisePolynomial such that ret.value(t) =
this.value(t).block(i,j,p,q);</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial.ConcatenateInTime(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial,</span> <span class="pre">other:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Concatenates <code class="docutils literal notranslate"><span class="pre">other</span></code> to the end of <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The resulting PiecewisePolynomial will only be continuous to the
degree that the first Polynomial of <code class="docutils literal notranslate"><span class="pre">other</span></code> is continuous with
the last Polynomial of <code class="docutils literal notranslate"><span class="pre">this</span></code>. See warning about evaluating
discontinuous derivatives at breaks in derivative().</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other</span></code>:</dt><dd><p>PiecewisePolynomial instance to concatenate.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if trajectories' dimensions do not match each other</strong> – </p></li>
<li><p><strong>(</strong><strong>either rows</strong><strong>(</strong><strong>) or </strong><strong>cols</strong><strong>(</strong><strong>) </strong><strong>does not match between this and</strong> – </p></li>
<li><p><strong>other`</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if this-&gt;end_time</strong><strong>(</strong><strong>) </strong><strong>and other-&gt;start_time</strong><strong>(</strong><strong>)</strong> – </p></li>
<li><p><strong>are not within PiecewiseTrajectory&lt;T&gt;::kEpsilonTime from each</strong> – </p></li>
<li><p><strong>other.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial.CubicHermite(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CubicHermite(breaks: list[float], samples: list[list[float]], samples_dot: list[list[float]]) -&gt; pydrake.trajectories.PiecewisePolynomial</p></li>
</ol>
<p>Version of CubicHermite(breaks, samples, samples_dot) that uses vector
samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Corresponding
columns of <code class="docutils literal notranslate"><span class="pre">samples</span></code> and <code class="docutils literal notranslate"><span class="pre">samples_dot</span></code> are used as the sample
point and independent variable derivative, respectively.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">samples_dot.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>CubicHermite(breaks: list[float], samples: list[numpy.ndarray[numpy.float64[m, n]]], samples_dot: list[numpy.ndarray[numpy.float64[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial</p></li>
</ol>
<p>Constructs a third order PiecewisePolynomial using matrix samples and
derivatives of samples (<code class="docutils literal notranslate"><span class="pre">samples_dot</span></code>); each matrix element of
<code class="docutils literal notranslate"><span class="pre">samples_dot</span></code> represents the derivative with respect to the
independent variable (e.g., the time derivative) of the corresponding
entry in <code class="docutils literal notranslate"><span class="pre">samples</span></code>. Each segment is fully specified by <code class="docutils literal notranslate"><span class="pre">samples</span></code>
and <code class="docutils literal notranslate"><span class="pre">sample_dot</span></code> at both ends. Second derivatives are not
continuous.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial.CubicShapePreserving(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CubicShapePreserving(breaks: list[float], samples: list[list[float]], zero_end_point_derivatives: bool = False) -&gt; pydrake.trajectories.PiecewisePolynomial</p></li>
</ol>
<p>Version of CubicShapePreserving(breaks, samples,
zero_end_point_derivatives) that uses vector samples and Eigen
VectorXd and MatrixX&lt;T&gt; arguments. Each column of <code class="docutils literal notranslate"><span class="pre">samples</span></code>
represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>CubicShapePreserving(breaks: list[float], samples: list[numpy.ndarray[numpy.float64[m, n]]], zero_end_point_derivatives: bool = False) -&gt; pydrake.trajectories.PiecewisePolynomial</p></li>
</ol>
<p>Constructs a third order PiecewisePolynomial using vector samples,
where each column of <code class="docutils literal notranslate"><span class="pre">samples</span></code> represents a sample point. First
derivatives are chosen to be “shape preserving”, i.e. if <code class="docutils literal notranslate"><span class="pre">samples</span></code>
is monotonic within some interval, the interpolated data will also be
monotonic. The second derivative is not guaranteed to be smooth across
the entire spline.</p>
<p>MATLAB calls this method “pchip” (short for “Piecewise Cubic Hermite
Interpolating Polynomial”), and provides a nice description in their
documentation.
<a class="reference external" href="http://home.uchicago.edu/~sctchoi/courses/cs138/interp.pdf">http://home.uchicago.edu/~sctchoi/courses/cs138/interp.pdf</a> is also a
good reference.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, the first and last
first derivative is chosen using a non-centered, shape-preserving
three-point formulae. See equation (2.10) in the following reference
for more details. <a class="reference external" href="http://www.mi.sanu.ac.rs/~gvm/radovi/mon.pdf">http://www.mi.sanu.ac.rs/~gvm/radovi/mon.pdf</a> If
<code class="docutils literal notranslate"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, they are set to zeros.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, <cite>breaks</cite> and
<code class="docutils literal notranslate"><span class="pre">samples</span></code> must have at least 3 elements for the algorithm to
determine the first derivatives.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, <cite>breaks</cite> and
<code class="docutils literal notranslate"><span class="pre">samples</span></code> may have 2 or more elements. For the 2 elements case, the
result is equivalent to computing a cubic polynomial whose values are
given by <code class="docutils literal notranslate"><span class="pre">samples</span></code>, and derivatives set to zero.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if</strong> – <ul>
<li><p><code class="docutils literal notranslate"><span class="pre">breaks</span></code> has length smaller than 3 and</p></li>
</ul>
</p></li>
<li><p><strong>zero_end_point_derivatives` is False</strong><strong>, </strong><strong>- breaks has lengt</strong> – </p></li>
<li><p><strong>smaller than 2 and zero_end_point_derivatives is true.</strong> – </p></li>
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial.CubicWithContinuousSecondDerivatives(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CubicWithContinuousSecondDerivatives(breaks: list[float], samples: list[list[float]], sample_dot_at_start: numpy.ndarray[numpy.float64[m, n]], sample_dot_at_end: numpy.ndarray[numpy.float64[m, n]]) -&gt; pydrake.trajectories.PiecewisePolynomial</p></li>
</ol>
<p>Version of CubicWithContinuousSecondDerivatives() that uses vector
samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each column of
<code class="docutils literal notranslate"><span class="pre">samples</span></code> represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>CubicWithContinuousSecondDerivatives(breaks: list[float], samples: list[numpy.ndarray[numpy.float64[m, n]]], sample_dot_at_start: numpy.ndarray[numpy.float64[m, n]], sample_dot_at_end: numpy.ndarray[numpy.float64[m, n]]) -&gt; pydrake.trajectories.PiecewisePolynomial</p></li>
</ol>
<p>Constructs a third order PiecewisePolynomial using matrix samples. The
PiecewisePolynomial is constructed such that the interior segments
have the same value, first and second derivatives at <code class="docutils literal notranslate"><span class="pre">breaks</span></code>.
<cite>sample_dot_at_start</cite> and <code class="docutils literal notranslate"><span class="pre">sample_dot_at_end</span></code> are used for the first
and last first derivatives.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if sample_dot_at_start</strong><strong> or </strong><strong>sample_dot_at_end</strong> – </p></li>
<li><p><strong>and samples have inconsistent dimensions.</strong> – </p></li>
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>CubicWithContinuousSecondDerivatives(breaks: list[float], samples: list[list[float]], periodic_end_condition: bool = False) -&gt; pydrake.trajectories.PiecewisePolynomial</p></li>
</ol>
<p>Version of CubicWithContinuousSecondDerivatives(breaks, samples) that
uses vector samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each
column of <code class="docutils literal notranslate"><span class="pre">samples</span></code> represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>CubicWithContinuousSecondDerivatives(breaks: list[float], samples: list[numpy.ndarray[numpy.float64[m, n]]], periodic_end: bool) -&gt; pydrake.trajectories.PiecewisePolynomial</p></li>
</ol>
<p>Constructs a third order PiecewisePolynomial using matrix samples. The
PiecewisePolynomial is constructed such that the interior segments
have the same value, first and second derivatives at <code class="docutils literal notranslate"><span class="pre">breaks</span></code>. If
<code class="docutils literal notranslate"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code> (default), then the
“Not-a-sample” end condition is used here, which means the third
derivatives are continuous for the first two and last two segments. If
<code class="docutils literal notranslate"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, then the first and second
derivatives between the end of the last segment and the beginning of
the first segment will be continuous. Note that the periodic end
condition does not require the first and last sample to be collocated,
nor does it add an additional sample to connect the first and last
segments. Only first and second derivative continuity is enforced. See
<a class="reference external" href="https://en.wikipedia.org/wiki/Spline_interpolation">https://en.wikipedia.org/wiki/Spline_interpolation</a> and
<a class="reference external" href="https://web.archive.org/web/20140125011904/https://www.math.uh.edu/~jingqiu/math4364/spline.pdf">https://web.archive.org/web/20140125011904/https://www.math.uh.edu/~jingqiu/math4364/spline.pdf</a>
for more about cubic splines and their end conditions. The MATLAB docs
for methods “spline” and “csape” are also good references.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">breaks</span></code> and <code class="docutils literal notranslate"><span class="pre">samples</span></code> must have at least 3 elements. If
<code class="docutils literal notranslate"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, then for two samples, it
would produce a straight line (use <code class="docutils literal notranslate"><span class="pre">FirstOrderHold</span></code> for this
instead), and if <code class="docutils literal notranslate"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code> the
problem is ill-defined.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial.derivative(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial,</span> <span class="pre">derivative_order:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">1)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial</span></span></dt>
<dd><p>Returns a PiecewisePolynomial where each segment is the specified
derivative of the corresponding segment in <code class="docutils literal notranslate"><span class="pre">this</span></code>. Any rules or
limitations of Polynomial::derivative() also apply to this function.</p>
<p>Derivatives evaluated at non-differentiable points return the value at
the left hand side of the interval.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code>:</dt><dd><p>The order of the derivative, namely, if <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code> = n,
the n’th derivative of the polynomial will be returned.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In the event of discontinuous derivatives evaluated at breaks, it
is not defined which polynomial (i.e., to the left or right of the
break) will be the one that is evaluated at the break.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial.FirstOrderHold(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>FirstOrderHold(breaks: list[float], samples: list[list[float]]) -&gt; pydrake.trajectories.PiecewisePolynomial</p></li>
</ol>
<p>Version of FirstOrderHold(breaks, samples) that uses vector samples
and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each column of <code class="docutils literal notranslate"><span class="pre">samples</span></code>
represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>FirstOrderHold(breaks: list[float], samples: list[numpy.ndarray[numpy.float64[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial</p></li>
</ol>
<p>Constructs a piecewise linear PiecewisePolynomial using matrix
samples.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial.getPolynomial(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial,</span> <span class="pre">segment_index:</span> <span class="pre">int,</span> <span class="pre">row:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">col:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.polynomial.Polynomial</span></span></dt>
<dd><p>Gets the Polynomial with the given matrix row and column index that
corresponds to the given segment index. Equivalent to
<code class="docutils literal notranslate"><span class="pre">getPolynomialMatrix(segment_index)(row,</span> <span class="pre">col)</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calls PiecewiseTrajectory&lt;T&gt;::segment_number_range_check() to
validate <code class="docutils literal notranslate"><span class="pre">segment_index</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial.getPolynomialMatrix(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial,</span> <span class="pre">segment_index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>Gets the matrix of Polynomials corresponding to the given segment
index.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><code class="docutils literal notranslate"><span class="pre">segment_index</span></code> is not checked for validity.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial.getSegmentPolynomialDegree(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial,</span> <span class="pre">segment_index:</span> <span class="pre">int,</span> <span class="pre">row:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">col:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Gets the degree of the Polynomial with the given matrix row and column
index that corresponds to the given segment index. Equivalent to
<code class="docutils literal notranslate"><span class="pre">getPolynomial(segment_index,</span> <span class="pre">row,</span> <span class="pre">col).GetDegree()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial.isApprox(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial,</span> <span class="pre">other:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial,</span> <span class="pre">tol:</span> <span class="pre">float,</span> <span class="pre">tol_type:</span> <span class="pre">pydrake.common.ToleranceType</span> <span class="pre">=</span> <span class="pre">&lt;ToleranceType.kRelative:</span> <span class="pre">1&gt;)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Checks whether a PiecewisePolynomial is approximately equal to this
one by calling Polynomial&lt;T&gt;::CoefficientsAlmostEqual() on every
element of every segment.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Polynomial&lt;T&gt;::CoefficientsAlmostEqual().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial.LagrangeInterpolatingPolynomial(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>LagrangeInterpolatingPolynomial(times: list[float], samples: list[list[float]]) -&gt; pydrake.trajectories.PiecewisePolynomial</p></li>
</ol>
<p>Version of LagrangeInterpolatingPolynomial(times, samples) that uses
vector samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each column
of <code class="docutils literal notranslate"><span class="pre">samples</span></code> represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">times.size()</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>LagrangeInterpolatingPolynomial(times: list[float], samples: list[numpy.ndarray[numpy.float64[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial</p></li>
</ol>
<p>Constructs a polynomial with a <em>single segment</em> of the lowest possible
degree that passes through all of the sample points. See “polynomial
interpolation” and/or “Lagrange polynomial” on Wikipedia for more
information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">times</span></code> must be monotonically increasing.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.size()</span> <span class="pre">==</span> <span class="pre">times.size()</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial.RemoveFinalSegment(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Removes the final segment from the trajectory, reducing the number of
segments by 1.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> is not empty()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial.Reshape(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial,</span> <span class="pre">rows:</span> <span class="pre">int,</span> <span class="pre">cols:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Reshapes the dimensions of the Eigen::MatrixX&lt;T&gt; returned by value(),
EvalDerivative(), etc.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">rows</span></code> x <code class="docutils literal notranslate"><span class="pre">cols</span></code> must equal this.rows() * this.cols().</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Eigen::PlainObjectBase::resize().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial.ReverseTime(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Modifies the trajectory so that pp_after(t) = pp_before(-t).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The new trajectory will evaluate differently at precisely the
break points if the original trajectory was discontinuous at the
break points. This is because the segments are defined on the
half-open intervals [breaks(i), breaks(i+1)), and the order of the
breaks have been reversed.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial.ScaleTime(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial,</span> <span class="pre">scale:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Scales the time of the trajectory by non-negative <code class="docutils literal notranslate"><span class="pre">scale</span></code> (use
ReverseTime() if you want to also negate time). The resulting
polynomial evaluates to pp_after(t) = pp_before(t/scale).</p>
<p>As an example, <a href="#id3"><span class="problematic" id="id4">`</span></a>scale`=2 will result in a trajectory that is twice as
long (start_time() and end_time() have both doubled).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial.setPolynomialMatrixBlock(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial,</span> <span class="pre">replacement:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]],</span> <span class="pre">segment_index:</span> <span class="pre">int,</span> <span class="pre">row_start:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">col_start:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Replaces the specified block of the PolynomialMatrix at the given
segment index.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calls PiecewiseTrajectory&lt;T&gt;::segment_number_range_check() to
validate <code class="docutils literal notranslate"><span class="pre">segment_index</span></code>.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This code relies upon Eigen to verify that the replacement block
is not too large.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial.shiftRight(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial,</span> <span class="pre">offset:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Adds <code class="docutils literal notranslate"><span class="pre">offset</span></code> to all of the breaks. <code class="docutils literal notranslate"><span class="pre">offset</span></code> need not be a
non-negative number. The resulting polynomial will evaluate to
pp_after(t) = pp_before(t-offset).</p>
<p>As an example, <a href="#id5"><span class="problematic" id="id6">`</span></a>offset`=2 will result in the start_time() and
end_time() being 2 seconds later.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial.slice(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial,</span> <span class="pre">start_segment_index:</span> <span class="pre">int,</span> <span class="pre">num_segments:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial</span></span></dt>
<dd><p>Returns the PiecewisePolynomial comprising the <code class="docutils literal notranslate"><span class="pre">num_segments</span></code>
segments starting at the specified <code class="docutils literal notranslate"><span class="pre">start_segment_index</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calls PiecewiseTrajectory&lt;T&gt;::segment_number_range_check() to
validate <code class="docutils literal notranslate"><span class="pre">segment_index</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial.Transpose(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial</span></span></dt>
<dd><p>Constructs a new PiecewisePolynomial for which value(t) ==
this.value(t).transpose().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial.ZeroOrderHold(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>ZeroOrderHold(breaks: list[float], samples: list[list[float]]) -&gt; pydrake.trajectories.PiecewisePolynomial</p></li>
</ol>
<p>Version of ZeroOrderHold(breaks, samples) that uses vector samples and
<code class="docutils literal notranslate"><span class="pre">Eigen::VectorX&lt;T&gt;/MatrixX&lt;T&gt;</span></code> arguments. Each column of <code class="docutils literal notranslate"><span class="pre">samples</span></code>
represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>ZeroOrderHold(breaks: list[float], samples: list[numpy.ndarray[numpy.float64[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial</p></li>
</ol>
<p>Constructs a piecewise constant PiecewisePolynomial using matrix
samples. Note that constructing a PiecewisePolynomial requires at
least two sample points, although in this case, the second sample
point’s value is ignored, and only its break time is used.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewisePolynomial_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewisePolynomial_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewisePolynomial_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd]</span></code></p>
<p>A scalar multi-variate piecewise polynomial.</p>
<p>PiecewisePolynomial represents a list of contiguous segments in a
scalar independent variable (typically corresponding to time) with
Polynomials defined at each segment. We call the output from
evaluating the PiecewisePolynomial at the scalar independent variable
“the output”, and that output can be either a Eigen MatrixX&lt;T&gt; (if
evaluated using value()) or a scalar (if evaluated using
scalar_value()).</p>
<p>An example of a piecewise polynomial is a function of m segments in
time, where a different polynomial is defined for each segment. For a
specific example, consider the absolute value function over the
interval [-1, 1]. We can define a PiecewisePolynomial over this
interval using breaks at t = { -1.0, 0.0, 1.0 }, and “samples” of
abs(t).</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Construct the PiecewisePolynomial.</span>
<span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">breaks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">-1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span><span class="o">&gt;</span><span class="w"> </span><span class="n">samples</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">breaks</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">resize</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">  </span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">breaks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">pp</span><span class="w"> </span><span class="o">=</span>
<span class="w">     </span><span class="n">PiecewisePolynomial</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">FirstOrderHold</span><span class="p">(</span><span class="n">breaks</span><span class="p">,</span><span class="w"> </span><span class="n">samples</span><span class="p">);</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="c1">// Evaluate the PiecewisePolynomial at some values.</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pp</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="mf">-.5</span><span class="p">)(</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w">    </span><span class="c1">// Outputs 0.5.</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pp</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)(</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w">    </span><span class="c1">// Outputs 0.0;</span>

<span class="c1">// Show how we can evaluate the first derivative (outputs -1.0).</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pp</span><span class="p">.</span><span class="n">derivative</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">value</span><span class="p">(</span><span class="mf">-.5</span><span class="p">)(</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
</details><p>A note on terminology. For piecewise-polynomial interpolation, we use
<code class="docutils literal notranslate"><span class="pre">breaks</span></code> to indicate the scalar (e.g. times) which form the boundary
of each segment. We use <code class="docutils literal notranslate"><span class="pre">samples</span></code> to indicate the function value at
the <code class="docutils literal notranslate"><span class="pre">breaks</span></code>, e.g. <code class="docutils literal notranslate"><span class="pre">p(breaks[i])</span> <span class="pre">=</span> <span class="pre">samples[i]</span></code>. The term <code class="docutils literal notranslate"><span class="pre">knot</span></code>
should be reserved for the “(x,y)” coordinate, here <code class="docutils literal notranslate"><span class="pre">knot[i]</span> <span class="pre">=</span>
<span class="pre">(breaks[i],</span> <span class="pre">samples[i])</span></code>, though it is used inconsistently in the
interpolation literature (sometimes for <code class="docutils literal notranslate"><span class="pre">breaks</span></code>, sometimes for
<code class="docutils literal notranslate"><span class="pre">samples</span></code>), so we try to mostly avoid it here.</p>
<p>PiecewisePolynomial objects can be added, subtracted, and multiplied.
They cannot be divided because Polynomials are not closed under
division.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>PiecewisePolynomial silently clips input evaluations outside of
the range defined by the breaks. So <code class="docutils literal notranslate"><span class="pre">pp.value(-2.0,</span> <span class="pre">row,</span> <span class="pre">col)</span></code>
in the example above would evaluate to -1.0. See value().</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Constructs an empty piecewise polynomial.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd], arg0: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; None</p></li>
</ol>
<p>Single segment, constant value constructor over the interval [-∞, ∞].
The constructed PiecewisePolynomial will return <code class="docutils literal notranslate"><span class="pre">constant_value</span></code> at
every evaluated point (i.e., <code class="docutils literal notranslate"><span class="pre">value(t)</span> <span class="pre">=</span> <span class="pre">constant_value</span></code> ∀t ∈ [-∞,
∞]).</p>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd], arg0: list[numpy.ndarray[object[m, n]]], arg1: list[pydrake.autodiffutils.AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Constructs a PiecewisePolynomial using matrix-output Polynomials
defined over each segment.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">polynomials.size()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span> <span class="pre">-</span> <span class="pre">1</span></code></p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd], arg0: list[pydrake.polynomial.Polynomial_[AutoDiffXd]], arg1: list[pydrake.autodiffutils.AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Constructs a PiecewisePolynomial using scalar-output Polynomials
defined over each segment.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">polynomials.size()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span> <span class="pre">-</span> <span class="pre">1</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[AutoDiffXd].AppendCubicHermiteSegment(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd],</span> <span class="pre">time:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">sample:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous],</span> <span class="pre">sample_dot:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>The CubicHermite spline construction has a nice property of being
incremental (each segment can be solved independently). Given a new
sample and it’s derivative, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code> where the start sample and derivative are taken as the value
and derivative at the final break of <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> is not empty()</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">time</span></code> &gt; end_time()</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">sample</span></code> and <code class="docutils literal notranslate"><span class="pre">sample_dot</span></code> must have size rows() x cols().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[AutoDiffXd].AppendFirstOrderSegment(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd],</span> <span class="pre">time:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">sample:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Given a new sample, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code> using a first-order hold, where the start sample is taken as
the value at the final break of <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[AutoDiffXd].Block(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd],</span> <span class="pre">start_row:</span> <span class="pre">int,</span> <span class="pre">start_col:</span> <span class="pre">int,</span> <span class="pre">block_rows:</span> <span class="pre">int,</span> <span class="pre">block_cols:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</span></span></dt>
<dd><p>Extracts a trajectory representing a block of size (block_rows,
block_cols) starting at (start_row, start_col) from the
PiecewisePolynomial.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a PiecewisePolynomial such that ret.value(t) =
this.value(t).block(i,j,p,q);</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[AutoDiffXd].ConcatenateInTime(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd],</span> <span class="pre">other:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Concatenates <code class="docutils literal notranslate"><span class="pre">other</span></code> to the end of <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The resulting PiecewisePolynomial will only be continuous to the
degree that the first Polynomial of <code class="docutils literal notranslate"><span class="pre">other</span></code> is continuous with
the last Polynomial of <code class="docutils literal notranslate"><span class="pre">this</span></code>. See warning about evaluating
discontinuous derivatives at breaks in derivative().</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other</span></code>:</dt><dd><p>PiecewisePolynomial instance to concatenate.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if trajectories' dimensions do not match each other</strong> – </p></li>
<li><p><strong>(</strong><strong>either rows</strong><strong>(</strong><strong>) or </strong><strong>cols</strong><strong>(</strong><strong>) </strong><strong>does not match between this and</strong> – </p></li>
<li><p><strong>other`</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if this-&gt;end_time</strong><strong>(</strong><strong>) </strong><strong>and other-&gt;start_time</strong><strong>(</strong><strong>)</strong> – </p></li>
<li><p><strong>are not within PiecewiseTrajectory&lt;T&gt;::kEpsilonTime from each</strong> – </p></li>
<li><p><strong>other.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[AutoDiffXd].CubicHermite(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CubicHermite(breaks: list[pydrake.autodiffutils.AutoDiffXd], samples: list[list[pydrake.autodiffutils.AutoDiffXd]], samples_dot: list[list[pydrake.autodiffutils.AutoDiffXd]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</p></li>
</ol>
<p>Version of CubicHermite(breaks, samples, samples_dot) that uses vector
samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Corresponding
columns of <code class="docutils literal notranslate"><span class="pre">samples</span></code> and <code class="docutils literal notranslate"><span class="pre">samples_dot</span></code> are used as the sample
point and independent variable derivative, respectively.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">samples_dot.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>CubicHermite(breaks: list[pydrake.autodiffutils.AutoDiffXd], samples: list[numpy.ndarray[object[m, n]]], samples_dot: list[numpy.ndarray[object[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</p></li>
</ol>
<p>Constructs a third order PiecewisePolynomial using matrix samples and
derivatives of samples (<code class="docutils literal notranslate"><span class="pre">samples_dot</span></code>); each matrix element of
<code class="docutils literal notranslate"><span class="pre">samples_dot</span></code> represents the derivative with respect to the
independent variable (e.g., the time derivative) of the corresponding
entry in <code class="docutils literal notranslate"><span class="pre">samples</span></code>. Each segment is fully specified by <code class="docutils literal notranslate"><span class="pre">samples</span></code>
and <code class="docutils literal notranslate"><span class="pre">sample_dot</span></code> at both ends. Second derivatives are not
continuous.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[AutoDiffXd].CubicShapePreserving(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CubicShapePreserving(breaks: list[pydrake.autodiffutils.AutoDiffXd], samples: list[list[pydrake.autodiffutils.AutoDiffXd]], zero_end_point_derivatives: bool = False) -&gt; pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</p></li>
</ol>
<p>Version of CubicShapePreserving(breaks, samples,
zero_end_point_derivatives) that uses vector samples and Eigen
VectorXd and MatrixX&lt;T&gt; arguments. Each column of <code class="docutils literal notranslate"><span class="pre">samples</span></code>
represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>CubicShapePreserving(breaks: list[pydrake.autodiffutils.AutoDiffXd], samples: list[numpy.ndarray[object[m, n]]], zero_end_point_derivatives: bool = False) -&gt; pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</p></li>
</ol>
<p>Constructs a third order PiecewisePolynomial using vector samples,
where each column of <code class="docutils literal notranslate"><span class="pre">samples</span></code> represents a sample point. First
derivatives are chosen to be “shape preserving”, i.e. if <code class="docutils literal notranslate"><span class="pre">samples</span></code>
is monotonic within some interval, the interpolated data will also be
monotonic. The second derivative is not guaranteed to be smooth across
the entire spline.</p>
<p>MATLAB calls this method “pchip” (short for “Piecewise Cubic Hermite
Interpolating Polynomial”), and provides a nice description in their
documentation.
<a class="reference external" href="http://home.uchicago.edu/~sctchoi/courses/cs138/interp.pdf">http://home.uchicago.edu/~sctchoi/courses/cs138/interp.pdf</a> is also a
good reference.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, the first and last
first derivative is chosen using a non-centered, shape-preserving
three-point formulae. See equation (2.10) in the following reference
for more details. <a class="reference external" href="http://www.mi.sanu.ac.rs/~gvm/radovi/mon.pdf">http://www.mi.sanu.ac.rs/~gvm/radovi/mon.pdf</a> If
<code class="docutils literal notranslate"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, they are set to zeros.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, <cite>breaks</cite> and
<code class="docutils literal notranslate"><span class="pre">samples</span></code> must have at least 3 elements for the algorithm to
determine the first derivatives.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, <cite>breaks</cite> and
<code class="docutils literal notranslate"><span class="pre">samples</span></code> may have 2 or more elements. For the 2 elements case, the
result is equivalent to computing a cubic polynomial whose values are
given by <code class="docutils literal notranslate"><span class="pre">samples</span></code>, and derivatives set to zero.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if</strong> – <ul>
<li><p><code class="docutils literal notranslate"><span class="pre">breaks</span></code> has length smaller than 3 and</p></li>
</ul>
</p></li>
<li><p><strong>zero_end_point_derivatives` is False</strong><strong>, </strong><strong>- breaks has lengt</strong> – </p></li>
<li><p><strong>smaller than 2 and zero_end_point_derivatives is true.</strong> – </p></li>
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[AutoDiffXd].CubicWithContinuousSecondDerivatives(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CubicWithContinuousSecondDerivatives(breaks: list[pydrake.autodiffutils.AutoDiffXd], samples: list[list[pydrake.autodiffutils.AutoDiffXd]], sample_dot_at_start: numpy.ndarray[object[m, n]], sample_dot_at_end: numpy.ndarray[object[m, n]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</p></li>
</ol>
<p>Version of CubicWithContinuousSecondDerivatives() that uses vector
samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each column of
<code class="docutils literal notranslate"><span class="pre">samples</span></code> represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>CubicWithContinuousSecondDerivatives(breaks: list[pydrake.autodiffutils.AutoDiffXd], samples: list[numpy.ndarray[object[m, n]]], sample_dot_at_start: numpy.ndarray[object[m, n]], sample_dot_at_end: numpy.ndarray[object[m, n]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</p></li>
</ol>
<p>Constructs a third order PiecewisePolynomial using matrix samples. The
PiecewisePolynomial is constructed such that the interior segments
have the same value, first and second derivatives at <code class="docutils literal notranslate"><span class="pre">breaks</span></code>.
<cite>sample_dot_at_start</cite> and <code class="docutils literal notranslate"><span class="pre">sample_dot_at_end</span></code> are used for the first
and last first derivatives.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if sample_dot_at_start</strong><strong> or </strong><strong>sample_dot_at_end</strong> – </p></li>
<li><p><strong>and samples have inconsistent dimensions.</strong> – </p></li>
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>CubicWithContinuousSecondDerivatives(breaks: list[pydrake.autodiffutils.AutoDiffXd], samples: list[list[pydrake.autodiffutils.AutoDiffXd]], periodic_end_condition: bool = False) -&gt; pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</p></li>
</ol>
<p>Version of CubicWithContinuousSecondDerivatives(breaks, samples) that
uses vector samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each
column of <code class="docutils literal notranslate"><span class="pre">samples</span></code> represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>CubicWithContinuousSecondDerivatives(breaks: list[pydrake.autodiffutils.AutoDiffXd], samples: list[numpy.ndarray[object[m, n]]], periodic_end: bool) -&gt; pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</p></li>
</ol>
<p>Constructs a third order PiecewisePolynomial using matrix samples. The
PiecewisePolynomial is constructed such that the interior segments
have the same value, first and second derivatives at <code class="docutils literal notranslate"><span class="pre">breaks</span></code>. If
<code class="docutils literal notranslate"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code> (default), then the
“Not-a-sample” end condition is used here, which means the third
derivatives are continuous for the first two and last two segments. If
<code class="docutils literal notranslate"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, then the first and second
derivatives between the end of the last segment and the beginning of
the first segment will be continuous. Note that the periodic end
condition does not require the first and last sample to be collocated,
nor does it add an additional sample to connect the first and last
segments. Only first and second derivative continuity is enforced. See
<a class="reference external" href="https://en.wikipedia.org/wiki/Spline_interpolation">https://en.wikipedia.org/wiki/Spline_interpolation</a> and
<a class="reference external" href="https://web.archive.org/web/20140125011904/https://www.math.uh.edu/~jingqiu/math4364/spline.pdf">https://web.archive.org/web/20140125011904/https://www.math.uh.edu/~jingqiu/math4364/spline.pdf</a>
for more about cubic splines and their end conditions. The MATLAB docs
for methods “spline” and “csape” are also good references.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">breaks</span></code> and <code class="docutils literal notranslate"><span class="pre">samples</span></code> must have at least 3 elements. If
<code class="docutils literal notranslate"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, then for two samples, it
would produce a straight line (use <code class="docutils literal notranslate"><span class="pre">FirstOrderHold</span></code> for this
instead), and if <code class="docutils literal notranslate"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code> the
problem is ill-defined.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[AutoDiffXd].derivative(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd],</span> <span class="pre">derivative_order:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">1)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</span></span></dt>
<dd><p>Returns a PiecewisePolynomial where each segment is the specified
derivative of the corresponding segment in <code class="docutils literal notranslate"><span class="pre">this</span></code>. Any rules or
limitations of Polynomial::derivative() also apply to this function.</p>
<p>Derivatives evaluated at non-differentiable points return the value at
the left hand side of the interval.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code>:</dt><dd><p>The order of the derivative, namely, if <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code> = n,
the n’th derivative of the polynomial will be returned.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In the event of discontinuous derivatives evaluated at breaks, it
is not defined which polynomial (i.e., to the left or right of the
break) will be the one that is evaluated at the break.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[AutoDiffXd].FirstOrderHold(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>FirstOrderHold(breaks: list[pydrake.autodiffutils.AutoDiffXd], samples: list[list[pydrake.autodiffutils.AutoDiffXd]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</p></li>
</ol>
<p>Version of FirstOrderHold(breaks, samples) that uses vector samples
and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each column of <code class="docutils literal notranslate"><span class="pre">samples</span></code>
represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>FirstOrderHold(breaks: list[pydrake.autodiffutils.AutoDiffXd], samples: list[numpy.ndarray[object[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</p></li>
</ol>
<p>Constructs a piecewise linear PiecewisePolynomial using matrix
samples.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[AutoDiffXd].getPolynomial(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd],</span> <span class="pre">segment_index:</span> <span class="pre">int,</span> <span class="pre">row:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">col:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.polynomial.Polynomial_[AutoDiffXd]</span></span></dt>
<dd><p>Gets the Polynomial with the given matrix row and column index that
corresponds to the given segment index. Equivalent to
<code class="docutils literal notranslate"><span class="pre">getPolynomialMatrix(segment_index)(row,</span> <span class="pre">col)</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calls PiecewiseTrajectory&lt;T&gt;::segment_number_range_check() to
validate <code class="docutils literal notranslate"><span class="pre">segment_index</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[AutoDiffXd].getPolynomialMatrix(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd],</span> <span class="pre">segment_index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>Gets the matrix of Polynomials corresponding to the given segment
index.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><code class="docutils literal notranslate"><span class="pre">segment_index</span></code> is not checked for validity.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[AutoDiffXd].getSegmentPolynomialDegree(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd],</span> <span class="pre">segment_index:</span> <span class="pre">int,</span> <span class="pre">row:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">col:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Gets the degree of the Polynomial with the given matrix row and column
index that corresponds to the given segment index. Equivalent to
<code class="docutils literal notranslate"><span class="pre">getPolynomial(segment_index,</span> <span class="pre">row,</span> <span class="pre">col).GetDegree()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[AutoDiffXd].isApprox(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd],</span> <span class="pre">other:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd],</span> <span class="pre">tol:</span> <span class="pre">float,</span> <span class="pre">tol_type:</span> <span class="pre">pydrake.common.ToleranceType</span> <span class="pre">=</span> <span class="pre">&lt;ToleranceType.kRelative:</span> <span class="pre">1&gt;)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Checks whether a PiecewisePolynomial is approximately equal to this
one by calling Polynomial&lt;T&gt;::CoefficientsAlmostEqual() on every
element of every segment.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Polynomial&lt;T&gt;::CoefficientsAlmostEqual().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[AutoDiffXd].LagrangeInterpolatingPolynomial(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>LagrangeInterpolatingPolynomial(times: list[pydrake.autodiffutils.AutoDiffXd], samples: list[list[pydrake.autodiffutils.AutoDiffXd]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</p></li>
</ol>
<p>Version of LagrangeInterpolatingPolynomial(times, samples) that uses
vector samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each column
of <code class="docutils literal notranslate"><span class="pre">samples</span></code> represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">times.size()</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>LagrangeInterpolatingPolynomial(times: list[pydrake.autodiffutils.AutoDiffXd], samples: list[numpy.ndarray[object[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</p></li>
</ol>
<p>Constructs a polynomial with a <em>single segment</em> of the lowest possible
degree that passes through all of the sample points. See “polynomial
interpolation” and/or “Lagrange polynomial” on Wikipedia for more
information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">times</span></code> must be monotonically increasing.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.size()</span> <span class="pre">==</span> <span class="pre">times.size()</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[AutoDiffXd].RemoveFinalSegment(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Removes the final segment from the trajectory, reducing the number of
segments by 1.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> is not empty()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[AutoDiffXd].Reshape(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd],</span> <span class="pre">rows:</span> <span class="pre">int,</span> <span class="pre">cols:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Reshapes the dimensions of the Eigen::MatrixX&lt;T&gt; returned by value(),
EvalDerivative(), etc.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">rows</span></code> x <code class="docutils literal notranslate"><span class="pre">cols</span></code> must equal this.rows() * this.cols().</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Eigen::PlainObjectBase::resize().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[AutoDiffXd].ReverseTime(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Modifies the trajectory so that pp_after(t) = pp_before(-t).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The new trajectory will evaluate differently at precisely the
break points if the original trajectory was discontinuous at the
break points. This is because the segments are defined on the
half-open intervals [breaks(i), breaks(i+1)), and the order of the
breaks have been reversed.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[AutoDiffXd].ScaleTime(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd],</span> <span class="pre">scale:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Scales the time of the trajectory by non-negative <code class="docutils literal notranslate"><span class="pre">scale</span></code> (use
ReverseTime() if you want to also negate time). The resulting
polynomial evaluates to pp_after(t) = pp_before(t/scale).</p>
<p>As an example, <a href="#id7"><span class="problematic" id="id8">`</span></a>scale`=2 will result in a trajectory that is twice as
long (start_time() and end_time() have both doubled).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[AutoDiffXd].setPolynomialMatrixBlock(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd],</span> <span class="pre">replacement:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]],</span> <span class="pre">segment_index:</span> <span class="pre">int,</span> <span class="pre">row_start:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">col_start:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Replaces the specified block of the PolynomialMatrix at the given
segment index.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calls PiecewiseTrajectory&lt;T&gt;::segment_number_range_check() to
validate <code class="docutils literal notranslate"><span class="pre">segment_index</span></code>.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This code relies upon Eigen to verify that the replacement block
is not too large.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[AutoDiffXd].shiftRight(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd],</span> <span class="pre">offset:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Adds <code class="docutils literal notranslate"><span class="pre">offset</span></code> to all of the breaks. <code class="docutils literal notranslate"><span class="pre">offset</span></code> need not be a
non-negative number. The resulting polynomial will evaluate to
pp_after(t) = pp_before(t-offset).</p>
<p>As an example, <a href="#id9"><span class="problematic" id="id10">`</span></a>offset`=2 will result in the start_time() and
end_time() being 2 seconds later.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[AutoDiffXd].slice(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd],</span> <span class="pre">start_segment_index:</span> <span class="pre">int,</span> <span class="pre">num_segments:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</span></span></dt>
<dd><p>Returns the PiecewisePolynomial comprising the <code class="docutils literal notranslate"><span class="pre">num_segments</span></code>
segments starting at the specified <code class="docutils literal notranslate"><span class="pre">start_segment_index</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calls PiecewiseTrajectory&lt;T&gt;::segment_number_range_check() to
validate <code class="docutils literal notranslate"><span class="pre">segment_index</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[AutoDiffXd].Transpose(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</span></span></dt>
<dd><p>Constructs a new PiecewisePolynomial for which value(t) ==
this.value(t).transpose().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[AutoDiffXd].ZeroOrderHold(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>ZeroOrderHold(breaks: list[pydrake.autodiffutils.AutoDiffXd], samples: list[list[pydrake.autodiffutils.AutoDiffXd]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</p></li>
</ol>
<p>Version of ZeroOrderHold(breaks, samples) that uses vector samples and
<code class="docutils literal notranslate"><span class="pre">Eigen::VectorX&lt;T&gt;/MatrixX&lt;T&gt;</span></code> arguments. Each column of <code class="docutils literal notranslate"><span class="pre">samples</span></code>
represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>ZeroOrderHold(breaks: list[pydrake.autodiffutils.AutoDiffXd], samples: list[numpy.ndarray[object[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</p></li>
</ol>
<p>Constructs a piecewise constant PiecewisePolynomial using matrix
samples. Note that constructing a PiecewisePolynomial requires at
least two sample points, although in this case, the second sample
point’s value is ignored, and only its break time is used.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_[Expression]</span></code></p>
<p>A scalar multi-variate piecewise polynomial.</p>
<p>PiecewisePolynomial represents a list of contiguous segments in a
scalar independent variable (typically corresponding to time) with
Polynomials defined at each segment. We call the output from
evaluating the PiecewisePolynomial at the scalar independent variable
“the output”, and that output can be either a Eigen MatrixX&lt;T&gt; (if
evaluated using value()) or a scalar (if evaluated using
scalar_value()).</p>
<p>An example of a piecewise polynomial is a function of m segments in
time, where a different polynomial is defined for each segment. For a
specific example, consider the absolute value function over the
interval [-1, 1]. We can define a PiecewisePolynomial over this
interval using breaks at t = { -1.0, 0.0, 1.0 }, and “samples” of
abs(t).</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Construct the PiecewisePolynomial.</span>
<span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">breaks</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="mf">-1.0</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="o">::</span><span class="n">MatrixXd</span><span class="o">&gt;</span><span class="w"> </span><span class="n">samples</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">breaks</span><span class="p">.</span><span class="n">size</span><span class="p">());</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">resize</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">  </span><span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">abs</span><span class="p">(</span><span class="n">breaks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
<span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="w"> </span><span class="n">pp</span><span class="w"> </span><span class="o">=</span>
<span class="w">     </span><span class="n">PiecewisePolynomial</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;::</span><span class="n">FirstOrderHold</span><span class="p">(</span><span class="n">breaks</span><span class="p">,</span><span class="w"> </span><span class="n">samples</span><span class="p">);</span>
<span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="c1">// Evaluate the PiecewisePolynomial at some values.</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pp</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="mf">-.5</span><span class="p">)(</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w">    </span><span class="c1">// Outputs 0.5.</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pp</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)(</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span><span class="w">    </span><span class="c1">// Outputs 0.0;</span>

<span class="c1">// Show how we can evaluate the first derivative (outputs -1.0).</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pp</span><span class="p">.</span><span class="n">derivative</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">value</span><span class="p">(</span><span class="mf">-.5</span><span class="p">)(</span><span class="n">row</span><span class="p">,</span><span class="w"> </span><span class="n">col</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
</details><p>A note on terminology. For piecewise-polynomial interpolation, we use
<code class="docutils literal notranslate"><span class="pre">breaks</span></code> to indicate the scalar (e.g. times) which form the boundary
of each segment. We use <code class="docutils literal notranslate"><span class="pre">samples</span></code> to indicate the function value at
the <code class="docutils literal notranslate"><span class="pre">breaks</span></code>, e.g. <code class="docutils literal notranslate"><span class="pre">p(breaks[i])</span> <span class="pre">=</span> <span class="pre">samples[i]</span></code>. The term <code class="docutils literal notranslate"><span class="pre">knot</span></code>
should be reserved for the “(x,y)” coordinate, here <code class="docutils literal notranslate"><span class="pre">knot[i]</span> <span class="pre">=</span>
<span class="pre">(breaks[i],</span> <span class="pre">samples[i])</span></code>, though it is used inconsistently in the
interpolation literature (sometimes for <code class="docutils literal notranslate"><span class="pre">breaks</span></code>, sometimes for
<code class="docutils literal notranslate"><span class="pre">samples</span></code>), so we try to mostly avoid it here.</p>
<p>PiecewisePolynomial objects can be added, subtracted, and multiplied.
They cannot be divided because Polynomials are not closed under
division.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>PiecewisePolynomial silently clips input evaluations outside of
the range defined by the breaks. So <code class="docutils literal notranslate"><span class="pre">pp.value(-2.0,</span> <span class="pre">row,</span> <span class="pre">col)</span></code>
in the example above would evaluate to -1.0. See value().</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.PiecewisePolynomial_[Expression]) -&gt; None</p></li>
</ol>
<p>Constructs an empty piecewise polynomial.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.trajectories.PiecewisePolynomial_[Expression], arg0: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; None</p></li>
</ol>
<p>Single segment, constant value constructor over the interval [-∞, ∞].
The constructed PiecewisePolynomial will return <code class="docutils literal notranslate"><span class="pre">constant_value</span></code> at
every evaluated point (i.e., <code class="docutils literal notranslate"><span class="pre">value(t)</span> <span class="pre">=</span> <span class="pre">constant_value</span></code> ∀t ∈ [-∞,
∞]).</p>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.trajectories.PiecewisePolynomial_[Expression], arg0: list[numpy.ndarray[object[m, n]]], arg1: list[pydrake.symbolic.Expression]) -&gt; None</p></li>
</ol>
<p>Constructs a PiecewisePolynomial using matrix-output Polynomials
defined over each segment.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">polynomials.size()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span> <span class="pre">-</span> <span class="pre">1</span></code></p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.trajectories.PiecewisePolynomial_[Expression], arg0: list[pydrake.polynomial.Polynomial_[Expression]], arg1: list[pydrake.symbolic.Expression]) -&gt; None</p></li>
</ol>
<p>Constructs a PiecewisePolynomial using scalar-output Polynomials
defined over each segment.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">polynomials.size()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span> <span class="pre">-</span> <span class="pre">1</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[Expression].AppendCubicHermiteSegment(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[Expression],</span> <span class="pre">time:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">sample:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous],</span> <span class="pre">sample_dot:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>The CubicHermite spline construction has a nice property of being
incremental (each segment can be solved independently). Given a new
sample and it’s derivative, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code> where the start sample and derivative are taken as the value
and derivative at the final break of <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> is not empty()</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">time</span></code> &gt; end_time()</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">sample</span></code> and <code class="docutils literal notranslate"><span class="pre">sample_dot</span></code> must have size rows() x cols().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[Expression].AppendFirstOrderSegment(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[Expression],</span> <span class="pre">time:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">sample:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Given a new sample, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code> using a first-order hold, where the start sample is taken as
the value at the final break of <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[Expression].Block(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[Expression],</span> <span class="pre">start_row:</span> <span class="pre">int,</span> <span class="pre">start_col:</span> <span class="pre">int,</span> <span class="pre">block_rows:</span> <span class="pre">int,</span> <span class="pre">block_cols:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[Expression]</span></span></dt>
<dd><p>Extracts a trajectory representing a block of size (block_rows,
block_cols) starting at (start_row, start_col) from the
PiecewisePolynomial.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a PiecewisePolynomial such that ret.value(t) =
this.value(t).block(i,j,p,q);</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[Expression].ConcatenateInTime(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[Expression],</span> <span class="pre">other:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Concatenates <code class="docutils literal notranslate"><span class="pre">other</span></code> to the end of <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The resulting PiecewisePolynomial will only be continuous to the
degree that the first Polynomial of <code class="docutils literal notranslate"><span class="pre">other</span></code> is continuous with
the last Polynomial of <code class="docutils literal notranslate"><span class="pre">this</span></code>. See warning about evaluating
discontinuous derivatives at breaks in derivative().</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other</span></code>:</dt><dd><p>PiecewisePolynomial instance to concatenate.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if trajectories' dimensions do not match each other</strong> – </p></li>
<li><p><strong>(</strong><strong>either rows</strong><strong>(</strong><strong>) or </strong><strong>cols</strong><strong>(</strong><strong>) </strong><strong>does not match between this and</strong> – </p></li>
<li><p><strong>other`</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if this-&gt;end_time</strong><strong>(</strong><strong>) </strong><strong>and other-&gt;start_time</strong><strong>(</strong><strong>)</strong> – </p></li>
<li><p><strong>are not within PiecewiseTrajectory&lt;T&gt;::kEpsilonTime from each</strong> – </p></li>
<li><p><strong>other.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[Expression].CubicHermite(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CubicHermite(breaks: list[pydrake.symbolic.Expression], samples: list[list[pydrake.symbolic.Expression]], samples_dot: list[list[pydrake.symbolic.Expression]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[Expression]</p></li>
</ol>
<p>Version of CubicHermite(breaks, samples, samples_dot) that uses vector
samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Corresponding
columns of <code class="docutils literal notranslate"><span class="pre">samples</span></code> and <code class="docutils literal notranslate"><span class="pre">samples_dot</span></code> are used as the sample
point and independent variable derivative, respectively.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">samples_dot.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>CubicHermite(breaks: list[pydrake.symbolic.Expression], samples: list[numpy.ndarray[object[m, n]]], samples_dot: list[numpy.ndarray[object[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[Expression]</p></li>
</ol>
<p>Constructs a third order PiecewisePolynomial using matrix samples and
derivatives of samples (<code class="docutils literal notranslate"><span class="pre">samples_dot</span></code>); each matrix element of
<code class="docutils literal notranslate"><span class="pre">samples_dot</span></code> represents the derivative with respect to the
independent variable (e.g., the time derivative) of the corresponding
entry in <code class="docutils literal notranslate"><span class="pre">samples</span></code>. Each segment is fully specified by <code class="docutils literal notranslate"><span class="pre">samples</span></code>
and <code class="docutils literal notranslate"><span class="pre">sample_dot</span></code> at both ends. Second derivatives are not
continuous.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[Expression].CubicShapePreserving(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CubicShapePreserving(breaks: list[pydrake.symbolic.Expression], samples: list[list[pydrake.symbolic.Expression]], zero_end_point_derivatives: bool = False) -&gt; pydrake.trajectories.PiecewisePolynomial_[Expression]</p></li>
</ol>
<p>Version of CubicShapePreserving(breaks, samples,
zero_end_point_derivatives) that uses vector samples and Eigen
VectorXd and MatrixX&lt;T&gt; arguments. Each column of <code class="docutils literal notranslate"><span class="pre">samples</span></code>
represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>CubicShapePreserving(breaks: list[pydrake.symbolic.Expression], samples: list[numpy.ndarray[object[m, n]]], zero_end_point_derivatives: bool = False) -&gt; pydrake.trajectories.PiecewisePolynomial_[Expression]</p></li>
</ol>
<p>Constructs a third order PiecewisePolynomial using vector samples,
where each column of <code class="docutils literal notranslate"><span class="pre">samples</span></code> represents a sample point. First
derivatives are chosen to be “shape preserving”, i.e. if <code class="docutils literal notranslate"><span class="pre">samples</span></code>
is monotonic within some interval, the interpolated data will also be
monotonic. The second derivative is not guaranteed to be smooth across
the entire spline.</p>
<p>MATLAB calls this method “pchip” (short for “Piecewise Cubic Hermite
Interpolating Polynomial”), and provides a nice description in their
documentation.
<a class="reference external" href="http://home.uchicago.edu/~sctchoi/courses/cs138/interp.pdf">http://home.uchicago.edu/~sctchoi/courses/cs138/interp.pdf</a> is also a
good reference.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, the first and last
first derivative is chosen using a non-centered, shape-preserving
three-point formulae. See equation (2.10) in the following reference
for more details. <a class="reference external" href="http://www.mi.sanu.ac.rs/~gvm/radovi/mon.pdf">http://www.mi.sanu.ac.rs/~gvm/radovi/mon.pdf</a> If
<code class="docutils literal notranslate"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, they are set to zeros.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, <cite>breaks</cite> and
<code class="docutils literal notranslate"><span class="pre">samples</span></code> must have at least 3 elements for the algorithm to
determine the first derivatives.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, <cite>breaks</cite> and
<code class="docutils literal notranslate"><span class="pre">samples</span></code> may have 2 or more elements. For the 2 elements case, the
result is equivalent to computing a cubic polynomial whose values are
given by <code class="docutils literal notranslate"><span class="pre">samples</span></code>, and derivatives set to zero.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if</strong> – <ul>
<li><p><code class="docutils literal notranslate"><span class="pre">breaks</span></code> has length smaller than 3 and</p></li>
</ul>
</p></li>
<li><p><strong>zero_end_point_derivatives` is False</strong><strong>, </strong><strong>- breaks has lengt</strong> – </p></li>
<li><p><strong>smaller than 2 and zero_end_point_derivatives is true.</strong> – </p></li>
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[Expression].CubicWithContinuousSecondDerivatives(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CubicWithContinuousSecondDerivatives(breaks: list[pydrake.symbolic.Expression], samples: list[list[pydrake.symbolic.Expression]], sample_dot_at_start: numpy.ndarray[object[m, n]], sample_dot_at_end: numpy.ndarray[object[m, n]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[Expression]</p></li>
</ol>
<p>Version of CubicWithContinuousSecondDerivatives() that uses vector
samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each column of
<code class="docutils literal notranslate"><span class="pre">samples</span></code> represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>CubicWithContinuousSecondDerivatives(breaks: list[pydrake.symbolic.Expression], samples: list[numpy.ndarray[object[m, n]]], sample_dot_at_start: numpy.ndarray[object[m, n]], sample_dot_at_end: numpy.ndarray[object[m, n]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[Expression]</p></li>
</ol>
<p>Constructs a third order PiecewisePolynomial using matrix samples. The
PiecewisePolynomial is constructed such that the interior segments
have the same value, first and second derivatives at <code class="docutils literal notranslate"><span class="pre">breaks</span></code>.
<cite>sample_dot_at_start</cite> and <code class="docutils literal notranslate"><span class="pre">sample_dot_at_end</span></code> are used for the first
and last first derivatives.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if sample_dot_at_start</strong><strong> or </strong><strong>sample_dot_at_end</strong> – </p></li>
<li><p><strong>and samples have inconsistent dimensions.</strong> – </p></li>
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>CubicWithContinuousSecondDerivatives(breaks: list[pydrake.symbolic.Expression], samples: list[list[pydrake.symbolic.Expression]], periodic_end_condition: bool = False) -&gt; pydrake.trajectories.PiecewisePolynomial_[Expression]</p></li>
</ol>
<p>Version of CubicWithContinuousSecondDerivatives(breaks, samples) that
uses vector samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each
column of <code class="docutils literal notranslate"><span class="pre">samples</span></code> represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>CubicWithContinuousSecondDerivatives(breaks: list[pydrake.symbolic.Expression], samples: list[numpy.ndarray[object[m, n]]], periodic_end: bool) -&gt; pydrake.trajectories.PiecewisePolynomial_[Expression]</p></li>
</ol>
<p>Constructs a third order PiecewisePolynomial using matrix samples. The
PiecewisePolynomial is constructed such that the interior segments
have the same value, first and second derivatives at <code class="docutils literal notranslate"><span class="pre">breaks</span></code>. If
<code class="docutils literal notranslate"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code> (default), then the
“Not-a-sample” end condition is used here, which means the third
derivatives are continuous for the first two and last two segments. If
<code class="docutils literal notranslate"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, then the first and second
derivatives between the end of the last segment and the beginning of
the first segment will be continuous. Note that the periodic end
condition does not require the first and last sample to be collocated,
nor does it add an additional sample to connect the first and last
segments. Only first and second derivative continuity is enforced. See
<a class="reference external" href="https://en.wikipedia.org/wiki/Spline_interpolation">https://en.wikipedia.org/wiki/Spline_interpolation</a> and
<a class="reference external" href="https://web.archive.org/web/20140125011904/https://www.math.uh.edu/~jingqiu/math4364/spline.pdf">https://web.archive.org/web/20140125011904/https://www.math.uh.edu/~jingqiu/math4364/spline.pdf</a>
for more about cubic splines and their end conditions. The MATLAB docs
for methods “spline” and “csape” are also good references.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">breaks</span></code> and <code class="docutils literal notranslate"><span class="pre">samples</span></code> must have at least 3 elements. If
<code class="docutils literal notranslate"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, then for two samples, it
would produce a straight line (use <code class="docutils literal notranslate"><span class="pre">FirstOrderHold</span></code> for this
instead), and if <code class="docutils literal notranslate"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code> the
problem is ill-defined.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[Expression].derivative(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[Expression],</span> <span class="pre">derivative_order:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">1)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[Expression]</span></span></dt>
<dd><p>Returns a PiecewisePolynomial where each segment is the specified
derivative of the corresponding segment in <code class="docutils literal notranslate"><span class="pre">this</span></code>. Any rules or
limitations of Polynomial::derivative() also apply to this function.</p>
<p>Derivatives evaluated at non-differentiable points return the value at
the left hand side of the interval.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code>:</dt><dd><p>The order of the derivative, namely, if <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code> = n,
the n’th derivative of the polynomial will be returned.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In the event of discontinuous derivatives evaluated at breaks, it
is not defined which polynomial (i.e., to the left or right of the
break) will be the one that is evaluated at the break.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[Expression].FirstOrderHold(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>FirstOrderHold(breaks: list[pydrake.symbolic.Expression], samples: list[list[pydrake.symbolic.Expression]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[Expression]</p></li>
</ol>
<p>Version of FirstOrderHold(breaks, samples) that uses vector samples
and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each column of <code class="docutils literal notranslate"><span class="pre">samples</span></code>
represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>FirstOrderHold(breaks: list[pydrake.symbolic.Expression], samples: list[numpy.ndarray[object[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[Expression]</p></li>
</ol>
<p>Constructs a piecewise linear PiecewisePolynomial using matrix
samples.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[Expression].getPolynomial(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[Expression],</span> <span class="pre">segment_index:</span> <span class="pre">int,</span> <span class="pre">row:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">col:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.polynomial.Polynomial_[Expression]</span></span></dt>
<dd><p>Gets the Polynomial with the given matrix row and column index that
corresponds to the given segment index. Equivalent to
<code class="docutils literal notranslate"><span class="pre">getPolynomialMatrix(segment_index)(row,</span> <span class="pre">col)</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calls PiecewiseTrajectory&lt;T&gt;::segment_number_range_check() to
validate <code class="docutils literal notranslate"><span class="pre">segment_index</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[Expression].getPolynomialMatrix(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[Expression],</span> <span class="pre">segment_index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>Gets the matrix of Polynomials corresponding to the given segment
index.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><code class="docutils literal notranslate"><span class="pre">segment_index</span></code> is not checked for validity.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[Expression].getSegmentPolynomialDegree(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[Expression],</span> <span class="pre">segment_index:</span> <span class="pre">int,</span> <span class="pre">row:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">col:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Gets the degree of the Polynomial with the given matrix row and column
index that corresponds to the given segment index. Equivalent to
<code class="docutils literal notranslate"><span class="pre">getPolynomial(segment_index,</span> <span class="pre">row,</span> <span class="pre">col).GetDegree()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[Expression].isApprox(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[Expression],</span> <span class="pre">other:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[Expression],</span> <span class="pre">tol:</span> <span class="pre">float,</span> <span class="pre">tol_type:</span> <span class="pre">pydrake.common.ToleranceType</span> <span class="pre">=</span> <span class="pre">&lt;ToleranceType.kRelative:</span> <span class="pre">1&gt;)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Checks whether a PiecewisePolynomial is approximately equal to this
one by calling Polynomial&lt;T&gt;::CoefficientsAlmostEqual() on every
element of every segment.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Polynomial&lt;T&gt;::CoefficientsAlmostEqual().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[Expression].LagrangeInterpolatingPolynomial(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>LagrangeInterpolatingPolynomial(times: list[pydrake.symbolic.Expression], samples: list[list[pydrake.symbolic.Expression]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[Expression]</p></li>
</ol>
<p>Version of LagrangeInterpolatingPolynomial(times, samples) that uses
vector samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each column
of <code class="docutils literal notranslate"><span class="pre">samples</span></code> represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">times.size()</span></code>.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>LagrangeInterpolatingPolynomial(times: list[pydrake.symbolic.Expression], samples: list[numpy.ndarray[object[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[Expression]</p></li>
</ol>
<p>Constructs a polynomial with a <em>single segment</em> of the lowest possible
degree that passes through all of the sample points. See “polynomial
interpolation” and/or “Lagrange polynomial” on Wikipedia for more
information.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">times</span></code> must be monotonically increasing.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.size()</span> <span class="pre">==</span> <span class="pre">times.size()</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[Expression].RemoveFinalSegment(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Removes the final segment from the trajectory, reducing the number of
segments by 1.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">this</span></code> is not empty()</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[Expression].Reshape(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[Expression],</span> <span class="pre">rows:</span> <span class="pre">int,</span> <span class="pre">cols:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Reshapes the dimensions of the Eigen::MatrixX&lt;T&gt; returned by value(),
EvalDerivative(), etc.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">rows</span></code> x <code class="docutils literal notranslate"><span class="pre">cols</span></code> must equal this.rows() * this.cols().</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Eigen::PlainObjectBase::resize().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[Expression].ReverseTime(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Modifies the trajectory so that pp_after(t) = pp_before(-t).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The new trajectory will evaluate differently at precisely the
break points if the original trajectory was discontinuous at the
break points. This is because the segments are defined on the
half-open intervals [breaks(i), breaks(i+1)), and the order of the
breaks have been reversed.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[Expression].ScaleTime(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[Expression],</span> <span class="pre">scale:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Scales the time of the trajectory by non-negative <code class="docutils literal notranslate"><span class="pre">scale</span></code> (use
ReverseTime() if you want to also negate time). The resulting
polynomial evaluates to pp_after(t) = pp_before(t/scale).</p>
<p>As an example, <a href="#id11"><span class="problematic" id="id12">`</span></a>scale`=2 will result in a trajectory that is twice as
long (start_time() and end_time() have both doubled).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[Expression].setPolynomialMatrixBlock(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[Expression],</span> <span class="pre">replacement:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]],</span> <span class="pre">segment_index:</span> <span class="pre">int,</span> <span class="pre">row_start:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">col_start:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Replaces the specified block of the PolynomialMatrix at the given
segment index.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calls PiecewiseTrajectory&lt;T&gt;::segment_number_range_check() to
validate <code class="docutils literal notranslate"><span class="pre">segment_index</span></code>.</p>
</div>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This code relies upon Eigen to verify that the replacement block
is not too large.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[Expression].shiftRight(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[Expression],</span> <span class="pre">offset:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Adds <code class="docutils literal notranslate"><span class="pre">offset</span></code> to all of the breaks. <code class="docutils literal notranslate"><span class="pre">offset</span></code> need not be a
non-negative number. The resulting polynomial will evaluate to
pp_after(t) = pp_before(t-offset).</p>
<p>As an example, <a href="#id13"><span class="problematic" id="id14">`</span></a>offset`=2 will result in the start_time() and
end_time() being 2 seconds later.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[Expression].slice(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[Expression],</span> <span class="pre">start_segment_index:</span> <span class="pre">int,</span> <span class="pre">num_segments:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[Expression]</span></span></dt>
<dd><p>Returns the PiecewisePolynomial comprising the <code class="docutils literal notranslate"><span class="pre">num_segments</span></code>
segments starting at the specified <code class="docutils literal notranslate"><span class="pre">start_segment_index</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Calls PiecewiseTrajectory&lt;T&gt;::segment_number_range_check() to
validate <code class="docutils literal notranslate"><span class="pre">segment_index</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[Expression].Transpose(self:</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[Expression]</span></span></dt>
<dd><p>Constructs a new PiecewisePolynomial for which value(t) ==
this.value(t).transpose().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePolynomial_[Expression].ZeroOrderHold(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>ZeroOrderHold(breaks: list[pydrake.symbolic.Expression], samples: list[list[pydrake.symbolic.Expression]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[Expression]</p></li>
</ol>
<p>Version of ZeroOrderHold(breaks, samples) that uses vector samples and
<code class="docutils literal notranslate"><span class="pre">Eigen::VectorX&lt;T&gt;/MatrixX&lt;T&gt;</span></code> arguments. Each column of <code class="docutils literal notranslate"><span class="pre">samples</span></code>
represents a sample point.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>ZeroOrderHold(breaks: list[pydrake.symbolic.Expression], samples: list[numpy.ndarray[object[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial_[Expression]</p></li>
</ol>
<p>Constructs a piecewise constant PiecewisePolynomial using matrix
samples. Note that constructing a PiecewisePolynomial requires at
least two sample points, although in this case, the second sample
point’s value is ignored, and only its break time is used.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError under the conditions specified under</strong> – </p></li>
<li><p><strong>coefficient_construction_methods.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePose</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PiecewiseTrajectory</span></code></p>
<p>A wrapper class that represents a pose trajectory, whose rotation part
is a PiecewiseQuaternionSlerp and the translation part is a
PiecewisePolynomial.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewisePose_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePose.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.PiecewisePose) -&gt; None</p></li>
</ol>
<p>Constructs an empty piecewise pose trajectory.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.trajectories.PiecewisePose, position_trajectory: pydrake.trajectories.PiecewisePolynomial, orientation_trajectory: pydrake.trajectories.PiecewiseQuaternionSlerp) -&gt; None</p></li>
</ol>
<p>Constructor.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">position_trajectory</span></code>:</dt><dd><p>Position trajectory.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">orientation_trajectory</span></code>:</dt><dd><p>Orientation trajectory.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePose.get_orientation_trajectory(self:</span> <span class="pre">pydrake.trajectories.PiecewisePose)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.PiecewiseQuaternionSlerp</span></span></dt>
<dd><p>Returns the orientation trajectory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePose.get_position_trajectory(self:</span> <span class="pre">pydrake.trajectories.PiecewisePose)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial</span></span></dt>
<dd><p>Returns the position trajectory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePose.GetAcceleration(self:</span> <span class="pre">pydrake.trajectories.PiecewisePose,</span> <span class="pre">time:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[6,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the interpolated acceleration at <code class="docutils literal notranslate"><span class="pre">time</span></code> or zero if <code class="docutils literal notranslate"><span class="pre">time</span></code>
is before this trajectory’s start time or after its end time.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePose.GetPose(self:</span> <span class="pre">pydrake.trajectories.PiecewisePose,</span> <span class="pre">time:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RigidTransform</span></span></dt>
<dd><p>Returns the interpolated pose at <code class="docutils literal notranslate"><span class="pre">time</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePose.GetVelocity(self:</span> <span class="pre">pydrake.trajectories.PiecewisePose,</span> <span class="pre">time:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[6,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the interpolated velocity at <code class="docutils literal notranslate"><span class="pre">time</span></code> or zero if <code class="docutils literal notranslate"><span class="pre">time</span></code> is
before this trajectory’s start time or after its end time.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePose.IsApprox(self:</span> <span class="pre">pydrake.trajectories.PiecewisePose,</span> <span class="pre">other:</span> <span class="pre">pydrake.trajectories.PiecewisePose,</span> <span class="pre">tol:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true if the position and orientation trajectories are both
within <code class="docutils literal notranslate"><span class="pre">tol</span></code> from the other’s.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePose.MakeCubicLinearWithEndLinearVelocity(times:</span> <span class="pre">list[float],</span> <span class="pre">poses:</span> <span class="pre">list[pydrake.math.RigidTransform],</span> <span class="pre">start_vel:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span> <span class="pre">=</span> <span class="pre">array([0.,</span> <span class="pre">0.,</span> <span class="pre">0.]),</span> <span class="pre">end_vel:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span> <span class="pre">=</span> <span class="pre">array([0.,</span> <span class="pre">0.,</span> <span class="pre">0.]))</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.PiecewisePose</span></span></dt>
<dd><p>Constructs a PiecewisePose from given <code class="docutils literal notranslate"><span class="pre">times</span></code> and <code class="docutils literal notranslate"><span class="pre">poses</span></code>. A cubic
polynomial with given end velocities is used to construct the position
part. The rotational part is represented by a piecewise quaterion
trajectory. There must be at least two elements in <code class="docutils literal notranslate"><span class="pre">times</span></code> and
<code class="docutils literal notranslate"><span class="pre">poses</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">times</span></code>:</dt><dd><p>Breaks used to build the splines.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">poses</span></code>:</dt><dd><p>Knots used to build the splines.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">start_vel</span></code>:</dt><dd><p>Start linear velocity.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">end_vel</span></code>:</dt><dd><p>End linear velocity.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePose.MakeLinear(times:</span> <span class="pre">list[float],</span> <span class="pre">poses:</span> <span class="pre">list[pydrake.math.RigidTransform])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.PiecewisePose</span></span></dt>
<dd><p>Constructs a PiecewisePose from given <code class="docutils literal notranslate"><span class="pre">times</span></code> and <code class="docutils literal notranslate"><span class="pre">poses</span></code>. The
positions trajectory is constructed as a first-order hold. The
orientation is constructed using the quaternion slerp. There must be
at least two elements in <code class="docutils literal notranslate"><span class="pre">times</span></code> and <code class="docutils literal notranslate"><span class="pre">poses</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">times</span></code>:</dt><dd><p>Breaks used to build the splines.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">poses</span></code>:</dt><dd><p>Knots used to build the splines.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePose_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewisePose_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewisePose_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewisePose_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePose_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd]</span></code></p>
<p>A wrapper class that represents a pose trajectory, whose rotation part
is a PiecewiseQuaternionSlerp and the translation part is a
PiecewisePolynomial.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePose_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.PiecewisePose_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Constructs an empty piecewise pose trajectory.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.trajectories.PiecewisePose_[AutoDiffXd], position_trajectory: pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd], orientation_trajectory: pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Constructor.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">position_trajectory</span></code>:</dt><dd><p>Position trajectory.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">orientation_trajectory</span></code>:</dt><dd><p>Orientation trajectory.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePose_[AutoDiffXd].get_orientation_trajectory(self:</span> <span class="pre">pydrake.trajectories.PiecewisePose_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd]</span></span></dt>
<dd><p>Returns the orientation trajectory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePose_[AutoDiffXd].get_position_trajectory(self:</span> <span class="pre">pydrake.trajectories.PiecewisePose_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[AutoDiffXd]</span></span></dt>
<dd><p>Returns the position trajectory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePose_[AutoDiffXd].GetAcceleration(self:</span> <span class="pre">pydrake.trajectories.PiecewisePose_[AutoDiffXd],</span> <span class="pre">time:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[6,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the interpolated acceleration at <code class="docutils literal notranslate"><span class="pre">time</span></code> or zero if <code class="docutils literal notranslate"><span class="pre">time</span></code>
is before this trajectory’s start time or after its end time.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePose_[AutoDiffXd].GetPose(self:</span> <span class="pre">pydrake.trajectories.PiecewisePose_[AutoDiffXd],</span> <span class="pre">time:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RigidTransform_[AutoDiffXd]</span></span></dt>
<dd><p>Returns the interpolated pose at <code class="docutils literal notranslate"><span class="pre">time</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePose_[AutoDiffXd].GetVelocity(self:</span> <span class="pre">pydrake.trajectories.PiecewisePose_[AutoDiffXd],</span> <span class="pre">time:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[6,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the interpolated velocity at <code class="docutils literal notranslate"><span class="pre">time</span></code> or zero if <code class="docutils literal notranslate"><span class="pre">time</span></code> is
before this trajectory’s start time or after its end time.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePose_[AutoDiffXd].IsApprox(self:</span> <span class="pre">pydrake.trajectories.PiecewisePose_[AutoDiffXd],</span> <span class="pre">other:</span> <span class="pre">pydrake.trajectories.PiecewisePose_[AutoDiffXd],</span> <span class="pre">tol:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true if the position and orientation trajectories are both
within <code class="docutils literal notranslate"><span class="pre">tol</span></code> from the other’s.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePose_[AutoDiffXd].MakeCubicLinearWithEndLinearVelocity(times:</span> <span class="pre">list[pydrake.autodiffutils.AutoDiffXd],</span> <span class="pre">poses:</span> <span class="pre">list[pydrake.math.RigidTransform_[AutoDiffXd]],</span> <span class="pre">start_vel:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span> <span class="pre">=</span> <span class="pre">array([&lt;AutoDiffXd</span> <span class="pre">0.0</span> <span class="pre">nderiv=0&gt;,</span> <span class="pre">&lt;AutoDiffXd</span> <span class="pre">0.0</span> <span class="pre">nderiv=0&gt;,</span> <span class="pre">&lt;AutoDiffXd</span> <span class="pre">0.0</span> <span class="pre">nderiv=0&gt;],</span> <span class="pre">dtype=object),</span> <span class="pre">end_vel:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span> <span class="pre">=</span> <span class="pre">array([&lt;AutoDiffXd</span> <span class="pre">0.0</span> <span class="pre">nderiv=0&gt;,</span> <span class="pre">&lt;AutoDiffXd</span> <span class="pre">0.0</span> <span class="pre">nderiv=0&gt;,</span> <span class="pre">&lt;AutoDiffXd</span> <span class="pre">0.0</span> <span class="pre">nderiv=0&gt;],</span> <span class="pre">dtype=object))</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.PiecewisePose_[AutoDiffXd]</span></span></dt>
<dd><p>Constructs a PiecewisePose from given <code class="docutils literal notranslate"><span class="pre">times</span></code> and <code class="docutils literal notranslate"><span class="pre">poses</span></code>. A cubic
polynomial with given end velocities is used to construct the position
part. The rotational part is represented by a piecewise quaterion
trajectory. There must be at least two elements in <code class="docutils literal notranslate"><span class="pre">times</span></code> and
<code class="docutils literal notranslate"><span class="pre">poses</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">times</span></code>:</dt><dd><p>Breaks used to build the splines.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">poses</span></code>:</dt><dd><p>Knots used to build the splines.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">start_vel</span></code>:</dt><dd><p>Start linear velocity.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">end_vel</span></code>:</dt><dd><p>End linear velocity.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePose_[AutoDiffXd].MakeLinear(times:</span> <span class="pre">list[pydrake.autodiffutils.AutoDiffXd],</span> <span class="pre">poses:</span> <span class="pre">list[pydrake.math.RigidTransform_[AutoDiffXd]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.PiecewisePose_[AutoDiffXd]</span></span></dt>
<dd><p>Constructs a PiecewisePose from given <code class="docutils literal notranslate"><span class="pre">times</span></code> and <code class="docutils literal notranslate"><span class="pre">poses</span></code>. The
positions trajectory is constructed as a first-order hold. The
orientation is constructed using the quaternion slerp. There must be
at least two elements in <code class="docutils literal notranslate"><span class="pre">times</span></code> and <code class="docutils literal notranslate"><span class="pre">poses</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">times</span></code>:</dt><dd><p>Breaks used to build the splines.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">poses</span></code>:</dt><dd><p>Knots used to build the splines.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePose_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_[Expression]</span></code></p>
<p>A wrapper class that represents a pose trajectory, whose rotation part
is a PiecewiseQuaternionSlerp and the translation part is a
PiecewisePolynomial.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePose_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.PiecewisePose_[Expression]) -&gt; None</p></li>
</ol>
<p>Constructs an empty piecewise pose trajectory.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.trajectories.PiecewisePose_[Expression], position_trajectory: pydrake.trajectories.PiecewisePolynomial_[Expression], orientation_trajectory: pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression]) -&gt; None</p></li>
</ol>
<p>Constructor.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">position_trajectory</span></code>:</dt><dd><p>Position trajectory.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">orientation_trajectory</span></code>:</dt><dd><p>Orientation trajectory.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePose_[Expression].get_orientation_trajectory(self:</span> <span class="pre">pydrake.trajectories.PiecewisePose_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression]</span></span></dt>
<dd><p>Returns the orientation trajectory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePose_[Expression].get_position_trajectory(self:</span> <span class="pre">pydrake.trajectories.PiecewisePose_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.PiecewisePolynomial_[Expression]</span></span></dt>
<dd><p>Returns the position trajectory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePose_[Expression].GetAcceleration(self:</span> <span class="pre">pydrake.trajectories.PiecewisePose_[Expression],</span> <span class="pre">time:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[6,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the interpolated acceleration at <code class="docutils literal notranslate"><span class="pre">time</span></code> or zero if <code class="docutils literal notranslate"><span class="pre">time</span></code>
is before this trajectory’s start time or after its end time.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePose_[Expression].GetPose(self:</span> <span class="pre">pydrake.trajectories.PiecewisePose_[Expression],</span> <span class="pre">time:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RigidTransform_[Expression]</span></span></dt>
<dd><p>Returns the interpolated pose at <code class="docutils literal notranslate"><span class="pre">time</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePose_[Expression].GetVelocity(self:</span> <span class="pre">pydrake.trajectories.PiecewisePose_[Expression],</span> <span class="pre">time:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[6,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the interpolated velocity at <code class="docutils literal notranslate"><span class="pre">time</span></code> or zero if <code class="docutils literal notranslate"><span class="pre">time</span></code> is
before this trajectory’s start time or after its end time.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePose_[Expression].IsApprox(self:</span> <span class="pre">pydrake.trajectories.PiecewisePose_[Expression],</span> <span class="pre">other:</span> <span class="pre">pydrake.trajectories.PiecewisePose_[Expression],</span> <span class="pre">tol:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true if the position and orientation trajectories are both
within <code class="docutils literal notranslate"><span class="pre">tol</span></code> from the other’s.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePose_[Expression].MakeCubicLinearWithEndLinearVelocity(times:</span> <span class="pre">list[pydrake.symbolic.Expression],</span> <span class="pre">poses:</span> <span class="pre">list[pydrake.math.RigidTransform_[Expression]],</span> <span class="pre">start_vel:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span> <span class="pre">=</span> <span class="pre">array([&lt;Expression</span> <span class="pre">&quot;0&quot;&gt;,</span> <span class="pre">&lt;Expression</span> <span class="pre">&quot;0&quot;&gt;,</span> <span class="pre">&lt;Expression</span> <span class="pre">&quot;0&quot;&gt;],</span> <span class="pre">dtype=object),</span> <span class="pre">end_vel:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span> <span class="pre">=</span> <span class="pre">array([&lt;Expression</span> <span class="pre">&quot;0&quot;&gt;,</span> <span class="pre">&lt;Expression</span> <span class="pre">&quot;0&quot;&gt;,</span> <span class="pre">&lt;Expression</span> <span class="pre">&quot;0&quot;&gt;],</span> <span class="pre">dtype=object))</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.PiecewisePose_[Expression]</span></span></dt>
<dd><p>Constructs a PiecewisePose from given <code class="docutils literal notranslate"><span class="pre">times</span></code> and <code class="docutils literal notranslate"><span class="pre">poses</span></code>. A cubic
polynomial with given end velocities is used to construct the position
part. The rotational part is represented by a piecewise quaterion
trajectory. There must be at least two elements in <code class="docutils literal notranslate"><span class="pre">times</span></code> and
<code class="docutils literal notranslate"><span class="pre">poses</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">times</span></code>:</dt><dd><p>Breaks used to build the splines.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">poses</span></code>:</dt><dd><p>Knots used to build the splines.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">start_vel</span></code>:</dt><dd><p>Start linear velocity.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">end_vel</span></code>:</dt><dd><p>End linear velocity.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewisePose_[Expression].MakeLinear(times:</span> <span class="pre">list[pydrake.symbolic.Expression],</span> <span class="pre">poses:</span> <span class="pre">list[pydrake.math.RigidTransform_[Expression]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.PiecewisePose_[Expression]</span></span></dt>
<dd><p>Constructs a PiecewisePose from given <code class="docutils literal notranslate"><span class="pre">times</span></code> and <code class="docutils literal notranslate"><span class="pre">poses</span></code>. The
positions trajectory is constructed as a first-order hold. The
orientation is constructed using the quaternion slerp. There must be
at least two elements in <code class="docutils literal notranslate"><span class="pre">times</span></code> and <code class="docutils literal notranslate"><span class="pre">poses</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">times</span></code>:</dt><dd><p>Breaks used to build the splines.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">poses</span></code>:</dt><dd><p>Knots used to build the splines.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseQuaternionSlerp</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PiecewiseTrajectory</span></code></p>
<p>A class representing a trajectory for quaternions that are
interpolated using piecewise slerp (spherical linear interpolation).
All the orientation samples are expected to be with respect to the
same parent reference frame, i.e. q_i represents the rotation R_PBi
for the orientation of frame B at the ith sample in a fixed parent
frame P. The world frame is a common choice for the parent frame. The
angular velocity and acceleration are also relative to the parent
frame and expressed in the parent frame. Since there is a sign
ambiguity when using quaternions to represent orientation, namely q
and -q represent the same orientation, the internal quaternion
representations ensure that q_n.dot(q_{n+1}) &gt;= 0. Another intuitive
way to think about this is that consecutive quaternions have the
shortest geodesic distance on the unit sphere. Note that the
quarternion value is in w, x, y, z order when represented as a
Vector4.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewiseQuaternionSlerp_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseQuaternionSlerp.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp) -&gt; None</p></li>
</ol>
<p>Builds an empty PiecewiseQuaternionSlerp.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp, breaks: list[float], quaternions: list[pydrake.common.eigen_geometry.Quaternion]) -&gt; None</p></li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if breaks and quaternions have different length</strong><strong>, </strong><strong>or</strong> – </p></li>
<li><p><strong>breaks have length &lt; 2.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp, breaks: list[float], rotation_matrices: list[numpy.ndarray[numpy.float64[3, 3]]]) -&gt; None</p></li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if breaks and rot_matrices have different length</strong><strong>, </strong><strong>or</strong> – </p></li>
<li><p><strong>breaks have length &lt; 2.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp, breaks: list[float], rotation_matrices: list[pydrake.math.RotationMatrix]) -&gt; None</p></li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if breaks and rot_matrices have different length</strong><strong>, </strong><strong>or</strong> – </p></li>
<li><p><strong>breaks have length &lt; 2.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="5">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp, breaks: list[float], angle_axes: list[pydrake.common.eigen_geometry.AngleAxis]) -&gt; None</p></li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if breaks and ang_axes have different length</strong><strong>, </strong><strong>or</strong> – </p></li>
<li><p><strong>breaks have length &lt; 2.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseQuaternionSlerp.angular_acceleration(self:</span> <span class="pre">pydrake.trajectories.PiecewiseQuaternionSlerp,</span> <span class="pre">time:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Interpolates angular acceleration.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time</span></code>:</dt><dd><p>Time for interpolation.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The interpolated angular acceleration at <code class="docutils literal notranslate"><span class="pre">time</span></code>, which is always
zero for slerp.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseQuaternionSlerp.angular_velocity(self:</span> <span class="pre">pydrake.trajectories.PiecewiseQuaternionSlerp,</span> <span class="pre">time:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Interpolates angular velocity.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time</span></code>:</dt><dd><p>Time for interpolation.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The interpolated angular velocity at <code class="docutils literal notranslate"><span class="pre">time</span></code>, which is constant
per segment.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseQuaternionSlerp.Append(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>Append(self: pydrake.trajectories.PiecewiseQuaternionSlerp, time: float, quaternion: pydrake.common.eigen_geometry.Quaternion) -&gt; None</p></li>
</ol>
<p>Given a new Quaternion, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<ol class="arabic simple" start="2">
<li><p>Append(self: pydrake.trajectories.PiecewiseQuaternionSlerp, time: float, rotation_matrix: pydrake.math.RotationMatrix) -&gt; None</p></li>
</ol>
<p>Given a new RotationMatrix, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<ol class="arabic simple" start="3">
<li><p>Append(self: pydrake.trajectories.PiecewiseQuaternionSlerp, time: float, angle_axis: pydrake.common.eigen_geometry.AngleAxis) -&gt; None</p></li>
</ol>
<p>Given a new AngleAxis, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseQuaternionSlerp.orientation(self:</span> <span class="pre">pydrake.trajectories.PiecewiseQuaternionSlerp,</span> <span class="pre">time:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.eigen_geometry.Quaternion</span></span></dt>
<dd><p>Interpolates orientation.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time</span></code>:</dt><dd><p>Time for interpolation.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The interpolated quaternion at <code class="docutils literal notranslate"><span class="pre">time</span></code>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseQuaternionSlerp_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewiseQuaternionSlerp_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewiseQuaternionSlerp_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewiseQuaternionSlerp_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseQuaternionSlerp_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd]</span></code></p>
<p>A class representing a trajectory for quaternions that are
interpolated using piecewise slerp (spherical linear interpolation).
All the orientation samples are expected to be with respect to the
same parent reference frame, i.e. q_i represents the rotation R_PBi
for the orientation of frame B at the ith sample in a fixed parent
frame P. The world frame is a common choice for the parent frame. The
angular velocity and acceleration are also relative to the parent
frame and expressed in the parent frame. Since there is a sign
ambiguity when using quaternions to represent orientation, namely q
and -q represent the same orientation, the internal quaternion
representations ensure that q_n.dot(q_{n+1}) &gt;= 0. Another intuitive
way to think about this is that consecutive quaternions have the
shortest geodesic distance on the unit sphere. Note that the
quarternion value is in w, x, y, z order when represented as a
Vector4.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseQuaternionSlerp_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Builds an empty PiecewiseQuaternionSlerp.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd], breaks: list[pydrake.autodiffutils.AutoDiffXd], quaternions: list[pydrake.common.eigen_geometry.Quaternion_[AutoDiffXd]]) -&gt; None</p></li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if breaks and quaternions have different length</strong><strong>, </strong><strong>or</strong> – </p></li>
<li><p><strong>breaks have length &lt; 2.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd], breaks: list[pydrake.autodiffutils.AutoDiffXd], rotation_matrices: list[numpy.ndarray[object[3, 3]]]) -&gt; None</p></li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if breaks and rot_matrices have different length</strong><strong>, </strong><strong>or</strong> – </p></li>
<li><p><strong>breaks have length &lt; 2.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd], breaks: list[pydrake.autodiffutils.AutoDiffXd], rotation_matrices: list[pydrake.math.RotationMatrix_[AutoDiffXd]]) -&gt; None</p></li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if breaks and rot_matrices have different length</strong><strong>, </strong><strong>or</strong> – </p></li>
<li><p><strong>breaks have length &lt; 2.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="5">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd], breaks: list[pydrake.autodiffutils.AutoDiffXd], angle_axes: list[pydrake.common.eigen_geometry.AngleAxis_[AutoDiffXd]]) -&gt; None</p></li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if breaks and ang_axes have different length</strong><strong>, </strong><strong>or</strong> – </p></li>
<li><p><strong>breaks have length &lt; 2.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseQuaternionSlerp_[AutoDiffXd].angular_acceleration(self:</span> <span class="pre">pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd],</span> <span class="pre">time:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Interpolates angular acceleration.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time</span></code>:</dt><dd><p>Time for interpolation.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The interpolated angular acceleration at <code class="docutils literal notranslate"><span class="pre">time</span></code>, which is always
zero for slerp.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseQuaternionSlerp_[AutoDiffXd].angular_velocity(self:</span> <span class="pre">pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd],</span> <span class="pre">time:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Interpolates angular velocity.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time</span></code>:</dt><dd><p>Time for interpolation.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The interpolated angular velocity at <code class="docutils literal notranslate"><span class="pre">time</span></code>, which is constant
per segment.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseQuaternionSlerp_[AutoDiffXd].Append(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>Append(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd], time: pydrake.autodiffutils.AutoDiffXd, quaternion: pydrake.common.eigen_geometry.Quaternion_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Given a new Quaternion, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<ol class="arabic simple" start="2">
<li><p>Append(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd], time: pydrake.autodiffutils.AutoDiffXd, rotation_matrix: pydrake.math.RotationMatrix_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Given a new RotationMatrix, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<ol class="arabic simple" start="3">
<li><p>Append(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd], time: pydrake.autodiffutils.AutoDiffXd, angle_axis: pydrake.common.eigen_geometry.AngleAxis_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Given a new AngleAxis, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseQuaternionSlerp_[AutoDiffXd].orientation(self:</span> <span class="pre">pydrake.trajectories.PiecewiseQuaternionSlerp_[AutoDiffXd],</span> <span class="pre">time:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.eigen_geometry.Quaternion_[AutoDiffXd]</span></span></dt>
<dd><p>Interpolates orientation.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time</span></code>:</dt><dd><p>Time for interpolation.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The interpolated quaternion at <code class="docutils literal notranslate"><span class="pre">time</span></code>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseQuaternionSlerp_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.PiecewiseTrajectory_[Expression]</span></code></p>
<p>A class representing a trajectory for quaternions that are
interpolated using piecewise slerp (spherical linear interpolation).
All the orientation samples are expected to be with respect to the
same parent reference frame, i.e. q_i represents the rotation R_PBi
for the orientation of frame B at the ith sample in a fixed parent
frame P. The world frame is a common choice for the parent frame. The
angular velocity and acceleration are also relative to the parent
frame and expressed in the parent frame. Since there is a sign
ambiguity when using quaternions to represent orientation, namely q
and -q represent the same orientation, the internal quaternion
representations ensure that q_n.dot(q_{n+1}) &gt;= 0. Another intuitive
way to think about this is that consecutive quaternions have the
shortest geodesic distance on the unit sphere. Note that the
quarternion value is in w, x, y, z order when represented as a
Vector4.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseQuaternionSlerp_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression]) -&gt; None</p></li>
</ol>
<p>Builds an empty PiecewiseQuaternionSlerp.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression], breaks: list[pydrake.symbolic.Expression], quaternions: list[pydrake.common.eigen_geometry.Quaternion_[Expression]]) -&gt; None</p></li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if breaks and quaternions have different length</strong><strong>, </strong><strong>or</strong> – </p></li>
<li><p><strong>breaks have length &lt; 2.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression], breaks: list[pydrake.symbolic.Expression], rotation_matrices: list[numpy.ndarray[object[3, 3]]]) -&gt; None</p></li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if breaks and rot_matrices have different length</strong><strong>, </strong><strong>or</strong> – </p></li>
<li><p><strong>breaks have length &lt; 2.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression], breaks: list[pydrake.symbolic.Expression], rotation_matrices: list[pydrake.math.RotationMatrix_[Expression]]) -&gt; None</p></li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if breaks and rot_matrices have different length</strong><strong>, </strong><strong>or</strong> – </p></li>
<li><p><strong>breaks have length &lt; 2.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="5">
<li><p>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression], breaks: list[pydrake.symbolic.Expression], angle_axes: list[pydrake.common.eigen_geometry.AngleAxis_[Expression]]) -&gt; None</p></li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if breaks and ang_axes have different length</strong><strong>, </strong><strong>or</strong> – </p></li>
<li><p><strong>breaks have length &lt; 2.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseQuaternionSlerp_[Expression].angular_acceleration(self:</span> <span class="pre">pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression],</span> <span class="pre">time:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Interpolates angular acceleration.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time</span></code>:</dt><dd><p>Time for interpolation.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The interpolated angular acceleration at <code class="docutils literal notranslate"><span class="pre">time</span></code>, which is always
zero for slerp.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseQuaternionSlerp_[Expression].angular_velocity(self:</span> <span class="pre">pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression],</span> <span class="pre">time:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Interpolates angular velocity.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time</span></code>:</dt><dd><p>Time for interpolation.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The interpolated angular velocity at <code class="docutils literal notranslate"><span class="pre">time</span></code>, which is constant
per segment.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseQuaternionSlerp_[Expression].Append(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>Append(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression], time: pydrake.symbolic.Expression, quaternion: pydrake.common.eigen_geometry.Quaternion_[Expression]) -&gt; None</p></li>
</ol>
<p>Given a new Quaternion, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<ol class="arabic simple" start="2">
<li><p>Append(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression], time: pydrake.symbolic.Expression, rotation_matrix: pydrake.math.RotationMatrix_[Expression]) -&gt; None</p></li>
</ol>
<p>Given a new RotationMatrix, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
<ol class="arabic simple" start="3">
<li><p>Append(self: pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression], time: pydrake.symbolic.Expression, angle_axis: pydrake.common.eigen_geometry.AngleAxis_[Expression]) -&gt; None</p></li>
</ol>
<p>Given a new AngleAxis, this method adds one segment to the end of
<code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseQuaternionSlerp_[Expression].orientation(self:</span> <span class="pre">pydrake.trajectories.PiecewiseQuaternionSlerp_[Expression],</span> <span class="pre">time:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.eigen_geometry.Quaternion_[Expression]</span></span></dt>
<dd><p>Interpolates orientation.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time</span></code>:</dt><dd><p>Time for interpolation.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The interpolated quaternion at <code class="docutils literal notranslate"><span class="pre">time</span></code>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseTrajectory</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory</span></code></p>
<p>Abstract class that implements the basic logic of maintaining
consequent segments of time (delimited by <code class="docutils literal notranslate"><span class="pre">breaks</span></code>) to implement a
trajectory that is represented by simpler logic in each segment or
“piece”.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewiseTrajectory_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseTrajectory.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseTrajectory.duration(self:</span> <span class="pre">pydrake.trajectories.PiecewiseTrajectory,</span> <span class="pre">segment_index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseTrajectory.end_time(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>end_time(self: pydrake.trajectories.PiecewiseTrajectory, segment_index: int) -&gt; float</p></li>
<li><p>end_time(self: pydrake.trajectories.PiecewiseTrajectory) -&gt; float</p></li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseTrajectory.get_number_of_segments(self:</span> <span class="pre">pydrake.trajectories.PiecewiseTrajectory)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseTrajectory.get_segment_index(self:</span> <span class="pre">pydrake.trajectories.PiecewiseTrajectory,</span> <span class="pre">t:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseTrajectory.get_segment_times(self:</span> <span class="pre">pydrake.trajectories.PiecewiseTrajectory)</span> <span class="pre">-&gt;</span> <span class="pre">list[float]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseTrajectory.is_time_in_range(self:</span> <span class="pre">pydrake.trajectories.PiecewiseTrajectory,</span> <span class="pre">t:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">&gt;=</span> <span class="pre">getStartTime()</span> <span class="pre">&amp;&amp;</span> <span class="pre">t</span> <span class="pre">&lt;=</span> <span class="pre">getEndTime()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseTrajectory.start_time(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>start_time(self: pydrake.trajectories.PiecewiseTrajectory, segment_index: int) -&gt; float</p></li>
<li><p>start_time(self: pydrake.trajectories.PiecewiseTrajectory) -&gt; float</p></li>
</ol>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseTrajectory_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewiseTrajectory_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewiseTrajectory_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">PiecewiseTrajectory_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseTrajectory_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[AutoDiffXd]</span></code></p>
<p>Abstract class that implements the basic logic of maintaining
consequent segments of time (delimited by <code class="docutils literal notranslate"><span class="pre">breaks</span></code>) to implement a
trajectory that is represented by simpler logic in each segment or
“piece”.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseTrajectory_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseTrajectory_[AutoDiffXd].duration(self:</span> <span class="pre">pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd],</span> <span class="pre">segment_index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseTrajectory_[AutoDiffXd].end_time(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>end_time(self: pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd], segment_index: int) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
<li><p>end_time(self: pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd]) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseTrajectory_[AutoDiffXd].get_number_of_segments(self:</span> <span class="pre">pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseTrajectory_[AutoDiffXd].get_segment_index(self:</span> <span class="pre">pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd],</span> <span class="pre">t:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseTrajectory_[AutoDiffXd].get_segment_times(self:</span> <span class="pre">pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.autodiffutils.AutoDiffXd]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseTrajectory_[AutoDiffXd].is_time_in_range(self:</span> <span class="pre">pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd],</span> <span class="pre">t:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">&gt;=</span> <span class="pre">getStartTime()</span> <span class="pre">&amp;&amp;</span> <span class="pre">t</span> <span class="pre">&lt;=</span> <span class="pre">getEndTime()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseTrajectory_[AutoDiffXd].start_time(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>start_time(self: pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd], segment_index: int) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
<li><p>start_time(self: pydrake.trajectories.PiecewiseTrajectory_[AutoDiffXd]) -&gt; pydrake.autodiffutils.AutoDiffXd</p></li>
</ol>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseTrajectory_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[Expression]</span></code></p>
<p>Abstract class that implements the basic logic of maintaining
consequent segments of time (delimited by <code class="docutils literal notranslate"><span class="pre">breaks</span></code>) to implement a
trajectory that is represented by simpler logic in each segment or
“piece”.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseTrajectory_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseTrajectory_[Expression].duration(self:</span> <span class="pre">pydrake.trajectories.PiecewiseTrajectory_[Expression],</span> <span class="pre">segment_index:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseTrajectory_[Expression].end_time(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>end_time(self: pydrake.trajectories.PiecewiseTrajectory_[Expression], segment_index: int) -&gt; pydrake.symbolic.Expression</p></li>
<li><p>end_time(self: pydrake.trajectories.PiecewiseTrajectory_[Expression]) -&gt; pydrake.symbolic.Expression</p></li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseTrajectory_[Expression].get_number_of_segments(self:</span> <span class="pre">pydrake.trajectories.PiecewiseTrajectory_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseTrajectory_[Expression].get_segment_index(self:</span> <span class="pre">pydrake.trajectories.PiecewiseTrajectory_[Expression],</span> <span class="pre">t:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseTrajectory_[Expression].get_segment_times(self:</span> <span class="pre">pydrake.trajectories.PiecewiseTrajectory_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.symbolic.Expression]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseTrajectory_[Expression].is_time_in_range(self:</span> <span class="pre">pydrake.trajectories.PiecewiseTrajectory_[Expression],</span> <span class="pre">t:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Formula</span></span></dt>
<dd><p>Returns true iff <code class="docutils literal notranslate"><span class="pre">t</span> <span class="pre">&gt;=</span> <span class="pre">getStartTime()</span> <span class="pre">&amp;&amp;</span> <span class="pre">t</span> <span class="pre">&lt;=</span> <span class="pre">getEndTime()</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PiecewiseTrajectory_[Expression].start_time(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>start_time(self: pydrake.trajectories.PiecewiseTrajectory_[Expression], segment_index: int) -&gt; pydrake.symbolic.Expression</p></li>
<li><p>start_time(self: pydrake.trajectories.PiecewiseTrajectory_[Expression]) -&gt; pydrake.symbolic.Expression</p></li>
</ol>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">StackedTrajectory</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory</span></code></p>
<p>A StackedTrajectory stacks the values from one or more underlying
Trajectory objects into a single Trajectory, without changing the
<code class="docutils literal notranslate"><span class="pre">%start_time()</span></code> or <code class="docutils literal notranslate"><span class="pre">%end_time()</span></code>.</p>
<p>For sequencing trajectories in time instead, see CompositeTrajectory.</p>
<p>All of the underlying Trajectory objects must have the same
<code class="docutils literal notranslate"><span class="pre">%start_time()</span></code> and <code class="docutils literal notranslate"><span class="pre">%end_time()</span></code>.</p>
<p>When constructed with <code class="docutils literal notranslate"><span class="pre">rowwise</span></code> set to true, all of the underlying
Trajectory objects must have the same number of <code class="docutils literal notranslate"><span class="pre">%cols()</span></code> and the
<code class="docutils literal notranslate"><span class="pre">value()</span></code> matrix will be the <strong>vstack</strong> of the the trajectories in
the order they were added.</p>
<p>When constructed with <code class="docutils literal notranslate"><span class="pre">rowwise</span></code> set to false, all of the underlying
Trajectory objects must have the same number of <code class="docutils literal notranslate"><span class="pre">%rows()</span></code> and the
<code class="docutils literal notranslate"><span class="pre">value()</span></code> matrix will be the <strong>hstack</strong> of the the trajectories in
the order they were added.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">StackedTrajectory_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">StackedTrajectory.__init__(self:</span> <span class="pre">pydrake.trajectories.StackedTrajectory,</span> <span class="pre">rowwise:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">True)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Creates an empty trajectory.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rowwise</span></code>:</dt><dd><p>governs the stacking order</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">StackedTrajectory.Append(self:</span> <span class="pre">pydrake.trajectories.StackedTrajectory,</span> <span class="pre">arg0:</span> <span class="pre">pydrake.trajectories.Trajectory)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Stacks another sub-Trajectory onto this. Refer to the class overview
documentation for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the matrix dimension is incompatible.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">StackedTrajectory_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">StackedTrajectory_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">StackedTrajectory_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">StackedTrajectory_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">StackedTrajectory_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[AutoDiffXd]</span></code></p>
<p>A StackedTrajectory stacks the values from one or more underlying
Trajectory objects into a single Trajectory, without changing the
<code class="docutils literal notranslate"><span class="pre">%start_time()</span></code> or <code class="docutils literal notranslate"><span class="pre">%end_time()</span></code>.</p>
<p>For sequencing trajectories in time instead, see CompositeTrajectory.</p>
<p>All of the underlying Trajectory objects must have the same
<code class="docutils literal notranslate"><span class="pre">%start_time()</span></code> and <code class="docutils literal notranslate"><span class="pre">%end_time()</span></code>.</p>
<p>When constructed with <code class="docutils literal notranslate"><span class="pre">rowwise</span></code> set to true, all of the underlying
Trajectory objects must have the same number of <code class="docutils literal notranslate"><span class="pre">%cols()</span></code> and the
<code class="docutils literal notranslate"><span class="pre">value()</span></code> matrix will be the <strong>vstack</strong> of the the trajectories in
the order they were added.</p>
<p>When constructed with <code class="docutils literal notranslate"><span class="pre">rowwise</span></code> set to false, all of the underlying
Trajectory objects must have the same number of <code class="docutils literal notranslate"><span class="pre">%rows()</span></code> and the
<code class="docutils literal notranslate"><span class="pre">value()</span></code> matrix will be the <strong>hstack</strong> of the the trajectories in
the order they were added.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">StackedTrajectory_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.trajectories.StackedTrajectory_[AutoDiffXd],</span> <span class="pre">rowwise:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">True)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Creates an empty trajectory.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rowwise</span></code>:</dt><dd><p>governs the stacking order</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">StackedTrajectory_[AutoDiffXd].Append(self:</span> <span class="pre">pydrake.trajectories.StackedTrajectory_[AutoDiffXd],</span> <span class="pre">arg0:</span> <span class="pre">pydrake.trajectories.Trajectory_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Stacks another sub-Trajectory onto this. Refer to the class overview
documentation for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the matrix dimension is incompatible.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">StackedTrajectory_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.trajectories.Trajectory_[Expression]</span></code></p>
<p>A StackedTrajectory stacks the values from one or more underlying
Trajectory objects into a single Trajectory, without changing the
<code class="docutils literal notranslate"><span class="pre">%start_time()</span></code> or <code class="docutils literal notranslate"><span class="pre">%end_time()</span></code>.</p>
<p>For sequencing trajectories in time instead, see CompositeTrajectory.</p>
<p>All of the underlying Trajectory objects must have the same
<code class="docutils literal notranslate"><span class="pre">%start_time()</span></code> and <code class="docutils literal notranslate"><span class="pre">%end_time()</span></code>.</p>
<p>When constructed with <code class="docutils literal notranslate"><span class="pre">rowwise</span></code> set to true, all of the underlying
Trajectory objects must have the same number of <code class="docutils literal notranslate"><span class="pre">%cols()</span></code> and the
<code class="docutils literal notranslate"><span class="pre">value()</span></code> matrix will be the <strong>vstack</strong> of the the trajectories in
the order they were added.</p>
<p>When constructed with <code class="docutils literal notranslate"><span class="pre">rowwise</span></code> set to false, all of the underlying
Trajectory objects must have the same number of <code class="docutils literal notranslate"><span class="pre">%rows()</span></code> and the
<code class="docutils literal notranslate"><span class="pre">value()</span></code> matrix will be the <strong>hstack</strong> of the the trajectories in
the order they were added.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">StackedTrajectory_[Expression].__init__(self:</span> <span class="pre">pydrake.trajectories.StackedTrajectory_[Expression],</span> <span class="pre">rowwise:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">True)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Creates an empty trajectory.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rowwise</span></code>:</dt><dd><p>governs the stacking order</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">StackedTrajectory_[Expression].Append(self:</span> <span class="pre">pydrake.trajectories.StackedTrajectory_[Expression],</span> <span class="pre">arg0:</span> <span class="pre">pydrake.trajectories.Trajectory_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Stacks another sub-Trajectory onto this. Refer to the class overview
documentation for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the matrix dimension is incompatible.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Trajectory</span></span></dt>
<dd><p>A Trajectory represents a time-varying matrix, indexed by a single
scalar time.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">Trajectory_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Trajectory.__init__(self:</span> <span class="pre">pydrake.trajectories.Trajectory)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Trajectory.Clone(self:</span> <span class="pre">pydrake.trajectories.Trajectory)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.Trajectory</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Trajectory.cols(self:</span> <span class="pre">pydrake.trajectories.Trajectory)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The number of columns in the matrix returned by value().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Trajectory.end_time(self:</span> <span class="pre">pydrake.trajectories.Trajectory)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Trajectory.EvalDerivative(self:</span> <span class="pre">pydrake.trajectories.Trajectory,</span> <span class="pre">t:</span> <span class="pre">float,</span> <span class="pre">derivative_order:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">1)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>Evaluates the derivative of <code class="docutils literal notranslate"><span class="pre">this</span></code> at the given time <code class="docutils literal notranslate"><span class="pre">t</span></code>. Returns
the nth derivative, where <code class="docutils literal notranslate"><span class="pre">n</span></code> is the value of <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if derivative_order is negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Trajectory.has_derivative(self:</span> <span class="pre">pydrake.trajectories.Trajectory)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff the Trajectory provides and implementation for
EvalDerivative() and MakeDerivative(). The derivative need not be
continuous, but should return a result for all t for which value(t)
returns a result.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Trajectory.MakeDerivative(self:</span> <span class="pre">pydrake.trajectories.Trajectory,</span> <span class="pre">derivative_order:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">1)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.Trajectory</span></span></dt>
<dd><p>Takes the derivative of this Trajectory.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code>:</dt><dd><p>The number of times to take the derivative before returning.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The nth derivative of this object.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>RuntimeError if derivative_order is negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Trajectory.rows(self:</span> <span class="pre">pydrake.trajectories.Trajectory)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The number of rows in the matrix returned by value().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Trajectory.start_time(self:</span> <span class="pre">pydrake.trajectories.Trajectory)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Trajectory.value(self:</span> <span class="pre">pydrake.trajectories.Trajectory,</span> <span class="pre">t:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>Evaluates the trajectory at the given time <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">t</span></code>:</dt><dd><p>The time at which to evaluate the trajectory.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The matrix of evaluated values.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Trajectory.vector_values(self:</span> <span class="pre">pydrake.trajectories.Trajectory,</span> <span class="pre">t:</span> <span class="pre">list[float])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>If cols()==1, then evaluates the trajectory at each time <code class="docutils literal notranslate"><span class="pre">t</span></code>, and
returns the results as a Matrix with the ith column corresponding to
the ith time. Otherwise, if rows()==1, then evaluates the trajectory
at each time <code class="docutils literal notranslate"><span class="pre">t</span></code>, and returns the results as a Matrix with the ith
row corresponding to the ith time.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if both cols and rows are not equal to 1.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Trajectory_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">Trajectory_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Trajectory_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Trajectory_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Trajectory_[AutoDiffXd]</span></span></dt>
<dd><p>A Trajectory represents a time-varying matrix, indexed by a single
scalar time.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Trajectory_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.trajectories.Trajectory_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Trajectory_[AutoDiffXd].Clone(self:</span> <span class="pre">pydrake.trajectories.Trajectory_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.Trajectory_[AutoDiffXd]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Trajectory_[AutoDiffXd].cols(self:</span> <span class="pre">pydrake.trajectories.Trajectory_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The number of columns in the matrix returned by value().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Trajectory_[AutoDiffXd].end_time(self:</span> <span class="pre">pydrake.trajectories.Trajectory_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Trajectory_[AutoDiffXd].EvalDerivative(self:</span> <span class="pre">pydrake.trajectories.Trajectory_[AutoDiffXd],</span> <span class="pre">t:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">derivative_order:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">1)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>Evaluates the derivative of <code class="docutils literal notranslate"><span class="pre">this</span></code> at the given time <code class="docutils literal notranslate"><span class="pre">t</span></code>. Returns
the nth derivative, where <code class="docutils literal notranslate"><span class="pre">n</span></code> is the value of <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if derivative_order is negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Trajectory_[AutoDiffXd].has_derivative(self:</span> <span class="pre">pydrake.trajectories.Trajectory_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff the Trajectory provides and implementation for
EvalDerivative() and MakeDerivative(). The derivative need not be
continuous, but should return a result for all t for which value(t)
returns a result.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Trajectory_[AutoDiffXd].MakeDerivative(self:</span> <span class="pre">pydrake.trajectories.Trajectory_[AutoDiffXd],</span> <span class="pre">derivative_order:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">1)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.Trajectory_[AutoDiffXd]</span></span></dt>
<dd><p>Takes the derivative of this Trajectory.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code>:</dt><dd><p>The number of times to take the derivative before returning.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The nth derivative of this object.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>RuntimeError if derivative_order is negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Trajectory_[AutoDiffXd].rows(self:</span> <span class="pre">pydrake.trajectories.Trajectory_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The number of rows in the matrix returned by value().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Trajectory_[AutoDiffXd].start_time(self:</span> <span class="pre">pydrake.trajectories.Trajectory_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Trajectory_[AutoDiffXd].value(self:</span> <span class="pre">pydrake.trajectories.Trajectory_[AutoDiffXd],</span> <span class="pre">t:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>Evaluates the trajectory at the given time <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">t</span></code>:</dt><dd><p>The time at which to evaluate the trajectory.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The matrix of evaluated values.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Trajectory_[AutoDiffXd].vector_values(self:</span> <span class="pre">pydrake.trajectories.Trajectory_[AutoDiffXd],</span> <span class="pre">t:</span> <span class="pre">list[pydrake.autodiffutils.AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>If cols()==1, then evaluates the trajectory at each time <code class="docutils literal notranslate"><span class="pre">t</span></code>, and
returns the results as a Matrix with the ith column corresponding to
the ith time. Otherwise, if rows()==1, then evaluates the trajectory
at each time <code class="docutils literal notranslate"><span class="pre">t</span></code>, and returns the results as a Matrix with the ith
row corresponding to the ith time.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if both cols and rows are not equal to 1.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Trajectory_[Expression]</span></span></dt>
<dd><p>A Trajectory represents a time-varying matrix, indexed by a single
scalar time.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Trajectory_[Expression].__init__(self:</span> <span class="pre">pydrake.trajectories.Trajectory_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Trajectory_[Expression].Clone(self:</span> <span class="pre">pydrake.trajectories.Trajectory_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.Trajectory_[Expression]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Trajectory_[Expression].cols(self:</span> <span class="pre">pydrake.trajectories.Trajectory_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The number of columns in the matrix returned by value().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Trajectory_[Expression].end_time(self:</span> <span class="pre">pydrake.trajectories.Trajectory_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Trajectory_[Expression].EvalDerivative(self:</span> <span class="pre">pydrake.trajectories.Trajectory_[Expression],</span> <span class="pre">t:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">derivative_order:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">1)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>Evaluates the derivative of <code class="docutils literal notranslate"><span class="pre">this</span></code> at the given time <code class="docutils literal notranslate"><span class="pre">t</span></code>. Returns
the nth derivative, where <code class="docutils literal notranslate"><span class="pre">n</span></code> is the value of <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if derivative_order is negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Trajectory_[Expression].has_derivative(self:</span> <span class="pre">pydrake.trajectories.Trajectory_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff the Trajectory provides and implementation for
EvalDerivative() and MakeDerivative(). The derivative need not be
continuous, but should return a result for all t for which value(t)
returns a result.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Trajectory_[Expression].MakeDerivative(self:</span> <span class="pre">pydrake.trajectories.Trajectory_[Expression],</span> <span class="pre">derivative_order:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">1)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.trajectories.Trajectory_[Expression]</span></span></dt>
<dd><p>Takes the derivative of this Trajectory.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">derivative_order</span></code>:</dt><dd><p>The number of times to take the derivative before returning.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The nth derivative of this object.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>RuntimeError if derivative_order is negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Trajectory_[Expression].rows(self:</span> <span class="pre">pydrake.trajectories.Trajectory_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The number of rows in the matrix returned by value().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Trajectory_[Expression].start_time(self:</span> <span class="pre">pydrake.trajectories.Trajectory_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Trajectory_[Expression].value(self:</span> <span class="pre">pydrake.trajectories.Trajectory_[Expression],</span> <span class="pre">t:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>Evaluates the trajectory at the given time <code class="docutils literal notranslate"><span class="pre">t</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">t</span></code>:</dt><dd><p>The time at which to evaluate the trajectory.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The matrix of evaluated values.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Trajectory_[Expression].vector_values(self:</span> <span class="pre">pydrake.trajectories.Trajectory_[Expression],</span> <span class="pre">t:</span> <span class="pre">list[pydrake.symbolic.Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>If cols()==1, then evaluates the trajectory at each time <code class="docutils literal notranslate"><span class="pre">t</span></code>, and
returns the results as a Matrix with the ith column corresponding to
the ith time. Otherwise, if rows()==1, then evaluates the trajectory
at each time <code class="docutils literal notranslate"><span class="pre">t</span></code>, and returns the results as a Matrix with the ith
row corresponding to the ith time.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if both cols and rows are not equal to 1.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="pydrake.systems.sensors.html" class="btn btn-neutral float-left" title="pydrake.systems.sensors" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="pydrake.tutorials.html" class="btn btn-neutral float-right" title="pydrake.tutorials" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p></p>
  </div>

  
</footer>
<script>
  /* Enables clicking for the mobile "hamburger" (three-line) menu item. */
  const siteHeader = document.querySelector('.site-header')
  const mobileButton = document.querySelector('.menu-mobile-toggle')
  const body = document.querySelector('body')

  mobileButton.addEventListener('click', function(event) {
    siteHeader.classList.toggle('open');
    body.classList.toggle('overflow-hidden');
  })
</script>
<footer class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg">
    </a>
    <div class="footer-menu">
      <ul>
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"></a>
        </li>
      </ul>
    </div>
  </div>


</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>