

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pydrake.trajectories &mdash; pydrake  documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="pydrake  documentation" href="index.html"/>
        <link rel="next" title="pydrake.visualization" href="pydrake.visualization.html"/>
        <link rel="prev" title="pydrake.systems.trajectory_optimization" href="pydrake.systems.trajectory_optimization.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> pydrake
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="pydrake.all.html">pydrake.all</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.autodiffutils.html">pydrake.autodiffutils</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.common.html">pydrake.common</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.examples.html">pydrake.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.forwarddiff.html">pydrake.forwarddiff</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.geometry.html">pydrake.geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.lcm.html">pydrake.lcm</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.manipulation.html">pydrake.manipulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.math.html">pydrake.math</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.multibody.html">pydrake.multibody</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.perception.html">pydrake.perception</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.polynomial.html">pydrake.polynomial</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.html">pydrake.solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.symbolic.html">pydrake.symbolic</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.systems.html">pydrake.systems</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">pydrake.trajectories</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.visualization.html">pydrake.visualization</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pydrake</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>pydrake.trajectories</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-pydrake.trajectories">
<span id="pydrake-trajectories"></span><h1>pydrake.trajectories<a class="headerlink" href="#module-pydrake.trajectories" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="pydrake.trajectories.BsplineTrajectory">
<em class="property">class </em><code class="descclassname">pydrake.trajectories.</code><code class="descname">BsplineTrajectory</code><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.Trajectory" title="pydrake.trajectories.Trajectory"><code class="xref py py-class docutils literal"><span class="pre">pydrake.trajectories.Trajectory</span></code></a></p>
<p>Represents a B-spline curve using a given <code class="docutils literal"><span class="pre">basis</span></code> with ordered
<code class="docutils literal"><span class="pre">control_points</span></code> such that each control point is a matrix in ℝʳᵒʷˢ ˣ
ᶜᵒˡˢ.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">math::BsplineBasis</p>
</div>
<dl class="method">
<dt id="pydrake.trajectories.BsplineTrajectory.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.trajectories.BsplineTrajectory) -&gt; None</li>
<li>__init__(self: pydrake.trajectories.BsplineTrajectory, basis: pydrake.math.BsplineBasis_[float], control_points: List[numpy.ndarray[numpy.float64[m, n]]]) -&gt; None</li>
</ol>
<p>Constructs a B-spline trajectory with the given <code class="docutils literal"><span class="pre">basis</span></code> and
<code class="docutils literal"><span class="pre">control_points</span></code>.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>control_points.size() == basis.num_basis_functions()</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.BsplineTrajectory.basis">
<code class="descname">basis</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.BsplineTrajectory</em><span class="sig-paren">)</span> &#x2192; pydrake.math.BsplineBasis_[float]<a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory.basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the basis of this curve.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.BsplineTrajectory.Clone">
<code class="descname">Clone</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.BsplineTrajectory</em><span class="sig-paren">)</span> &#x2192; pydrake.trajectories.Trajectory<a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory.Clone" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.BsplineTrajectory.control_points">
<code class="descname">control_points</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.BsplineTrajectory</em><span class="sig-paren">)</span> &#x2192; List[numpy.ndarray[numpy.float64[m, n]]]<a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory.control_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the control points of this curve.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.BsplineTrajectory.CopyBlock">
<code class="descname">CopyBlock</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.BsplineTrajectory</em>, <em>start_row: int</em>, <em>start_col: int</em>, <em>block_rows: int</em>, <em>block_cols: int</em><span class="sig-paren">)</span> &#x2192; pydrake.trajectories.BsplineTrajectory<a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory.CopyBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new BsplineTrajectory that uses the same basis as <code class="docutils literal"><span class="pre">this</span></code>,
and whose control points are the result of calling
<code class="docutils literal"><span class="pre">point.block(start_row,</span> <span class="pre">start_col,</span> <span class="pre">block_rows,</span> <span class="pre">block_cols)</span></code> on each
<code class="docutils literal"><span class="pre">point</span></code> in <code class="docutils literal"><span class="pre">this-&gt;control_points()</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.BsplineTrajectory.CopyHead">
<code class="descname">CopyHead</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.BsplineTrajectory</em>, <em>n: int</em><span class="sig-paren">)</span> &#x2192; pydrake.trajectories.BsplineTrajectory<a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory.CopyHead" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new BsplineTrajectory that uses the same basis as <code class="docutils literal"><span class="pre">this</span></code>,
and whose control points are the result of calling <code class="docutils literal"><span class="pre">point.head(n)</span></code>
on each <code class="docutils literal"><span class="pre">point</span></code> in <code class="docutils literal"><span class="pre">this-&gt;control_points()</span></code>.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>this-&gt;cols() == 1</dd>
<dt>Precondition:</dt>
<dd>control_points()[0].head(n) must be a valid operation.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.BsplineTrajectory.FinalValue">
<code class="descname">FinalValue</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.BsplineTrajectory</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, n]]<a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory.FinalValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns this-&gt;value(this-&gt;end_time())</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.BsplineTrajectory.InitialValue">
<code class="descname">InitialValue</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.BsplineTrajectory</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, n]]<a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory.InitialValue" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns this-&gt;value(this-&gt;start_time())</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.BsplineTrajectory.InsertKnots">
<code class="descname">InsertKnots</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.BsplineTrajectory, additional_knots: List[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory.InsertKnots" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds new knots at the specified <code class="docutils literal"><span class="pre">additional_knots</span></code> without changing
the behavior of the trajectory. The basis and control points of the
trajectory are adjusted such that it produces the same value for any
valid time before and after this method is called. The resulting
trajectory is guaranteed to have the same level of continuity as the
original, even if knot values are duplicated. Note that
<code class="docutils literal"><span class="pre">additional_knots</span></code> need not be sorted.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>start_time() &lt;= t &lt;= end_time() for all t in <code class="docutils literal"><span class="pre">additional_knots</span></code></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.BsplineTrajectory.num_control_points">
<code class="descname">num_control_points</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.BsplineTrajectory</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.trajectories.BsplineTrajectory.num_control_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of control points in this curve.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.trajectories.PiecewisePolynomial">
<em class="property">class </em><code class="descclassname">pydrake.trajectories.</code><code class="descname">PiecewisePolynomial</code><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory" title="pydrake.trajectories.PiecewiseTrajectory"><code class="xref py py-class docutils literal"><span class="pre">pydrake.trajectories.PiecewiseTrajectory</span></code></a></p>
<p>A scalar multi-variate piecewise polynomial.</p>
<p>PiecewisePolynomial represents a list of contiguous segments in a
scalar independent variable (typically corresponding to time) with
Polynomials defined at each segment. We call the output from
evaluating the PiecewisePolynomial at the scalar independent variable
“the output”, and that output can be either a Eigen MatrixX&lt;T&gt; (if
evaluated using value()) or a scalar (if evaluated using
scalar_value()).</p>
<p>An example of a piecewise polynomial is a function of m segments in
time, where a different polynomial is defined for each segment. For a
specific example, consider the absolute value function over the
interval [-1, 1]. We can define a PiecewisePolynomial over this
interval using breaks at t = { -1.0, 0.0, 1.0 }, and “samples” of
abs(t).</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Construct</span> <span class="n">the</span> <span class="n">PiecewisePolynomial</span><span class="o">.</span>
<span class="n">const</span> <span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">breaks</span> <span class="o">=</span> <span class="p">{</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span> <span class="p">};</span>
<span class="n">std</span><span class="p">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="p">::</span><span class="n">MatrixXd</span><span class="o">&gt;</span> <span class="n">samples</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="nb">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">static_cast</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">breaks</span><span class="o">.</span><span class="n">size</span><span class="p">());</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">std</span><span class="p">::</span><span class="nb">abs</span><span class="p">(</span><span class="n">breaks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="p">}</span>
<span class="n">const</span> <span class="n">auto</span> <span class="n">pp</span> <span class="o">=</span>
     <span class="n">PiecewisePolynomial</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">::</span><span class="n">FirstOrderHold</span><span class="p">(</span><span class="n">breaks</span><span class="p">,</span> <span class="n">samples</span><span class="p">);</span>
<span class="n">const</span> <span class="nb">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Evaluate</span> <span class="n">the</span> <span class="n">PiecewisePolynomial</span> <span class="n">at</span> <span class="n">some</span> <span class="n">values</span><span class="o">.</span>
<span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="o">-.</span><span class="mi">5</span><span class="p">)(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>    <span class="o">//</span> <span class="n">Outputs</span> <span class="mf">0.5</span><span class="o">.</span>
<span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>    <span class="o">//</span> <span class="n">Outputs</span> <span class="mf">0.0</span><span class="p">;</span>

<span class="o">//</span> <span class="n">Show</span> <span class="n">how</span> <span class="n">we</span> <span class="n">can</span> <span class="n">evaluate</span> <span class="n">the</span> <span class="n">first</span> <span class="n">derivative</span> <span class="p">(</span><span class="n">outputs</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">)</span><span class="o">.</span>
<span class="n">std</span><span class="p">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pp</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="o">-.</span><span class="mi">5</span><span class="p">)(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>A note on terminology. For piecewise-polynomial interpolation, we use
<code class="docutils literal"><span class="pre">breaks</span></code> to indicate the scalar (e.g. times) which form the boundary
of each segment. We use <code class="docutils literal"><span class="pre">samples</span></code> to indicate the function value at
the <code class="docutils literal"><span class="pre">breaks</span></code>, e.g. <code class="docutils literal"><span class="pre">p(breaks[i])</span> <span class="pre">=</span> <span class="pre">samples[i]</span></code>. The term <code class="docutils literal"><span class="pre">knot</span></code>
should be reserved for the “(x,y)” coordinate, here <code class="docutils literal"><span class="pre">knot[i]</span> <span class="pre">=</span>
<span class="pre">(breaks[i],</span> <span class="pre">samples[i])</span></code>, though it is used inconsistently in the
interpolation literature (sometimes for <code class="docutils literal"><span class="pre">breaks</span></code>, sometimes for
<code class="docutils literal"><span class="pre">samples</span></code>), so we try to mostly avoid it here.</p>
<p>PiecewisePolynomial objects can be added, subtracted, and multiplied.
They cannot be divided because Polynomials are not closed under
division.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">PiecewisePolynomial silently clips input evaluations outside of
the range defined by the breaks. So <code class="docutils literal"><span class="pre">pp.value(-2.0,</span> <span class="pre">row,</span> <span class="pre">col)</span></code>
in the example above would evaluate to -1.0. See value().</p>
</div>
<p>&#64;tparam_default_scalars</p>
<dl class="method">
<dt id="pydrake.trajectories.PiecewisePolynomial.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.trajectories.PiecewisePolynomial) -&gt; None</li>
</ol>
<p>Constructs an empty piecewise polynomial.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.trajectories.PiecewisePolynomial, arg0: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]) -&gt; None</li>
</ol>
<p>Single segment, constant value constructor over the interval [-∞, ∞].
The constructed PiecewisePolynomial will return <code class="docutils literal"><span class="pre">constant_value</span></code> at
every evaluated point (i.e., <code class="docutils literal"><span class="pre">value(t)</span> <span class="pre">=</span> <span class="pre">constant_value</span></code> ∀t ∈ [-∞,
∞]).</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.trajectories.PiecewisePolynomial, arg0: List[numpy.ndarray[object[m, n]]], arg1: List[float]) -&gt; None</li>
</ol>
<p>Constructs a PiecewisePolynomial using matrix-output Polynomials
defined over each segment.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd><code class="docutils literal"><span class="pre">polynomials.size()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span> <span class="pre">-</span> <span class="pre">1</span></code></dd>
</dl>
<ol class="arabic simple" start="4">
<li>__init__(self: pydrake.trajectories.PiecewisePolynomial, arg0: List[pydrake.polynomial.Polynomial], arg1: List[float]) -&gt; None</li>
</ol>
<p>Constructs a PiecewisePolynomial using scalar-output Polynomials
defined over each segment.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd><code class="docutils literal"><span class="pre">polynomials.size()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span> <span class="pre">-</span> <span class="pre">1</span></code></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.PiecewisePolynomial.AppendCubicHermiteSegment">
<code class="descname">AppendCubicHermiteSegment</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.PiecewisePolynomial, time: float, sample: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], sample_dot: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.AppendCubicHermiteSegment" title="Permalink to this definition">¶</a></dt>
<dd><p>The CubicHermite spline construction has a nice property of being
incremental (each segment can be solved independently). Given a new
sample and it’s derivative, this method adds one segment to the end of
<code class="docutils literal"><span class="pre">this</span></code> where the start sample and derivative are taken as the value
and derivative at the final break of <code class="docutils literal"><span class="pre">this</span></code>.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd><code class="docutils literal"><span class="pre">this</span></code> is not empty()</dd>
<dt>Precondition:</dt>
<dd><code class="docutils literal"><span class="pre">time</span></code> &gt; end_time()</dd>
<dt>Precondition:</dt>
<dd><code class="docutils literal"><span class="pre">sample</span></code> and <code class="docutils literal"><span class="pre">sample_dot</span></code> must have size rows() x cols().</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.PiecewisePolynomial.AppendFirstOrderSegment">
<code class="descname">AppendFirstOrderSegment</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.PiecewisePolynomial, time: float, sample: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.AppendFirstOrderSegment" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a new sample, this method adds one segment to the end of
<code class="docutils literal"><span class="pre">this</span></code> using a first-order hold, where the start sample is taken as
the value at the final break of <code class="docutils literal"><span class="pre">this</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.PiecewisePolynomial.Block">
<code class="descname">Block</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.PiecewisePolynomial</em>, <em>start_row: int</em>, <em>start_col: int</em>, <em>block_rows: int</em>, <em>block_cols: int</em><span class="sig-paren">)</span> &#x2192; pydrake.trajectories.PiecewisePolynomial<a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.Block" title="Permalink to this definition">¶</a></dt>
<dd><p>Extracts a trajectory representing a block of size (block_rows,
block_cols) starting at (start_row, start_col) from the
PiecewisePolynomial.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a PiecewisePolynomial such that ret.value(t) =
this.value(t).block(i,j,p,q);</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.PiecewisePolynomial.ConcatenateInTime">
<code class="descname">ConcatenateInTime</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.PiecewisePolynomial</em>, <em>other: pydrake.trajectories.PiecewisePolynomial</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.ConcatenateInTime" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenates <code class="docutils literal"><span class="pre">other</span></code> to the end of <code class="docutils literal"><span class="pre">this</span></code>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The resulting PiecewisePolynomial will only be continuous to the
degree that the first Polynomial of <code class="docutils literal"><span class="pre">other</span></code> is continuous with
the last Polynomial of <code class="docutils literal"><span class="pre">this</span></code>. See warning about evaluating
discontinuous derivatives at breaks in derivative().</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">other</span></code>:</dt>
<dd>PiecewisePolynomial instance to concatenate.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if trajectories’ dimensions do not match each other</li>
<li>(either rows() or cols() does not match between this and</li>
<li><code class="docutils literal"><span class="pre">other</span></code>).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">this-&gt;end_time()</span></code> and <code class="docutils literal"><span class="pre">other-&gt;start_time()</span></code></li>
<li>are not within PiecewiseTrajectory&lt;T&gt;::kEpsilonTime from each</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">other.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.trajectories.PiecewisePolynomial.CubicHermite">
<em class="property">static </em><code class="descname">CubicHermite</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.CubicHermite" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>CubicHermite(breaks: List[float], samples: List[List[float]], samples_dot: List[List[float]]) -&gt; pydrake.trajectories.PiecewisePolynomial</li>
</ol>
<p>Version of CubicHermite(breaks, samples, samples_dot) that uses vector
samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Corresponding
columns of <code class="docutils literal"><span class="pre">samples</span></code> and <code class="docutils literal"><span class="pre">samples_dot</span></code> are used as the sample
point and independent variable derivative, respectively.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd><code class="docutils literal"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">samples_dot.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</dd>
</dl>
<ol class="arabic simple" start="2">
<li>CubicHermite(breaks: List[float], samples: List[numpy.ndarray[numpy.float64[m, n]]], samples_dot: List[numpy.ndarray[numpy.float64[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial</li>
</ol>
<p>Constructs a third order PiecewisePolynomial using matrix samples and
derivatives of samples (<code class="docutils literal"><span class="pre">samples_dot</span></code>); each matrix element of
<code class="docutils literal"><span class="pre">samples_dot</span></code> represents the derivative with respect to the
independent variable (e.g., the time derivative) of the corresponding
entry in <code class="docutils literal"><span class="pre">samples</span></code>. Each segment is fully specified by <code class="docutils literal"><span class="pre">samples</span></code>
and <code class="docutils literal"><span class="pre">sample_dot</span></code> at both ends. Second derivatives are not
continuous.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.trajectories.PiecewisePolynomial.CubicShapePreserving">
<em class="property">static </em><code class="descname">CubicShapePreserving</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.CubicShapePreserving" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>CubicShapePreserving(breaks: List[float], samples: List[List[float]], zero_end_point_derivatives: bool = False) -&gt; pydrake.trajectories.PiecewisePolynomial</li>
</ol>
<p>Version of CubicShapePreserving(breaks, samples,
zero_end_point_derivatives) that uses vector samples and Eigen
VectorXd and MatrixX&lt;T&gt; arguments. Each column of <code class="docutils literal"><span class="pre">samples</span></code>
represents a sample point.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd><code class="docutils literal"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError under the conditions specified under</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">coefficient_construction_methods.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>CubicShapePreserving(breaks: List[float], samples: List[numpy.ndarray[numpy.float64[m, n]]], zero_end_point_derivatives: bool = False) -&gt; pydrake.trajectories.PiecewisePolynomial</li>
</ol>
<p>Constructs a third order PiecewisePolynomial using vector samples,
where each column of <code class="docutils literal"><span class="pre">samples</span></code> represents a sample point. First
derivatives are chosen to be “shape preserving”, i.e. if <code class="docutils literal"><span class="pre">samples</span></code>
is monotonic within some interval, the interpolated data will also be
monotonic. The second derivative is not guaranteed to be smooth across
the entire spline.</p>
<p>MATLAB calls this method “pchip” (short for “Piecewise Cubic Hermite
Interpolating Polynomial”), and provides a nice description in their
documentation.
<a class="reference external" href="http://home.uchicago.edu/~sctchoi/courses/cs138/interp.pdf">http://home.uchicago.edu/~sctchoi/courses/cs138/interp.pdf</a> is also a
good reference.</p>
<p>If <code class="docutils literal"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal"><span class="pre">False</span></code>, the first and last
first derivative is chosen using a non-centered, shape-preserving
three-point formulae. See equation (2.10) in the following reference
for more details. <a class="reference external" href="http://www.mi.sanu.ac.rs/~gvm/radovi/mon.pdf">http://www.mi.sanu.ac.rs/~gvm/radovi/mon.pdf</a> If
<code class="docutils literal"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal"><span class="pre">True</span></code>, they are set to zeros.</p>
<p>If <code class="docutils literal"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal"><span class="pre">False</span></code>, <cite>breaks</cite> and
<code class="docutils literal"><span class="pre">samples</span></code> must have at least 3 elements for the algorithm to
determine the first derivatives.</p>
<p>If <code class="docutils literal"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal"><span class="pre">True</span></code>, <cite>breaks</cite> and
<code class="docutils literal"><span class="pre">samples</span></code> may have 2 or more elements. For the 2 elements case, the
result is equivalent to computing a cubic polynomial whose values are
given by <code class="docutils literal"><span class="pre">samples</span></code>, and derivatives set to zero.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li><em>RuntimeError if</em> – - <code class="docutils literal"><span class="pre">breaks</span></code> has length smaller than 3 and</li>
<li><code class="docutils literal"><span class="pre">zero_end_point_derivatives</span></code> is <code class="docutils literal"><span class="pre">False</span></code>, - <cite>breaks</cite> has length</li>
<li>smaller than 2 and <code class="docutils literal"><span class="pre">zero_end_point_derivatives</span></code> is true.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError under the conditions specified under</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">coefficient_construction_methods.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.trajectories.PiecewisePolynomial.CubicWithContinuousSecondDerivatives">
<em class="property">static </em><code class="descname">CubicWithContinuousSecondDerivatives</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.CubicWithContinuousSecondDerivatives" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>CubicWithContinuousSecondDerivatives(breaks: List[float], samples: List[List[float]], sample_dot_at_start: numpy.ndarray[numpy.float64[m, n]], sample_dot_at_end: numpy.ndarray[numpy.float64[m, n]]) -&gt; pydrake.trajectories.PiecewisePolynomial</li>
</ol>
<p>Version of CubicWithContinuousSecondDerivatives() that uses vector
samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each column of
<code class="docutils literal"><span class="pre">samples</span></code> represents a sample point.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd><code class="docutils literal"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError under the conditions specified under</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">coefficient_construction_methods.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>CubicWithContinuousSecondDerivatives(breaks: List[float], samples: List[numpy.ndarray[numpy.float64[m, n]]], sample_dot_at_start: numpy.ndarray[numpy.float64[m, n]], sample_dot_at_end: numpy.ndarray[numpy.float64[m, n]]) -&gt; pydrake.trajectories.PiecewisePolynomial</li>
</ol>
<p>Constructs a third order PiecewisePolynomial using matrix samples. The
PiecewisePolynomial is constructed such that the interior segments
have the same value, first and second derivatives at <code class="docutils literal"><span class="pre">breaks</span></code>.
<cite>sample_dot_at_start</cite> and <code class="docutils literal"><span class="pre">sample_dot_at_end</span></code> are used for the first
and last first derivatives.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if <code class="docutils literal"><span class="pre">sample_dot_at_start</span></code> or <code class="docutils literal"><span class="pre">sample_dot_at_end</span></code></li>
<li>and <code class="docutils literal"><span class="pre">samples</span></code> have inconsistent dimensions.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError under the conditions specified under</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">coefficient_construction_methods.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="3">
<li>CubicWithContinuousSecondDerivatives(breaks: List[float], samples: List[List[float]], periodic_end_condition: bool = False) -&gt; pydrake.trajectories.PiecewisePolynomial</li>
</ol>
<p>Version of CubicWithContinuousSecondDerivatives(breaks, samples) that
uses vector samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each
column of <code class="docutils literal"><span class="pre">samples</span></code> represents a sample point.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd><code class="docutils literal"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code>.</dd>
</dl>
<ol class="arabic simple" start="4">
<li>CubicWithContinuousSecondDerivatives(breaks: List[float], samples: List[numpy.ndarray[numpy.float64[m, n]]], periodic_end: bool) -&gt; pydrake.trajectories.PiecewisePolynomial</li>
</ol>
<p>Constructs a third order PiecewisePolynomial using matrix samples. The
PiecewisePolynomial is constructed such that the interior segments
have the same value, first and second derivatives at <code class="docutils literal"><span class="pre">breaks</span></code>. If
<code class="docutils literal"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal"><span class="pre">False</span></code> (default), then the
“Not-a-sample” end condition is used here, which means the third
derivatives are continuous for the first two and last two segments. If
<code class="docutils literal"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal"><span class="pre">True</span></code>, then the first and second
derivatives between the end of the last segment and the beginning of
the first segment will be continuous. Note that the periodic end
condition does not require the first and last sample to be collocated,
nor does it add an additional sample to connect the first and last
segments. Only first and second derivative continuity is enforced. See
<a class="reference external" href="https://en.wikipedia.org/wiki/Spline_interpolation">https://en.wikipedia.org/wiki/Spline_interpolation</a> and
<a class="reference external" href="https://www.math.uh.edu/~jingqiu/math4364/spline.pdf">https://www.math.uh.edu/~jingqiu/math4364/spline.pdf</a> for more about
cubic splines and their end conditions. The MATLAB docs for methods
“spline” and “csape” are also good references.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd><code class="docutils literal"><span class="pre">breaks</span></code> and <code class="docutils literal"><span class="pre">samples</span></code> must have at least 3 elements. If
<code class="docutils literal"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal"><span class="pre">True</span></code>, then for two samples, it
would produce a straight line (use <code class="docutils literal"><span class="pre">FirstOrderHold</span></code> for this
instead), and if <code class="docutils literal"><span class="pre">periodic_end_condition</span></code> is <code class="docutils literal"><span class="pre">False</span></code> the
problem is ill-defined.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.PiecewisePolynomial.derivative">
<code class="descname">derivative</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.PiecewisePolynomial</em>, <em>derivative_order: int = 1</em><span class="sig-paren">)</span> &#x2192; pydrake.trajectories.PiecewisePolynomial<a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.derivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a PiecewisePolynomial where each segment is the specified
derivative of the corresponding segment in <code class="docutils literal"><span class="pre">this</span></code>. Any rules or
limitations of Polynomial::derivative() also apply to this function.</p>
<p>Derivatives evaluated at non-differentiable points return the value at
the left hand side of the interval.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">derivative_order</span></code>:</dt>
<dd>The order of the derivative, namely, if <code class="docutils literal"><span class="pre">derivative_order</span></code> = n,
the n’th derivative of the polynomial will be returned.</dd>
</dl>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">In the event of discontinuous derivatives evaluated at breaks, it
is not defined which polynomial (i.e., to the left or right of the
break) will be the one that is evaluated at the break.</p>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.trajectories.PiecewisePolynomial.FirstOrderHold">
<em class="property">static </em><code class="descname">FirstOrderHold</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.FirstOrderHold" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>FirstOrderHold(breaks: List[float], samples: List[List[float]]) -&gt; pydrake.trajectories.PiecewisePolynomial</li>
</ol>
<p>Version of FirstOrderHold(breaks, samples) that uses vector samples
and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each column of <code class="docutils literal"><span class="pre">samples</span></code>
represents a sample point.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd><code class="docutils literal"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code></dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError under the conditions specified under</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">coefficient_construction_methods.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>FirstOrderHold(breaks: List[float], samples: List[numpy.ndarray[numpy.float64[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial</li>
</ol>
<p>Constructs a piecewise linear PiecewisePolynomial using matrix
samples.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError under the conditions specified under</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">coefficient_construction_methods.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.PiecewisePolynomial.getPolynomial">
<code class="descname">getPolynomial</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.PiecewisePolynomial</em>, <em>segment_index: int</em>, <em>row: int = 0</em>, <em>col: int = 0</em><span class="sig-paren">)</span> &#x2192; pydrake.polynomial.Polynomial<a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.getPolynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the Polynomial with the given matrix row and column index that
corresponds to the given segment index. Equivalent to
<code class="docutils literal"><span class="pre">getPolynomialMatrix(segment_index)(row,</span> <span class="pre">col)</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Calls PiecewiseTrajectory&lt;T&gt;::segment_number_range_check() to
validate <code class="docutils literal"><span class="pre">segment_index</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.PiecewisePolynomial.getPolynomialMatrix">
<code class="descname">getPolynomialMatrix</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.PiecewisePolynomial</em>, <em>segment_index: int</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, n]]<a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.getPolynomialMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the matrix of Polynomials corresponding to the given segment
index.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last"><code class="docutils literal"><span class="pre">segment_index</span></code> is not checked for validity.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.PiecewisePolynomial.getSegmentPolynomialDegree">
<code class="descname">getSegmentPolynomialDegree</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.PiecewisePolynomial</em>, <em>segment_index: int</em>, <em>row: int = 0</em>, <em>col: int = 0</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.getSegmentPolynomialDegree" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the degree of the Polynomial with the given matrix row and column
index that corresponds to the given segment index. Equivalent to
<code class="docutils literal"><span class="pre">getPolynomial(segment_index,</span> <span class="pre">row,</span> <span class="pre">col).GetDegree()</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.PiecewisePolynomial.isApprox">
<code class="descname">isApprox</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.PiecewisePolynomial</em>, <em>other: pydrake.trajectories.PiecewisePolynomial</em>, <em>tol: float</em>, <em>tol_type: pydrake.common._module_py.ToleranceType = &lt;ToleranceType.kRelative: 1&gt;</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.isApprox" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether a PiecewisePolynomial is approximately equal to this
one by calling Polynomial&lt;T&gt;::CoefficientsAlmostEqual() on every
element of every segment.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Polynomial&lt;T&gt;::CoefficientsAlmostEqual().</p>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.trajectories.PiecewisePolynomial.LagrangeInterpolatingPolynomial">
<em class="property">static </em><code class="descname">LagrangeInterpolatingPolynomial</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.LagrangeInterpolatingPolynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>LagrangeInterpolatingPolynomial(times: List[float], samples: List[List[float]]) -&gt; pydrake.trajectories.PiecewisePolynomial</li>
</ol>
<p>Version of LagrangeInterpolatingPolynomial(times, samples) that uses
vector samples and Eigen VectorXd / MatrixX&lt;T&gt; arguments. Each column
of <code class="docutils literal"><span class="pre">samples</span></code> represents a sample point.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd><code class="docutils literal"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">times.size()</span></code>.</dd>
</dl>
<ol class="arabic simple" start="2">
<li>LagrangeInterpolatingPolynomial(times: List[float], samples: List[numpy.ndarray[numpy.float64[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial</li>
</ol>
<p>Constructs a polynomial with a <em>single segment</em> of the lowest possible
degree that passes through all of the sample points. See “polynomial
interpolation” and/or “Lagrange polynomial” on Wikipedia for more
information.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd><code class="docutils literal"><span class="pre">times</span></code> must be monotonically increasing.</dd>
<dt>Precondition:</dt>
<dd><code class="docutils literal"><span class="pre">samples.size()</span> <span class="pre">==</span> <span class="pre">times.size()</span></code>.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.PiecewisePolynomial.RemoveFinalSegment">
<code class="descname">RemoveFinalSegment</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.PiecewisePolynomial</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.RemoveFinalSegment" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes the final segment from the trajectory, reducing the number of
segments by 1.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd><code class="docutils literal"><span class="pre">this</span></code> is not empty()</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.PiecewisePolynomial.Reshape">
<code class="descname">Reshape</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.PiecewisePolynomial</em>, <em>rows: int</em>, <em>cols: int</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.Reshape" title="Permalink to this definition">¶</a></dt>
<dd><p>Reshapes the dimensions of the Eigen::MatrixX&lt;T&gt; returned by value(),
EvalDerivative(), etc.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd><code class="docutils literal"><span class="pre">rows</span></code> x <code class="docutils literal"><span class="pre">cols</span></code> must equal this.rows() * this.cols().</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Eigen::PlainObjectBase::resize().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.PiecewisePolynomial.ReverseTime">
<code class="descname">ReverseTime</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.PiecewisePolynomial</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.ReverseTime" title="Permalink to this definition">¶</a></dt>
<dd><p>Modifies the trajectory so that pp_after(t) = pp_before(-t).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The new trajectory will evaluate differently at precisely the
break points if the original trajectory was discontinuous at the
break points. This is because the segments are defined on the
half-open intervals [breaks(i), breaks(i+1)), and the order of the
breaks have been reversed.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.PiecewisePolynomial.ScaleTime">
<code class="descname">ScaleTime</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.PiecewisePolynomial</em>, <em>scale: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.ScaleTime" title="Permalink to this definition">¶</a></dt>
<dd><p>Scales the time of the trajectory by non-negative <code class="docutils literal"><span class="pre">scale</span></code> (use
ReverseTime() if you want to also negate time). The resulting
polynomial evaluates to pp_after(t) = pp_before(t/scale).</p>
<p>As an example, <a href="#id1"><span class="problematic" id="id2">`</span></a>scale`=2 will result in a trajectory that is twice as
long (start_time() and end_time() have both doubled).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.PiecewisePolynomial.setPolynomialMatrixBlock">
<code class="descname">setPolynomialMatrixBlock</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.PiecewisePolynomial, replacement: numpy.ndarray[object[m, n]], segment_index: int, row_start: int = 0, col_start: int = 0</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.setPolynomialMatrixBlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Replaces the specified block of the PolynomialMatrix at the given
segment index.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Calls PiecewiseTrajectory&lt;T&gt;::segment_number_range_check() to
validate <code class="docutils literal"><span class="pre">segment_index</span></code>.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This code relies upon Eigen to verify that the replacement block
is not too large.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.PiecewisePolynomial.shiftRight">
<code class="descname">shiftRight</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.PiecewisePolynomial</em>, <em>offset: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.shiftRight" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds <code class="docutils literal"><span class="pre">offset</span></code> to all of the breaks. <code class="docutils literal"><span class="pre">offset</span></code> need not be a
non-negative number. The resulting polynomial will evaluate to
pp_after(t) = pp_before(t-offset).</p>
<p>As an example, <a href="#id3"><span class="problematic" id="id4">`</span></a>offset`=2 will result in the start_time() and
end_time() being 2 seconds later.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.PiecewisePolynomial.slice">
<code class="descname">slice</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.PiecewisePolynomial</em>, <em>start_segment_index: int</em>, <em>num_segments: int</em><span class="sig-paren">)</span> &#x2192; pydrake.trajectories.PiecewisePolynomial<a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the PiecewisePolynomial comprising the <code class="docutils literal"><span class="pre">num_segments</span></code>
segments starting at the specified <code class="docutils literal"><span class="pre">start_segment_index</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Calls PiecewiseTrajectory&lt;T&gt;::segment_number_range_check() to
validate <code class="docutils literal"><span class="pre">segment_index</span></code>.</p>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.trajectories.PiecewisePolynomial.ZeroOrderHold">
<em class="property">static </em><code class="descname">ZeroOrderHold</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePolynomial.ZeroOrderHold" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>ZeroOrderHold(breaks: List[float], samples: List[List[float]]) -&gt; pydrake.trajectories.PiecewisePolynomial</li>
</ol>
<p>Version of ZeroOrderHold(breaks, samples) that uses vector samples and
Eigen VectorXd/MatrixX&lt;T&gt; arguments. Each column of <code class="docutils literal"><span class="pre">samples</span></code>
represents a sample point.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd><code class="docutils literal"><span class="pre">samples.cols()</span> <span class="pre">==</span> <span class="pre">breaks.size()</span></code></dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError under the conditions specified under</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">coefficient_construction_methods.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>ZeroOrderHold(breaks: List[float], samples: List[numpy.ndarray[numpy.float64[m, n]]]) -&gt; pydrake.trajectories.PiecewisePolynomial</li>
</ol>
<p>Constructs a piecewise constant PiecewisePolynomial using matrix
samples. Note that constructing a PiecewisePolynomial requires at
least two sample points, although in this case, the second sample
point’s value is ignored, and only its break time is used.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError under the conditions specified under</li>
<li><code class="xref py py-exc docutils literal"><span class="pre">coefficient_construction_methods.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.trajectories.PiecewisePose">
<em class="property">class </em><code class="descclassname">pydrake.trajectories.</code><code class="descname">PiecewisePose</code><a class="headerlink" href="#pydrake.trajectories.PiecewisePose" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory" title="pydrake.trajectories.PiecewiseTrajectory"><code class="xref py py-class docutils literal"><span class="pre">pydrake.trajectories.PiecewiseTrajectory</span></code></a></p>
<p>A wrapper class that represents a pose trajectory, whose rotation part
is a PiecewiseQuaternionSlerp and the translation part is a
PiecewisePolynomial.</p>
<p>&#64;tparam_default_scalars</p>
<dl class="method">
<dt id="pydrake.trajectories.PiecewisePose.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewisePose.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.trajectories.PiecewisePose) -&gt; None</li>
</ol>
<p>Constructs an empty piecewise pose trajectory.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.trajectories.PiecewisePose, position_trajectory: pydrake.trajectories.PiecewisePolynomial, orientation_trajectory: pydrake.trajectories.PiecewiseQuaternionSlerp) -&gt; None</li>
</ol>
<p>Constructor.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">pos_traj</span></code>:</dt>
<dd>Position trajectory.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">rot_traj</span></code>:</dt>
<dd>Orientation trajectory.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.PiecewisePose.get_orientation_trajectory">
<code class="descname">get_orientation_trajectory</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.PiecewisePose</em><span class="sig-paren">)</span> &#x2192; pydrake.trajectories.PiecewiseQuaternionSlerp<a class="headerlink" href="#pydrake.trajectories.PiecewisePose.get_orientation_trajectory" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the orientation trajectory.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.PiecewisePose.get_position_trajectory">
<code class="descname">get_position_trajectory</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.PiecewisePose</em><span class="sig-paren">)</span> &#x2192; pydrake.trajectories.PiecewisePolynomial<a class="headerlink" href="#pydrake.trajectories.PiecewisePose.get_position_trajectory" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the position trajectory.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.PiecewisePose.GetAcceleration">
<code class="descname">GetAcceleration</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.PiecewisePose</em>, <em>time: float</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[6, 1]]<a class="headerlink" href="#pydrake.trajectories.PiecewisePose.GetAcceleration" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the interpolated acceleration at <code class="docutils literal"><span class="pre">time</span></code> or zero if <code class="docutils literal"><span class="pre">time</span></code>
is before this trajectory’s start time or after its end time.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.PiecewisePose.GetPose">
<code class="descname">GetPose</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.PiecewisePose</em>, <em>time: float</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.trajectories.PiecewisePose.GetPose" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the interpolated pose at <code class="docutils literal"><span class="pre">time</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.PiecewisePose.GetVelocity">
<code class="descname">GetVelocity</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.PiecewisePose</em>, <em>time: float</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[6, 1]]<a class="headerlink" href="#pydrake.trajectories.PiecewisePose.GetVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the interpolated velocity at <code class="docutils literal"><span class="pre">time</span></code> or zero if <code class="docutils literal"><span class="pre">time</span></code> is
before this trajectory’s start time or after its end time.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.PiecewisePose.IsApprox">
<code class="descname">IsApprox</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.PiecewisePose</em>, <em>other: pydrake.trajectories.PiecewisePose</em>, <em>tol: float</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.trajectories.PiecewisePose.IsApprox" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if the position and orientation trajectories are both
within <code class="docutils literal"><span class="pre">tol</span></code> from the other’s.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.trajectories.PiecewisePose.MakeCubicLinearWithEndLinearVelocity">
<em class="property">static </em><code class="descname">MakeCubicLinearWithEndLinearVelocity</code><span class="sig-paren">(</span><em>times: List[float], poses: List[pydrake.math.RigidTransform_[float]], start_vel: numpy.ndarray[numpy.float64[3, 1]] = array([ 0.,  0.,  0.]), end_vel: numpy.ndarray[numpy.float64[3, 1]] = array([ 0.,  0.,  0.])</em><span class="sig-paren">)</span> &#x2192; pydrake.trajectories.PiecewisePose<a class="headerlink" href="#pydrake.trajectories.PiecewisePose.MakeCubicLinearWithEndLinearVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a PiecewisePose from given <code class="docutils literal"><span class="pre">time</span></code> and <code class="docutils literal"><span class="pre">poses</span></code>. A cubic
polynomial with given end velocities is used to construct the position
part. The rotational part is represented by a piecewise quaterion
trajectory. There must be at least two elements in <code class="docutils literal"><span class="pre">times</span></code> and
<code class="docutils literal"><span class="pre">poses</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">times</span></code>:</dt>
<dd>Breaks used to build the splines.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">poses</span></code>:</dt>
<dd>Knots used to build the splines.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">start_vel</span></code>:</dt>
<dd>Start linear velocity.</dd>
<dt>Parameter <code class="docutils literal"><span class="pre">end_vel</span></code>:</dt>
<dd>End linear velocity.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.trajectories.PiecewiseQuaternionSlerp">
<em class="property">class </em><code class="descclassname">pydrake.trajectories.</code><code class="descname">PiecewiseQuaternionSlerp</code><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.PiecewiseTrajectory" title="pydrake.trajectories.PiecewiseTrajectory"><code class="xref py py-class docutils literal"><span class="pre">pydrake.trajectories.PiecewiseTrajectory</span></code></a></p>
<p>A class representing a trajectory for quaternions that are
interpolated using piecewise slerp (spherical linear interpolation).
All the orientation samples are expected to be with respect to the
same parent reference frame, i.e. q_i represents the rotation R_PBi
for the orientation of frame B at the ith sample in a fixed parent
frame P. The world frame is a common choice for the parent frame. The
angular velocity and acceleration are also relative to the parent
frame and expressed in the parent frame. Since there is a sign
ambiguity when using quaternions to represent orientation, namely q
and -q represent the same orientation, the internal quaternion
representations ensure that q_n.dot(q_{n+1}) &gt;= 0. Another intuitive
way to think about this is that consecutive quaternions have the
shortest geodesic distance on the unit sphere.</p>
<p>&#64;tparam_default_scalars</p>
<dl class="method">
<dt id="pydrake.trajectories.PiecewiseQuaternionSlerp.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp) -&gt; None</li>
</ol>
<p>Builds an empty PiecewiseQuaternionSlerp.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp, breaks: List[float], quaternions: List[pydrake.common.eigen_geometry.Quaternion_[float]]) -&gt; None</li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if breaks and quaternions have different length, or</li>
<li>breaks have length &lt; 2.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp, breaks: List[float], rotation_matrices: List[numpy.ndarray[numpy.float64[3, 3]]]) -&gt; None</li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if breaks and rot_matrices have different length, or</li>
<li>breaks have length &lt; 2.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="4">
<li>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp, breaks: List[float], rotation_matrices: List[pydrake.math.RotationMatrix_[float]]) -&gt; None</li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if breaks and rot_matrices have different length, or</li>
<li>breaks have length &lt; 2.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="5">
<li>__init__(self: pydrake.trajectories.PiecewiseQuaternionSlerp, breaks: List[float], angle_axes: List[pydrake.common.eigen_geometry.AngleAxis_[float]]) -&gt; None</li>
</ol>
<p>Builds a PiecewiseQuaternionSlerp.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if breaks and ang_axes have different length, or</li>
<li>breaks have length &lt; 2.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.PiecewiseQuaternionSlerp.angular_acceleration">
<code class="descname">angular_acceleration</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.PiecewiseQuaternionSlerp</em>, <em>time: float</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp.angular_acceleration" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolates angular acceleration.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">time</span></code>:</dt>
<dd>Time for interpolation.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The interpolated angular acceleration at <code class="docutils literal"><span class="pre">time</span></code>, which is always
zero for slerp.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.PiecewiseQuaternionSlerp.angular_velocity">
<code class="descname">angular_velocity</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.PiecewiseQuaternionSlerp</em>, <em>time: float</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp.angular_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolates angular velocity.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">time</span></code>:</dt>
<dd>Time for interpolation.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The interpolated angular velocity at <code class="docutils literal"><span class="pre">time</span></code>, which is constant
per segment.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.PiecewiseQuaternionSlerp.Append">
<code class="descname">Append</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp.Append" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>Append(self: pydrake.trajectories.PiecewiseQuaternionSlerp, time: float, quaternion: pydrake.common.eigen_geometry.Quaternion_[float]) -&gt; None</li>
</ol>
<p>Given a new Quaternion, this method adds one segment to the end of
<code class="docutils literal"><span class="pre">this</span></code>.</p>
<ol class="arabic simple" start="2">
<li>Append(self: pydrake.trajectories.PiecewiseQuaternionSlerp, time: float, rotation_matrix: pydrake.math.RotationMatrix_[float]) -&gt; None</li>
</ol>
<p>Given a new RotationMatrix, this method adds one segment to the end of
<code class="docutils literal"><span class="pre">this</span></code>.</p>
<ol class="arabic simple" start="3">
<li>Append(self: pydrake.trajectories.PiecewiseQuaternionSlerp, time: float, angle_axis: pydrake.common.eigen_geometry.AngleAxis_[float]) -&gt; None</li>
</ol>
<p>Given a new AngleAxis, this method adds one segment to the end of
<code class="docutils literal"><span class="pre">this</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.PiecewiseQuaternionSlerp.orientation">
<code class="descname">orientation</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.PiecewiseQuaternionSlerp</em>, <em>time: float</em><span class="sig-paren">)</span> &#x2192; pydrake.common.eigen_geometry.Quaternion_[float]<a class="headerlink" href="#pydrake.trajectories.PiecewiseQuaternionSlerp.orientation" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolates orientation.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">time</span></code>:</dt>
<dd>Time for interpolation.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The interpolated quaternion at <code class="docutils literal"><span class="pre">time</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.trajectories.PiecewiseTrajectory">
<em class="property">class </em><code class="descclassname">pydrake.trajectories.</code><code class="descname">PiecewiseTrajectory</code><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.trajectories.Trajectory" title="pydrake.trajectories.Trajectory"><code class="xref py py-class docutils literal"><span class="pre">pydrake.trajectories.Trajectory</span></code></a></p>
<p>Abstract class that implements the basic logic of maintaining
consequent segments of time (delimited by <code class="docutils literal"><span class="pre">breaks</span></code>) to implement a
trajectory that is represented by simpler logic in each segment or
“piece”.</p>
<p>&#64;tparam_default_scalars</p>
<dl class="attribute">
<dt id="pydrake.trajectories.PiecewiseTrajectory.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.PiecewiseTrajectory.duration">
<code class="descname">duration</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.PiecewiseTrajectory</em>, <em>segment_index: int</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory.duration" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.PiecewiseTrajectory.end_time">
<code class="descname">end_time</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory.end_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>end_time(self: pydrake.trajectories.PiecewiseTrajectory, segment_index: int) -&gt; float</li>
<li>end_time(self: pydrake.trajectories.PiecewiseTrajectory) -&gt; float</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.PiecewiseTrajectory.get_number_of_segments">
<code class="descname">get_number_of_segments</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.PiecewiseTrajectory</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory.get_number_of_segments" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.PiecewiseTrajectory.get_segment_index">
<code class="descname">get_segment_index</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.PiecewiseTrajectory</em>, <em>t: float</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory.get_segment_index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.PiecewiseTrajectory.get_segment_times">
<code class="descname">get_segment_times</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.PiecewiseTrajectory</em><span class="sig-paren">)</span> &#x2192; List[float]<a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory.get_segment_times" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.PiecewiseTrajectory.is_time_in_range">
<code class="descname">is_time_in_range</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.PiecewiseTrajectory</em>, <em>t: float</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory.is_time_in_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true iff <code class="docutils literal"><span class="pre">t</span> <span class="pre">&gt;=</span> <span class="pre">getStartTime()</span> <span class="pre">&amp;&amp;</span> <span class="pre">t</span> <span class="pre">&lt;=</span> <span class="pre">getEndTime()</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.PiecewiseTrajectory.start_time">
<code class="descname">start_time</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.trajectories.PiecewiseTrajectory.start_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>start_time(self: pydrake.trajectories.PiecewiseTrajectory, segment_index: int) -&gt; float</li>
<li>start_time(self: pydrake.trajectories.PiecewiseTrajectory) -&gt; float</li>
</ol>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.trajectories.Trajectory">
<em class="property">class </em><code class="descclassname">pydrake.trajectories.</code><code class="descname">Trajectory</code><a class="headerlink" href="#pydrake.trajectories.Trajectory" title="Permalink to this definition">¶</a></dt>
<dd><p>A Trajectory represents a time-varying matrix, indexed by a single
scalar time.</p>
<p>&#64;tparam_default_scalars</p>
<dl class="attribute">
<dt id="pydrake.trajectories.Trajectory.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.trajectories.Trajectory.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.Trajectory.cols">
<code class="descname">cols</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.Trajectory</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.trajectories.Trajectory.cols" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The number of columns in the matrix returned by value().</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.Trajectory.end_time">
<code class="descname">end_time</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.Trajectory</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.trajectories.Trajectory.end_time" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.Trajectory.EvalDerivative">
<code class="descname">EvalDerivative</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.Trajectory</em>, <em>t: float</em>, <em>derivative_order: int = 1</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, n]]<a class="headerlink" href="#pydrake.trajectories.Trajectory.EvalDerivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates the derivative of <code class="docutils literal"><span class="pre">this</span></code> at the given time <code class="docutils literal"><span class="pre">t</span></code>. Returns
the nth derivative, where <code class="docutils literal"><span class="pre">n</span></code> is the value of <code class="docutils literal"><span class="pre">derivative_order</span></code>.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>derivative_order must be non-negative.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.Trajectory.MakeDerivative">
<code class="descname">MakeDerivative</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.Trajectory</em>, <em>derivative_order: int = 1</em><span class="sig-paren">)</span> &#x2192; pydrake.trajectories.Trajectory<a class="headerlink" href="#pydrake.trajectories.Trajectory.MakeDerivative" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes the derivative of this Trajectory.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">derivative_order</span></code>:</dt>
<dd>The number of times to take the derivative before returning.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The nth derivative of this object.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.Trajectory.rows">
<code class="descname">rows</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.Trajectory</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.trajectories.Trajectory.rows" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The number of rows in the matrix returned by value().</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.Trajectory.start_time">
<code class="descname">start_time</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.Trajectory</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.trajectories.Trajectory.start_time" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.Trajectory.value">
<code class="descname">value</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.Trajectory</em>, <em>t: float</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, n]]<a class="headerlink" href="#pydrake.trajectories.Trajectory.value" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates the trajectory at the given time <code class="docutils literal"><span class="pre">t</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal"><span class="pre">t</span></code>:</dt>
<dd>The time at which to evaluate the trajectory.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The matrix of evaluated values.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.trajectories.Trajectory.vector_values">
<code class="descname">vector_values</code><span class="sig-paren">(</span><em>self: pydrake.trajectories.Trajectory, arg0: List[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, n]]<a class="headerlink" href="#pydrake.trajectories.Trajectory.vector_values" title="Permalink to this definition">¶</a></dt>
<dd><p>If cols()==1, then evaluates the trajectory at each time <code class="docutils literal"><span class="pre">t</span></code>, and
returns the results as a Matrix with the ith column corresponding to
the ith time. Otherwise, if rows()==1, then evaluates the trajectory
at each time <code class="docutils literal"><span class="pre">t</span></code>, and returns the results as a Matrix with the ith
row corresponding to the ith time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if both cols and rows are not equal to 1.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="pydrake.visualization.html" class="btn btn-neutral float-right" title="pydrake.visualization" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="pydrake.systems.trajectory_optimization.html" class="btn btn-neutral" title="pydrake.systems.trajectory_optimization" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  false,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>