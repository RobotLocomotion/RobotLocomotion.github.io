

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pydrake.solvers &mdash; pydrake  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="pydrake.solvers.all" href="pydrake.solvers.all.html" />
    <link rel="prev" title="pydrake.polynomial" href="pydrake.polynomial.html" /> 
</head>

<body class="wy-body-for-nav">

  
<header class="site-header">
  <div class="site-header-inner contain">
    <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
    <div class="menu-mobile-toggle">
      <span></span>
    </div>
    <nav class="site-menu">
      <ul>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/">Home</a>
        </li>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/installation.html">Installation</a>
        </li>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/gallery.html">Gallery</a>
        </li>
        <li class="site-menu-item site-menu-item-main">API Documentation
          <div class="sub">
            <a class="site-menu-item" href="https://drake.mit.edu/doxygen_cxx/index.html">C++</a> <a class="site-menu-item" href="https://drake.mit.edu/pydrake/index.html">Python</a>
          </div>
        </li>
        <li class="site-menu-item site-menu-item-main">Resources
          <div class="sub">
            <a class="site-menu-item" href="/getting_help.html">Getting Help</a> <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/%2Findex.ipynb">Tutorials</a> <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a> <a class="site-menu-item" href="/developers.html">For Developers</a> <a class="site-menu-item" href="/credits.html">Credits</a>
          </div>
        </li>
        <li class="github-link">
          <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
        </li>
      </ul>
    </nav>
  </div>
</header>

  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> pydrake
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search pydrake only…" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
  <form id="ddg-search-form" class="wy_form" action="https://duckduckgo.com/" method="get">
    <input type="text" name="q" placeholder="Search all of Drake…" />
    <input type="hidden" name="sites" value="drake.mit.edu" />
  </form>
</div>


          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="pydrake.all.html">pydrake.all</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.autodiffutils.html">pydrake.autodiffutils</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.common.html">pydrake.common</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.examples.html">pydrake.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.forwarddiff.html">pydrake.forwarddiff</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.geometry.html">pydrake.geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.lcm.html">pydrake.lcm</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.manipulation.html">pydrake.manipulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.math.html">pydrake.math</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.multibody.html">pydrake.multibody</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.perception.html">pydrake.perception</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.polynomial.html">pydrake.polynomial</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">pydrake.solvers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pydrake.solvers.all.html">pydrake.solvers.all</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.solvers.augmented_lagrangian.html">pydrake.solvers.augmented_lagrangian</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.solvers.branch_and_bound.html">pydrake.solvers.branch_and_bound</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.solvers.clp.html">pydrake.solvers.clp</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.solvers.csdp.html">pydrake.solvers.csdp</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.solvers.dreal.html">pydrake.solvers.dreal</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.solvers.gurobi.html">pydrake.solvers.gurobi</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.solvers.ipopt.html">pydrake.solvers.ipopt</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.solvers.mathematicalprogram.html">pydrake.solvers.mathematicalprogram</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.solvers.mixed_integer_optimization_util.html">pydrake.solvers.mixed_integer_optimization_util</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.solvers.mixed_integer_rotation_constraint.html">pydrake.solvers.mixed_integer_rotation_constraint</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.solvers.mosek.html">pydrake.solvers.mosek</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.solvers.nlopt.html">pydrake.solvers.nlopt</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.solvers.osqp.html">pydrake.solvers.osqp</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.solvers.scs.html">pydrake.solvers.scs</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.solvers.sdpa_free_format.html">pydrake.solvers.sdpa_free_format</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.solvers.snopt.html">pydrake.solvers.snopt</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.symbolic.html">pydrake.symbolic</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.systems.html">pydrake.systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.trajectories.html">pydrake.trajectories</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.tutorials.html">pydrake.tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.visualization.html">pydrake.visualization</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pydrake</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>pydrake.solvers</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="pydrake-solvers">
<h1>pydrake.solvers<a class="headerlink" href="#pydrake-solvers" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.all.html">pydrake.solvers.all</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.augmented_lagrangian.html">pydrake.solvers.augmented_lagrangian</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.branch_and_bound.html">pydrake.solvers.branch_and_bound</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.clp.html">pydrake.solvers.clp</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.csdp.html">pydrake.solvers.csdp</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.dreal.html">pydrake.solvers.dreal</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.gurobi.html">pydrake.solvers.gurobi</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.ipopt.html">pydrake.solvers.ipopt</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.mathematicalprogram.html">pydrake.solvers.mathematicalprogram</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.mixed_integer_optimization_util.html">pydrake.solvers.mixed_integer_optimization_util</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.mixed_integer_rotation_constraint.html">pydrake.solvers.mixed_integer_rotation_constraint</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.mosek.html">pydrake.solvers.mosek</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.nlopt.html">pydrake.solvers.nlopt</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.osqp.html">pydrake.solvers.osqp</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.scs.html">pydrake.solvers.scs</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.sdpa_free_format.html">pydrake.solvers.sdpa_free_format</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.snopt.html">pydrake.solvers.snopt</a></li>
</ul>
</div>
<span class="target" id="module-pydrake.solvers"></span><p>Bindings for Solving Mathematical Programs.</p>
<p>If you are formulating constraints using symbolic formulas, please review the
top-level documentation for <a class="reference internal" href="pydrake.math.html#module-pydrake.math" title="pydrake.math"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydrake.math</span></code></a>.</p>
<dl class="function">
<dt id="pydrake.solvers.AddBilinearProductMcCormickEnvelopeSos2">
<code class="descclassname">pydrake.solvers.</code><code class="descname">AddBilinearProductMcCormickEnvelopeSos2</code><span class="sig-paren">(</span><em>prog: pydrake.solvers.MathematicalProgram, x: pydrake.symbolic.Variable, y: pydrake.symbolic.Variable, w: pydrake.symbolic.Expression, phi_x: numpy.ndarray[numpy.float64[m, 1]], phi_y: numpy.ndarray[numpy.float64[m, 1]], Bx: numpy.ndarray[object[m, 1]], By: numpy.ndarray[object[m, 1]], binning: pydrake.solvers.IntervalBinning</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, n]]<a class="headerlink" href="#pydrake.solvers.AddBilinearProductMcCormickEnvelopeSos2" title="Permalink to this definition">¶</a></dt>
<dd><p>Add constraints to the optimization program, such that the bilinear
product x * y is approximated by w, using Special Ordered Set of Type
2 (sos2) constraint. To do so, we assume that the range of x is
[x_min, x_max], and the range of y is [y_min, y_max]. We first
consider two arrays φˣ, φʸ, satisfying</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>x_min = φˣ₀ &lt; φˣ₁ &lt; ... &lt; φˣₘ = x_max
y_min = φʸ₀ &lt; φʸ₁ &lt; ... &lt; φʸₙ = y_max
</pre></div>
</div>
<p>, and divide the range of x into intervals [φˣ₀, φˣ₁], [φˣ₁, φˣ₂], …
, [φˣₘ₋₁, φˣₘ] and the range of y into intervals [φʸ₀, φʸ₁], [φʸ₁,
φʸ₂], … , [φʸₙ₋₁, φʸₙ]. The xy plane is thus cut into rectangles,
with each rectangle as [φˣᵢ, φˣᵢ₊₁] x [φʸⱼ, φʸⱼ₊₁]. The convex hull of
the surface z = x * y for x, y in each rectangle is a tetrahedron. We
then approximate the bilinear product x * y with w, such that (x, y,
w) is in one of the tetrahedrons.</p>
<p>We use two different encoding schemes on the binary variables, to
determine which interval is active. We can choose either linear or
logarithmic binning. When using linear binning, for a variable with N
intervals, we use N binary variables, and B(i) = 1 indicates the
variable is in the i’th interval. When using logarithmic binning, we
use ⌈log₂(N)⌉ binary variables. If these binary variables represent
integer M in the reflected Gray code, then the continuous variable is
in the M’th interval.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">prog</span></code>:</dt>
<dd>The program to which the bilinear product constraint is added</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">x</span></code>:</dt>
<dd>The decision variable.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">y</span></code>:</dt>
<dd>The decision variable.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">w</span></code>:</dt>
<dd>The expression to approximate x * y</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">phi_x</span></code>:</dt>
<dd>The end points of the intervals for <code class="docutils literal notranslate"><span class="pre">x</span></code>.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">phi_y</span></code>:</dt>
<dd>The end points of the intervals for <code class="docutils literal notranslate"><span class="pre">y</span></code>.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Bx</span></code>:</dt>
<dd>The binary variables for the interval in which x stays encoded as
described above.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">By</span></code>:</dt>
<dd>The binary variables for the interval in which y stays encoded as
described above.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">binning</span></code>:</dt>
<dd>Determine whether to use linear binning or logarithmic binning.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">lambda The auxiliary continuous variables.</td>
</tr>
</tbody>
</table>
<p>The constraints we impose are</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>x = (φˣ)ᵀ * ∑ⱼ λᵢⱼ
y = (φʸ)ᵀ * ∑ᵢ λᵢⱼ
w = ∑ᵢⱼ φˣᵢ * φʸⱼ * λᵢⱼ
Both ∑ⱼ λᵢⱼ = λ.rowwise().sum() and ∑ᵢ λᵢⱼ = λ.colwise().sum() satisfy SOS2
constraint.
</pre></div>
</div>
<p>If x ∈ [φx(M), φx(M+1)] and y ∈ [φy(N), φy(N+1)], then only λ(M, N),
λ(M + 1, N), λ(M, N + 1) and λ(M+1, N+1) can be strictly positive, all
other λ(i, j) are zero.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">We DO NOT add the constraint Bx(i) ∈ {0, 1}, By(j) ∈ {0, 1} in
this function. It is the user’s responsibility to ensure that
these constraints are enforced.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="pydrake.solvers.AddLogarithmicSos1Constraint">
<code class="descclassname">pydrake.solvers.</code><code class="descname">AddLogarithmicSos1Constraint</code><span class="sig-paren">(</span><em>prog: pydrake.solvers.MathematicalProgram</em>, <em>num_lambda: int</em><span class="sig-paren">)</span> &#x2192; Tuple[numpy.ndarray[object[m, 1]], numpy.ndarray[object[m, 1]]]<a class="headerlink" href="#pydrake.solvers.AddLogarithmicSos1Constraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the special ordered set of type 1 (SOS1) constraint. Namely</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>λ(0) + ... + λ(n-1) = 1
  λ(i) ≥ 0 ∀i
  ∃ j ∈ {0, 1, ..., n-1}, s.t λ(j) = 1
</pre></div>
</div>
<p>where one and only one of λ(i) is 1, all other λ(j) are 0. We will
need to add ⌈log₂(n)⌉ binary variables, where n is the number of rows
in λ. For more information, please refer to Modeling Disjunctive
Constraints with a Logarithmic Number of Binary Variables and
Constraints by J. Vielma and G. Nemhauser, 2011.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">prog</span></code>:</dt>
<dd>The program to which the SOS1 constraint is added.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_lambda</span></code>:</dt>
<dd>n in the documentation above.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">(lambda, y) lambda is λ in the documentation above. Notice that λ
are declared as continuous variables, but they only admit binary
solutions. y are binary variables of size ⌈log₂(n)⌉. When this
sos1 constraint is satisfied, suppose that λ(i)=1 and λ(j)=0 ∀
j≠i, then y is the Reflected Gray code of i. For example, suppose
n = 8, i = 5, then y is a vector of size ⌈log₂(n)⌉ = 3, and the
value of y is (1, 1, 0) which equals to 5 according to reflected
Gray code.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="pydrake.solvers.AddLogarithmicSos2Constraint">
<code class="descclassname">pydrake.solvers.</code><code class="descname">AddLogarithmicSos2Constraint</code><span class="sig-paren">(</span><em>prog: pydrake.solvers.MathematicalProgram, lambdas: numpy.ndarray[object[m, 1]], binary_variable_name: str = 'y'</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.solvers.AddLogarithmicSos2Constraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the special ordered set 2 (SOS2) constraint,</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddLogarithmicSos2Constraint.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="pydrake.solvers.AddSos2Constraint">
<code class="descclassname">pydrake.solvers.</code><code class="descname">AddSos2Constraint</code><span class="sig-paren">(</span><em>prog: pydrake.solvers.MathematicalProgram, lambdas: numpy.ndarray[object[m, 1]], y: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.AddSos2Constraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the special ordered set 2 (SOS2) constraint. y(i) takes binary
values (either 0 or 1).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">y</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">=&gt;</span> <span class="n">λ</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">λ</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddLogarithmicSos2Constraint for a complete explanation on SOS2
constraint.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">prog</span></code>:</dt>
<dd>The optimization program to which the SOS2 constraint is added.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lambda</span></code>:</dt>
<dd>At most two entries in λ can be strictly positive, and these two
entries have to be adjacent. All other entries are zero. Moreover,
these two entries should sum up to 1.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">y</span></code>:</dt>
<dd>y(i) takes binary value, and determines which two entries in λ can
be strictly positive. Throw a runtime error if y.rows() !=
lambda.rows() - 1.</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.AugmentedLagrangianNonsmooth">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">AugmentedLagrangianNonsmooth</code><a class="headerlink" href="#pydrake.solvers.AugmentedLagrangianNonsmooth" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the augmented Lagrangian (AL) of a given mathematical program</p>
<p>min f(x) s.t h(x) = 0 l &lt;= g(x) &lt;= u x_lo &lt;= x &lt;= x_up</p>
<p>We first turn it into an equality constrained program with
non-negative slack variable s as follows</p>
<p>min f(x) s.t h(x) = 0 c(x) - s = 0 s &gt;= 0</p>
<p>Depending on the option include_x_bounds, the constraint h(x)=0,
c(x)&gt;=0 may or may not include the bounding box constraint x_lo &lt;= x
&lt;= x_up.</p>
<p>the (non-smooth) augmented Lagrangian is defined as</p>
<p>L(x, λ, μ) = f(x) − λ₁ᵀh(x) + μ/2 h(x)ᵀh(x) - λ₂ᵀ(c(x)-s) + μ/2
(c(x)-s)ᵀ(c(x)-s)</p>
<p>where s = max(c(x) - λ₂/μ, 0).</p>
<p>For more details, refer to section 17.4 of Numerical Optimization by
Jorge Nocedal and Stephen Wright, Edition 1, 1999 (This formulation
isn’t presented in Edition 2, but to stay consistent with Edition 2,
we use μ/2 as the coefficient of the quadratic penalty term instead of
1/(2μ) in Edition 1). Note that the augmented Lagrangian L(x, λ, μ) is
NOT a smooth function of x, since s = max(c(x) - λ₂/μ, 0) is
non-smooth at c(x) - λ₂/μ = 0.</p>
<dl class="method">
<dt id="pydrake.solvers.AugmentedLagrangianNonsmooth.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.AugmentedLagrangianNonsmooth</em>, <em>prog: pydrake.solvers.MathematicalProgram</em>, <em>include_x_bounds: bool</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.AugmentedLagrangianNonsmooth.__init__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">prog</span></code>:</dt>
<dd>The mathematical program we will evaluate.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">include_x_bounds</span></code>:</dt>
<dd>. Whether the Lagrangian and the penalty for the bounds x_lo &lt;= x
&lt;= x_up are included in the augmented Lagrangian L(x, λ, μ) or
not.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.AugmentedLagrangianNonsmooth.Eval">
<code class="descname">Eval</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.AugmentedLagrangianNonsmooth.Eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>Eval(self: pydrake.solvers.AugmentedLagrangianNonsmooth, x: numpy.ndarray[numpy.float64[m, 1]], lambda_val: numpy.ndarray[numpy.float64[m, 1]], mu: float) -&gt; Tuple[float, numpy.ndarray[numpy.float64[m, 1]], float]</li>
</ol>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">x</span></code>:</dt>
<dd>The value of all the decision variables.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lambda_val</span></code>:</dt>
<dd>The estimated Lagrangian multipliers. The order of the Lagrangian
multiplier is as this: We first call to evaluate all constraints.
Then for each row of the constraint, if it is an equality
constraint, we append one single Lagrangian multiplier. Otherwise
we append the Lagrangian multiplier for the lower and upper bounds
(where the lower comes before the upper), if the corresponding
bound is not ±∞. The order of evaluating all the constraints is
the same as prog.GetAllConstraints() except for
prog.bounding_box_constraints(). If include_x_bounds=true, then we
aggregate all the bounding_box_constraints() and evaluate them at
the end of all constraints.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mu</span></code>:</dt>
<dd>μ in the documentation above. The constant for penalty term
weight. This should be a strictly positive number.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">constraint_residue</span></code>:</dt>
<dd>The value of the all the constraints. For an equality constraint
c(x)=0 or the inequality constraint c(x)&gt;= 0, the residue is c(x).
Depending on include_x_bounds, <code class="docutils literal notranslate"><span class="pre">constraint_residue</span></code> may or may
not contain the residue for bounding box constraints x_lo &lt;= x &lt;=
x_up at the end.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">cost</span></code>:</dt>
<dd>The value of the cost function f(x).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The evaluated Augmented Lagrangian (AL) L(x, λ, μ).</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>Eval(self: pydrake.solvers.AugmentedLagrangianNonsmooth, x: numpy.ndarray[object[m, 1]], lambda_val: numpy.ndarray[numpy.float64[m, 1]], mu: float) -&gt; Tuple[pydrake.autodiffutils.AutoDiffXd, numpy.ndarray[object[m, 1]], pydrake.autodiffutils.AutoDiffXd]</li>
</ol>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">x</span></code>:</dt>
<dd>The value of all the decision variables.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lambda_val</span></code>:</dt>
<dd>The estimated Lagrangian multipliers. The order of the Lagrangian
multiplier is as this: We first call to evaluate all constraints.
Then for each row of the constraint, if it is an equality
constraint, we append one single Lagrangian multiplier. Otherwise
we append the Lagrangian multiplier for the lower and upper bounds
(where the lower comes before the upper), if the corresponding
bound is not ±∞. The order of evaluating all the constraints is
the same as prog.GetAllConstraints() except for
prog.bounding_box_constraints(). If include_x_bounds=true, then we
aggregate all the bounding_box_constraints() and evaluate them at
the end of all constraints.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mu</span></code>:</dt>
<dd>μ in the documentation above. The constant for penalty term
weight. This should be a strictly positive number.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">constraint_residue</span></code>:</dt>
<dd>The value of the all the constraints. For an equality constraint
c(x)=0 or the inequality constraint c(x)&gt;= 0, the residue is c(x).
Depending on include_x_bounds, <code class="docutils literal notranslate"><span class="pre">constraint_residue</span></code> may or may
not contain the residue for bounding box constraints x_lo &lt;= x &lt;=
x_up at the end.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">cost</span></code>:</dt>
<dd>The value of the cost function f(x).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The evaluated Augmented Lagrangian (AL) L(x, λ, μ).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.AugmentedLagrangianNonsmooth.include_x_bounds">
<code class="descname">include_x_bounds</code><span class="sig-paren">(</span><em>self: pydrake.solvers.AugmentedLagrangianNonsmooth</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.solvers.AugmentedLagrangianNonsmooth.include_x_bounds" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Whether the bounding box constraint x_lo &lt;= x &lt;= x_up is included
in the augmented Lagrangian L(x, λ, μ).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.AugmentedLagrangianNonsmooth.is_equality">
<code class="descname">is_equality</code><span class="sig-paren">(</span><em>self: pydrake.solvers.AugmentedLagrangianNonsmooth</em><span class="sig-paren">)</span> &#x2192; List[bool]<a class="headerlink" href="#pydrake.solvers.AugmentedLagrangianNonsmooth.is_equality" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Whether each constraint is equality or not. The order of the
constraint is explained in the class documentation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.AugmentedLagrangianNonsmooth.lagrangian_size">
<code class="descname">lagrangian_size</code><span class="sig-paren">(</span><em>self: pydrake.solvers.AugmentedLagrangianNonsmooth</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.solvers.AugmentedLagrangianNonsmooth.lagrangian_size" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The size of the Lagrangian multiplier λ.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.AugmentedLagrangianNonsmooth.prog">
<code class="descname">prog</code><span class="sig-paren">(</span><em>self: pydrake.solvers.AugmentedLagrangianNonsmooth</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.MathematicalProgram<a class="headerlink" href="#pydrake.solvers.AugmentedLagrangianNonsmooth.prog" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The mathematical program for which the augmented Lagrangian is
computed.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.AugmentedLagrangianNonsmooth.x_lo">
<code class="descname">x_lo</code><span class="sig-paren">(</span><em>self: pydrake.solvers.AugmentedLagrangianNonsmooth</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.solvers.AugmentedLagrangianNonsmooth.x_lo" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">all the lower bounds of x.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.AugmentedLagrangianNonsmooth.x_up">
<code class="descname">x_up</code><span class="sig-paren">(</span><em>self: pydrake.solvers.AugmentedLagrangianNonsmooth</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.solvers.AugmentedLagrangianNonsmooth.x_up" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">all the upper bounds of x.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.AugmentedLagrangianSmooth">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">AugmentedLagrangianSmooth</code><a class="headerlink" href="#pydrake.solvers.AugmentedLagrangianSmooth" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the augmented Lagrangian (AL) of a given mathematical program</p>
<p>min f(x) s.t h(x) = 0 l &lt;= g(x) &lt;= u x_lo &lt;= x &lt;= x_up</p>
<p>We first turn it into an equality constrained program with
non-negative slack variable s as follows</p>
<p>min f(x) s.t h(x) = 0 c(x) - s = 0 s &gt;= 0</p>
<p>We regard this as an optimization problem on variable (x, s), with
equality constraints h(x) = 0, c(x)-s = 0, and the bound constraint s
&gt;= 0.</p>
<p>Depending on the option include_x_bounds, the constraint h(x)=0,
c(x)&gt;=0 may or may not include the bounding box constraint x_lo &lt;= x
&lt;= x_up.</p>
<p>The (smooth) augmented Lagrangian is defined as</p>
<p>L(x, s, λ, μ) = f(x) − λ₁ᵀh(x) + μ/2 h(x)ᵀh(x) - λ₂ᵀ(c(x)-s) + μ/2
(c(x)-s)ᵀ(c(x)-s)</p>
<p>For more details, refer to section 17.4 of Numerical Optimization by
Jorge Nocedal and Stephen Wright, Edition 2, 2006. Note that the
augmented Lagrangian L(x, s, λ, μ) is a smooth function of (x, s),</p>
<p>This is the implementation used in LANCELOT. To solve the nonlinear
optimization through this Augmented Lagrangian, the nonlinear solve
should be able to handle bounding box constraints on the decision
variables.</p>
<dl class="method">
<dt id="pydrake.solvers.AugmentedLagrangianSmooth.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.AugmentedLagrangianSmooth</em>, <em>prog: pydrake.solvers.MathematicalProgram</em>, <em>include_x_bounds: bool</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.AugmentedLagrangianSmooth.__init__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">prog</span></code>:</dt>
<dd>The mathematical program we will evaluate.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">include_x_bounds</span></code>:</dt>
<dd>. Whether the Lagrangian and the penalty for the bounds x_lo &lt;= x
&lt;= x_up are included in the augmented Lagrangian L(x, s, λ, μ) or
not.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.AugmentedLagrangianSmooth.Eval">
<code class="descname">Eval</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.AugmentedLagrangianSmooth.Eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>Eval(self: pydrake.solvers.AugmentedLagrangianSmooth, x: numpy.ndarray[numpy.float64[m, 1]], s: numpy.ndarray[numpy.float64[m, 1]], lambda_val: numpy.ndarray[numpy.float64[m, 1]], mu: float) -&gt; Tuple[float, numpy.ndarray[numpy.float64[m, 1]], float]</li>
</ol>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">x</span></code>:</dt>
<dd>The value of all the decision variables in prog().</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">s</span></code>:</dt>
<dd>The value of all slack variables s.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lambda_val</span></code>:</dt>
<dd>The estimated Lagrangian multipliers. The order of the Lagrangian
multiplier is as follows: We first call to evaluate all
constraints. Then for each row of the constraint, if it is an
equality constraint, we append one single Lagrangian multiplier.
Otherwise we append the Lagrangian multiplier for the lower and
upper bounds (where the lower comes before the upper), if the
corresponding bound is not ±∞. The order of evaluating all the
constraints is the same as prog.GetAllConstraints() except for
prog.bounding_box_constraints(). If include_x_bounds=true, then we
aggregate all the bounding_box_constraints() and evaluate them at
the end of all constraints.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mu</span></code>:</dt>
<dd>μ in the documentation above. The constant for penalty term
weight. This should be a strictly positive number.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">constraint_residue</span></code>:</dt>
<dd>The value of the all the constraints. For an equality constraint
c(x)=0, the residue is c(x); for an inequality constraint c(x)&gt;=0,
the residue is c(x)-s where s is the corresponding slack variable.
Depending on include_x_bounds, <code class="docutils literal notranslate"><span class="pre">constraint_residue</span></code> may or may
not contain the residue for bounding box constraints x_lo &lt;= x &lt;=
x_up at the end.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">cost</span></code>:</dt>
<dd>The value of the cost function f(x).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The evaluated Augmented Lagrangian (AL) L(x, s, λ, μ).</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This Eval function differs from
AugmentedLagrangianNonsmooth::Eval() function as <code class="docutils literal notranslate"><span class="pre">s</span></code> is an input
argument.</p>
</div>
<ol class="arabic simple" start="2">
<li>Eval(self: pydrake.solvers.AugmentedLagrangianSmooth, x: numpy.ndarray[object[m, 1]], s: numpy.ndarray[object[m, 1]], lambda_val: numpy.ndarray[numpy.float64[m, 1]], mu: float) -&gt; Tuple[pydrake.autodiffutils.AutoDiffXd, numpy.ndarray[object[m, 1]], pydrake.autodiffutils.AutoDiffXd]</li>
</ol>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">x</span></code>:</dt>
<dd>The value of all the decision variables in prog().</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">s</span></code>:</dt>
<dd>The value of all slack variables s.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lambda_val</span></code>:</dt>
<dd>The estimated Lagrangian multipliers. The order of the Lagrangian
multiplier is as follows: We first call to evaluate all
constraints. Then for each row of the constraint, if it is an
equality constraint, we append one single Lagrangian multiplier.
Otherwise we append the Lagrangian multiplier for the lower and
upper bounds (where the lower comes before the upper), if the
corresponding bound is not ±∞. The order of evaluating all the
constraints is the same as prog.GetAllConstraints() except for
prog.bounding_box_constraints(). If include_x_bounds=true, then we
aggregate all the bounding_box_constraints() and evaluate them at
the end of all constraints.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mu</span></code>:</dt>
<dd>μ in the documentation above. The constant for penalty term
weight. This should be a strictly positive number.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">constraint_residue</span></code>:</dt>
<dd>The value of the all the constraints. For an equality constraint
c(x)=0, the residue is c(x); for an inequality constraint c(x)&gt;=0,
the residue is c(x)-s where s is the corresponding slack variable.
Depending on include_x_bounds, <code class="docutils literal notranslate"><span class="pre">constraint_residue</span></code> may or may
not contain the residue for bounding box constraints x_lo &lt;= x &lt;=
x_up at the end.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">cost</span></code>:</dt>
<dd>The value of the cost function f(x).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The evaluated Augmented Lagrangian (AL) L(x, s, λ, μ).</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This Eval function differs from
AugmentedLagrangianNonsmooth::Eval() function as <code class="docutils literal notranslate"><span class="pre">s</span></code> is an input
argument.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.AugmentedLagrangianSmooth.include_x_bounds">
<code class="descname">include_x_bounds</code><span class="sig-paren">(</span><em>self: pydrake.solvers.AugmentedLagrangianSmooth</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.solvers.AugmentedLagrangianSmooth.include_x_bounds" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Whether the bounding box constraint x_lo &lt;= x &lt;= x_up is included
in the augmented Lagrangian L(x, λ, μ).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.AugmentedLagrangianSmooth.is_equality">
<code class="descname">is_equality</code><span class="sig-paren">(</span><em>self: pydrake.solvers.AugmentedLagrangianSmooth</em><span class="sig-paren">)</span> &#x2192; List[bool]<a class="headerlink" href="#pydrake.solvers.AugmentedLagrangianSmooth.is_equality" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Whether each constraint is equality or not. The order of the
constraint is explained in the class documentation.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.AugmentedLagrangianSmooth.lagrangian_size">
<code class="descname">lagrangian_size</code><span class="sig-paren">(</span><em>self: pydrake.solvers.AugmentedLagrangianSmooth</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.solvers.AugmentedLagrangianSmooth.lagrangian_size" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The size of the Lagrangian multiplier λ.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.AugmentedLagrangianSmooth.prog">
<code class="descname">prog</code><span class="sig-paren">(</span><em>self: pydrake.solvers.AugmentedLagrangianSmooth</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.MathematicalProgram<a class="headerlink" href="#pydrake.solvers.AugmentedLagrangianSmooth.prog" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The mathematical program for which the augmented Lagrangian is
computed.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.AugmentedLagrangianSmooth.s_size">
<code class="descname">s_size</code><span class="sig-paren">(</span><em>self: pydrake.solvers.AugmentedLagrangianSmooth</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.solvers.AugmentedLagrangianSmooth.s_size" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The size of the slack variable s.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.AugmentedLagrangianSmooth.x_lo">
<code class="descname">x_lo</code><span class="sig-paren">(</span><em>self: pydrake.solvers.AugmentedLagrangianSmooth</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.solvers.AugmentedLagrangianSmooth.x_lo" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">All the lower bounds of x.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.AugmentedLagrangianSmooth.x_up">
<code class="descname">x_up</code><span class="sig-paren">(</span><em>self: pydrake.solvers.AugmentedLagrangianSmooth</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.solvers.AugmentedLagrangianSmooth.x_up" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">All the upper bounds of x.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="template">
<dt id="pydrake.solvers.Binding">
<em class="property">template </em><code class="descclassname">pydrake.solvers.</code><code class="descname">Binding</code><a class="headerlink" href="#pydrake.solvers.Binding" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.solvers.Binding[EvaluatorBase]" title="pydrake.solvers.Binding[EvaluatorBase]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[EvaluatorBase]</span></code></a>, <a class="reference internal" href="#pydrake.solvers.Binding[Constraint]" title="pydrake.solvers.Binding[Constraint]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[Constraint]</span></code></a>, <a class="reference internal" href="#pydrake.solvers.Binding[LinearConstraint]" title="pydrake.solvers.Binding[LinearConstraint]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[LinearConstraint]</span></code></a>, <a class="reference internal" href="#pydrake.solvers.Binding[LorentzConeConstraint]" title="pydrake.solvers.Binding[LorentzConeConstraint]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[LorentzConeConstraint]</span></code></a>, <a class="reference internal" href="#pydrake.solvers.Binding[RotatedLorentzConeConstraint]" title="pydrake.solvers.Binding[RotatedLorentzConeConstraint]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[RotatedLorentzConeConstraint]</span></code></a>, <a class="reference internal" href="#pydrake.solvers.Binding[LinearEqualityConstraint]" title="pydrake.solvers.Binding[LinearEqualityConstraint]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[LinearEqualityConstraint]</span></code></a>, <a class="reference internal" href="#pydrake.solvers.Binding[BoundingBoxConstraint]" title="pydrake.solvers.Binding[BoundingBoxConstraint]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[BoundingBoxConstraint]</span></code></a>, <a class="reference internal" href="#pydrake.solvers.Binding[PositiveSemidefiniteConstraint]" title="pydrake.solvers.Binding[PositiveSemidefiniteConstraint]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[PositiveSemidefiniteConstraint]</span></code></a>, <a class="reference internal" href="#pydrake.solvers.Binding[LinearMatrixInequalityConstraint]" title="pydrake.solvers.Binding[LinearMatrixInequalityConstraint]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[LinearMatrixInequalityConstraint]</span></code></a>, <a class="reference internal" href="#pydrake.solvers.Binding[LinearComplementarityConstraint]" title="pydrake.solvers.Binding[LinearComplementarityConstraint]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[LinearComplementarityConstraint]</span></code></a>, <a class="reference internal" href="#pydrake.solvers.Binding[ExponentialConeConstraint]" title="pydrake.solvers.Binding[ExponentialConeConstraint]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[ExponentialConeConstraint]</span></code></a>, <a class="reference internal" href="#pydrake.solvers.Binding[Cost]" title="pydrake.solvers.Binding[Cost]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[Cost]</span></code></a>, <a class="reference internal" href="#pydrake.solvers.Binding[LinearCost]" title="pydrake.solvers.Binding[LinearCost]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[LinearCost]</span></code></a>, <a class="reference internal" href="#pydrake.solvers.Binding[QuadraticCost]" title="pydrake.solvers.Binding[QuadraticCost]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[QuadraticCost]</span></code></a>, <a class="reference internal" href="#pydrake.solvers.Binding[L1NormCost]" title="pydrake.solvers.Binding[L1NormCost]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[L1NormCost]</span></code></a>, <a class="reference internal" href="#pydrake.solvers.Binding[L2NormCost]" title="pydrake.solvers.Binding[L2NormCost]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[L2NormCost]</span></code></a>, <a class="reference internal" href="#pydrake.solvers.Binding[LInfNormCost]" title="pydrake.solvers.Binding[LInfNormCost]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[LInfNormCost]</span></code></a>, <a class="reference internal" href="#pydrake.solvers.Binding[PerspectiveQuadraticCost]" title="pydrake.solvers.Binding[PerspectiveQuadraticCost]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[PerspectiveQuadraticCost]</span></code></a>, <a class="reference internal" href="#pydrake.solvers.Binding[VisualizationCallback]" title="pydrake.solvers.Binding[VisualizationCallback]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[VisualizationCallback]</span></code></a></p>
<dl class="class">
<dt id="pydrake.solvers.Binding.Binding[EvaluatorBase]">
<em class="property">class </em><code class="descname">Binding[EvaluatorBase]</code><a class="headerlink" href="#pydrake.solvers.Binding.Binding[EvaluatorBase]" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pydrake.solvers.Binding.Binding[EvaluatorBase].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.Binding.Binding[EvaluatorBase].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.solvers.Binding[EvaluatorBase], c: pydrake.solvers.EvaluatorBase, v: numpy.ndarray[object[m, 1]]) -&gt; None</li>
</ol>
<p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.solvers.Binding[EvaluatorBase], arg0: object) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Binding.Binding[EvaluatorBase].evaluator">
<code class="descname">evaluator</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[EvaluatorBase]</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.EvaluatorBase<a class="headerlink" href="#pydrake.solvers.Binding.Binding[EvaluatorBase].evaluator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Binding.Binding[EvaluatorBase].variables">
<code class="descname">variables</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[EvaluatorBase]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.solvers.Binding.Binding[EvaluatorBase].variables" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.Binding[BoundingBoxConstraint]">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">Binding[BoundingBoxConstraint]</code><a class="headerlink" href="#pydrake.solvers.Binding[BoundingBoxConstraint]" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pydrake.solvers.Binding[BoundingBoxConstraint].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[BoundingBoxConstraint], c: pydrake.solvers.BoundingBoxConstraint, v: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.Binding[BoundingBoxConstraint].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Binding[BoundingBoxConstraint].evaluator">
<code class="descname">evaluator</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[BoundingBoxConstraint]</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.BoundingBoxConstraint<a class="headerlink" href="#pydrake.solvers.Binding[BoundingBoxConstraint].evaluator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Binding[BoundingBoxConstraint].variables">
<code class="descname">variables</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[BoundingBoxConstraint]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.solvers.Binding[BoundingBoxConstraint].variables" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.Binding[Constraint]">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">Binding[Constraint]</code><a class="headerlink" href="#pydrake.solvers.Binding[Constraint]" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pydrake.solvers.Binding[Constraint].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.Binding[Constraint].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.solvers.Binding[Constraint], c: pydrake.solvers.Constraint, v: numpy.ndarray[object[m, 1]]) -&gt; None</li>
</ol>
<p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.solvers.Binding[Constraint], arg0: object) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Binding[Constraint].evaluator">
<code class="descname">evaluator</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[Constraint]</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.Constraint<a class="headerlink" href="#pydrake.solvers.Binding[Constraint].evaluator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Binding[Constraint].variables">
<code class="descname">variables</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[Constraint]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.solvers.Binding[Constraint].variables" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.Binding[Cost]">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">Binding[Cost]</code><a class="headerlink" href="#pydrake.solvers.Binding[Cost]" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pydrake.solvers.Binding[Cost].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.Binding[Cost].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.solvers.Binding[Cost], c: pydrake.solvers.Cost, v: numpy.ndarray[object[m, 1]]) -&gt; None</li>
</ol>
<p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.solvers.Binding[Cost], arg0: object) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Binding[Cost].evaluator">
<code class="descname">evaluator</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[Cost]</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.Cost<a class="headerlink" href="#pydrake.solvers.Binding[Cost].evaluator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Binding[Cost].variables">
<code class="descname">variables</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[Cost]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.solvers.Binding[Cost].variables" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.Binding[EvaluatorBase]">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">Binding[EvaluatorBase]</code><a class="headerlink" href="#pydrake.solvers.Binding[EvaluatorBase]" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pydrake.solvers.Binding[EvaluatorBase].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.Binding[EvaluatorBase].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.solvers.Binding[EvaluatorBase], c: pydrake.solvers.EvaluatorBase, v: numpy.ndarray[object[m, 1]]) -&gt; None</li>
</ol>
<p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.solvers.Binding[EvaluatorBase], arg0: object) -&gt; None</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Binding[EvaluatorBase].evaluator">
<code class="descname">evaluator</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[EvaluatorBase]</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.EvaluatorBase<a class="headerlink" href="#pydrake.solvers.Binding[EvaluatorBase].evaluator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Binding[EvaluatorBase].variables">
<code class="descname">variables</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[EvaluatorBase]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.solvers.Binding[EvaluatorBase].variables" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.Binding[ExponentialConeConstraint]">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">Binding[ExponentialConeConstraint]</code><a class="headerlink" href="#pydrake.solvers.Binding[ExponentialConeConstraint]" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pydrake.solvers.Binding[ExponentialConeConstraint].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[ExponentialConeConstraint], c: pydrake.solvers.ExponentialConeConstraint, v: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.Binding[ExponentialConeConstraint].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Binding[ExponentialConeConstraint].evaluator">
<code class="descname">evaluator</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[ExponentialConeConstraint]</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.ExponentialConeConstraint<a class="headerlink" href="#pydrake.solvers.Binding[ExponentialConeConstraint].evaluator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Binding[ExponentialConeConstraint].variables">
<code class="descname">variables</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[ExponentialConeConstraint]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.solvers.Binding[ExponentialConeConstraint].variables" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.Binding[L1NormCost]">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">Binding[L1NormCost]</code><a class="headerlink" href="#pydrake.solvers.Binding[L1NormCost]" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pydrake.solvers.Binding[L1NormCost].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[L1NormCost], c: pydrake.solvers.L1NormCost, v: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.Binding[L1NormCost].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Binding[L1NormCost].evaluator">
<code class="descname">evaluator</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[L1NormCost]</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.L1NormCost<a class="headerlink" href="#pydrake.solvers.Binding[L1NormCost].evaluator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Binding[L1NormCost].variables">
<code class="descname">variables</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[L1NormCost]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.solvers.Binding[L1NormCost].variables" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.Binding[L2NormCost]">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">Binding[L2NormCost]</code><a class="headerlink" href="#pydrake.solvers.Binding[L2NormCost]" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pydrake.solvers.Binding[L2NormCost].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[L2NormCost], c: pydrake.solvers.L2NormCost, v: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.Binding[L2NormCost].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Binding[L2NormCost].evaluator">
<code class="descname">evaluator</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[L2NormCost]</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.L2NormCost<a class="headerlink" href="#pydrake.solvers.Binding[L2NormCost].evaluator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Binding[L2NormCost].variables">
<code class="descname">variables</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[L2NormCost]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.solvers.Binding[L2NormCost].variables" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.Binding[LinearComplementarityConstraint]">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">Binding[LinearComplementarityConstraint]</code><a class="headerlink" href="#pydrake.solvers.Binding[LinearComplementarityConstraint]" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pydrake.solvers.Binding[LinearComplementarityConstraint].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[LinearComplementarityConstraint], c: pydrake.solvers.LinearComplementarityConstraint, v: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.Binding[LinearComplementarityConstraint].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Binding[LinearComplementarityConstraint].evaluator">
<code class="descname">evaluator</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[LinearComplementarityConstraint]</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.LinearComplementarityConstraint<a class="headerlink" href="#pydrake.solvers.Binding[LinearComplementarityConstraint].evaluator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Binding[LinearComplementarityConstraint].variables">
<code class="descname">variables</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[LinearComplementarityConstraint]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.solvers.Binding[LinearComplementarityConstraint].variables" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.Binding[LinearConstraint]">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">Binding[LinearConstraint]</code><a class="headerlink" href="#pydrake.solvers.Binding[LinearConstraint]" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pydrake.solvers.Binding[LinearConstraint].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[LinearConstraint], c: pydrake.solvers.LinearConstraint, v: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.Binding[LinearConstraint].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Binding[LinearConstraint].evaluator">
<code class="descname">evaluator</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[LinearConstraint]</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.LinearConstraint<a class="headerlink" href="#pydrake.solvers.Binding[LinearConstraint].evaluator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Binding[LinearConstraint].variables">
<code class="descname">variables</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[LinearConstraint]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.solvers.Binding[LinearConstraint].variables" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.Binding[LinearCost]">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">Binding[LinearCost]</code><a class="headerlink" href="#pydrake.solvers.Binding[LinearCost]" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pydrake.solvers.Binding[LinearCost].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[LinearCost], c: pydrake.solvers.LinearCost, v: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.Binding[LinearCost].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Binding[LinearCost].evaluator">
<code class="descname">evaluator</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[LinearCost]</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.LinearCost<a class="headerlink" href="#pydrake.solvers.Binding[LinearCost].evaluator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Binding[LinearCost].variables">
<code class="descname">variables</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[LinearCost]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.solvers.Binding[LinearCost].variables" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.Binding[LinearEqualityConstraint]">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">Binding[LinearEqualityConstraint]</code><a class="headerlink" href="#pydrake.solvers.Binding[LinearEqualityConstraint]" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pydrake.solvers.Binding[LinearEqualityConstraint].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[LinearEqualityConstraint], c: pydrake.solvers.LinearEqualityConstraint, v: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.Binding[LinearEqualityConstraint].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Binding[LinearEqualityConstraint].evaluator">
<code class="descname">evaluator</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[LinearEqualityConstraint]</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.LinearEqualityConstraint<a class="headerlink" href="#pydrake.solvers.Binding[LinearEqualityConstraint].evaluator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Binding[LinearEqualityConstraint].variables">
<code class="descname">variables</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[LinearEqualityConstraint]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.solvers.Binding[LinearEqualityConstraint].variables" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.Binding[LinearMatrixInequalityConstraint]">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">Binding[LinearMatrixInequalityConstraint]</code><a class="headerlink" href="#pydrake.solvers.Binding[LinearMatrixInequalityConstraint]" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pydrake.solvers.Binding[LinearMatrixInequalityConstraint].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[LinearMatrixInequalityConstraint], c: pydrake.solvers.LinearMatrixInequalityConstraint, v: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.Binding[LinearMatrixInequalityConstraint].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Binding[LinearMatrixInequalityConstraint].evaluator">
<code class="descname">evaluator</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[LinearMatrixInequalityConstraint]</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.LinearMatrixInequalityConstraint<a class="headerlink" href="#pydrake.solvers.Binding[LinearMatrixInequalityConstraint].evaluator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Binding[LinearMatrixInequalityConstraint].variables">
<code class="descname">variables</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[LinearMatrixInequalityConstraint]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.solvers.Binding[LinearMatrixInequalityConstraint].variables" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.Binding[LInfNormCost]">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">Binding[LInfNormCost]</code><a class="headerlink" href="#pydrake.solvers.Binding[LInfNormCost]" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pydrake.solvers.Binding[LInfNormCost].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[LInfNormCost], c: pydrake.solvers.LInfNormCost, v: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.Binding[LInfNormCost].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Binding[LInfNormCost].evaluator">
<code class="descname">evaluator</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[LInfNormCost]</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.LInfNormCost<a class="headerlink" href="#pydrake.solvers.Binding[LInfNormCost].evaluator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Binding[LInfNormCost].variables">
<code class="descname">variables</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[LInfNormCost]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.solvers.Binding[LInfNormCost].variables" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.Binding[LorentzConeConstraint]">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">Binding[LorentzConeConstraint]</code><a class="headerlink" href="#pydrake.solvers.Binding[LorentzConeConstraint]" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pydrake.solvers.Binding[LorentzConeConstraint].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[LorentzConeConstraint], c: pydrake.solvers.LorentzConeConstraint, v: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.Binding[LorentzConeConstraint].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Binding[LorentzConeConstraint].evaluator">
<code class="descname">evaluator</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[LorentzConeConstraint]</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.LorentzConeConstraint<a class="headerlink" href="#pydrake.solvers.Binding[LorentzConeConstraint].evaluator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Binding[LorentzConeConstraint].variables">
<code class="descname">variables</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[LorentzConeConstraint]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.solvers.Binding[LorentzConeConstraint].variables" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.Binding[PerspectiveQuadraticCost]">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">Binding[PerspectiveQuadraticCost]</code><a class="headerlink" href="#pydrake.solvers.Binding[PerspectiveQuadraticCost]" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pydrake.solvers.Binding[PerspectiveQuadraticCost].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[PerspectiveQuadraticCost], c: pydrake.solvers.PerspectiveQuadraticCost, v: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.Binding[PerspectiveQuadraticCost].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Binding[PerspectiveQuadraticCost].evaluator">
<code class="descname">evaluator</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[PerspectiveQuadraticCost]</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.PerspectiveQuadraticCost<a class="headerlink" href="#pydrake.solvers.Binding[PerspectiveQuadraticCost].evaluator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Binding[PerspectiveQuadraticCost].variables">
<code class="descname">variables</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[PerspectiveQuadraticCost]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.solvers.Binding[PerspectiveQuadraticCost].variables" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.Binding[PositiveSemidefiniteConstraint]">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">Binding[PositiveSemidefiniteConstraint]</code><a class="headerlink" href="#pydrake.solvers.Binding[PositiveSemidefiniteConstraint]" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pydrake.solvers.Binding[PositiveSemidefiniteConstraint].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[PositiveSemidefiniteConstraint], c: pydrake.solvers.PositiveSemidefiniteConstraint, v: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.Binding[PositiveSemidefiniteConstraint].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Binding[PositiveSemidefiniteConstraint].evaluator">
<code class="descname">evaluator</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[PositiveSemidefiniteConstraint]</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.PositiveSemidefiniteConstraint<a class="headerlink" href="#pydrake.solvers.Binding[PositiveSemidefiniteConstraint].evaluator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Binding[PositiveSemidefiniteConstraint].variables">
<code class="descname">variables</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[PositiveSemidefiniteConstraint]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.solvers.Binding[PositiveSemidefiniteConstraint].variables" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.Binding[QuadraticCost]">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">Binding[QuadraticCost]</code><a class="headerlink" href="#pydrake.solvers.Binding[QuadraticCost]" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pydrake.solvers.Binding[QuadraticCost].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[QuadraticCost], c: pydrake.solvers.QuadraticCost, v: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.Binding[QuadraticCost].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Binding[QuadraticCost].evaluator">
<code class="descname">evaluator</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[QuadraticCost]</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.QuadraticCost<a class="headerlink" href="#pydrake.solvers.Binding[QuadraticCost].evaluator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Binding[QuadraticCost].variables">
<code class="descname">variables</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[QuadraticCost]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.solvers.Binding[QuadraticCost].variables" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.Binding[RotatedLorentzConeConstraint]">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">Binding[RotatedLorentzConeConstraint]</code><a class="headerlink" href="#pydrake.solvers.Binding[RotatedLorentzConeConstraint]" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pydrake.solvers.Binding[RotatedLorentzConeConstraint].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[RotatedLorentzConeConstraint], c: pydrake.solvers.RotatedLorentzConeConstraint, v: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.Binding[RotatedLorentzConeConstraint].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Binding[RotatedLorentzConeConstraint].evaluator">
<code class="descname">evaluator</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[RotatedLorentzConeConstraint]</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.RotatedLorentzConeConstraint<a class="headerlink" href="#pydrake.solvers.Binding[RotatedLorentzConeConstraint].evaluator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Binding[RotatedLorentzConeConstraint].variables">
<code class="descname">variables</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[RotatedLorentzConeConstraint]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.solvers.Binding[RotatedLorentzConeConstraint].variables" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.Binding[VisualizationCallback]">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">Binding[VisualizationCallback]</code><a class="headerlink" href="#pydrake.solvers.Binding[VisualizationCallback]" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pydrake.solvers.Binding[VisualizationCallback].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[VisualizationCallback], c: pydrake.solvers.VisualizationCallback, v: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.Binding[VisualizationCallback].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Binding[VisualizationCallback].evaluator">
<code class="descname">evaluator</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[VisualizationCallback]</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.VisualizationCallback<a class="headerlink" href="#pydrake.solvers.Binding[VisualizationCallback].evaluator" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Binding[VisualizationCallback].variables">
<code class="descname">variables</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Binding[VisualizationCallback]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.solvers.Binding[VisualizationCallback].variables" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.BoundingBoxConstraint">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">BoundingBoxConstraint</code><a class="headerlink" href="#pydrake.solvers.BoundingBoxConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.LinearConstraint" title="pydrake.solvers.LinearConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.LinearConstraint</span></code></a></p>
<p>Implements a constraint of the form <span class="math notranslate nohighlight">\(lb &lt;= x &lt;= ub\)</span></p>
<p>Note: the base Constraint class (as implemented at the moment) could
play this role. But this class enforces that it is ONLY a bounding box
constraint, and not something more general. Some solvers use this
information to handle bounding box constraints differently than
general constraints, so use of this form is encouraged.</p>
<dl class="method">
<dt id="pydrake.solvers.BoundingBoxConstraint.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.BoundingBoxConstraint, lb: numpy.ndarray[numpy.float64[m, 1]], ub: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.BoundingBoxConstraint.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="pydrake.solvers.ChooseBestSolver">
<code class="descclassname">pydrake.solvers.</code><code class="descname">ChooseBestSolver</code><span class="sig-paren">(</span><em>prog: pydrake.solvers.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.SolverId<a class="headerlink" href="#pydrake.solvers.ChooseBestSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Choose the best solver given the formulation in the optimization
program and the availability of the solvers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if there is no available solver for <code class="docutils literal notranslate"><span class="pre">prog</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.ClpSolver">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">ClpSolver</code><a class="headerlink" href="#pydrake.solvers.ClpSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.SolverInterface" title="pydrake.solvers.SolverInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.SolverInterface</span></code></a></p>
<p>A wrapper to call CLP using Drake’s MathematicalProgram.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Currently our ClpSolver has a memory issue when solving a QP. The
user should be aware of this risk.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The authors can adjust the problem scaling option by setting
“scaling” as mentioned in
<a class="reference external" href="https://github.com/coin-or/Clp/blob/43129ba1a7fd66ce70fe0761fcd696951917ed2e/src/ClpModel.hpp#L705-L706">https://github.com/coin-or/Clp/blob/43129ba1a7fd66ce70fe0761fcd696951917ed2e/src/ClpModel.hpp#L705-L706</a>
For example prog.SetSolverOption(ClpSolver::id(), “scaling”, 0);
will do “no scaling”. The default is 1.</p>
</div>
<dl class="method">
<dt id="pydrake.solvers.ClpSolver.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.ClpSolver</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.ClpSolver.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="pydrake.solvers.ClpSolver.id">
<em class="property">static </em><code class="descname">id</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.solvers.SolverId<a class="headerlink" href="#pydrake.solvers.ClpSolver.id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.ClpSolverDetails">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">ClpSolverDetails</code><a class="headerlink" href="#pydrake.solvers.ClpSolverDetails" title="Permalink to this definition">¶</a></dt>
<dd><p>The CLP solver details after calling Solve() function. The user can
call MathematicalProgramResult::get_solver_details&lt;ClpSolver&gt;() to
obtain the details.</p>
<dl class="attribute">
<dt id="pydrake.solvers.ClpSolverDetails.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.solvers.ClpSolverDetails.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.ClpSolverDetails.status">
<code class="descname">status</code><a class="headerlink" href="#pydrake.solvers.ClpSolverDetails.status" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.CommonSolverOption">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">CommonSolverOption</code><a class="headerlink" href="#pydrake.solvers.CommonSolverOption" title="Permalink to this definition">¶</a></dt>
<dd><p>Some options can be applied to not one solver, but many solvers (for
example, many solvers support printing out the progress in each
iteration). CommonSolverOption contain the names of these supported
options. The user can use these options as “key” in
SolverOption::SetOption().</p>
<p>Members:</p>
<blockquote>
<div>kPrintFileName : Many solvers support printing the progress of each iteration to a</div></blockquote>
<p>file. The user can call SolverOptions::SetOption(kPrintFileName,
file_name) where file_name is a string. If the user doesn’t want to
print to a file, then use SolverOptions::SetOption(kPrintFileName,
“”), where the empty string “” indicates no print.</p>
<blockquote>
<div>kPrintToConsole : Many solvers support printing the progress of each iteration to the</div></blockquote>
<p>console, the user can call SolverOptions::SetOption(kPrintToConsole,
1) to turn on printing to the console, or
SolverOptions::SetOption(kPrintToConsole, 0) to turn off printing to
the console.</p>
<dl class="method">
<dt id="pydrake.solvers.CommonSolverOption.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.CommonSolverOption</em>, <em>value: int</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.CommonSolverOption.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.CommonSolverOption.kPrintFileName">
<code class="descname">kPrintFileName</code><em class="property"> = &lt;CommonSolverOption.kPrintFileName: 0&gt;</em><a class="headerlink" href="#pydrake.solvers.CommonSolverOption.kPrintFileName" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.CommonSolverOption.kPrintToConsole">
<code class="descname">kPrintToConsole</code><em class="property"> = &lt;CommonSolverOption.kPrintToConsole: 1&gt;</em><a class="headerlink" href="#pydrake.solvers.CommonSolverOption.kPrintToConsole" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.CommonSolverOption.name">
<code class="descname">name</code><a class="headerlink" href="#pydrake.solvers.CommonSolverOption.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.CommonSolverOption.value">
<code class="descname">value</code><a class="headerlink" href="#pydrake.solvers.CommonSolverOption.value" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.Constraint">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">Constraint</code><a class="headerlink" href="#pydrake.solvers.Constraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.EvaluatorBase" title="pydrake.solvers.EvaluatorBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.EvaluatorBase</span></code></a></p>
<p>A constraint is a function + lower and upper bounds.</p>
<p>Solver interfaces must acknowledge that these constraints are mutable.
Parameters can change after the constraint is constructed and before
the call to Solve().</p>
<p>It should support evaluating the constraint, and adding it to an
optimization problem.</p>
<dl class="attribute">
<dt id="pydrake.solvers.Constraint.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.solvers.Constraint.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Constraint.CheckSatisfied">
<code class="descname">CheckSatisfied</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.Constraint.CheckSatisfied" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>CheckSatisfied(self: pydrake.solvers.Constraint, x: numpy.ndarray[numpy.float64[m, 1]], tol: float = 1e-06) -&gt; bool</li>
</ol>
<p>Return whether this constraint is satisfied by the given value, <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">x</span></code>:</dt>
<dd>A <code class="docutils literal notranslate"><span class="pre">num_vars</span></code> x 1 vector.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">tol</span></code>:</dt>
<dd>A tolerance for bound checking.</dd>
</dl>
<ol class="arabic simple" start="2">
<li>CheckSatisfied(self: pydrake.solvers.Constraint, x: numpy.ndarray[object[m, 1]], tol: float = 1e-06) -&gt; bool</li>
</ol>
<p>Return whether this constraint is satisfied by the given value, <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">x</span></code>:</dt>
<dd>A <code class="docutils literal notranslate"><span class="pre">num_vars</span></code> x 1 vector.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">tol</span></code>:</dt>
<dd>A tolerance for bound checking.</dd>
</dl>
<ol class="arabic simple" start="3">
<li>CheckSatisfied(self: pydrake.solvers.Constraint, x: numpy.ndarray[object[m, 1]]) -&gt; pydrake.symbolic.Formula</li>
</ol>
<p>Return whether this constraint is satisfied by the given value, <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">x</span></code>:</dt>
<dd>A <code class="docutils literal notranslate"><span class="pre">num_vars</span></code> x 1 vector.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">tol</span></code>:</dt>
<dd>A tolerance for bound checking.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Constraint.CheckSatisfiedVectorized">
<code class="descname">CheckSatisfiedVectorized</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Constraint, x: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], tol: float</em><span class="sig-paren">)</span> &#x2192; List[bool]<a class="headerlink" href="#pydrake.solvers.Constraint.CheckSatisfiedVectorized" title="Permalink to this definition">¶</a></dt>
<dd><p>A “vectorized” version of CheckSatisfied.  It evaluates the constraint for every column of <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Constraint.lower_bound">
<code class="descname">lower_bound</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Constraint</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.solvers.Constraint.lower_bound" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Constraint.num_constraints">
<code class="descname">num_constraints</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Constraint</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.solvers.Constraint.num_constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of rows in the output constraint.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.Constraint.upper_bound">
<code class="descname">upper_bound</code><span class="sig-paren">(</span><em>self: pydrake.solvers.Constraint</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.solvers.Constraint.upper_bound" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.Cost">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">Cost</code><a class="headerlink" href="#pydrake.solvers.Cost" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.EvaluatorBase" title="pydrake.solvers.EvaluatorBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.EvaluatorBase</span></code></a></p>
<p>Provides an abstract base for all costs.</p>
<dl class="attribute">
<dt id="pydrake.solvers.Cost.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.solvers.Cost.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.CsdpSolver">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">CsdpSolver</code><a class="headerlink" href="#pydrake.solvers.CsdpSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.SolverInterface" title="pydrake.solvers.SolverInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.SolverInterface</span></code></a></p>
<p>Wrap CSDP solver such that it can solve a
drake::solvers::MathematicalProgram.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">CSDP doesn’t accept free variables, while
drake::solvers::MathematicalProgram does. In order to convert
MathematicalProgram into CSDP format, we provide several
approaches to remove free variables. You can set the approach
through</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">cc</span><span class="p">}</span>
<span class="n">SolverOptions</span> <span class="n">solver_options</span><span class="p">;</span>
<span class="n">solver_options</span><span class="o">.</span><span class="n">SetOption</span><span class="p">(</span><span class="n">CsdpSolver</span><span class="p">::</span><span class="nb">id</span><span class="p">(),</span>
   <span class="s2">&quot;drake::RemoveFreeVariableMethod&quot;</span><span class="p">,</span>
   <span class="n">static_cast</span><span class="o">&lt;</span><span class="nb">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">RemoveFreeVariableMethod</span><span class="p">::</span><span class="n">kNullspace</span><span class="p">));</span>
<span class="n">CsdpSolver</span> <span class="n">solver</span><span class="p">;</span>
<span class="n">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">Solve</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="n">std</span><span class="p">::</span><span class="n">nullopt</span><span class="p">,</span> <span class="n">solver_options</span><span class="p">);</span>
</pre></div>
</div>
<p>For more details, check out RemoveFreeVariableMethod.</p>
<dl class="method">
<dt id="pydrake.solvers.CsdpSolver.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.CsdpSolver</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.CsdpSolver.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Default constructor</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.solvers.CsdpSolver.id">
<em class="property">static </em><code class="descname">id</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.solvers.SolverId<a class="headerlink" href="#pydrake.solvers.CsdpSolver.id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.CsdpSolverDetails">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">CsdpSolverDetails</code><a class="headerlink" href="#pydrake.solvers.CsdpSolverDetails" title="Permalink to this definition">¶</a></dt>
<dd><p>The CSDP solver details after calling Solve() function. The user can
call MathematicalProgramResult::get_solver_details&lt;CsdpSolver&gt;() to
obtain the details.</p>
<dl class="attribute">
<dt id="pydrake.solvers.CsdpSolverDetails.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.solvers.CsdpSolverDetails.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.CsdpSolverDetails.dual_objective">
<code class="descname">dual_objective</code><a class="headerlink" href="#pydrake.solvers.CsdpSolverDetails.dual_objective" title="Permalink to this definition">¶</a></dt>
<dd><p>The dual objective value.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.CsdpSolverDetails.primal_objective">
<code class="descname">primal_objective</code><a class="headerlink" href="#pydrake.solvers.CsdpSolverDetails.primal_objective" title="Permalink to this definition">¶</a></dt>
<dd><p>The primal objective value.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.CsdpSolverDetails.return_code">
<code class="descname">return_code</code><a class="headerlink" href="#pydrake.solvers.CsdpSolverDetails.return_code" title="Permalink to this definition">¶</a></dt>
<dd><p>Refer to the Return Codes section of CSDP 6.2.0 User’s Guide for
explanation on the return code. Some of the common return codes are</p>
<p>0 Problem is solved to optimality. 1 Problem is primal infeasible. 2
Problem is dual infeasible. 3 Problem solved to near optimality. 4
Maximum iterations reached.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.CsdpSolverDetails.y_val">
<code class="descname">y_val</code><a class="headerlink" href="#pydrake.solvers.CsdpSolverDetails.y_val" title="Permalink to this definition">¶</a></dt>
<dd><p>CSDP solves a primal problem of the form</p>
<p>max tr(C*X) s.t tr(Aᵢ*X) = aᵢ X ≽ 0</p>
<p>The dual form is</p>
<p>min aᵀy s.t ∑ᵢ yᵢAᵢ - C = Z Z ≽ 0</p>
<p>y, Z are the variables for the dual problem. y_val, Z_val are the
solutions to the dual problem.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.CsdpSolverDetails.Z_val">
<code class="descname">Z_val</code><a class="headerlink" href="#pydrake.solvers.CsdpSolverDetails.Z_val" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.DrealSolver">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">DrealSolver</code><a class="headerlink" href="#pydrake.solvers.DrealSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.SolverInterface" title="pydrake.solvers.SolverInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.SolverInterface</span></code></a></p>
<p>An implementation of SolverInterface for the dReal4 solver
(<a class="reference external" href="https://github.com/dreal/dreal4">https://github.com/dreal/dreal4</a>).</p>
<p>Currently this implementation supports the following options: *
precision &lt;double&gt;: This value is used as a termination condition.
When the ICP algorithm finds an interval box whose width is smaller
than this value, it concludes that the query is delta-satisfiable and
provides the interval box as a witness. Default value = 0.001.</p>
<ul class="simple">
<li>use_local_optimization &lt;bool&gt;: Use local-optimization algorithms in</li>
</ul>
<p>solving exists-forall problem. For now, the solver is using NLopt. See
<a class="reference external" href="https://link.springer.com/chapter/10.1007%2F978-3-319-96142-2_15">https://link.springer.com/chapter/10.1007%2F978-3-319-96142-2_15</a> for
details. Default value = True.</p>
<p>To see the full list of dReal4 options, visit
<a class="reference external" href="https://github.com/dreal/dreal4#command-line-options">https://github.com/dreal/dreal4#command-line-options</a>.</p>
<dl class="method">
<dt id="pydrake.solvers.DrealSolver.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.DrealSolver</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.DrealSolver.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="pydrake.solvers.DrealSolver.CheckSatisfiability">
<em class="property">static </em><code class="descname">CheckSatisfiability</code><span class="sig-paren">(</span><em>f: pydrake.symbolic.Formula</em>, <em>delta: float</em><span class="sig-paren">)</span> &#x2192; Optional[Dict[pydrake.symbolic.Variable, pydrake.solvers.DrealSolver.Interval]]<a class="headerlink" href="#pydrake.solvers.DrealSolver.CheckSatisfiability" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks the satisfiability of a given formula <code class="docutils literal notranslate"><span class="pre">f</span></code> with a given
precision <code class="docutils literal notranslate"><span class="pre">delta</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a model, a mapping from a variable to an interval, if <code class="docutils literal notranslate"><span class="pre">f</span></code> is
δ-satisfiable.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a nullopt, if <code class="docutils literal notranslate"><span class="pre">is</span></code> unsatisfiable.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.solvers.DrealSolver.id">
<em class="property">static </em><code class="descname">id</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.solvers.SolverId<a class="headerlink" href="#pydrake.solvers.DrealSolver.id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="pydrake.solvers.DrealSolver.Interval">
<em class="property">class </em><code class="descname">Interval</code><a class="headerlink" href="#pydrake.solvers.DrealSolver.Interval" title="Permalink to this definition">¶</a></dt>
<dd><p>Class representing an interval of doubles.</p>
<dl class="method">
<dt id="pydrake.solvers.DrealSolver.Interval.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.DrealSolver.Interval</em>, <em>low: float</em>, <em>high: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.DrealSolver.Interval.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs an interval [low, high].</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>Its lower bound <code class="docutils literal notranslate"><span class="pre">low</span></code> must be less than or equal to its upper
bound <code class="docutils literal notranslate"><span class="pre">high</span></code>.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.DrealSolver.Interval.diam">
<code class="descname">diam</code><span class="sig-paren">(</span><em>self: pydrake.solvers.DrealSolver.Interval</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.solvers.DrealSolver.Interval.diam" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns its diameter.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.DrealSolver.Interval.high">
<code class="descname">high</code><span class="sig-paren">(</span><em>self: pydrake.solvers.DrealSolver.Interval</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.solvers.DrealSolver.Interval.high" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns its upper bound.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.DrealSolver.Interval.low">
<code class="descname">low</code><span class="sig-paren">(</span><em>self: pydrake.solvers.DrealSolver.Interval</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.solvers.DrealSolver.Interval.low" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns its lower bound.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.DrealSolver.Interval.mid">
<code class="descname">mid</code><span class="sig-paren">(</span><em>self: pydrake.solvers.DrealSolver.Interval</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.solvers.DrealSolver.Interval.mid" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns its mid-point.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.DrealSolver.LocalOptimization">
<em class="property">class </em><code class="descname">LocalOptimization</code><a class="headerlink" href="#pydrake.solvers.DrealSolver.LocalOptimization" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicates whether to use dReal’s –local-optimization option or not.</p>
<p>Members:</p>
<blockquote>
<div><p>kUse : Use “–local-optimization” option.</p>
<p>kNotUse : Do not use “–local-optimization” option.</p>
</div></blockquote>
<dl class="method">
<dt id="pydrake.solvers.DrealSolver.LocalOptimization.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.DrealSolver.LocalOptimization</em>, <em>value: int</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.DrealSolver.LocalOptimization.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.DrealSolver.LocalOptimization.kNotUse">
<code class="descname">kNotUse</code><em class="property"> = &lt;LocalOptimization.kNotUse: 1&gt;</em><a class="headerlink" href="#pydrake.solvers.DrealSolver.LocalOptimization.kNotUse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.DrealSolver.LocalOptimization.kUse">
<code class="descname">kUse</code><em class="property"> = &lt;LocalOptimization.kUse: 0&gt;</em><a class="headerlink" href="#pydrake.solvers.DrealSolver.LocalOptimization.kUse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.DrealSolver.LocalOptimization.name">
<code class="descname">name</code><a class="headerlink" href="#pydrake.solvers.DrealSolver.LocalOptimization.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.DrealSolver.LocalOptimization.value">
<code class="descname">value</code><a class="headerlink" href="#pydrake.solvers.DrealSolver.LocalOptimization.value" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.solvers.DrealSolver.Minimize">
<em class="property">static </em><code class="descname">Minimize</code><span class="sig-paren">(</span><em>objective: pydrake.symbolic.Expression</em>, <em>constraint: pydrake.symbolic.Formula</em>, <em>delta: float</em>, <em>local_optimization: pydrake.solvers.DrealSolver.LocalOptimization</em><span class="sig-paren">)</span> &#x2192; Optional[Dict[pydrake.symbolic.Variable, pydrake.solvers.DrealSolver.Interval]]<a class="headerlink" href="#pydrake.solvers.DrealSolver.Minimize" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds a solution to minimize <code class="docutils literal notranslate"><span class="pre">objective</span></code> function while satisfying a
given <code class="docutils literal notranslate"><span class="pre">constraint</span></code> using <code class="docutils literal notranslate"><span class="pre">delta</span></code>. When <code class="docutils literal notranslate"><span class="pre">local_optimization</span></code> is
Localoptimization::kUse, enable “–local-optimization” dReal option
which uses NLopt’s local-optimization algorithms to refine
counterexamples in the process of global optimization.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a model, a mapping from a variable to an interval, if a solution
exists.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">nullopt, if there is no solution.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.EvaluatorBase">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">EvaluatorBase</code><a class="headerlink" href="#pydrake.solvers.EvaluatorBase" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="pydrake.solvers.EvaluatorBase.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.solvers.EvaluatorBase.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.EvaluatorBase.Eval">
<code class="descname">Eval</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.EvaluatorBase.Eval" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>Eval(self: pydrake.solvers.EvaluatorBase, x: numpy.ndarray[numpy.float64[m, 1]]) -&gt; numpy.ndarray[numpy.float64[m, 1]]</li>
</ol>
<p>Evaluates the expression.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">x</span></code>:</dt>
<dd>A <code class="docutils literal notranslate"><span class="pre">num_vars</span></code> x 1 input vector.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">y</span></code>:</dt>
<dd>A <code class="docutils literal notranslate"><span class="pre">num_outputs</span></code> x 1 output vector.</dd>
</dl>
<ol class="arabic simple" start="2">
<li>Eval(self: pydrake.solvers.EvaluatorBase, x: numpy.ndarray[object[m, 1]]) -&gt; numpy.ndarray[object[m, 1]]</li>
</ol>
<p>Evaluates the expression.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">x</span></code>:</dt>
<dd>A <code class="docutils literal notranslate"><span class="pre">num_vars</span></code> x 1 input vector.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">y</span></code>:</dt>
<dd>A <code class="docutils literal notranslate"><span class="pre">num_outputs</span></code> x 1 output vector.</dd>
</dl>
<ol class="arabic simple" start="3">
<li>Eval(self: pydrake.solvers.EvaluatorBase, x: numpy.ndarray[object[m, 1]]) -&gt; numpy.ndarray[object[m, 1]]</li>
</ol>
<p>Evaluates the expression.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">x</span></code>:</dt>
<dd>A <code class="docutils literal notranslate"><span class="pre">num_vars</span></code> x 1 input vector.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">y</span></code>:</dt>
<dd>A <code class="docutils literal notranslate"><span class="pre">num_outputs</span></code> x 1 output vector.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.EvaluatorBase.get_description">
<code class="descname">get_description</code><span class="sig-paren">(</span><em>self: pydrake.solvers.EvaluatorBase</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.solvers.EvaluatorBase.get_description" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for a human-friendly description for the evaluator.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.EvaluatorBase.gradient_sparsity_pattern">
<code class="descname">gradient_sparsity_pattern</code><span class="sig-paren">(</span><em>self: pydrake.solvers.EvaluatorBase</em><span class="sig-paren">)</span> &#x2192; Optional[List[Tuple[int, int]]]<a class="headerlink" href="#pydrake.solvers.EvaluatorBase.gradient_sparsity_pattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the vector of (row_index, col_index) that contains all the
entries in the gradient of Eval function (∂y/∂x) whose value could be
non-zero, namely if ∂yᵢ/∂xⱼ could be non-zero, then the pair (i, j) is
in gradient_sparsity_pattern.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">gradient_sparsity_pattern</span></code>:</dt>
<dd>If nullopt, then we regard all entries of the gradient as
potentially non-zero.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.EvaluatorBase.num_outputs">
<code class="descname">num_outputs</code><span class="sig-paren">(</span><em>self: pydrake.solvers.EvaluatorBase</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.solvers.EvaluatorBase.num_outputs" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for the number of outputs, namely the number of rows in y, as
used in Eval(x, y).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.EvaluatorBase.num_vars">
<code class="descname">num_vars</code><span class="sig-paren">(</span><em>self: pydrake.solvers.EvaluatorBase</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.solvers.EvaluatorBase.num_vars" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for the number of variables, namely the number of rows in x, as
used in Eval(x, y).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.EvaluatorBase.set_description">
<code class="descname">set_description</code><span class="sig-paren">(</span><em>self: pydrake.solvers.EvaluatorBase</em>, <em>arg0: str</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.EvaluatorBase.set_description" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a human-friendly description for the evaluator.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.EvaluatorBase.SetGradientSparsityPattern">
<code class="descname">SetGradientSparsityPattern</code><span class="sig-paren">(</span><em>self: pydrake.solvers.EvaluatorBase, gradient_sparsity_pattern: List[Tuple[int, int]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.EvaluatorBase.SetGradientSparsityPattern" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the sparsity pattern of the gradient matrix ∂y/∂x (the gradient of
y value in Eval, w.r.t x in Eval) . gradient_sparsity_pattern contains
<em>all</em> the pairs of (row_index, col_index) for which the corresponding
entries could have non-zero value in the gradient matrix ∂y/∂x.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.ExponentialConeConstraint">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">ExponentialConeConstraint</code><a class="headerlink" href="#pydrake.solvers.ExponentialConeConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.Constraint" title="pydrake.solvers.Constraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Constraint</span></code></a></p>
<p>An exponential cone constraint is a special type of convex cone
constraint. We constrain A * x + b to be in the exponential cone,
where A has 3 rows, and b is in ℝ³, x is the decision variable. A
vector z in ℝ³ is in the exponential cone, if {z₀, z₁, z₂ | z₀ ≥ z₁ *
exp(z₂ / z₁), z₁ &gt; 0}. Equivalently, this constraint can be
refomulated with logarithm function {z₀, z₁, z₂ | z₂ ≤ z₁ * log(z₀ /
z₁), z₀ &gt; 0, z₁ &gt; 0}</p>
<p>The Eval function implemented in this class is z₀ - z₁ * exp(z₂ / z₁)
&gt;= 0, z₁ &gt; 0 where z = A * x + b. It is not recommended to solve an
exponential cone constraint through generic nonlinear optimization. It
is possible that the nonlinear solver can accidentally set z₁ = 0,
where the constraint is not well defined. Instead, the user should
consider to solve the program through conic solvers that can exploit
exponential cone, such as MOSEK<a href="/tm.html">™</a> and SCS.</p>
<dl class="method">
<dt id="pydrake.solvers.ExponentialConeConstraint.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.ExponentialConeConstraint, A: numpy.ndarray[numpy.float64[m, n]], b: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.ExponentialConeConstraint.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor for exponential cone. Constrains A * x + b to be in the
exponential cone.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>A has 3 rows.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.ExponentialConeConstraint.A">
<code class="descname">A</code><span class="sig-paren">(</span><em>self: pydrake.solvers.ExponentialConeConstraint</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, n]]<a class="headerlink" href="#pydrake.solvers.ExponentialConeConstraint.A" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for matrix A.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.ExponentialConeConstraint.b">
<code class="descname">b</code><span class="sig-paren">(</span><em>self: pydrake.solvers.ExponentialConeConstraint</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.solvers.ExponentialConeConstraint.b" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for vector b.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pydrake.solvers.GenerateSDPA">
<code class="descclassname">pydrake.solvers.</code><code class="descname">GenerateSDPA</code><span class="sig-paren">(</span><em>prog: pydrake.solvers.MathematicalProgram</em>, <em>file_name: str</em>, <em>method: pydrake.solvers.RemoveFreeVariableMethod = &lt;RemoveFreeVariableMethod.kNullspace: 2&gt;</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.solvers.GenerateSDPA" title="Permalink to this definition">¶</a></dt>
<dd><p>SDPA is a format to record an SDP problem</p>
<p>max tr(C*X) s.t tr(Aᵢ*X) = gᵢ X ≽ 0</p>
<p>or the dual of the problem</p>
<p>min gᵀy s.t ∑ᵢ yᵢAᵢ - C ≽ 0</p>
<p>where X is a symmetric block diagonal matrix. The format is described
in <a class="reference external" href="http://plato.asu.edu/ftp/sdpa_format.txt">http://plato.asu.edu/ftp/sdpa_format.txt</a>. Many solvers, such as
CSDP, DSDP, SDPA, sedumi and SDPT3, accept an SDPA format file as the
input. This function reads a MathematicalProgram that can be
formulated as above, and write an SDPA file.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">prog</span></code>:</dt>
<dd>a program that contains an optimization program.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">file_name</span></code>:</dt>
<dd>The name of the file, note that the extension will be added
automatically.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">method</span></code>:</dt>
<dd>If <code class="docutils literal notranslate"><span class="pre">prog</span></code> contains free variables (i.e., variables without
bounds), then we need to remove these free variables to write the
program in the SDPA format. Please refer to
RemoveFreeVariableMethod for details on how to remove the free
variables. $*Default:* is RemoveFreeVariableMethod::kNullspace.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">is_success</span></code>:</dt>
<dd>. Returns true if we can generate the SDPA file. The failure could
be 1. <code class="docutils literal notranslate"><span class="pre">prog</span></code> cannot be captured by the formulation above. 2.
<code class="docutils literal notranslate"><span class="pre">prog</span></code> cannot create a file with the given name, etc.</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="pydrake.solvers.GetAvailableSolvers">
<code class="descclassname">pydrake.solvers.</code><code class="descname">GetAvailableSolvers</code><span class="sig-paren">(</span><em>prog_type: pydrake.solvers.ProgramType</em><span class="sig-paren">)</span> &#x2192; List[pydrake.solvers.SolverId]<a class="headerlink" href="#pydrake.solvers.GetAvailableSolvers" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the list of available and enabled solvers that definitely
accept all programs of the given program type. The order of the
returned SolverIds reflects an approximate order of preference, from
most preferred (front) to least preferred (back). Because we are
analyzing only based on the program type rather than a specific
program, it’s possible that solvers later in the list would perform
better in certain situations. To obtain the truly best solver, using
ChooseBestSolver() instead.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If a solver only accepts a subset of the program type, then that
solver is not included in the returned results. For example
EqualityConstrainedQPSolver doesn’t accept programs with
inequality linear constraints, so it doesn’t show up in the return
of GetAvailableSolvers(ProgramType::kQP).</p>
</div>
</dd></dl>

<dl class="function">
<dt id="pydrake.solvers.GetProgramType">
<code class="descclassname">pydrake.solvers.</code><code class="descname">GetProgramType</code><span class="sig-paren">(</span><em>arg0: pydrake.solvers.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.ProgramType<a class="headerlink" href="#pydrake.solvers.GetProgramType" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the type of the optimization program (LP, QP, etc), based on
the properties of its cost/constraints/variables. Each mathematical
program should be characterized by a unique type. If a program can be
characterized as either type A or type B (for example, a program with
linear constraint and linear costs can be characterized as either an
LP or an SDP), then we choose the type corresponding to a smaller set
of programs (LP in this case).</p>
</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.GurobiSolver">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">GurobiSolver</code><a class="headerlink" href="#pydrake.solvers.GurobiSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.SolverInterface" title="pydrake.solvers.SolverInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.SolverInterface</span></code></a></p>
<p>An implementation of SolverInterface for the commercially-licensed
Gurobi solver (<a class="reference external" href="https://www.gurobi.com/">https://www.gurobi.com/</a>).</p>
<p>The default build of Drake is not configured to use Gurobi, so
therefore SolverInterface::available() will return false. You must
compile Drake from source in order to link against Gurobi. For
details, refer to the documentation at
<a class="reference external" href="https://drake.mit.edu/bazel.html#proprietary-solvers">https://drake.mit.edu/bazel.html#proprietary-solvers</a>.</p>
<p>The GRB_LICENSE_FILE environment variable controls whether or not
SolverInterface::enabled() returns true. If it is set to any non-empty
value, then the solver is enabled; otherwise, the solver is not
enabled.</p>
<p>Gurobi solver supports options/parameters listed in
<a class="reference external" href="https://www.gurobi.com/documentation/9.1/refman/parameters.html">https://www.gurobi.com/documentation/9.1/refman/parameters.html</a>. On
top of these options, we provide the following additional options 1.
“GRBwrite”, set to a file name so that Gurobi solver will write the
optimization model to this file, check
<a class="reference external" href="https://www.gurobi.com/documentation/9.1/refman/py_model_write.html">https://www.gurobi.com/documentation/9.1/refman/py_model_write.html</a>
for more details, such as all supported file extensions. Set this
option to “” if you don’t want to write to file. Default is not to
write to a file. 2. “GRBcomputeIIS”, set to 1 to compute an
Irreducible Inconsistent Subsystem (IIS) when the problem is
infeasible. Refer to
<a class="reference external" href="https://www.gurobi.com/documentation/9.1/refman/py_model_computeiis.html">https://www.gurobi.com/documentation/9.1/refman/py_model_computeiis.html</a>
for more details. Often this method is called together with setting
GRBwrite to “FILENAME.ilp” to write IIS to a file with extension
“ilp”. Default is not to compute IIS.</p>
<dl class="method">
<dt id="pydrake.solvers.GurobiSolver.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.GurobiSolver</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.GurobiSolver.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="pydrake.solvers.GurobiSolver.AcquireLicense">
<em class="property">static </em><code class="descname">AcquireLicense</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.solvers.GurobiSolver.License<a class="headerlink" href="#pydrake.solvers.GurobiSolver.AcquireLicense" title="Permalink to this definition">¶</a></dt>
<dd><p>This acquires a Gurobi license environment shared among all
GurobiSolver instances; the environment will stay valid as long as at
least one shared_ptr returned by this function is alive. Call this
ONLY if you must use different MathematicalProgram instances at
different instances in time, and repeatedly acquiring the license is
costly (e.g., requires contacting a license server).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A shared pointer to a license environment that will stay valid as
long as any shared_ptr returned by this function is alive. If
Gurobi not available in your build, this will return a null
(empty) shared_ptr.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if Gurobi is available but a license cannot be</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">obtained.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.GurobiSolver.AddMipNodeCallback">
<code class="descname">AddMipNodeCallback</code><span class="sig-paren">(</span><em>self: pydrake.solvers.GurobiSolver, callback: Callable[[pydrake.solvers.MathematicalProgram, pydrake.solvers.GurobiSolver.SolveStatusInfo, numpy.ndarray[numpy.float64[m, 1]], numpy.ndarray[object[m, 1]]], None]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.GurobiSolver.AddMipNodeCallback" title="Permalink to this definition">¶</a></dt>
<dd><p>Registers a callback to be called at intermediate solutions during the
solve.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">callback</span></code>:</dt>
<dd>User callback function.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">user_data</span></code>:</dt>
<dd>Arbitrary data that will be passed to the user callback function.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.GurobiSolver.AddMipSolCallback">
<code class="descname">AddMipSolCallback</code><span class="sig-paren">(</span><em>self: pydrake.solvers.GurobiSolver, callback: Callable[[pydrake.solvers.MathematicalProgram, pydrake.solvers.GurobiSolver.SolveStatusInfo], None]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.GurobiSolver.AddMipSolCallback" title="Permalink to this definition">¶</a></dt>
<dd><p>Registers a callback to be called at feasible solutions during the
solve.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">callback</span></code>:</dt>
<dd>User callback function.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">usrdata</span></code>:</dt>
<dd>Arbitrary data that will be passed to the user callback function.</dd>
</dl>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.solvers.GurobiSolver.id">
<em class="property">static </em><code class="descname">id</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.solvers.SolverId<a class="headerlink" href="#pydrake.solvers.GurobiSolver.id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="pydrake.solvers.GurobiSolver.License">
<em class="property">class </em><code class="descname">License</code><a class="headerlink" href="#pydrake.solvers.GurobiSolver.License" title="Permalink to this definition">¶</a></dt>
<dd><p>Context-manageable license from <code class="docutils literal notranslate"><span class="pre">GurobiSolver.AcquireLicense()</span></code>.</p>
<dl class="attribute">
<dt id="pydrake.solvers.GurobiSolver.License.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.solvers.GurobiSolver.License.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.GurobiSolver.License.is_valid">
<code class="descname">is_valid</code><span class="sig-paren">(</span><em>self: pydrake.solvers.GurobiSolver.License</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.solvers.GurobiSolver.License.is_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicates that this has a valid license that has not been released.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.GurobiSolver.SolveStatusInfo">
<em class="property">class </em><code class="descname">SolveStatusInfo</code><a class="headerlink" href="#pydrake.solvers.GurobiSolver.SolveStatusInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Contains info returned to a user function that handles a Node or
Solution callback.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">MipNodeCallbackFunction</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">MipSolCallbackFunction</p>
</div>
<dl class="attribute">
<dt id="pydrake.solvers.GurobiSolver.SolveStatusInfo.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.solvers.GurobiSolver.SolveStatusInfo.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.GurobiSolver.SolveStatusInfo.best_bound">
<code class="descname">best_bound</code><a class="headerlink" href="#pydrake.solvers.GurobiSolver.SolveStatusInfo.best_bound" title="Permalink to this definition">¶</a></dt>
<dd><p>Best known objective lower bound.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.GurobiSolver.SolveStatusInfo.best_objective">
<code class="descname">best_objective</code><a class="headerlink" href="#pydrake.solvers.GurobiSolver.SolveStatusInfo.best_objective" title="Permalink to this definition">¶</a></dt>
<dd><p>Objective of best solution yet.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.GurobiSolver.SolveStatusInfo.current_objective">
<code class="descname">current_objective</code><a class="headerlink" href="#pydrake.solvers.GurobiSolver.SolveStatusInfo.current_objective" title="Permalink to this definition">¶</a></dt>
<dd><p>Objective of current solution.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.GurobiSolver.SolveStatusInfo.explored_node_count">
<code class="descname">explored_node_count</code><a class="headerlink" href="#pydrake.solvers.GurobiSolver.SolveStatusInfo.explored_node_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of nodes explored so far.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.GurobiSolver.SolveStatusInfo.feasible_solutions_count">
<code class="descname">feasible_solutions_count</code><a class="headerlink" href="#pydrake.solvers.GurobiSolver.SolveStatusInfo.feasible_solutions_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of feasible sols found so far.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.GurobiSolver.SolveStatusInfo.reported_runtime">
<code class="descname">reported_runtime</code><a class="headerlink" href="#pydrake.solvers.GurobiSolver.SolveStatusInfo.reported_runtime" title="Permalink to this definition">¶</a></dt>
<dd><p>Runtime as of this callback.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.GurobiSolverDetails">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">GurobiSolverDetails</code><a class="headerlink" href="#pydrake.solvers.GurobiSolverDetails" title="Permalink to this definition">¶</a></dt>
<dd><p>The Gurobi solver details after calling Solve() function. The user can
call MathematicalProgramResult::get_solver_details&lt;GurobiSolver&gt;() to
obtain the details.</p>
<dl class="attribute">
<dt id="pydrake.solvers.GurobiSolverDetails.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.solvers.GurobiSolverDetails.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.GurobiSolverDetails.error_code">
<code class="descname">error_code</code><a class="headerlink" href="#pydrake.solvers.GurobiSolverDetails.error_code" title="Permalink to this definition">¶</a></dt>
<dd><p>The error message returned from Gurobi call. Please refer to
<a class="reference external" href="https://www.gurobi.com/documentation/9.5/refman/error_codes.html">https://www.gurobi.com/documentation/9.5/refman/error_codes.html</a></p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.GurobiSolverDetails.objective_bound">
<code class="descname">objective_bound</code><a class="headerlink" href="#pydrake.solvers.GurobiSolverDetails.objective_bound" title="Permalink to this definition">¶</a></dt>
<dd><p>The best known bound on the optimal objective. This is used in mixed
integer optimization. Please refer to
<a class="reference external" href="https://www.gurobi.com/documentation/9.5/refman/objbound.html">https://www.gurobi.com/documentation/9.5/refman/objbound.html</a></p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.GurobiSolverDetails.optimization_status">
<code class="descname">optimization_status</code><a class="headerlink" href="#pydrake.solvers.GurobiSolverDetails.optimization_status" title="Permalink to this definition">¶</a></dt>
<dd><p>The status code when the optimize call has returned. Please refer to
<a class="reference external" href="https://www.gurobi.com/documentation/9.5/refman/optimization_status_codes.html">https://www.gurobi.com/documentation/9.5/refman/optimization_status_codes.html</a></p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.GurobiSolverDetails.optimizer_time">
<code class="descname">optimizer_time</code><a class="headerlink" href="#pydrake.solvers.GurobiSolverDetails.optimizer_time" title="Permalink to this definition">¶</a></dt>
<dd><p>The gurobi optimization time. Please refer to
<a class="reference external" href="https://www.gurobi.com/documentation/9.5/refman/runtime.html">https://www.gurobi.com/documentation/9.5/refman/runtime.html</a></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.IbexSolver">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">IbexSolver</code><a class="headerlink" href="#pydrake.solvers.IbexSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.SolverInterface" title="pydrake.solvers.SolverInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.SolverInterface</span></code></a></p>
<p>An implementation of SolverInterface for the IBEX solver
(<a class="reference external" href="http://www.ibex-lib.org">http://www.ibex-lib.org</a>).</p>
<p>This solver supports the following constraints / costs: -
ExponentialConeConstraint - GenericConstraint -
LinearComplementarityConstraint - LinearConstraint -
LinearEqualityConstraint - LorentzConeConstraint -
RotatedLorentzConeConstraint - GenericCost - LinearCost -
QuadraticCost</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Only costs and constraints that support symbolic evaluation are
compatible with this solver.</p>
</div>
<p>Currently this implementation supports the following options: -
rel_eps_f &lt;double&gt;: Relative precision (∈ ℝ⁺) on the objective. -
abs_eps_f &lt;double&gt;: Absolute precision (∈ ℝ⁺) on the objective. -
eps_h &lt;double&gt;: Equality relaxation value (∈ ℝ⁺). - rigor &lt;int&gt;:
Activate rigor mode (certify feasibility of equations). 0 –&gt; rigor
off, != 0 –&gt; rigor on. - random_seed &lt;double&gt;: Random seed (useful
for reproducibility). - eps_x &lt;double&gt;: Precision on the variable (∈
ℝ⁺). - trace &lt;int&gt;: Activate trace. Updates of loup/uplo are printed
while minimizing. 0 - nothing is printed. 1 - prints every loup/uplo
update. 2 - prints also each handled node. Note that trace = 1 if
kPrintToConsole = true. - timeout &lt;double&gt;: Timeout (time in seconds).
0.0 indicates +∞.</p>
<p>See <a class="reference external" href="http://www.ibex-lib.org/doc/optim.html#options">http://www.ibex-lib.org/doc/optim.html#options</a> for more
information.</p>
<dl class="method">
<dt id="pydrake.solvers.IbexSolver.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.IbexSolver</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.IbexSolver.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="pydrake.solvers.IbexSolver.id">
<em class="property">static </em><code class="descname">id</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.solvers.SolverId<a class="headerlink" href="#pydrake.solvers.IbexSolver.id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.IntervalBinning">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">IntervalBinning</code><a class="headerlink" href="#pydrake.solvers.IntervalBinning" title="Permalink to this definition">¶</a></dt>
<dd><p>For a continuous variable whose range is cut into small intervals, we
will use binary variables to represent which interval the continuous
variable is in. We support two representations, either using
logarithmic number of binary variables, or linear number of binary
variables. For more details,</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">AddLogarithmicSos2Constraint and AddSos2Constraint</p>
</div>
<p>Members:</p>
<blockquote>
<div><p>kLogarithmic</p>
<p>kLinear</p>
</div></blockquote>
<dl class="method">
<dt id="pydrake.solvers.IntervalBinning.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.IntervalBinning</em>, <em>value: int</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.IntervalBinning.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.IntervalBinning.kLinear">
<code class="descname">kLinear</code><em class="property"> = &lt;IntervalBinning.kLinear: 1&gt;</em><a class="headerlink" href="#pydrake.solvers.IntervalBinning.kLinear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.IntervalBinning.kLogarithmic">
<code class="descname">kLogarithmic</code><em class="property"> = &lt;IntervalBinning.kLogarithmic: 0&gt;</em><a class="headerlink" href="#pydrake.solvers.IntervalBinning.kLogarithmic" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.IntervalBinning.name">
<code class="descname">name</code><a class="headerlink" href="#pydrake.solvers.IntervalBinning.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.IntervalBinning.value">
<code class="descname">value</code><a class="headerlink" href="#pydrake.solvers.IntervalBinning.value" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.IpoptSolver">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">IpoptSolver</code><a class="headerlink" href="#pydrake.solvers.IpoptSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.SolverInterface" title="pydrake.solvers.SolverInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.SolverInterface</span></code></a></p>
<dl class="method">
<dt id="pydrake.solvers.IpoptSolver.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.IpoptSolver</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.IpoptSolver.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="pydrake.solvers.IpoptSolver.id">
<em class="property">static </em><code class="descname">id</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.solvers.SolverId<a class="headerlink" href="#pydrake.solvers.IpoptSolver.id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.IpoptSolverDetails">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">IpoptSolverDetails</code><a class="headerlink" href="#pydrake.solvers.IpoptSolverDetails" title="Permalink to this definition">¶</a></dt>
<dd><p>The Ipopt solver details after calling Solve() function. The user can
call MathematicalProgramResult::get_solver_details&lt;IpoptSolver&gt;() to
obtain the details.</p>
<dl class="attribute">
<dt id="pydrake.solvers.IpoptSolverDetails.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.solvers.IpoptSolverDetails.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.IpoptSolverDetails.ConvertStatusToString">
<code class="descname">ConvertStatusToString</code><span class="sig-paren">(</span><em>self: pydrake.solvers.IpoptSolverDetails</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.solvers.IpoptSolverDetails.ConvertStatusToString" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert status field to string. This function is useful if you want to
interpret the meaning of status.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.IpoptSolverDetails.g">
<code class="descname">g</code><a class="headerlink" href="#pydrake.solvers.IpoptSolverDetails.g" title="Permalink to this definition">¶</a></dt>
<dd><p>The final value for the constraint function.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.IpoptSolverDetails.lambda_val">
<code class="descname">lambda_val</code><a class="headerlink" href="#pydrake.solvers.IpoptSolverDetails.lambda_val" title="Permalink to this definition">¶</a></dt>
<dd><p>The final value for the constraint multiplier.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.IpoptSolverDetails.status">
<code class="descname">status</code><a class="headerlink" href="#pydrake.solvers.IpoptSolverDetails.status" title="Permalink to this definition">¶</a></dt>
<dd><p>The final status of the solver. Please refer to section 6 in
Introduction to Ipopt: A tutorial for downloading, installing, and
using Ipopt. You could also find the meaning of the status as
Ipopt::SolverReturn defined in IpAlgTypes.hpp</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.IpoptSolverDetails.z_L">
<code class="descname">z_L</code><a class="headerlink" href="#pydrake.solvers.IpoptSolverDetails.z_L" title="Permalink to this definition">¶</a></dt>
<dd><p>The final value for the lower bound multiplier.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.IpoptSolverDetails.z_U">
<code class="descname">z_U</code><a class="headerlink" href="#pydrake.solvers.IpoptSolverDetails.z_U" title="Permalink to this definition">¶</a></dt>
<dd><p>The final value for the upper bound multiplier.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.L1NormCost">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">L1NormCost</code><a class="headerlink" href="#pydrake.solvers.L1NormCost" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.Cost" title="pydrake.solvers.Cost"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Cost</span></code></a></p>
<p>Implements a cost of the form ‖Ax + b‖₁. Note that this cost is
non-differentiable when any element of Ax + b equals zero.</p>
<dl class="method">
<dt id="pydrake.solvers.L1NormCost.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.L1NormCost, A: numpy.ndarray[numpy.float64[m, n]], b: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.L1NormCost.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a cost of the form ‖Ax + b‖₁.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">A</span></code>:</dt>
<dd>Linear term.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>:</dt>
<dd>Constant term.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.L1NormCost.A">
<code class="descname">A</code><span class="sig-paren">(</span><em>self: pydrake.solvers.L1NormCost</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, n]]<a class="headerlink" href="#pydrake.solvers.L1NormCost.A" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.L1NormCost.b">
<code class="descname">b</code><span class="sig-paren">(</span><em>self: pydrake.solvers.L1NormCost</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.solvers.L1NormCost.b" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.L1NormCost.UpdateCoefficients">
<code class="descname">UpdateCoefficients</code><span class="sig-paren">(</span><em>self: pydrake.solvers.L1NormCost, new_A: numpy.ndarray[numpy.float64[m, n]], new_b: numpy.ndarray[numpy.float64[m, 1]] = 0</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.L1NormCost.UpdateCoefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the coefficients of the cost. Note that the number of
variables (columns of A) cannot change.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_A</span></code>:</dt>
<dd>New linear term.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_b</span></code>:</dt>
<dd>New constant term.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.L2NormCost">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">L2NormCost</code><a class="headerlink" href="#pydrake.solvers.L2NormCost" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.Cost" title="pydrake.solvers.Cost"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Cost</span></code></a></p>
<p>Implements a cost of the form ‖Ax + b‖₂.</p>
<dl class="method">
<dt id="pydrake.solvers.L2NormCost.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.L2NormCost, A: numpy.ndarray[numpy.float64[m, n]], b: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.L2NormCost.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a cost of the form ‖Ax + b‖₂.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">A</span></code>:</dt>
<dd>Linear term.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>:</dt>
<dd>Constant term.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.L2NormCost.A">
<code class="descname">A</code><span class="sig-paren">(</span><em>self: pydrake.solvers.L2NormCost</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, n]]<a class="headerlink" href="#pydrake.solvers.L2NormCost.A" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.L2NormCost.b">
<code class="descname">b</code><span class="sig-paren">(</span><em>self: pydrake.solvers.L2NormCost</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.solvers.L2NormCost.b" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.L2NormCost.UpdateCoefficients">
<code class="descname">UpdateCoefficients</code><span class="sig-paren">(</span><em>self: pydrake.solvers.L2NormCost, new_A: numpy.ndarray[numpy.float64[m, n]], new_b: numpy.ndarray[numpy.float64[m, 1]] = 0</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.L2NormCost.UpdateCoefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the coefficients of the cost. Note that the number of
variables (columns of A) cannot change.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_A</span></code>:</dt>
<dd>New linear term.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_b</span></code>:</dt>
<dd>New constant term.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.LinearComplementarityConstraint">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">LinearComplementarityConstraint</code><a class="headerlink" href="#pydrake.solvers.LinearComplementarityConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.Constraint" title="pydrake.solvers.Constraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Constraint</span></code></a></p>
<p>Implements a constraint of the form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Mx</span> <span class="o">+</span> <span class="n">q</span> <span class="o">&gt;=</span> <span class="mi">0</span>
  <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span>
  <span class="n">x</span><span class="s1">&#39;(Mx + q) == 0</span>
</pre></div>
</div>
<p>An implied slack variable complements any 0 component of x. To get the
slack values at a given solution x, use Eval(x).</p>
<dl class="attribute">
<dt id="pydrake.solvers.LinearComplementarityConstraint.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.solvers.LinearComplementarityConstraint.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.LinearConstraint">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">LinearConstraint</code><a class="headerlink" href="#pydrake.solvers.LinearConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.Constraint" title="pydrake.solvers.Constraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Constraint</span></code></a></p>
<p>Implements a constraint of the form <span class="math notranslate nohighlight">\(lb &lt;= Ax &lt;= ub\)</span></p>
<dl class="method">
<dt id="pydrake.solvers.LinearConstraint.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.LinearConstraint.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.solvers.LinearConstraint, A: numpy.ndarray[numpy.float64[m, n]], lb: numpy.ndarray[numpy.float64[m, 1]], ub: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</li>
</ol>
<p>Construct the linear constraint lb &lt;= A*x &lt;= ub</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.solvers.LinearConstraint, A: scipy.sparse.csc_matrix[numpy.float64], lb: numpy.ndarray[numpy.float64[m, 1]], ub: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</li>
</ol>
<p>Overloads constructor with a sparse A matrix.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.LinearConstraint.get_sparse_A">
<code class="descname">get_sparse_A</code><span class="sig-paren">(</span><em>self: pydrake.solvers.LinearConstraint</em><span class="sig-paren">)</span> &#x2192; scipy.sparse.csc_matrix[numpy.float64]<a class="headerlink" href="#pydrake.solvers.LinearConstraint.get_sparse_A" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.LinearConstraint.GetDenseA">
<code class="descname">GetDenseA</code><span class="sig-paren">(</span><em>self: pydrake.solvers.LinearConstraint</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, n]]<a class="headerlink" href="#pydrake.solvers.LinearConstraint.GetDenseA" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the matrix A as a dense matrix.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">this might involve memory allocation to convert a sparse matrix to
a dense one, for better performance you should call get_sparse_A()
which returns a sparse matrix.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.LinearConstraint.RemoveTinyCoefficient">
<code class="descname">RemoveTinyCoefficient</code><span class="sig-paren">(</span><em>self: pydrake.solvers.LinearConstraint</em>, <em>tol: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.LinearConstraint.RemoveTinyCoefficient" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets A(i, j) to zero if abs(A(i, j)) &lt;= tol. Oftentimes the
coefficient A is computed numerically with round-off errors. Such
small round-off errors can cause numerical issues for certain
optimization solvers. Hence it is recommended to remove the tiny
coefficients to achieve numerical robustness.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">tol</span></code>:</dt>
<dd>The entries in A with absolute value &lt;= tol will be set to 0.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">tol&gt;= 0.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.LinearConstraint.set_bounds">
<code class="descname">set_bounds</code><span class="sig-paren">(</span><em>self: pydrake.solvers.LinearConstraint, new_lb: numpy.ndarray[numpy.float64[m, 1]], new_ub: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.LinearConstraint.set_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the upper and lower bounds of the constraint.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_lb</span></code>:</dt>
<dd>. A <code class="docutils literal notranslate"><span class="pre">num_constraints</span></code> x 1 vector.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_ub</span></code>:</dt>
<dd>. A <code class="docutils literal notranslate"><span class="pre">num_constraints</span></code> x 1 vector.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If the users want to expose this method in a sub-class, do using
Constraint::set_bounds, as in LinearConstraint.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.LinearConstraint.UpdateCoefficients">
<code class="descname">UpdateCoefficients</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.LinearConstraint.UpdateCoefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>UpdateCoefficients(self: pydrake.solvers.LinearConstraint, new_A: numpy.ndarray[numpy.float64[m, n]], new_lb: numpy.ndarray[numpy.float64[m, 1]], new_ub: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</li>
</ol>
<p>Updates the linear term, upper and lower bounds in the linear
constraint. The updated constraint is: new_lb &lt;= new_A * x &lt;= new_ub
Note that the size of constraints (number of rows) can change, but the
number of variables (number of cols) cannot.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_A</span></code>:</dt>
<dd>new linear term</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_lb</span></code>:</dt>
<dd>new lower bound</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_up</span></code>:</dt>
<dd>new upper bound</dd>
</dl>
<ol class="arabic simple" start="2">
<li>UpdateCoefficients(self: pydrake.solvers.LinearConstraint, new_A: scipy.sparse.csc_matrix[numpy.float64], new_lb: numpy.ndarray[numpy.float64[m, 1]], new_ub: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</li>
</ol>
<p>Overloads UpdateCoefficients but with a sparse A matrix.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.LinearConstraint.UpdateLowerBound">
<code class="descname">UpdateLowerBound</code><span class="sig-paren">(</span><em>self: pydrake.solvers.LinearConstraint, new_lb: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.LinearConstraint.UpdateLowerBound" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the lower bound.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">if the users want to expose this method in a sub-class, do using
Constraint::UpdateLowerBound, as in LinearConstraint.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.LinearConstraint.UpdateUpperBound">
<code class="descname">UpdateUpperBound</code><span class="sig-paren">(</span><em>self: pydrake.solvers.LinearConstraint, new_ub: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.LinearConstraint.UpdateUpperBound" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the upper bound.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">if the users want to expose this method in a sub-class, do using
Constraint::UpdateUpperBound, as in LinearConstraint.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.LinearCost">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">LinearCost</code><a class="headerlink" href="#pydrake.solvers.LinearCost" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.Cost" title="pydrake.solvers.Cost"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Cost</span></code></a></p>
<p>Implements a cost of the form</p>
<div class="math notranslate nohighlight">
\[a'x + b\]</div>
<p>.</p>
<dl class="method">
<dt id="pydrake.solvers.LinearCost.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.LinearCost, a: numpy.ndarray[numpy.float64[m, 1]], b: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.LinearCost.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a linear cost of the form</p>
<div class="math notranslate nohighlight">
\[a'x + b\]</div>
<p>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">a</span></code>:</dt>
<dd>Linear term.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>:</dt>
<dd>(optional) Constant term.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.LinearCost.a">
<code class="descname">a</code><span class="sig-paren">(</span><em>self: pydrake.solvers.LinearCost</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.solvers.LinearCost.a" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.LinearCost.b">
<code class="descname">b</code><span class="sig-paren">(</span><em>self: pydrake.solvers.LinearCost</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.solvers.LinearCost.b" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.LinearCost.UpdateCoefficients">
<code class="descname">UpdateCoefficients</code><span class="sig-paren">(</span><em>self: pydrake.solvers.LinearCost, new_a: numpy.ndarray[numpy.float64[m, 1]], new_b: float = 0</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.LinearCost.UpdateCoefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the coefficients of the cost. Note that the number of
variables (size of a) cannot change.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_a</span></code>:</dt>
<dd>New linear term.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_b</span></code>:</dt>
<dd>(optional) New constant term.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.LinearEqualityConstraint">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">LinearEqualityConstraint</code><a class="headerlink" href="#pydrake.solvers.LinearEqualityConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.LinearConstraint" title="pydrake.solvers.LinearConstraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.LinearConstraint</span></code></a></p>
<p>Implements a constraint of the form <span class="math notranslate nohighlight">\(Ax = b\)</span></p>
<dl class="method">
<dt id="pydrake.solvers.LinearEqualityConstraint.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.LinearEqualityConstraint.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.solvers.LinearEqualityConstraint, Aeq: numpy.ndarray[numpy.float64[m, n]], beq: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</li>
</ol>
<p>Constructs the linear equality constraint Aeq * x = beq</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.solvers.LinearEqualityConstraint, Aeq: scipy.sparse.csc_matrix[numpy.float64], beq: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</li>
</ol>
<p>Overloads the constructor with a sparse matrix Aeq.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.solvers.LinearEqualityConstraint, a: numpy.ndarray[numpy.float64[1, n]], beq: float) -&gt; None</li>
</ol>
<p>Constructs the linear equality constraint a.dot(x) = beq</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.LinearEqualityConstraint.UpdateCoefficients">
<code class="descname">UpdateCoefficients</code><span class="sig-paren">(</span><em>self: pydrake.solvers.LinearEqualityConstraint, Aeq: numpy.ndarray[numpy.float64[m, n]], beq: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.LinearEqualityConstraint.UpdateCoefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloads UpdateCoefficients but with a sparse A matrix.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.LinearMatrixInequalityConstraint">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">LinearMatrixInequalityConstraint</code><a class="headerlink" href="#pydrake.solvers.LinearMatrixInequalityConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.Constraint" title="pydrake.solvers.Constraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Constraint</span></code></a></p>
<p>Impose the matrix inequality constraint on variable x</p>
<div class="math notranslate nohighlight">
\[F_0 + x_1  F_1 + ... + x_n  F_n \text{ is p.s.d}\]</div>
<p>where p.s.d stands for positive semidefinite. <span class="math notranslate nohighlight">\(F_0, F_1, ...,
F_n\)</span> are all given symmetric matrices of the same size.</p>
<dl class="method">
<dt id="pydrake.solvers.LinearMatrixInequalityConstraint.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.LinearMatrixInequalityConstraint, F: List[numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]], symmetry_tolerance: float = 1e-10</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.LinearMatrixInequalityConstraint.__init__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">F</span></code>:</dt>
<dd>Each symmetric matrix F[i] should be of the same size.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">symmetry_tolerance</span></code>:</dt>
<dd>The precision to determine if the input matrices Fi are all
symmetric.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">math::IsSymmetric().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.LinearMatrixInequalityConstraint.F">
<code class="descname">F</code><span class="sig-paren">(</span><em>self: pydrake.solvers.LinearMatrixInequalityConstraint</em><span class="sig-paren">)</span> &#x2192; List[numpy.ndarray[numpy.float64[m, n]]]<a class="headerlink" href="#pydrake.solvers.LinearMatrixInequalityConstraint.F" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.LinearMatrixInequalityConstraint.matrix_rows">
<code class="descname">matrix_rows</code><span class="sig-paren">(</span><em>self: pydrake.solvers.LinearMatrixInequalityConstraint</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.solvers.LinearMatrixInequalityConstraint.matrix_rows" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the number of rows in the matrix inequality constraint. Namely Fi
are all matrix_rows() x matrix_rows() matrices.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.LInfNormCost">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">LInfNormCost</code><a class="headerlink" href="#pydrake.solvers.LInfNormCost" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.Cost" title="pydrake.solvers.Cost"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Cost</span></code></a></p>
<p>Implements a cost of the form ‖Ax + b‖∞. Note that this cost is
non-differentiable when any two or more elements of Ax + b are equal.</p>
<dl class="method">
<dt id="pydrake.solvers.LInfNormCost.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.LInfNormCost, A: numpy.ndarray[numpy.float64[m, n]], b: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.LInfNormCost.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a cost of the form ‖Ax + b‖∞.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">A</span></code>:</dt>
<dd>Linear term.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>:</dt>
<dd>Constant term.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.LInfNormCost.A">
<code class="descname">A</code><span class="sig-paren">(</span><em>self: pydrake.solvers.LInfNormCost</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, n]]<a class="headerlink" href="#pydrake.solvers.LInfNormCost.A" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.LInfNormCost.b">
<code class="descname">b</code><span class="sig-paren">(</span><em>self: pydrake.solvers.LInfNormCost</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.solvers.LInfNormCost.b" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.LInfNormCost.UpdateCoefficients">
<code class="descname">UpdateCoefficients</code><span class="sig-paren">(</span><em>self: pydrake.solvers.LInfNormCost, new_A: numpy.ndarray[numpy.float64[m, n]], new_b: numpy.ndarray[numpy.float64[m, 1]] = 0</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.LInfNormCost.UpdateCoefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the coefficients of the cost. Note that the number of
variables (columns of A) cannot change.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_A</span></code>:</dt>
<dd>New linear term.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_b</span></code>:</dt>
<dd>New constant term.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.LorentzConeConstraint">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">LorentzConeConstraint</code><a class="headerlink" href="#pydrake.solvers.LorentzConeConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.Constraint" title="pydrake.solvers.Constraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Constraint</span></code></a></p>
<p>Constraining the linear expression <span class="math notranslate nohighlight">\(z=Ax+b\)</span> lies within the
Lorentz cone. A vector z ∈ ℝ ⁿ lies within Lorentz cone if</p>
<div class="math notranslate nohighlight">
\[z_0 \ge \sqrt{z_1^2+...+z_{n-1}^2}\]</div>
<p>where A ∈ ℝ ⁿˣᵐ, b ∈ ℝ ⁿ are given matrices. Ideally this constraint
should be handled by a second-order cone solver. In case the user
wants to enforce this constraint through general nonlinear
optimization, we provide three different formulations on the Lorentz
cone constraint 1. [kConvex] g(z) = z₀ - sqrt(z₁² + … + zₙ₋₁²) ≥ 0
This formulation is not differentiable at z₁=…=zₙ₋₁=0 2.
[kConvexSmooth] g(z) = z₀ - sqrt(z₁² + … + zₙ₋₁²) ≥ 0 but the
gradient of g(z) is approximated as ∂g(z)/∂z = [1, -z₁/sqrt(z₁² + …
zₙ₋₁² + ε), …, -zₙ₋₁/sqrt(z₁²+…+zₙ₋₁²+ε)] where ε is a small
positive number. 3. [kNonconvex] z₀²-(z₁²+…+zₙ₋₁²) ≥ 0 z₀ ≥ 0 This
constraint is differentiable everywhere, but z₀²-(z₁²+…+zₙ₋₁²) ≥ 0
is non-convex. For more information and visualization, please refer to
<a class="reference external" href="https://www.epfl.ch/labs/disopt/wp-content/uploads/2018/09/7.pdf">https://www.epfl.ch/labs/disopt/wp-content/uploads/2018/09/7.pdf</a> and
<a class="reference external" href="https://docs.mosek.com/modeling-cookbook/cqo.html">https://docs.mosek.com/modeling-cookbook/cqo.html</a> (Fig 3.1)</p>
<dl class="method">
<dt id="pydrake.solvers.LorentzConeConstraint.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.LorentzConeConstraint, A: numpy.ndarray[numpy.float64[m, n]], b: numpy.ndarray[numpy.float64[m, 1]], eval_type: pydrake.solvers.LorentzConeConstraint.EvalType = &lt;EvalType.kConvexSmooth: 1&gt;</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.LorentzConeConstraint.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.LorentzConeConstraint.A">
<code class="descname">A</code><span class="sig-paren">(</span><em>self: pydrake.solvers.LorentzConeConstraint</em><span class="sig-paren">)</span> &#x2192; scipy.sparse.csc_matrix[numpy.float64]<a class="headerlink" href="#pydrake.solvers.LorentzConeConstraint.A" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for A.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.LorentzConeConstraint.b">
<code class="descname">b</code><span class="sig-paren">(</span><em>self: pydrake.solvers.LorentzConeConstraint</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.solvers.LorentzConeConstraint.b" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for b.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.LorentzConeConstraint.eval_type">
<code class="descname">eval_type</code><span class="sig-paren">(</span><em>self: pydrake.solvers.LorentzConeConstraint</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.LorentzConeConstraint.EvalType<a class="headerlink" href="#pydrake.solvers.LorentzConeConstraint.eval_type" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for eval type.</p>
</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.LorentzConeConstraint.EvalType">
<em class="property">class </em><code class="descname">EvalType</code><a class="headerlink" href="#pydrake.solvers.LorentzConeConstraint.EvalType" title="Permalink to this definition">¶</a></dt>
<dd><p>We provide three possible Eval functions to represent the Lorentz cone
constraint z₀ ≥ sqrt(z₁² + … + zₙ₋₁²). For more explanation on the
three formulations, refer to LorentzConeConstraint documentation.</p>
<p>Members:</p>
<blockquote>
<div>kConvex : The constraint is g(z) = z₀ - sqrt(z₁² + … + zₙ₋₁²) ≥ 0. Note this</div></blockquote>
<p>formulation is non-differentiable at z₁= …= zₙ₋₁=0</p>
<blockquote>
<div>kConvexSmooth : Same as kConvex, but with approximated gradient that exists</div></blockquote>
<p>everywhere..</p>
<blockquote>
<div>kNonconvex : Nonconvex constraint z₀²-(z₁²+…+zₙ₋₁²) ≥ 0 and z₀ ≥ 0. Note this</div></blockquote>
<p>formulation is differentiable, but at z₁= …= zₙ₋₁=0 the gradient is
also 0, so a gradient-based nonlinear solver can get stuck.</p>
<dl class="method">
<dt id="pydrake.solvers.LorentzConeConstraint.EvalType.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.LorentzConeConstraint.EvalType</em>, <em>value: int</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.LorentzConeConstraint.EvalType.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.LorentzConeConstraint.EvalType.kConvex">
<code class="descname">kConvex</code><em class="property"> = &lt;EvalType.kConvex: 0&gt;</em><a class="headerlink" href="#pydrake.solvers.LorentzConeConstraint.EvalType.kConvex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.LorentzConeConstraint.EvalType.kConvexSmooth">
<code class="descname">kConvexSmooth</code><em class="property"> = &lt;EvalType.kConvexSmooth: 1&gt;</em><a class="headerlink" href="#pydrake.solvers.LorentzConeConstraint.EvalType.kConvexSmooth" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.LorentzConeConstraint.EvalType.kNonconvex">
<code class="descname">kNonconvex</code><em class="property"> = &lt;EvalType.kNonconvex: 2&gt;</em><a class="headerlink" href="#pydrake.solvers.LorentzConeConstraint.EvalType.kNonconvex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.LorentzConeConstraint.EvalType.name">
<code class="descname">name</code><a class="headerlink" href="#pydrake.solvers.LorentzConeConstraint.EvalType.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.LorentzConeConstraint.EvalType.value">
<code class="descname">value</code><a class="headerlink" href="#pydrake.solvers.LorentzConeConstraint.EvalType.value" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.LorentzConeConstraint.UpdateCoefficients">
<code class="descname">UpdateCoefficients</code><span class="sig-paren">(</span><em>self: pydrake.solvers.LorentzConeConstraint, new_A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], new_b: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.LorentzConeConstraint.UpdateCoefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the coefficients, the updated constraint is z=new_A * x +
new_b in the Lorentz cone.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the new_A.cols() != A.cols(), namely the variable</li>
<li>size should not change.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Precondition:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">new_A</span></code> has to have at least 2 rows and new_A.rows() ==
new_b.rows().</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pydrake.solvers.MakeFirstAvailableSolver">
<code class="descclassname">pydrake.solvers.</code><code class="descname">MakeFirstAvailableSolver</code><span class="sig-paren">(</span><em>solver_ids: List[pydrake.solvers.SolverId]</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.SolverInterface<a class="headerlink" href="#pydrake.solvers.MakeFirstAvailableSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes the first available and enabled solver. If no solvers are
available, throws a RuntimeError.</p>
</dd></dl>

<dl class="function">
<dt id="pydrake.solvers.MakeSolver">
<code class="descclassname">pydrake.solvers.</code><code class="descname">MakeSolver</code><span class="sig-paren">(</span><em>id: pydrake.solvers.SolverId</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.SolverInterface<a class="headerlink" href="#pydrake.solvers.MakeSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the solver ID, create the solver with the matching ID.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if there is no matching solver.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.MathematicalProgram">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">MathematicalProgram</code><a class="headerlink" href="#pydrake.solvers.MathematicalProgram" title="Permalink to this definition">¶</a></dt>
<dd><p>MathematicalProgram stores the decision variables, the constraints and
costs of an optimization problem. The user can solve the problem by
calling solvers::Solve() function, and obtain the results of the
optimization.</p>
<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.Add2NormSquaredCost">
<code class="descname">Add2NormSquaredCost</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram, A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[m, 1]], vars: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.Binding[QuadraticCost]<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.Add2NormSquaredCost" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a quadratic cost of the form <a href="#id1"><span class="problematic" id="id2">|</span></a>Ax-b|²=(Ax-b)ᵀ(Ax-b)</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.AddBoundingBoxConstraint">
<code class="descname">AddBoundingBoxConstraint</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.MathematicalProgram.AddBoundingBoxConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>AddBoundingBoxConstraint(self: pydrake.solvers.MathematicalProgram, arg0: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], arg1: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], arg2: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; pydrake.solvers.Binding[BoundingBoxConstraint]</li>
</ol>
<p>Adds bounding box constraints referencing potentially a subset of the
decision variables.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lb</span></code>:</dt>
<dd>The lower bound.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">ub</span></code>:</dt>
<dd>The upper bound.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">vars</span></code>:</dt>
<dd>Will imposes constraint lb(i, j) &lt;= vars(i, j) &lt;= ub(i, j).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The newly constructed BoundingBoxConstraint.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>AddBoundingBoxConstraint(self: pydrake.solvers.MathematicalProgram, arg0: float, arg1: float, arg2: pydrake.symbolic.Variable) -&gt; pydrake.solvers.Binding[BoundingBoxConstraint]</li>
</ol>
<p>Adds bounds for a single variable.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lb</span></code>:</dt>
<dd>Lower bound.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">ub</span></code>:</dt>
<dd>Upper bound.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">var</span></code>:</dt>
<dd>The decision variable.</dd>
</dl>
<ol class="arabic simple" start="3">
<li>AddBoundingBoxConstraint(self: pydrake.solvers.MathematicalProgram, arg0: float, arg1: float, arg2: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; pydrake.solvers.Binding[BoundingBoxConstraint]</li>
</ol>
<p>Adds the same scalar lower and upper bound to every variable in
<code class="docutils literal notranslate"><span class="pre">vars</span></code>.</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">Derived</span></code>:</dt>
<dd>An Eigen::Matrix with Variable as the scalar type. The matrix has
unknown number of columns at compile time, or has more than one
column.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lb</span></code>:</dt>
<dd>Lower bound.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">ub</span></code>:</dt>
<dd>Upper bound.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">vars</span></code>:</dt>
<dd>The decision variables.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.AddConstraint">
<code class="descname">AddConstraint</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.MathematicalProgram.AddConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>AddConstraint(self: pydrake.solvers.MathematicalProgram, func: function, lb: numpy.ndarray[numpy.float64[m, 1]], ub: numpy.ndarray[numpy.float64[m, 1]], vars: numpy.ndarray[object[m, 1]], description: str = ‘’) -&gt; pydrake.solvers.Binding[Constraint]</li>
</ol>
<p>Adds a constraint using a Python function.</p>
<ol class="arabic simple" start="2">
<li>AddConstraint(self: pydrake.solvers.MathematicalProgram, arg0: pydrake.symbolic.Expression, arg1: float, arg2: float) -&gt; pydrake.solvers.Binding[Constraint]</li>
</ol>
<p>Adds one row of constraint lb &lt;= e &lt;= ub where <code class="docutils literal notranslate"><span class="pre">e</span></code> is a symbolic
expression.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if 1. <code class="docutils literal notranslate"><span class="pre">lb</span> <span class="pre">&lt;=</span> <span class="pre">e</span> <span class="pre">&lt;=</span> <span class="pre">ub</span></code> is a trivial constraint such</li>
<li>as 1 &lt;= 2 &lt;= 3. 2. <code class="docutils literal notranslate"><span class="pre">lb</span> <span class="pre">&lt;=</span> <span class="pre">e</span> <span class="pre">&lt;=</span> <span class="pre">ub</span></code> is unsatisfiable such as 1 &lt;=</li>
<li>-5 &lt;= 3</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">e</span></code>:</dt>
<dd>A symbolic expression of the decision variables.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lb</span></code>:</dt>
<dd>A scalar, the lower bound.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">ub</span></code>:</dt>
<dd>A scalar, the upper bound.</dd>
</dl>
<p>The resulting constraint may be a BoundingBoxConstraint,
LinearConstraint, LinearEqualityConstraint, or ExpressionConstraint,
depending on the arguments. Constraints of the form x == 1 (which
could be created as a BoundingBoxConstraint or
LinearEqualityConstraint) will be constructed as a
LinearEqualityConstraint.</p>
<ol class="arabic simple" start="3">
<li>AddConstraint(self: pydrake.solvers.MathematicalProgram, arg0: pydrake.symbolic.Formula) -&gt; pydrake.solvers.Binding[Constraint]</li>
</ol>
<p>Add a constraint represented by a symbolic formula to the program. The
input formula <code class="docutils literal notranslate"><span class="pre">f</span></code> can be of the following forms:</p>
<ol class="arabic simple">
<li>e1 &lt;= e2</li>
<li>e1 &gt;= e2</li>
<li>e1 == e2</li>
<li>A conjunction of relational formulas where each conjunct is
a relational formula matched by 1, 2, or 3.</li>
</ol>
<p>Note that first two cases might return an object of
Binding&lt;BoundingBoxConstraint&gt;, Binding&lt;LinearConstraint&gt;, or
Binding&lt;ExpressionConstraint&gt;, depending on <code class="docutils literal notranslate"><span class="pre">f</span></code>. Also the third case
might return an object of Binding&lt;LinearEqualityConstraint&gt; or
Binding&lt;ExpressionConstraint&gt;.</p>
<p>It throws an exception if 1. <code class="docutils literal notranslate"><span class="pre">f</span></code> is not matched with one of the
above patterns. Especially, strict inequalities (&lt;, &gt;) are not
allowed. 2. <code class="docutils literal notranslate"><span class="pre">f</span></code> is either a trivial constraint such as “1 &lt;= 2” or
an unsatisfiable constraint such as “2 &lt;= 1”. 3. It is not possible to
find numerical bounds of <code class="docutils literal notranslate"><span class="pre">e1</span></code> and <code class="docutils literal notranslate"><span class="pre">e2</span></code> where <code class="docutils literal notranslate"><span class="pre">f</span></code> = e1 ≃ e2. We
allow <code class="docutils literal notranslate"><span class="pre">e1</span></code> and <code class="docutils literal notranslate"><span class="pre">e2</span></code> to be infinite but only if there are no other
terms. For example, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">∞</span></code> is allowed. However, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">∞</span> <span class="pre">&lt;=</span> <span class="pre">0</span></code> is
not allowed because <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">↦</span> <span class="pre">∞</span></code> introduces <code class="docutils literal notranslate"><span class="pre">nan</span></code> in the evaluation.</p>
<ol class="arabic simple" start="4">
<li>AddConstraint(self: pydrake.solvers.MathematicalProgram, constraint: pydrake.solvers.Constraint, vars: numpy.ndarray[object[m, 1]]) -&gt; pydrake.solvers.Binding[Constraint]</li>
</ol>
<p>Adds a generic constraint to the program. This should only be used if
a more specific type of constraint is not available, as it may require
the use of a significantly more expensive solver.</p>
<ol class="arabic simple" start="5">
<li>AddConstraint(self: pydrake.solvers.MathematicalProgram, formulas: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; pydrake.solvers.Binding[Constraint]</li>
</ol>
<p>Adds a constraint represented by an Eigen::Matrix&lt;symbolic::Formula&gt;
or Eigen::Array&lt;symbolic::Formula&gt; to the program. A common use-case
of this function is to add a constraint with the element-wise
comparison between two Eigen matrices, using <code class="docutils literal notranslate"><span class="pre">A.array()</span> <span class="pre">&lt;=</span>
<span class="pre">B.array()</span></code>. See the following example.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MathematicalProgram</span> <span class="n">prog</span><span class="p">;</span>
  <span class="n">Eigen</span><span class="p">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">double</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>
  <span class="n">Eigen</span><span class="p">::</span><span class="n">Vector2d</span> <span class="n">b</span> <span class="o">=</span> <span class="o">...</span><span class="p">;</span>
  <span class="n">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">NewContinuousVariables</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">);</span>
  <span class="n">prog</span><span class="o">.</span><span class="n">AddConstraint</span><span class="p">((</span><span class="n">A</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">array</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="o">.</span><span class="n">array</span><span class="p">());</span>
</pre></div>
</div>
<p>A formula in <code class="docutils literal notranslate"><span class="pre">formulas</span></code> can be of the following forms:</p>
<ol class="arabic simple">
<li>e1 &lt;= e2</li>
<li>e1 &gt;= e2</li>
<li>e1 == e2</li>
</ol>
<p>It throws an exception if AddConstraint(const symbolic::Formula&amp; f)
throws an exception for f ∈ <code class="docutils literal notranslate"><span class="pre">formulas</span></code>.</p>
<p>&#64;overload Binding&lt;Constraint&gt; AddConstraint(const symbolic::Formula&amp;
f)</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">Derived</span></code>:</dt>
<dd>Eigen::Matrix or Eigen::Array with Formula as the Scalar.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.AddCost">
<code class="descname">AddCost</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.MathematicalProgram.AddCost" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>AddCost(self: pydrake.solvers.MathematicalProgram, func: function, vars: numpy.ndarray[object[m, 1]], description: str = ‘’) -&gt; pydrake.solvers.Binding[Cost]</li>
</ol>
<p>Adds a cost function.</p>
<ol class="arabic simple" start="2">
<li>AddCost(self: pydrake.solvers.MathematicalProgram, arg0: pydrake.symbolic.Expression) -&gt; pydrake.solvers.Binding[Cost]</li>
</ol>
<p>Adds a cost expression.</p>
<ol class="arabic simple" start="3">
<li>AddCost(self: pydrake.solvers.MathematicalProgram, obj: pydrake.solvers.Cost, vars: numpy.ndarray[object[m, 1]]) -&gt; pydrake.solvers.Binding[Cost]</li>
</ol>
<p>Adds a cost type to the optimization program.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">obj</span></code>:</dt>
<dd>The added objective.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">vars</span></code>:</dt>
<dd>The decision variables on which the cost depend.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.AddDecisionVariables">
<code class="descname">AddDecisionVariables</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram, decision_variables: numpy.ndarray[object[m, n], flags.f_contiguous]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.AddDecisionVariables" title="Permalink to this definition">¶</a></dt>
<dd><p>Appends new variables to the end of the existing variables.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">decision_variables</span></code>:</dt>
<dd>The newly added decision_variables.</dd>
<dt>Precondition:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">decision_variables</span></code> should not intersect with the existing
variables or indeterminates in the optimization program.</dd>
<dt>Precondition:</dt>
<dd>Each entry in <code class="docutils literal notranslate"><span class="pre">decision_variables</span></code> should not be a dummy
variable.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the preconditions are not satisfied.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.AddEqualityConstraintBetweenPolynomials">
<code class="descname">AddEqualityConstraintBetweenPolynomials</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em>, <em>p1: pydrake.symbolic.Polynomial</em>, <em>p2: pydrake.symbolic.Polynomial</em><span class="sig-paren">)</span> &#x2192; List[pydrake.solvers.Binding[LinearEqualityConstraint]]<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.AddEqualityConstraintBetweenPolynomials" title="Permalink to this definition">¶</a></dt>
<dd><p>Constraining that two polynomials are the same (i.e., they have the
same coefficients for each monomial). This function is often used in
sum-of-squares optimization. We will impose the linear equality
constraint that the coefficient of a monomial in <code class="docutils literal notranslate"><span class="pre">p1</span></code> is the same as
the coefficient of the same monomial in <code class="docutils literal notranslate"><span class="pre">p2</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p1</span></code>:</dt>
<dd>Note that p1’s indeterminates should have been registered as
indeterminates in this MathematicalProgram object, and p1’s
coefficients are affine functions of decision variables in this
MathematicalProgram object.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p2</span></code>:</dt>
<dd>Note that p2’s indeterminates should have been registered as
indeterminates in this MathematicalProgram object, and p2’s
coefficients are affine functions of decision variables in this
MathematicalProgram object.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It calls <code class="docutils literal notranslate"><span class="pre">Reparse</span></code> to enforce <code class="docutils literal notranslate"><span class="pre">p1</span></code> and <code class="docutils literal notranslate"><span class="pre">p2</span></code> to have this
MathematicalProgram’s indeterminates.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.AddExponentialConeConstraint">
<code class="descname">AddExponentialConeConstraint</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.MathematicalProgram.AddExponentialConeConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>AddExponentialConeConstraint(self: pydrake.solvers.MathematicalProgram, A: numpy.ndarray[numpy.float64[3, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[3, 1]], vars: numpy.ndarray[object[m, 1]]) -&gt; pydrake.solvers.Binding[ExponentialConeConstraint]</li>
</ol>
<p>Adds an exponential cone constraint, that z = A * vars + b should be
in the exponential cone. Namely {z₀, z₁, z₂ | z₀ ≥ z₁ * exp(z₂ / z₁),
z₁ &gt; 0}.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">A</span></code>:</dt>
<dd>The A matrix in the documentation above. A must have 3 rows.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>:</dt>
<dd>The b vector in the documentation above.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">vars</span></code>:</dt>
<dd>The variables bound with this constraint.</dd>
</dl>
<ol class="arabic simple" start="2">
<li>AddExponentialConeConstraint(self: pydrake.solvers.MathematicalProgram, z: numpy.ndarray[object[3, 1]]) -&gt; pydrake.solvers.Binding[ExponentialConeConstraint]</li>
</ol>
<p>Add the constraint that z is in the exponential cone.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">z</span></code>:</dt>
<dd>The expression in the exponential cone.</dd>
<dt>Precondition:</dt>
<dd>each entry in <code class="docutils literal notranslate"><span class="pre">z</span></code> is a linear expression of the decision
variables.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.AddIndeterminates">
<code class="descname">AddIndeterminates</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram, new_indeterminates: numpy.ndarray[object[m, n], flags.f_contiguous]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.AddIndeterminates" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds indeterminates. This method appends some indeterminates to the
end of the program’s old indeterminates.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_indeterminates</span></code>:</dt>
<dd>The indeterminates to be appended to the program’s old
indeterminates.</dd>
<dt>Precondition:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">new_indeterminates</span></code> should not intersect with the program’s old
indeterminates or decision variables.</dd>
<dt>Precondition:</dt>
<dd>Each entry in new_indeterminates should not be dummy.</dd>
<dt>Precondition:</dt>
<dd>Each entry in new_indeterminates should be of CONTINUOUS type.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.AddL2NormCost">
<code class="descname">AddL2NormCost</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram, A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[m, 1]], vars: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.Binding[L2NormCost]<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.AddL2NormCost" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds an L2 norm cost <a href="#id3"><span class="problematic" id="id4">|</span></a>Ax+b|₂ (notice this cost is not quadratic since
we don’t take the square of the L2 norm).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Currently no solver supports kL2NormCost, and the user will
receive an error message if they add L2NormCost and call Solve().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.AddL2NormCostUsingConicConstraint">
<code class="descname">AddL2NormCostUsingConicConstraint</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram, A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[m, 1]], vars: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; Tuple[pydrake.symbolic.Variable, pydrake.solvers.Binding[LinearCost], pydrake.solvers.Binding[LorentzConeConstraint]]<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.AddL2NormCostUsingConicConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds an L2 norm cost min <a href="#id5"><span class="problematic" id="id6">|</span></a>Ax+b|₂ as a linear cost min s on the slack
variable s, together with a Lorentz cone constraint s ≥ <a href="#id7"><span class="problematic" id="id8">|</span></a>Ax+b|₂ Many
conic optimization solvers (Gurobi, MOSEK<a href="/tm.html">™</a>, SCS, etc) natively prefers
this form of linear cost + conic constraints. So if you are going to
use one of these conic solvers, then add the L2 norm cost using this
function instead of AddL2NormCost().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">(s, linear_cost, lorentz_cone_constraint). <code class="docutils literal notranslate"><span class="pre">s</span></code> is the slack
variable (with variable name string as “slack”), <code class="docutils literal notranslate"><span class="pre">linear_cost</span></code>
is the cost on <code class="docutils literal notranslate"><span class="pre">s</span></code>, and <code class="docutils literal notranslate"><span class="pre">lorentz_cone_constraint</span></code> is the
constraint s≥|Ax+b|₂</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.AddLinearComplementarityConstraint">
<code class="descname">AddLinearComplementarityConstraint</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram, arg0: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], arg1: numpy.ndarray[numpy.float64[m, 1]], arg2: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.Binding[LinearComplementarityConstraint]<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.AddLinearComplementarityConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a linear complementarity constraints referencing a subset of the
decision variables.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.AddLinearConstraint">
<code class="descname">AddLinearConstraint</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.MathematicalProgram.AddLinearConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>AddLinearConstraint(self: pydrake.solvers.MathematicalProgram, A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], lb: numpy.ndarray[numpy.float64[m, 1]], ub: numpy.ndarray[numpy.float64[m, 1]], vars: numpy.ndarray[object[m, 1]]) -&gt; pydrake.solvers.Binding[LinearConstraint]</li>
</ol>
<p>Adds linear constraints referencing potentially a subset of the
decision variables (defined in the vars parameter).</p>
<ol class="arabic simple" start="2">
<li>AddLinearConstraint(self: pydrake.solvers.MathematicalProgram, e: pydrake.symbolic.Expression, lb: float, ub: float) -&gt; pydrake.solvers.Binding[LinearConstraint]</li>
</ol>
<p>Adds one row of linear constraint lb &lt;= e &lt;= ub where <code class="docutils literal notranslate"><span class="pre">e</span></code> is a
symbolic expression.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if 1. <code class="docutils literal notranslate"><span class="pre">e</span></code> is a non-linear expression. 2. <a href="#id9"><span class="problematic" id="id10">``</span></a>lb &lt;= e</li>
<li>&lt;= ub`` is a trivial constraint such as 1 &lt;= 2 &lt;= 3. 3. <a href="#id11"><span class="problematic" id="id12">``</span></a>lb &lt;= e</li>
<li>&lt;= ub`` is unsatisfiable such as 1 &lt;= -5 &lt;= 3</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">e</span></code>:</dt>
<dd>A linear symbolic expression in the form of <code class="docutils literal notranslate"><span class="pre">c0</span> <span class="pre">+</span> <span class="pre">c1</span> <span class="pre">*</span> <span class="pre">v1</span> <span class="pre">+</span> <span class="pre">...</span> <span class="pre">+</span>
<span class="pre">cn</span> <span class="pre">*</span> <span class="pre">vn</span></code> where <code class="docutils literal notranslate"><span class="pre">c_i</span></code> is a constant and &#64;v_i is a variable.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lb</span></code>:</dt>
<dd>A scalar, the lower bound.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">ub</span></code>:</dt>
<dd>A scalar, the upper bound.</dd>
</dl>
<ol class="arabic simple" start="3">
<li>AddLinearConstraint(self: pydrake.solvers.MathematicalProgram, v: numpy.ndarray[object[m, n], flags.f_contiguous], lb: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], ub: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]) -&gt; pydrake.solvers.Binding[LinearConstraint]</li>
</ol>
<p>Adds linear constraints represented by symbolic expressions to the
program. It throws if &#64;v includes a non-linear expression or <code class="docutils literal notranslate"><span class="pre">lb</span> <span class="pre">&lt;=</span> <span class="pre">v</span>
<span class="pre">&lt;=</span> <span class="pre">ub</span></code> includes trivial/unsatisfiable constraints.</p>
<ol class="arabic simple" start="4">
<li>AddLinearConstraint(self: pydrake.solvers.MathematicalProgram, f: pydrake.symbolic.Formula) -&gt; pydrake.solvers.Binding[LinearConstraint]</li>
</ol>
<p>Add a linear constraint represented by a symbolic formula to the
program. The input formula <code class="docutils literal notranslate"><span class="pre">f</span></code> can be of the following forms:</p>
<ol class="arabic simple">
<li>e1 &lt;= e2</li>
<li>e1 &gt;= e2</li>
<li>e1 == e2</li>
<li>A conjunction of relational formulas where each conjunct is
a relational formula matched by 1, 2, or 3.</li>
</ol>
<p>Note that first two cases might return an object of
Binding&lt;BoundingBoxConstraint&gt; depending on <code class="docutils literal notranslate"><span class="pre">f</span></code>. Also the third case
returns an object of Binding&lt;LinearEqualityConstraint&gt;.</p>
<p>It throws an exception if 1. <code class="docutils literal notranslate"><span class="pre">f</span></code> is not matched with one of the
above patterns. Especially, strict inequalities (&lt;, &gt;) are not
allowed. 2. <code class="docutils literal notranslate"><span class="pre">f</span></code> includes a non-linear expression. 3. <code class="docutils literal notranslate"><span class="pre">f</span></code> is either
a trivial constraint such as “1 &lt;= 2” or an unsatisfiable constraint
such as “2 &lt;= 1”. 4. It is not possible to find numerical bounds of
<code class="docutils literal notranslate"><span class="pre">e1</span></code> and <code class="docutils literal notranslate"><span class="pre">e2</span></code> where <code class="docutils literal notranslate"><span class="pre">f</span></code> = e1 ≃ e2. We allow <code class="docutils literal notranslate"><span class="pre">e1</span></code> and <code class="docutils literal notranslate"><span class="pre">e2</span></code> to
be infinite but only if there are no other terms. For example, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;=</span>
<span class="pre">∞</span></code> is allowed. However, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">∞</span> <span class="pre">&lt;=</span> <span class="pre">0</span></code> is not allowed because <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">↦</span>
<span class="pre">∞</span></code> introduces <code class="docutils literal notranslate"><span class="pre">nan</span></code> in the evaluation.</p>
<ol class="arabic simple" start="5">
<li>AddLinearConstraint(self: pydrake.solvers.MathematicalProgram, formulas: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; pydrake.solvers.Binding[LinearConstraint]</li>
</ol>
<p>Add a linear constraint represented by an
Eigen::Array&lt;symbolic::Formula&gt; to the program. A common use-case of
this function is to add a linear constraint with the element-wise
comparison between two Eigen matrices, using <code class="docutils literal notranslate"><span class="pre">A.array()</span> <span class="pre">&lt;=</span>
<span class="pre">B.array()</span></code>. See the following example.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MathematicalProgram</span> <span class="n">prog</span><span class="p">;</span>
  <span class="n">Eigen</span><span class="p">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">double</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">A</span><span class="p">;</span>
  <span class="n">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">NewContinuousVariables</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">);</span>
  <span class="n">Eigen</span><span class="p">::</span><span class="n">Vector2d</span> <span class="n">b</span><span class="p">;</span>
  <span class="o">...</span> <span class="o">//</span> <span class="nb">set</span> <span class="n">up</span> <span class="n">A</span> <span class="ow">and</span> <span class="n">b</span>
  <span class="n">prog</span><span class="o">.</span><span class="n">AddLinearConstraint</span><span class="p">((</span><span class="n">A</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">array</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="o">.</span><span class="n">array</span><span class="p">());</span>
</pre></div>
</div>
<p>A formula in <code class="docutils literal notranslate"><span class="pre">formulas</span></code> can be of the following forms:</p>
<ol class="arabic simple">
<li>e1 &lt;= e2 2. e1 &gt;= e2 3. e1 == e2</li>
</ol>
<p>It throws an exception if AddLinearConstraint(const symbolic::Formula&amp;
f) throws an exception for f ∈ <code class="docutils literal notranslate"><span class="pre">formulas</span></code>.</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">Derived</span></code>:</dt>
<dd>An Eigen Array type of Formula.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.AddLinearCost">
<code class="descname">AddLinearCost</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.MathematicalProgram.AddLinearCost" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>AddLinearCost(self: pydrake.solvers.MathematicalProgram, e: pydrake.symbolic.Expression) -&gt; pydrake.solvers.Binding[LinearCost]</li>
</ol>
<p>Adds a linear cost term of the form a’<a href="#id13"><span class="problematic" id="id14">*</span></a>x + b.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">e</span></code>:</dt>
<dd>A linear symbolic expression.</dd>
<dt>Precondition:</dt>
<dd>e is a linear expression a’<a href="#id15"><span class="problematic" id="id16">*</span></a>x + b, where each entry of x is a
decision variable in the mathematical program.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The newly added linear constraint, together with the bound
variables.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>AddLinearCost(self: pydrake.solvers.MathematicalProgram, a: numpy.ndarray[numpy.float64[m, 1]], b: float, vars: numpy.ndarray[object[m, 1]]) -&gt; pydrake.solvers.Binding[LinearCost]</li>
</ol>
<p>Adds a linear cost term of the form a’<a href="#id17"><span class="problematic" id="id18">*</span></a>x + b. Applied to a subset of
the variables and pushes onto the linear cost data structure.</p>
<ol class="arabic simple" start="3">
<li>AddLinearCost(self: pydrake.solvers.MathematicalProgram, a: numpy.ndarray[numpy.float64[m, 1]], vars: numpy.ndarray[object[m, 1]]) -&gt; pydrake.solvers.Binding[LinearCost]</li>
</ol>
<p>Adds a linear cost term of the form a’<a href="#id19"><span class="problematic" id="id20">*</span></a>x. Applied to a subset of the
variables and pushes onto the linear cost data structure.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.AddLinearEqualityConstraint">
<code class="descname">AddLinearEqualityConstraint</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.MathematicalProgram.AddLinearEqualityConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>AddLinearEqualityConstraint(self: pydrake.solvers.MathematicalProgram, Aeq: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], beq: numpy.ndarray[numpy.float64[m, 1]], vars: numpy.ndarray[object[m, 1]]) -&gt; pydrake.solvers.Binding[LinearEqualityConstraint]</li>
</ol>
<p>AddLinearEqualityConstraint</p>
<p>Adds linear equality constraints referencing potentially a subset of
the decision variables.</p>
<p>Example: to add two equality constraints which only depend on two of
the elements of x, you could use</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">NewContinuousVariables</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="s2">&quot;myvar&quot;</span><span class="p">);</span>
  <span class="n">Eigen</span><span class="p">::</span><span class="n">Matrix2d</span> <span class="n">Aeq</span><span class="p">;</span>
  <span class="n">Aeq</span> <span class="o">&lt;&lt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
          <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">Eigen</span><span class="p">::</span><span class="n">Vector2d</span> <span class="n">beq</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
  <span class="o">//</span> <span class="n">Imposes</span> <span class="n">constraint</span>
  <span class="o">//</span> <span class="o">-</span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="o">//</span>  <span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span>  <span class="n">x</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="mi">3</span>
  <span class="n">prog</span><span class="o">.</span><span class="n">AddLinearEqualityConstraint</span><span class="p">(</span><span class="n">Aeq</span><span class="p">,</span> <span class="n">beq</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">head</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">());</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li>AddLinearEqualityConstraint(self: pydrake.solvers.MathematicalProgram, e: pydrake.symbolic.Expression, b: float) -&gt; pydrake.solvers.Binding[LinearEqualityConstraint]</li>
</ol>
<p>Adds one row of linear constraint e = b where <code class="docutils literal notranslate"><span class="pre">e</span></code> is a symbolic
expression.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if 1. <code class="docutils literal notranslate"><span class="pre">e</span></code> is a non-linear expression. 2. <code class="docutils literal notranslate"><span class="pre">e</span></code> is a</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">constant.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">e</span></code>:</dt>
<dd>A linear symbolic expression in the form of <code class="docutils literal notranslate"><span class="pre">c0</span> <span class="pre">+</span> <span class="pre">c1</span> <span class="pre">*</span> <span class="pre">x1</span> <span class="pre">+</span> <span class="pre">...</span> <span class="pre">+</span>
<span class="pre">cn</span> <span class="pre">*</span> <span class="pre">xn</span></code> where <code class="docutils literal notranslate"><span class="pre">c_i</span></code> is a constant and &#64;x_i is a variable.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>:</dt>
<dd>A scalar.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The newly added linear equality constraint, together with the
bound variable.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="3">
<li>AddLinearEqualityConstraint(self: pydrake.solvers.MathematicalProgram, f: pydrake.symbolic.Formula) -&gt; pydrake.solvers.Binding[LinearEqualityConstraint]</li>
</ol>
<p>Adds a linear equality constraint represented by a symbolic formula to
the program. The input formula <code class="docutils literal notranslate"><span class="pre">f</span></code> is either an equality formula
(<code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">==</span> <span class="pre">e2</span></code>) or a conjunction of equality formulas.</p>
<p>It throws an exception if</p>
<ol class="arabic simple">
<li><code class="docutils literal notranslate"><span class="pre">f</span></code> is neither an equality formula nor a conjunction of equalities.</li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code> includes a non-linear expression.</li>
</ol>
<ol class="arabic simple" start="4">
<li>AddLinearEqualityConstraint(self: pydrake.solvers.MathematicalProgram, v: numpy.ndarray[object[m, 1]], b: numpy.ndarray[numpy.float64[m, 1]]) -&gt; pydrake.solvers.Binding[LinearEqualityConstraint]</li>
</ol>
<p>Adds linear equality constraints <span class="math notranslate nohighlight">\(v = b\)</span>, where <code class="docutils literal notranslate"><span class="pre">v(i)</span></code> is a
symbolic linear expression.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if 1. <code class="docutils literal notranslate"><span class="pre">v(i)</span></code> is a non-linear expression. 2.</li>
<li><code class="docutils literal notranslate"><span class="pre">v(i)</span></code> is a constant.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">DerivedV</span></code>:</dt>
<dd>An Eigen Matrix type of Expression. A column vector.</dd>
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">DerivedB</span></code>:</dt>
<dd>An Eigen Matrix type of double. A column vector.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v</span></code>:</dt>
<dd>v(i) is a linear symbolic expression in the form of `` c0 + c1 *
x1 + … + cn * xn `` where ci is a constant and &#64;xi is a
variable.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>:</dt>
<dd>A vector of doubles.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The newly added linear equality constraint, together with the
bound variables.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.AddLinearMatrixInequalityConstraint">
<code class="descname">AddLinearMatrixInequalityConstraint</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram, F: List[numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]], vars: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.Binding[LinearMatrixInequalityConstraint]<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.AddLinearMatrixInequalityConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a linear matrix inequality constraint to the program.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.AddLorentzConeConstraint">
<code class="descname">AddLorentzConeConstraint</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.MathematicalProgram.AddLorentzConeConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>AddLorentzConeConstraint(self: pydrake.solvers.MathematicalProgram, v: numpy.ndarray[object[m, 1]], eval_type: pydrake.solvers.LorentzConeConstraint.EvalType = &lt;EvalType.kConvexSmooth: 1&gt;) -&gt; pydrake.solvers.Binding[LorentzConeConstraint]</li>
</ol>
<p>Adds Lorentz cone constraint referencing potentially a subset of the
decision variables.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v</span></code>:</dt>
<dd>An Eigen::Vector of symbolic::Expression. Constraining that</dd>
</dl>
<div class="math notranslate nohighlight">
\[v_0 \ge \sqrt{v_1^2 + ... + v_{n-1}^2}\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The newly constructed Lorentz cone constraint with the bounded
variables. For example, to add the Lorentz cone constraint</td>
</tr>
</tbody>
</table>
<p>x+1 &gt;= sqrt(y² + 2y + x² + 5), = sqrt((y+1)²+x²+2²) The user could
call</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">cc</span><span class="p">}</span>
<span class="n">Vector4</span><span class="o">&lt;</span><span class="n">symbolic</span><span class="p">::</span><span class="n">Expression</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="mf">2.</span><span class="p">);</span>
<span class="n">prog</span><span class="o">.</span><span class="n">AddLorentzConeConstraint</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">eval_type</span></code>:</dt>
<dd>The evaluation type when evaluating the lorentz cone constraint in
generic optimization. Refer to LorentzConeConstraint::EvalType for
more details.</dd>
</dl>
<ol class="arabic simple" start="2">
<li>AddLorentzConeConstraint(self: pydrake.solvers.MathematicalProgram, linear_expression: pydrake.symbolic.Expression, quadratic_expression: pydrake.symbolic.Expression, tol: float = 0.0, eval_type: pydrake.solvers.LorentzConeConstraint.EvalType = &lt;EvalType.kConvexSmooth: 1&gt;) -&gt; pydrake.solvers.Binding[LorentzConeConstraint]</li>
</ol>
<p>Adds Lorentz cone constraint on the linear expression v1 and quadratic
expression v2, such that v1 &gt;= sqrt(v2)</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">linear_expression</span></code>:</dt>
<dd>The linear expression v1.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quadratic_expression</span></code>:</dt>
<dd>The quadratic expression v2.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">tol</span></code>:</dt>
<dd>The tolerance to determine if the matrix in v2 is positive
semidefinite or not.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">DecomposePositiveQuadraticForm for more explanation. $*Default:*
is 0.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">eval_type</span></code>:</dt>
<dd>The evaluation type when evaluating the lorentz cone constraint in
generic optimization. Refer to LorentzConeConstraint::EvalType for
more details.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">binding</span></code>:</dt>
<dd>The newly added Lorentz cone constraint, together with the bound
variables.</dd>
</dl>
<p>Precondition:
1. <code class="docutils literal notranslate"><span class="pre">v1</span></code> is a linear expression, in the form of c’<a href="#id21"><span class="problematic" id="id22">*</span></a>x + d.
2. <code class="docutils literal notranslate"><span class="pre">v2</span></code> is a quadratic expression, in the form of</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="s1">&#39;*Q*x + b&#39;</span><span class="n">x</span> <span class="o">+</span> <span class="n">a</span>
</pre></div>
</div>
<p>Also the quadratic expression has to be convex, namely Q is a positive
semidefinite matrix, and the quadratic expression needs to be
non-negative for any x.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the preconditions are not satisfied.</td>
</tr>
</tbody>
</table>
<p>Notice this constraint is equivalent to the vector [z;y] is within a
Lorentz cone, where</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">z</span> <span class="o">=</span> <span class="n">v1</span>
 <span class="n">y</span> <span class="o">=</span> <span class="n">R</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">d</span>
</pre></div>
</div>
<p>while (R, d) satisfies y’<a href="#id23"><span class="problematic" id="id24">*</span></a>y = x’<a href="#id25"><span class="problematic" id="id26">*</span></a>Q*x + b’<a href="#id27"><span class="problematic" id="id28">*</span></a>x + a For example, to add
the Lorentz cone constraint</p>
<p>x+1 &gt;= sqrt(y² + 2y + x² + 4), the user could call</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">cc</span><span class="p">}</span>
<span class="n">prog</span><span class="o">.</span><span class="n">AddLorentzConeConstraint</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">pow</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="nb">pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
</pre></div>
</div>
<ol class="arabic simple" start="3">
<li>AddLorentzConeConstraint(self: pydrake.solvers.MathematicalProgram, A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[m, 1]], vars: numpy.ndarray[object[m, 1]], eval_type: pydrake.solvers.LorentzConeConstraint.EvalType = &lt;EvalType.kConvexSmooth: 1&gt;) -&gt; pydrake.solvers.Binding[LorentzConeConstraint]</li>
</ol>
<p>Adds Lorentz cone constraint referencing potentially a subset of the
decision variables (defined in the vars parameter). The linear
expression <span class="math notranslate nohighlight">\(z=Ax+b\)</span> is in the Lorentz cone. A vector <span class="math notranslate nohighlight">\(z
\in\mathbb{R}^n\)</span> is in the Lorentz cone, if</p>
<div class="math notranslate nohighlight">
\[z_0 \ge \sqrt{z_1^2 + ... + z_{n-1}^2}\]</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">A</span></code>:</dt>
<dd>A <span class="math notranslate nohighlight">\(\mathbb{R}^{n\times m}\)</span> matrix, whose number of columns
equals to the size of the decision variables.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>:</dt>
<dd>A <span class="math notranslate nohighlight">\(\mathbb{R}^n\)</span> vector, whose number of rows equals to the
size of the decision variables.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">vars</span></code>:</dt>
<dd>The Eigen vector of <span class="math notranslate nohighlight">\(m\)</span> decision variables.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">eval_type</span></code>:</dt>
<dd>The evaluation type when evaluating the lorentz cone constraint in
generic optimization. Refer to LorentzConeConstraint::EvalType for
more details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The newly added Lorentz cone constraint.</td>
</tr>
</tbody>
</table>
<p>For example, to add the Lorentz cone constraint</p>
<p>x+1 &gt;= sqrt(y² + 2y + x² + 5) = sqrt((y+1)² + x² + 2²), the user could
call</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">cc</span><span class="p">}</span>
<span class="n">Eigen</span><span class="p">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">double</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">A</span><span class="p">;</span>
<span class="n">Eigen</span><span class="p">::</span><span class="n">Vector4d</span> <span class="n">b</span><span class="p">;</span>
<span class="n">A</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">;</span>
<span class="o">//</span> <span class="n">A</span> <span class="o">*</span> <span class="p">[</span><span class="n">x</span><span class="p">;</span><span class="n">y</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">x</span><span class="p">;</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">prog</span><span class="o">.</span><span class="n">AddLorentzConeConstraint</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">Vector2</span><span class="o">&lt;</span><span class="n">symbolic</span><span class="p">::</span><span class="n">Variable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">));</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.AddMaximizeGeometricMeanCost">
<code class="descname">AddMaximizeGeometricMeanCost</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.MathematicalProgram.AddMaximizeGeometricMeanCost" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>AddMaximizeGeometricMeanCost(self: pydrake.solvers.MathematicalProgram, A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[m, 1]], x: numpy.ndarray[object[m, 1]]) -&gt; pydrake.solvers.Binding[LinearCost]</li>
</ol>
<p>An overloaded version of maximize_geometric_mean.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">cost The added cost (note that since MathematicalProgram only
minimizes the cost, the returned cost evaluates to -c *
power(∏ᵢx(i), 1/n).</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>A.rows() == b.rows(), A.rows() &gt;= 2.</dd>
</dl>
<ol class="arabic simple" start="2">
<li>AddMaximizeGeometricMeanCost(self: pydrake.solvers.MathematicalProgram, x: numpy.ndarray[object[m, 1]], c: float) -&gt; pydrake.solvers.Binding[LinearCost]</li>
</ol>
<p>An overloaded version of maximize_geometric_mean. We add the cost to
maximize the geometric mean of x, i.e., c*power(∏ᵢx(i), 1/n).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">c</span></code>:</dt>
<dd>The positive coefficient of the geometric mean cost, $*Default:*
is 1.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">cost The added cost (note that since MathematicalProgram only
minimizes the cost, the returned cost evaluates to -c *
power(∏ᵢx(i), 1/n).</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>x.rows() &gt;= 2.</dd>
<dt>Precondition:</dt>
<dd>c &gt; 0.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.AddMaximizeLogDeterminantCost">
<code class="descname">AddMaximizeLogDeterminantCost</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram, X: numpy.ndarray[object[m, n], flags.f_contiguous]</em><span class="sig-paren">)</span> &#x2192; Tuple[pydrake.solvers.Binding[LinearCost], numpy.ndarray[object[m, 1]], numpy.ndarray[object[m, n]]]<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.AddMaximizeLogDeterminantCost" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the cost to maximize the log determinant of symmetric matrix X.
log(det(X)) is a concave function of X, so we can maximize it through
convex optimization. In order to do that, we introduce slack variables
t, and a lower triangular matrix Z, with the constraints</p>
<p>⌈X Z⌉ is positive semidifinite. ⌊Zᵀ diag(Z)⌋</p>
<p>log(Z(i, i)) &gt;= t(i)</p>
<p>and we will minimize -∑ᵢt(i).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X</span></code>:</dt>
<dd>A symmetric positive semidefinite matrix X, whose log(det(X)) will
be maximized.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">(cost, t, Z) cost is -∑ᵢt(i), we also return the newly created
slack variables t and the lower triangular matrix Z. Note that Z
is not a matrix of symbolic::Variable but symbolic::Expression,
because the upper-diagonal entries of Z are not variable, but
expression 0.</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>X is a symmetric matrix.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">We implicitly require that <code class="docutils literal notranslate"><span class="pre">X</span></code> being positive semidefinite (psd)
(as X is the diagonal entry of the big psd matrix above). If your
<code class="docutils literal notranslate"><span class="pre">X</span></code> is not necessarily psd, then don’t call this function.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The constraint log(Z(i, i)) &gt;= t(i) is imposed as an exponential
cone constraint. Please make sure your have a solver that supports
exponential cone constraint (currently SCS does). Refer to
<a class="reference external" href="https://docs.mosek.com/modeling-cookbook/sdo.html#log-determinant">https://docs.mosek.com/modeling-cookbook/sdo.html#log-determinant</a>
for more details.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.AddPositiveDiagonallyDominantMatrixConstraint">
<code class="descname">AddPositiveDiagonallyDominantMatrixConstraint</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram, X: numpy.ndarray[object[m, n], flags.f_contiguous]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, n]]<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.AddPositiveDiagonallyDominantMatrixConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the constraint that a symmetric matrix is diagonally dominant
with non-negative diagonal entries. A symmetric matrix X is diagonally
dominant with non-negative diagonal entries if X(i, i) &gt;= ∑ⱼ <a href="#id47"><span class="problematic" id="id48">|X(i, j)|</span></a>
∀ j ≠ i namely in each row, the diagonal entry is larger than the sum
of the absolute values of all other entries in the same row. A matrix
being diagonally dominant with non-negative diagonals is a sufficient
(but not necessary) condition of a matrix being positive semidefinite.
Internally we will create a matrix Y as slack variables, such that
Y(i, j) represents the absolute value <a href="#id49"><span class="problematic" id="id50">|X(i, j)|</span></a> ∀ j ≠ i. The diagonal
entries Y(i, i) = X(i, i) The users can refer to “DSOS and SDSOS
Optimization: More Tractable Alternatives to Sum of Squares and
Semidefinite Optimization” by Amir Ali Ahmadi and Anirudha Majumdar,
with arXiv link <a class="reference external" href="https://arxiv.org/abs/1706.02586">https://arxiv.org/abs/1706.02586</a></p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X</span></code>:</dt>
<dd>The matrix X. We will use 0.5(X+Xᵀ) as the “symmetric version” of
X.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Y The slack variable. Y(i, j) represents <a href="#id51"><span class="problematic" id="id52">|X(i, j)|</span></a> ∀ j ≠ i, with
the constraint Y(i, j) &gt;= X(i, j) and Y(i, j) &gt;= -X(i, j). Y is a
symmetric matrix. The diagonal entries Y(i, i) = X(i, i)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.AddPositiveSemidefiniteConstraint">
<code class="descname">AddPositiveSemidefiniteConstraint</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.MathematicalProgram.AddPositiveSemidefiniteConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>AddPositiveSemidefiniteConstraint(self: pydrake.solvers.MathematicalProgram, arg0: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; pydrake.solvers.Binding[PositiveSemidefiniteConstraint]</li>
</ol>
<p>Adds a positive semidefinite constraint on a symmetric matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError in Debug mode if <code class="docutils literal notranslate"><span class="pre">symmetric_matrix_var</span></code> is not</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">symmetric.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">symmetric_matrix_var</span></code>:</dt>
<dd>A symmetric MatrixDecisionVariable object.</dd>
</dl>
<ol class="arabic simple" start="2">
<li>AddPositiveSemidefiniteConstraint(self: pydrake.solvers.MathematicalProgram, arg0: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; pydrake.solvers.Binding[PositiveSemidefiniteConstraint]</li>
</ol>
<p>Adds a positive semidefinite constraint on a symmetric matrix of
symbolic expressions <code class="docutils literal notranslate"><span class="pre">e</span></code>. We create a new symmetric matrix of
variables M being positive semidefinite, with the linear equality
constraint e == M.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">e</span></code>:</dt>
<dd>Imposes constraint “e is positive semidefinite”.</dd>
<dt>Precondition:</dt>
<dd>{1. e is symmetric. 2. e(i, j) is linear for all i, j }</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The newly added positive semidefinite constraint, with the bound
variable M that are also newly added.</td>
</tr>
</tbody>
</table>
<p>For example, to add a constraint that</p>
<p>⌈x + 1 2x + 3 x+y⌉ <a href="#id53"><span class="problematic" id="id54">|2x+ 3 2 0|</span></a> is positive semidefinite ⌊x + y 0 x⌋
The user could call</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">cc</span><span class="p">}</span>
<span class="n">Matrix3</span><span class="o">&lt;</span><span class="n">symbolic</span><span class="p">::</span><span class="n">Expression</span><span class="o">&gt;</span> <span class="n">e</span>
<span class="n">e</span> <span class="o">&lt;&lt;</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">,</span>
     <span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span>   <span class="mi">2</span><span class="p">,</span>   <span class="mi">0</span><span class="p">,</span>
     <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>   <span class="n">x</span><span class="p">;</span>
<span class="n">prog</span><span class="o">.</span><span class="n">AddPositiveSemidefiniteConstraint</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.AddQuadraticAsRotatedLorentzConeConstraint">
<code class="descname">AddQuadraticAsRotatedLorentzConeConstraint</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram, Q: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[m, 1]], c: float, vars: numpy.ndarray[object[m, 1]], psd_tol: float = 0.0</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.Binding[RotatedLorentzConeConstraint]<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.AddQuadraticAsRotatedLorentzConeConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the convex quadratic constraint 0.5xᵀQx + bᵀx + c &lt;= 0 as a
rotated Lorentz cone constraint [rᵀx+s, 1, Px+q] is in the rotated
Lorentz cone. When solving the optimization problem using conic
solvers (like Mosek, Gurobi, SCS, etc), it is numerically preferrable
to impose the convex quadratic constraint as rotated Lorentz cone
constraint. See
<a class="reference external" href="https://docs.mosek.com/latest/capi/prob-def-quadratic.html#a-recommendation">https://docs.mosek.com/latest/capi/prob-def-quadratic.html#a-recommendation</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>exception if this quadratic constraint is not convex (Q is not</li>
<li>positive semidefinite)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Q</span></code>:</dt>
<dd>The Hessian of the quadratic constraint. Should be positive
semidefinite.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>:</dt>
<dd>The linear coefficient of the quadratic constraint.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">c</span></code>:</dt>
<dd>The constant term of the quadratic constraint.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">vars</span></code>:</dt>
<dd>x in the documentation above.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">psd_tol</span></code>:</dt>
<dd>If the minimal eigenvalue of Q is smaller than -psd_tol, then
throw an exception. $*Default:* = 0.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.AddQuadraticCost">
<code class="descname">AddQuadraticCost</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.MathematicalProgram.AddQuadraticCost" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>AddQuadraticCost(self: pydrake.solvers.MathematicalProgram, e: pydrake.symbolic.Expression, is_convex: Optional[bool] = None) -&gt; pydrake.solvers.Binding[QuadraticCost]</li>
</ol>
<p>Add a quadratic cost term of the form 0.5*x’<a href="#id29"><span class="problematic" id="id30">*</span></a>Q*x + b’<a href="#id31"><span class="problematic" id="id32">*</span></a>x + c. Notice
that in the optimization program, the constant term <code class="docutils literal notranslate"><span class="pre">c</span></code> in the cost
is ignored.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">e</span></code>:</dt>
<dd>A quadratic symbolic expression.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">is_convex</span></code>:</dt>
<dd>Whether the cost is already known to be convex. If
is_convex=nullopt (the default), then Drake will determine if
<code class="docutils literal notranslate"><span class="pre">e</span></code> is a convex quadratic cost or not. To improve the
computation speed, the user can set is_convex if the user knows
whether the cost is convex or not.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the expression is not quadratic.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The newly added cost together with the bound variables.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>AddQuadraticCost(self: pydrake.solvers.MathematicalProgram, Q: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[m, 1]], vars: numpy.ndarray[object[m, 1]], is_convex: Optional[bool] = None) -&gt; pydrake.solvers.Binding[QuadraticCost]</li>
</ol>
<p>Adds a cost term of the form 0.5*x’<a href="#id33"><span class="problematic" id="id34">*</span></a>Q*x + b’x Applied to subset of the
variables.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">is_convex</span></code>:</dt>
<dd>Whether the cost is already known to be convex. If
is_convex=nullopt (the default), then Drake will determine if this
is a convex quadratic cost or not. To improve the computation
speed, the user can set is_convex if the user knows whether the
cost is convex or not.</dd>
</dl>
<ol class="arabic simple" start="3">
<li>AddQuadraticCost(self: pydrake.solvers.MathematicalProgram, Q: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[m, 1]], c: float, vars: numpy.ndarray[object[m, 1]], is_convex: Optional[bool] = None) -&gt; pydrake.solvers.Binding[QuadraticCost]</li>
</ol>
<p>Adds a cost term of the form 0.5*x’<a href="#id35"><span class="problematic" id="id36">*</span></a>Q*x + b’x + c Applied to subset of
the variables.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">is_convex</span></code>:</dt>
<dd>Whether the cost is already known to be convex. If
is_convex=nullopt (the default), then Drake will determine if this
is a convex quadratic cost or not. To improve the computation
speed, the user can set is_convex if the user knows whether the
cost is convex or not.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.AddQuadraticErrorCost">
<code class="descname">AddQuadraticErrorCost</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram, Q: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], x_desired: numpy.ndarray[numpy.float64[m, 1]], vars: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.Binding[QuadraticCost]<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.AddQuadraticErrorCost" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a cost term of the form (x-x_desired)’<a href="#id37"><span class="problematic" id="id38">*</span></a>Q*(x-x_desired).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.AddRotatedLorentzConeConstraint">
<code class="descname">AddRotatedLorentzConeConstraint</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.MathematicalProgram.AddRotatedLorentzConeConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>AddRotatedLorentzConeConstraint(self: pydrake.solvers.MathematicalProgram, linear_expression1: pydrake.symbolic.Expression, linear_expression2: pydrake.symbolic.Expression, quadratic_expression: pydrake.symbolic.Expression, tol: float = 0) -&gt; pydrake.solvers.Binding[RotatedLorentzConeConstraint]</li>
</ol>
<p>Adds rotated Lorentz cone constraint on the linear expression v1, v2
and quadratic expression u, such that v1 * v2 &gt;= u, v1 &gt;= 0, v2 &gt;= 0</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">linear_expression1</span></code>:</dt>
<dd>The linear expression v1.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">linear_expression2</span></code>:</dt>
<dd>The linear expression v2.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quadratic_expression</span></code>:</dt>
<dd>The quadratic expression u.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">tol</span></code>:</dt>
<dd>The tolerance to determine if the matrix in v2 is positive
semidefinite or not.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">DecomposePositiveQuadraticForm for more explanation. $*Default:*
is 0.</p>
</div>
<dl class="docutils">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">binding</span></code>:</dt>
<dd>The newly added rotated Lorentz cone constraint, together with the
bound variables.</dd>
</dl>
<p>Precondition:
1. <code class="docutils literal notranslate"><span class="pre">linear_expression1</span></code> is a linear (affine) expression, in the form of</p>
<blockquote>
<div>v1 = c1’<a href="#id39"><span class="problematic" id="id40">*</span></a>x + d1.</div></blockquote>
<ol class="arabic simple" start="2">
<li><code class="docutils literal notranslate"><span class="pre">linear_expression2</span></code> is a linear (affine) expression, in the form of
v2 = c2’<a href="#id41"><span class="problematic" id="id42">*</span></a>x + d2.</li>
</ol>
<ol class="arabic simple" start="2">
<li><code class="docutils literal notranslate"><span class="pre">quadratic_expression</span></code> is a quadratic expression, in the form of</li>
</ol>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">u</span> <span class="o">=</span> <span class="n">x</span><span class="s1">&#39;*Q*x + b&#39;</span><span class="n">x</span> <span class="o">+</span> <span class="n">a</span>
</pre></div>
</div>
<p>Also the quadratic expression has to be convex, namely Q is a positive
semidefinite matrix, and the quadratic expression needs to be
non-negative for any x.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the preconditions are not satisfied.</td>
</tr>
</tbody>
</table>
<p>For example, to add the rotated Lorentz cone constraint</p>
<p>(x+1)(x+y) &gt;= x²+z²+2z+5 x+1 &gt;= 0 x+y &gt;= 0 The user could call</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">cc</span><span class="p">}</span>
<span class="n">prog</span><span class="o">.</span><span class="n">AddRotatedLorentzConeConstraint</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">,</span> <span class="nb">pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nb">pow</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span>
<span class="mi">2</span><span class="o">*</span><span class="n">z</span><span class="o">+</span><span class="mi">5</span><span class="p">);</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li>AddRotatedLorentzConeConstraint(self: pydrake.solvers.MathematicalProgram, v: numpy.ndarray[object[m, 1]]) -&gt; pydrake.solvers.Binding[RotatedLorentzConeConstraint]</li>
</ol>
<p>Adds a constraint that a symbolic expression</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v</span></code>:</dt>
<dd>is in the rotated Lorentz cone, i.e.,</dd>
</dl>
<div class="math notranslate nohighlight">
\[v_0v_1 \ge v_2^2 + ... + v_{n-1}^2\\]</div>
<p>v_0 ge 0, v_1 ge 0</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v</span></code>:</dt>
<dd>A linear expression of variables, <span class="math notranslate nohighlight">\(v = A x + b\)</span>, where
<span class="math notranslate nohighlight">\(A, b\)</span> are given matrices of the correct size, <span class="math notranslate nohighlight">\(x\)</span> is
the vector of decision variables.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">binding</span></code>:</dt>
<dd>The newly added rotated Lorentz cone constraint, together with the
bound variables.</dd>
</dl>
<p>For example, to add the rotated Lorentz cone constraint</p>
<p>(x+1)(x+y) &gt;= x²+z²+2z+5 = x² + (z+1)² + 2² x+1 &gt;= 0 x+y &gt;= 0 The user
could call</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">cc</span><span class="p">}</span>
<span class="n">Eigen</span><span class="p">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">symbolic</span><span class="p">::</span><span class="n">Expression</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
<span class="n">v</span> <span class="o">&lt;&lt;</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">prog</span><span class="o">.</span><span class="n">AddRotatedLorentzConeConstraint</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
</pre></div>
</div>
<ol class="arabic simple" start="3">
<li>AddRotatedLorentzConeConstraint(self: pydrake.solvers.MathematicalProgram, A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[m, 1]], vars: numpy.ndarray[object[m, 1]]) -&gt; pydrake.solvers.Binding[RotatedLorentzConeConstraint]</li>
</ol>
<p>Adds a rotated Lorentz cone constraint referencing potentially a
subset of decision variables, The linear expression <span class="math notranslate nohighlight">\(z=Ax+b\)</span> is
in rotated Lorentz cone. A vector <span class="math notranslate nohighlight">\(z \in\mathbb{R}^n\)</span> is in the
rotated Lorentz cone, if</p>
<div class="math notranslate nohighlight">
\[z_0z_1 \ge z_2^2 + ... + z_{n-1}^2\]</div>
<p>where <span class="math notranslate nohighlight">\(A\in\mathbb{R}^{n\times m}, b\in\mathbb{R}^n\)</span> are given
matrices.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">A</span></code>:</dt>
<dd>A matrix whose number of columns equals to the size of the
decision variables.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>:</dt>
<dd>A vector whose number of rows equals to the size fo the decision
variables.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">vars</span></code>:</dt>
<dd>The decision variables on which the constraint is imposed.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.AddScaledDiagonallyDominantMatrixConstraint">
<code class="descname">AddScaledDiagonallyDominantMatrixConstraint</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.MathematicalProgram.AddScaledDiagonallyDominantMatrixConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>AddScaledDiagonallyDominantMatrixConstraint(self: pydrake.solvers.MathematicalProgram, X: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; List[List[numpy.ndarray[object[2, 2]]]]</li>
</ol>
<p>This is an overloaded variant of addsdd “scaled diagonally dominant
matrix constraint”</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X</span></code>:</dt>
<dd>The matrix X to be constrained scaled diagonally dominant. X.</dd>
<dt>Precondition:</dt>
<dd>X(i, j) should be a linear expression of decision variables.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">M A vector of vectors of 2 x 2 symmetric matrices M. For i &lt; j,
M[i][j] is</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">Mⁱʲ</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="n">Mⁱʲ</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)]</span>
<span class="p">[</span><span class="n">Mⁱʲ</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">Mⁱʲ</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">)]</span><span class="o">.</span>
</pre></div>
</div>
<p>Note that M[i][j](0, 1) = Mⁱʲ(i, j) = (X(i, j) + X(j, i)) / 2 for i &gt;=
j, M[i][j] is the zero matrix.</p>
<ol class="arabic simple" start="2">
<li>AddScaledDiagonallyDominantMatrixConstraint(self: pydrake.solvers.MathematicalProgram, X: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; List[List[numpy.ndarray[object[2, 2]]]]</li>
</ol>
<p>This is an overloaded variant of addsdd “scaled diagonally dominant
matrix constraint”</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X</span></code>:</dt>
<dd>The symmetric matrix X to be constrained scaled diagonally
dominant.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">M For i &lt; j M[i][j] contains the slack variables, mentioned in
addsdd “scaled diagonally dominant matrix constraint”. For i &gt;= j,
M[i][j] contains dummy variables.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.AddSosConstraint">
<code class="descname">AddSosConstraint</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.MathematicalProgram.AddSosConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>AddSosConstraint(self: pydrake.solvers.MathematicalProgram, p: pydrake.symbolic.Polynomial, monomial_basis: numpy.ndarray[object[m, 1]], type: pydrake.solvers.MathematicalProgram.NonnegativePolynomial = &lt;NonnegativePolynomial.kSos: 1&gt;, gram_name: str = ‘S’) -&gt; numpy.ndarray[object[m, n]]</li>
</ol>
<p>Adds constraints that a given polynomial <code class="docutils literal notranslate"><span class="pre">p</span></code> is a sums-of-squares
(SOS), that is, <code class="docutils literal notranslate"><span class="pre">p</span></code> can be decomposed into <code class="docutils literal notranslate"><span class="pre">mᵀQm</span></code>, where m is the
<code class="docutils literal notranslate"><span class="pre">monomial_basis</span></code>. It returns the coefficients matrix Q, which is
positive semidefinite.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">type</span></code>:</dt>
<dd>The type of the polynomial. $*Default:* is kSos, but the user can
also use kSdsos and kDsos. Refer to NonnegativePolynomial for
details on different types of sos polynomials.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">gram_name</span></code>:</dt>
<dd>The name of the gram matrix for print out.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It calls <code class="docutils literal notranslate"><span class="pre">Reparse</span></code> to enforce <code class="docutils literal notranslate"><span class="pre">p</span></code> to have this
MathematicalProgram’s indeterminates if necessary.</p>
</div>
<ol class="arabic simple" start="2">
<li>AddSosConstraint(self: pydrake.solvers.MathematicalProgram, p: pydrake.symbolic.Polynomial, type: pydrake.solvers.MathematicalProgram.NonnegativePolynomial = &lt;NonnegativePolynomial.kSos: 1&gt;, gram_name: str = ‘S’) -&gt; Tuple[numpy.ndarray[object[m, n]], numpy.ndarray[object[m, 1]]]</li>
</ol>
<p>Adds constraints that a given polynomial <code class="docutils literal notranslate"><span class="pre">p</span></code> is a sums-of-squares
(SOS), that is, <code class="docutils literal notranslate"><span class="pre">p</span></code> can be decomposed into <code class="docutils literal notranslate"><span class="pre">mᵀQm</span></code>, where m is a
monomial basis selected from the sparsity of <code class="docutils literal notranslate"><span class="pre">p</span></code>. It returns a pair
of constraint bindings expressing: - The coefficients matrix Q, which
is positive semidefinite. - The monomial basis m.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">type</span></code>:</dt>
<dd>The type of the polynomial. $*Default:* is kSos, but the user can
also use kSdsos and kDsos. Refer to NonnegativePolynomial for the
details on different type of sos polynomials.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">gram_name</span></code>:</dt>
<dd>The name of the gram matrix for print out.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It calls <code class="docutils literal notranslate"><span class="pre">Reparse</span></code> to enforce <code class="docutils literal notranslate"><span class="pre">p</span></code> to have this
MathematicalProgram’s indeterminates if necessary.</p>
</div>
<ol class="arabic simple" start="3">
<li>AddSosConstraint(self: pydrake.solvers.MathematicalProgram, e: pydrake.symbolic.Expression, monomial_basis: numpy.ndarray[object[m, 1]], type: pydrake.solvers.MathematicalProgram.NonnegativePolynomial = &lt;NonnegativePolynomial.kSos: 1&gt;, gram_name: str = ‘S’) -&gt; numpy.ndarray[object[m, n]]</li>
</ol>
<p>Adds constraints that a given symbolic expression <code class="docutils literal notranslate"><span class="pre">e</span></code> is a
sums-of-squares (SOS), that is, <code class="docutils literal notranslate"><span class="pre">p</span></code> can be decomposed into <code class="docutils literal notranslate"><span class="pre">mᵀQm</span></code>,
where m is the <code class="docutils literal notranslate"><span class="pre">monomial_basis</span></code>. Note that it decomposes <code class="docutils literal notranslate"><span class="pre">e</span></code> into
a polynomial with respect to <code class="docutils literal notranslate"><span class="pre">indeterminates()</span></code> in this mathematical
program. It returns the coefficients matrix Q, which is positive
semidefinite.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">type</span></code>:</dt>
<dd>Refer to NonnegativePolynomial class documentation.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">gram_name</span></code>:</dt>
<dd>The name of the gram matrix for print out.</dd>
</dl>
<ol class="arabic simple" start="4">
<li>AddSosConstraint(self: pydrake.solvers.MathematicalProgram, e: pydrake.symbolic.Expression, type: pydrake.solvers.MathematicalProgram.NonnegativePolynomial = &lt;NonnegativePolynomial.kSos: 1&gt;, gram_name: str = ‘S’) -&gt; Tuple[numpy.ndarray[object[m, n]], numpy.ndarray[object[m, 1]]]</li>
</ol>
<p>Adds constraints that a given symbolic expression <code class="docutils literal notranslate"><span class="pre">e</span></code> is a
sums-of-squares (SOS), that is, <code class="docutils literal notranslate"><span class="pre">e</span></code> can be decomposed into <code class="docutils literal notranslate"><span class="pre">mᵀQm</span></code>.
Note that it decomposes <code class="docutils literal notranslate"><span class="pre">e</span></code> into a polynomial with respect to
<code class="docutils literal notranslate"><span class="pre">indeterminates()</span></code> in this mathematical program. It returns a pair
expressing: - The coefficients matrix Q, which is positive
semidefinite. - The monomial basis m.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">type</span></code>:</dt>
<dd>Refer to NonnegativePolynomial class documentation.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">gram_name</span></code>:</dt>
<dd>The name of the gram matrix for print out.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.AddVisualizationCallback">
<code class="descname">AddVisualizationCallback</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram, arg0: Callable[[numpy.ndarray[numpy.float64[m, 1]]], None], arg1: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.Binding[VisualizationCallback]<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.AddVisualizationCallback" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a callback method to visualize intermediate results of the
optimization.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Just like other costs/constraints, not all solvers support
callbacks. Adding a callback here will force
MathematicalProgram::Solve to select a solver that support
callbacks. For instance, adding a visualization callback to a
quadratic programming problem may result in using a nonlinear
programming solver as the default solver.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">callback</span></code>:</dt>
<dd>a std::function that accepts an Eigen::Vector of doubles
representing the bound decision variables.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">vars</span></code>:</dt>
<dd>the decision variables that should be passed to the callback.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.bounding_box_constraints">
<code class="descname">bounding_box_constraints</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; List[pydrake.solvers.Binding[BoundingBoxConstraint]]<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.bounding_box_constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for all bounding box constraints</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.CheckSatisfied">
<code class="descname">CheckSatisfied</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.MathematicalProgram.CheckSatisfied" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>CheckSatisfied(self: pydrake.solvers.MathematicalProgram, binding: pydrake.solvers.Binding[Constraint], prog_var_vals: numpy.ndarray[numpy.float64[m, 1]], tol: float = 1e-06) -&gt; bool</li>
</ol>
<p>Evaluates CheckSatisfied for the constraint in <code class="docutils literal notranslate"><span class="pre">binding</span></code> using the
value of ALL of the decision variables in this program.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the size of <code class="docutils literal notranslate"><span class="pre">prog_var_vals</span></code> is invalid.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>CheckSatisfied(self: pydrake.solvers.MathematicalProgram, bindings: List[pydrake.solvers.Binding[Constraint]], prog_var_vals: numpy.ndarray[numpy.float64[m, 1]], tol: float = 1e-06) -&gt; bool</li>
</ol>
<p>Evaluates CheckSatisfied for the all of the constraints in <code class="docutils literal notranslate"><span class="pre">binding</span></code>
using the value of ALL of the decision variables in this program.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">true iff all of the constraints are satisfied.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the size of <code class="docutils literal notranslate"><span class="pre">prog_var_vals</span></code> is invalid.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.CheckSatisfiedAtInitialGuess">
<code class="descname">CheckSatisfiedAtInitialGuess</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.MathematicalProgram.CheckSatisfiedAtInitialGuess" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>CheckSatisfiedAtInitialGuess(self: pydrake.solvers.MathematicalProgram, binding: pydrake.solvers.Binding[Constraint], tol: float = 1e-06) -&gt; bool</li>
</ol>
<p>Evaluates CheckSatisfied for the constraint in <code class="docutils literal notranslate"><span class="pre">binding</span></code> at the
initial guess.</p>
<ol class="arabic simple" start="2">
<li>CheckSatisfiedAtInitialGuess(self: pydrake.solvers.MathematicalProgram, bindings: List[pydrake.solvers.Binding[Constraint]], tol: float = 1e-06) -&gt; bool</li>
</ol>
<p>Evaluates CheckSatisfied for the all of the constraints in
<code class="docutils literal notranslate"><span class="pre">bindings</span></code> at the initial guess.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">true iff all of the constraints are satisfied.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.ClearVariableScaling">
<code class="descname">ClearVariableScaling</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.ClearVariableScaling" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears the scaling factors for decision variables.</p>
<p>See variable_scaling “Variable scaling” for more information.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.Clone">
<code class="descname">Clone</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.MathematicalProgram<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.Clone" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.decision_variable">
<code class="descname">decision_variable</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em>, <em>i: int</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Variable<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.decision_variable" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for the decision variable with index <code class="docutils literal notranslate"><span class="pre">i</span></code> in the program.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.decision_variable_index">
<code class="descname">decision_variable_index</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; Dict[int, int]<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.decision_variable_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the mapping from a decision variable ID to its index in the
vector containing all the decision variables in the mathematical
program.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.decision_variables">
<code class="descname">decision_variables</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.decision_variables" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for all decision variables in the program.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.EvalBinding">
<code class="descname">EvalBinding</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.MathematicalProgram.EvalBinding" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>EvalBinding(self: pydrake.solvers.MathematicalProgram, binding: pydrake.solvers.Binding[EvaluatorBase], prog_var_vals: numpy.ndarray[numpy.float64[m, 1]]) -&gt; numpy.ndarray[numpy.float64[m, 1]]</li>
</ol>
<p>Evaluates the value of some binding, for some input value for all
decision variables.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">binding</span></code>:</dt>
<dd>A Binding whose variables are decision variables in this program.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">prog_var_vals</span></code>:</dt>
<dd>The value of all the decision variables in this program.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the size of <code class="docutils literal notranslate"><span class="pre">prog_var_vals</span></code> is invalid.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>EvalBinding(self: pydrake.solvers.MathematicalProgram, binding: pydrake.solvers.Binding[EvaluatorBase], prog_var_vals: numpy.ndarray[object[m, 1]]) -&gt; numpy.ndarray[object[m, 1]]</li>
</ol>
<p>Evaluates the value of some binding, for some input value for all
decision variables.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">binding</span></code>:</dt>
<dd>A Binding whose variables are decision variables in this program.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">prog_var_vals</span></code>:</dt>
<dd>The value of all the decision variables in this program.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the size of <code class="docutils literal notranslate"><span class="pre">prog_var_vals</span></code> is invalid.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.EvalBindings">
<code class="descname">EvalBindings</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.MathematicalProgram.EvalBindings" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>EvalBindings(self: pydrake.solvers.MathematicalProgram, bindings: List[pydrake.solvers.Binding[EvaluatorBase]], prog_var_vals: numpy.ndarray[numpy.float64[m, 1]]) -&gt; numpy.ndarray[numpy.float64[m, 1]]</li>
</ol>
<p>Evaluates a set of bindings (plural version of <code class="docutils literal notranslate"><span class="pre">EvalBinding</span></code>).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">bindings</span></code>:</dt>
<dd>List of bindings.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">prog</span></code>:</dt>
<dd>$Parameter <code class="docutils literal notranslate"><span class="pre">prog_var_vals</span></code>:</dd>
</dl>
<p>The value of all the decision variables in this program.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">All binding values, concatenated into a single vector.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the size of <code class="docutils literal notranslate"><span class="pre">prog_var_vals</span></code> is invalid.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>EvalBindings(self: pydrake.solvers.MathematicalProgram, bindings: List[pydrake.solvers.Binding[EvaluatorBase]], prog_var_vals: numpy.ndarray[object[m, 1]]) -&gt; numpy.ndarray[object[m, 1]]</li>
</ol>
<p>Evaluates a set of bindings (plural version of <code class="docutils literal notranslate"><span class="pre">EvalBinding</span></code>).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">bindings</span></code>:</dt>
<dd>List of bindings.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">prog</span></code>:</dt>
<dd>$Parameter <code class="docutils literal notranslate"><span class="pre">prog_var_vals</span></code>:</dd>
</dl>
<p>The value of all the decision variables in this program.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">All binding values, concatenated into a single vector.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the size of <code class="docutils literal notranslate"><span class="pre">prog_var_vals</span></code> is invalid.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.EvalBindingVectorized">
<code class="descname">EvalBindingVectorized</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram, binding: pydrake.solvers.Binding[EvaluatorBase], prog_var_vals: numpy.ndarray[numpy.float64[m, n]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, n]]<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.EvalBindingVectorized" title="Permalink to this definition">¶</a></dt>
<dd><p>A “vectorized” version of EvalBinding.  It evaluates the binding
for every column of <code class="docutils literal notranslate"><span class="pre">prog_var_vals</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.exponential_cone_constraints">
<code class="descname">exponential_cone_constraints</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; List[pydrake.solvers.Binding[ExponentialConeConstraint]]<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.exponential_cone_constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for exponential cone constraints.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.FindDecisionVariableIndex">
<code class="descname">FindDecisionVariableIndex</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em>, <em>var: pydrake.symbolic.Variable</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.FindDecisionVariableIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index of the decision variable. Internally the solvers
thinks all variables are stored in an array, and it accesses each
individual variable using its index. This index is used when adding
constraints and costs for each solver.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>{<code class="docutils literal notranslate"><span class="pre">var</span></code> is a decision variable in the mathematical program,
otherwise this function throws a runtime error.}</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.FindDecisionVariableIndices">
<code class="descname">FindDecisionVariableIndices</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram, vars: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; List[int]<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.FindDecisionVariableIndices" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the indices of the decision variables. Internally the solvers
thinks all variables are stored in an array, and it accesses each
individual variable using its index. This index is used when adding
constraints and costs for each solver.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>{<code class="docutils literal notranslate"><span class="pre">vars</span></code> are decision variables in the mathematical program,
otherwise this function throws a runtime error.}</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.FindIndeterminateIndex">
<code class="descname">FindIndeterminateIndex</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em>, <em>var: pydrake.symbolic.Variable</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.FindIndeterminateIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index of the indeterminate. Internally a solver thinks all
indeterminates are stored in an array, and it accesses each individual
indeterminate using its index. This index is used when adding
constraints and costs for each solver.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">var</span></code> is a indeterminate in the mathematical program, otherwise
this function throws a runtime error.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.generic_constraints">
<code class="descname">generic_constraints</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; List[pydrake.solvers.Binding[Constraint]]<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.generic_constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for all generic constraints</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.generic_costs">
<code class="descname">generic_costs</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; List[pydrake.solvers.Binding[Cost]]<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.generic_costs" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for all generic costs.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.GetAllConstraints">
<code class="descname">GetAllConstraints</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; List[pydrake.solvers.Binding[Constraint]]<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.GetAllConstraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for returning all constraints.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Vector of all constraint bindings.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The group ordering may change as more constraint types are added.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.GetAllCosts">
<code class="descname">GetAllCosts</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; List[pydrake.solvers.Binding[Cost]]<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.GetAllCosts" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter returning all costs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Vector of all cost bindings.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The group ordering may change as more cost types are added.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.GetBindingVariableValues">
<code class="descname">GetBindingVariableValues</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram, binding: pydrake.solvers.Binding[EvaluatorBase], prog_var_vals: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.GetBindingVariableValues" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the value of all decision variables, namely
this.decision_variable(i) takes the value prog_var_vals(i), returns
the vector that contains the value of the variables in
binding.variables().</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">binding</span></code>:</dt>
<dd>binding.variables() must be decision variables in this
MathematicalProgram.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">prog_var_vals</span></code>:</dt>
<dd>The value of ALL the decision variables in this program.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">binding_variable_vals binding_variable_vals(i) is the value of
binding.variables()(i) in prog_var_vals.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.GetInitialGuess">
<code class="descname">GetInitialGuess</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.MathematicalProgram.GetInitialGuess" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>GetInitialGuess(self: pydrake.solvers.MathematicalProgram, arg0: pydrake.symbolic.Variable) -&gt; float</li>
</ol>
<p>Gets the initial guess for a single variable.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">decision_variable</span></code> has been registered in the optimization
program.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the pre condition is not satisfied.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>GetInitialGuess(self: pydrake.solvers.MathematicalProgram, arg0: numpy.ndarray[object[m, 1]]) -&gt; numpy.ndarray[numpy.float64[m, 1]]</li>
</ol>
<p>Gets the initial guess for some variables.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>Each variable in <code class="docutils literal notranslate"><span class="pre">decision_variable_mat</span></code> has been registered in
the optimization program.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the pre condition is not satisfied.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="3">
<li>GetInitialGuess(self: pydrake.solvers.MathematicalProgram, arg0: numpy.ndarray[object[m, n]]) -&gt; numpy.ndarray[numpy.float64[m, n]]</li>
</ol>
<p>Gets the initial guess for some variables.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>Each variable in <code class="docutils literal notranslate"><span class="pre">decision_variable_mat</span></code> has been registered in
the optimization program.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the pre condition is not satisfied.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.GetLinearConstraints">
<code class="descname">GetLinearConstraints</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; List[pydrake.solvers.Binding[LinearConstraint]]<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.GetLinearConstraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter returning all linear constraints (both linear equality and
inequality constraints).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Vector of all linear constraint bindings.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.GetSolverOptions">
<code class="descname">GetSolverOptions</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.MathematicalProgram.GetSolverOptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>GetSolverOptions(self: pydrake.solvers.MathematicalProgram, arg0: pydrake.solvers.SolverId) -&gt; dict</li>
<li>GetSolverOptions(self: pydrake.solvers.MathematicalProgram, arg0: pydrake.solvers.SolverType) -&gt; dict</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.GetVariableScaling">
<code class="descname">GetVariableScaling</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; Dict[int, float]<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.GetVariableScaling" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the mapping from a decision variable index to its scaling
factor.</p>
<p>See variable_scaling “Variable scaling” for more information.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.indeterminate">
<code class="descname">indeterminate</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em>, <em>i: int</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Variable<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.indeterminate" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for the indeterminate with index <code class="docutils literal notranslate"><span class="pre">i</span></code> in the program.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.indeterminates">
<code class="descname">indeterminates</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.indeterminates" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for all indeterminates in the program.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.indeterminates_index">
<code class="descname">indeterminates_index</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; Dict[int, int]<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.indeterminates_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the mapping from an indeterminate ID to its index in the
vector containing all the indeterminates in the mathematical program.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.initial_guess">
<code class="descname">initial_guess</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.initial_guess" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for the initial guess</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.l2norm_costs">
<code class="descname">l2norm_costs</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; List[pydrake.solvers.Binding[L2NormCost]]<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.l2norm_costs" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for l2norm costs.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.linear_complementarity_constraints">
<code class="descname">linear_complementarity_constraints</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; List[pydrake.solvers.Binding[LinearComplementarityConstraint]]<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.linear_complementarity_constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for all linear complementarity constraints.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.linear_constraints">
<code class="descname">linear_constraints</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; List[pydrake.solvers.Binding[LinearConstraint]]<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.linear_constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for linear constraints.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.linear_costs">
<code class="descname">linear_costs</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; List[pydrake.solvers.Binding[LinearCost]]<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.linear_costs" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for linear costs.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.linear_equality_constraints">
<code class="descname">linear_equality_constraints</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; List[pydrake.solvers.Binding[LinearEqualityConstraint]]<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.linear_equality_constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for linear equality constraints.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.linear_matrix_inequality_constraints">
<code class="descname">linear_matrix_inequality_constraints</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; List[pydrake.solvers.Binding[LinearMatrixInequalityConstraint]]<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.linear_matrix_inequality_constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for linear matrix inequality constraints.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.lorentz_cone_constraints">
<code class="descname">lorentz_cone_constraints</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; List[pydrake.solvers.Binding[LorentzConeConstraint]]<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.lorentz_cone_constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for Lorentz cone constraints.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.MakePolynomial">
<code class="descname">MakePolynomial</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em>, <em>e: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Polynomial<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.MakePolynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a symbolic polynomial from the given expression <code class="docutils literal notranslate"><span class="pre">e</span></code>. It uses
this MathematicalProgram’s <code class="docutils literal notranslate"><span class="pre">indeterminates()</span></code> in constructing the
polynomial.</p>
<p>This method helps a user create a polynomial with the right set of
indeterminates which are declared in this MathematicalProgram. We
recommend users to use this method over an explicit call to Polynomial
constructors to avoid a possible mismatch between this
MathematicalProgram’s indeterminates and the user-specified
indeterminates (or unspecified, which then includes all symbolic
variables in the expression <code class="docutils literal notranslate"><span class="pre">e</span></code>). Consider the following example.</p>
<p>e = ax + bx + c</p>
<p>MP.indeterminates() = {x} MP.decision_variables() = {a, b}</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">MP.MakePolynomial(e)</span></code> create a polynomial, <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">+</span> <span class="pre">b)x</span> <span class="pre">+</span> <span class="pre">c</span></code>.  Here only
<code class="docutils literal notranslate"><span class="pre">x</span></code> is an indeterminate of this polynomial.</li>
<li>In contrast, <code class="docutils literal notranslate"><span class="pre">symbolic::Polynomial(e)</span></code> returns <code class="docutils literal notranslate"><span class="pre">ax</span> <span class="pre">+</span> <span class="pre">bx</span> <span class="pre">+</span> <span class="pre">c</span></code> where all
variables <code class="docutils literal notranslate"><span class="pre">{a,</span> <span class="pre">b,</span> <span class="pre">x}</span></code> are indeterminates. Note that this is problematic
as its indeterminates, <code class="docutils literal notranslate"><span class="pre">{a,</span> <span class="pre">b,</span> <span class="pre">x}</span></code> and the MathematicalProgram’s decision
variables, <code class="docutils literal notranslate"><span class="pre">{a,</span> <span class="pre">b}</span></code> overlap.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This function does not require that the decision variables in
<code class="docutils literal notranslate"><span class="pre">e</span></code> is a subset of the decision variables in
MathematicalProgram.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.NewBinaryVariables">
<code class="descname">NewBinaryVariables</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.MathematicalProgram.NewBinaryVariables" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>NewBinaryVariables(self: pydrake.solvers.MathematicalProgram, rows: int, name: str = ‘b’) -&gt; numpy.ndarray[object[m, 1]]</li>
</ol>
<p>Adds binary variables to this MathematicalProgram. The new variables
are viewed as a column vector, with size <code class="docutils literal notranslate"><span class="pre">rows</span></code> x 1.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">NewBinaryVariables(int rows, int cols, const
std::vector&lt;std::string&gt;&amp; names);</p>
</div>
<ol class="arabic simple" start="2">
<li>NewBinaryVariables(self: pydrake.solvers.MathematicalProgram, rows: int, cols: int, name: str = ‘b’) -&gt; numpy.ndarray[object[m, n]]</li>
</ol>
<p>Adds binary variables, appending them to an internal vector of any
existing vars. The initial guess values for the new variables are set
to NaN, to indicate that an initial guess has not been assigned.
Callers are expected to add costs and/or constraints to have any
effect during optimization. Callers can also set the initial guess of
the decision variables through SetInitialGuess() or
SetInitialGuessForAllVariables().</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">Rows</span></code>:</dt>
<dd>The number of rows in the new variables.</dd>
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">Cols</span></code>:</dt>
<dd>The number of columns in the new variables.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rows</span></code>:</dt>
<dd>The number of rows in the new variables.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">cols</span></code>:</dt>
<dd>The number of columns in the new variables.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt>
<dd>The commonly shared name of the new variables.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The MatrixDecisionVariable of size rows x cols, containing the new
vars (not all the vars stored).</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MathematicalProgram</span> <span class="n">prog</span><span class="p">;</span>
<span class="n">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">NewBinaryVariables</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>This adds a 2 x 3 matrix decision variables into the program.</p>
<p>The name of the variable is only used for the user in order to ease
readability.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.NewContinuousVariables">
<code class="descname">NewContinuousVariables</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.MathematicalProgram.NewContinuousVariables" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>NewContinuousVariables(self: pydrake.solvers.MathematicalProgram, rows: int, name: str = ‘x’) -&gt; numpy.ndarray[object[m, 1]]</li>
</ol>
<p>Adds continuous variables, appending them to an internal vector of any
existing vars. The initial guess values for the new variables are set
to NaN, to indicate that an initial guess has not been assigned.
Callers are expected to add costs and/or constraints to have any
effect during optimization. Callers can also set the initial guess of
the decision variables through SetInitialGuess() or
SetInitialGuessForAllVariables().</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rows</span></code>:</dt>
<dd>The number of rows in the new variables.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt>
<dd>The name of the newly added variables</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The VectorDecisionVariable of size rows x 1, containing the new
vars (not all the vars stored).</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MathematicalProgram</span> <span class="n">prog</span><span class="p">;</span>
<span class="n">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">NewContinuousVariables</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>This adds a 2 x 1 vector containing decision variables into the
program. The names of the variables are “x(0)” and “x(1)”.</p>
<p>The name of the variable is only used for the user in order to ease
readability.</p>
<ol class="arabic simple" start="2">
<li>NewContinuousVariables(self: pydrake.solvers.MathematicalProgram, rows: int, cols: int, name: str = ‘x’) -&gt; numpy.ndarray[object[m, n]]</li>
</ol>
<p>Adds continuous variables, appending them to an internal vector of any
existing vars. The initial guess values for the new variables are set
to NaN, to indicate that an initial guess has not been assigned.
Callers are expected to add costs and/or constraints to have any
effect during optimization. Callers can also set the initial guess of
the decision variables through SetInitialGuess() or
SetInitialGuessForAllVariables().</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">Rows</span></code>:</dt>
<dd>The number of rows of the new variables, in the compile time.</dd>
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">Cols</span></code>:</dt>
<dd>The number of columns of the new variables, in the compile time.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rows</span></code>:</dt>
<dd>The number of rows in the new variables. When Rows is not
Eigen::Dynamic, rows is ignored.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">cols</span></code>:</dt>
<dd>The number of columns in the new variables. When Cols is not
Eigen::Dynamic, cols is ignored.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt>
<dd>All variables will share the same name, but different index.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The MatrixDecisionVariable of size Rows x Cols, containing the new
vars (not all the vars stored).</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MathematicalProgram</span> <span class="n">prog</span><span class="p">;</span>
<span class="n">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">NewContinuousVariables</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">);</span>
<span class="n">auto</span> <span class="n">y</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">NewContinuousVariables</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;X&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>This adds a 2 x 3 matrix decision variables into the program.</p>
<p>The name of the variable is only used for the user in order to ease
readability.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.NewEvenDegreeDsosPolynomial">
<code class="descname">NewEvenDegreeDsosPolynomial</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em>, <em>indeterminates: pydrake.symbolic.Variables</em>, <em>degree: int</em><span class="sig-paren">)</span> &#x2192; Tuple[pydrake.symbolic.Polynomial, numpy.ndarray[object[m, n]], numpy.ndarray[object[m, n]]]<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.NewEvenDegreeDsosPolynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>see even_degree_nonnegative_polynomial for details. Variant that
produces a DSOS polynomial. Same as NewEvenDegreeSosPolynomial, except
the returned polynomial is diagonally dominant sum of squares (dsos).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.NewEvenDegreeFreePolynomial">
<code class="descname">NewEvenDegreeFreePolynomial</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em>, <em>indeterminates: pydrake.symbolic.Variables</em>, <em>degree: int</em>, <em>coeff_name: str = 'a'</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Polynomial<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.NewEvenDegreeFreePolynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a free polynomial that only contains even degree monomials. A
monomial is even degree if its total degree (sum of all variables’
degree) is even. For example, xy is an even degree monomial (degree 2)
while x²y is not (degree 3).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">indeterminates</span></code>:</dt>
<dd>The monomial basis is over these indeterminates.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">degree</span></code>:</dt>
<dd>The highest degree of the polynomial.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">coeff_name</span></code>:</dt>
<dd>The coefficients of the polynomial are decision variables with
this name as a base. The variable name would be “a1”, “a2”, etc.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.NewEvenDegreeNonnegativePolynomial">
<code class="descname">NewEvenDegreeNonnegativePolynomial</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em>, <em>indeterminates: pydrake.symbolic.Variables</em>, <em>degree: int</em>, <em>type: pydrake.solvers.MathematicalProgram.NonnegativePolynomial</em><span class="sig-paren">)</span> &#x2192; Tuple[pydrake.symbolic.Polynomial, numpy.ndarray[object[m, n]], numpy.ndarray[object[m, n]]]<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.NewEvenDegreeNonnegativePolynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>See even_degree_nonnegative_polynomial for more details. Variant that
produces different non-negative polynomials depending on <code class="docutils literal notranslate"><span class="pre">type</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">type</span></code>:</dt>
<dd>The returned polynomial p(x) can be either SOS, SDSOS or DSOS,
depending on <code class="docutils literal notranslate"><span class="pre">type</span></code>.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.NewEvenDegreeSdsosPolynomial">
<code class="descname">NewEvenDegreeSdsosPolynomial</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em>, <em>indeterminates: pydrake.symbolic.Variables</em>, <em>degree: int</em><span class="sig-paren">)</span> &#x2192; Tuple[pydrake.symbolic.Polynomial, numpy.ndarray[object[m, n]], numpy.ndarray[object[m, n]]]<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.NewEvenDegreeSdsosPolynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>see even_degree_nonnegative_polynomial for details. Variant that
produces an SDSOS polynomial.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.NewEvenDegreeSosPolynomial">
<code class="descname">NewEvenDegreeSosPolynomial</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em>, <em>indeterminates: pydrake.symbolic.Variables</em>, <em>degree: int</em><span class="sig-paren">)</span> &#x2192; Tuple[pydrake.symbolic.Polynomial, numpy.ndarray[object[m, n]], numpy.ndarray[object[m, n]]]<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.NewEvenDegreeSosPolynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>See even_degree_nonnegative_polynomial for more details. Variant that
produces a SOS polynomial.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.NewFreePolynomial">
<code class="descname">NewFreePolynomial</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em>, <em>indeterminates: pydrake.symbolic.Variables</em>, <em>deg: int</em>, <em>coeff_name: str = 'a'</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Polynomial<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.NewFreePolynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a free polynomial in a monomial basis over <code class="docutils literal notranslate"><span class="pre">indeterminates</span></code>
of a given <code class="docutils literal notranslate"><span class="pre">degree</span></code>. It uses <code class="docutils literal notranslate"><span class="pre">coeff_name</span></code> to make new decision
variables and use them as coefficients. For example,
<code class="docutils literal notranslate"><span class="pre">NewFreePolynomial({x₀,</span> <span class="pre">x₁},</span> <span class="pre">2)</span></code> returns a₀x₁² + a₁x₀x₁ + a₂x₀² +
a₃x₁ + a₄x₀ + a₅.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.NewIndeterminates">
<code class="descname">NewIndeterminates</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.MathematicalProgram.NewIndeterminates" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>NewIndeterminates(self: pydrake.solvers.MathematicalProgram, rows: int, name: str = ‘x’) -&gt; numpy.ndarray[object[m, 1]]</li>
</ol>
<p>Adds indeterminates to this MathematicalProgram, with default name
“x”.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">NewIndeterminates(int rows, int cols, const
std::vector&lt;std::string&gt;&amp; names);</p>
</div>
<ol class="arabic simple" start="2">
<li>NewIndeterminates(self: pydrake.solvers.MathematicalProgram, rows: int, cols: int, name: str = ‘X’) -&gt; numpy.ndarray[object[m, n]]</li>
</ol>
<p>Adds indeterminates to this MathematicalProgram, with default name
“X”. The new variables are returned and viewed as a matrix, with size
<code class="docutils literal notranslate"><span class="pre">rows</span></code> x <code class="docutils literal notranslate"><span class="pre">cols</span></code>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">NewIndeterminates(int rows, int cols, const
std::vector&lt;std::string&gt;&amp; names);</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.NewOddDegreeFreePolynomial">
<code class="descname">NewOddDegreeFreePolynomial</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em>, <em>indeterminates: pydrake.symbolic.Variables</em>, <em>degree: int</em>, <em>coeff_name: str = 'a'</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Polynomial<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.NewOddDegreeFreePolynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a free polynomial that only contains odd degree monomials. A
monomial is odd degree if its total degree (sum of all variables’
degree) is even. For example, xy is not an odd degree monomial (degree
2) while x²y is (degree 3).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">indeterminates</span></code>:</dt>
<dd>The monomial basis is over these indeterminates.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">degree</span></code>:</dt>
<dd>The highest degree of the polynomial.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">coeff_name</span></code>:</dt>
<dd>The coefficients of the polynomial are decision variables with
this name as a base. The variable name would be “a1”, “a2”, etc.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.NewSosPolynomial">
<code class="descname">NewSosPolynomial</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.MathematicalProgram.NewSosPolynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>NewSosPolynomial(self: pydrake.solvers.MathematicalProgram, monomial_basis: numpy.ndarray[object[m, 1]], type: pydrake.solvers.MathematicalProgram.NonnegativePolynomial = &lt;NonnegativePolynomial.kSos: 1&gt;, gram_name: str = ‘S’) -&gt; Tuple[pydrake.symbolic.Polynomial, numpy.ndarray[object[m, n]]]</li>
</ol>
<p>Returns a pair of a SOS polynomial p = mᵀQm and the Gramian matrix Q,
where m is the <code class="docutils literal notranslate"><span class="pre">monomial</span></code> basis. For example,
<code class="docutils literal notranslate"><span class="pre">NewSosPolynomial(Vector2&lt;Monomial&gt;{x,y})</span></code> returns a polynomial p =
Q₍₀,₀₎x² + 2Q₍₁,₀₎xy + Q₍₁,₁₎y² and Q. Depending on the type of the
polynomial, we will impose different constraint on the polynomial. -
if type = kSos, we impose the polynomial being SOS. - if type =
kSdsos, we impose the polynomial being SDSOS. - if type = kDsos, we
impose the polynomial being DSOS.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">gram_name</span></code>:</dt>
<dd>The name of the gram matrix for print out.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Q is a symmetric monomial_basis.rows() x monomial_basis.rows()
matrix.</p>
</div>
<ol class="arabic simple" start="2">
<li>NewSosPolynomial(self: pydrake.solvers.MathematicalProgram, gramian: numpy.ndarray[object[m, n], flags.f_contiguous], monomial_basis: numpy.ndarray[object[m, 1]], type: pydrake.solvers.MathematicalProgram.NonnegativePolynomial = &lt;NonnegativePolynomial.kSos: 1&gt;) -&gt; pydrake.symbolic.Polynomial</li>
</ol>
<p>Overloads NewSosPolynomial, except the Gramian matrix Q is an input
instead of an output.</p>
<ol class="arabic simple" start="3">
<li>NewSosPolynomial(self: pydrake.solvers.MathematicalProgram, indeterminates: pydrake.symbolic.Variables, degree: int, type: pydrake.solvers.MathematicalProgram.NonnegativePolynomial = &lt;NonnegativePolynomial.kSos: 1&gt;, gram_name: str = ‘S’) -&gt; Tuple[pydrake.symbolic.Polynomial, numpy.ndarray[object[m, n]]]</li>
</ol>
<p>Overloads NewSosPolynomial. Returns a pair of a SOS polynomial p =
m(x)ᵀQm(x) of degree <code class="docutils literal notranslate"><span class="pre">degree</span></code> and the Gramian matrix Q that should
be PSD, where m(x) is the result of calling
<code class="docutils literal notranslate"><span class="pre">MonomialBasis(indeterminates,</span> <span class="pre">degree/2)</span></code>. For example,
<code class="docutils literal notranslate"><span class="pre">NewSosPolynomial({x},</span> <span class="pre">4)</span></code> returns a pair of a polynomial p =
Q₍₀,₀₎x⁴ + 2Q₍₁,₀₎ x³ + (2Q₍₂,₀₎ + Q₍₁,₁₎)x² + 2Q₍₂,₁₎x + Q₍₂,₂₎ and
Q.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">type</span></code>:</dt>
<dd>Depending on the type of the polynomial, we will impose different
constraint on the polynomial. - if type = kSos, we impose the
polynomial being SOS. - if type = kSdsos, we impose the polynomial
being SDSOS. - if type = kDsos, we impose the polynomial being
DSOS.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">gram_name</span></code>:</dt>
<dd>The name of the gram matrix for print out.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal notranslate"><span class="pre">degree</span></code> is not a positive even integer.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">MonomialBasis.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.NewSymmetricContinuousVariables">
<code class="descname">NewSymmetricContinuousVariables</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em>, <em>rows: int</em>, <em>name: str = 'Symmetric'</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, n]]<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.NewSymmetricContinuousVariables" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a runtime sized symmetric matrix as decision variables to this
MathematicalProgram. The optimization will only use the stacked
columns of the lower triangular part of the symmetric matrix as
decision variables.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rows</span></code>:</dt>
<dd>The number of rows in the symmetric matrix.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt>
<dd>The name of the matrix. It is only used the for user to understand
the optimization program. The default name is “Symmetric”, and
each variable will be named as</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Symmetric</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>     <span class="n">Symmetric</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>     <span class="o">...</span> <span class="n">Symmetric</span><span class="p">(</span><span class="n">rows</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">Symmetric</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>     <span class="n">Symmetric</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>     <span class="o">...</span> <span class="n">Symmetric</span><span class="p">(</span><span class="n">rows</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
           <span class="o">...</span>
<span class="n">Symmetric</span><span class="p">(</span><span class="n">rows</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="n">Symmetric</span><span class="p">(</span><span class="n">rows</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">...</span> <span class="n">Symmetric</span><span class="p">(</span><span class="n">rows</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">rows</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Notice that the (i,j)’th entry and (j,i)’th entry has the same name.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The newly added decision variables.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.MathematicalProgram.NonnegativePolynomial">
<em class="property">class </em><code class="descname">NonnegativePolynomial</code><a class="headerlink" href="#pydrake.solvers.MathematicalProgram.NonnegativePolynomial" title="Permalink to this definition">¶</a></dt>
<dd><p>Types of non-negative polynomial that can be found through conic
optimization. We currently support SOS, SDSOS and DSOS. For more
information about these polynomial types, please refer to “DSOS and
SDSOS Optimization: More Tractable Alternatives to Sum of Squares and
Semidefinite Optimization” by Amir Ali Ahmadi and Anirudha Majumdar,
with arXiv link <a class="reference external" href="https://arxiv.org/abs/1706.02586">https://arxiv.org/abs/1706.02586</a></p>
<p>Members:</p>
<blockquote>
<div><p>kSos : A sum-of-squares polynomial.</p>
<p>kSdsos : A scaled-diagonally dominant sum-of-squares polynomial.</p>
<p>kDsos : A diagonally dominant sum-of-squares polynomial.</p>
</div></blockquote>
<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.NonnegativePolynomial.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram.NonnegativePolynomial</em>, <em>value: int</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.NonnegativePolynomial.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.MathematicalProgram.NonnegativePolynomial.kDsos">
<code class="descname">kDsos</code><em class="property"> = &lt;NonnegativePolynomial.kDsos: 3&gt;</em><a class="headerlink" href="#pydrake.solvers.MathematicalProgram.NonnegativePolynomial.kDsos" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.MathematicalProgram.NonnegativePolynomial.kSdsos">
<code class="descname">kSdsos</code><em class="property"> = &lt;NonnegativePolynomial.kSdsos: 2&gt;</em><a class="headerlink" href="#pydrake.solvers.MathematicalProgram.NonnegativePolynomial.kSdsos" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.MathematicalProgram.NonnegativePolynomial.kSos">
<code class="descname">kSos</code><em class="property"> = &lt;NonnegativePolynomial.kSos: 1&gt;</em><a class="headerlink" href="#pydrake.solvers.MathematicalProgram.NonnegativePolynomial.kSos" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.MathematicalProgram.NonnegativePolynomial.name">
<code class="descname">name</code><a class="headerlink" href="#pydrake.solvers.MathematicalProgram.NonnegativePolynomial.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.MathematicalProgram.NonnegativePolynomial.value">
<code class="descname">value</code><a class="headerlink" href="#pydrake.solvers.MathematicalProgram.NonnegativePolynomial.value" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.num_indeterminates">
<code class="descname">num_indeterminates</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.num_indeterminates" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the number of indeterminates in the optimization program</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.num_vars">
<code class="descname">num_vars</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.num_vars" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for number of variables in the optimization program</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.positive_semidefinite_constraints">
<code class="descname">positive_semidefinite_constraints</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; List[pydrake.solvers.Binding[PositiveSemidefiniteConstraint]]<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.positive_semidefinite_constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for positive semidefinite constraints.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.quadratic_costs">
<code class="descname">quadratic_costs</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; List[pydrake.solvers.Binding[QuadraticCost]]<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.quadratic_costs" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for quadratic costs.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.RemoveConstraint">
<code class="descname">RemoveConstraint</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram, constraint: pydrake.solvers.Binding[Constraint]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.RemoveConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes <code class="docutils literal notranslate"><span class="pre">constraint</span></code> from this mathematical program. See
remove_cost_constraint “Remove costs or constraints” for more details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">number of constraint objects removed from this program. If this
program doesn’t contain <code class="docutils literal notranslate"><span class="pre">constraint</span></code>, then returns 0. If this
program contains multiple <code class="docutils literal notranslate"><span class="pre">constraint</span></code> objects, then returns the
repetition of <code class="docutils literal notranslate"><span class="pre">constraint</span></code> in this program.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.RemoveCost">
<code class="descname">RemoveCost</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram, cost: pydrake.solvers.Binding[Cost]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.RemoveCost" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes <code class="docutils literal notranslate"><span class="pre">cost</span></code> from this mathematical program. See
remove_cost_constraint “Remove costs or constraints” for more details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">number of cost objects removed from this program. If this program
doesn’t contain <code class="docutils literal notranslate"><span class="pre">cost</span></code>, then returns 0. If this program contains
multiple <code class="docutils literal notranslate"><span class="pre">cost</span></code> objects, then returns the repetition of <code class="docutils literal notranslate"><span class="pre">cost</span></code>
in this program.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.Reparse">
<code class="descname">Reparse</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em>, <em>p: pydrake.symbolic.Polynomial</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.Reparse" title="Permalink to this definition">¶</a></dt>
<dd><p>Reparses the polynomial <code class="docutils literal notranslate"><span class="pre">p</span></code> using this MathematicalProgram’s
indeterminates.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.rotated_lorentz_cone_constraints">
<code class="descname">rotated_lorentz_cone_constraints</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; List[pydrake.solvers.Binding[RotatedLorentzConeConstraint]]<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.rotated_lorentz_cone_constraints" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for rotated Lorentz cone constraints.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.SetDecisionVariableValueInVector">
<code class="descname">SetDecisionVariableValueInVector</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.MathematicalProgram.SetDecisionVariableValueInVector" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>SetDecisionVariableValueInVector(self: pydrake.solvers.MathematicalProgram, decision_variable: pydrake.symbolic.Variable, decision_variable_new_value: float, values: Optional[numpy.ndarray[numpy.float64[m, 1], flags.writeable]]) -&gt; None</li>
</ol>
<p>Updates the value of a single <code class="docutils literal notranslate"><span class="pre">decision_variable</span></code> inside the
<code class="docutils literal notranslate"><span class="pre">values</span></code> vector to be <code class="docutils literal notranslate"><span class="pre">decision_variable_new_value</span></code>. The other
decision variables’ values in <code class="docutils literal notranslate"><span class="pre">values</span></code> are unchanged.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">decision_variable</span></code>:</dt>
<dd>a registered decision variable in this program.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">decision_variable_new_value</span></code>:</dt>
<dd>the variable’s new values.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">values</span></code>:</dt>
<dd>The vector to be tweaked; must be of size num_vars().</dd>
</dl>
<ol class="arabic simple" start="2">
<li>SetDecisionVariableValueInVector(self: pydrake.solvers.MathematicalProgram, decision_variables: numpy.ndarray[object[m, n], flags.f_contiguous], decision_variables_new_values: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], values: Optional[numpy.ndarray[numpy.float64[m, 1], flags.writeable]]) -&gt; None</li>
</ol>
<p>Updates the values of some <code class="docutils literal notranslate"><span class="pre">decision_variables</span></code> inside the
<code class="docutils literal notranslate"><span class="pre">values</span></code> vector to be <code class="docutils literal notranslate"><span class="pre">decision_variables_new_values</span></code>. The other
decision variables’ values in <code class="docutils literal notranslate"><span class="pre">values</span></code> are unchanged.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">decision_variables</span></code>:</dt>
<dd>registered decision variables in this program.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">decision_variables_new_values</span></code>:</dt>
<dd>the variables’ respective new values; must have the same rows()
and cols() sizes and <code class="docutils literal notranslate"><span class="pre">decision_variables</span></code>.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">values</span></code>:</dt>
<dd>The vector to be tweaked; must be of size num_vars().</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.SetInitialGuess">
<code class="descname">SetInitialGuess</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.MathematicalProgram.SetInitialGuess" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>SetInitialGuess(self: pydrake.solvers.MathematicalProgram, arg0: pydrake.symbolic.Variable, arg1: float) -&gt; None</li>
</ol>
<p>Sets the initial guess for a single variable <code class="docutils literal notranslate"><span class="pre">decision_variable</span></code>.
The guess is stored as part of this program.</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>decision_variable is a registered decision variable in the
program.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if precondition is not satisfied.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>SetInitialGuess(self: pydrake.solvers.MathematicalProgram, arg0: numpy.ndarray[object[m, n]], arg1: numpy.ndarray[numpy.float64[m, n]]) -&gt; None</li>
</ol>
<p>Sets the initial guess for the decision variables stored in
<code class="docutils literal notranslate"><span class="pre">decision_variable_mat</span></code> to be <code class="docutils literal notranslate"><span class="pre">x0</span></code>. The guess is stored as part of
this program.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.SetInitialGuessForAllVariables">
<code class="descname">SetInitialGuessForAllVariables</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram, arg0: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.SetInitialGuessForAllVariables" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the initial guess for ALL decision variables. Note that variables
begin with a default initial guess of NaN to indicate that no guess is
available.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">x0</span></code>:</dt>
<dd>A vector of appropriate size (num_vars() x 1).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.SetSolverOption">
<code class="descname">SetSolverOption</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.MathematicalProgram.SetSolverOption" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>SetSolverOption(self: pydrake.solvers.MathematicalProgram, solver_id: pydrake.solvers.SolverId, solver_option: str, option_value: float) -&gt; None</li>
</ol>
<p>See set_solver_option for more details. Set the double-valued options.</p>
<ol class="arabic simple" start="2">
<li>SetSolverOption(self: pydrake.solvers.MathematicalProgram, solver_id: pydrake.solvers.SolverId, solver_option: str, option_value: int) -&gt; None</li>
</ol>
<p>See set_solver_option for more details. Set the integer-valued
options.</p>
<ol class="arabic simple" start="3">
<li>SetSolverOption(self: pydrake.solvers.MathematicalProgram, solver_id: pydrake.solvers.SolverId, solver_option: str, option_value: str) -&gt; None</li>
</ol>
<p>See set_solver_option for more details. Set the string-valued options.</p>
<ol class="arabic simple" start="4">
<li>SetSolverOption(self: pydrake.solvers.MathematicalProgram, arg0: pydrake.solvers.SolverType, arg1: str, arg2: float) -&gt; None</li>
</ol>
<p>See set_solver_option for more details. Set the double-valued options.</p>
<ol class="arabic simple" start="5">
<li>SetSolverOption(self: pydrake.solvers.MathematicalProgram, arg0: pydrake.solvers.SolverType, arg1: str, arg2: int) -&gt; None</li>
</ol>
<p>See set_solver_option for more details. Set the integer-valued
options.</p>
<ol class="arabic simple" start="6">
<li>SetSolverOption(self: pydrake.solvers.MathematicalProgram, arg0: pydrake.solvers.SolverType, arg1: str, arg2: str) -&gt; None</li>
</ol>
<p>See set_solver_option for more details. Set the string-valued options.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.SetSolverOptions">
<code class="descname">SetSolverOptions</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em>, <em>arg0: pydrake.solvers.SolverOptions</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.SetSolverOptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Overwrite the stored solver options inside MathematicalProgram with
the provided solver options.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgram.SetVariableScaling">
<code class="descname">SetVariableScaling</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgram</em>, <em>var: pydrake.symbolic.Variable</em>, <em>s: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.MathematicalProgram.SetVariableScaling" title="Permalink to this definition">¶</a></dt>
<dd><p>Setter for the scaling <code class="docutils literal notranslate"><span class="pre">s</span></code> of decision variable <code class="docutils literal notranslate"><span class="pre">var</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">var</span></code>:</dt>
<dd>the decision variable to be scaled.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">s</span></code>:</dt>
<dd>scaling factor (must be positive).</dd>
</dl>
<p>See variable_scaling “Variable scaling” for more information.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.MathematicalProgramResult">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">MathematicalProgramResult</code><a class="headerlink" href="#pydrake.solvers.MathematicalProgramResult" title="Permalink to this definition">¶</a></dt>
<dd><p>The result returned by MathematicalProgram::Solve(). It stores the
solvers::SolutionResult (whether the program is solved to optimality,
detected infeasibility, etc), the optimal value for the decision
variables, the optimal cost, and solver specific details.</p>
<dl class="method">
<dt id="pydrake.solvers.MathematicalProgramResult.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgramResult</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.MathematicalProgramResult.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs the result.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The solver_details is set to nullptr.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgramResult.EvalBinding">
<code class="descname">EvalBinding</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgramResult, arg0: pydrake.solvers.Binding[EvaluatorBase]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.solvers.MathematicalProgramResult.EvalBinding" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate a Binding at the solution.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">binding</span></code>:</dt>
<dd>A binding between a constraint/cost and the variables.</dd>
<dt>Precondition:</dt>
<dd>The binding.variables() must be the within the decision variables
in the MathematicalProgram that generated this
MathematicalProgramResult.</dd>
<dt>Precondition:</dt>
<dd>The user must have called set_decision_variable_index() function.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgramResult.get_optimal_cost">
<code class="descname">get_optimal_cost</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgramResult</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.solvers.MathematicalProgramResult.get_optimal_cost" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the optimal cost.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgramResult.get_solution_result">
<code class="descname">get_solution_result</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgramResult</em><span class="sig-paren">)</span> &#x2192; drake::solvers::SolutionResult<a class="headerlink" href="#pydrake.solvers.MathematicalProgramResult.get_solution_result" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets SolutionResult.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgramResult.get_solver_details">
<code class="descname">get_solver_details</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgramResult</em><span class="sig-paren">)</span> &#x2192; object<a class="headerlink" href="#pydrake.solvers.MathematicalProgramResult.get_solver_details" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the solver details for the <code class="docutils literal notranslate"><span class="pre">Solver</span></code> that solved the program.
Throws an error if the solver_details has not been set.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgramResult.get_solver_id">
<code class="descname">get_solver_id</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgramResult</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.SolverId<a class="headerlink" href="#pydrake.solvers.MathematicalProgramResult.get_solver_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the solver ID.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgramResult.get_suboptimal_objective">
<code class="descname">get_suboptimal_objective</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgramResult</em>, <em>solution_number: int</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.solvers.MathematicalProgramResult.get_suboptimal_objective" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the suboptimal objective value. See solution_pools “solution
pools”.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">solution_number</span></code>:</dt>
<dd>The index of the sub-optimal solution.</dd>
<dt>Precondition:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">solution_number</span></code> should be in the range [0,
num_suboptimal_solution()).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgramResult.get_x_val">
<code class="descname">get_x_val</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgramResult</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.solvers.MathematicalProgramResult.get_x_val" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the decision variable values.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgramResult.GetDualSolution">
<code class="descname">GetDualSolution</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgramResult, arg0: pydrake.solvers.Binding[EvaluatorBase]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.solvers.MathematicalProgramResult.GetDualSolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the dual solution associated with a constraint.</p>
<p>For constraints in the form lower &lt;= f(x) &lt;= upper (including linear
inequality, linear equality, bounding box constraints, and general
nonlinear constraints), we interpret the dual variable value as the
“shadow price” of the original problem. Namely if we change the
constraint bound by one unit (each unit is infinitesimally small), the
change of the optimal cost is the value of the dual solution times the
unit. Mathematically dual_solution = ∂optimal_cost / ∂bound.</p>
<p>For a linear equality constraint Ax = b where b ∈ ℝⁿ, the vector of
dual variables has n rows, and dual_solution(i) is the value of the
dual variable for the constraint A(i,:)*x = b(i).</p>
<p>For a linear inequality constraint lower &lt;= A*x &lt;= upper where lower
and upper ∈ ℝⁿ, dual_solution also has n rows. dual_solution(i) is the
value of the dual variable for constraint lower(i) &lt;= A(i,:)*x &lt;=
upper(i). If neither side of the constraint is active, then
dual_solution(i) is 0. If the left hand-side lower(i) &lt;= A(i, :)*x is
active (meaning lower(i) = A(i, :)*x at the solution), then
dual_solution(i) is non-negative (because the objective is to minimize
a cost, increasing the lower bound means the constraint set is
tighter, hence the optimal solution cannot decrease. Thus the shadow
price is non-negative). If the right hand-side A(i, :)*x&lt;=upper(i) is
active (meaning A(i,:)*x=upper(i) at the solution), then
dual_solution(i) is non-positive.</p>
<p>For a bounding box constraint lower &lt;= x &lt;= upper, the interpretation
of the dual solution is the same as the linear inequality constraint.</p>
<p>For a Lorentz cone or rotated Lorentz cone constraint that Ax + b is
in the cone, depending on the solver, the dual solution has different
meanings: 1. If the solver is Gurobi, then the user can only obtain
the dual solution by explicitly setting the options for computing dual
solution.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">auto</span> <span class="n">constraint</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">AddLorentzConeConstraint</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
   <span class="n">GurobiSolver</span> <span class="n">solver</span><span class="p">;</span>
   <span class="o">//</span> <span class="n">Explicitly</span> <span class="n">tell</span> <span class="n">the</span> <span class="n">solver</span> <span class="n">to</span> <span class="n">compute</span> <span class="n">the</span> <span class="n">dual</span> <span class="n">solution</span> <span class="k">for</span> <span class="n">Lorentz</span>
   <span class="o">//</span> <span class="n">cone</span> <span class="ow">or</span> <span class="n">rotated</span> <span class="n">Lorentz</span> <span class="n">cone</span> <span class="n">constraint</span><span class="p">,</span> <span class="n">check</span>
   <span class="o">//</span> <span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">www</span><span class="o">.</span><span class="n">gurobi</span><span class="o">.</span><span class="n">com</span><span class="o">/</span><span class="n">documentation</span><span class="o">/</span><span class="mf">9.5</span><span class="o">/</span><span class="n">refman</span><span class="o">/</span><span class="n">qcpdual</span><span class="o">.</span><span class="n">html</span> <span class="k">for</span>
   <span class="o">//</span> <span class="n">more</span> <span class="n">information</span><span class="o">.</span>
   <span class="n">SolverOptions</span> <span class="n">options</span><span class="p">;</span>
   <span class="n">options</span><span class="o">.</span><span class="n">SetOption</span><span class="p">(</span><span class="n">GurobiSolver</span><span class="p">::</span><span class="nb">id</span><span class="p">(),</span> <span class="s2">&quot;QCPDual&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
   <span class="n">MathematicalProgramResult</span> <span class="n">result</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">Solve</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span> <span class="p">{},</span> <span class="n">options</span><span class="p">);</span>
   <span class="n">Eigen</span><span class="p">::</span><span class="n">VectorXd</span> <span class="n">dual_solution</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">GetDualSolution</span><span class="p">(</span><span class="n">constraint</span><span class="p">);</span>
</pre></div>
</div>
<p>The dual solution has size 1, dual_solution(0) is the shadow price for
the constraint z₁² + … +zₙ² ≤ z₀² for Lorentz cone constraint, and
the shadow price for the constraint z₂² + … +zₙ² ≤ z₀z₁ for rotated
Lorentz cone constraint, where z is the slack variable representing z
= A*x+b and z in the Lorentz cone/rotated Lorentz cone. 2. For
nonlinear solvers like IPOPT, the dual solution for Lorentz cone
constraint (with EvalType::kConvex) is the shadow price for z₀ -
sqrt(z₁² + … +zₙ²) ≥ 0, where z = Ax+b. 3. For other convex conic
solver such as SCS, MOSEK<a href="/tm.html">™</a>, CSDP, etc, the dual solution to the
(rotated) Lorentz cone constraint doesn’t have the “shadow price”
interpretation, but should lie in the dual cone, and satisfy the KKT
condition. For more information, refer to
https://docs.mosek.com/10.0/capi/prob-def-conic.html#duality-for-conic-optimization
as an explanation.</p>
<p>The interpretation for the dual variable to conic constraint x ∈ K can
be different. Here K is a convex cone, including exponential cone,
power cone, psd cone, etc. When the problem is solved by a convex
solver (like SCS, MOSEK<a href="/tm.html">™</a>, CSDP, etc), often it has a dual variable z ∈
K*, where K* is the dual cone. Here the dual variable DOESN’T have the
interpretation of “shadow price”, but should satisfy the KKT
condition, while the dual variable stays inside the dual cone.</p>
<p>When K is a psd cone, the returned dual solution is the lower triangle
of the dual symmetric psd matrix. Namely for the primal problem</p>
<p>min trace(C*X) s.t A(X) = b X is psd</p>
<p>the dual is</p>
<p>max b’<a href="#id43"><span class="problematic" id="id44">*</span></a>y s.t A’(y) - C = Z Z is psd.</p>
<p>We return the lower triangular part of Z. You can call
drake::math::ToSymmetricMatrixFromLowerTriangularColumns to get the
matrix Z.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgramResult.GetInfeasibleConstraintNames">
<code class="descname">GetInfeasibleConstraintNames</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgramResult</em>, <em>prog: drake::solvers::MathematicalProgram</em>, <em>tol: Optional[float] = None</em><span class="sig-paren">)</span> &#x2192; List[str]<a class="headerlink" href="#pydrake.solvers.MathematicalProgramResult.GetInfeasibleConstraintNames" title="Permalink to this definition">¶</a></dt>
<dd><p>See get_infeasible_constraints for more information.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">prog</span></code>:</dt>
<dd>The MathematicalProgram that was solved to obtain <code class="docutils literal notranslate"><span class="pre">this</span></code>
MathematicalProgramResult.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">tolerance</span></code>:</dt>
<dd>A positive tolerance to check the constraint violation. If no
tolerance is provided, this method will attempt to obtain the
constraint tolerance from the solver, or insert a conservative
default tolerance.</dd>
</dl>
<p>Note: Currently most constraints have the empty string as the
description, so the NiceTypeName of the Constraint is used instead.
Use e.g. <code class="docutils literal notranslate"><span class="pre">prog.AddConstraint(x</span> <span class="pre">==</span>
<span class="pre">1).evaluator().set_description(str)</span></code> to make this method more
specific/useful.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgramResult.GetInfeasibleConstraints">
<code class="descname">GetInfeasibleConstraints</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgramResult</em>, <em>prog: drake::solvers::MathematicalProgram</em>, <em>tol: Optional[float] = None</em><span class="sig-paren">)</span> &#x2192; List[pydrake.solvers.Binding[Constraint]]<a class="headerlink" href="#pydrake.solvers.MathematicalProgramResult.GetInfeasibleConstraints" title="Permalink to this definition">¶</a></dt>
<dd><p>See get_infeasible_constraints for more information.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">prog</span></code>:</dt>
<dd>The MathematicalProgram that was solved to obtain <code class="docutils literal notranslate"><span class="pre">this</span></code>
MathematicalProgramResult.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">tolerance</span></code>:</dt>
<dd>A positive tolerance to check the constraint violation. If no
tolerance is provided, this method will attempt to obtain the
constraint tolerance from the solver, or insert a conservative
default tolerance.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">infeasible_bindings A vector of all infeasible bindings
(constraints together with the associated variables) at the
best-effort solution.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgramResult.GetSolution">
<code class="descname">GetSolution</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.MathematicalProgramResult.GetSolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>GetSolution(self: pydrake.solvers.MathematicalProgramResult) -&gt; numpy.ndarray[numpy.float64[m, 1]]</li>
</ol>
<p>Gets the solution of all decision variables.</p>
<ol class="arabic simple" start="2">
<li>GetSolution(self: pydrake.solvers.MathematicalProgramResult, arg0: pydrake.symbolic.Variable) -&gt; float</li>
</ol>
<p>Gets the solution of a single decision variable.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">var</span></code>:</dt>
<dd>The decision variable.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The value of the decision variable after solving the problem.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal notranslate"><span class="pre">var</span></code> is not captured in the mapping</li>
<li><code class="docutils literal notranslate"><span class="pre">decision_variable_index</span></code>, as the input argument of</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">set_decision_variable_index().</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="3">
<li>GetSolution(self: pydrake.solvers.MathematicalProgramResult, arg0: numpy.ndarray[object[m, 1]]) -&gt; numpy.ndarray[numpy.float64[m, 1]]</li>
</ol>
<p>Gets the solution of an Eigen matrix of decision variables.</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">Derived</span></code>:</dt>
<dd>An Eigen matrix containing Variable.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">var</span></code>:</dt>
<dd>The decision variables.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The value of the decision variable after solving the problem.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="4">
<li>GetSolution(self: pydrake.solvers.MathematicalProgramResult, arg0: numpy.ndarray[object[m, n]]) -&gt; numpy.ndarray[numpy.float64[m, n]]</li>
</ol>
<p>Gets the solution of an Eigen matrix of decision variables.</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">Derived</span></code>:</dt>
<dd>An Eigen matrix containing Variable.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">var</span></code>:</dt>
<dd>The decision variables.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The value of the decision variable after solving the problem.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="5">
<li>GetSolution(self: pydrake.solvers.MathematicalProgramResult, arg0: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</li>
</ol>
<p>Substitutes the value of all decision variables into the Expression.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">e</span></code>:</dt>
<dd>The decision variable.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the Expression that is the result of the substitution.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="6">
<li>GetSolution(self: pydrake.solvers.MathematicalProgramResult, arg0: pydrake.symbolic.Polynomial) -&gt; pydrake.symbolic.Polynomial</li>
</ol>
<p>Substitutes the value of all decision variables into the coefficients
of the symbolic polynomial.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p</span></code>:</dt>
<dd>A symbolic polynomial. Its indeterminates can’t intersect with the
set of decision variables of the MathematicalProgram from which
this result is obtained.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">the symbolic::Polynomial as the result of the substitution.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="7">
<li>GetSolution(self: pydrake.solvers.MathematicalProgramResult, arg0: numpy.ndarray[object[m, n]]) -&gt; numpy.ndarray[object[m, n]]</li>
</ol>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgramResult.GetSuboptimalSolution">
<code class="descname">GetSuboptimalSolution</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.MathematicalProgramResult.GetSuboptimalSolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>GetSuboptimalSolution(self: pydrake.solvers.MathematicalProgramResult, arg0: pydrake.symbolic.Variable, arg1: int) -&gt; float</li>
</ol>
<p>Gets the suboptimal solution of a decision variable. See
solution_pools “solution pools”</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">var</span></code>:</dt>
<dd>The decision variable.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">solution_number</span></code>:</dt>
<dd>The index of the sub-optimal solution.</dd>
<dt>Precondition:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">solution_number</span></code> should be in the range [0,
num_suboptimal_solution()).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The suboptimal value of the decision variable after solving the
problem.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>GetSuboptimalSolution(self: pydrake.solvers.MathematicalProgramResult, arg0: numpy.ndarray[object[m, 1]], arg1: int) -&gt; numpy.ndarray[numpy.float64[m, 1]]</li>
</ol>
<p>&#64;name Solution Pools Some solvers (like Gurobi, Cplex, etc) can store
a pool of (suboptimal) solutions for mixed integer programming model.
Gets the suboptimal solution corresponding to a matrix of decision
variables. See solution_pools “solution pools”</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">var</span></code>:</dt>
<dd>The decision variables.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">solution_number</span></code>:</dt>
<dd>The index of the sub-optimal solution.</dd>
<dt>Precondition:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">solution_number</span></code> should be in the range [0,
num_suboptimal_solution()).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The suboptimal values of the decision variables after solving the
problem.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="3">
<li>GetSuboptimalSolution(self: pydrake.solvers.MathematicalProgramResult, arg0: numpy.ndarray[object[m, n]], arg1: int) -&gt; numpy.ndarray[numpy.float64[m, n]]</li>
</ol>
<p>&#64;name Solution Pools Some solvers (like Gurobi, Cplex, etc) can store
a pool of (suboptimal) solutions for mixed integer programming model.
Gets the suboptimal solution corresponding to a matrix of decision
variables. See solution_pools “solution pools”</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">var</span></code>:</dt>
<dd>The decision variables.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">solution_number</span></code>:</dt>
<dd>The index of the sub-optimal solution.</dd>
<dt>Precondition:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">solution_number</span></code> should be in the range [0,
num_suboptimal_solution()).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The suboptimal values of the decision variables after solving the
problem.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgramResult.is_success">
<code class="descname">is_success</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgramResult</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.solvers.MathematicalProgramResult.is_success" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if the optimization problem is solved successfully; false
otherwise. For more information on the solution status, the user could
call get_solver_details() to obtain the solver-specific solution
status.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgramResult.set_solution_result">
<code class="descname">set_solution_result</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgramResult</em>, <em>arg0: drake::solvers::SolutionResult</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.MathematicalProgramResult.set_solution_result" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets SolutionResult.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MathematicalProgramResult.set_x_val">
<code class="descname">set_x_val</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MathematicalProgramResult, x_val: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.MathematicalProgramResult.set_x_val" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the decision variable values.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.MixedIntegerBranchAndBound">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">MixedIntegerBranchAndBound</code><a class="headerlink" href="#pydrake.solvers.MixedIntegerBranchAndBound" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a mixed-integer optimization problem (MIP) (or more accurately,
mixed binary problem), solve this problem through branch-and-bound
process. We will first replace all the binary variables with
continuous variables, and relax the integral constraint on the binary
variables z ∈ {0, 1} with continuous constraints 0 ≤ z ≤ 1. In the
subsequent steps, at each node of the tree, we will fix some binary
variables to either 0 or 1, and solve the rest of the variables.
Notice that we will create a new set of variables in the
branch-and-bound process, since we need to replace the binary
variables with continuous variables.</p>
<dl class="method">
<dt id="pydrake.solvers.MixedIntegerBranchAndBound.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MixedIntegerBranchAndBound</em>, <em>prog: pydrake.solvers.MathematicalProgram</em>, <em>solver_id: pydrake.solvers.SolverId</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.MixedIntegerBranchAndBound.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a branch-and-bound tree from a mixed-integer optimization
program.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">prog</span></code>:</dt>
<dd>A mixed-integer optimization program.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">solver_id</span></code>:</dt>
<dd>The ID of the solver for the optimization.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MixedIntegerBranchAndBound.GetOptimalCost">
<code class="descname">GetOptimalCost</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MixedIntegerBranchAndBound</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.solvers.MixedIntegerBranchAndBound.GetOptimalCost" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the optimal cost.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MixedIntegerBranchAndBound.GetSolution">
<code class="descname">GetSolution</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.MixedIntegerBranchAndBound.GetSolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>GetSolution(self: pydrake.solvers.MixedIntegerBranchAndBound, mip_var: pydrake.symbolic.Variable, nth_best_solution: int = 0) -&gt; float</li>
</ol>
<p>Get the n’th best integral solution for a variable. The best solutions
are sorted in the ascending order based on their costs. Each solution
is found in a separate node in the branch-and-bound tree, so the
values of the binary variables are different in each solution.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mip_var</span></code>:</dt>
<dd>A variable in the original MIP.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">nth_best_solution</span></code>:</dt>
<dd>. The index of the best integral solution.</dd>
<dt>Precondition:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">mip_var</span></code> is a variable in the original MIP.</dd>
<dt>Precondition:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">nth_best_solution</span></code> is between 0 and solutions().size().</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the preconditions are not satisfied.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>GetSolution(self: pydrake.solvers.MixedIntegerBranchAndBound, mip_vars: numpy.ndarray[object[m, 1]], nth_best_solution: int = 0) -&gt; numpy.ndarray[numpy.float64[m, 1]]</li>
</ol>
<p>Get the n’th best integral solution for some variables. The best
solutions are sorted in the ascending order based on their costs. Each
solution is found in a separate node in the branch-and-bound tree, so</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mip_vars</span></code>:</dt>
<dd>Variables in the original MIP.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">nth_best_solution</span></code>:</dt>
<dd>. The index of the best integral solution.</dd>
<dt>Precondition:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">mip_vars</span></code> are variables in the original MIP.</dd>
<dt>Precondition:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">nth_best_solution</span></code> is between 0 and solutions().size().</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the preconditions are not satisfied.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="3">
<li>GetSolution(self: pydrake.solvers.MixedIntegerBranchAndBound, mip_vars: numpy.ndarray[object[m, n]], nth_best_solution: int = 0) -&gt; numpy.ndarray[numpy.float64[m, n]]</li>
</ol>
<p>Get the n’th best integral solution for some variables. The best
solutions are sorted in the ascending order based on their costs. Each
solution is found in a separate node in the branch-and-bound tree, so</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mip_vars</span></code>:</dt>
<dd>Variables in the original MIP.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">nth_best_solution</span></code>:</dt>
<dd>. The index of the best integral solution.</dd>
<dt>Precondition:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">mip_vars</span></code> are variables in the original MIP.</dd>
<dt>Precondition:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">nth_best_solution</span></code> is between 0 and solutions().size().</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the preconditions are not satisfied.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MixedIntegerBranchAndBound.GetSubOptimalCost">
<code class="descname">GetSubOptimalCost</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MixedIntegerBranchAndBound</em>, <em>nth_suboptimal_cost: int</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.solvers.MixedIntegerBranchAndBound.GetSubOptimalCost" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the n’th sub-optimal cost. The costs are sorted in the ascending
order. The sub-optimal costs do not include the optimal cost.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">nth_suboptimal_cost</span></code>:</dt>
<dd>The n’th sub-optimal cost.</dd>
<dt>Precondition:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">nth_suboptimal_cost</span></code> is between 0 and solutions().size() - 1.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the precondition is not satisfied.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MixedIntegerBranchAndBound.Solve">
<code class="descname">Solve</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MixedIntegerBranchAndBound</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.SolutionResult<a class="headerlink" href="#pydrake.solvers.MixedIntegerBranchAndBound.Solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the mixed-integer problem (MIP) through a branch and bound
process.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">solution_result</span></code>:</dt>
<dd>If solution_result=SolutionResult::kSolutionFound, then the best
solutions are stored inside solutions(). The user can access the
value of each variable(s) through GetSolution(…). If
solution_result=SolutionResult::kInfeasibleConstraints, then the
mixed-integer problem is primal infeasible. If
solution_result=SolutionResult::kUnbounded, then the mixed-integer
problem is primal unbounded.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.MixedIntegerRotationConstraintGenerator">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">MixedIntegerRotationConstraintGenerator</code><a class="headerlink" href="#pydrake.solvers.MixedIntegerRotationConstraintGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>We relax the non-convex SO(3) constraint on rotation matrix R to
mixed-integer linear constraints. The formulation of these constraints
are described in Global Inverse Kinematics via Mixed-integer Convex
Optimization by Hongkai Dai, Gregory Izatt and Russ Tedrake, ISRR,
2017</p>
<p>The SO(3) constraint on a rotation matrix R = [r₁, r₂, r₃], rᵢ∈ℝ³ is</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>rᵢᵀrᵢ = 1    (1)
rᵢᵀrⱼ = 0    (2)
r₁ x r₂ = r₃ (3)
</pre></div>
</div>
<p>To relax SO(3) constraint on rotation matrix R, we divide the range
[-1, 1] (the range of each entry in R) into smaller intervals [φ(i),
φ(i+1)], and then relax the SO(3) constraint within each interval. We
provide 3 approaches for relaxation 1. By replacing each bilinear
product in constraint (1), (2) and (3) with a new variable, in the
McCormick envelope of the bilinear product w = x * y. 2. By
considering the intersection region between axis-aligned boxes, and
the surface of a unit sphere in 3D. 3. By combining the two approaches
above. This will result in a tighter relaxation.</p>
<p>These three approaches give different relaxation of SO(3) constraint
(the feasible sets for each relaxation are different), and different
computation speed. The users can switch between the approaches to find
the best fit for their problem.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If you have several rotation matrices that all need to be relaxed
through mixed-integer constraint, then you can create a single
MixedIntegerRotationConstraintGenerator object, and add the
mixed-integer constraint to each rotation matrix, by calling
AddToProgram() function repeatedly.</p>
</div>
<dl class="method">
<dt id="pydrake.solvers.MixedIntegerRotationConstraintGenerator.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MixedIntegerRotationConstraintGenerator</em>, <em>approach: pydrake.solvers.MixedIntegerRotationConstraintGenerator.Approach</em>, <em>num_intervals_per_half_axis: int</em>, <em>interval_binning: pydrake.solvers.IntervalBinning</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.MixedIntegerRotationConstraintGenerator.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">approach</span></code>:</dt>
<dd>Refer to MixedIntegerRotationConstraintGenerator::Approach for the
details.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_intervals_per_half_axis</span></code>:</dt>
<dd>We will cut the range [-1, 1] evenly to 2 *
<code class="docutils literal notranslate"><span class="pre">num_intervals_per_half_axis</span></code> small intervals. The number of
binary variables will depend on the number of intervals.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">interval_binning</span></code>:</dt>
<dd>The binning scheme we use to add SOS2 constraint with binary
variables. If interval_binning = kLinear, then we will add 9 * 2 *
<code class="docutils literal notranslate"><span class="pre">num_intervals_per_half_axis</span> <span class="pre">binary</span></code> variables; if
interval_binning = kLogarithmic, then we will add 9 * (1 +
log₂(num_intervals_per_half_axis)) binary variables. Refer to
AddLogarithmicSos2Constraint and AddSos2Constraint for more
details.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MixedIntegerRotationConstraintGenerator.AddToProgram">
<code class="descname">AddToProgram</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MixedIntegerRotationConstraintGenerator, R: numpy.ndarray[object[3, 3], flags.f_contiguous], prog: pydrake.solvers.MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.MixedIntegerRotationConstraintGenerator.ReturnType<a class="headerlink" href="#pydrake.solvers.MixedIntegerRotationConstraintGenerator.AddToProgram" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the mixed-integer linear constraints to the optimization program,
as a relaxation of SO(3) constraint on the rotation matrix <code class="docutils literal notranslate"><span class="pre">R</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R</span></code>:</dt>
<dd>The rotation matrix on which the SO(3) constraint is imposed.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">prog</span></code>:</dt>
<dd>The optimization program to which the mixed-integer constraints
(and additional variables) are added.</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.MixedIntegerRotationConstraintGenerator.Approach">
<em class="property">class </em><code class="descname">Approach</code><a class="headerlink" href="#pydrake.solvers.MixedIntegerRotationConstraintGenerator.Approach" title="Permalink to this definition">¶</a></dt>
<dd><p>Members:</p>
<blockquote>
<div>kBoxSphereIntersection : Relax SO(3) constraint by considering the intersection between boxes</div></blockquote>
<p>and the unit sphere surface.</p>
<blockquote>
<div>kBilinearMcCormick : Relax SO(3) constraint by considering the McCormick envelope on the</div></blockquote>
<p>bilinear product.</p>
<blockquote>
<div>kBoth : Relax SO(3) constraint by considering both the intersection between</div></blockquote>
<p>boxes and the unit sphere surface, and the McCormick envelope on the
bilinear product.</p>
<dl class="method">
<dt id="pydrake.solvers.MixedIntegerRotationConstraintGenerator.Approach.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MixedIntegerRotationConstraintGenerator.Approach</em>, <em>value: int</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.MixedIntegerRotationConstraintGenerator.Approach.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.MixedIntegerRotationConstraintGenerator.Approach.kBilinearMcCormick">
<code class="descname">kBilinearMcCormick</code><em class="property"> = &lt;Approach.kBilinearMcCormick: 1&gt;</em><a class="headerlink" href="#pydrake.solvers.MixedIntegerRotationConstraintGenerator.Approach.kBilinearMcCormick" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.MixedIntegerRotationConstraintGenerator.Approach.kBoth">
<code class="descname">kBoth</code><em class="property"> = &lt;Approach.kBoth: 2&gt;</em><a class="headerlink" href="#pydrake.solvers.MixedIntegerRotationConstraintGenerator.Approach.kBoth" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.MixedIntegerRotationConstraintGenerator.Approach.kBoxSphereIntersection">
<code class="descname">kBoxSphereIntersection</code><em class="property"> = &lt;Approach.kBoxSphereIntersection: 0&gt;</em><a class="headerlink" href="#pydrake.solvers.MixedIntegerRotationConstraintGenerator.Approach.kBoxSphereIntersection" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.MixedIntegerRotationConstraintGenerator.Approach.name">
<code class="descname">name</code><a class="headerlink" href="#pydrake.solvers.MixedIntegerRotationConstraintGenerator.Approach.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.MixedIntegerRotationConstraintGenerator.Approach.value">
<code class="descname">value</code><a class="headerlink" href="#pydrake.solvers.MixedIntegerRotationConstraintGenerator.Approach.value" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MixedIntegerRotationConstraintGenerator.interval_binning">
<code class="descname">interval_binning</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MixedIntegerRotationConstraintGenerator</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.IntervalBinning<a class="headerlink" href="#pydrake.solvers.MixedIntegerRotationConstraintGenerator.interval_binning" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MixedIntegerRotationConstraintGenerator.num_intervals_per_half_axis">
<code class="descname">num_intervals_per_half_axis</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MixedIntegerRotationConstraintGenerator</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.solvers.MixedIntegerRotationConstraintGenerator.num_intervals_per_half_axis" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MixedIntegerRotationConstraintGenerator.phi">
<code class="descname">phi</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MixedIntegerRotationConstraintGenerator</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.solvers.MixedIntegerRotationConstraintGenerator.phi" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for φ.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MixedIntegerRotationConstraintGenerator.phi_nonnegative">
<code class="descname">phi_nonnegative</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MixedIntegerRotationConstraintGenerator</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.solvers.MixedIntegerRotationConstraintGenerator.phi_nonnegative" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for φ₊, the non-negative part of φ.</p>
</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.MixedIntegerRotationConstraintGenerator.ReturnType">
<em class="property">class </em><code class="descname">ReturnType</code><a class="headerlink" href="#pydrake.solvers.MixedIntegerRotationConstraintGenerator.ReturnType" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="pydrake.solvers.MixedIntegerRotationConstraintGenerator.ReturnType.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.solvers.MixedIntegerRotationConstraintGenerator.ReturnType.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.MixedIntegerRotationConstraintGenerator.ReturnType.B_">
<code class="descname">B_</code><a class="headerlink" href="#pydrake.solvers.MixedIntegerRotationConstraintGenerator.ReturnType.B_" title="Permalink to this definition">¶</a></dt>
<dd><p><a href="#id55"><span class="problematic" id="id56">B_</span></a> contains the new binary variables added to the program. B_`i][j]
represents in which interval R(i, j) lies. If we use linear binning,
then B_[i][j] is of length 2 * <a href="#id57"><span class="problematic" id="id58">num_intervals_per_half_axis_</span></a>. B_[i][j
&lt;k&gt;`_ = 1 =&gt; φ(k) ≤ R(i, j) ≤ φ(k + 1) B_`i][j &lt;k&gt;`_ = 0 =&gt; R(i, j) ≥
φ(k + 1) or R(i, j) ≤ φ(k) If we use logarithmic binning, then
B_[i][j] is of length 1 + log₂(<a href="#id59"><span class="problematic" id="id60">num_intervals_per_half_axis_</span></a>). If
B_[i][j] represents integer k in reflected Gray code, then R(i, j) is
in the interval [φ(k), φ(k+1)].</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.MixedIntegerRotationConstraintGenerator.ReturnType.lambda_">
<code class="descname">lambda_</code><a class="headerlink" href="#pydrake.solvers.MixedIntegerRotationConstraintGenerator.ReturnType.lambda_" title="Permalink to this definition">¶</a></dt>
<dd><p>λ contains part of the new continuous variables added to the program.
λ_`i][j] is of length 2 * <a href="#id61"><span class="problematic" id="id62">num_intervals_per_half_axis_</span></a> + 1, such that
R(i, j) = φᵀ * λ_[i][j]. Notice that λ_[i][j] satisfies the special
ordered set of type 2 (SOS2) constraint. Namely at most two entries in
λ_[i][j] can be strictly positive, and these two entries have to be
consecutive. Mathematically</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>∑ₖ λ_[i][j &lt;k&gt;`_ = 1
λ_`i][j &lt;k&gt;`_ ≥ 0 ∀ k
∃ m s.t λ_`i][j &lt;n&gt;`_ = 0 if n ≠ m and n ≠ m+1
</pre></div>
</div>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.MosekSolver">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">MosekSolver</code><a class="headerlink" href="#pydrake.solvers.MosekSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.SolverInterface" title="pydrake.solvers.SolverInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.SolverInterface</span></code></a></p>
<p>An implementation of SolverInterface for the commercially-licensed
MOSEK<a href="/tm.html">™</a> solver (<a class="reference external" href="https://www.mosek.com/">https://www.mosek.com/</a>).</p>
<p>The default build of Drake is not configured to use MOSEK<a href="/tm.html">™</a>, so
therefore SolverInterface::available() will return false. You must
compile Drake from source in order to link against MOSEK<a href="/tm.html">™</a>. For
details, refer to the documentation at
<a class="reference external" href="https://drake.mit.edu/bazel.html#mosek">https://drake.mit.edu/bazel.html#mosek</a>.</p>
<p>The MOSEKLM_LICENSE_FILE environment variable controls whether or not
SolverInterface::enabled() returns true. Iff it is set to any
non-empty value, then the solver is enabled; otherwise, the solver is
not enabled.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">MOSEK<a href="/tm.html">™</a> only cares about the initial guess of integer variables.
The initial guess of continuous variables are not passed to
MOSEK<a href="/tm.html">™</a>. If all the integer variables are set to some integer
values, then MOSEK<a href="/tm.html">™</a> will be forced to compute the remaining
continuous variable values as the initial guess. (MOSEK<a href="/tm.html">™</a> might
change the values of the integer/binary variables in the
subsequent iterations.) If the specified integer solution is
infeasible or incomplete, MOSEK<a href="/tm.html">™</a> will simply ignore it. For more
details, check
<a class="reference external" href="https://docs.mosek.com/10.0/capi/tutorial-mio-shared.html?highlight=initial">https://docs.mosek.com/10.0/capi/tutorial-mio-shared.html?highlight=initial</a></p>
</div>
<p>MOSEK<a href="/tm.html">™</a> supports many solver parameters. You can refer to the full list
of parameters in
<a class="reference external" href="https://docs.mosek.com/10.0/capi/param-groups.html#doc-param-groups">https://docs.mosek.com/10.0/capi/param-groups.html#doc-param-groups</a>.
On top of these parameters, we also provide the following additional
parameters 1. “writedata”, set to a file name so that MOSEK<a href="/tm.html">™</a> solver
will write the optimization model to this file. check
<a class="reference external" href="https://docs.mosek.com/10.0/capi/solver-io.html#saving-a-problem-to-a-file">https://docs.mosek.com/10.0/capi/solver-io.html#saving-a-problem-to-a-file</a>
for more details. The supported file extensions are listed in
<a class="reference external" href="https://docs.mosek.com/10.0/capi/supported-file-formats.html#doc-shared-file-formats">https://docs.mosek.com/10.0/capi/supported-file-formats.html#doc-shared-file-formats</a>.
Set this parameter to “” if you don’t want to write to a file. Default
is not to write to a file.</p>
<dl class="method">
<dt id="pydrake.solvers.MosekSolver.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MosekSolver</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.MosekSolver.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="pydrake.solvers.MosekSolver.AcquireLicense">
<em class="property">static </em><code class="descname">AcquireLicense</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.solvers.MosekSolver.License<a class="headerlink" href="#pydrake.solvers.MosekSolver.AcquireLicense" title="Permalink to this definition">¶</a></dt>
<dd><p>This acquires a MOSEK<a href="/tm.html">™</a> license environment shared among all
MosekSolver instances; the environment will stay valid as long as at
least one shared_ptr returned by this function is alive. Call this
ONLY if you must use different MathematicalProgram instances at
different instances in time, and repeatedly acquiring the license is
costly (e.g., requires contacting a license server).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">A shared pointer to a license environment that will stay valid as
long as any shared_ptr returned by this function is alive. If
MOSEK<a href="/tm.html">™</a> is not available in your build, this will return a null
(empty) shared_ptr.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if MOSEK<a href="/tm.html">™</a> is available but a license cannot be</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">obtained.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.solvers.MosekSolver.id">
<em class="property">static </em><code class="descname">id</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.solvers.SolverId<a class="headerlink" href="#pydrake.solvers.MosekSolver.id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="pydrake.solvers.MosekSolver.License">
<em class="property">class </em><code class="descname">License</code><a class="headerlink" href="#pydrake.solvers.MosekSolver.License" title="Permalink to this definition">¶</a></dt>
<dd><p>Context-manageable license from <code class="docutils literal notranslate"><span class="pre">MosekSolver.AcquireLicense()</span></code>.</p>
<dl class="attribute">
<dt id="pydrake.solvers.MosekSolver.License.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.solvers.MosekSolver.License.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.MosekSolver.License.is_valid">
<code class="descname">is_valid</code><span class="sig-paren">(</span><em>self: pydrake.solvers.MosekSolver.License</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.solvers.MosekSolver.License.is_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicates that this has a valid license that has not been released.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.MosekSolverDetails">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">MosekSolverDetails</code><a class="headerlink" href="#pydrake.solvers.MosekSolverDetails" title="Permalink to this definition">¶</a></dt>
<dd><p>The MOSEK<a href="/tm.html">™</a> solver details after calling Solve() function. The user can
call MathematicalProgramResult::get_solver_details&lt;MosekSolver&gt;() to
obtain the details.</p>
<dl class="attribute">
<dt id="pydrake.solvers.MosekSolverDetails.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.solvers.MosekSolverDetails.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.MosekSolverDetails.optimizer_time">
<code class="descname">optimizer_time</code><a class="headerlink" href="#pydrake.solvers.MosekSolverDetails.optimizer_time" title="Permalink to this definition">¶</a></dt>
<dd><p>The MOSEK<a href="/tm.html">™</a> optimization time. Please refer to MSK_DINF_OPTIMIZER_TIME
in
<a class="reference external" href="https://docs.mosek.com/10.0/capi/constants.html?highlight=msk_dinf_optimizer_time">https://docs.mosek.com/10.0/capi/constants.html?highlight=msk_dinf_optimizer_time</a></p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.MosekSolverDetails.rescode">
<code class="descname">rescode</code><a class="headerlink" href="#pydrake.solvers.MosekSolverDetails.rescode" title="Permalink to this definition">¶</a></dt>
<dd><p>The response code returned from MOSEK<a href="/tm.html">™</a> solver. Check
<a class="reference external" href="https://docs.mosek.com/10.0/capi/response-codes.html">https://docs.mosek.com/10.0/capi/response-codes.html</a> for the meaning
on the response code.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.MosekSolverDetails.solution_status">
<code class="descname">solution_status</code><a class="headerlink" href="#pydrake.solvers.MosekSolverDetails.solution_status" title="Permalink to this definition">¶</a></dt>
<dd><p>The solution status after solving the problem. Check
<a class="reference external" href="https://docs.mosek.com/10.0/capi/accessing-solution.html">https://docs.mosek.com/10.0/capi/accessing-solution.html</a> and
<a class="reference external" href="https://docs.mosek.com/10.0/capi/constants.html#mosek.solsta">https://docs.mosek.com/10.0/capi/constants.html#mosek.solsta</a> for the
meaning on the solution status.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.NloptSolver">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">NloptSolver</code><a class="headerlink" href="#pydrake.solvers.NloptSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.SolverInterface" title="pydrake.solvers.SolverInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.SolverInterface</span></code></a></p>
<dl class="method">
<dt id="pydrake.solvers.NloptSolver.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.NloptSolver</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.NloptSolver.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="pydrake.solvers.NloptSolver.id">
<em class="property">static </em><code class="descname">id</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.solvers.SolverId<a class="headerlink" href="#pydrake.solvers.NloptSolver.id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.NloptSolverDetails">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">NloptSolverDetails</code><a class="headerlink" href="#pydrake.solvers.NloptSolverDetails" title="Permalink to this definition">¶</a></dt>
<dd><p>The NLopt solver details after calling Solve() function. The user can
call MathematicalProgramResult::get_solver_details&lt;NloptSolver&gt;() to
obtain the details.</p>
<dl class="attribute">
<dt id="pydrake.solvers.NloptSolverDetails.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.solvers.NloptSolverDetails.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.NloptSolverDetails.status">
<code class="descname">status</code><a class="headerlink" href="#pydrake.solvers.NloptSolverDetails.status" title="Permalink to this definition">¶</a></dt>
<dd><p>The return status of NLopt solver. Please refer to
<a class="reference external" href="https://nlopt.readthedocs.io/en/latest/NLopt_Reference/#return-values">https://nlopt.readthedocs.io/en/latest/NLopt_Reference/#return-values</a>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.OsqpSolver">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">OsqpSolver</code><a class="headerlink" href="#pydrake.solvers.OsqpSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.SolverInterface" title="pydrake.solvers.SolverInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.SolverInterface</span></code></a></p>
<dl class="method">
<dt id="pydrake.solvers.OsqpSolver.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.OsqpSolver</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.OsqpSolver.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="pydrake.solvers.OsqpSolver.id">
<em class="property">static </em><code class="descname">id</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.solvers.SolverId<a class="headerlink" href="#pydrake.solvers.OsqpSolver.id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.OsqpSolverDetails">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">OsqpSolverDetails</code><a class="headerlink" href="#pydrake.solvers.OsqpSolverDetails" title="Permalink to this definition">¶</a></dt>
<dd><p>The OSQP solver details after calling Solve() function. The user can
call MathematicalProgramResult::get_solver_details&lt;OsqpSolver&gt;() to
obtain the details.</p>
<dl class="attribute">
<dt id="pydrake.solvers.OsqpSolverDetails.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.solvers.OsqpSolverDetails.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.OsqpSolverDetails.dual_res">
<code class="descname">dual_res</code><a class="headerlink" href="#pydrake.solvers.OsqpSolverDetails.dual_res" title="Permalink to this definition">¶</a></dt>
<dd><p>Norm of dual residue.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.OsqpSolverDetails.iter">
<code class="descname">iter</code><a class="headerlink" href="#pydrake.solvers.OsqpSolverDetails.iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of iterations taken.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.OsqpSolverDetails.polish_time">
<code class="descname">polish_time</code><a class="headerlink" href="#pydrake.solvers.OsqpSolverDetails.polish_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Time taken for polish phase (seconds).</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.OsqpSolverDetails.primal_res">
<code class="descname">primal_res</code><a class="headerlink" href="#pydrake.solvers.OsqpSolverDetails.primal_res" title="Permalink to this definition">¶</a></dt>
<dd><p>Norm of primal residue.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.OsqpSolverDetails.run_time">
<code class="descname">run_time</code><a class="headerlink" href="#pydrake.solvers.OsqpSolverDetails.run_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Total OSQP time (seconds).</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.OsqpSolverDetails.setup_time">
<code class="descname">setup_time</code><a class="headerlink" href="#pydrake.solvers.OsqpSolverDetails.setup_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Time taken for setup phase (seconds).</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.OsqpSolverDetails.solve_time">
<code class="descname">solve_time</code><a class="headerlink" href="#pydrake.solvers.OsqpSolverDetails.solve_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Time taken for solve phase (seconds).</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.OsqpSolverDetails.status_val">
<code class="descname">status_val</code><a class="headerlink" href="#pydrake.solvers.OsqpSolverDetails.status_val" title="Permalink to this definition">¶</a></dt>
<dd><p>Status of the solver at termination. Please refer to
<a class="reference external" href="https://github.com/oxfordcontrol/osqp/blob/master/include/constants.h">https://github.com/oxfordcontrol/osqp/blob/master/include/constants.h</a></p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.OsqpSolverDetails.y">
<code class="descname">y</code><a class="headerlink" href="#pydrake.solvers.OsqpSolverDetails.y" title="Permalink to this definition">¶</a></dt>
<dd><p>y contains the solution for the Lagrangian multiplier associated with
l &lt;= Ax &lt;= u. The Lagrangian multiplier is set only when OSQP solves
the problem. Notice that the order of the linear constraints are
linear inequality first, and then linear equality constraints.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.PerspectiveQuadraticCost">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">PerspectiveQuadraticCost</code><a class="headerlink" href="#pydrake.solvers.PerspectiveQuadraticCost" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.Cost" title="pydrake.solvers.Cost"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Cost</span></code></a></p>
<p>If z = Ax + b, implements a cost of the form: (z_1^2 + z_2^2 + … +
z_{n-1}^2) / z_0. Note that this cost is convex when we additonally
constrain z_0 &gt; 0. It is treated as a generic nonlinear objective by
most solvers.</p>
<dl class="method">
<dt id="pydrake.solvers.PerspectiveQuadraticCost.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.PerspectiveQuadraticCost, A: numpy.ndarray[numpy.float64[m, n]], b: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.PerspectiveQuadraticCost.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a cost of the form (z_1^2 + z_2^2 + … + z_{n-1}^2) / z_0
where z = Ax + b.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">A</span></code>:</dt>
<dd>Linear term.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>:</dt>
<dd>Constant term.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.PerspectiveQuadraticCost.A">
<code class="descname">A</code><span class="sig-paren">(</span><em>self: pydrake.solvers.PerspectiveQuadraticCost</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, n]]<a class="headerlink" href="#pydrake.solvers.PerspectiveQuadraticCost.A" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.PerspectiveQuadraticCost.b">
<code class="descname">b</code><span class="sig-paren">(</span><em>self: pydrake.solvers.PerspectiveQuadraticCost</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.solvers.PerspectiveQuadraticCost.b" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.PerspectiveQuadraticCost.UpdateCoefficients">
<code class="descname">UpdateCoefficients</code><span class="sig-paren">(</span><em>self: pydrake.solvers.PerspectiveQuadraticCost, new_A: numpy.ndarray[numpy.float64[m, n]], new_b: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.PerspectiveQuadraticCost.UpdateCoefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the coefficients of the cost. Note that the number of
variables (columns of A) cannot change.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_A</span></code>:</dt>
<dd>New linear term.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_b</span></code>:</dt>
<dd>New constant term.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.PositiveSemidefiniteConstraint">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">PositiveSemidefiniteConstraint</code><a class="headerlink" href="#pydrake.solvers.PositiveSemidefiniteConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.Constraint" title="pydrake.solvers.Constraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Constraint</span></code></a></p>
<p>Implements a positive semidefinite constraint on a symmetric matrix S</p>
<div class="math notranslate nohighlight">
\[\text{
S is p.s.d\]</div>
<p>}</p>
<p>namely, all eigen values of S are non-negative.</p>
<dl class="method">
<dt id="pydrake.solvers.PositiveSemidefiniteConstraint.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.PositiveSemidefiniteConstraint</em>, <em>rows: int</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.PositiveSemidefiniteConstraint.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Impose the constraint that a symmetric matrix with size <code class="docutils literal notranslate"><span class="pre">rows</span></code> x
<code class="docutils literal notranslate"><span class="pre">rows</span></code> is positive semidefinite.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">MathematicalProgram::AddPositiveSemidefiniteConstraint() for how
to use this constraint on some decision variables. We currently
use this constraint as a place holder in MathematicalProgram, to
indicate the positive semidefiniteness of some decision variables.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rows</span></code>:</dt>
<dd>The number of rows (and columns) of the symmetric matrix.</dd>
</dl>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">MathematicalProgram</span> <span class="nb">object</span><span class="o">.</span>
<span class="n">auto</span> <span class="n">prog</span> <span class="o">=</span> <span class="n">MathematicalProgram</span><span class="p">();</span>

<span class="o">//</span> <span class="n">Add</span> <span class="n">a</span> <span class="mi">2</span> <span class="n">x</span> <span class="mi">2</span> <span class="n">symmetric</span> <span class="n">matrix</span> <span class="n">S</span> <span class="n">to</span> <span class="n">optimization</span> <span class="n">program</span> <span class="k">as</span> <span class="n">new</span> <span class="n">decision</span>
<span class="o">//</span> <span class="n">variables</span><span class="o">.</span>
<span class="n">auto</span> <span class="n">S</span> <span class="o">=</span> <span class="n">prog</span><span class="o">.</span><span class="n">NewSymmetricContinuousVariables</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">);</span>

<span class="o">//</span> <span class="n">Impose</span> <span class="n">a</span> <span class="n">positive</span> <span class="n">semidefinite</span> <span class="n">constraint</span> <span class="n">on</span> <span class="n">S</span><span class="o">.</span>
<span class="n">std</span><span class="p">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">PositiveSemidefiniteConstraint</span><span class="o">&gt;</span> <span class="n">psd_constraint</span> <span class="o">=</span>
    <span class="n">prog</span><span class="o">.</span><span class="n">AddPositiveSemidefiniteConstraint</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>

<span class="o">/////////////////////////////////////////////////////////////</span>
<span class="o">//</span> <span class="n">Add</span> <span class="n">more</span> <span class="n">constraints</span> <span class="n">to</span> <span class="n">make</span> <span class="n">the</span> <span class="n">program</span> <span class="n">more</span> <span class="n">interesting</span><span class="p">,</span>
<span class="o">//</span> <span class="n">but</span> <span class="n">this</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">needed</span><span class="o">.</span>

<span class="o">//</span> <span class="n">Add</span> <span class="n">the</span> <span class="n">constraint</span> <span class="n">that</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="mf">1.</span>
<span class="n">prog</span><span class="o">.</span><span class="n">AddBoundingBoxConstraint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

<span class="o">//</span> <span class="n">Minimize</span> <span class="n">S</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span>
<span class="n">prog</span><span class="o">.</span><span class="n">AddLinearCost</span><span class="p">(</span><span class="n">Eigen</span><span class="p">::</span><span class="n">RowVector2d</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">{</span><span class="n">S</span><span class="o">.</span><span class="n">diagonal</span><span class="p">()});</span>

<span class="o">/////////////////////////////////////////////////////////////</span>

<span class="o">//</span> <span class="n">Now</span> <span class="n">solve</span> <span class="n">the</span> <span class="n">program</span><span class="o">.</span>
<span class="n">auto</span> <span class="n">result</span> <span class="o">=</span> <span class="n">Solve</span><span class="p">(</span><span class="n">prog</span><span class="p">);</span>

<span class="o">//</span> <span class="n">Retrieve</span> <span class="n">the</span> <span class="n">solution</span> <span class="n">of</span> <span class="n">matrix</span> <span class="n">S</span><span class="o">.</span>
<span class="n">auto</span> <span class="n">S_value</span> <span class="o">=</span> <span class="n">GetSolution</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>

<span class="o">//</span> <span class="n">Compute</span> <span class="n">the</span> <span class="n">eigen</span> <span class="n">values</span> <span class="n">of</span> <span class="n">the</span> <span class="n">solution</span><span class="p">,</span> <span class="n">to</span> <span class="n">see</span> <span class="k">if</span> <span class="n">they</span> <span class="n">are</span>
<span class="o">//</span> <span class="nb">all</span> <span class="n">non</span><span class="o">-</span><span class="n">negative</span><span class="o">.</span>
<span class="n">Eigen</span><span class="p">::</span><span class="n">Vector4d</span> <span class="n">S_stacked</span><span class="p">;</span>
<span class="n">S_stacked</span> <span class="o">&lt;&lt;</span> <span class="n">S_value</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">S_value</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="n">Eigen</span><span class="p">::</span><span class="n">VectorXd</span> <span class="n">S_eigen_values</span><span class="p">;</span>
<span class="n">psd_constraint</span><span class="o">-&gt;</span><span class="n">Eval</span><span class="p">(</span><span class="n">S_stacked</span><span class="p">,</span> <span class="n">S_eigen_values</span><span class="p">);</span>

<span class="n">std</span><span class="p">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s2">&quot;S solution is: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">S</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">std</span><span class="p">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s2">&quot;The eigen value of S is &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">S_eigen_values</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="p">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.PositiveSemidefiniteConstraint.matrix_rows">
<code class="descname">matrix_rows</code><span class="sig-paren">(</span><em>self: pydrake.solvers.PositiveSemidefiniteConstraint</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.solvers.PositiveSemidefiniteConstraint.matrix_rows" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.ProgramType">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">ProgramType</code><a class="headerlink" href="#pydrake.solvers.ProgramType" title="Permalink to this definition">¶</a></dt>
<dd><p>A coarse categorization of the optimization problem based on the type
of constraints/costs/variables. Notice that Drake chooses the solver
based on a finer category; for example we have a specific solver for
equality-constrained convex QP.</p>
<p>Members:</p>
<blockquote>
<div><p>kLP : Linear Programming, with a linear cost and linear constraints.</p>
<p>kQP : Quadratic Programming, with a convex quadratic cost and linear</p>
</div></blockquote>
<p>constraints.</p>
<blockquote>
<div>kSOCP : Second-order Cone Programming, with a linear cost and second-order</div></blockquote>
<p>cone constraints.</p>
<blockquote>
<div>kSDP : Semidefinite Programming, with a linear cost and positive semidefinite</div></blockquote>
<p>matrix constraints.</p>
<blockquote>
<div>kGP : Geometric Programming, with a linear cost and exponential cone</div></blockquote>
<p>constraints.</p>
<blockquote>
<div>kCGP : Conic Geometric Programming, this is a superset that unifies GP and</div></blockquote>
<p>SDP. Refer to <a class="reference external" href="http://people.lids.mit.edu/pari/cgp_preprint.pdf">http://people.lids.mit.edu/pari/cgp_preprint.pdf</a> for
more details.</p>
<blockquote>
<div>kMILP : Mixed-integer Linear Programming. LP with some variables taking binary</div></blockquote>
<p>values.</p>
<blockquote>
<div>kMIQP : Mixed-integer Quadratic Programming. QP with some variables taking</div></blockquote>
<p>binary values.</p>
<blockquote>
<div>kMISOCP : Mixed-integer Second-order Cone Programming. SOCP with some variables</div></blockquote>
<p>taking binary values.</p>
<blockquote>
<div>kMISDP : Mixed-integer Semidefinite Programming. SDP with some variables taking</div></blockquote>
<p>binary values.</p>
<blockquote>
<div><p>kQuadraticCostConicConstraint : convex quadratic cost with nonlinear conic constraints.</p>
<p>kNLP : nonlinear programming. Programs with generic costs or constraints.</p>
<p>kLCP : Linear Complementarity Programs. Programs with linear complementary</p>
</div></blockquote>
<p>constraints and no cost.</p>
<blockquote>
<div>kUnknown : Does not fall into any of the types above.</div></blockquote>
<dl class="method">
<dt id="pydrake.solvers.ProgramType.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.ProgramType</em>, <em>value: int</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.ProgramType.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.ProgramType.kCGP">
<code class="descname">kCGP</code><em class="property"> = &lt;ProgramType.kCGP: 5&gt;</em><a class="headerlink" href="#pydrake.solvers.ProgramType.kCGP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.ProgramType.kGP">
<code class="descname">kGP</code><em class="property"> = &lt;ProgramType.kGP: 4&gt;</em><a class="headerlink" href="#pydrake.solvers.ProgramType.kGP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.ProgramType.kLCP">
<code class="descname">kLCP</code><em class="property"> = &lt;ProgramType.kLCP: 12&gt;</em><a class="headerlink" href="#pydrake.solvers.ProgramType.kLCP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.ProgramType.kLP">
<code class="descname">kLP</code><em class="property"> = &lt;ProgramType.kLP: 0&gt;</em><a class="headerlink" href="#pydrake.solvers.ProgramType.kLP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.ProgramType.kMILP">
<code class="descname">kMILP</code><em class="property"> = &lt;ProgramType.kMILP: 6&gt;</em><a class="headerlink" href="#pydrake.solvers.ProgramType.kMILP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.ProgramType.kMIQP">
<code class="descname">kMIQP</code><em class="property"> = &lt;ProgramType.kMIQP: 7&gt;</em><a class="headerlink" href="#pydrake.solvers.ProgramType.kMIQP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.ProgramType.kMISDP">
<code class="descname">kMISDP</code><em class="property"> = &lt;ProgramType.kMISDP: 9&gt;</em><a class="headerlink" href="#pydrake.solvers.ProgramType.kMISDP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.ProgramType.kMISOCP">
<code class="descname">kMISOCP</code><em class="property"> = &lt;ProgramType.kMISOCP: 8&gt;</em><a class="headerlink" href="#pydrake.solvers.ProgramType.kMISOCP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.ProgramType.kNLP">
<code class="descname">kNLP</code><em class="property"> = &lt;ProgramType.kNLP: 11&gt;</em><a class="headerlink" href="#pydrake.solvers.ProgramType.kNLP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.ProgramType.kQP">
<code class="descname">kQP</code><em class="property"> = &lt;ProgramType.kQP: 1&gt;</em><a class="headerlink" href="#pydrake.solvers.ProgramType.kQP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.ProgramType.kQuadraticCostConicConstraint">
<code class="descname">kQuadraticCostConicConstraint</code><em class="property"> = &lt;ProgramType.kQuadraticCostConicConstraint: 10&gt;</em><a class="headerlink" href="#pydrake.solvers.ProgramType.kQuadraticCostConicConstraint" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.ProgramType.kSDP">
<code class="descname">kSDP</code><em class="property"> = &lt;ProgramType.kSDP: 3&gt;</em><a class="headerlink" href="#pydrake.solvers.ProgramType.kSDP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.ProgramType.kSOCP">
<code class="descname">kSOCP</code><em class="property"> = &lt;ProgramType.kSOCP: 2&gt;</em><a class="headerlink" href="#pydrake.solvers.ProgramType.kSOCP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.ProgramType.kUnknown">
<code class="descname">kUnknown</code><em class="property"> = &lt;ProgramType.kUnknown: 13&gt;</em><a class="headerlink" href="#pydrake.solvers.ProgramType.kUnknown" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.ProgramType.name">
<code class="descname">name</code><a class="headerlink" href="#pydrake.solvers.ProgramType.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.ProgramType.value">
<code class="descname">value</code><a class="headerlink" href="#pydrake.solvers.ProgramType.value" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.PyFunctionConstraint">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">PyFunctionConstraint</code><a class="headerlink" href="#pydrake.solvers.PyFunctionConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.Constraint" title="pydrake.solvers.Constraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Constraint</span></code></a></p>
<p>Constraint with its evaluator as a Python function</p>
<dl class="attribute">
<dt id="pydrake.solvers.PyFunctionConstraint.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.solvers.PyFunctionConstraint.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.PyFunctionConstraint.set_bounds">
<code class="descname">set_bounds</code><span class="sig-paren">(</span><em>self: pydrake.solvers.PyFunctionConstraint, lower_bound: numpy.ndarray[numpy.float64[m, 1]], upper_bound: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.PyFunctionConstraint.set_bounds" title="Permalink to this definition">¶</a></dt>
<dd><p>Set both the lower and upper bounds of the constraint.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.PyFunctionConstraint.UpdateLowerBound">
<code class="descname">UpdateLowerBound</code><span class="sig-paren">(</span><em>self: pydrake.solvers.PyFunctionConstraint, new_lb: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.PyFunctionConstraint.UpdateLowerBound" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the lower bound of the constraint.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.PyFunctionConstraint.UpdateUpperBound">
<code class="descname">UpdateUpperBound</code><span class="sig-paren">(</span><em>self: pydrake.solvers.PyFunctionConstraint, new_ub: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.PyFunctionConstraint.UpdateUpperBound" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the upper bound of the constraint.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.QuadraticConstraint">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">QuadraticConstraint</code><a class="headerlink" href="#pydrake.solvers.QuadraticConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.Constraint" title="pydrake.solvers.Constraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Constraint</span></code></a></p>
<p>lb ≤ .5 xᵀQx + bᵀx ≤ ub Without loss of generality, the class stores a
symmetric matrix Q. For a non-symmetric matrix Q₀, we can define Q =
(Q₀ + Q₀ᵀ) / 2, since xᵀQ₀x = xᵀQ₀ᵀx = xᵀ*(Q₀+Q₀ᵀ)/2 <a href="#id45"><span class="problematic" id="id46">*</span></a>x. The first
equality holds because the transpose of a scalar is the scalar itself.
Hence we can always convert a non-symmetric matrix Q₀ to a symmetric
matrix Q.</p>
<dl class="method">
<dt id="pydrake.solvers.QuadraticConstraint.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.QuadraticConstraint, Q0: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[m, 1]], lb: float, ub: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.QuadraticConstraint.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a quadratic constraint.</p>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">DerivedQ</span></code>:</dt>
<dd>The type for Q.</dd>
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">Derivedb</span></code>:</dt>
<dd>The type for b.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Q0</span></code>:</dt>
<dd>The square matrix. Notice that Q₀ does not have to be symmetric.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>:</dt>
<dd>The linear coefficient.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lb</span></code>:</dt>
<dd>The lower bound.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">ub</span></code>:</dt>
<dd>The upper bound.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.QuadraticConstraint.b">
<code class="descname">b</code><span class="sig-paren">(</span><em>self: pydrake.solvers.QuadraticConstraint</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.solvers.QuadraticConstraint.b" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.QuadraticConstraint.Q">
<code class="descname">Q</code><span class="sig-paren">(</span><em>self: pydrake.solvers.QuadraticConstraint</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, n]]<a class="headerlink" href="#pydrake.solvers.QuadraticConstraint.Q" title="Permalink to this definition">¶</a></dt>
<dd><p>The symmetric matrix Q, being the Hessian of this constraint.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.QuadraticCost">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">QuadraticCost</code><a class="headerlink" href="#pydrake.solvers.QuadraticCost" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.Cost" title="pydrake.solvers.Cost"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Cost</span></code></a></p>
<p>Implements a cost of the form</p>
<div class="math notranslate nohighlight">
\[.5 x'Qx + b'x + c\]</div>
<p>.</p>
<dl class="method">
<dt id="pydrake.solvers.QuadraticCost.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.QuadraticCost, Q: numpy.ndarray[numpy.float64[m, n]], b: numpy.ndarray[numpy.float64[m, 1]], c: float, is_convex: Optional[bool] = None</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.QuadraticCost.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a cost of the form</p>
<div class="math notranslate nohighlight">
\[.5 x'Qx + b'x + c\]</div>
<p>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Q</span></code>:</dt>
<dd>Quadratic term.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>:</dt>
<dd>Linear term.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">c</span></code>:</dt>
<dd>(optional) Constant term.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">is_hessian_psd</span></code>:</dt>
<dd>(optional) Indicates if the Hessian matrix Q is positive
semidefinite (psd) or not. If set to true, then the user
guarantees that Q is psd; if set to false, then the user
guarantees that Q is not psd. If set to std::nullopt, then the
constructor will check if Q is psd or not. The default is
std::nullopt. To speed up the constructor, set is_hessian_psd to
either true or false.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.QuadraticCost.b">
<code class="descname">b</code><span class="sig-paren">(</span><em>self: pydrake.solvers.QuadraticCost</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.solvers.QuadraticCost.b" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.QuadraticCost.c">
<code class="descname">c</code><span class="sig-paren">(</span><em>self: pydrake.solvers.QuadraticCost</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.solvers.QuadraticCost.c" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.QuadraticCost.is_convex">
<code class="descname">is_convex</code><span class="sig-paren">(</span><em>self: pydrake.solvers.QuadraticCost</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.solvers.QuadraticCost.is_convex" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if this cost is convex. A quadratic cost if convex if and
only if its Hessian matrix Q is positive semidefinite.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.QuadraticCost.Q">
<code class="descname">Q</code><span class="sig-paren">(</span><em>self: pydrake.solvers.QuadraticCost</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, n]]<a class="headerlink" href="#pydrake.solvers.QuadraticCost.Q" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the symmetric matrix Q, as the Hessian of the cost.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.QuadraticCost.UpdateCoefficients">
<code class="descname">UpdateCoefficients</code><span class="sig-paren">(</span><em>self: pydrake.solvers.QuadraticCost, new_Q: numpy.ndarray[numpy.float64[m, n]], new_b: numpy.ndarray[numpy.float64[m, 1]], new_c: float = 0, is_convex: Optional[bool] = None</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.QuadraticCost.UpdateCoefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the quadratic and linear term of the constraint. The new
matrices need to have the same dimension as before.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_Q</span></code>:</dt>
<dd>New quadratic term.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_b</span></code>:</dt>
<dd>New linear term.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_c</span></code>:</dt>
<dd>(optional) New constant term.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">is_hessian_psd</span></code>:</dt>
<dd>(optional) Indicates if the Hessian matrix Q is positive
semidefinite (psd) or not. If set to true, then the user
guarantees that Q is psd; if set to false, then the user
guarantees that Q is not psd. If set to std::nullopt, then this
function will check if Q is psd or not. The default is
std::nullopt. To speed up the computation, set is_hessian_psd to
either true or false.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.RemoveFreeVariableMethod">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">RemoveFreeVariableMethod</code><a class="headerlink" href="#pydrake.solvers.RemoveFreeVariableMethod" title="Permalink to this definition">¶</a></dt>
<dd><p>SDPA format doesn’t accept free variables, namely the problem it
solves is in this form P1</p>
<p>max tr(C * X) s.t tr(Aᵢ*X) = aᵢ X ≽ 0.</p>
<p>Notice that the decision variable X has to be in the proper cone X ≽
0, and it doesn’t accept free variable (without the conic constraint).
On the other hand, most real-world applications require free
variables, namely problems in this form P2</p>
<p>max tr(C * X) + dᵀs s.t tr(Aᵢ*X) + bᵢᵀs = aᵢ X ≽ 0 s is free.</p>
<p>In order to remove the free variables, we consider three approaches.
1. Replace a free variable s with two variables s = p - q, p ≥ 0, q ≥
0. 2. First write the dual of the problem P2 as D2</p>
<p>min aᵀy s.t ∑ᵢ yᵢAᵢ - C = Z Z ≽ 0 Bᵀ * y = d,</p>
<p>where bᵢᵀ is the i’th row of B. The last constraint Bᵀ * y = d means y
= ŷ + Nt, where Bᵀ * ŷ = d, and N is the null space of Bᵀ. Hence, D2
is equivalent to the following problem, D3</p>
<p>min aᵀNt + aᵀŷ s.t ∑ᵢ tᵢFᵢ - (C -∑ᵢ ŷᵢAᵢ) = Z Z ≽ 0,</p>
<p>where Fᵢ = ∑ⱼ NⱼᵢAⱼ. D3 is the dual of the following primal problem P3
without free variables</p>
<p>max tr((C-∑ᵢ ŷᵢAᵢ)*X̂) + aᵀŷ s.t tr(FᵢX̂) = (Nᵀa)(i) X̂ ≽ 0.</p>
<p>Then (X, s) = (X̂, B⁻¹(a - tr(Aᵢ X̂))) is the solution to the original
problem P2. 3. Add a slack variable t, with the Lorentz cone
constraint t ≥ sqrt(sᵀs).</p>
<p>Members:</p>
<blockquote>
<div>kNullspace : Approach 2, reformulate the dual problem by considering the nullspace</div></blockquote>
<p>of the linear constraint in the dual.</p>
<blockquote>
<div><p>kTwoSlackVariables : Approach 1, replace a free variable s as s = y⁺ - y⁻, y⁺ ≥ 0, y⁻ ≥ 0.</p>
<p>kLorentzConeSlack : Approach 3, add a slack variable t with the lorentz cone constraint t</p>
</div></blockquote>
<p>≥ sqrt(sᵀs).</p>
<dl class="method">
<dt id="pydrake.solvers.RemoveFreeVariableMethod.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.RemoveFreeVariableMethod</em>, <em>value: int</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.RemoveFreeVariableMethod.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.RemoveFreeVariableMethod.kLorentzConeSlack">
<code class="descname">kLorentzConeSlack</code><em class="property"> = &lt;RemoveFreeVariableMethod.kLorentzConeSlack: 3&gt;</em><a class="headerlink" href="#pydrake.solvers.RemoveFreeVariableMethod.kLorentzConeSlack" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.RemoveFreeVariableMethod.kNullspace">
<code class="descname">kNullspace</code><em class="property"> = &lt;RemoveFreeVariableMethod.kNullspace: 2&gt;</em><a class="headerlink" href="#pydrake.solvers.RemoveFreeVariableMethod.kNullspace" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.RemoveFreeVariableMethod.kTwoSlackVariables">
<code class="descname">kTwoSlackVariables</code><em class="property"> = &lt;RemoveFreeVariableMethod.kTwoSlackVariables: 1&gt;</em><a class="headerlink" href="#pydrake.solvers.RemoveFreeVariableMethod.kTwoSlackVariables" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.RemoveFreeVariableMethod.name">
<code class="descname">name</code><a class="headerlink" href="#pydrake.solvers.RemoveFreeVariableMethod.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.RemoveFreeVariableMethod.value">
<code class="descname">value</code><a class="headerlink" href="#pydrake.solvers.RemoveFreeVariableMethod.value" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.RotatedLorentzConeConstraint">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">RotatedLorentzConeConstraint</code><a class="headerlink" href="#pydrake.solvers.RotatedLorentzConeConstraint" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.Constraint" title="pydrake.solvers.Constraint"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Constraint</span></code></a></p>
<p>Constraining that the linear expression <span class="math notranslate nohighlight">\(z=Ax+b\)</span> lies within
rotated Lorentz cone. A vector z ∈ ℝ ⁿ lies within rotated Lorentz
cone, if</p>
<div class="math notranslate nohighlight">
\[z_0 \ge 0\\]</div>
<p>z_1 ge 0z_0  z_1 ge z_2^2 + z_3^2 + … + z_{n-1}^2</p>
<p>where A ∈ ℝ ⁿˣᵐ, b ∈ ℝ ⁿ are given matrices.</p>
<p>For more information and visualization, please refer to
<a class="reference external" href="https://docs.mosek.com/modeling-cookbook/cqo.html">https://docs.mosek.com/modeling-cookbook/cqo.html</a> (Fig 3.1)</p>
<dl class="method">
<dt id="pydrake.solvers.RotatedLorentzConeConstraint.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.RotatedLorentzConeConstraint, A: numpy.ndarray[numpy.float64[m, n]], b: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.RotatedLorentzConeConstraint.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.RotatedLorentzConeConstraint.A">
<code class="descname">A</code><span class="sig-paren">(</span><em>self: pydrake.solvers.RotatedLorentzConeConstraint</em><span class="sig-paren">)</span> &#x2192; scipy.sparse.csc_matrix[numpy.float64]<a class="headerlink" href="#pydrake.solvers.RotatedLorentzConeConstraint.A" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for A.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.RotatedLorentzConeConstraint.b">
<code class="descname">b</code><span class="sig-paren">(</span><em>self: pydrake.solvers.RotatedLorentzConeConstraint</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.solvers.RotatedLorentzConeConstraint.b" title="Permalink to this definition">¶</a></dt>
<dd><p>Getter for b.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.RotatedLorentzConeConstraint.UpdateCoefficients">
<code class="descname">UpdateCoefficients</code><span class="sig-paren">(</span><em>self: pydrake.solvers.RotatedLorentzConeConstraint, new_A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], new_b: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.RotatedLorentzConeConstraint.UpdateCoefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Updates the coefficients, the updated constraint is z=new_A * x +
new_b in the rotated Lorentz cone.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the new_A.cols() != A.cols(), namely the variable</li>
<li>size should not change.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>new_A.rows() &gt;= 3 and new_A.rows() == new_b.rows().</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.ScsSolver">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">ScsSolver</code><a class="headerlink" href="#pydrake.solvers.ScsSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.SolverInterface" title="pydrake.solvers.SolverInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.SolverInterface</span></code></a></p>
<dl class="method">
<dt id="pydrake.solvers.ScsSolver.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.ScsSolver</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.ScsSolver.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="pydrake.solvers.ScsSolver.id">
<em class="property">static </em><code class="descname">id</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.solvers.SolverId<a class="headerlink" href="#pydrake.solvers.ScsSolver.id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.ScsSolverDetails">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">ScsSolverDetails</code><a class="headerlink" href="#pydrake.solvers.ScsSolverDetails" title="Permalink to this definition">¶</a></dt>
<dd><p>The SCS solver details after calling Solve() function. The user can
call MathematicalProgramResult::get_solver_details&lt;ScsSolver&gt;() to
obtain the details.</p>
<dl class="attribute">
<dt id="pydrake.solvers.ScsSolverDetails.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.solvers.ScsSolverDetails.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.ScsSolverDetails.dual_objective">
<code class="descname">dual_objective</code><a class="headerlink" href="#pydrake.solvers.ScsSolverDetails.dual_objective" title="Permalink to this definition">¶</a></dt>
<dd><p>Dual objective value at termination. Equal to SCS_INFO.dobj</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.ScsSolverDetails.duality_gap">
<code class="descname">duality_gap</code><a class="headerlink" href="#pydrake.solvers.ScsSolverDetails.duality_gap" title="Permalink to this definition">¶</a></dt>
<dd><p>duality gap. Equal to SCS_INFO.gap.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.ScsSolverDetails.iter">
<code class="descname">iter</code><a class="headerlink" href="#pydrake.solvers.ScsSolverDetails.iter" title="Permalink to this definition">¶</a></dt>
<dd><p>These are the information returned by SCS at termination, please refer
to “SCS_INFO” struct in
<a class="reference external" href="https://github.com/cvxgrp/scs/blob/master/include/scs.h">https://github.com/cvxgrp/scs/blob/master/include/scs.h</a> Number of
iterations taken at termination. Equal to SCS_INFO.iter</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.ScsSolverDetails.primal_objective">
<code class="descname">primal_objective</code><a class="headerlink" href="#pydrake.solvers.ScsSolverDetails.primal_objective" title="Permalink to this definition">¶</a></dt>
<dd><p>Primal objective value at termination. Equal to SCS_INFO.pobj</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.ScsSolverDetails.primal_residue">
<code class="descname">primal_residue</code><a class="headerlink" href="#pydrake.solvers.ScsSolverDetails.primal_residue" title="Permalink to this definition">¶</a></dt>
<dd><p>Primal equality residue. Equal to SCS_INFO.res_pri</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.ScsSolverDetails.residue_infeasibility">
<code class="descname">residue_infeasibility</code><a class="headerlink" href="#pydrake.solvers.ScsSolverDetails.residue_infeasibility" title="Permalink to this definition">¶</a></dt>
<dd><p>infeasibility certificate residue. Equal to SCS_INFO.res_infeas</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.ScsSolverDetails.residue_unbounded_a">
<code class="descname">residue_unbounded_a</code><a class="headerlink" href="#pydrake.solvers.ScsSolverDetails.residue_unbounded_a" title="Permalink to this definition">¶</a></dt>
<dd><p>unbounded certificate residue. Equal to SCS_INFO.res_unbdd_a</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.ScsSolverDetails.residue_unbounded_p">
<code class="descname">residue_unbounded_p</code><a class="headerlink" href="#pydrake.solvers.ScsSolverDetails.residue_unbounded_p" title="Permalink to this definition">¶</a></dt>
<dd><p>unbounded certificate residue. Equal to SCS_INFO.res_unbdd_p</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.ScsSolverDetails.s">
<code class="descname">s</code><a class="headerlink" href="#pydrake.solvers.ScsSolverDetails.s" title="Permalink to this definition">¶</a></dt>
<dd><p>The primal equality constraint slack, namely Ax + s = b where x is the
primal variable.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.ScsSolverDetails.scs_setup_time">
<code class="descname">scs_setup_time</code><a class="headerlink" href="#pydrake.solvers.ScsSolverDetails.scs_setup_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Time taken for SCS to setup in milliseconds. Equal to
SCS_INFO.setup_time.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.ScsSolverDetails.scs_solve_time">
<code class="descname">scs_solve_time</code><a class="headerlink" href="#pydrake.solvers.ScsSolverDetails.scs_solve_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Time taken for SCS to solve in millisecond. Equal to
SCS_INFO.solve_time.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.ScsSolverDetails.scs_status">
<code class="descname">scs_status</code><a class="headerlink" href="#pydrake.solvers.ScsSolverDetails.scs_status" title="Permalink to this definition">¶</a></dt>
<dd><p>The status of the solver at termination. Please refer to
<a class="reference external" href="https://github.com/cvxgrp/scs/blob/master/include/glbopts.h">https://github.com/cvxgrp/scs/blob/master/include/glbopts.h</a> Note that
the SCS code on github master might be slightly more up-to-date than
the version used in Drake.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.ScsSolverDetails.y">
<code class="descname">y</code><a class="headerlink" href="#pydrake.solvers.ScsSolverDetails.y" title="Permalink to this definition">¶</a></dt>
<dd><p>The dual variable values at termination.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.SnoptSolver">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">SnoptSolver</code><a class="headerlink" href="#pydrake.solvers.SnoptSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.SolverInterface" title="pydrake.solvers.SolverInterface"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.SolverInterface</span></code></a></p>
<p>An implementation of SolverInterface for the commercially-licensed
SNOPT solver (<a class="reference external" href="https://ccom.ucsd.edu/~optimizers/solvers/snopt/">https://ccom.ucsd.edu/~optimizers/solvers/snopt/</a>).</p>
<p>Builds of Drake from source do not compile SNOPT by default, so
therefore SolverInterface::available() will return false. You must
opt-in to build SNOPT per the documentation at
<a class="reference external" href="https://drake.mit.edu/bazel.html#snopt">https://drake.mit.edu/bazel.html#snopt</a>.</p>
<p><a class="reference external" href="https://drake.mit.edu/installation.html">Drake’s pre-compiled binary releases</a> do incorporate SNOPT, so
therefore SolverInterface::available() will return true. Thanks to
Philip E. Gill and Elizabeth Wong for their kind support.</p>
<p>There is no license configuration required to use SNOPT, so
SolverInterface::enabled() will always return true.</p>
<dl class="method">
<dt id="pydrake.solvers.SnoptSolver.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.SnoptSolver</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.SnoptSolver.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="pydrake.solvers.SnoptSolver.id">
<em class="property">static </em><code class="descname">id</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.solvers.SolverId<a class="headerlink" href="#pydrake.solvers.SnoptSolver.id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.SnoptSolverDetails">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">SnoptSolverDetails</code><a class="headerlink" href="#pydrake.solvers.SnoptSolverDetails" title="Permalink to this definition">¶</a></dt>
<dd><p>The SNOPT solver details after calling Solve() function. The user can
call MathematicalProgramResult::get_solver_details&lt;SnoptSolver&gt;() to
obtain the details.</p>
<dl class="attribute">
<dt id="pydrake.solvers.SnoptSolverDetails.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.solvers.SnoptSolverDetails.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.SnoptSolverDetails.F">
<code class="descname">F</code><a class="headerlink" href="#pydrake.solvers.SnoptSolverDetails.F" title="Permalink to this definition">¶</a></dt>
<dd><p>The final value of the vector of problem functions F(x).</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.SnoptSolverDetails.Fmul">
<code class="descname">Fmul</code><a class="headerlink" href="#pydrake.solvers.SnoptSolverDetails.Fmul" title="Permalink to this definition">¶</a></dt>
<dd><p>The final value of the dual variables (Lagrange multipliers) for the
general constraints F_lower &lt;= F(x) &lt;= F_upper.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.SnoptSolverDetails.info">
<code class="descname">info</code><a class="headerlink" href="#pydrake.solvers.SnoptSolverDetails.info" title="Permalink to this definition">¶</a></dt>
<dd><p>The snopt INFO field. Please refer to section 8.6 in “User’s Guide for
SNOPT Version 7: Software for Large-Scale Nonlinear Programming”
(<a class="reference external" href="https://web.stanford.edu/group/SOL/guides/sndoc7.pdf">https://web.stanford.edu/group/SOL/guides/sndoc7.pdf</a>) by Philip E.
Gill to interpret the INFO field.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.SnoptSolverDetails.xmul">
<code class="descname">xmul</code><a class="headerlink" href="#pydrake.solvers.SnoptSolverDetails.xmul" title="Permalink to this definition">¶</a></dt>
<dd><p>The final value of the dual variables for the bound constraint x_lower
&lt;= x &lt;= x_upper.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.SolutionResult">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">SolutionResult</code><a class="headerlink" href="#pydrake.solvers.SolutionResult" title="Permalink to this definition">¶</a></dt>
<dd><p>Members:</p>
<blockquote>
<div><p>kSolutionFound : Found the optimal solution.</p>
<p>kInvalidInput : Invalid input.</p>
<p>kInfeasibleConstraints : The primal is infeasible.</p>
<p>kUnbounded : The primal is unbounded.</p>
<p>kUnknownError : Unknown error.</p>
<p>kInfeasibleOrUnbounded :</p>
<p>kIterationLimit : Reaches the iteration limits.</p>
<p>kDualInfeasible : Dual problem is infeasible. In this case we cannot</p>
</div></blockquote>
<dl class="method">
<dt id="pydrake.solvers.SolutionResult.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.SolutionResult</em>, <em>value: int</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.SolutionResult.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.SolutionResult.kDualInfeasible">
<code class="descname">kDualInfeasible</code><em class="property"> = &lt;SolutionResult.kDualInfeasible: -7&gt;</em><a class="headerlink" href="#pydrake.solvers.SolutionResult.kDualInfeasible" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.SolutionResult.kInfeasibleConstraints">
<code class="descname">kInfeasibleConstraints</code><em class="property"> = &lt;SolutionResult.kInfeasibleConstraints: -2&gt;</em><a class="headerlink" href="#pydrake.solvers.SolutionResult.kInfeasibleConstraints" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.SolutionResult.kInfeasibleOrUnbounded">
<code class="descname">kInfeasibleOrUnbounded</code><em class="property"> = &lt;SolutionResult.kInfeasibleOrUnbounded: -5&gt;</em><a class="headerlink" href="#pydrake.solvers.SolutionResult.kInfeasibleOrUnbounded" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.SolutionResult.kInvalidInput">
<code class="descname">kInvalidInput</code><em class="property"> = &lt;SolutionResult.kInvalidInput: -1&gt;</em><a class="headerlink" href="#pydrake.solvers.SolutionResult.kInvalidInput" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.SolutionResult.kIterationLimit">
<code class="descname">kIterationLimit</code><em class="property"> = &lt;SolutionResult.kIterationLimit: -6&gt;</em><a class="headerlink" href="#pydrake.solvers.SolutionResult.kIterationLimit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.SolutionResult.kSolutionFound">
<code class="descname">kSolutionFound</code><em class="property"> = &lt;SolutionResult.kSolutionFound: 0&gt;</em><a class="headerlink" href="#pydrake.solvers.SolutionResult.kSolutionFound" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.SolutionResult.kUnbounded">
<code class="descname">kUnbounded</code><em class="property"> = &lt;SolutionResult.kUnbounded: -3&gt;</em><a class="headerlink" href="#pydrake.solvers.SolutionResult.kUnbounded" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.SolutionResult.kUnknownError">
<code class="descname">kUnknownError</code><em class="property"> = &lt;SolutionResult.kUnknownError: -4&gt;</em><a class="headerlink" href="#pydrake.solvers.SolutionResult.kUnknownError" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.SolutionResult.name">
<code class="descname">name</code><a class="headerlink" href="#pydrake.solvers.SolutionResult.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.SolutionResult.value">
<code class="descname">value</code><a class="headerlink" href="#pydrake.solvers.SolutionResult.value" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="pydrake.solvers.Solve">
<code class="descclassname">pydrake.solvers.</code><code class="descname">Solve</code><span class="sig-paren">(</span><em>prog: pydrake.solvers.MathematicalProgram</em>, <em>initial_guess: Optional[numpy.ndarray[numpy.float64[m</em>, <em>1]]] = None</em>, <em>solver_options: Optional[pydrake.solvers.SolverOptions] = None</em><span class="sig-paren">)</span> &#x2192; pydrake.solvers.MathematicalProgramResult<a class="headerlink" href="#pydrake.solvers.Solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves an optimization program, with optional initial guess and solver
options. This function first chooses the best solver depending on the
availability of the solver and the program formulation; it then
constructs that solver and call the Solve function of that solver. The
optimization result is stored in the return argument.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">prog</span></code>:</dt>
<dd>Contains the formulation of the program, and possibly solver
options.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">initial_guess</span></code>:</dt>
<dd>The initial guess for the decision variables.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">solver_options</span></code>:</dt>
<dd>The options in addition to those stored in <code class="docutils literal notranslate"><span class="pre">prog</span></code>. For each
option entry (like print out), there are 4 ways to set that
option, and the priority given to the solver options is as follows
(from lowest / least, to highest / most): 1. common option set on
the MathematicalProgram itself 2. common option passed as an
argument to Solve 3. solver-specific option set on the
MathematicalProgram itself 4. solver-specific option passed as an
argument to Solve</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">result The result of solving the program through the solver.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.SolverId">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">SolverId</code><a class="headerlink" href="#pydrake.solvers.SolverId" title="Permalink to this definition">¶</a></dt>
<dd><p>Identifies a SolverInterface implementation.</p>
<p>A moved-from instance is guaranteed to be empty and will not compare
equal to any non-empty ID.</p>
<dl class="method">
<dt id="pydrake.solvers.SolverId.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.SolverId</em>, <em>name: str</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.SolverId.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a specific, known solver type. Internally, a hidden
identifier is allocated and assigned to this instance; all instances
that share an identifier (including copies of this instance) are
considered equal. The solver names are not enforced to be unique,
though we recommend that they remain so in practice.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.SolverId.name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self: pydrake.solvers.SolverId</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.solvers.SolverId.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.SolverInterface">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">SolverInterface</code><a class="headerlink" href="#pydrake.solvers.SolverInterface" title="Permalink to this definition">¶</a></dt>
<dd><p>Interface used by implementations of individual solvers.</p>
<dl class="method">
<dt id="pydrake.solvers.SolverInterface.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.SolverInterface</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.SolverInterface.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.SolverInterface.AreProgramAttributesSatisfied">
<code class="descname">AreProgramAttributesSatisfied</code><span class="sig-paren">(</span><em>self: pydrake.solvers.SolverInterface</em>, <em>prog: drake::solvers::MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.solvers.SolverInterface.AreProgramAttributesSatisfied" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true iff the program’s attributes are compatible with this
solver’s capabilities.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.SolverInterface.available">
<code class="descname">available</code><span class="sig-paren">(</span><em>self: pydrake.solvers.SolverInterface</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.solvers.SolverInterface.available" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true iff support for this solver has been compiled into Drake.
When this method returns false, the Solve method will throw.</p>
<p>Most solver implementations will always return true, but certain
solvers may have been excluded at compile-time due to licensing
restrictions, or to narrow Drake’s dependency footprint. In Drake’s
default build, only commercially-licensed solvers might return false.</p>
<p>Contrast this with enabled(), which reflects whether a solver has been
configured for use at runtime (not compile-time).</p>
<p>For details on linking commercial solvers, refer to the solvers’ class
overview documentation, e.g., SnoptSolver, MosekSolver, GurobiSolver.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.SolverInterface.enabled">
<code class="descname">enabled</code><span class="sig-paren">(</span><em>self: pydrake.solvers.SolverInterface</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.solvers.SolverInterface.enabled" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true iff this solver is properly configured for use at
runtime. When this method returns false, the Solve method will throw.</p>
<p>Most solver implementation will always return true, but certain
solvers require additional configuration before they may be used,
e.g., setting an environment variable to specify a license file or
license server. In Drake’s default build, only commercially-licensed
solvers might return false.</p>
<p>Contrast this with available(), which reflects whether a solver has
been incorporated into Drake at compile-time (and has nothing to do
with the runtime configuration). A solver where available() returns
false may still return true for enabled() if it is properly
configured.</p>
<p>The mechanism to configure a particular solver implementation is
specific to the solver in question, but typically uses an environment
variable. For details on configuring commercial solvers, refer to the
solvers’ class overview documentation, e.g., SnoptSolver, MosekSolver,
GurobiSolver.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.SolverInterface.ExplainUnsatisfiedProgramAttributes">
<code class="descname">ExplainUnsatisfiedProgramAttributes</code><span class="sig-paren">(</span><em>self: pydrake.solvers.SolverInterface</em>, <em>prog: drake::solvers::MathematicalProgram</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.solvers.SolverInterface.ExplainUnsatisfiedProgramAttributes" title="Permalink to this definition">¶</a></dt>
<dd><p>Describes the reasons (if any) why the program is incompatible with
this solver’s capabilities. If AreProgramAttributesSatisfied would
return true for the program, then this function returns the empty
string.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.SolverInterface.Solve">
<code class="descname">Solve</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.SolverInterface.Solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>Solve(self: pydrake.solvers.SolverInterface, prog: drake::solvers::MathematicalProgram, initial_guess: Optional[numpy.ndarray[numpy.float64[m, 1]]], solver_options: Optional[drake::solvers::SolverOptions], result: drake::solvers::MathematicalProgramResult) -&gt; None</li>
</ol>
<p>Solves an optimization program with optional initial guess and solver
options. Note that these initial guess and solver options are not
written to <code class="docutils literal notranslate"><span class="pre">prog</span></code>. If the <code class="docutils literal notranslate"><span class="pre">prog</span></code> has set an option for a solver,
and <code class="docutils literal notranslate"><span class="pre">solver_options</span></code> contains a different value for the same option
on the same solver, then <code class="docutils literal notranslate"><span class="pre">solver_options</span></code> takes priority. Derived
implementations of this interface may elect to throw RuntimeError for
badly formed programs.</p>
<ol class="arabic simple" start="2">
<li>Solve(self: pydrake.solvers.SolverInterface, prog: drake::solvers::MathematicalProgram, initial_guess: Optional[numpy.ndarray[numpy.float64[m, 1]]] = None, solver_options: Optional[drake::solvers::SolverOptions] = None) -&gt; drake::solvers::MathematicalProgramResult</li>
</ol>
<p>Like SolverInterface::Solve(), but the result is a return value
instead of an output argument.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.SolverInterface.solver_id">
<code class="descname">solver_id</code><span class="sig-paren">(</span><em>self: pydrake.solvers.SolverInterface</em><span class="sig-paren">)</span> &#x2192; drake::solvers::SolverId<a class="headerlink" href="#pydrake.solvers.SolverInterface.solver_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the identifier of this solver.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.SolverInterface.solver_type">
<code class="descname">solver_type</code><span class="sig-paren">(</span><em>self: pydrake.solvers.SolverInterface</em><span class="sig-paren">)</span> &#x2192; Optional[drake::solvers::SolverType]<a class="headerlink" href="#pydrake.solvers.SolverInterface.solver_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.SolverInterface.SolverName">
<code class="descname">SolverName</code><span class="sig-paren">(</span><em>self: pydrake.solvers.SolverInterface</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.solvers.SolverInterface.SolverName" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.SolverOptions">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">SolverOptions</code><a class="headerlink" href="#pydrake.solvers.SolverOptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Stores options for multiple solvers. This interface does not do any
verification of solver parameters. It does not even verify that the
specified solver exists. Use this only when you have particular
knowledge of what solver is being invoked, and exactly what tuning is
required.</p>
<p>Supported solver names/options:</p>
<p>“SNOPT” – Parameter names and values as specified in SNOPT User’s
Guide section 7.7 “Description of the optional parameters”, used as
described in section 7.5 for snSet(). The SNOPT user guide can be
obtained from <a class="reference external" href="https://web.stanford.edu/group/SOL/guides/sndoc7.pdf">https://web.stanford.edu/group/SOL/guides/sndoc7.pdf</a></p>
<p>“IPOPT” – Parameter names and values as specified in IPOPT users
guide section “Options Reference”
<a class="reference external" href="http://www.coin-or.org/Ipopt/documentation/node40.html">http://www.coin-or.org/Ipopt/documentation/node40.html</a></p>
<p>“GUROBI” – Parameter name and values as specified in Gurobi Reference
Manual, section 10.2 “Parameter Descriptions”
<a class="reference external" href="https://www.gurobi.com/documentation/9.5/refman/parameters.html">https://www.gurobi.com/documentation/9.5/refman/parameters.html</a></p>
<p>“SCS” – Parameter name and values as specified in the struct
SCS_SETTINGS in SCS header file
<a class="reference external" href="https://github.com/cvxgrp/scs/blob/master/include/scs.h">https://github.com/cvxgrp/scs/blob/master/include/scs.h</a> Note that the
SCS code on github master might be more up-to-date than the version
used in Drake.</p>
<p>“MOSEK<a href="/tm.html">™</a>” – Parameter name and values as specified in Mosek Reference
<a class="reference external" href="https://docs.mosek.com/9.3/capi/parameters.html">https://docs.mosek.com/9.3/capi/parameters.html</a></p>
<p>“OSQP” – Parameter name and values as specified in OSQP Reference
<a class="reference external" href="https://osqp.org/docs/interfaces/solver_settings.html#solver-settings">https://osqp.org/docs/interfaces/solver_settings.html#solver-settings</a></p>
<p>“dReal” – Parameter name and values as specified in dReal Reference
<a class="reference external" href="https://github.com/dreal/dreal4/blob/master/README.md#command-line-options">https://github.com/dreal/dreal4/blob/master/README.md#command-line-options</a>.
Note that Drake only supports a subset of the options listed in the
reference.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">DrealSolver for the subset of these options supported by the
solver interface.</p>
</div>
<p>“IBEX” – Parameter name and values as specified in IBEX Reference
<a class="reference external" href="http://www.ibex-lib.org/doc/optim.html?highlight=eps#options">http://www.ibex-lib.org/doc/optim.html?highlight=eps#options</a>. Note
that Drake only supports a subset of the options listed in the
reference.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">IbexSolver for the subset of these options supported by the solver
interface.</p>
</div>
<dl class="method">
<dt id="pydrake.solvers.SolverOptions.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.SolverOptions</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.SolverOptions.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.SolverOptions.common_solver_options">
<code class="descname">common_solver_options</code><span class="sig-paren">(</span><em>self: pydrake.solvers.SolverOptions</em><span class="sig-paren">)</span> &#x2192; Dict[drake::solvers::CommonSolverOption, Union[float, int, str]]<a class="headerlink" href="#pydrake.solvers.SolverOptions.common_solver_options" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the common options for all solvers. Refer to CommonSolverOption
for more details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.SolverOptions.get_print_file_name">
<code class="descname">get_print_file_name</code><span class="sig-paren">(</span><em>self: pydrake.solvers.SolverOptions</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.solvers.SolverOptions.get_print_file_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the kPrintFileName set via CommonSolverOption, or else an
empty string if the option has not been set.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.SolverOptions.get_print_to_console">
<code class="descname">get_print_to_console</code><span class="sig-paren">(</span><em>self: pydrake.solvers.SolverOptions</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.solvers.SolverOptions.get_print_to_console" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the kPrintToConsole set via CommonSolverOption, or else false
if the option has not been set.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.solvers.SolverOptions.GetOptions">
<code class="descname">GetOptions</code><span class="sig-paren">(</span><em>self: pydrake.solvers.SolverOptions</em>, <em>solver_id: pydrake.solvers.SolverId</em><span class="sig-paren">)</span> &#x2192; dict<a class="headerlink" href="#pydrake.solvers.SolverOptions.GetOptions" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.solvers.SolverOptions.SetOption">
<code class="descname">SetOption</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.solvers.SolverOptions.SetOption" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>SetOption(self: pydrake.solvers.SolverOptions, solver_id: pydrake.solvers.SolverId, solver_option: str, option_value: float) -&gt; None</li>
</ol>
<p>Sets a double-valued solver option for a specific solver.</p>
<ol class="arabic simple" start="2">
<li>SetOption(self: pydrake.solvers.SolverOptions, solver_id: pydrake.solvers.SolverId, solver_option: str, option_value: int) -&gt; None</li>
</ol>
<p>Sets an integer-valued solver option for a specific solver.</p>
<ol class="arabic simple" start="3">
<li>SetOption(self: pydrake.solvers.SolverOptions, solver_id: pydrake.solvers.SolverId, solver_option: str, option_value: str) -&gt; None</li>
</ol>
<p>Sets a string-valued solver option for a specific solver.</p>
<ol class="arabic simple" start="4">
<li>SetOption(self: pydrake.solvers.SolverOptions, key: drake::solvers::CommonSolverOption, value: Union[float, int, str]) -&gt; None</li>
</ol>
<p>Sets a common option for all solvers supporting that option (for
example, printing the progress in each iteration). If the solver
doesn’t support the option, the option is ignored.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.SolverType">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">SolverType</code><a class="headerlink" href="#pydrake.solvers.SolverType" title="Permalink to this definition">¶</a></dt>
<dd><p>This type only exists for backwards compatiblity, and should not be
used in new code.</p>
<p>Members:</p>
<blockquote>
<div><p>kClp :</p>
<p>kCsdp :</p>
<p>kDReal :</p>
<p>kEqualityConstrainedQP :</p>
<p>kGurobi :</p>
<p>kIbex :</p>
<p>kIpopt :</p>
<p>kLinearSystem :</p>
<p>kMobyLCP :</p>
<p>kMosek :</p>
<p>kNlopt :</p>
<p>kOsqp :</p>
<p>kScs :</p>
<p>kSnopt :</p>
</div></blockquote>
<dl class="method">
<dt id="pydrake.solvers.SolverType.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.solvers.SolverType</em>, <em>value: int</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.solvers.SolverType.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.SolverType.kClp">
<code class="descname">kClp</code><em class="property"> = &lt;SolverType.kClp: 0&gt;</em><a class="headerlink" href="#pydrake.solvers.SolverType.kClp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.SolverType.kCsdp">
<code class="descname">kCsdp</code><em class="property"> = &lt;SolverType.kCsdp: 1&gt;</em><a class="headerlink" href="#pydrake.solvers.SolverType.kCsdp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.SolverType.kDReal">
<code class="descname">kDReal</code><em class="property"> = &lt;SolverType.kDReal: 2&gt;</em><a class="headerlink" href="#pydrake.solvers.SolverType.kDReal" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.SolverType.kEqualityConstrainedQP">
<code class="descname">kEqualityConstrainedQP</code><em class="property"> = &lt;SolverType.kEqualityConstrainedQP: 3&gt;</em><a class="headerlink" href="#pydrake.solvers.SolverType.kEqualityConstrainedQP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.SolverType.kGurobi">
<code class="descname">kGurobi</code><em class="property"> = &lt;SolverType.kGurobi: 4&gt;</em><a class="headerlink" href="#pydrake.solvers.SolverType.kGurobi" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.SolverType.kIbex">
<code class="descname">kIbex</code><em class="property"> = &lt;SolverType.kIbex: 5&gt;</em><a class="headerlink" href="#pydrake.solvers.SolverType.kIbex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.SolverType.kIpopt">
<code class="descname">kIpopt</code><em class="property"> = &lt;SolverType.kIpopt: 6&gt;</em><a class="headerlink" href="#pydrake.solvers.SolverType.kIpopt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.SolverType.kLinearSystem">
<code class="descname">kLinearSystem</code><em class="property"> = &lt;SolverType.kLinearSystem: 7&gt;</em><a class="headerlink" href="#pydrake.solvers.SolverType.kLinearSystem" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.SolverType.kMobyLCP">
<code class="descname">kMobyLCP</code><em class="property"> = &lt;SolverType.kMobyLCP: 8&gt;</em><a class="headerlink" href="#pydrake.solvers.SolverType.kMobyLCP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.SolverType.kMosek">
<code class="descname">kMosek</code><em class="property"> = &lt;SolverType.kMosek: 9&gt;</em><a class="headerlink" href="#pydrake.solvers.SolverType.kMosek" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.SolverType.kNlopt">
<code class="descname">kNlopt</code><em class="property"> = &lt;SolverType.kNlopt: 10&gt;</em><a class="headerlink" href="#pydrake.solvers.SolverType.kNlopt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.SolverType.kOsqp">
<code class="descname">kOsqp</code><em class="property"> = &lt;SolverType.kOsqp: 11&gt;</em><a class="headerlink" href="#pydrake.solvers.SolverType.kOsqp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.SolverType.kScs">
<code class="descname">kScs</code><em class="property"> = &lt;SolverType.kScs: 13&gt;</em><a class="headerlink" href="#pydrake.solvers.SolverType.kScs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.SolverType.kSnopt">
<code class="descname">kSnopt</code><em class="property"> = &lt;SolverType.kSnopt: 12&gt;</em><a class="headerlink" href="#pydrake.solvers.SolverType.kSnopt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.SolverType.name">
<code class="descname">name</code><a class="headerlink" href="#pydrake.solvers.SolverType.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.solvers.SolverType.value">
<code class="descname">value</code><a class="headerlink" href="#pydrake.solvers.SolverType.value" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.solvers.VisualizationCallback">
<em class="property">class </em><code class="descclassname">pydrake.solvers.</code><code class="descname">VisualizationCallback</code><a class="headerlink" href="#pydrake.solvers.VisualizationCallback" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.solvers.EvaluatorBase" title="pydrake.solvers.EvaluatorBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.EvaluatorBase</span></code></a></p>
<p>Defines a simple evaluator with no outputs that takes a callback
function pointer. This is intended for debugging / visualization of
intermediate results during an optimization (for solvers that support
it).</p>
<dl class="attribute">
<dt id="pydrake.solvers.VisualizationCallback.__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.solvers.VisualizationCallback.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="pydrake.solvers.all.html" class="btn btn-neutral float-right" title="pydrake.solvers.all" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="pydrake.polynomial.html" class="btn btn-neutral float-left" title="pydrake.polynomial" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>

    </p>
  </div>
</footer>
<script>
  /* Enables clicking for the mobile "hamburger" (three-line) menu item. */
  const siteHeader = document.querySelector('.site-header')
  const mobileButton = document.querySelector('.menu-mobile-toggle')
  const body = document.querySelector('body')

  mobileButton.addEventListener('click', function(event) {
    siteHeader.classList.toggle('open');
    body.classList.toggle('overflow-hidden');
  })
</script>
<footer class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg">
    </a>
    <div class="footer-menu">
      <ul>
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"></a>
        </li>
      </ul>
    </div>
  </div>


</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>