<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pydrake.solvers &mdash; pydrake  documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=86f27845" />
      <link rel="stylesheet" type="text/css" href="_static/css/custom.css?v=6b576c25" />

  
  
        <script src="_static/jquery.js?v=8dae8fb0"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=7f41d439"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="pydrake.symbolic" href="pydrake.symbolic.html" />
    <link rel="prev" title="pydrake.polynomial" href="pydrake.polynomial.html" /> 
</head>

<body class="wy-body-for-nav">
<header class="site-header">
  <div class="site-header-inner contain">
    <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
    <div class="menu-mobile-toggle">
      <span></span>
    </div>
    <nav class="site-menu">
      <ul>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/">Home</a>
        </li>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/installation.html">Installation</a>
        </li>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/gallery.html">Gallery</a>
        </li>
        <li class="site-menu-item site-menu-item-main">API Documentation
          <div class="sub">
            <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a> <a class="site-menu-item" href="/pydrake/index.html">Python</a>
          </div>
        </li>
        <li class="site-menu-item site-menu-item-main">Resources
          <div class="sub">
            <a class="site-menu-item" href="/getting_help.html">Getting Help</a> <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/%2Findex.ipynb">Tutorials</a> <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a> <a class="site-menu-item" href="/developers.html">For Developers</a> <a class="site-menu-item" href="/credits.html">Credits</a>
          </div>
        </li>
        <li class="github-link">
          <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
        </li>
      </ul>
    </nav>
  </div>
</header>

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            pydrake
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search pydrake only…" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
    <input type="text" name="q" placeholder="Search all of Drake…" />
    <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu" />
  </form>
</div>

        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="pydrake.all.html">pydrake.all</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.autodiffutils.html">pydrake.autodiffutils</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.common.html">pydrake.common</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.examples.html">pydrake.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.forwarddiff.html">pydrake.forwarddiff</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.geometry.html">pydrake.geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.gym.html">pydrake.gym</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.lcm.html">pydrake.lcm</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.manipulation.html">pydrake.manipulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.math.html">pydrake.math</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.multibody.html">pydrake.multibody</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.perception.html">pydrake.perception</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.planning.html">pydrake.planning</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.polynomial.html">pydrake.polynomial</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">pydrake.solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.symbolic.html">pydrake.symbolic</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.systems.html">pydrake.systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.trajectories.html">pydrake.trajectories</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.tutorials.html">pydrake.tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.visualization.html">pydrake.visualization</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pydrake</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">pydrake.solvers</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-pydrake.solvers">
<span id="pydrake-solvers"></span><h1>pydrake.solvers<a class="headerlink" href="#module-pydrake.solvers" title="Link to this heading"></a></h1>
<p>Bindings for Solving Mathematical Programs.</p>
<p>If you are formulating constraints using symbolic formulas, please review the
top-level documentation for <a class="reference internal" href="pydrake.math.html#module-pydrake.math" title="pydrake.math"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pydrake.math</span></code></a>.</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AddBilinearProductMcCormickEnvelopeSos2(prog:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">x:</span> <span class="pre">pydrake.symbolic.Variable,</span> <span class="pre">y:</span> <span class="pre">pydrake.symbolic.Variable,</span> <span class="pre">w:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">phi_x:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">phi_y:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">Bx:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]],</span> <span class="pre">By:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]],</span> <span class="pre">binning:</span> <span class="pre">pydrake.solvers.IntervalBinning)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>Add constraints to the optimization program, such that the bilinear
product x * y is approximated by w, using Special Ordered Set of Type
2 (sos2) constraint. To do so, we assume that the range of x is
[x_min, x_max], and the range of y is [y_min, y_max]. We first
consider two arrays φˣ, φʸ, satisfying</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">x_min</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">φˣ₀</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">φˣ₁</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">φˣₘ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x_max</span>
<span class="n">y_min</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">φʸ₀</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">φʸ₁</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">φʸₙ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y_max</span>
</pre></div>
</div>
</details><p>, and divide the range of x into intervals [φˣ₀, φˣ₁], [φˣ₁, φˣ₂], …
, [φˣₘ₋₁, φˣₘ] and the range of y into intervals [φʸ₀, φʸ₁], [φʸ₁,
φʸ₂], … , [φʸₙ₋₁, φʸₙ]. The xy plane is thus cut into rectangles,
with each rectangle as [φˣᵢ, φˣᵢ₊₁] x [φʸⱼ, φʸⱼ₊₁]. The convex hull of
the surface z = x * y for x, y in each rectangle is a tetrahedron. We
then approximate the bilinear product x * y with w, such that (x, y,
w) is in one of the tetrahedrons.</p>
<p>We use two different encoding schemes on the binary variables, to
determine which interval is active. We can choose either linear or
logarithmic binning. When using linear binning, for a variable with N
intervals, we use N binary variables, and B(i) = 1 indicates the
variable is in the i’th interval. When using logarithmic binning, we
use ⌈log₂(N)⌉ binary variables. If these binary variables represent
integer M in the reflected Gray code, then the continuous variable is
in the M’th interval.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">prog</span></code>:</dt><dd><p>The program to which the bilinear product constraint is added</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">x</span></code>:</dt><dd><p>The decision variable.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">y</span></code>:</dt><dd><p>The decision variable.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">w</span></code>:</dt><dd><p>The expression to approximate x * y</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">phi_x</span></code>:</dt><dd><p>The end points of the intervals for <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">phi_y</span></code>:</dt><dd><p>The end points of the intervals for <code class="docutils literal notranslate"><span class="pre">y</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Bx</span></code>:</dt><dd><p>The binary variables for the interval in which x stays encoded as
described above.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">By</span></code>:</dt><dd><p>The binary variables for the interval in which y stays encoded as
described above.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">binning</span></code>:</dt><dd><p>Determine whether to use linear binning or logarithmic binning.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>lambda The auxiliary continuous variables.</p>
</dd>
</dl>
<p>The constraints we impose are</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">φˣ</span><span class="p">)</span><span class="n">ᵀ</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="err">∑</span><span class="n">ⱼ</span><span class="w"> </span><span class="n">λᵢⱼ</span>
<span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">φʸ</span><span class="p">)</span><span class="n">ᵀ</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="err">∑</span><span class="n">ᵢ</span><span class="w"> </span><span class="n">λᵢⱼ</span>
<span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">∑</span><span class="n">ᵢⱼ</span><span class="w"> </span><span class="n">φˣᵢ</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">φʸⱼ</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">λᵢⱼ</span>
<span class="n">Both</span><span class="w"> </span><span class="err">∑</span><span class="n">ⱼ</span><span class="w"> </span><span class="n">λᵢⱼ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">λ</span><span class="p">.</span><span class="n">rowwise</span><span class="p">().</span><span class="n">sum</span><span class="p">()</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="err">∑</span><span class="n">ᵢ</span><span class="w"> </span><span class="n">λᵢⱼ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">λ</span><span class="p">.</span><span class="n">colwise</span><span class="p">().</span><span class="n">sum</span><span class="p">()</span><span class="w"> </span><span class="n">satisfy</span><span class="w"> </span><span class="n">SOS2</span>
<span class="n">constraint</span><span class="p">.</span>
</pre></div>
</div>
</details><p>If x ∈ [φx(M), φx(M+1)] and y ∈ [φy(N), φy(N+1)], then only λ(M, N),
λ(M + 1, N), λ(M, N + 1) and λ(M+1, N+1) can be strictly positive, all
other λ(i, j) are zero.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>We DO NOT add the constraint Bx(i) ∈ {0, 1}, By(j) ∈ {0, 1} in
this function. It is the user’s responsibility to ensure that
these constraints are enforced.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AddLogarithmicSos1Constraint(prog:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">num_lambda:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">tuple[numpy.ndarray[object[m,</span> <span class="pre">1]],</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]]</span></span></dt>
<dd><p>Adds the special ordered set of type 1 (SOS1) constraint. Namely</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">λ</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">λ</span><span class="p">(</span><span class="n">n</span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">  </span><span class="n">λ</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="err">≥</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="err">∀</span><span class="n">i</span>
<span class="w">  </span><span class="err">∃</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="err">∈</span><span class="w"> </span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">n</span><span class="mi">-1</span><span class="p">},</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">t</span><span class="w"> </span><span class="n">λ</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
</pre></div>
</div>
</details><p>where one and only one of λ(i) is 1, all other λ(j) are 0. We will
need to add ⌈log₂(n)⌉ binary variables, where n is the number of rows
in λ. For more information, please refer to Modeling Disjunctive
Constraints with a Logarithmic Number of Binary Variables and
Constraints by J. Vielma and G. Nemhauser, 2011.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">prog</span></code>:</dt><dd><p>The program to which the SOS1 constraint is added.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_lambda</span></code>:</dt><dd><p>n in the documentation above.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>(lambda, y) lambda is λ in the documentation above. Notice that λ
are declared as continuous variables, but they only admit binary
solutions. y are binary variables of size ⌈log₂(n)⌉. When this
sos1 constraint is satisfied, suppose that λ(i)=1 and λ(j)=0 ∀
j≠i, then y is the Reflected Gray code of i. For example, suppose
n = 8, i = 5, then y is a vector of size ⌈log₂(n)⌉ = 3, and the
value of y is (1, 1, 0) which equals to 5 according to reflected
Gray code.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AddLogarithmicSos2Constraint(prog:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">lambdas:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]],</span> <span class="pre">binary_variable_name:</span> <span class="pre">str</span> <span class="pre">=</span> <span class="pre">'y')</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Adds the special ordered set 2 (SOS2) constraint,</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddLogarithmicSos2Constraint.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AddSos2Constraint(prog:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">lambdas:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]],</span> <span class="pre">y:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Adds the special ordered set 2 (SOS2) constraint. y(i) takes binary
values (either 0 or 1).</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">y</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">λ</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">λ</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.</span>
</pre></div>
</div>
</details><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddLogarithmicSos2Constraint for a complete explanation on SOS2
constraint.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">prog</span></code>:</dt><dd><p>The optimization program to which the SOS2 constraint is added.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lambda</span></code>:</dt><dd><p>At most two entries in λ can be strictly positive, and these two
entries have to be adjacent. All other entries are zero. Moreover,
these two entries should sum up to 1.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">y</span></code>:</dt><dd><p>y(i) takes binary value, and determines which two entries in λ can
be strictly positive. Throw a runtime error if y.rows() !=
lambda.rows() - 1.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AugmentedLagrangianNonsmooth</span></span></dt>
<dd><p>Compute the augmented Lagrangian (AL) of a given mathematical program</p>
<p>min f(x) s.t h(x) = 0 l &lt;= g(x) &lt;= u x_lo &lt;= x &lt;= x_up</p>
<p>We first turn it into an equality constrained program with
non-negative slack variable s as follows</p>
<p>min f(x) s.t h(x) = 0 c(x) - s = 0 s &gt;= 0</p>
<p>Depending on the option include_x_bounds, the constraint h(x)=0,
c(x)&gt;=0 may or may not include the bounding box constraint x_lo &lt;= x
&lt;= x_up.</p>
<p>the (non-smooth) augmented Lagrangian is defined as</p>
<p>L(x, λ, μ) = f(x) − λ₁ᵀh(x) + μ/2 h(x)ᵀh(x) - λ₂ᵀ(c(x)-s) + μ/2
(c(x)-s)ᵀ(c(x)-s)</p>
<p>where s = max(c(x) - λ₂/μ, 0).</p>
<p>For more details, refer to section 17.4 of Numerical Optimization by
Jorge Nocedal and Stephen Wright, Edition 1, 1999 (This formulation
isn’t presented in Edition 2, but to stay consistent with Edition 2,
we use μ/2 as the coefficient of the quadratic penalty term instead of
1/(2μ) in Edition 1). Note that the augmented Lagrangian L(x, λ, μ) is
NOT a smooth function of x, since s = max(c(x) - λ₂/μ, 0) is
non-smooth at c(x) - λ₂/μ = 0.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AugmentedLagrangianNonsmooth.__init__(self:</span> <span class="pre">pydrake.solvers.AugmentedLagrangianNonsmooth,</span> <span class="pre">prog:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">include_x_bounds:</span> <span class="pre">bool)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">prog</span></code>:</dt><dd><p>The mathematical program we will evaluate.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">include_x_bounds</span></code>:</dt><dd><p>Whether the Lagrangian and the penalty for the bounds x_lo &lt;= x &lt;=
x_up are included in the augmented Lagrangian L(x, λ, μ) or not.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AugmentedLagrangianNonsmooth.Eval(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>Eval(self: pydrake.solvers.AugmentedLagrangianNonsmooth, x: numpy.ndarray[numpy.float64[m, 1]], lambda_val: numpy.ndarray[numpy.float64[m, 1]], mu: float) -&gt; tuple[float, numpy.ndarray[numpy.float64[m, 1]], float]</p></li>
</ol>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">x</span></code>:</dt><dd><p>The value of all the decision variables.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lambda_val</span></code>:</dt><dd><p>The estimated Lagrangian multipliers. The order of the Lagrangian
multiplier is as this: We first call to evaluate all constraints.
Then for each row of the constraint, if it is an equality
constraint, we append one single Lagrangian multiplier. Otherwise
we append the Lagrangian multiplier for the lower and upper bounds
(where the lower comes before the upper), if the corresponding
bound is not ±∞. The order of evaluating all the constraints is
the same as prog.GetAllConstraints() except for
prog.bounding_box_constraints(). If include_x_bounds=true, then we
aggregate all the bounding_box_constraints() and evaluate them at
the end of all constraints.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mu</span></code>:</dt><dd><p>μ in the documentation above. The constant for penalty term
weight. This should be a strictly positive number.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">constraint_residue</span></code>:</dt><dd><p>The value of the all the constraints. For an equality constraint
c(x)=0 or the inequality constraint c(x)&gt;= 0, the residue is c(x).
Depending on include_x_bounds, <code class="docutils literal notranslate"><span class="pre">constraint_residue</span></code> may or may
not contain the residue for bounding box constraints x_lo &lt;= x &lt;=
x_up at the end.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">cost</span></code>:</dt><dd><p>The value of the cost function f(x).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The evaluated Augmented Lagrangian (AL) L(x, λ, μ).</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>Eval(self: pydrake.solvers.AugmentedLagrangianNonsmooth, x: numpy.ndarray[object[m, 1]], lambda_val: numpy.ndarray[numpy.float64[m, 1]], mu: float) -&gt; tuple[pydrake.autodiffutils.AutoDiffXd, numpy.ndarray[object[m, 1]], pydrake.autodiffutils.AutoDiffXd]</p></li>
</ol>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">x</span></code>:</dt><dd><p>The value of all the decision variables.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lambda_val</span></code>:</dt><dd><p>The estimated Lagrangian multipliers. The order of the Lagrangian
multiplier is as this: We first call to evaluate all constraints.
Then for each row of the constraint, if it is an equality
constraint, we append one single Lagrangian multiplier. Otherwise
we append the Lagrangian multiplier for the lower and upper bounds
(where the lower comes before the upper), if the corresponding
bound is not ±∞. The order of evaluating all the constraints is
the same as prog.GetAllConstraints() except for
prog.bounding_box_constraints(). If include_x_bounds=true, then we
aggregate all the bounding_box_constraints() and evaluate them at
the end of all constraints.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mu</span></code>:</dt><dd><p>μ in the documentation above. The constant for penalty term
weight. This should be a strictly positive number.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">constraint_residue</span></code>:</dt><dd><p>The value of the all the constraints. For an equality constraint
c(x)=0 or the inequality constraint c(x)&gt;= 0, the residue is c(x).
Depending on include_x_bounds, <code class="docutils literal notranslate"><span class="pre">constraint_residue</span></code> may or may
not contain the residue for bounding box constraints x_lo &lt;= x &lt;=
x_up at the end.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">cost</span></code>:</dt><dd><p>The value of the cost function f(x).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The evaluated Augmented Lagrangian (AL) L(x, λ, μ).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AugmentedLagrangianNonsmooth.include_x_bounds(self:</span> <span class="pre">pydrake.solvers.AugmentedLagrangianNonsmooth)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Whether the bounding box constraint x_lo &lt;= x &lt;= x_up is included
in the augmented Lagrangian L(x, λ, μ).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AugmentedLagrangianNonsmooth.is_equality(self:</span> <span class="pre">pydrake.solvers.AugmentedLagrangianNonsmooth)</span> <span class="pre">-&gt;</span> <span class="pre">list[bool]</span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Whether each constraint is equality or not. The order of the
constraint is explained in the class documentation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AugmentedLagrangianNonsmooth.lagrangian_size(self:</span> <span class="pre">pydrake.solvers.AugmentedLagrangianNonsmooth)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The size of the Lagrangian multiplier λ.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AugmentedLagrangianNonsmooth.prog(self:</span> <span class="pre">pydrake.solvers.AugmentedLagrangianNonsmooth)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.MathematicalProgram</span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The mathematical program for which the augmented Lagrangian is
computed.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AugmentedLagrangianNonsmooth.x_lo(self:</span> <span class="pre">pydrake.solvers.AugmentedLagrangianNonsmooth)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>all the lower bounds of x.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AugmentedLagrangianNonsmooth.x_up(self:</span> <span class="pre">pydrake.solvers.AugmentedLagrangianNonsmooth)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>all the upper bounds of x.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AugmentedLagrangianSmooth</span></span></dt>
<dd><p>Compute the augmented Lagrangian (AL) of a given mathematical program</p>
<p>min f(x) s.t h(x) = 0 l &lt;= g(x) &lt;= u x_lo &lt;= x &lt;= x_up</p>
<p>We first turn it into an equality constrained program with
non-negative slack variable s as follows</p>
<p>min f(x) s.t h(x) = 0 c(x) - s = 0 s &gt;= 0</p>
<p>We regard this as an optimization problem on variable (x, s), with
equality constraints h(x) = 0, c(x)-s = 0, and the bound constraint s
&gt;= 0.</p>
<p>Depending on the option include_x_bounds, the constraint h(x)=0,
c(x)&gt;=0 may or may not include the bounding box constraint x_lo &lt;= x
&lt;= x_up.</p>
<p>The (smooth) augmented Lagrangian is defined as</p>
<p>L(x, s, λ, μ) = f(x) − λ₁ᵀh(x) + μ/2 h(x)ᵀh(x) - λ₂ᵀ(c(x)-s) + μ/2
(c(x)-s)ᵀ(c(x)-s)</p>
<p>For more details, refer to section 17.4 of Numerical Optimization by
Jorge Nocedal and Stephen Wright, Edition 2, 2006. Note that the
augmented Lagrangian L(x, s, λ, μ) is a smooth function of (x, s),</p>
<p>This is the implementation used in LANCELOT. To solve the nonlinear
optimization through this Augmented Lagrangian, the nonlinear solve
should be able to handle bounding box constraints on the decision
variables.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AugmentedLagrangianSmooth.__init__(self:</span> <span class="pre">pydrake.solvers.AugmentedLagrangianSmooth,</span> <span class="pre">prog:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">include_x_bounds:</span> <span class="pre">bool)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">prog</span></code>:</dt><dd><p>The mathematical program we will evaluate.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">include_x_bounds</span></code>:</dt><dd><p>Whether the Lagrangian and the penalty for the bounds x_lo &lt;= x &lt;=
x_up are included in the augmented Lagrangian L(x, s, λ, μ) or
not.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AugmentedLagrangianSmooth.Eval(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>Eval(self: pydrake.solvers.AugmentedLagrangianSmooth, x: numpy.ndarray[numpy.float64[m, 1]], s: numpy.ndarray[numpy.float64[m, 1]], lambda_val: numpy.ndarray[numpy.float64[m, 1]], mu: float) -&gt; tuple[float, numpy.ndarray[numpy.float64[m, 1]], float]</p></li>
</ol>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">x</span></code>:</dt><dd><p>The value of all the decision variables in prog().</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">s</span></code>:</dt><dd><p>The value of all slack variables s.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lambda_val</span></code>:</dt><dd><p>The estimated Lagrangian multipliers. The order of the Lagrangian
multiplier is as follows: We first call to evaluate all
constraints. Then for each row of the constraint, if it is an
equality constraint, we append one single Lagrangian multiplier.
Otherwise we append the Lagrangian multiplier for the lower and
upper bounds (where the lower comes before the upper), if the
corresponding bound is not ±∞. The order of evaluating all the
constraints is the same as prog.GetAllConstraints() except for
prog.bounding_box_constraints(). If include_x_bounds=true, then we
aggregate all the bounding_box_constraints() and evaluate them at
the end of all constraints.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mu</span></code>:</dt><dd><p>μ in the documentation above. The constant for penalty term
weight. This should be a strictly positive number.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">constraint_residue</span></code>:</dt><dd><p>The value of the all the constraints. For an equality constraint
c(x)=0, the residue is c(x); for an inequality constraint c(x)&gt;=0,
the residue is c(x)-s where s is the corresponding slack variable.
Depending on include_x_bounds, <code class="docutils literal notranslate"><span class="pre">constraint_residue</span></code> may or may
not contain the residue for bounding box constraints x_lo &lt;= x &lt;=
x_up at the end.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">cost</span></code>:</dt><dd><p>The value of the cost function f(x).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The evaluated Augmented Lagrangian (AL) L(x, s, λ, μ).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This Eval function differs from
AugmentedLagrangianNonsmooth::Eval() function as <code class="docutils literal notranslate"><span class="pre">s</span></code> is an input
argument.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>Eval(self: pydrake.solvers.AugmentedLagrangianSmooth, x: numpy.ndarray[object[m, 1]], s: numpy.ndarray[object[m, 1]], lambda_val: numpy.ndarray[numpy.float64[m, 1]], mu: float) -&gt; tuple[pydrake.autodiffutils.AutoDiffXd, numpy.ndarray[object[m, 1]], pydrake.autodiffutils.AutoDiffXd]</p></li>
</ol>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">x</span></code>:</dt><dd><p>The value of all the decision variables in prog().</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">s</span></code>:</dt><dd><p>The value of all slack variables s.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lambda_val</span></code>:</dt><dd><p>The estimated Lagrangian multipliers. The order of the Lagrangian
multiplier is as follows: We first call to evaluate all
constraints. Then for each row of the constraint, if it is an
equality constraint, we append one single Lagrangian multiplier.
Otherwise we append the Lagrangian multiplier for the lower and
upper bounds (where the lower comes before the upper), if the
corresponding bound is not ±∞. The order of evaluating all the
constraints is the same as prog.GetAllConstraints() except for
prog.bounding_box_constraints(). If include_x_bounds=true, then we
aggregate all the bounding_box_constraints() and evaluate them at
the end of all constraints.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mu</span></code>:</dt><dd><p>μ in the documentation above. The constant for penalty term
weight. This should be a strictly positive number.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">constraint_residue</span></code>:</dt><dd><p>The value of the all the constraints. For an equality constraint
c(x)=0, the residue is c(x); for an inequality constraint c(x)&gt;=0,
the residue is c(x)-s where s is the corresponding slack variable.
Depending on include_x_bounds, <code class="docutils literal notranslate"><span class="pre">constraint_residue</span></code> may or may
not contain the residue for bounding box constraints x_lo &lt;= x &lt;=
x_up at the end.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">cost</span></code>:</dt><dd><p>The value of the cost function f(x).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The evaluated Augmented Lagrangian (AL) L(x, s, λ, μ).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This Eval function differs from
AugmentedLagrangianNonsmooth::Eval() function as <code class="docutils literal notranslate"><span class="pre">s</span></code> is an input
argument.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AugmentedLagrangianSmooth.include_x_bounds(self:</span> <span class="pre">pydrake.solvers.AugmentedLagrangianSmooth)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Whether the bounding box constraint x_lo &lt;= x &lt;= x_up is included
in the augmented Lagrangian L(x, λ, μ).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AugmentedLagrangianSmooth.is_equality(self:</span> <span class="pre">pydrake.solvers.AugmentedLagrangianSmooth)</span> <span class="pre">-&gt;</span> <span class="pre">list[bool]</span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Whether each constraint is equality or not. The order of the
constraint is explained in the class documentation.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AugmentedLagrangianSmooth.lagrangian_size(self:</span> <span class="pre">pydrake.solvers.AugmentedLagrangianSmooth)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The size of the Lagrangian multiplier λ.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AugmentedLagrangianSmooth.prog(self:</span> <span class="pre">pydrake.solvers.AugmentedLagrangianSmooth)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.MathematicalProgram</span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The mathematical program for which the augmented Lagrangian is
computed.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AugmentedLagrangianSmooth.s_size(self:</span> <span class="pre">pydrake.solvers.AugmentedLagrangianSmooth)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The size of the slack variable s.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AugmentedLagrangianSmooth.x_lo(self:</span> <span class="pre">pydrake.solvers.AugmentedLagrangianSmooth)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>All the lower bounds of x.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AugmentedLagrangianSmooth.x_up(self:</span> <span class="pre">pydrake.solvers.AugmentedLagrangianSmooth)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>All the upper bounds of x.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[EvaluatorBase]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[Constraint]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[LinearConstraint]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[QuadraticConstraint]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[LorentzConeConstraint]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[RotatedLorentzConeConstraint]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[LinearEqualityConstraint]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[BoundingBoxConstraint]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[PositiveSemidefiniteConstraint]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[LinearMatrixInequalityConstraint]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[LinearComplementarityConstraint]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[ExponentialConeConstraint]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[MinimumValueLowerBoundConstraint]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[MinimumValueUpperBoundConstraint]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[ExpressionConstraint]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[Cost]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[LinearCost]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[QuadraticCost]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[L1NormCost]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[L2NormCost]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[LInfNormCost]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[PerspectiveQuadraticCost]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[ExpressionCost]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Binding[VisualizationCallback]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[BoundingBoxConstraint]</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[BoundingBoxConstraint].__init__(self:</span> <span class="pre">pydrake.solvers.Binding[BoundingBoxConstraint],</span> <span class="pre">c:</span> <span class="pre">pydrake.solvers.BoundingBoxConstraint,</span> <span class="pre">v:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[BoundingBoxConstraint].evaluator(self:</span> <span class="pre">pydrake.solvers.Binding[BoundingBoxConstraint])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.BoundingBoxConstraint</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[BoundingBoxConstraint].ToLatex(self:</span> <span class="pre">pydrake.solvers.Binding[BoundingBoxConstraint],</span> <span class="pre">precision:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">3)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a LaTeX description of this Binding. Does not include any
characters to enter/exit math mode; you might want, e.g. “$$” +
evaluator.ToLatex() + “$$”.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[BoundingBoxConstraint].variables(self:</span> <span class="pre">pydrake.solvers.Binding[BoundingBoxConstraint])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[Constraint]</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[Constraint].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.solvers.Binding[Constraint], c: pydrake.solvers.Constraint, v: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.solvers.Binding[Constraint], arg0: object) -&gt; None</p></li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[Constraint].evaluator(self:</span> <span class="pre">pydrake.solvers.Binding[Constraint])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.Constraint</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[Constraint].ToLatex(self:</span> <span class="pre">pydrake.solvers.Binding[Constraint],</span> <span class="pre">precision:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">3)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a LaTeX description of this Binding. Does not include any
characters to enter/exit math mode; you might want, e.g. “$$” +
evaluator.ToLatex() + “$$”.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[Constraint].variables(self:</span> <span class="pre">pydrake.solvers.Binding[Constraint])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[Cost]</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[Cost].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.solvers.Binding[Cost], c: pydrake.solvers.Cost, v: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.solvers.Binding[Cost], arg0: object) -&gt; None</p></li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[Cost].evaluator(self:</span> <span class="pre">pydrake.solvers.Binding[Cost])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.Cost</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[Cost].ToLatex(self:</span> <span class="pre">pydrake.solvers.Binding[Cost],</span> <span class="pre">precision:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">3)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a LaTeX description of this Binding. Does not include any
characters to enter/exit math mode; you might want, e.g. “$$” +
evaluator.ToLatex() + “$$”.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[Cost].variables(self:</span> <span class="pre">pydrake.solvers.Binding[Cost])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[EvaluatorBase]</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[EvaluatorBase].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.solvers.Binding[EvaluatorBase], c: pydrake.solvers.EvaluatorBase, v: numpy.ndarray[object[m, 1]]) -&gt; None</p></li>
</ol>
<p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.solvers.Binding[EvaluatorBase], arg0: object) -&gt; None</p></li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[EvaluatorBase].evaluator(self:</span> <span class="pre">pydrake.solvers.Binding[EvaluatorBase])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.EvaluatorBase</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[EvaluatorBase].ToLatex(self:</span> <span class="pre">pydrake.solvers.Binding[EvaluatorBase],</span> <span class="pre">precision:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">3)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a LaTeX description of this Binding. Does not include any
characters to enter/exit math mode; you might want, e.g. “$$” +
evaluator.ToLatex() + “$$”.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[EvaluatorBase].variables(self:</span> <span class="pre">pydrake.solvers.Binding[EvaluatorBase])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[ExponentialConeConstraint]</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[ExponentialConeConstraint].__init__(self:</span> <span class="pre">pydrake.solvers.Binding[ExponentialConeConstraint],</span> <span class="pre">c:</span> <span class="pre">pydrake.solvers.ExponentialConeConstraint,</span> <span class="pre">v:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[ExponentialConeConstraint].evaluator(self:</span> <span class="pre">pydrake.solvers.Binding[ExponentialConeConstraint])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.ExponentialConeConstraint</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[ExponentialConeConstraint].ToLatex(self:</span> <span class="pre">pydrake.solvers.Binding[ExponentialConeConstraint],</span> <span class="pre">precision:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">3)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a LaTeX description of this Binding. Does not include any
characters to enter/exit math mode; you might want, e.g. “$$” +
evaluator.ToLatex() + “$$”.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[ExponentialConeConstraint].variables(self:</span> <span class="pre">pydrake.solvers.Binding[ExponentialConeConstraint])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[ExpressionConstraint]</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[ExpressionConstraint].__init__(self:</span> <span class="pre">pydrake.solvers.Binding[ExpressionConstraint],</span> <span class="pre">c:</span> <span class="pre">pydrake.solvers.ExpressionConstraint,</span> <span class="pre">v:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[ExpressionConstraint].evaluator(self:</span> <span class="pre">pydrake.solvers.Binding[ExpressionConstraint])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.ExpressionConstraint</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[ExpressionConstraint].ToLatex(self:</span> <span class="pre">pydrake.solvers.Binding[ExpressionConstraint],</span> <span class="pre">precision:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">3)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a LaTeX description of this Binding. Does not include any
characters to enter/exit math mode; you might want, e.g. “$$” +
evaluator.ToLatex() + “$$”.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[ExpressionConstraint].variables(self:</span> <span class="pre">pydrake.solvers.Binding[ExpressionConstraint])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[ExpressionCost]</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[ExpressionCost].__init__(self:</span> <span class="pre">pydrake.solvers.Binding[ExpressionCost],</span> <span class="pre">c:</span> <span class="pre">pydrake.solvers.ExpressionCost,</span> <span class="pre">v:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[ExpressionCost].evaluator(self:</span> <span class="pre">pydrake.solvers.Binding[ExpressionCost])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.ExpressionCost</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[ExpressionCost].ToLatex(self:</span> <span class="pre">pydrake.solvers.Binding[ExpressionCost],</span> <span class="pre">precision:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">3)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a LaTeX description of this Binding. Does not include any
characters to enter/exit math mode; you might want, e.g. “$$” +
evaluator.ToLatex() + “$$”.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[ExpressionCost].variables(self:</span> <span class="pre">pydrake.solvers.Binding[ExpressionCost])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[L1NormCost]</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[L1NormCost].__init__(self:</span> <span class="pre">pydrake.solvers.Binding[L1NormCost],</span> <span class="pre">c:</span> <span class="pre">pydrake.solvers.L1NormCost,</span> <span class="pre">v:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[L1NormCost].evaluator(self:</span> <span class="pre">pydrake.solvers.Binding[L1NormCost])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.L1NormCost</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[L1NormCost].ToLatex(self:</span> <span class="pre">pydrake.solvers.Binding[L1NormCost],</span> <span class="pre">precision:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">3)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a LaTeX description of this Binding. Does not include any
characters to enter/exit math mode; you might want, e.g. “$$” +
evaluator.ToLatex() + “$$”.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[L1NormCost].variables(self:</span> <span class="pre">pydrake.solvers.Binding[L1NormCost])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[L2NormCost]</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[L2NormCost].__init__(self:</span> <span class="pre">pydrake.solvers.Binding[L2NormCost],</span> <span class="pre">c:</span> <span class="pre">pydrake.solvers.L2NormCost,</span> <span class="pre">v:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[L2NormCost].evaluator(self:</span> <span class="pre">pydrake.solvers.Binding[L2NormCost])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.L2NormCost</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[L2NormCost].ToLatex(self:</span> <span class="pre">pydrake.solvers.Binding[L2NormCost],</span> <span class="pre">precision:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">3)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a LaTeX description of this Binding. Does not include any
characters to enter/exit math mode; you might want, e.g. “$$” +
evaluator.ToLatex() + “$$”.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[L2NormCost].variables(self:</span> <span class="pre">pydrake.solvers.Binding[L2NormCost])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[LinearComplementarityConstraint]</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[LinearComplementarityConstraint].__init__(self:</span> <span class="pre">pydrake.solvers.Binding[LinearComplementarityConstraint],</span> <span class="pre">c:</span> <span class="pre">pydrake.solvers.LinearComplementarityConstraint,</span> <span class="pre">v:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[LinearComplementarityConstraint].evaluator(self:</span> <span class="pre">pydrake.solvers.Binding[LinearComplementarityConstraint])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.LinearComplementarityConstraint</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[LinearComplementarityConstraint].ToLatex(self:</span> <span class="pre">pydrake.solvers.Binding[LinearComplementarityConstraint],</span> <span class="pre">precision:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">3)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a LaTeX description of this Binding. Does not include any
characters to enter/exit math mode; you might want, e.g. “$$” +
evaluator.ToLatex() + “$$”.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[LinearComplementarityConstraint].variables(self:</span> <span class="pre">pydrake.solvers.Binding[LinearComplementarityConstraint])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[LinearConstraint]</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[LinearConstraint].__init__(self:</span> <span class="pre">pydrake.solvers.Binding[LinearConstraint],</span> <span class="pre">c:</span> <span class="pre">pydrake.solvers.LinearConstraint,</span> <span class="pre">v:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[LinearConstraint].evaluator(self:</span> <span class="pre">pydrake.solvers.Binding[LinearConstraint])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.LinearConstraint</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[LinearConstraint].ToLatex(self:</span> <span class="pre">pydrake.solvers.Binding[LinearConstraint],</span> <span class="pre">precision:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">3)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a LaTeX description of this Binding. Does not include any
characters to enter/exit math mode; you might want, e.g. “$$” +
evaluator.ToLatex() + “$$”.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[LinearConstraint].variables(self:</span> <span class="pre">pydrake.solvers.Binding[LinearConstraint])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[LinearCost]</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[LinearCost].__init__(self:</span> <span class="pre">pydrake.solvers.Binding[LinearCost],</span> <span class="pre">c:</span> <span class="pre">pydrake.solvers.LinearCost,</span> <span class="pre">v:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[LinearCost].evaluator(self:</span> <span class="pre">pydrake.solvers.Binding[LinearCost])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.LinearCost</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[LinearCost].ToLatex(self:</span> <span class="pre">pydrake.solvers.Binding[LinearCost],</span> <span class="pre">precision:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">3)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a LaTeX description of this Binding. Does not include any
characters to enter/exit math mode; you might want, e.g. “$$” +
evaluator.ToLatex() + “$$”.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[LinearCost].variables(self:</span> <span class="pre">pydrake.solvers.Binding[LinearCost])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[LinearEqualityConstraint]</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[LinearEqualityConstraint].__init__(self:</span> <span class="pre">pydrake.solvers.Binding[LinearEqualityConstraint],</span> <span class="pre">c:</span> <span class="pre">pydrake.solvers.LinearEqualityConstraint,</span> <span class="pre">v:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[LinearEqualityConstraint].evaluator(self:</span> <span class="pre">pydrake.solvers.Binding[LinearEqualityConstraint])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.LinearEqualityConstraint</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[LinearEqualityConstraint].ToLatex(self:</span> <span class="pre">pydrake.solvers.Binding[LinearEqualityConstraint],</span> <span class="pre">precision:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">3)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a LaTeX description of this Binding. Does not include any
characters to enter/exit math mode; you might want, e.g. “$$” +
evaluator.ToLatex() + “$$”.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[LinearEqualityConstraint].variables(self:</span> <span class="pre">pydrake.solvers.Binding[LinearEqualityConstraint])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[LinearMatrixInequalityConstraint]</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[LinearMatrixInequalityConstraint].__init__(self:</span> <span class="pre">pydrake.solvers.Binding[LinearMatrixInequalityConstraint],</span> <span class="pre">c:</span> <span class="pre">pydrake.solvers.LinearMatrixInequalityConstraint,</span> <span class="pre">v:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[LinearMatrixInequalityConstraint].evaluator(self:</span> <span class="pre">pydrake.solvers.Binding[LinearMatrixInequalityConstraint])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.LinearMatrixInequalityConstraint</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[LinearMatrixInequalityConstraint].ToLatex(self:</span> <span class="pre">pydrake.solvers.Binding[LinearMatrixInequalityConstraint],</span> <span class="pre">precision:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">3)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a LaTeX description of this Binding. Does not include any
characters to enter/exit math mode; you might want, e.g. “$$” +
evaluator.ToLatex() + “$$”.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[LinearMatrixInequalityConstraint].variables(self:</span> <span class="pre">pydrake.solvers.Binding[LinearMatrixInequalityConstraint])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[LInfNormCost]</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[LInfNormCost].__init__(self:</span> <span class="pre">pydrake.solvers.Binding[LInfNormCost],</span> <span class="pre">c:</span> <span class="pre">pydrake.solvers.LInfNormCost,</span> <span class="pre">v:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[LInfNormCost].evaluator(self:</span> <span class="pre">pydrake.solvers.Binding[LInfNormCost])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.LInfNormCost</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[LInfNormCost].ToLatex(self:</span> <span class="pre">pydrake.solvers.Binding[LInfNormCost],</span> <span class="pre">precision:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">3)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a LaTeX description of this Binding. Does not include any
characters to enter/exit math mode; you might want, e.g. “$$” +
evaluator.ToLatex() + “$$”.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[LInfNormCost].variables(self:</span> <span class="pre">pydrake.solvers.Binding[LInfNormCost])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[LorentzConeConstraint]</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[LorentzConeConstraint].__init__(self:</span> <span class="pre">pydrake.solvers.Binding[LorentzConeConstraint],</span> <span class="pre">c:</span> <span class="pre">pydrake.solvers.LorentzConeConstraint,</span> <span class="pre">v:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[LorentzConeConstraint].evaluator(self:</span> <span class="pre">pydrake.solvers.Binding[LorentzConeConstraint])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.LorentzConeConstraint</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[LorentzConeConstraint].ToLatex(self:</span> <span class="pre">pydrake.solvers.Binding[LorentzConeConstraint],</span> <span class="pre">precision:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">3)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a LaTeX description of this Binding. Does not include any
characters to enter/exit math mode; you might want, e.g. “$$” +
evaluator.ToLatex() + “$$”.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[LorentzConeConstraint].variables(self:</span> <span class="pre">pydrake.solvers.Binding[LorentzConeConstraint])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[MinimumValueLowerBoundConstraint]</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[MinimumValueLowerBoundConstraint].__init__(self:</span> <span class="pre">pydrake.solvers.Binding[MinimumValueLowerBoundConstraint],</span> <span class="pre">c:</span> <span class="pre">pydrake.solvers.MinimumValueLowerBoundConstraint,</span> <span class="pre">v:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[MinimumValueLowerBoundConstraint].evaluator(self:</span> <span class="pre">pydrake.solvers.Binding[MinimumValueLowerBoundConstraint])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.MinimumValueLowerBoundConstraint</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[MinimumValueLowerBoundConstraint].ToLatex(self:</span> <span class="pre">pydrake.solvers.Binding[MinimumValueLowerBoundConstraint],</span> <span class="pre">precision:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">3)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a LaTeX description of this Binding. Does not include any
characters to enter/exit math mode; you might want, e.g. “$$” +
evaluator.ToLatex() + “$$”.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[MinimumValueLowerBoundConstraint].variables(self:</span> <span class="pre">pydrake.solvers.Binding[MinimumValueLowerBoundConstraint])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[MinimumValueUpperBoundConstraint]</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[MinimumValueUpperBoundConstraint].__init__(self:</span> <span class="pre">pydrake.solvers.Binding[MinimumValueUpperBoundConstraint],</span> <span class="pre">c:</span> <span class="pre">pydrake.solvers.MinimumValueUpperBoundConstraint,</span> <span class="pre">v:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[MinimumValueUpperBoundConstraint].evaluator(self:</span> <span class="pre">pydrake.solvers.Binding[MinimumValueUpperBoundConstraint])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.MinimumValueUpperBoundConstraint</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[MinimumValueUpperBoundConstraint].ToLatex(self:</span> <span class="pre">pydrake.solvers.Binding[MinimumValueUpperBoundConstraint],</span> <span class="pre">precision:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">3)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a LaTeX description of this Binding. Does not include any
characters to enter/exit math mode; you might want, e.g. “$$” +
evaluator.ToLatex() + “$$”.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[MinimumValueUpperBoundConstraint].variables(self:</span> <span class="pre">pydrake.solvers.Binding[MinimumValueUpperBoundConstraint])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[PerspectiveQuadraticCost]</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[PerspectiveQuadraticCost].__init__(self:</span> <span class="pre">pydrake.solvers.Binding[PerspectiveQuadraticCost],</span> <span class="pre">c:</span> <span class="pre">pydrake.solvers.PerspectiveQuadraticCost,</span> <span class="pre">v:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[PerspectiveQuadraticCost].evaluator(self:</span> <span class="pre">pydrake.solvers.Binding[PerspectiveQuadraticCost])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.PerspectiveQuadraticCost</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[PerspectiveQuadraticCost].ToLatex(self:</span> <span class="pre">pydrake.solvers.Binding[PerspectiveQuadraticCost],</span> <span class="pre">precision:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">3)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a LaTeX description of this Binding. Does not include any
characters to enter/exit math mode; you might want, e.g. “$$” +
evaluator.ToLatex() + “$$”.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[PerspectiveQuadraticCost].variables(self:</span> <span class="pre">pydrake.solvers.Binding[PerspectiveQuadraticCost])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[PositiveSemidefiniteConstraint]</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[PositiveSemidefiniteConstraint].__init__(self:</span> <span class="pre">pydrake.solvers.Binding[PositiveSemidefiniteConstraint],</span> <span class="pre">c:</span> <span class="pre">pydrake.solvers.PositiveSemidefiniteConstraint,</span> <span class="pre">v:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[PositiveSemidefiniteConstraint].evaluator(self:</span> <span class="pre">pydrake.solvers.Binding[PositiveSemidefiniteConstraint])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.PositiveSemidefiniteConstraint</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[PositiveSemidefiniteConstraint].ToLatex(self:</span> <span class="pre">pydrake.solvers.Binding[PositiveSemidefiniteConstraint],</span> <span class="pre">precision:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">3)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a LaTeX description of this Binding. Does not include any
characters to enter/exit math mode; you might want, e.g. “$$” +
evaluator.ToLatex() + “$$”.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[PositiveSemidefiniteConstraint].variables(self:</span> <span class="pre">pydrake.solvers.Binding[PositiveSemidefiniteConstraint])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[QuadraticConstraint]</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[QuadraticConstraint].__init__(self:</span> <span class="pre">pydrake.solvers.Binding[QuadraticConstraint],</span> <span class="pre">c:</span> <span class="pre">pydrake.solvers.QuadraticConstraint,</span> <span class="pre">v:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[QuadraticConstraint].evaluator(self:</span> <span class="pre">pydrake.solvers.Binding[QuadraticConstraint])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.QuadraticConstraint</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[QuadraticConstraint].ToLatex(self:</span> <span class="pre">pydrake.solvers.Binding[QuadraticConstraint],</span> <span class="pre">precision:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">3)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a LaTeX description of this Binding. Does not include any
characters to enter/exit math mode; you might want, e.g. “$$” +
evaluator.ToLatex() + “$$”.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[QuadraticConstraint].variables(self:</span> <span class="pre">pydrake.solvers.Binding[QuadraticConstraint])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[QuadraticCost]</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[QuadraticCost].__init__(self:</span> <span class="pre">pydrake.solvers.Binding[QuadraticCost],</span> <span class="pre">c:</span> <span class="pre">pydrake.solvers.QuadraticCost,</span> <span class="pre">v:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[QuadraticCost].evaluator(self:</span> <span class="pre">pydrake.solvers.Binding[QuadraticCost])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.QuadraticCost</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[QuadraticCost].ToLatex(self:</span> <span class="pre">pydrake.solvers.Binding[QuadraticCost],</span> <span class="pre">precision:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">3)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a LaTeX description of this Binding. Does not include any
characters to enter/exit math mode; you might want, e.g. “$$” +
evaluator.ToLatex() + “$$”.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[QuadraticCost].variables(self:</span> <span class="pre">pydrake.solvers.Binding[QuadraticCost])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[RotatedLorentzConeConstraint]</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[RotatedLorentzConeConstraint].__init__(self:</span> <span class="pre">pydrake.solvers.Binding[RotatedLorentzConeConstraint],</span> <span class="pre">c:</span> <span class="pre">pydrake.solvers.RotatedLorentzConeConstraint,</span> <span class="pre">v:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[RotatedLorentzConeConstraint].evaluator(self:</span> <span class="pre">pydrake.solvers.Binding[RotatedLorentzConeConstraint])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.RotatedLorentzConeConstraint</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[RotatedLorentzConeConstraint].ToLatex(self:</span> <span class="pre">pydrake.solvers.Binding[RotatedLorentzConeConstraint],</span> <span class="pre">precision:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">3)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a LaTeX description of this Binding. Does not include any
characters to enter/exit math mode; you might want, e.g. “$$” +
evaluator.ToLatex() + “$$”.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[RotatedLorentzConeConstraint].variables(self:</span> <span class="pre">pydrake.solvers.Binding[RotatedLorentzConeConstraint])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[VisualizationCallback]</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[VisualizationCallback].__init__(self:</span> <span class="pre">pydrake.solvers.Binding[VisualizationCallback],</span> <span class="pre">c:</span> <span class="pre">pydrake.solvers.VisualizationCallback,</span> <span class="pre">v:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Concatenates each VectorDecisionVariable object in <code class="docutils literal notranslate"><span class="pre">v</span></code> into a single
column vector, binds this column vector of decision variables with the
constraint <code class="docutils literal notranslate"><span class="pre">c</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[VisualizationCallback].evaluator(self:</span> <span class="pre">pydrake.solvers.Binding[VisualizationCallback])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.VisualizationCallback</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[VisualizationCallback].ToLatex(self:</span> <span class="pre">pydrake.solvers.Binding[VisualizationCallback],</span> <span class="pre">precision:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">3)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a LaTeX description of this Binding. Does not include any
characters to enter/exit math mode; you might want, e.g. “$$” +
evaluator.ToLatex() + “$$”.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Binding[VisualizationCallback].variables(self:</span> <span class="pre">pydrake.solvers.Binding[VisualizationCallback])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BoundingBoxConstraint</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.LinearConstraint</span></code></p>
<p>Implements a constraint of the form <span class="math notranslate nohighlight">\(lb &lt;= x &lt;= ub\)</span></p>
<p>Note: the base Constraint class (as implemented at the moment) could
play this role. But this class enforces that it is ONLY a bounding box
constraint, and not something more general. Some solvers use this
information to handle bounding box constraints differently than
general constraints, so use of this form is encouraged.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BoundingBoxConstraint.__init__(self:</span> <span class="pre">pydrake.solvers.BoundingBoxConstraint,</span> <span class="pre">lb:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">ub:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ChooseBestSolver(prog:</span> <span class="pre">pydrake.solvers.MathematicalProgram)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.SolverId</span></span></dt>
<dd><p>Choose the best solver given the formulation in the optimization
program and the availability of the solvers.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if there is no available solver for prog.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ClarabelSolver</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.SolverInterface</span></code></p>
<p>An interface to wrap Clarabel
<a class="reference external" href="https://github.com/oxfordcontrol/Clarabel.cpp">https://github.com/oxfordcontrol/Clarabel.cpp</a></p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ClarabelSolver.__init__(self:</span> <span class="pre">pydrake.solvers.ClarabelSolver)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ClarabelSolver.id()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.SolverId</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ClarabelSolverDetails</span></span></dt>
<dd><p>The Clarabel solver details after calling the Solve() function. The
user can call
MathematicalProgramResult::get_solver_details&lt;ClarabelSolver&gt;() to
obtain the details.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ClarabelSolverDetails.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ClarabelSolverDetails.iterations</span></span></dt>
<dd><p>Number of iterations in Clarabel.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ClarabelSolverDetails.solve_time</span></span></dt>
<dd><p>The solve time inside Clarabel in seconds.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ClarabelSolverDetails.status</span></span></dt>
<dd><p>The status from Clarabel.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ClpSolver</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.SolverInterface</span></code></p>
<p>A wrapper to call CLP using Drake’s MathematicalProgram.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently our ClpSolver has a memory issue when solving a QP. The
user should be aware of this risk.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The authors can adjust the problem scaling option by setting
“scaling” as mentioned in
<a class="reference external" href="https://github.com/coin-or/Clp/blob/43129ba1a7fd66ce70fe0761fcd696951917ed2e/src/ClpModel.hpp#L705-L706">https://github.com/coin-or/Clp/blob/43129ba1a7fd66ce70fe0761fcd696951917ed2e/src/ClpModel.hpp#L705-L706</a>
For example prog.SetSolverOption(ClpSolver::id(), “scaling”, 0);
will do “no scaling”. The default is 1.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ClpSolver.__init__(self:</span> <span class="pre">pydrake.solvers.ClpSolver)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ClpSolver.id()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.SolverId</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ClpSolverDetails</span></span></dt>
<dd><p>The CLP solver details after calling Solve() function. The user can
call MathematicalProgramResult::get_solver_details&lt;ClpSolver&gt;() to
obtain the details.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ClpSolverDetails.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ClpSolverDetails.status</span></span></dt>
<dd><p>Refer to ClpModel::status() function for the meaning of the status
code. - -1: unknown error. - 0: optimal. - 1: primal infeasible - 2:
dual infeasible - 3: stopped on iterations or time. - 4: stopped due
to errors - 5: stopped by event handler</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CommonSolverOption</span></span></dt>
<dd><p>Some options can be applied to not one solver, but many solvers (for
example, many solvers support printing out the progress in each
iteration). CommonSolverOption contain the names of these supported
options. The user can use these options as “key” in
SolverOption::SetOption(). If the solver doesn’t support the option,
the option is ignored.</p>
<p>Members:</p>
<blockquote>
<div><p>kPrintFileName : Many solvers support printing the progress of each iteration to a</p>
</div></blockquote>
<p>file. The user can call SolverOptions::SetOption(kPrintFileName,
“filename.log”) to enable this. To disable, set the option to the
empty string <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>, which indicates that no file should be written.</p>
<blockquote>
<div><p>kPrintToConsole : Many solvers support printing the progress of each iteration to the</p>
</div></blockquote>
<p>console. The user can call <code class="docutils literal notranslate"><span class="pre">SolverOptions::SetOption(kPrintToConsole,</span>
<span class="pre">1)</span></code> to enable this, or use <code class="docutils literal notranslate"><span class="pre">0</span></code> to turn off printing to the console.</p>
<blockquote>
<div><p>kStandaloneReproductionFileName : Some solvers support writing a standalone (e.g., it does not depend on</p>
</div></blockquote>
<p>Drake) minimal reproduction of the problem to a file. This is
especially useful for sending bug reports upstream to the developers
of the solver. The user can call
<code class="docutils literal notranslate"><span class="pre">SolverOptions::SetOption(kStandaloneReproductionFileName,</span>
<span class="pre">&quot;filename.txt&quot;)</span></code> to enable this. To disable, set the option to the
empty string <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>, which indicates that no file should be written.</p>
<blockquote>
<div><p>kMaxThreads : Some solvers are multi-threaded. The user can request the maximum</p>
</div></blockquote>
<p>number of threads used by the solver with this <code class="docutils literal notranslate"><span class="pre">int</span></code> option. When
not set, the value defaults to Parallelism.Max().num_threads(), which
can be controlled via the drake::Parallelism “DRAKE_NUM_THREADS”
environment variable.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>The number of threads must be greater than 0.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Setting this value higher than the actual hardware concurrency may
result in a degraded performance. It is recommended to set this
value lower than or equal to Parallelism.Max().num_threads().</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A solver may choose to use fewer threads than the value specified.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This options does NOT disable multi-threading in BLAS/LAPACK which
is used by many solvers under the hood. Therefore, some internal
operations of the solvers may still be multi-core.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CommonSolverOption.__init__(self:</span> <span class="pre">pydrake.solvers.CommonSolverOption,</span> <span class="pre">value:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CommonSolverOption.kMaxThreads</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CommonSolverOption.kPrintFileName</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CommonSolverOption.kPrintToConsole</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CommonSolverOption.kStandaloneReproductionFileName</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CommonSolverOption.name</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CommonSolverOption.value</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Constraint</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.EvaluatorBase</span></code></p>
<p>A constraint is a function + lower and upper bounds.</p>
<p>Solver interfaces must acknowledge that these constraints are mutable.
Parameters can change after the constraint is constructed and before
the call to Solve().</p>
<p>It should support evaluating the constraint, and adding it to an
optimization problem.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Constraint.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Constraint.CheckSatisfied(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CheckSatisfied(self: pydrake.solvers.Constraint, x: numpy.ndarray[numpy.float64[m, 1]], tol: float = 1e-06) -&gt; bool</p></li>
</ol>
<p>Return whether this constraint is satisfied by the given value, <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">x</span></code>:</dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">num_vars</span></code> x 1 vector.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">tol</span></code>:</dt><dd><p>A tolerance for bound checking.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the size</strong><strong> of </strong><strong>x isn't correct.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>CheckSatisfied(self: pydrake.solvers.Constraint, x: numpy.ndarray[object[m, 1]], tol: float = 1e-06) -&gt; bool</p></li>
</ol>
<p>Return whether this constraint is satisfied by the given value, <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">x</span></code>:</dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">num_vars</span></code> x 1 vector.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">tol</span></code>:</dt><dd><p>A tolerance for bound checking.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the size</strong><strong> of </strong><strong>x isn't correct.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>CheckSatisfied(self: pydrake.solvers.Constraint, x: numpy.ndarray[object[m, 1]]) -&gt; pydrake.symbolic.Formula</p></li>
</ol>
<p>Return whether this constraint is satisfied by the given value, <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">x</span></code>:</dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">num_vars</span></code> x 1 vector.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">tol</span></code>:</dt><dd><p>A tolerance for bound checking.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the size</strong><strong> of </strong><strong>x isn't correct.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Constraint.CheckSatisfiedVectorized(self:</span> <span class="pre">pydrake.solvers.Constraint,</span> <span class="pre">x:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous],</span> <span class="pre">tol:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">list[bool]</span></span></dt>
<dd><p>A “vectorized” version of CheckSatisfied.  It evaluates the constraint for every column of <code class="docutils literal notranslate"><span class="pre">x</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Constraint.lower_bound(self:</span> <span class="pre">pydrake.solvers.Constraint)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Constraint.num_constraints(self:</span> <span class="pre">pydrake.solvers.Constraint)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Number of rows in the output constraint.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Constraint.upper_bound(self:</span> <span class="pre">pydrake.solvers.Constraint)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Cost</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.EvaluatorBase</span></code></p>
<p>Provides an abstract base for all costs.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Cost.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CsdpSolver</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.SolverInterface</span></code></p>
<p>Wrap CSDP solver such that it can solve a
drake::solvers::MathematicalProgram.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>CSDP doesn’t accept free variables, while
drake::solvers::MathematicalProgram does. In order to convert
MathematicalProgram into CSDP format, we provide several
approaches to remove free variables. You can set the approach
through</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">cc</span><span class="p">}</span>
<span class="n">SolverOptions</span><span class="w"> </span><span class="n">solver_options</span><span class="p">;</span>
<span class="n">solver_options</span><span class="p">.</span><span class="n">SetOption</span><span class="p">(</span><span class="n">CsdpSolver</span><span class="o">::</span><span class="n">id</span><span class="p">(),</span>
<span class="w">   </span><span class="s">&quot;drake::RemoveFreeVariableMethod&quot;</span><span class="p">,</span>
<span class="w">   </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">RemoveFreeVariableMethod</span><span class="o">::</span><span class="n">kNullspace</span><span class="p">));</span>
<span class="n">CsdpSolver</span><span class="w"> </span><span class="n">solver</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">solver</span><span class="p">.</span><span class="n">Solve</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">,</span><span class="w"> </span><span class="n">solver_options</span><span class="p">);</span>
</pre></div>
</div>
</details><p>For more details, check out RemoveFreeVariableMethod.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CsdpSolver.__init__(self:</span> <span class="pre">pydrake.solvers.CsdpSolver)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Default constructor</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CsdpSolver.id()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.SolverId</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CsdpSolverDetails</span></span></dt>
<dd><p>The CSDP solver details after calling Solve() function. The user can
call MathematicalProgramResult::get_solver_details&lt;CsdpSolver&gt;() to
obtain the details.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CsdpSolverDetails.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CsdpSolverDetails.dual_objective</span></span></dt>
<dd><p>The dual objective value.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CsdpSolverDetails.primal_objective</span></span></dt>
<dd><p>The primal objective value.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CsdpSolverDetails.return_code</span></span></dt>
<dd><p>Refer to the Return Codes section of CSDP 6.2.0 User’s Guide for
explanation on the return code. Some of the common return codes are</p>
<p>0 Problem is solved to optimality. 1 Problem is primal infeasible. 2
Problem is dual infeasible. 3 Problem solved to near optimality. 4
Maximum iterations reached. 5 Stuck at edge of primal feasibility. 6
Stuck at edge of dual feasibility. 7 Lack of progress. 8 X, Z, or O is
singular. 9 NaN or Inf values encountered.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CsdpSolverDetails.y_val</span></span></dt>
<dd><p>CSDP solves a primal problem of the form</p>
<p>max tr(C*X) s.t tr(Aᵢ*X) = aᵢ X ≽ 0</p>
<p>The dual form is</p>
<p>min aᵀy s.t ∑ᵢ yᵢAᵢ - C = Z Z ≽ 0</p>
<p>y, Z are the variables for the dual problem. y_val, Z_val are the
solutions to the dual problem.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CsdpSolverDetails.Z_val</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">EvaluatorBase</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">EvaluatorBase.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">EvaluatorBase.Eval(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>Eval(self: pydrake.solvers.EvaluatorBase, x: numpy.ndarray[numpy.float64[m, 1]]) -&gt; numpy.ndarray[numpy.float64[m, 1]]</p></li>
</ol>
<p>Evaluates the expression.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">x</span></code>:</dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">num_vars</span></code> x 1 input vector.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">y</span></code>:</dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">num_outputs</span></code> x 1 output vector.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>Eval(self: pydrake.solvers.EvaluatorBase, x: numpy.ndarray[object[m, 1]]) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Evaluates the expression.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">x</span></code>:</dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">num_vars</span></code> x 1 input vector.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">y</span></code>:</dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">num_outputs</span></code> x 1 output vector.</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>Eval(self: pydrake.solvers.EvaluatorBase, x: numpy.ndarray[object[m, 1]]) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Evaluates the expression.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">x</span></code>:</dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">num_vars</span></code> x 1 input vector.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">y</span></code>:</dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">num_outputs</span></code> x 1 output vector.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">EvaluatorBase.get_description(self:</span> <span class="pre">pydrake.solvers.EvaluatorBase)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Getter for a human-friendly description for the evaluator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">EvaluatorBase.gradient_sparsity_pattern(self:</span> <span class="pre">pydrake.solvers.EvaluatorBase)</span> <span class="pre">-&gt;</span> <span class="pre">Optional[list[tuple[int,</span> <span class="pre">int]]]</span></span></dt>
<dd><p>Returns the vector of (row_index, col_index) that contains all the
entries in the gradient of Eval function (∂y/∂x) whose value could be
non-zero, namely if ∂yᵢ/∂xⱼ could be non-zero, then the pair (i, j) is
in gradient_sparsity_pattern.</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">gradient_sparsity_pattern</span></code>:</dt><dd><p>If nullopt, then we regard all entries of the gradient as
potentially non-zero.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">EvaluatorBase.is_thread_safe(self:</span> <span class="pre">pydrake.solvers.EvaluatorBase)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns whether it is safe to call Eval in parallel.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">EvaluatorBase.num_outputs(self:</span> <span class="pre">pydrake.solvers.EvaluatorBase)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Getter for the number of outputs, namely the number of rows in y, as
used in Eval(x, y).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">EvaluatorBase.num_vars(self:</span> <span class="pre">pydrake.solvers.EvaluatorBase)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Getter for the number of variables, namely the number of rows in x, as
used in Eval(x, y).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">EvaluatorBase.set_description(self:</span> <span class="pre">pydrake.solvers.EvaluatorBase,</span> <span class="pre">arg0:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Set a human-friendly description for the evaluator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">EvaluatorBase.SetGradientSparsityPattern(self:</span> <span class="pre">pydrake.solvers.EvaluatorBase,</span> <span class="pre">gradient_sparsity_pattern:</span> <span class="pre">list[tuple[int,</span> <span class="pre">int]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Set the sparsity pattern of the gradient matrix ∂y/∂x (the gradient of
y value in Eval, w.r.t x in Eval) . gradient_sparsity_pattern contains
<em>all</em> the pairs of (row_index, col_index) for which the corresponding
entries could have non-zero value in the gradient matrix ∂y/∂x.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">EvaluatorBase.ToLatex(self:</span> <span class="pre">pydrake.solvers.EvaluatorBase,</span> <span class="pre">vars:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]],</span> <span class="pre">precision:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">3)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a LaTeX string describing this evaluator. Does not include any
characters to enter/exit math mode; you might want, e.g. “$$” +
evaluator.ToLatex() + “$$”.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ExponentialConeConstraint</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Constraint</span></code></p>
<p>An exponential cone constraint is a special type of convex cone
constraint. We constrain A * x + b to be in the exponential cone,
where A has 3 rows, and b is in ℝ³, x is the decision variable. A
vector z in ℝ³ is in the exponential cone, if {z₀, z₁, z₂ | z₀ ≥ z₁ *
exp(z₂ / z₁), z₁ &gt; 0}. Equivalently, this constraint can be
refomulated with logarithm function {z₀, z₁, z₂ | z₂ ≤ z₁ * log(z₀ /
z₁), z₀ &gt; 0, z₁ &gt; 0}</p>
<p>The Eval function implemented in this class is z₀ - z₁ * exp(z₂ / z₁)
&gt;= 0, z₁ &gt; 0 where z = A * x + b. It is not recommended to solve an
exponential cone constraint through generic nonlinear optimization. It
is possible that the nonlinear solver can accidentally set z₁ = 0,
where the constraint is not well defined. Instead, the user should
consider to solve the program through conic solvers that can exploit
exponential cone, such as MOSEK<a href="/tm.html">™</a> and SCS.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ExponentialConeConstraint.__init__(self:</span> <span class="pre">pydrake.solvers.ExponentialConeConstraint,</span> <span class="pre">A:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]],</span> <span class="pre">b:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructor for exponential cone. Constrains A * x + b to be in the
exponential cone.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>A has 3 rows.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ExponentialConeConstraint.A(self:</span> <span class="pre">pydrake.solvers.ExponentialConeConstraint)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>Getter for matrix A.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ExponentialConeConstraint.b(self:</span> <span class="pre">pydrake.solvers.ExponentialConeConstraint)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Getter for vector b.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ExpressionConstraint</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Constraint</span></code></p>
<p>Impose a generic (potentially nonlinear) constraint represented as a
vector of symbolic Expression. Expression::Evaluate is called on every
constraint evaluation.</p>
<p>Uses symbolic::Jacobian to provide the gradients to the AutoDiff
method.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ExpressionConstraint.__init__(self:</span> <span class="pre">pydrake.solvers.ExpressionConstraint,</span> <span class="pre">v:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]],</span> <span class="pre">lb:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">ub:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ExpressionConstraint.expressions(self:</span> <span class="pre">pydrake.solvers.ExpressionConstraint)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the symbolic expressions.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ExpressionConstraint.vars(self:</span> <span class="pre">pydrake.solvers.ExpressionConstraint)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the list of the variables involved in the vector of expressions,
in the order that they are expected to be received during DoEval.
Any Binding that connects this constraint to decision variables
should pass this list of variables to the Binding.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ExpressionCost</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Cost</span></code></p>
<p>Impose a generic (potentially nonlinear) cost represented as a
symbolic Expression. Expression::Evaluate is called on every
constraint evaluation.</p>
<p>Uses symbolic::Jacobian to provide the gradients to the AutoDiff
method.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ExpressionCost.__init__(self:</span> <span class="pre">pydrake.solvers.ExpressionCost,</span> <span class="pre">e:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ExpressionCost.expression(self:</span> <span class="pre">pydrake.solvers.ExpressionCost)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the symbolic expression.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ExpressionCost.vars(self:</span> <span class="pre">pydrake.solvers.ExpressionCost)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the list of the variables involved in the vector of expressions,
in the order that they are expected to be received during DoEval.
Any Binding that connects this constraint to decision variables
should pass this list of variables to the Binding.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GenerateSDPA(prog:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">file_name:</span> <span class="pre">str,</span> <span class="pre">method:</span> <span class="pre">pydrake.solvers.RemoveFreeVariableMethod</span> <span class="pre">=</span> <span class="pre">&lt;RemoveFreeVariableMethod.kNullspace:</span> <span class="pre">2&gt;)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>SDPA is a format to record an SDP problem</p>
<p>max tr(C*X) s.t tr(Aᵢ*X) = gᵢ X ≽ 0</p>
<p>or the dual of the problem</p>
<p>min gᵀy s.t ∑ᵢ yᵢAᵢ - C ≽ 0</p>
<p>where X is a symmetric block diagonal matrix. The format is described
in <a class="reference external" href="http://plato.asu.edu/ftp/sdpa_format.txt">http://plato.asu.edu/ftp/sdpa_format.txt</a>. Many solvers, such as
CSDP, DSDP, SDPA, sedumi and SDPT3, accept an SDPA format file as the
input. This function reads a MathematicalProgram that can be
formulated as above, and write an SDPA file.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">prog</span></code>:</dt><dd><p>a program that contains an optimization program.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">file_name</span></code>:</dt><dd><p>The name of the file, note that the extension will be added
automatically.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">method</span></code>:</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">prog</span></code> contains free variables (i.e., variables without
bounds), then we need to remove these free variables to write the
program in the SDPA format. Please refer to
RemoveFreeVariableMethod for details on how to remove the free
variables. $*Default:* is RemoveFreeVariableMethod::kNullspace.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">is_success</span></code>:</dt><dd><p>. Returns true if we can generate the SDPA file. The failure could
be 1. <code class="docutils literal notranslate"><span class="pre">prog</span></code> cannot be captured by the formulation above. 2.
<code class="docutils literal notranslate"><span class="pre">prog</span></code> cannot create a file with the given name, etc.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GetAvailableSolvers(prog_type:</span> <span class="pre">pydrake.solvers.ProgramType)</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.solvers.SolverId]</span></span></dt>
<dd><p>Returns the list of available and enabled solvers that definitely
accept all programs of the given program type. The order of the
returned SolverIds reflects an approximate order of preference, from
most preferred (front) to least preferred (back). Because we are
analyzing only based on the program type rather than a specific
program, it’s possible that solvers later in the list would perform
better in certain situations. To obtain the truly best solver, using
ChooseBestSolver() instead.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If a solver only accepts a subset of the program type, then that
solver is not included in the returned results. For example
EqualityConstrainedQPSolver doesn’t accept programs with
inequality linear constraints, so it doesn’t show up in the return
of GetAvailableSolvers(ProgramType::kQP).</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GetProgramType(arg0:</span> <span class="pre">pydrake.solvers.MathematicalProgram)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.ProgramType</span></span></dt>
<dd><p>Returns the type of the optimization program (LP, QP, etc), based on
the properties of its cost/constraints/variables. Each mathematical
program should be characterized by a unique type. If a program can be
characterized as either type A or type B (for example, a program with
linear constraint and linear costs can be characterized as either an
LP or an SDP), then we choose the type corresponding to a smaller set
of programs (LP in this case).</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GurobiSolver</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.SolverInterface</span></code></p>
<p>An implementation of SolverInterface for the commercially-licensed
Gurobi solver (<a class="reference external" href="https://www.gurobi.com/">https://www.gurobi.com/</a>).</p>
<p>The default build of Drake is not configured to use Gurobi, so
therefore SolverInterface::available() will return false. You must
compile Drake from source in order to link against Gurobi. For
details, refer to the documentation at
<a class="reference external" href="https://drake.mit.edu/bazel.html#proprietary-solvers">https://drake.mit.edu/bazel.html#proprietary-solvers</a>.</p>
<p>The GRB_LICENSE_FILE environment variable controls whether or not
SolverInterface::enabled() returns true. If it is set to any non-empty
value, then the solver is enabled; otherwise, the solver is not
enabled.</p>
<p>Gurobi solver supports options/parameters listed in
<a class="reference external" href="https://www.gurobi.com/documentation/10.0/refman/parameters.html">https://www.gurobi.com/documentation/10.0/refman/parameters.html</a>. On
top of these options, we provide the following additional options 1.
“GRBwrite”, set to a file name so that Gurobi solver will write the
optimization model to this file, check
<a class="reference external" href="https://www.gurobi.com/documentation/10.0/refman/py_model_write.html">https://www.gurobi.com/documentation/10.0/refman/py_model_write.html</a>
for more details, such as all supported file extensions. Set this
option to “” if you don’t want to write to file. Default is not to
write to a file. 2. “GRBcomputeIIS”, set to 1 to compute an
Irreducible Inconsistent Subsystem (IIS) when the problem is
infeasible. Refer to
<a class="reference external" href="https://www.gurobi.com/documentation/10.0/refman/py_model_computeiis.html">https://www.gurobi.com/documentation/10.0/refman/py_model_computeiis.html</a>
for more details. Often this method is called together with setting
GRBwrite to “FILENAME.ilp” to write IIS to a file with extension
“ilp”. Default is not to compute IIS.</p>
<p>GurobiSolver supports parallelization during Solve(). If both the
“Threads” integer solver option and CommonSolverOption::kMaxThreads
have been set by the user, then the value in “Threads” will be used as
the number of threads.</p>
<p>If neither the “Threads” integer solver option nor
CommonSolverOption::kMaxThreads has been set by the user, then
GurobiSolver uses the environment variable GUROBI_NUM_THREADS (if set)
as a default value for “Threads”.</p>
<p>If none of “Threads”, CommonSolverOption::kMaxThreads, or
GUROBI_NUM_THREADS are set, then Drake’s default maximum parallelism
will be used.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GurobiSolver.__init__(self:</span> <span class="pre">pydrake.solvers.GurobiSolver)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GurobiSolver.AcquireLicense()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.GurobiSolver.License</span></span></dt>
<dd><p>This acquires a Gurobi license environment shared among all
GurobiSolver instances. The environment will stay valid as long as at
least one shared_ptr returned by this function is alive. GurobiSolver
calls this method on each Solve().</p>
<p>If the license file contains the string <code class="docutils literal notranslate"><span class="pre">HOSTID</span></code>, then we treat this
as confirmation that the license is attached to the local host, and
maintain an internal copy of the shared_ptr for the lifetime of the
process. Otherwise the default behavior is to only hold the license
while at least one GurobiSolver instance is alive.</p>
<p>Call this method directly and maintain the shared_ptr ONLY if you must
use different MathematicalProgram instances at different instances in
time, and repeatedly acquiring the license is costly (e.g., requires
contacting a license server).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A shared pointer to a license environment that will stay valid as
long as any shared_ptr returned by this function is alive. If
Gurobi is not available in your build, this will return a null
(empty) shared_ptr.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if Gurobi is available but a license cannot be</strong> – </p></li>
<li><p><strong>obtained.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GurobiSolver.AddMipNodeCallback(self:</span> <span class="pre">pydrake.solvers.GurobiSolver,</span> <span class="pre">callback:</span> <span class="pre">Callable[[pydrake.solvers.MathematicalProgram,</span> <span class="pre">pydrake.solvers.GurobiSolver.SolveStatusInfo,</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]],</span> <span class="pre">None])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Registers a callback to be called at intermediate solutions during the
solve.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">callback</span></code>:</dt><dd><p>User callback function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GurobiSolver.AddMipSolCallback(self:</span> <span class="pre">pydrake.solvers.GurobiSolver,</span> <span class="pre">callback:</span> <span class="pre">Callable[[pydrake.solvers.MathematicalProgram,</span> <span class="pre">pydrake.solvers.GurobiSolver.SolveStatusInfo],</span> <span class="pre">None])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Registers a callback to be called at feasible solutions during the
solve.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">callback</span></code>:</dt><dd><p>User callback function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GurobiSolver.id()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.SolverId</span></span></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GurobiSolver.License</span></span></dt>
<dd><p>Context-manageable license from <code class="docutils literal notranslate"><span class="pre">GurobiSolver.AcquireLicense()</span></code>.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GurobiSolver.License.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GurobiSolver.License.is_valid(self:</span> <span class="pre">pydrake.solvers.GurobiSolver.License)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Indicates that this has a valid license that has not been released.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GurobiSolver.SolveStatusInfo</span></span></dt>
<dd><p>Contains info returned to a user function that handles a Node or
Solution callback.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MipNodeCallbackFunction</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MipSolCallbackFunction</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GurobiSolver.SolveStatusInfo.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GurobiSolver.SolveStatusInfo.best_bound</span></span></dt>
<dd><p>Best known objective lower bound.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GurobiSolver.SolveStatusInfo.best_objective</span></span></dt>
<dd><p>Objective of best solution yet.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GurobiSolver.SolveStatusInfo.current_objective</span></span></dt>
<dd><p>Objective of current solution.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GurobiSolver.SolveStatusInfo.explored_node_count</span></span></dt>
<dd><p>Number of nodes explored so far.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GurobiSolver.SolveStatusInfo.feasible_solutions_count</span></span></dt>
<dd><p>Number of feasible sols found so far.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GurobiSolver.SolveStatusInfo.reported_runtime</span></span></dt>
<dd><p>Runtime as of this callback.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GurobiSolverDetails</span></span></dt>
<dd><p>The Gurobi solver details after calling Solve() function. The user can
call MathematicalProgramResult::get_solver_details&lt;GurobiSolver&gt;() to
obtain the details.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GurobiSolverDetails.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GurobiSolverDetails.error_code</span></span></dt>
<dd><p>The error message returned from Gurobi call. Please refer to
<a class="reference external" href="https://www.gurobi.com/documentation/10.0/refman/error_codes.html">https://www.gurobi.com/documentation/10.0/refman/error_codes.html</a></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GurobiSolverDetails.objective_bound</span></span></dt>
<dd><p>The best known bound on the optimal objective. This is used in mixed
integer optimization. Please refer to
<a class="reference external" href="https://www.gurobi.com/documentation/10.0/refman/objbound.html">https://www.gurobi.com/documentation/10.0/refman/objbound.html</a></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GurobiSolverDetails.optimization_status</span></span></dt>
<dd><p>The status code when the optimize call has returned. Please refer to
<a class="reference external" href="https://www.gurobi.com/documentation/10.0/refman/optimization_status_codes.html">https://www.gurobi.com/documentation/10.0/refman/optimization_status_codes.html</a></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GurobiSolverDetails.optimizer_time</span></span></dt>
<dd><p>The gurobi optimization time. Please refer to
<a class="reference external" href="https://www.gurobi.com/documentation/10.0/refman/runtime.html">https://www.gurobi.com/documentation/10.0/refman/runtime.html</a></p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IntervalBinning</span></span></dt>
<dd><p>For a continuous variable whose range is cut into small intervals, we
will use binary variables to represent which interval the continuous
variable is in. We support two representations, either using
logarithmic number of binary variables, or linear number of binary
variables. For more details,</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddLogarithmicSos2Constraint and AddSos2Constraint</p>
</div>
<p>Members:</p>
<blockquote>
<div><p>kLogarithmic</p>
<p>kLinear</p>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IntervalBinning.__init__(self:</span> <span class="pre">pydrake.solvers.IntervalBinning,</span> <span class="pre">value:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IntervalBinning.kLinear</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IntervalBinning.kLogarithmic</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IntervalBinning.name</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IntervalBinning.value</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IpoptSolver</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.SolverInterface</span></code></p>
<p>A wrapper to call &lt;a href=”<a class="reference external" href="https://coin-or.github.io/Ipopt/">https://coin-or.github.io/Ipopt/</a>”&gt;Ipopt&lt;/a&gt;
using Drake’s MathematicalProgram.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IpoptSolver.__init__(self:</span> <span class="pre">pydrake.solvers.IpoptSolver)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IpoptSolver.id()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.SolverId</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IpoptSolverDetails</span></span></dt>
<dd><p>The Ipopt solver details after calling Solve() function. The user can
call MathematicalProgramResult::get_solver_details&lt;IpoptSolver&gt;() to
obtain the details.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IpoptSolverDetails.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IpoptSolverDetails.ConvertStatusToString(self:</span> <span class="pre">pydrake.solvers.IpoptSolverDetails)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Convert status field to string. This function is useful if you want to
interpret the meaning of status.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IpoptSolverDetails.g</span></span></dt>
<dd><p>The final value for the constraint function.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IpoptSolverDetails.lambda_val</span></span></dt>
<dd><p>The final value for the constraint multiplier.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IpoptSolverDetails.status</span></span></dt>
<dd><p>The final status of the solver. Please refer to section 6 in
Introduction to Ipopt: A tutorial for downloading, installing, and
using Ipopt. You could also find the meaning of the status as
Ipopt::SolverReturn defined in IpAlgTypes.hpp</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IpoptSolverDetails.z_L</span></span></dt>
<dd><p>The final value for the lower bound multiplier.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">IpoptSolverDetails.z_U</span></span></dt>
<dd><p>The final value for the upper bound multiplier.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">L1NormCost</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Cost</span></code></p>
<p>Implements a cost of the form ‖Ax + b‖₁. Note that this cost is
non-differentiable when any element of Ax + b equals zero.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">L1NormCost.__init__(self:</span> <span class="pre">pydrake.solvers.L1NormCost,</span> <span class="pre">A:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]],</span> <span class="pre">b:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Construct a cost of the form ‖Ax + b‖₁.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">A</span></code>:</dt><dd><p>Linear term.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>:</dt><dd><p>Constant term.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the size</strong><strong> of </strong><strong>A and b don't match.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">L1NormCost.A(self:</span> <span class="pre">pydrake.solvers.L1NormCost)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">L1NormCost.b(self:</span> <span class="pre">pydrake.solvers.L1NormCost)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">L1NormCost.update_A_entry(self:</span> <span class="pre">pydrake.solvers.L1NormCost,</span> <span class="pre">i:</span> <span class="pre">int,</span> <span class="pre">j:</span> <span class="pre">int,</span> <span class="pre">val:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Updates A(i, j) = val.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>if i</strong><strong> or </strong><strong>j are invalid indices.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">L1NormCost.update_b_entry(self:</span> <span class="pre">pydrake.solvers.L1NormCost,</span> <span class="pre">i:</span> <span class="pre">int,</span> <span class="pre">val:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Updates b(i) = val.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>if i is an invalid index.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">L1NormCost.UpdateCoefficients(self:</span> <span class="pre">pydrake.solvers.L1NormCost,</span> <span class="pre">new_A:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]],</span> <span class="pre">new_b:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Updates the coefficients of the cost. Note that the number of
variables (columns of A) cannot change.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_A</span></code>:</dt><dd><p>New linear term.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_b</span></code>:</dt><dd><p>New constant term.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">L2NormCost</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Cost</span></code></p>
<p>Implements a cost of the form ‖Ax + b‖₂.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">L2NormCost.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.solvers.L2NormCost, A: numpy.ndarray[numpy.float64[m, n]], b: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Construct a cost of the form ‖Ax + b‖₂.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">A</span></code>:</dt><dd><p>Linear term.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>:</dt><dd><p>Constant term.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the size</strong><strong> of </strong><strong>A and b don't match.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.solvers.L2NormCost, A: scipy.sparse.csc_matrix[numpy.float64], b: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Overloads constructor with a sparse A matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">L2NormCost.b(self:</span> <span class="pre">pydrake.solvers.L2NormCost)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">L2NormCost.get_sparse_A(self:</span> <span class="pre">pydrake.solvers.L2NormCost)</span> <span class="pre">-&gt;</span> <span class="pre">scipy.sparse.csc_matrix[numpy.float64]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">L2NormCost.GetDenseA(self:</span> <span class="pre">pydrake.solvers.L2NormCost)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">L2NormCost.UpdateCoefficients(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>UpdateCoefficients(self: pydrake.solvers.L2NormCost, new_A: numpy.ndarray[numpy.float64[m, n]], new_b: numpy.ndarray[numpy.float64[m, 1]] = 0) -&gt; None</p></li>
</ol>
<p>Updates the coefficients of the cost. Note that the number of
variables (columns of A) cannot change.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_A</span></code>:</dt><dd><p>New linear term.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_b</span></code>:</dt><dd><p>New constant term.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>UpdateCoefficients(self: pydrake.solvers.L2NormCost, new_A: scipy.sparse.csc_matrix[numpy.float64], new_b: numpy.ndarray[numpy.float64[m, 1]] = 0) -&gt; None</p></li>
</ol>
<p>Overloads UpdateCoefficients but with a sparse A matrix.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearComplementarityConstraint</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Constraint</span></code></p>
<p>Implements a constraint of the form:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Mx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="err">≥</span><span class="w"> </span><span class="mi">0</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="err">≥</span><span class="w"> </span><span class="mi">0</span>
<span class="w">  </span><span class="n">x</span><span class="err">&#39;</span><span class="p">(</span><span class="n">Mx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span>
</pre></div>
</div>
</details><p>Often this is summarized with the short-hand:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span><span class="w"> </span><span class="err">≤</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="err">⊥</span><span class="w"> </span><span class="n">Mz</span><span class="o">+</span><span class="n">q</span><span class="w"> </span><span class="err">≥</span><span class="w"> </span><span class="mi">0</span>
</pre></div>
</div>
</details><p>An implied slack variable complements any 0 component of x. To get the
slack values at a given solution x, use Eval(x).</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearComplementarityConstraint.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearComplementarityConstraint.M(self:</span> <span class="pre">pydrake.solvers.LinearComplementarityConstraint)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearComplementarityConstraint.q(self:</span> <span class="pre">pydrake.solvers.LinearComplementarityConstraint)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearConstraint</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Constraint</span></code></p>
<p>Implements a constraint of the form <span class="math notranslate nohighlight">\(lb &lt;= Ax &lt;= ub\)</span></p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearConstraint.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.solvers.LinearConstraint, A: numpy.ndarray[numpy.float64[m, n]], lb: numpy.ndarray[numpy.float64[m, 1]], ub: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Construct the linear constraint lb &lt;= A*x &lt;= ub</p>
<p>Throws if A has any entry which is not finite.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.solvers.LinearConstraint, A: scipy.sparse.csc_matrix[numpy.float64], lb: numpy.ndarray[numpy.float64[m, 1]], ub: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Overloads constructor with a sparse A matrix. Throws if A has any
entry which is not finite.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearConstraint.get_sparse_A(self:</span> <span class="pre">pydrake.solvers.LinearConstraint)</span> <span class="pre">-&gt;</span> <span class="pre">scipy.sparse.csc_matrix[numpy.float64]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearConstraint.GetDenseA(self:</span> <span class="pre">pydrake.solvers.LinearConstraint)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>Get the matrix A as a dense matrix.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>this might involve memory allocation to convert a sparse matrix to
a dense one, for better performance you should call get_sparse_A()
which returns a sparse matrix.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearConstraint.is_dense_A_constructed(self:</span> <span class="pre">pydrake.solvers.LinearConstraint)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff this constraint already has a dense representation,
i.e, if GetDenseA() will be cheap.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearConstraint.RemoveTinyCoefficient(self:</span> <span class="pre">pydrake.solvers.LinearConstraint,</span> <span class="pre">tol:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets A(i, j) to zero if abs(A(i, j)) &lt;= tol. Oftentimes the
coefficient A is computed numerically with round-off errors. Such
small round-off errors can cause numerical issues for certain
optimization solvers. Hence it is recommended to remove the tiny
coefficients to achieve numerical robustness.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">tol</span></code>:</dt><dd><p>The entries in A with absolute value &lt;= tol will be set to 0.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>tol&gt;= 0.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearConstraint.set_bounds(self:</span> <span class="pre">pydrake.solvers.LinearConstraint,</span> <span class="pre">new_lb:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">new_ub:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Set the upper and lower bounds of the constraint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_lb</span></code>:</dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">num_constraints</span></code> x 1 vector.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_ub</span></code>:</dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">num_constraints</span></code> x 1 vector.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the users want to expose this method in a sub-class, do using
Constraint::set_bounds, as in LinearConstraint.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearConstraint.UpdateCoefficients(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>UpdateCoefficients(self: pydrake.solvers.LinearConstraint, new_A: numpy.ndarray[numpy.float64[m, n]], new_lb: numpy.ndarray[numpy.float64[m, 1]], new_ub: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Updates the linear term, upper and lower bounds in the linear
constraint. The updated constraint is: new_lb &lt;= new_A * x &lt;= new_ub
Note that the size of constraints (number of rows) can change, but the
number of variables (number of cols) cannot.</p>
<p>Throws if new_A has any entry which is not finite or if new_A, new_lb,
and new_ub don’t all have the same number of rows.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_A</span></code>:</dt><dd><p>new linear term</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_lb</span></code>:</dt><dd><p>new lower bound</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_ub</span></code>:</dt><dd><p>new upper bound</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>UpdateCoefficients(self: pydrake.solvers.LinearConstraint, new_A: scipy.sparse.csc_matrix[numpy.float64], new_lb: numpy.ndarray[numpy.float64[m, 1]], new_ub: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Overloads UpdateCoefficients but with a sparse A matrix.</p>
<p>Throws if new_A has any entry which is not finite or if new_A, new_lb,
and new_ub don’t all have the same number of rows.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearConstraint.UpdateLowerBound(self:</span> <span class="pre">pydrake.solvers.LinearConstraint,</span> <span class="pre">new_lb:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Updates the lower bound.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>if the users want to expose this method in a sub-class, do using
Constraint::UpdateLowerBound, as in LinearConstraint.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearConstraint.UpdateUpperBound(self:</span> <span class="pre">pydrake.solvers.LinearConstraint,</span> <span class="pre">new_ub:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Updates the upper bound.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>if the users want to expose this method in a sub-class, do using
Constraint::UpdateUpperBound, as in LinearConstraint.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearCost</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Cost</span></code></p>
<p>Implements a cost of the form</p>
<div class="math notranslate nohighlight">
\[a'x + b\]</div>
<p>.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearCost.__init__(self:</span> <span class="pre">pydrake.solvers.LinearCost,</span> <span class="pre">a:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">b:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Construct a linear cost of the form</p>
<div class="math notranslate nohighlight">
\[a'x + b\]</div>
<p>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">a</span></code>:</dt><dd><p>Linear term.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>:</dt><dd><p>(optional) Constant term.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearCost.a(self:</span> <span class="pre">pydrake.solvers.LinearCost)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearCost.b(self:</span> <span class="pre">pydrake.solvers.LinearCost)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearCost.update_coefficient_entry(self:</span> <span class="pre">pydrake.solvers.LinearCost,</span> <span class="pre">i:</span> <span class="pre">int,</span> <span class="pre">val:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Updates one entry in the coefficient of the cost. a[i] = val.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">i</span></code>:</dt><dd><p>The index of the coefficient to be updated.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">val</span></code>:</dt><dd><p>The value of that updated entry.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearCost.update_constant_term(self:</span> <span class="pre">pydrake.solvers.LinearCost,</span> <span class="pre">new_b:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Updates the constant term in the cost to <code class="docutils literal notranslate"><span class="pre">new_b</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearCost.UpdateCoefficients(self:</span> <span class="pre">pydrake.solvers.LinearCost,</span> <span class="pre">new_a:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">new_b:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Updates the coefficients of the cost. Note that the number of
variables (size of a) cannot change.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_a</span></code>:</dt><dd><p>New linear term.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_b</span></code>:</dt><dd><p>(optional) New constant term.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearEqualityConstraint</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.LinearConstraint</span></code></p>
<p>Implements a constraint of the form <span class="math notranslate nohighlight">\(Ax = b\)</span></p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearEqualityConstraint.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.solvers.LinearEqualityConstraint, Aeq: numpy.ndarray[numpy.float64[m, n]], beq: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs the linear equality constraint Aeq * x = beq.</p>
<p>Throws is any entry in Aeq or beq is not finite.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.solvers.LinearEqualityConstraint, Aeq: scipy.sparse.csc_matrix[numpy.float64], beq: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Overloads the constructor with a sparse matrix Aeq.</p>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.solvers.LinearEqualityConstraint, a: numpy.ndarray[numpy.float64[1, n]], beq: float) -&gt; None</p></li>
</ol>
<p>Constructs the linear equality constraint a.dot(x) = beq</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearEqualityConstraint.UpdateCoefficients(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>UpdateCoefficients(self: pydrake.solvers.LinearEqualityConstraint, Aeq: numpy.ndarray[numpy.float64[m, n]], beq: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Overloads UpdateCoefficients but with a sparse A matrix.</p>
<p>Throws if any entry of beq or Aeq is not finite.</p>
<ol class="arabic simple" start="2">
<li><p>UpdateCoefficients(self: pydrake.solvers.LinearEqualityConstraint, Aeq: scipy.sparse.csc_matrix[numpy.float64], beq: numpy.ndarray[numpy.float64[m, 1]]) -&gt; None</p></li>
</ol>
<p>Overloads UpdateCoefficients but with a sparse A matrix.</p>
<p>Throws if any entry of beq or Aeq is not finite.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearMatrixInequalityConstraint</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Constraint</span></code></p>
<p>Impose the matrix inequality constraint on variable x</p>
<div class="math notranslate nohighlight">
\[F_0 + x_1  F_1 + ... + x_n  F_n \text{ is p.s.d}\]</div>
<p>where p.s.d stands for positive semidefinite. <span class="math notranslate nohighlight">\(F_0, F_1, ...,
F_n\)</span> are all given symmetric matrices of the same size.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>if the matrices Fᵢ all have 1 row, then it is better to impose a
linear inequality constraints; if they all have 2 rows, then it is
better to impose a rotated Lorentz cone constraint, since a 2 x 2
matrix X being p.s.d is equivalent to the constraint [X(0, 0),
X(1, 1), X(0, 1)] in the rotated Lorentz cone.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearMatrixInequalityConstraint.__init__(self:</span> <span class="pre">pydrake.solvers.LinearMatrixInequalityConstraint,</span> <span class="pre">F:</span> <span class="pre">list[numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]],</span> <span class="pre">symmetry_tolerance:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">1e-10)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">F</span></code>:</dt><dd><p>Each symmetric matrix F[i] should be of the same size.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">symmetry_tolerance</span></code>:</dt><dd><p>The precision to determine if the input matrices Fi are all
symmetric.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>math::IsSymmetric().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearMatrixInequalityConstraint.F(self:</span> <span class="pre">pydrake.solvers.LinearMatrixInequalityConstraint)</span> <span class="pre">-&gt;</span> <span class="pre">list[numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearMatrixInequalityConstraint.matrix_rows(self:</span> <span class="pre">pydrake.solvers.LinearMatrixInequalityConstraint)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Gets the number of rows in the matrix inequality constraint. Namely Fi
are all matrix_rows() x matrix_rows() matrices.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LInfNormCost</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Cost</span></code></p>
<p>Implements a cost of the form ‖Ax + b‖∞. Note that this cost is
non-differentiable when any two or more elements of Ax + b are equal.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LInfNormCost.__init__(self:</span> <span class="pre">pydrake.solvers.LInfNormCost,</span> <span class="pre">A:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]],</span> <span class="pre">b:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Construct a cost of the form ‖Ax + b‖∞.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">A</span></code>:</dt><dd><p>Linear term.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>:</dt><dd><p>Constant term.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the size</strong><strong> of </strong><strong>A and b don't match.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LInfNormCost.A(self:</span> <span class="pre">pydrake.solvers.LInfNormCost)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LInfNormCost.b(self:</span> <span class="pre">pydrake.solvers.LInfNormCost)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LInfNormCost.update_A_entry(self:</span> <span class="pre">pydrake.solvers.LInfNormCost,</span> <span class="pre">i:</span> <span class="pre">int,</span> <span class="pre">j:</span> <span class="pre">int,</span> <span class="pre">val:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Updates A(i, j) = val.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>if i</strong><strong> or </strong><strong>j are invalid indices.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LInfNormCost.update_b_entry(self:</span> <span class="pre">pydrake.solvers.LInfNormCost,</span> <span class="pre">i:</span> <span class="pre">int,</span> <span class="pre">val:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Updates b(i) = val.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>if i is an invalid index.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LInfNormCost.UpdateCoefficients(self:</span> <span class="pre">pydrake.solvers.LInfNormCost,</span> <span class="pre">new_A:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]],</span> <span class="pre">new_b:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Updates the coefficients of the cost. Note that the number of
variables (columns of A) cannot change.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_A</span></code>:</dt><dd><p>New linear term.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_b</span></code>:</dt><dd><p>New constant term.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LorentzConeConstraint</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Constraint</span></code></p>
<p>Constraining the linear expression <span class="math notranslate nohighlight">\(z=Ax+b\)</span> lies within the
Lorentz cone. A vector z ∈ ℝ ⁿ lies within Lorentz cone if</p>
<div class="math notranslate nohighlight">
\[z_0 \ge \sqrt{z_1^2+...+z_{n-1}^2}\]</div>
<p>where A ∈ ℝ ⁿˣᵐ, b ∈ ℝ ⁿ are given matrices. Ideally this constraint
should be handled by a second-order cone solver. In case the user
wants to enforce this constraint through general nonlinear
optimization, we provide three different formulations on the Lorentz
cone constraint 1. [kConvex] g(z) = z₀ - sqrt(z₁² + … + zₙ₋₁²) ≥ 0
This formulation is not differentiable at z₁=…=zₙ₋₁=0 2.
[kConvexSmooth] g(z) = z₀ - sqrt(z₁² + … + zₙ₋₁²) ≥ 0 but the
gradient of g(z) is approximated as ∂g(z)/∂z = [1, -z₁/sqrt(z₁² + …
zₙ₋₁² + ε), …, -zₙ₋₁/sqrt(z₁²+…+zₙ₋₁²+ε)] where ε is a small
positive number. 3. [kNonconvex] z₀²-(z₁²+…+zₙ₋₁²) ≥ 0 z₀ ≥ 0 This
constraint is differentiable everywhere, but z₀²-(z₁²+…+zₙ₋₁²) ≥ 0
is non-convex. For more information and visualization, please refer to
<a class="reference external" href="https://www.epfl.ch/labs/disopt/wp-content/uploads/2018/09/7.pdf">https://www.epfl.ch/labs/disopt/wp-content/uploads/2018/09/7.pdf</a> and
<a class="reference external" href="https://docs.mosek.com/modeling-cookbook/cqo.html">https://docs.mosek.com/modeling-cookbook/cqo.html</a> (Fig 3.1)</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LorentzConeConstraint.__init__(self:</span> <span class="pre">pydrake.solvers.LorentzConeConstraint,</span> <span class="pre">A:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]],</span> <span class="pre">b:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">eval_type:</span> <span class="pre">pydrake.solvers.LorentzConeConstraint.EvalType</span> <span class="pre">=</span> <span class="pre">&lt;EvalType.kConvexSmooth:</span> <span class="pre">1&gt;)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if A.row</strong><strong>(</strong><strong>) </strong><strong>&lt; 2.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LorentzConeConstraint.A(self:</span> <span class="pre">pydrake.solvers.LorentzConeConstraint)</span> <span class="pre">-&gt;</span> <span class="pre">scipy.sparse.csc_matrix[numpy.float64]</span></span></dt>
<dd><p>Getter for A.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LorentzConeConstraint.b(self:</span> <span class="pre">pydrake.solvers.LorentzConeConstraint)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Getter for b.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LorentzConeConstraint.eval_type(self:</span> <span class="pre">pydrake.solvers.LorentzConeConstraint)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.LorentzConeConstraint.EvalType</span></span></dt>
<dd><p>Getter for eval type.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LorentzConeConstraint.EvalType</span></span></dt>
<dd><p>We provide three possible Eval functions to represent the Lorentz cone
constraint z₀ ≥ sqrt(z₁² + … + zₙ₋₁²). For more explanation on the
three formulations, refer to LorentzConeConstraint documentation.</p>
<p>Members:</p>
<blockquote>
<div><p>kConvex : The constraint is g(z) = z₀ - sqrt(z₁² + … + zₙ₋₁²) ≥ 0. Note this</p>
</div></blockquote>
<p>formulation is non-differentiable at z₁= …= zₙ₋₁=0</p>
<blockquote>
<div><p>kConvexSmooth : Same as kConvex, but with approximated gradient that exists</p>
</div></blockquote>
<p>everywhere..</p>
<blockquote>
<div><p>kNonconvex : Nonconvex constraint z₀²-(z₁²+…+zₙ₋₁²) ≥ 0 and z₀ ≥ 0. Note this</p>
</div></blockquote>
<p>formulation is differentiable, but at z₁= …= zₙ₋₁=0 the gradient is
also 0, so a gradient-based nonlinear solver can get stuck.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LorentzConeConstraint.EvalType.__init__(self:</span> <span class="pre">pydrake.solvers.LorentzConeConstraint.EvalType,</span> <span class="pre">value:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LorentzConeConstraint.EvalType.kConvex</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LorentzConeConstraint.EvalType.kConvexSmooth</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LorentzConeConstraint.EvalType.kNonconvex</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LorentzConeConstraint.EvalType.name</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LorentzConeConstraint.EvalType.value</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LorentzConeConstraint.UpdateCoefficients(self:</span> <span class="pre">pydrake.solvers.LorentzConeConstraint,</span> <span class="pre">new_A:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous],</span> <span class="pre">new_b:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Updates the coefficients, the updated constraint is z=new_A * x +
new_b in the Lorentz cone.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the new_A.cols</strong><strong>(</strong><strong>) </strong><strong>!= A.cols</strong><strong>(</strong><strong>)</strong><strong>, </strong><strong>namely the variable</strong> – </p></li>
<li><p><strong>size should not change.</strong> – </p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">new_A</span></code> has to have at least 2 rows and new_A.rows() ==
new_b.rows().</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MakeFirstAvailableSolver(solver_ids:</span> <span class="pre">list[pydrake.solvers.SolverId])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.SolverInterface</span></span></dt>
<dd><p>Makes the first available and enabled solver. If no solvers are
available, throws a RuntimeError.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MakeSemidefiniteRelaxation(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>MakeSemidefiniteRelaxation(prog: pydrake.solvers.MathematicalProgram, options: pydrake.solvers.SemidefiniteRelaxationOptions = SemidefiniteRelaxationOptions(add_implied_linear_equality_constraints=True, add_implied_linear_constraints=True)) -&gt; pydrake.solvers.MathematicalProgram</p></li>
</ol>
<p>Constructs a new MathematicalProgram which represents the semidefinite
programming convex relaxation of the (likely nonconvex) program
<code class="docutils literal notranslate"><span class="pre">prog</span></code>. This method currently supports only linear and quadratic
costs and constraints, but may be extended in the future with broader
support.</p>
<p>See <a class="reference external" href="https://underactuated.mit.edu/optimization.html#sdp_relaxation">https://underactuated.mit.edu/optimization.html#sdp_relaxation</a> for
references and examples.</p>
<p>Note: Currently, programs using LinearEqualityConstraint will give
tighter relaxations than programs using LinearConstraint or
BoundingBoxConstraint, even if lower_bound == upper_bound. Prefer
LinearEqualityConstraint.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if prog has costs and constraints which are not</strong> – </p></li>
<li><p><strong>linear nor quadratic.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>MakeSemidefiniteRelaxation(prog: pydrake.solvers.MathematicalProgram, variable_groups: list[pydrake.symbolic.Variables], options: pydrake.solvers.SemidefiniteRelaxationOptions = SemidefiniteRelaxationOptions(add_implied_linear_equality_constraints=True, add_implied_linear_constraints=True)) -&gt; pydrake.solvers.MathematicalProgram</p></li>
</ol>
<p>A version of MakeSemidefiniteRelaxation that allows for specifying the
sparsity of the relaxation.</p>
<p>For each group in <code class="docutils literal notranslate"><span class="pre">variable_groups</span></code>, the costs and constraints whose
variables are a subset of the group will be jointly relaxed into a
single, dense semidefinite program in the same manner as
MakeSemidefiniteRelaxation(prog).</p>
<p>Each of these semidefinite relaxations are aggregated into a single
program, and their semidefinite variables are made to agree where the
variable groups overlap.</p>
<p>The returned program will always have the same number of PSD variables
as variable groups.</p>
<p>Costs and constraints whose variables are not a subset of any of the
groups are not relaxed and are simply added to the aggregated program.
If these costs and constraints are non-convex, then this method will
throw.</p>
<p>As an example, consider the following program. min x₂ᵀ * Q * x₂
subject to x₁ + x₂ ≤ 1 x₂ + x₃ ≤ 2 x₁ + x₃ ≤ 3</p>
<p>And suppose we call MakeSemidefiniteRelaxation(prog,
std::vector&lt;Variables&gt;{{x₁, x₂}, {x₂,x₃}}).</p>
<p>The resulting relaxation would have two semidefinite variables,
namely: [U₁, U₂, x₁] [W₁, W₂, x₂] [U₂, U₃, x₂], [W₂, W₃, x₃] [x₁ᵀ,
x₂ᵀ, 1] [x₂ᵀ, x₃ᵀ, 1]</p>
<p>The first semidefinite variable would be associated to the
semidefinite relaxation of the subprogram: min x₁ᵀ * Q * x₁ subject to
x₁ + x₂ ≤ 1 And the implied constraints from x₁ + x₂ ≤ 1 would be
added to the first semidefinite variable. These implied constraints
are additional constraints that can be placed on the matrix [U₁, U₂,
x₁] [U₂, U₃, x₂] [x₁ᵀ, x₂ᵀ, 1] which are redundant in the non-convex
program, but are not redundant in the semidefinite relaxation. See
<a class="reference external" href="https://underactuated.mit.edu/optimization.html#sdp_relaxation">https://underactuated.mit.edu/optimization.html#sdp_relaxation</a> for
references and examples.</p>
<p>The second semidefinite variable would be associated to the
semidefinite relaxation of the subprogram: min x₂ᵀ * Q * x₂ subject to
x₂ + x₃ ≤ 2 And the implied constraints from x₂ + x₃ ≤ 2 would be
added to the second semidefinite variable.</p>
<p>Since the constraint x₁ + x₃ ≤ 3 is not a subset of any of the
variable groups, it will be added to the overall relaxation, but will
not be used to generate implied constraints on any semidefinite
variable.</p>
<p>The total relaxation would also include an equality constraint that U₃
== W₁ so that the quadratic relaxation of x₂ is consistent between the
two semidefinite variables.</p>
<p>Note: 1) Costs are only associated to a single variable group, so that
the resulting aggregated program has a relaxed cost with the same
scaling. 2) The homogenization variable “1” is re-used in every
semidefinite variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if there is a non-convex cost</strong><strong> or </strong><strong>constraint whose</strong> – </p></li>
<li><p><strong>variables do not intersect with any</strong><strong> of </strong><strong>the variable groups.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MakeSolver(id:</span> <span class="pre">pydrake.solvers.SolverId)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.SolverInterface</span></span></dt>
<dd><p>Given the solver ID, create the solver with the matching ID.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if there is no matching solver.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram</span></span></dt>
<dd><p>MathematicalProgram stores the decision variables, the constraints and
costs of an optimization problem. The user can solve the problem by
calling solvers::Solve() function, and obtain the results of the
optimization.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.__init__(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.Add2NormSquaredCost(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">A:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous],</span> <span class="pre">b:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">vars:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.Binding[QuadraticCost]</span></span></dt>
<dd><p>Adds a quadratic cost of the form <a href="#id1"><span class="problematic" id="id2">|</span></a>Ax-b|²=(Ax-b)ᵀ(Ax-b)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.AddBoundingBoxConstraint(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddBoundingBoxConstraint(self: pydrake.solvers.MathematicalProgram, arg0: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], arg1: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], arg2: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; pydrake.solvers.Binding[BoundingBoxConstraint]</p></li>
</ol>
<p>Adds bounding box constraints referencing potentially a subset of the
decision variables.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lb</span></code>:</dt><dd><p>The lower bound.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">ub</span></code>:</dt><dd><p>The upper bound.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">vars</span></code>:</dt><dd><p>Will imposes constraint lb(i, j) &lt;= vars(i, j) &lt;= ub(i, j).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The newly constructed BoundingBoxConstraint.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>AddBoundingBoxConstraint(self: pydrake.solvers.MathematicalProgram, arg0: float, arg1: float, arg2: pydrake.symbolic.Variable) -&gt; pydrake.solvers.Binding[BoundingBoxConstraint]</p></li>
</ol>
<p>Adds bounds for a single variable.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lb</span></code>:</dt><dd><p>Lower bound.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">ub</span></code>:</dt><dd><p>Upper bound.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">var</span></code>:</dt><dd><p>The decision variable.</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>AddBoundingBoxConstraint(self: pydrake.solvers.MathematicalProgram, arg0: float, arg1: float, arg2: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; pydrake.solvers.Binding[BoundingBoxConstraint]</p></li>
</ol>
<p>Adds the same scalar lower and upper bound to every variable in
<code class="docutils literal notranslate"><span class="pre">vars</span></code>.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">Derived</span></code>:</dt><dd><p>An Eigen::Matrix with Variable as the scalar type. The matrix has
unknown number of columns at compile time, or has more than one
column.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lb</span></code>:</dt><dd><p>Lower bound.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">ub</span></code>:</dt><dd><p>Upper bound.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">vars</span></code>:</dt><dd><p>The decision variables.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.AddConstraint(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddConstraint(self: pydrake.solvers.MathematicalProgram, func: Callable, lb: numpy.ndarray[numpy.float64[m, 1]], ub: numpy.ndarray[numpy.float64[m, 1]], vars: numpy.ndarray[object[m, 1]], description: str = ‘’) -&gt; pydrake.solvers.Binding[Constraint]</p></li>
</ol>
<p>Adds a constraint using a Python function.</p>
<ol class="arabic simple" start="2">
<li><p>AddConstraint(self: pydrake.solvers.MathematicalProgram, arg0: pydrake.symbolic.Expression, arg1: float, arg2: float) -&gt; pydrake.solvers.Binding[Constraint]</p></li>
</ol>
<p>Adds one row of constraint lb &lt;= e &lt;= ub where <code class="docutils literal notranslate"><span class="pre">e</span></code> is a symbolic
expression.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if 1. lb &lt;= e &lt;= ub is a trivial constraint such</strong> – </p></li>
<li><p><strong>as 1 &lt;= 2 &lt;= 3. 2. lb &lt;= e &lt;= ub is unsatisfiable such as 1 &lt;=</strong> – </p></li>
<li><p><strong>-5 &lt;= 3</strong> – </p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">e</span></code>:</dt><dd><p>A symbolic expression of the decision variables.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lb</span></code>:</dt><dd><p>A scalar, the lower bound.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">ub</span></code>:</dt><dd><p>A scalar, the upper bound.</p>
</dd>
</dl>
<p>The resulting constraint may be a BoundingBoxConstraint,
LinearConstraint, LinearEqualityConstraint, QuadraticConstraint, or
ExpressionConstraint, depending on the arguments. Constraints of the
form x == 1 (which could be created as a BoundingBoxConstraint or
LinearEqualityConstraint) will be constructed as a
LinearEqualityConstraint.</p>
<ol class="arabic simple" start="3">
<li><p>AddConstraint(self: pydrake.solvers.MathematicalProgram, arg0: pydrake.symbolic.Formula) -&gt; pydrake.solvers.Binding[Constraint]</p></li>
</ol>
<p>Add a constraint represented by a symbolic formula to the program. The
input formula <code class="docutils literal notranslate"><span class="pre">f</span></code> can be of the following forms:</p>
<ol class="arabic simple">
<li><p>e1 &lt;= e2</p></li>
<li><p>e1 &gt;= e2</p></li>
<li><p>e1 == e2</p></li>
<li><p>A conjunction of relational formulas where each conjunct is
a relational formula matched by 1, 2, or 3.</p></li>
</ol>
<p>Note that first two cases might return an object of
Binding&lt;BoundingBoxConstraint&gt;, Binding&lt;LinearConstraint&gt;, or
Binding&lt;ExpressionConstraint&gt;, depending on <code class="docutils literal notranslate"><span class="pre">f</span></code>. Also the third case
might return an object of Binding&lt;LinearEqualityConstraint&gt; or
Binding&lt;ExpressionConstraint&gt;.</p>
<p>It throws an exception if 1. <code class="docutils literal notranslate"><span class="pre">f</span></code> is not matched with one of the
above patterns. Especially, strict inequalities (&lt;, &gt;) are not
allowed. 2. <code class="docutils literal notranslate"><span class="pre">f</span></code> is either a trivial constraint such as “1 &lt;= 2” or
an unsatisfiable constraint such as “2 &lt;= 1”. 3. It is not possible to
find numerical bounds of <code class="docutils literal notranslate"><span class="pre">e1</span></code> and <code class="docutils literal notranslate"><span class="pre">e2</span></code> where <code class="docutils literal notranslate"><span class="pre">f</span></code> = e1 ≃ e2. We
allow <code class="docutils literal notranslate"><span class="pre">e1</span></code> and <code class="docutils literal notranslate"><span class="pre">e2</span></code> to be infinite but only if there are no other
terms. For example, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">∞</span></code> is allowed. However, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">∞</span> <span class="pre">&lt;=</span> <span class="pre">0</span></code> is
not allowed because <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">↦</span> <span class="pre">∞</span></code> introduces <code class="docutils literal notranslate"><span class="pre">nan</span></code> in the evaluation.</p>
<ol class="arabic simple" start="4">
<li><p>AddConstraint(self: pydrake.solvers.MathematicalProgram, constraint: pydrake.solvers.Constraint, vars: numpy.ndarray[object[m, 1]]) -&gt; pydrake.solvers.Binding[Constraint]</p></li>
</ol>
<p>Adds a generic constraint to the program. This should only be used if
a more specific type of constraint is not available, as it may require
the use of a significantly more expensive solver.</p>
<ol class="arabic simple" start="5">
<li><p>AddConstraint(self: pydrake.solvers.MathematicalProgram, formulas: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; pydrake.solvers.Binding[Constraint]</p></li>
</ol>
<p>Adds a constraint represented by an Eigen::Matrix&lt;symbolic::Formula&gt;
or Eigen::Array&lt;symbolic::Formula&gt; to the program. A common use-case
of this function is to add a constraint with the element-wise
comparison between two Eigen matrices, using <code class="docutils literal notranslate"><span class="pre">A.array()</span> <span class="pre">&lt;=</span>
<span class="pre">B.array()</span></code>. See the following example.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MathematicalProgram</span><span class="w"> </span><span class="n">prog</span><span class="p">;</span>
<span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector2d</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">...;</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prog</span><span class="p">.</span><span class="n">NewContinuousVariables</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;x&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">prog</span><span class="p">.</span><span class="n">AddConstraint</span><span class="p">((</span><span class="n">A</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">).</span><span class="n">array</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">array</span><span class="p">());</span>
</pre></div>
</div>
</details><p>A formula in <code class="docutils literal notranslate"><span class="pre">formulas</span></code> can be of the following forms:</p>
<ol class="arabic simple">
<li><p>e1 &lt;= e2</p></li>
<li><p>e1 &gt;= e2</p></li>
<li><p>e1 == e2</p></li>
</ol>
<p>It throws an exception if AddConstraint(const symbolic::Formula&amp; f)
throws an exception for f ∈ <code class="docutils literal notranslate"><span class="pre">formulas</span></code>.</p>
<p>&#64;overload Binding&lt;Constraint&gt; AddConstraint(const symbolic::Formula&amp;
f)</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">Derived</span></code>:</dt><dd><p>Eigen::Matrix or Eigen::Array with Formula as the Scalar.</p>
</dd>
</dl>
<ol class="arabic simple" start="6">
<li><p>AddConstraint(self: pydrake.solvers.MathematicalProgram, binding: pydrake.solvers.Binding[Constraint]) -&gt; pydrake.solvers.Binding[Constraint]</p></li>
</ol>
<p>Adds a generic constraint to the program. This should only be used if
a more specific type of constraint is not available, as it may require
the use of a significantly more expensive solver.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code class="docutils literal notranslate"><span class="pre">binding</span></code>.evaluator()-&gt;num_constraints() == 0, then this
constraint is not added into the MathematicalProgram. We return
<code class="docutils literal notranslate"><span class="pre">binding</span></code> directly.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.AddCost(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddCost(self: pydrake.solvers.MathematicalProgram, func: Callable, vars: numpy.ndarray[object[m, 1]], description: str = ‘’) -&gt; pydrake.solvers.Binding[Cost]</p></li>
</ol>
<p>Adds a cost function.</p>
<ol class="arabic simple" start="2">
<li><p>AddCost(self: pydrake.solvers.MathematicalProgram, binding: pydrake.solvers.Binding[Cost]) -&gt; pydrake.solvers.Binding[Cost]</p></li>
</ol>
<p>Adds a generic cost to the optimization program.</p>
<ol class="arabic simple" start="3">
<li><p>AddCost(self: pydrake.solvers.MathematicalProgram, e: pydrake.symbolic.Expression) -&gt; pydrake.solvers.Binding[Cost]</p></li>
</ol>
<p>Adds a cost in the symbolic form.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The newly created cost, together with the bound variables.</p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>AddCost(self: pydrake.solvers.MathematicalProgram, obj: pydrake.solvers.Cost, vars: numpy.ndarray[object[m, 1]]) -&gt; pydrake.solvers.Binding[Cost]</p></li>
</ol>
<p>Adds a cost type to the optimization program.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">obj</span></code>:</dt><dd><p>The added objective.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">vars</span></code>:</dt><dd><p>The decision variables on which the cost depend.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.AddDecisionVariables(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">decision_variables:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Appends new variables to the end of the existing variables.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">decision_variables</span></code>:</dt><dd><p>The newly added decision_variables.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">decision_variables</span></code> should not intersect with the existing
indeterminates in the optimization program.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the preconditions are not satisfied.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.AddEqualityConstraintBetweenPolynomials(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">p1:</span> <span class="pre">pydrake.symbolic.Polynomial,</span> <span class="pre">p2:</span> <span class="pre">pydrake.symbolic.Polynomial)</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.solvers.Binding[LinearEqualityConstraint]]</span></span></dt>
<dd><p>Constraining that two polynomials are the same (i.e., they have the
same coefficients for each monomial). This function is often used in
sum-of-squares optimization. We will impose the linear equality
constraint that the coefficient of a monomial in <code class="docutils literal notranslate"><span class="pre">p1</span></code> is the same as
the coefficient of the same monomial in <code class="docutils literal notranslate"><span class="pre">p2</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p1</span></code>:</dt><dd><p>Note that p1’s indeterminates should have been registered as
indeterminates in this MathematicalProgram object, and p1’s
coefficients are affine functions of decision variables in this
MathematicalProgram object.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p2</span></code>:</dt><dd><p>Note that p2’s indeterminates should have been registered as
indeterminates in this MathematicalProgram object, and p2’s
coefficients are affine functions of decision variables in this
MathematicalProgram object.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It calls <code class="docutils literal notranslate"><span class="pre">Reparse</span></code> to enforce <code class="docutils literal notranslate"><span class="pre">p1</span></code> and <code class="docutils literal notranslate"><span class="pre">p2</span></code> to have this
MathematicalProgram’s indeterminates.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.AddExponentialConeConstraint(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddExponentialConeConstraint(self: pydrake.solvers.MathematicalProgram, A: numpy.ndarray[numpy.float64[3, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[3, 1]], vars: numpy.ndarray[object[m, 1]]) -&gt; pydrake.solvers.Binding[ExponentialConeConstraint]</p></li>
</ol>
<p>Adds an exponential cone constraint, that z = A * vars + b should be
in the exponential cone. Namely {z₀, z₁, z₂ | z₀ ≥ z₁ * exp(z₂ / z₁),
z₁ &gt; 0}, or equivalently (using the logarithm function), {z₀, z₁, z₂ |
z₂ ≤ z₁ * log(z₀ / z₁), z₀ &gt; 0, z₁ &gt; 0}.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">A</span></code>:</dt><dd><p>The A matrix in the documentation above. A must have 3 rows.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>:</dt><dd><p>The b vector in the documentation above.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">vars</span></code>:</dt><dd><p>The variables bound with this constraint.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>AddExponentialConeConstraint(self: pydrake.solvers.MathematicalProgram, z: numpy.ndarray[object[3, 1]]) -&gt; pydrake.solvers.Binding[ExponentialConeConstraint]</p></li>
</ol>
<p>Add the constraint that z is in the exponential cone.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">z</span></code>:</dt><dd><p>The expression in the exponential cone.</p>
</dd>
<dt>Precondition:</dt><dd><p>each entry in <code class="docutils literal notranslate"><span class="pre">z</span></code> is a linear expression of the decision
variables.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.AddIndeterminate(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">new_indeterminate:</span> <span class="pre">pydrake.symbolic.Variable)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Adds indeterminate. This method appends an indeterminate to the end of
the program’s old indeterminates, if <code class="docutils literal notranslate"><span class="pre">new_indeterminate</span></code> is not
already in the program’s old indeterminates.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_indeterminate</span></code>:</dt><dd><p>The indeterminate to be appended to the program’s old
indeterminates.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>indeterminate_index The index of the added indeterminate in the
program’s indeterminates. i.e.
prog.indeterminates()(indeterminate_index) = new_indeterminate.</p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">new_indeterminate</span></code> should not intersect with the program’s
decision variables.</p>
</dd>
<dt>Precondition:</dt><dd><p>new_indeterminate should be of CONTINUOUS type.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.AddIndeterminates(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddIndeterminates(self: pydrake.solvers.MathematicalProgram, new_indeterminates: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; None</p></li>
</ol>
<p>Adds indeterminates. This method appends some indeterminates to the
end of the program’s old indeterminates.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_indeterminates</span></code>:</dt><dd><p>The indeterminates to be appended to the program’s old
indeterminates.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">new_indeterminates</span></code> should not intersect with the program’s old
decision variables.</p>
</dd>
<dt>Precondition:</dt><dd><p>Each entry in new_indeterminates should be of CONTINUOUS type.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>AddIndeterminates(self: pydrake.solvers.MathematicalProgram, new_indeterminates: pydrake.symbolic.Variables) -&gt; None</p></li>
</ol>
<p>Adds indeterminates. This method appends some indeterminates to the
end of the program’s old indeterminates.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_indeterminates</span></code>:</dt><dd><p>The indeterminates to be appended to the program’s old
indeterminates.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">new_indeterminates</span></code> should not intersect with the program’s old
decision variables.</p>
</dd>
<dt>Precondition:</dt><dd><p>Each entry in new_indeterminates should be of CONTINUOUS type.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.AddL2NormCost(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddL2NormCost(self: pydrake.solvers.MathematicalProgram, A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[m, 1]], vars: numpy.ndarray[object[m, 1]]) -&gt; pydrake.solvers.Binding[L2NormCost]</p></li>
</ol>
<p>Adds an L2 norm cost <a href="#id3"><span class="problematic" id="id4">|</span></a>Ax+b|₂ (notice this cost is not quadratic since
we don’t take the square of the L2 norm).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently kL2NormCost is supported by SnoptSolver, IpoptSolver,
GurobiSolver, MosekSolver, ClarabelSolver, and SCSSolver.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>AddL2NormCost(self: pydrake.solvers.MathematicalProgram, e: pydrake.symbolic.Expression, psd_tol: float = 1e-08, coefficient_tol: float = 1e-08) -&gt; pydrake.solvers.Binding[L2NormCost]</p></li>
</ol>
<p>Adds an L2 norm cost <a href="#id5"><span class="problematic" id="id6">|</span></a>Ax+b|₂ from a symbolic expression which can be
decomposed into sqrt((Ax+b)’(Ax+b)). See
symbolic::DecomposeL2NormExpression for details on the tolerance
parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if e cannot be decomposed into an L2 norm.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.AddL2NormCostUsingConicConstraint(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">A:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous],</span> <span class="pre">b:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">vars:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">tuple[pydrake.symbolic.Variable,</span> <span class="pre">pydrake.solvers.Binding[LinearCost],</span> <span class="pre">pydrake.solvers.Binding[LorentzConeConstraint]]</span></span></dt>
<dd><p>Adds an L2 norm cost min <a href="#id7"><span class="problematic" id="id8">|</span></a>Ax+b|₂ as a linear cost min s on the slack
variable s, together with a Lorentz cone constraint s ≥ <a href="#id9"><span class="problematic" id="id10">|</span></a>Ax+b|₂ Many
conic optimization solvers (Gurobi, MOSEK<a href="/tm.html">™</a>, SCS, etc) natively prefers
this form of linear cost + conic constraints. So if you are going to
use one of these conic solvers, then add the L2 norm cost using this
function instead of AddL2NormCost().</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>(s, linear_cost, lorentz_cone_constraint). <code class="docutils literal notranslate"><span class="pre">s</span></code> is the slack
variable (with variable name string as “slack”), <code class="docutils literal notranslate"><span class="pre">linear_cost</span></code>
is the cost on <code class="docutils literal notranslate"><span class="pre">s</span></code>, and <code class="docutils literal notranslate"><span class="pre">lorentz_cone_constraint</span></code> is the
constraint s≥|Ax+b|₂</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.AddLinearComplementarityConstraint(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">M:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous],</span> <span class="pre">q:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">vars:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.Binding[LinearComplementarityConstraint]</span></span></dt>
<dd><p>Adds a linear complementarity constraints referencing a subset of the
decision variables.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.AddLinearConstraint(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddLinearConstraint(self: pydrake.solvers.MathematicalProgram, A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], lb: numpy.ndarray[numpy.float64[m, 1]], ub: numpy.ndarray[numpy.float64[m, 1]], vars: numpy.ndarray[object[m, 1]]) -&gt; pydrake.solvers.Binding[LinearConstraint]</p></li>
</ol>
<p>Adds linear constraints referencing potentially a subset of the
decision variables (defined in the vars parameter).</p>
<ol class="arabic simple" start="2">
<li><p>AddLinearConstraint(self: pydrake.solvers.MathematicalProgram, a: numpy.ndarray[numpy.float64[1, n]], lb: float, ub: float, vars: numpy.ndarray[object[m, 1]]) -&gt; pydrake.solvers.Binding[LinearConstraint]</p></li>
</ol>
<p>Adds one row of linear constraint referencing potentially a subset of
the decision variables (defined in the vars parameter). lb &lt;= a*vars
&lt;= ub</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">a</span></code>:</dt><dd><p>A row vector.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lb</span></code>:</dt><dd><p>A scalar, the lower bound.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">ub</span></code>:</dt><dd><p>A scalar, the upper bound.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">vars</span></code>:</dt><dd><p>The decision variables on which to impose the linear constraint.</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>AddLinearConstraint(self: pydrake.solvers.MathematicalProgram, A: scipy.sparse.csc_matrix[numpy.float64], lb: numpy.ndarray[numpy.float64[m, 1]], ub: numpy.ndarray[numpy.float64[m, 1]], vars: numpy.ndarray[object[m, 1]]) -&gt; pydrake.solvers.Binding[LinearConstraint]</p></li>
</ol>
<p>Adds sparse linear constraints referencing potentially a subset of the
decision variables (defined in the vars parameter).</p>
<ol class="arabic simple" start="4">
<li><p>AddLinearConstraint(self: pydrake.solvers.MathematicalProgram, e: pydrake.symbolic.Expression, lb: float, ub: float) -&gt; pydrake.solvers.Binding[LinearConstraint]</p></li>
</ol>
<p>Adds one row of linear constraint lb &lt;= e &lt;= ub where <code class="docutils literal notranslate"><span class="pre">e</span></code> is a
symbolic expression.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if 1. e is a non-linear expression. 2. ``lb &lt;= e</strong> – </p></li>
<li><p><strong>&lt;= ub`` is a trivial constraint such as 1 &lt;= 2 &lt;= 3. 3. ``lb &lt;= e</strong> – </p></li>
<li><p><strong>&lt;= ub`` is unsatisfiable such as 1 &lt;= -5 &lt;= 3</strong> – </p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">e</span></code>:</dt><dd><p>A linear symbolic expression in the form of <code class="docutils literal notranslate"><span class="pre">c0</span> <span class="pre">+</span> <span class="pre">c1</span> <span class="pre">*</span> <span class="pre">v1</span> <span class="pre">+</span> <span class="pre">...</span> <span class="pre">+</span>
<span class="pre">cn</span> <span class="pre">*</span> <span class="pre">vn</span></code> where <code class="docutils literal notranslate"><span class="pre">c_i</span></code> is a constant and &#64;v_i is a variable.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lb</span></code>:</dt><dd><p>A scalar, the lower bound.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">ub</span></code>:</dt><dd><p>A scalar, the upper bound.</p>
</dd>
</dl>
<ol class="arabic simple" start="5">
<li><p>AddLinearConstraint(self: pydrake.solvers.MathematicalProgram, v: numpy.ndarray[object[m, n], flags.f_contiguous], lb: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], ub: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]) -&gt; pydrake.solvers.Binding[LinearConstraint]</p></li>
</ol>
<p>Adds linear constraints represented by symbolic expressions to the
program. It throws if &#64;v includes a non-linear expression or <code class="docutils literal notranslate"><span class="pre">lb</span> <span class="pre">&lt;=</span> <span class="pre">v</span>
<span class="pre">&lt;=</span> <span class="pre">ub</span></code> includes trivial/unsatisfiable constraints.</p>
<ol class="arabic simple" start="6">
<li><p>AddLinearConstraint(self: pydrake.solvers.MathematicalProgram, f: pydrake.symbolic.Formula) -&gt; pydrake.solvers.Binding[LinearConstraint]</p></li>
</ol>
<p>Add a linear constraint represented by a symbolic formula to the
program. The input formula <code class="docutils literal notranslate"><span class="pre">f</span></code> can be of the following forms:</p>
<ol class="arabic simple">
<li><p>e1 &lt;= e2</p></li>
<li><p>e1 &gt;= e2</p></li>
<li><p>e1 == e2</p></li>
<li><p>A conjunction of relational formulas where each conjunct is
a relational formula matched by 1, 2, or 3.</p></li>
</ol>
<p>Note that first two cases might return an object of
Binding&lt;BoundingBoxConstraint&gt; depending on <code class="docutils literal notranslate"><span class="pre">f</span></code>. Also the third case
returns an object of Binding&lt;LinearEqualityConstraint&gt;.</p>
<p>It throws an exception if 1. <code class="docutils literal notranslate"><span class="pre">f</span></code> is not matched with one of the
above patterns. Especially, strict inequalities (&lt;, &gt;) are not
allowed. 2. <code class="docutils literal notranslate"><span class="pre">f</span></code> includes a non-linear expression. 3. <code class="docutils literal notranslate"><span class="pre">f</span></code> is either
a trivial constraint such as “1 &lt;= 2” or an unsatisfiable constraint
such as “2 &lt;= 1”. 4. It is not possible to find numerical bounds of
<code class="docutils literal notranslate"><span class="pre">e1</span></code> and <code class="docutils literal notranslate"><span class="pre">e2</span></code> where <code class="docutils literal notranslate"><span class="pre">f</span></code> = e1 ≃ e2. We allow <code class="docutils literal notranslate"><span class="pre">e1</span></code> and <code class="docutils literal notranslate"><span class="pre">e2</span></code> to
be infinite but only if there are no other terms. For example, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;=</span>
<span class="pre">∞</span></code> is allowed. However, <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">-</span> <span class="pre">∞</span> <span class="pre">&lt;=</span> <span class="pre">0</span></code> is not allowed because <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">↦</span>
<span class="pre">∞</span></code> introduces <code class="docutils literal notranslate"><span class="pre">nan</span></code> in the evaluation.</p>
<ol class="arabic simple" start="7">
<li><p>AddLinearConstraint(self: pydrake.solvers.MathematicalProgram, formulas: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; pydrake.solvers.Binding[LinearConstraint]</p></li>
</ol>
<p>Add a linear constraint represented by an
Eigen::Array&lt;symbolic::Formula&gt; to the program. A common use-case of
this function is to add a linear constraint with the element-wise
comparison between two Eigen matrices, using <code class="docutils literal notranslate"><span class="pre">A.array()</span> <span class="pre">&lt;=</span>
<span class="pre">B.array()</span></code>. See the following example.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MathematicalProgram</span><span class="w"> </span><span class="n">prog</span><span class="p">;</span>
<span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">A</span><span class="p">;</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prog</span><span class="p">.</span><span class="n">NewContinuousVariables</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;x&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector2d</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">  </span><span class="p">...</span><span class="w"> </span><span class="c1">// set up A and b</span>
<span class="w">  </span><span class="n">prog</span><span class="p">.</span><span class="n">AddLinearConstraint</span><span class="p">((</span><span class="n">A</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">).</span><span class="n">array</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">array</span><span class="p">());</span>
</pre></div>
</div>
</details><p>A formula in <code class="docutils literal notranslate"><span class="pre">formulas</span></code> can be of the following forms:</p>
<ol class="arabic simple">
<li><p>e1 &lt;= e2 2. e1 &gt;= e2 3. e1 == e2</p></li>
</ol>
<p>It throws an exception if AddLinearConstraint(const symbolic::Formula&amp;
f) throws an exception for f ∈ <code class="docutils literal notranslate"><span class="pre">formulas</span></code>.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">Derived</span></code>:</dt><dd><p>An Eigen Array type of Formula.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.AddLinearCost(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddLinearCost(self: pydrake.solvers.MathematicalProgram, e: pydrake.symbolic.Expression) -&gt; pydrake.solvers.Binding[LinearCost]</p></li>
</ol>
<p>Adds a linear cost term of the form a’<a href="#id15"><span class="problematic" id="id16">*</span></a>x + b.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">e</span></code>:</dt><dd><p>A linear symbolic expression.</p>
</dd>
<dt>Precondition:</dt><dd><p>e is a linear expression a’<a href="#id17"><span class="problematic" id="id18">*</span></a>x + b, where each entry of x is a
decision variable in the mathematical program.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The newly added linear constraint, together with the bound
variables.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>AddLinearCost(self: pydrake.solvers.MathematicalProgram, a: numpy.ndarray[numpy.float64[m, 1]], b: float, vars: numpy.ndarray[object[m, 1]]) -&gt; pydrake.solvers.Binding[LinearCost]</p></li>
</ol>
<p>Adds a linear cost term of the form a’<a href="#id19"><span class="problematic" id="id20">*</span></a>x + b. Applied to a subset of
the variables and pushes onto the linear cost data structure.</p>
<ol class="arabic simple" start="3">
<li><p>AddLinearCost(self: pydrake.solvers.MathematicalProgram, a: numpy.ndarray[numpy.float64[m, 1]], vars: numpy.ndarray[object[m, 1]]) -&gt; pydrake.solvers.Binding[LinearCost]</p></li>
</ol>
<p>Adds a linear cost term of the form a’<a href="#id21"><span class="problematic" id="id22">*</span></a>x. Applied to a subset of the
variables and pushes onto the linear cost data structure.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.AddLinearEqualityConstraint(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddLinearEqualityConstraint(self: pydrake.solvers.MathematicalProgram, Aeq: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], beq: numpy.ndarray[numpy.float64[m, 1]], vars: numpy.ndarray[object[m, 1]]) -&gt; pydrake.solvers.Binding[LinearEqualityConstraint]</p></li>
</ol>
<p>AddLinearEqualityConstraint</p>
<p>Adds linear equality constraints referencing potentially a subset of
the decision variables.</p>
<p>Example: to add two equality constraints which only depend on two of
the elements of x, you could use</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prog</span><span class="p">.</span><span class="n">NewContinuousVariables</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="s">&quot;myvar&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix2d</span><span class="w"> </span><span class="n">Aeq</span><span class="p">;</span>
<span class="w">  </span><span class="n">Aeq</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">          </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector2d</span><span class="w"> </span><span class="nf">beq</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// Imposes constraint</span>
<span class="w">  </span><span class="c1">// -x(0) + 2x(1) = 1</span>
<span class="w">  </span><span class="c1">//  x(0) +  x(1) = 3</span>
<span class="w">  </span><span class="n">prog</span><span class="p">.</span><span class="n">AddLinearEqualityConstraint</span><span class="p">(</span><span class="n">Aeq</span><span class="p">,</span><span class="w"> </span><span class="n">beq</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">.</span><span class="n">head</span><span class="o">&lt;</span><span class="mi">2</span><span class="o">&gt;</span><span class="p">());</span>
</pre></div>
</div>
</details><ol class="arabic simple" start="2">
<li><p>AddLinearEqualityConstraint(self: pydrake.solvers.MathematicalProgram, a: numpy.ndarray[numpy.float64[1, n]], beq: float, vars: numpy.ndarray[object[m, 1]]) -&gt; pydrake.solvers.Binding[LinearEqualityConstraint]</p></li>
</ol>
<p>Adds one row of linear equality constraint referencing potentially a
subset of decision variables.</p>
<div class="math notranslate nohighlight">
\[ax = beq\]</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">a</span></code>:</dt><dd><p>A row vector.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">beq</span></code>:</dt><dd><p>A scalar.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">vars</span></code>:</dt><dd><p>The decision variables on which the constraint is imposed.</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>AddLinearEqualityConstraint(self: pydrake.solvers.MathematicalProgram, Aeq: scipy.sparse.csc_matrix[numpy.float64], beq: numpy.ndarray[numpy.float64[m, 1]], vars: numpy.ndarray[object[m, 1]]) -&gt; pydrake.solvers.Binding[LinearEqualityConstraint]</p></li>
</ol>
<p>AddLinearEqualityConstraint</p>
<p>Adds linear equality constraints referencing potentially a subset of
the decision variables using a sparse A matrix.</p>
<ol class="arabic simple" start="4">
<li><p>AddLinearEqualityConstraint(self: pydrake.solvers.MathematicalProgram, e: pydrake.symbolic.Expression, b: float) -&gt; pydrake.solvers.Binding[LinearEqualityConstraint]</p></li>
</ol>
<p>Adds one row of linear constraint e = b where <code class="docutils literal notranslate"><span class="pre">e</span></code> is a symbolic
expression.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if 1. e is a non-linear expression. 2. e is a</strong> – </p></li>
<li><p><strong>constant.</strong> – </p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">e</span></code>:</dt><dd><p>A linear symbolic expression in the form of <code class="docutils literal notranslate"><span class="pre">c0</span> <span class="pre">+</span> <span class="pre">c1</span> <span class="pre">*</span> <span class="pre">x1</span> <span class="pre">+</span> <span class="pre">...</span> <span class="pre">+</span>
<span class="pre">cn</span> <span class="pre">*</span> <span class="pre">xn</span></code> where <code class="docutils literal notranslate"><span class="pre">c_i</span></code> is a constant and &#64;x_i is a variable.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>:</dt><dd><p>A scalar.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The newly added linear equality constraint, together with the
bound variable.</p>
</dd>
</dl>
<ol class="arabic simple" start="5">
<li><p>AddLinearEqualityConstraint(self: pydrake.solvers.MathematicalProgram, f: pydrake.symbolic.Formula) -&gt; pydrake.solvers.Binding[LinearEqualityConstraint]</p></li>
</ol>
<p>Adds a linear equality constraint represented by a symbolic formula to
the program. The input formula <code class="docutils literal notranslate"><span class="pre">f</span></code> is either an equality formula
(<code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">==</span> <span class="pre">e2</span></code>) or a conjunction of equality formulas.</p>
<p>It throws an exception if</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">f</span></code> is neither an equality formula nor a conjunction of equalities.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">f</span></code> includes a non-linear expression.</p></li>
</ol>
<ol class="arabic simple" start="6">
<li><p>AddLinearEqualityConstraint(self: pydrake.solvers.MathematicalProgram, formulas: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; pydrake.solvers.Binding[LinearEqualityConstraint]</p></li>
</ol>
<p>Adds a linear equality constraint represented by an
Eigen::Array&lt;symbolic::Formula&gt; to the program. A common use-case of
this function is to add a linear constraint with the element-wise
comparison between two Eigen matrices, using <code class="docutils literal notranslate"><span class="pre">A.array()</span> <span class="pre">==</span>
<span class="pre">B.array()</span></code>. See the following example.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MathematicalProgram</span><span class="w"> </span><span class="n">prog</span><span class="p">;</span>
<span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">A</span><span class="p">;</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prog</span><span class="p">.</span><span class="n">NewContinuousVariables</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;x&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector2d</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">  </span><span class="p">...</span><span class="w"> </span><span class="c1">// set up A and b</span>
<span class="w">  </span><span class="n">prog</span><span class="p">.</span><span class="n">AddLinearConstraint</span><span class="p">((</span><span class="n">A</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">).</span><span class="n">array</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">b</span><span class="p">.</span><span class="n">array</span><span class="p">());</span>
</pre></div>
</div>
</details><p>It throws an exception if AddLinearConstraint(const symbolic::Formula&amp;
f) throws an exception for f ∈ <code class="docutils literal notranslate"><span class="pre">formulas</span></code>.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">Derived</span></code>:</dt><dd><p>An Eigen Array type of Formula.</p>
</dd>
</dl>
<ol class="arabic simple" start="7">
<li><p>AddLinearEqualityConstraint(self: pydrake.solvers.MathematicalProgram, v: numpy.ndarray[object[m, 1]], b: numpy.ndarray[numpy.float64[m, 1]]) -&gt; pydrake.solvers.Binding[LinearEqualityConstraint]</p></li>
</ol>
<p>Adds linear equality constraints <span class="math notranslate nohighlight">\(v = b\)</span>, where <code class="docutils literal notranslate"><span class="pre">v(i)</span></code> is a
symbolic linear expression.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if 1. v</strong><strong>(</strong><strong>i</strong><strong>) </strong><strong>is a non-linear expression. 2.</strong> – </p></li>
<li><p><strong>v</strong><strong>(</strong><strong>i</strong><strong>)</strong><strong>` is a constant</strong> – </p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">DerivedV</span></code>:</dt><dd><p>An Eigen Matrix type of Expression. A column vector.</p>
</dd>
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">DerivedB</span></code>:</dt><dd><p>An Eigen Matrix type of double. A column vector.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v</span></code>:</dt><dd><p>v(i) is a linear symbolic expression in the form of `` c0 + c1 *
x1 + … + cn * xn `` where ci is a constant and &#64;xi is a
variable.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>:</dt><dd><p>A vector of doubles.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The newly added linear equality constraint, together with the
bound variables.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.AddLinearMatrixInequalityConstraint(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddLinearMatrixInequalityConstraint(self: pydrake.solvers.MathematicalProgram, F: list[numpy.ndarray[numpy.float64[m, n]]], vars: numpy.ndarray[object[m, 1]]) -&gt; pydrake.solvers.Binding[LinearMatrixInequalityConstraint]</p></li>
</ol>
<p>Adds a linear matrix inequality constraint to the program.</p>
<ol class="arabic simple" start="2">
<li><p>AddLinearMatrixInequalityConstraint(self: pydrake.solvers.MathematicalProgram, X: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; pydrake.solvers.Binding[LinearMatrixInequalityConstraint]</p></li>
</ol>
<p>Adds a linear matrix inequality constraint on a symmetric matrix of
symbolic expressions <code class="docutils literal notranslate"><span class="pre">X</span></code>, namely <code class="docutils literal notranslate"><span class="pre">X</span></code> is positive semidefinite, and
each entry in <code class="docutils literal notranslate"><span class="pre">X</span></code> is a linear (affine) expression of decision
variables.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X</span></code>:</dt><dd><p>Imposes constraint “X is positive semidefinite”.</p>
</dd>
<dt>Precondition:</dt><dd><p>X is symmetric.</p>
</dd>
<dt>Precondition:</dt><dd><p>X(i, j) is linear (affine) for all i, j</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The newly added linear matrix inequality constraint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.AddLogDeterminantLowerBoundConstraint(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">X:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous],</span> <span class="pre">lower:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">tuple[pydrake.solvers.Binding[LinearConstraint],</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]],</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]]]</span></span></dt>
<dd><p>Impose the constraint log(det(X)) &gt;= lower. See log_determinant for
more details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X</span></code>:</dt><dd><p>A symmetric positive semidefinite matrix X.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lower</span></code>:</dt><dd><p>The lower bound of log(det(X))</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>(constraint, t, Z) constraint is ∑ᵢt(i) &gt;= lower, we also return
the newly created slack variables t and the lower triangular
matrix Z. Note that Z is not a matrix of symbolic::Variable but
symbolic::Expression, because the upper-diagonal entries of Z are
not variable, but expression 0.</p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>X is a symmetric matrix.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.AddLorentzConeConstraint(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddLorentzConeConstraint(self: pydrake.solvers.MathematicalProgram, f: pydrake.symbolic.Formula, eval_type: pydrake.solvers.LorentzConeConstraint.EvalType = &lt;EvalType.kConvexSmooth: 1&gt;, psd_tol: float = 1e-08, coefficient_tol: float = 1e-08) -&gt; pydrake.solvers.Binding[LorentzConeConstraint]</p></li>
</ol>
<p>Adds a Lorentz cone constraint of the form Ax+b &gt;= <a href="#id23"><span class="problematic" id="id24">|</span></a>Cx+d|₂ from a
symbolic formula with one side which can be decomposed into
sqrt((Cx+d)’(Cx+d)).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">eval_type</span></code>:</dt><dd><p>The evaluation type when evaluating the lorentz cone constraint in
generic optimization. Refer to LorentzConeConstraint::EvalType for
more details.</p>
</dd>
</dl>
<p>See symbolic::DecomposeL2NormExpression for details on the tolerance
parameters, <code class="docutils literal notranslate"><span class="pre">psd_tol</span></code> and <code class="docutils literal notranslate"><span class="pre">coefficient_tol</span></code>. Consider using the
overload which takes a vector of expressions to avoid the numerical
decomposition.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if f cannot be decomposed into a Lorentz cone.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>AddLorentzConeConstraint(self: pydrake.solvers.MathematicalProgram, v: numpy.ndarray[object[m, 1]], eval_type: pydrake.solvers.LorentzConeConstraint.EvalType = &lt;EvalType.kConvexSmooth: 1&gt;) -&gt; pydrake.solvers.Binding[LorentzConeConstraint]</p></li>
</ol>
<p>Adds Lorentz cone constraint referencing potentially a subset of the
decision variables.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v</span></code>:</dt><dd><p>An Eigen::Vector of symbolic::Expression. Constraining that</p>
</dd>
</dl>
<div class="math notranslate nohighlight">
\[v_0 \ge \sqrt{v_1^2 + ... + v_{n-1}^2}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The newly constructed Lorentz cone constraint with the bounded
variables. For example, to add the Lorentz cone constraint</p>
</dd>
</dl>
<p>x+1 &gt;= sqrt(y² + 2y + x² + 5), = sqrt((y+1)²+x²+2²) The user could
call</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">cc</span><span class="p">}</span>
<span class="n">Vector4</span><span class="o">&lt;</span><span class="n">symbolic</span><span class="o">::</span><span class="n">Expression</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mf">2.</span><span class="p">);</span>
<span class="n">prog</span><span class="p">.</span><span class="n">AddLorentzConeConstraint</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
</pre></div>
</div>
</details><dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">eval_type</span></code>:</dt><dd><p>The evaluation type when evaluating the lorentz cone constraint in
generic optimization. Refer to LorentzConeConstraint::EvalType for
more details.</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>AddLorentzConeConstraint(self: pydrake.solvers.MathematicalProgram, linear_expression: pydrake.symbolic.Expression, quadratic_expression: pydrake.symbolic.Expression, tol: float = 0.0, eval_type: pydrake.solvers.LorentzConeConstraint.EvalType = &lt;EvalType.kConvexSmooth: 1&gt;) -&gt; pydrake.solvers.Binding[LorentzConeConstraint]</p></li>
</ol>
<p>Adds Lorentz cone constraint on the linear expression v1 and quadratic
expression v2, such that v1 &gt;= sqrt(v2)</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">linear_expression</span></code>:</dt><dd><p>The linear expression v1.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quadratic_expression</span></code>:</dt><dd><p>The quadratic expression v2.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">tol</span></code>:</dt><dd><p>The tolerance to determine if the matrix in v2 is positive
semidefinite or not.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DecomposePositiveQuadraticForm for more explanation. $*Default:*
is 0.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">eval_type</span></code>:</dt><dd><p>The evaluation type when evaluating the lorentz cone constraint in
generic optimization. Refer to LorentzConeConstraint::EvalType for
more details.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">binding</span></code>:</dt><dd><p>The newly added Lorentz cone constraint, together with the bound
variables.</p>
</dd>
</dl>
<p>Precondition:
1. <code class="docutils literal notranslate"><span class="pre">v1</span></code> is a linear expression, in the form of c’<a href="#id25"><span class="problematic" id="id26">*</span></a>x + d.
2. <code class="docutils literal notranslate"><span class="pre">v2</span></code> is a quadratic expression, in the form of</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="err">&#39;</span><span class="o">*</span><span class="n">Q</span><span class="o">*</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="err">&#39;</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span>
</pre></div>
</div>
</details><p>Also the quadratic expression has to be convex, namely Q is a positive
semidefinite matrix, and the quadratic expression needs to be
non-negative for any x.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the preconditions are not satisfied.</strong> – </p>
</dd>
</dl>
<p>Notice this constraint is equivalent to the vector [z;y] is within a
Lorentz cone, where</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v1</span>
<span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">d</span>
</pre></div>
</div>
</details><p>while (R, d) satisfies y’<a href="#id27"><span class="problematic" id="id28">*</span></a>y = x’<a href="#id29"><span class="problematic" id="id30">*</span></a>Q*x + b’<a href="#id31"><span class="problematic" id="id32">*</span></a>x + a For example, to add
the Lorentz cone constraint</p>
<p>x+1 &gt;= sqrt(y² + 2y + x² + 4), the user could call</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">cc</span><span class="p">}</span>
<span class="n">prog</span><span class="p">.</span><span class="n">AddLorentzConeConstraint</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">pow</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
</pre></div>
</div>
</details><ol class="arabic simple" start="4">
<li><p>AddLorentzConeConstraint(self: pydrake.solvers.MathematicalProgram, A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[m, 1]], vars: numpy.ndarray[object[m, 1]], eval_type: pydrake.solvers.LorentzConeConstraint.EvalType = &lt;EvalType.kConvexSmooth: 1&gt;) -&gt; pydrake.solvers.Binding[LorentzConeConstraint]</p></li>
</ol>
<p>Adds Lorentz cone constraint referencing potentially a subset of the
decision variables (defined in the vars parameter). The linear
expression <span class="math notranslate nohighlight">\(z=Ax+b\)</span> is in the Lorentz cone. A vector <span class="math notranslate nohighlight">\(z
\in\mathbb{R}^n\)</span> is in the Lorentz cone, if</p>
<div class="math notranslate nohighlight">
\[z_0 \ge \sqrt{z_1^2 + ... + z_{n-1}^2}\]</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">A</span></code>:</dt><dd><p>A <span class="math notranslate nohighlight">\(\mathbb{R}^{n\times m}\)</span> matrix, whose number of columns
equals to the size of the decision variables.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>:</dt><dd><p>A <span class="math notranslate nohighlight">\(\mathbb{R}^n\)</span> vector, whose number of rows equals to the
size of the decision variables.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">vars</span></code>:</dt><dd><p>The Eigen vector of <span class="math notranslate nohighlight">\(m\)</span> decision variables.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">eval_type</span></code>:</dt><dd><p>The evaluation type when evaluating the lorentz cone constraint in
generic optimization. Refer to LorentzConeConstraint::EvalType for
more details.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The newly added Lorentz cone constraint.</p>
</dd>
</dl>
<p>For example, to add the Lorentz cone constraint</p>
<p>x+1 &gt;= sqrt(y² + 2y + x² + 5) = sqrt((y+1)² + x² + 2²), the user could
call</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">cc</span><span class="p">}</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">A</span><span class="p">;</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector4d</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="n">A</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="n">b</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="c1">// A * [x;y] + b = [x+1; y+1; x; 2]</span>
<span class="n">prog</span><span class="p">.</span><span class="n">AddLorentzConeConstraint</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">Vector2</span><span class="o">&lt;</span><span class="n">symbolic</span><span class="o">::</span><span class="n">Variable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">));</span>
</pre></div>
</div>
</details></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.AddMaximizeGeometricMeanCost(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddMaximizeGeometricMeanCost(self: pydrake.solvers.MathematicalProgram, A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[m, 1]], x: numpy.ndarray[object[m, 1]]) -&gt; pydrake.solvers.Binding[LinearCost]</p></li>
</ol>
<p>An overloaded version of maximize_geometric_mean.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>cost The added cost (note that since MathematicalProgram only
minimizes the cost, the returned cost evaluates to -power(∏ᵢz(i),
1/n) where z = A*x+b.</p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>A.rows() == b.rows(), A.rows() &gt;= 2.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>AddMaximizeGeometricMeanCost(self: pydrake.solvers.MathematicalProgram, x: numpy.ndarray[object[m, 1]], c: float) -&gt; pydrake.solvers.Binding[LinearCost]</p></li>
</ol>
<p>An overloaded version of maximize_geometric_mean. We add the cost to
maximize the geometric mean of x, i.e., c*power(∏ᵢx(i), 1/n).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">c</span></code>:</dt><dd><p>The positive coefficient of the geometric mean cost, $*Default:*
is 1.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>cost The added cost (note that since MathematicalProgram only
minimizes the cost, the returned cost evaluates to -c *
power(∏ᵢx(i), 1/n).</p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>x.rows() &gt;= 2.</p>
</dd>
<dt>Precondition:</dt><dd><p>c &gt; 0.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.AddMaximizeLogDeterminantCost(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">X:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous])</span> <span class="pre">-&gt;</span> <span class="pre">tuple[pydrake.solvers.Binding[LinearCost],</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]],</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]]]</span></span></dt>
<dd><p>Maximize the log determinant. See log_determinant for more details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X</span></code>:</dt><dd><p>A symmetric positive semidefinite matrix X, whose log(det(X)) will
be maximized.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>(cost, t, Z) cost is -∑ᵢt(i), we also return the newly created
slack variables t and the lower triangular matrix Z. Note that Z
is not a matrix of symbolic::Variable but symbolic::Expression,
because the upper-diagonal entries of Z are not variable, but
expression 0.</p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>X is a symmetric matrix.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.AddPositiveDiagonallyDominantDualConeMatrixConstraint(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddPositiveDiagonallyDominantDualConeMatrixConstraint(self: pydrake.solvers.MathematicalProgram, X: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; pydrake.solvers.Binding[LinearConstraint]</p></li>
</ol>
<p>This is an overloaded variant of add_dd_dual “diagonally dominant dual
cone constraint”</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X</span></code>:</dt><dd><p>The matrix X. We will use 0.5(X+Xᵀ) as the “symmetric version” of
X.</p>
</dd>
<dt>Precondition:</dt><dd><p>X(i, j) should be a linear expression of decision variables.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A linear constraint of size n² encoding vᵢᵀXvᵢ ≥ 0</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>AddPositiveDiagonallyDominantDualConeMatrixConstraint(self: pydrake.solvers.MathematicalProgram, X: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; pydrake.solvers.Binding[LinearConstraint]</p></li>
</ol>
<p>This is an overloaded variant of add_dd_dual “diagonally dominant dual
cone constraint”</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X</span></code>:</dt><dd><p>The matrix X. We will use 0.5(X+Xᵀ) as the “symmetric version” of
X.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A linear constraint of size n² encoding vᵢᵀXvᵢ ≥ 0</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.AddPositiveDiagonallyDominantMatrixConstraint(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">X:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>Adds the constraint that a symmetric matrix is diagonally dominant
with non-negative diagonal entries. A symmetric matrix X is diagonally
dominant with non-negative diagonal entries if X(i, i) &gt;= ∑ⱼ <a href="#id55"><span class="problematic" id="id56">|X(i, j)|</span></a>
∀ j ≠ i namely in each row, the diagonal entry is larger than the sum
of the absolute values of all other entries in the same row. A matrix
being diagonally dominant with non-negative diagonals is a sufficient
(but not necessary) condition of a matrix being positive semidefinite.
Internally we will create a matrix Y as slack variables, such that
Y(i, j) represents the absolute value <a href="#id57"><span class="problematic" id="id58">|X(i, j)|</span></a> ∀ j ≠ i. The diagonal
entries Y(i, i) = X(i, i) The users can refer to “DSOS and SDSOS
Optimization: More Tractable Alternatives to Sum of Squares and
Semidefinite Optimization” by Amir Ali Ahmadi and Anirudha Majumdar,
with arXiv link <a class="reference external" href="https://arxiv.org/abs/1706.02586">https://arxiv.org/abs/1706.02586</a></p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X</span></code>:</dt><dd><p>The matrix X. We will use 0.5(X+Xᵀ) as the “symmetric version” of
X.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Y The slack variable. Y(i, j) represents <a href="#id59"><span class="problematic" id="id60">|X(i, j)|</span></a> ∀ j ≠ i, with
the constraint Y(i, j) &gt;= X(i, j) and Y(i, j) &gt;= -X(i, j). Y is a
symmetric matrix. The diagonal entries Y(i, i) = X(i, i)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.AddPositiveSemidefiniteConstraint(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddPositiveSemidefiniteConstraint(self: pydrake.solvers.MathematicalProgram, arg0: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; pydrake.solvers.Binding[PositiveSemidefiniteConstraint]</p></li>
</ol>
<p>Adds a positive semidefinite constraint on a symmetric matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError in Debug mode if symmetric_matrix_var is not</strong> – </p></li>
<li><p><strong>symmetric.</strong> – </p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">symmetric_matrix_var</span></code>:</dt><dd><p>A symmetric MatrixDecisionVariable object.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>AddPositiveSemidefiniteConstraint(self: pydrake.solvers.MathematicalProgram, arg0: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; pydrake.solvers.Binding[PositiveSemidefiniteConstraint]</p></li>
</ol>
<p>Adds a positive semidefinite constraint on a symmetric matrix of
symbolic expressions <code class="docutils literal notranslate"><span class="pre">e</span></code>. We create a new symmetric matrix of
variables M being positive semidefinite, with the linear equality
constraint e == M.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">e</span></code>:</dt><dd><p>Imposes constraint “e is positive semidefinite”.</p>
</dd>
<dt>Precondition:</dt><dd><p>e is symmetric.</p>
</dd>
<dt>Precondition:</dt><dd><p>e(i, j) is linear for all i, j</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The newly added positive semidefinite constraint, with the bound
variable M that are also newly added.</p>
</dd>
</dl>
<p>For example, to add a constraint that</p>
<p>⌈x + 1 2x + 3 x+y⌉ <a href="#id61"><span class="problematic" id="id62">|2x+ 3 2 0|</span></a> is positive semidefinite ⌊x + y 0 x⌋
The user could call</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">cc</span><span class="p">}</span>
<span class="n">Matrix3</span><span class="o">&lt;</span><span class="n">symbolic</span><span class="o">::</span><span class="n">Expression</span><span class="o">&gt;</span><span class="w"> </span><span class="n">e</span>
<span class="n">e</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">,</span>
<span class="w">     </span><span class="mi">2</span><span class="o">*</span><span class="n">x</span><span class="o">+</span><span class="mi">3</span><span class="p">,</span><span class="w">   </span><span class="mi">2</span><span class="p">,</span><span class="w">   </span><span class="mi">0</span><span class="p">,</span>
<span class="w">     </span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">,</span><span class="w">     </span><span class="mi">0</span><span class="p">,</span><span class="w">   </span><span class="n">x</span><span class="p">;</span>
<span class="n">prog</span><span class="p">.</span><span class="n">AddPositiveSemidefiniteConstraint</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
</pre></div>
</div>
</details><div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function will add additional variables and linear equality
constraints. Consider calling
AddLinearMatrixInequalityConstraint(e), which doesn’t introduce
new variables or linear equality constraints.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.AddPrincipalSubmatrixIsPsdConstraint(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddPrincipalSubmatrixIsPsdConstraint(self: pydrake.solvers.MathematicalProgram, arg0: numpy.ndarray[object[m, n], flags.f_contiguous], arg1: set[int]) -&gt; pydrake.solvers.Binding[PositiveSemidefiniteConstraint]</p></li>
</ol>
<p>Adds a constraint that the principal submatrix of a symmetric matrix
composed of the indices in minor_indices is positive semidefinite.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>The passed <code class="docutils literal notranslate"><span class="pre">symmetric_matrix_var</span></code> is a symmetric matrix.</p>
</dd>
<dt>Precondition:</dt><dd><p>All values in <code class="docutils literal notranslate"><span class="pre">minor_indices</span></code> lie in the range [0,
symmetric_matrix_var.rows() - 1].</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">symmetric_matrix_var</span></code>:</dt><dd><p>A symmetric MatrixDecisionVariable object.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddPositiveSemidefiniteConstraint</p>
</div>
<ol class="arabic simple" start="2">
<li><p>AddPrincipalSubmatrixIsPsdConstraint(self: pydrake.solvers.MathematicalProgram, arg0: numpy.ndarray[object[m, n], flags.f_contiguous], arg1: set[int]) -&gt; pydrake.solvers.Binding[LinearMatrixInequalityConstraint]</p></li>
</ol>
<p>Adds a constraint the that the principal submatrix of a symmetric
matrix of expressions composed of the indices in minor_indices is
positive semidefinite.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>The passed <code class="docutils literal notranslate"><span class="pre">symmetric_matrix_var</span></code> is a symmetric matrix.</p>
</dd>
<dt>Precondition:</dt><dd><p>All values in <code class="docutils literal notranslate"><span class="pre">minor_indices</span></code> lie in the range [0,
symmetric_matrix_var.rows() - 1].</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">e</span></code>:</dt><dd><p>Imposes constraint “e is positive semidefinite”.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddLinearMatrixInequalityConstraint.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>the return type is Binding&lt;LinearMatrixInequalityConstraint&gt;,
different from the overloaded function above which returns
Binding&lt;PositiveSemidefiniteConstraint&gt;. We impose the constraint
as an LMI so as to add fewer additional variables and constraints.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.AddQuadraticAsRotatedLorentzConeConstraint(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">Q:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous],</span> <span class="pre">b:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">c:</span> <span class="pre">float,</span> <span class="pre">vars:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]],</span> <span class="pre">psd_tol:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0.0)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.Binding[RotatedLorentzConeConstraint]</span></span></dt>
<dd><p>Add the convex quadratic constraint 0.5xᵀQx + bᵀx + c &lt;= 0 as a
rotated Lorentz cone constraint [rᵀx+s, 1, Px+q] is in the rotated
Lorentz cone. When solving the optimization problem using conic
solvers (like Mosek, Gurobi, SCS, etc), it is numerically preferable
to impose the convex quadratic constraint as rotated Lorentz cone
constraint. See
<a class="reference external" href="https://docs.mosek.com/latest/capi/prob-def-quadratic.html#a-recommendation">https://docs.mosek.com/latest/capi/prob-def-quadratic.html#a-recommendation</a></p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>exception if this quadratic constraint is not convex</strong><strong> (</strong><strong>Q is not</strong> – </p></li>
<li><p><strong>positive semidefinite</strong><strong>)</strong> – </p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Q</span></code>:</dt><dd><p>The Hessian of the quadratic constraint. Should be positive
semidefinite.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>:</dt><dd><p>The linear coefficient of the quadratic constraint.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">c</span></code>:</dt><dd><p>The constant term of the quadratic constraint.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">vars</span></code>:</dt><dd><p>x in the documentation above.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">psd_tol</span></code>:</dt><dd><p>If the minimal eigenvalue of Q is smaller than -psd_tol, then
throw an exception. $*Default:* = 0.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.AddQuadraticConstraint(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddQuadraticConstraint(self: pydrake.solvers.MathematicalProgram, Q: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[m, 1]], lb: float, ub: float, vars: numpy.ndarray[object[m, 1]], hessian_type: Optional[pydrake.solvers.QuadraticConstraint.HessianType] = None) -&gt; pydrake.solvers.Binding[QuadraticConstraint]</p></li>
</ol>
<p>Adds quadratic constraint lb ≤ .5 xᵀQx + bᵀx ≤ ub Notice that if your
quadratic constraint is convex, and you intend to solve the problem
with a convex solver (like Mosek), then it is better to reformulate it
with a second order cone constraint. See
<a class="reference external" href="https://docs.mosek.com/10.1/capi/prob-def-quadratic.html#a-recommendation">https://docs.mosek.com/10.1/capi/prob-def-quadratic.html#a-recommendation</a>
for an explanation.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">vars</span></code>:</dt><dd><p>x in the documentation above.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">hessian_type</span></code>:</dt><dd><p>Whether the Hessian is positive semidefinite, negative
semidefinite or indefinite. Drake will check the type if
hessian_type=std::nullopt. Specifying the hessian type will speed
this method up.</p>
</dd>
<dt>Precondition:</dt><dd><p>hessian_type should be correct if it is not std::nullopt, as we
will blindly trust it in the downstream code.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>AddQuadraticConstraint(self: pydrake.solvers.MathematicalProgram, e: pydrake.symbolic.Expression, lb: float, ub: float, hessian_type: Optional[pydrake.solvers.QuadraticConstraint.HessianType] = None) -&gt; pydrake.solvers.Binding[QuadraticConstraint]</p></li>
</ol>
<p>Overloads AddQuadraticConstraint, impose lb &lt;= e &lt;= ub where <code class="docutils literal notranslate"><span class="pre">e</span></code> is
a quadratic expression. Notice that if your quadratic constraint is
convex, and you intend to solve the problem with a convex solver (like
Mosek), then it is better to reformulate it with a second order cone
constraint. See
<a class="reference external" href="https://docs.mosek.com/10.1/capi/prob-def-quadratic.html#a-recommendation">https://docs.mosek.com/10.1/capi/prob-def-quadratic.html#a-recommendation</a>
for an explanation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.AddQuadraticCost(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddQuadraticCost(self: pydrake.solvers.MathematicalProgram, e: pydrake.symbolic.Expression, is_convex: Optional[bool] = None) -&gt; pydrake.solvers.Binding[QuadraticCost]</p></li>
</ol>
<p>Add a quadratic cost term of the form 0.5*x’<a href="#id33"><span class="problematic" id="id34">*</span></a>Q*x + b’<a href="#id35"><span class="problematic" id="id36">*</span></a>x + c.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">e</span></code>:</dt><dd><p>A quadratic symbolic expression.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">is_convex</span></code>:</dt><dd><p>Whether the cost is already known to be convex. If
is_convex=nullopt (the default), then Drake will determine if
<code class="docutils literal notranslate"><span class="pre">e</span></code> is a convex quadratic cost or not. To improve the
computation speed, the user can set is_convex if the user knows
whether the cost is convex or not.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the expression is not quadratic.</strong> – </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The newly added cost together with the bound variables.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>AddQuadraticCost(self: pydrake.solvers.MathematicalProgram, Q: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[m, 1]], vars: numpy.ndarray[object[m, 1]], is_convex: Optional[bool] = None) -&gt; pydrake.solvers.Binding[QuadraticCost]</p></li>
</ol>
<p>Adds a cost term of the form 0.5*x’<a href="#id37"><span class="problematic" id="id38">*</span></a>Q*x + b’x Applied to subset of the
variables.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">is_convex</span></code>:</dt><dd><p>Whether the cost is already known to be convex. If
is_convex=nullopt (the default), then Drake will determine if this
is a convex quadratic cost or not. To improve the computation
speed, the user can set is_convex if the user knows whether the
cost is convex or not.</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>AddQuadraticCost(self: pydrake.solvers.MathematicalProgram, Q: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[m, 1]], c: float, vars: numpy.ndarray[object[m, 1]], is_convex: Optional[bool] = None) -&gt; pydrake.solvers.Binding[QuadraticCost]</p></li>
</ol>
<p>Adds a cost term of the form 0.5*x’<a href="#id39"><span class="problematic" id="id40">*</span></a>Q*x + b’x + c Applied to subset of
the variables.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">is_convex</span></code>:</dt><dd><p>Whether the cost is already known to be convex. If
is_convex=nullopt (the default), then Drake will determine if this
is a convex quadratic cost or not. To improve the computation
speed, the user can set is_convex if the user knows whether the
cost is convex or not.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.AddQuadraticErrorCost(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddQuadraticErrorCost(self: pydrake.solvers.MathematicalProgram, w: float, x_desired: numpy.ndarray[numpy.float64[m, 1]], vars: numpy.ndarray[object[m, 1]]) -&gt; pydrake.solvers.Binding[QuadraticCost]</p></li>
</ol>
<p>Adds a cost term of the form w*|x-x_desired|^2.</p>
<ol class="arabic simple" start="2">
<li><p>AddQuadraticErrorCost(self: pydrake.solvers.MathematicalProgram, Q: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], x_desired: numpy.ndarray[numpy.float64[m, 1]], vars: numpy.ndarray[object[m, 1]]) -&gt; pydrake.solvers.Binding[QuadraticCost]</p></li>
</ol>
<p>Adds a cost term of the form (x-x_desired)’<a href="#id41"><span class="problematic" id="id42">*</span></a>Q*(x-x_desired).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.AddRotatedLorentzConeConstraint(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddRotatedLorentzConeConstraint(self: pydrake.solvers.MathematicalProgram, linear_expression1: pydrake.symbolic.Expression, linear_expression2: pydrake.symbolic.Expression, quadratic_expression: pydrake.symbolic.Expression, tol: float = 0) -&gt; pydrake.solvers.Binding[RotatedLorentzConeConstraint]</p></li>
</ol>
<p>Adds rotated Lorentz cone constraint on the linear expression v1, v2
and quadratic expression u, such that v1 * v2 &gt;= u, v1 &gt;= 0, v2 &gt;= 0</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">linear_expression1</span></code>:</dt><dd><p>The linear expression v1.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">linear_expression2</span></code>:</dt><dd><p>The linear expression v2.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">quadratic_expression</span></code>:</dt><dd><p>The quadratic expression u.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">tol</span></code>:</dt><dd><p>The tolerance to determine if the matrix in v2 is positive
semidefinite or not.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>DecomposePositiveQuadraticForm for more explanation. $*Default:*
is 0.</p>
</div>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">binding</span></code>:</dt><dd><p>The newly added rotated Lorentz cone constraint, together with the
bound variables.</p>
</dd>
</dl>
<p>Precondition:
1. <code class="docutils literal notranslate"><span class="pre">linear_expression1</span></code> is a linear (affine) expression, in the form of</p>
<blockquote>
<div><p>v1 = c1’<a href="#id43"><span class="problematic" id="id44">*</span></a>x + d1.</p>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p><code class="docutils literal notranslate"><span class="pre">linear_expression2</span></code> is a linear (affine) expression, in the form of
v2 = c2’<a href="#id45"><span class="problematic" id="id46">*</span></a>x + d2.</p></li>
</ol>
<ol class="arabic simple" start="2">
<li><p><code class="docutils literal notranslate"><span class="pre">quadratic_expression</span></code> is a quadratic expression, in the form of</p></li>
</ol>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="err">&#39;</span><span class="o">*</span><span class="n">Q</span><span class="o">*</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="err">&#39;</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">a</span>
</pre></div>
</div>
</details><p>Also the quadratic expression has to be convex, namely Q is a positive
semidefinite matrix, and the quadratic expression needs to be
non-negative for any x.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the preconditions are not satisfied.</strong> – </p>
</dd>
</dl>
<p>For example, to add the rotated Lorentz cone constraint</p>
<p>(x+1)(x+y) &gt;= x²+z²+2z+5 x+1 &gt;= 0 x+y &gt;= 0 The user could call</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">cc</span><span class="p">}</span>
<span class="n">prog</span><span class="p">.</span><span class="n">AddRotatedLorentzConeConstraint</span><span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pow</span><span class="p">(</span><span class="n">z</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span>
<span class="mi">2</span><span class="o">*</span><span class="n">z</span><span class="o">+</span><span class="mi">5</span><span class="p">);</span>
</pre></div>
</div>
</details><ol class="arabic simple" start="2">
<li><p>AddRotatedLorentzConeConstraint(self: pydrake.solvers.MathematicalProgram, v: numpy.ndarray[object[m, 1]]) -&gt; pydrake.solvers.Binding[RotatedLorentzConeConstraint]</p></li>
</ol>
<p>Adds a constraint that a symbolic expression <code class="docutils literal notranslate"><span class="pre">v</span></code> is in the rotated
Lorentz cone, i.e.,</p>
<div class="math notranslate nohighlight">
\[v_0v_1 \ge v_2^2 + ... + v_{n-1}^2\\]</div>
<p>v_0 ge 0, v_1 ge 0</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v</span></code>:</dt><dd><p>A linear expression of variables, <span class="math notranslate nohighlight">\(v = A x + b\)</span>, where
<span class="math notranslate nohighlight">\(A, b\)</span> are given matrices of the correct size, <span class="math notranslate nohighlight">\(x\)</span> is
the vector of decision variables.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">binding</span></code>:</dt><dd><p>The newly added rotated Lorentz cone constraint, together with the
bound variables.</p>
</dd>
</dl>
<p>For example, to add the rotated Lorentz cone constraint</p>
<p>(x+1)(x+y) &gt;= x²+z²+2z+5 = x² + (z+1)² + 2² x+1 &gt;= 0 x+y &gt;= 0 The user
could call</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">cc</span><span class="p">}</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&lt;</span><span class="n">symbolic</span><span class="o">::</span><span class="n">Expression</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="n">v</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">x</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="o">+</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">z</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="n">prog</span><span class="p">.</span><span class="n">AddRotatedLorentzConeConstraint</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
</pre></div>
</div>
</details><ol class="arabic simple" start="3">
<li><p>AddRotatedLorentzConeConstraint(self: pydrake.solvers.MathematicalProgram, A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[m, 1]], vars: numpy.ndarray[object[m, 1]]) -&gt; pydrake.solvers.Binding[RotatedLorentzConeConstraint]</p></li>
</ol>
<p>Adds a rotated Lorentz cone constraint referencing potentially a
subset of decision variables, The linear expression <span class="math notranslate nohighlight">\(z=Ax+b\)</span> is
in rotated Lorentz cone. A vector <span class="math notranslate nohighlight">\(z \in\mathbb{R}^n\)</span> is in the
rotated Lorentz cone, if</p>
<div class="math notranslate nohighlight">
\[z_0z_1 \ge z_2^2 + ... + z_{n-1}^2\]</div>
<p>where <span class="math notranslate nohighlight">\(A\in\mathbb{R}^{n\times m}, b\in\mathbb{R}^n\)</span> are given
matrices.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">A</span></code>:</dt><dd><p>A matrix whose number of columns equals to the size of the
decision variables.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>:</dt><dd><p>A vector whose number of rows equals to the size of the decision
variables.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">vars</span></code>:</dt><dd><p>The decision variables on which the constraint is imposed.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.AddScaledDiagonallyDominantDualConeMatrixConstraint(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddScaledDiagonallyDominantDualConeMatrixConstraint(self: pydrake.solvers.MathematicalProgram, X: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; list[pydrake.solvers.Binding[RotatedLorentzConeConstraint]]</p></li>
</ol>
<p>This is an overloaded variant of add_sdd_dual “scaled diagonally
dominant dual cone constraint”</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X</span></code>:</dt><dd><p>The matrix X. We will use 0.5(X+Xᵀ) as the “symmetric version” of
X.</p>
</dd>
<dt>Precondition:</dt><dd><p>X(i, j) should be a linear expression of decision variables.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A vector of RotatedLorentzConeConstraint constraints of length 1/2
* n * (n-1) encoding VᵢⱼᵀXVᵢⱼ is psd</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>AddScaledDiagonallyDominantDualConeMatrixConstraint(self: pydrake.solvers.MathematicalProgram, X: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; list[pydrake.solvers.Binding[RotatedLorentzConeConstraint]]</p></li>
</ol>
<p>This is an overloaded variant of add_sdd_dual “scaled diagonally
dominant dual cone constraint”</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X</span></code>:</dt><dd><p>The matrix X. We will use 0.5(X+Xᵀ) as the “symmetric version” of
X.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A vector of RotatedLorentzConeConstraint constraints of length 1/2
* n * (n-1) encoding VᵢⱼᵀXVᵢⱼ is psd</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.AddScaledDiagonallyDominantMatrixConstraint(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddScaledDiagonallyDominantMatrixConstraint(self: pydrake.solvers.MathematicalProgram, X: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; list[list[numpy.ndarray[object[2, 2]]]]</p></li>
</ol>
<p>This is an overloaded variant of addsdd “scaled diagonally dominant
matrix constraint”</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X</span></code>:</dt><dd><p>The matrix X to be constrained scaled diagonally dominant. X.</p>
</dd>
<dt>Precondition:</dt><dd><p>X(i, j) should be a linear expression of decision variables.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>M A vector of vectors of 2 x 2 symmetric matrices M. For i &lt; j,
M[i][j] is</p>
</dd>
</dl>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">Mⁱʲ</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">),</span><span class="w"> </span><span class="n">Mⁱʲ</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">)]</span>
<span class="p">[</span><span class="n">Mⁱʲ</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">),</span><span class="w"> </span><span class="n">Mⁱʲ</span><span class="p">(</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="p">)].</span>
</pre></div>
</div>
</details><p>Note that M[i][j](0, 1) = Mⁱʲ(i, j) = (X(i, j) + X(j, i)) / 2 for i &gt;=
j, M[i][j] is the zero matrix.</p>
<ol class="arabic simple" start="2">
<li><p>AddScaledDiagonallyDominantMatrixConstraint(self: pydrake.solvers.MathematicalProgram, X: numpy.ndarray[object[m, n], flags.f_contiguous]) -&gt; list[list[numpy.ndarray[object[2, 2]]]]</p></li>
</ol>
<p>This is an overloaded variant of addsdd “scaled diagonally dominant
matrix constraint”</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X</span></code>:</dt><dd><p>The symmetric matrix X to be constrained scaled diagonally
dominant.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>M For i &lt; j M[i][j] contains the slack variables, mentioned in
addsdd “scaled diagonally dominant matrix constraint”. For i &gt;= j,
M[i][j] contains default-constructed variables (with get_id() ==
0).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.AddSosConstraint(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddSosConstraint(self: pydrake.solvers.MathematicalProgram, p: pydrake.symbolic.Polynomial, monomial_basis: numpy.ndarray[object[m, 1]], type: pydrake.solvers.MathematicalProgram.NonnegativePolynomial = &lt;NonnegativePolynomial.kSos: 1&gt;, gram_name: str = ‘S’) -&gt; numpy.ndarray[object[m, n]]</p></li>
</ol>
<p>Adds constraints that a given polynomial <code class="docutils literal notranslate"><span class="pre">p</span></code> is a sums-of-squares
(SOS), that is, <code class="docutils literal notranslate"><span class="pre">p</span></code> can be decomposed into <code class="docutils literal notranslate"><span class="pre">mᵀQm</span></code>, where m is the
<code class="docutils literal notranslate"><span class="pre">monomial_basis</span></code>. It returns the coefficients matrix Q, which is
positive semidefinite.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">type</span></code>:</dt><dd><p>The type of the polynomial. $*Default:* is kSos, but the user can
also use kSdsos and kDsos. Refer to NonnegativePolynomial for
details on different types of sos polynomials.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">gram_name</span></code>:</dt><dd><p>The name of the gram matrix for print out.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It calls <code class="docutils literal notranslate"><span class="pre">Reparse</span></code> to enforce <code class="docutils literal notranslate"><span class="pre">p</span></code> to have this
MathematicalProgram’s indeterminates if necessary.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>AddSosConstraint(self: pydrake.solvers.MathematicalProgram, p: pydrake.symbolic.Polynomial, type: pydrake.solvers.MathematicalProgram.NonnegativePolynomial = &lt;NonnegativePolynomial.kSos: 1&gt;, gram_name: str = ‘S’) -&gt; tuple[numpy.ndarray[object[m, n]], numpy.ndarray[object[m, 1]]]</p></li>
</ol>
<p>Adds constraints that a given polynomial <code class="docutils literal notranslate"><span class="pre">p</span></code> is a sums-of-squares
(SOS), that is, <code class="docutils literal notranslate"><span class="pre">p</span></code> can be decomposed into <code class="docutils literal notranslate"><span class="pre">mᵀQm</span></code>, where m is a
monomial basis selected from the sparsity of <code class="docutils literal notranslate"><span class="pre">p</span></code>. It returns a pair
of constraint bindings expressing: - The coefficients matrix Q, which
is positive semidefinite. - The monomial basis m.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">type</span></code>:</dt><dd><p>The type of the polynomial. $*Default:* is kSos, but the user can
also use kSdsos and kDsos. Refer to NonnegativePolynomial for the
details on different type of sos polynomials.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">gram_name</span></code>:</dt><dd><p>The name of the gram matrix for print out.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It calls <code class="docutils literal notranslate"><span class="pre">Reparse</span></code> to enforce <code class="docutils literal notranslate"><span class="pre">p</span></code> to have this
MathematicalProgram’s indeterminates if necessary.</p>
</div>
<ol class="arabic simple" start="3">
<li><p>AddSosConstraint(self: pydrake.solvers.MathematicalProgram, e: pydrake.symbolic.Expression, monomial_basis: numpy.ndarray[object[m, 1]], type: pydrake.solvers.MathematicalProgram.NonnegativePolynomial = &lt;NonnegativePolynomial.kSos: 1&gt;, gram_name: str = ‘S’) -&gt; numpy.ndarray[object[m, n]]</p></li>
</ol>
<p>Adds constraints that a given symbolic expression <code class="docutils literal notranslate"><span class="pre">e</span></code> is a
sums-of-squares (SOS), that is, <code class="docutils literal notranslate"><span class="pre">p</span></code> can be decomposed into <code class="docutils literal notranslate"><span class="pre">mᵀQm</span></code>,
where m is the <code class="docutils literal notranslate"><span class="pre">monomial_basis</span></code>. Note that it decomposes <code class="docutils literal notranslate"><span class="pre">e</span></code> into
a polynomial with respect to <code class="docutils literal notranslate"><span class="pre">indeterminates()</span></code> in this mathematical
program. It returns the coefficients matrix Q, which is positive
semidefinite.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">type</span></code>:</dt><dd><p>Refer to NonnegativePolynomial class documentation.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">gram_name</span></code>:</dt><dd><p>The name of the gram matrix for print out.</p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>AddSosConstraint(self: pydrake.solvers.MathematicalProgram, e: pydrake.symbolic.Expression, type: pydrake.solvers.MathematicalProgram.NonnegativePolynomial = &lt;NonnegativePolynomial.kSos: 1&gt;, gram_name: str = ‘S’) -&gt; tuple[numpy.ndarray[object[m, n]], numpy.ndarray[object[m, 1]]]</p></li>
</ol>
<p>Adds constraints that a given symbolic expression <code class="docutils literal notranslate"><span class="pre">e</span></code> is a
sums-of-squares (SOS), that is, <code class="docutils literal notranslate"><span class="pre">e</span></code> can be decomposed into <code class="docutils literal notranslate"><span class="pre">mᵀQm</span></code>.
Note that it decomposes <code class="docutils literal notranslate"><span class="pre">e</span></code> into a polynomial with respect to
<code class="docutils literal notranslate"><span class="pre">indeterminates()</span></code> in this mathematical program. It returns a pair
expressing: - The coefficients matrix Q, which is positive
semidefinite. - The monomial basis m.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">type</span></code>:</dt><dd><p>Refer to NonnegativePolynomial class documentation.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">gram_name</span></code>:</dt><dd><p>The name of the gram matrix for print out.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.AddVisualizationCallback(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">arg0:</span> <span class="pre">Callable[[numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]],</span> <span class="pre">None],</span> <span class="pre">arg1:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.Binding[VisualizationCallback]</span></span></dt>
<dd><p>Adds a callback method to visualize intermediate results of the
optimization.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Just like other costs/constraints, not all solvers support
callbacks. Adding a callback here will force
MathematicalProgram::Solve to select a solver that support
callbacks. For instance, adding a visualization callback to a
quadratic programming problem may result in using a nonlinear
programming solver as the default solver.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">callback</span></code>:</dt><dd><p>a std::function that accepts an Eigen::Vector of doubles
representing the bound decision variables.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">vars</span></code>:</dt><dd><p>the decision variables that should be passed to the callback.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.bounding_box_constraints(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram)</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.solvers.Binding[BoundingBoxConstraint]]</span></span></dt>
<dd><p>Getter for all bounding box constraints</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.CheckSatisfied(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CheckSatisfied(self: pydrake.solvers.MathematicalProgram, binding: pydrake.solvers.Binding[Constraint], prog_var_vals: numpy.ndarray[numpy.float64[m, 1]], tol: float = 1e-06) -&gt; bool</p></li>
</ol>
<p>Evaluates CheckSatisfied for the constraint in <code class="docutils literal notranslate"><span class="pre">binding</span></code> using the
value of ALL of the decision variables in this program.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the size</strong><strong> of </strong><strong>prog_var_vals is invalid.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>CheckSatisfied(self: pydrake.solvers.MathematicalProgram, bindings: list[pydrake.solvers.Binding[Constraint]], prog_var_vals: numpy.ndarray[numpy.float64[m, 1]], tol: float = 1e-06) -&gt; bool</p></li>
</ol>
<p>Evaluates CheckSatisfied for the all of the constraints in <code class="docutils literal notranslate"><span class="pre">binding</span></code>
using the value of ALL of the decision variables in this program.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>true iff all of the constraints are satisfied.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>RuntimeError if the size</strong><strong> of </strong><strong>prog_var_vals is invalid.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.CheckSatisfiedAtInitialGuess(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CheckSatisfiedAtInitialGuess(self: pydrake.solvers.MathematicalProgram, binding: pydrake.solvers.Binding[Constraint], tol: float = 1e-06) -&gt; bool</p></li>
</ol>
<p>Evaluates CheckSatisfied for the constraint in <code class="docutils literal notranslate"><span class="pre">binding</span></code> at the
initial guess.</p>
<ol class="arabic simple" start="2">
<li><p>CheckSatisfiedAtInitialGuess(self: pydrake.solvers.MathematicalProgram, bindings: list[pydrake.solvers.Binding[Constraint]], tol: float = 1e-06) -&gt; bool</p></li>
</ol>
<p>Evaluates CheckSatisfied for the all of the constraints in
<code class="docutils literal notranslate"><span class="pre">bindings</span></code> at the initial guess.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>true iff all of the constraints are satisfied.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.ClearVariableScaling(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Clears the scaling factors for decision variables.</p>
<p>See variable_scaling “Variable scaling” for more information.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.Clone(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.MathematicalProgram</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.decision_variable(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">i:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Variable</span></span></dt>
<dd><p>Getter for the decision variable with index <code class="docutils literal notranslate"><span class="pre">i</span></code> in the program.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.decision_variable_index(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram)</span> <span class="pre">-&gt;</span> <span class="pre">dict[int,</span> <span class="pre">int]</span></span></dt>
<dd><p>Returns the mapping from a decision variable ID to its index in the
vector containing all the decision variables in the mathematical
program.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.decision_variables(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Getter for all decision variables in the program.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.EvalBinding(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>EvalBinding(self: pydrake.solvers.MathematicalProgram, binding: pydrake.solvers.Binding[EvaluatorBase], prog_var_vals: numpy.ndarray[numpy.float64[m, 1]]) -&gt; numpy.ndarray[numpy.float64[m, 1]]</p></li>
</ol>
<p>Evaluates the value of some binding, for some input value for all
decision variables.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">binding</span></code>:</dt><dd><p>A Binding whose variables are decision variables in this program.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">prog_var_vals</span></code>:</dt><dd><p>The value of all the decision variables in this program.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the size</strong><strong> of </strong><strong>prog_var_vals is invalid.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>EvalBinding(self: pydrake.solvers.MathematicalProgram, binding: pydrake.solvers.Binding[EvaluatorBase], prog_var_vals: numpy.ndarray[object[m, 1]]) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Evaluates the value of some binding, for some input value for all
decision variables.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">binding</span></code>:</dt><dd><p>A Binding whose variables are decision variables in this program.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">prog_var_vals</span></code>:</dt><dd><p>The value of all the decision variables in this program.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the size</strong><strong> of </strong><strong>prog_var_vals is invalid.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.EvalBindingAtInitialGuess(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">binding:</span> <span class="pre">pydrake.solvers.Binding[EvaluatorBase])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Evaluates the evaluator in <code class="docutils literal notranslate"><span class="pre">binding</span></code> at the initial guess.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The value of <code class="docutils literal notranslate"><span class="pre">binding</span></code> at the initial guess.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.EvalBindings(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>EvalBindings(self: pydrake.solvers.MathematicalProgram, bindings: list[pydrake.solvers.Binding[EvaluatorBase]], prog_var_vals: numpy.ndarray[numpy.float64[m, 1]]) -&gt; numpy.ndarray[numpy.float64[m, 1]]</p></li>
</ol>
<p>Evaluates a set of bindings (plural version of <code class="docutils literal notranslate"><span class="pre">EvalBinding</span></code>).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">bindings</span></code>:</dt><dd><p>List of bindings.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">prog_var_vals</span></code>:</dt><dd><p>The value of all the decision variables in this program.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>All binding values, concatenated into a single vector.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>RuntimeError if the size</strong><strong> of </strong><strong>prog_var_vals is invalid.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>EvalBindings(self: pydrake.solvers.MathematicalProgram, bindings: list[pydrake.solvers.Binding[EvaluatorBase]], prog_var_vals: numpy.ndarray[object[m, 1]]) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Evaluates a set of bindings (plural version of <code class="docutils literal notranslate"><span class="pre">EvalBinding</span></code>).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">bindings</span></code>:</dt><dd><p>List of bindings.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">prog_var_vals</span></code>:</dt><dd><p>The value of all the decision variables in this program.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>All binding values, concatenated into a single vector.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>RuntimeError if the size</strong><strong> of </strong><strong>prog_var_vals is invalid.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.EvalBindingVectorized(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">binding:</span> <span class="pre">pydrake.solvers.Binding[EvaluatorBase],</span> <span class="pre">prog_var_vals:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>A “vectorized” version of EvalBinding.  It evaluates the binding
for every column of <code class="docutils literal notranslate"><span class="pre">prog_var_vals</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.exponential_cone_constraints(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram)</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.solvers.Binding[ExponentialConeConstraint]]</span></span></dt>
<dd><p>Getter for exponential cone constraints.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.FindDecisionVariableIndex(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">var:</span> <span class="pre">pydrake.symbolic.Variable)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the index of the decision variable. Internally the solvers
thinks all variables are stored in an array, and it accesses each
individual variable using its index. This index is used when adding
constraints and costs for each solver.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>{<code class="docutils literal notranslate"><span class="pre">var</span></code> is a decision variable in the mathematical program,
otherwise this function throws a runtime error.}</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.FindDecisionVariableIndices(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">vars:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">list[int]</span></span></dt>
<dd><p>Returns the indices of the decision variables. Internally the solvers
thinks all variables are stored in an array, and it accesses each
individual variable using its index. This index is used when adding
constraints and costs for each solver.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>{<code class="docutils literal notranslate"><span class="pre">vars</span></code> are decision variables in the mathematical program,
otherwise this function throws a runtime error.}</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.FindIndeterminateIndex(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">var:</span> <span class="pre">pydrake.symbolic.Variable)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the index of the indeterminate. Internally a solver thinks all
indeterminates are stored in an array, and it accesses each individual
indeterminate using its index. This index is used when adding
constraints and costs for each solver.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">var</span></code> is a indeterminate in the mathematical program, otherwise
this function throws a runtime error.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.generic_constraints(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram)</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.solvers.Binding[Constraint]]</span></span></dt>
<dd><p>Getter for all generic constraints</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.generic_costs(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram)</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.solvers.Binding[Cost]]</span></span></dt>
<dd><p>Getter for all generic costs.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.GetAllConstraints(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram)</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.solvers.Binding[Constraint]]</span></span></dt>
<dd><p>Getter for returning all constraints.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Vector of all constraint bindings.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The group ordering may change as more constraint types are added.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.GetAllCosts(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram)</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.solvers.Binding[Cost]]</span></span></dt>
<dd><p>Getter returning all costs.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Vector of all cost bindings.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The group ordering may change as more cost types are added.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.GetBindingVariableValues(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">binding:</span> <span class="pre">pydrake.solvers.Binding[EvaluatorBase],</span> <span class="pre">prog_var_vals:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Given the value of all decision variables, namely
this.decision_variable(i) takes the value prog_var_vals(i), returns
the vector that contains the value of the variables in
binding.variables().</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">binding</span></code>:</dt><dd><p>binding.variables() must be decision variables in this
MathematicalProgram.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">prog_var_vals</span></code>:</dt><dd><p>The value of ALL the decision variables in this program.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>binding_variable_vals binding_variable_vals(i) is the value of
binding.variables()(i) in prog_var_vals.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.GetInitialGuess(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetInitialGuess(self: pydrake.solvers.MathematicalProgram, arg0: pydrake.symbolic.Variable) -&gt; float</p></li>
</ol>
<p>Gets the initial guess for a single variable.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">decision_variable</span></code> has been registered in the optimization
program.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the pre condition is not satisfied.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetInitialGuess(self: pydrake.solvers.MathematicalProgram, arg0: numpy.ndarray[object[m, 1]]) -&gt; numpy.ndarray[numpy.float64[m, 1]]</p></li>
</ol>
<p>Gets the initial guess for some variables.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Each variable in <code class="docutils literal notranslate"><span class="pre">decision_variable_mat</span></code> has been registered in
the optimization program.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the pre condition is not satisfied.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>GetInitialGuess(self: pydrake.solvers.MathematicalProgram, arg0: numpy.ndarray[object[m, n]]) -&gt; numpy.ndarray[numpy.float64[m, n]]</p></li>
</ol>
<p>Gets the initial guess for some variables.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>Each variable in <code class="docutils literal notranslate"><span class="pre">decision_variable_mat</span></code> has been registered in
the optimization program.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the pre condition is not satisfied.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.GetLinearConstraints(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram)</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.solvers.Binding[LinearConstraint]]</span></span></dt>
<dd><p>Getter returning all linear constraints (both linear equality and
inequality constraints). Note that this does <em>not</em> include bounding
box constraints, which are technically also linear.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Vector of all linear constraint bindings.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.GetSolverOptions(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetSolverOptions(self: pydrake.solvers.MathematicalProgram, arg0: pydrake.solvers.SolverId) -&gt; dict</p></li>
<li><p>GetSolverOptions(self: pydrake.solvers.MathematicalProgram, arg0: pydrake.solvers.SolverType) -&gt; dict</p></li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.GetVariableScaling(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram)</span> <span class="pre">-&gt;</span> <span class="pre">dict[int,</span> <span class="pre">float]</span></span></dt>
<dd><p>Returns the mapping from a decision variable index to its scaling
factor.</p>
<p>See variable_scaling “Variable scaling” for more information.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.indeterminate(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">i:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Variable</span></span></dt>
<dd><p>Getter for the indeterminate with index <code class="docutils literal notranslate"><span class="pre">i</span></code> in the program.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.indeterminates(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Getter for all indeterminates in the program.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.indeterminates_index(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram)</span> <span class="pre">-&gt;</span> <span class="pre">dict[int,</span> <span class="pre">int]</span></span></dt>
<dd><p>Returns the mapping from an indeterminate ID to its index in the
vector containing all the indeterminates in the mathematical program.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.initial_guess(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Getter for the initial guess</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.IsThreadSafe(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns whether it is safe to solve this mathematical program
concurrently. A mathematical program is safe to solve concurrently if
all of its cost, constraints, and visualization callbacks are marked
as thread safe.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.l2norm_costs(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram)</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.solvers.Binding[L2NormCost]]</span></span></dt>
<dd><p>Getter for l2norm costs.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.linear_complementarity_constraints(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram)</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.solvers.Binding[LinearComplementarityConstraint]]</span></span></dt>
<dd><p>Getter for all linear complementarity constraints.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.linear_constraints(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram)</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.solvers.Binding[LinearConstraint]]</span></span></dt>
<dd><p>Getter for linear <em>inequality</em> constraints. Note that this does not
include linear_equality_constraints() nor bounding_box_constraints().
See also GetAllLinearConstraints().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.linear_costs(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram)</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.solvers.Binding[LinearCost]]</span></span></dt>
<dd><p>Getter for linear costs.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.linear_equality_constraints(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram)</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.solvers.Binding[LinearEqualityConstraint]]</span></span></dt>
<dd><p>Getter for linear equality constraints. Note that this only includes
constraints that were added explicitly as LinearEqualityConstraint or
which were added symbolically (and their equality constraint nature
was uncovered). There may be bounding_box_constraints() and
linear_constraints() whose lower bounds also equal their upper bounds.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.linear_matrix_inequality_constraints(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram)</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.solvers.Binding[LinearMatrixInequalityConstraint]]</span></span></dt>
<dd><p>Getter for linear matrix inequality constraints.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.lorentz_cone_constraints(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram)</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.solvers.Binding[LorentzConeConstraint]]</span></span></dt>
<dd><p>Getter for Lorentz cone constraints.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.MakePolynomial(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">e:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Polynomial</span></span></dt>
<dd><p>Creates a symbolic polynomial from the given expression <code class="docutils literal notranslate"><span class="pre">e</span></code>. It uses
this MathematicalProgram’s <code class="docutils literal notranslate"><span class="pre">indeterminates()</span></code> in constructing the
polynomial.</p>
<p>This method helps a user create a polynomial with the right set of
indeterminates which are declared in this MathematicalProgram. We
recommend users to use this method over an explicit call to Polynomial
constructors to avoid a possible mismatch between this
MathematicalProgram’s indeterminates and the user-specified
indeterminates (or unspecified, which then includes all symbolic
variables in the expression <code class="docutils literal notranslate"><span class="pre">e</span></code>). Consider the following example.</p>
<p>e = ax + bx + c</p>
<p>MP.indeterminates() = {x} MP.decision_variables() = {a, b}</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">MP.MakePolynomial(e)</span></code> create a polynomial, <code class="docutils literal notranslate"><span class="pre">(a</span> <span class="pre">+</span> <span class="pre">b)x</span> <span class="pre">+</span> <span class="pre">c</span></code>.  Here only
<code class="docutils literal notranslate"><span class="pre">x</span></code> is an indeterminate of this polynomial.</p></li>
<li><p>In contrast, <code class="docutils literal notranslate"><span class="pre">symbolic::Polynomial(e)</span></code> returns <code class="docutils literal notranslate"><span class="pre">ax</span> <span class="pre">+</span> <span class="pre">bx</span> <span class="pre">+</span> <span class="pre">c</span></code> where all
variables <code class="docutils literal notranslate"><span class="pre">{a,</span> <span class="pre">b,</span> <span class="pre">x}</span></code> are indeterminates. Note that this is problematic
as its indeterminates, <code class="docutils literal notranslate"><span class="pre">{a,</span> <span class="pre">b,</span> <span class="pre">x}</span></code> and the MathematicalProgram’s decision
variables, <code class="docutils literal notranslate"><span class="pre">{a,</span> <span class="pre">b}</span></code> overlap.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function does not require that the decision variables in
<code class="docutils literal notranslate"><span class="pre">e</span></code> is a subset of the decision variables in
MathematicalProgram.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.NewBinaryVariables(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>NewBinaryVariables(self: pydrake.solvers.MathematicalProgram, rows: int, name: str = ‘b’) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Adds binary variables to this MathematicalProgram. The new variables
are viewed as a column vector, with size <code class="docutils literal notranslate"><span class="pre">rows</span></code> x 1.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>NewBinaryVariables(int rows, int cols, const
std::vector&lt;std::string&gt;&amp; names);</p>
</div>
<ol class="arabic simple" start="2">
<li><p>NewBinaryVariables(self: pydrake.solvers.MathematicalProgram, rows: int, cols: int, name: str = ‘b’) -&gt; numpy.ndarray[object[m, n]]</p></li>
</ol>
<p>Adds binary variables, appending them to an internal vector of any
existing vars. The initial guess values for the new variables are set
to NaN, to indicate that an initial guess has not been assigned.
Callers are expected to add costs and/or constraints to have any
effect during optimization. Callers can also set the initial guess of
the decision variables through SetInitialGuess() or
SetInitialGuessForAllVariables().</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">Rows</span></code>:</dt><dd><p>The number of rows in the new variables.</p>
</dd>
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">Cols</span></code>:</dt><dd><p>The number of columns in the new variables.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rows</span></code>:</dt><dd><p>The number of rows in the new variables.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">cols</span></code>:</dt><dd><p>The number of columns in the new variables.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>The commonly shared name of the new variables.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The MatrixDecisionVariable of size rows x cols, containing the new
vars (not all the vars stored).</p>
</dd>
</dl>
<p>Example:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MathematicalProgram</span><span class="w"> </span><span class="n">prog</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prog</span><span class="p">.</span><span class="n">NewBinaryVariables</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;b&quot;</span><span class="p">);</span>
</pre></div>
</div>
</details><p>This adds a 2 x 3 matrix decision variables into the program.</p>
<p>The name of the variable is only used for the user in order to ease
readability.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.NewContinuousVariables(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>NewContinuousVariables(self: pydrake.solvers.MathematicalProgram, rows: int, name: str = ‘x’) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Adds continuous variables, appending them to an internal vector of any
existing vars. The initial guess values for the new variables are set
to NaN, to indicate that an initial guess has not been assigned.
Callers are expected to add costs and/or constraints to have any
effect during optimization. Callers can also set the initial guess of
the decision variables through SetInitialGuess() or
SetInitialGuessForAllVariables().</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rows</span></code>:</dt><dd><p>The number of rows in the new variables.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>The name of the newly added variables</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The VectorDecisionVariable of size rows x 1, containing the new
vars (not all the vars stored).</p>
</dd>
</dl>
<p>Example:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MathematicalProgram</span><span class="w"> </span><span class="n">prog</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prog</span><span class="p">.</span><span class="n">NewContinuousVariables</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;x&quot;</span><span class="p">);</span>
</pre></div>
</div>
</details><p>This adds a 2 x 1 vector containing decision variables into the
program. The names of the variables are “x(0)” and “x(1)”.</p>
<p>The name of the variable is only used for the user in order to ease
readability.</p>
<ol class="arabic simple" start="2">
<li><p>NewContinuousVariables(self: pydrake.solvers.MathematicalProgram, rows: int, cols: int, name: str = ‘x’) -&gt; numpy.ndarray[object[m, n]]</p></li>
</ol>
<p>Adds continuous variables, appending them to an internal vector of any
existing vars. The initial guess values for the new variables are set
to NaN, to indicate that an initial guess has not been assigned.
Callers are expected to add costs and/or constraints to have any
effect during optimization. Callers can also set the initial guess of
the decision variables through SetInitialGuess() or
SetInitialGuessForAllVariables().</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">Rows</span></code>:</dt><dd><p>The number of rows of the new variables, in the compile time.</p>
</dd>
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">Cols</span></code>:</dt><dd><p>The number of columns of the new variables, in the compile time.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rows</span></code>:</dt><dd><p>The number of rows in the new variables. When Rows is not
Eigen::Dynamic, rows is ignored.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">cols</span></code>:</dt><dd><p>The number of columns in the new variables. When Cols is not
Eigen::Dynamic, cols is ignored.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>All variables will share the same name, but different index.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The MatrixDecisionVariable of size Rows x Cols, containing the new
vars (not all the vars stored).</p>
</dd>
</dl>
<p>Example:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MathematicalProgram</span><span class="w"> </span><span class="n">prog</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prog</span><span class="p">.</span><span class="n">NewContinuousVariables</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;X&quot;</span><span class="p">);</span>
<span class="k">auto</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prog</span><span class="p">.</span><span class="n">NewContinuousVariables</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;X&quot;</span><span class="p">);</span>
</pre></div>
</div>
</details><p>This adds a 2 x 3 matrix decision variables into the program.</p>
<p>The name of the variable is only used for the user in order to ease
readability.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.NewEvenDegreeDsosPolynomial(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">indeterminates:</span> <span class="pre">pydrake.symbolic.Variables,</span> <span class="pre">degree:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">tuple[pydrake.symbolic.Polynomial,</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]],</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]]]</span></span></dt>
<dd><p>see even_degree_nonnegative_polynomial for details. Variant that
produces a DSOS polynomial. Same as NewEvenDegreeSosPolynomial, except
the returned polynomial is diagonally dominant sum of squares (dsos).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.NewEvenDegreeFreePolynomial(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">indeterminates:</span> <span class="pre">pydrake.symbolic.Variables,</span> <span class="pre">degree:</span> <span class="pre">int,</span> <span class="pre">coeff_name:</span> <span class="pre">str</span> <span class="pre">=</span> <span class="pre">'a')</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Polynomial</span></span></dt>
<dd><p>Returns a free polynomial that only contains even degree monomials. A
monomial is even degree if its total degree (sum of all variables’
degree) is even. For example, xy is an even degree monomial (degree 2)
while x²y is not (degree 3).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">indeterminates</span></code>:</dt><dd><p>The monomial basis is over these indeterminates.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">degree</span></code>:</dt><dd><p>The highest degree of the polynomial.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">coeff_name</span></code>:</dt><dd><p>The coefficients of the polynomial are decision variables with
this name as a base. The variable name would be “a1”, “a2”, etc.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.NewEvenDegreeNonnegativePolynomial(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">indeterminates:</span> <span class="pre">pydrake.symbolic.Variables,</span> <span class="pre">degree:</span> <span class="pre">int,</span> <span class="pre">type:</span> <span class="pre">pydrake.solvers.MathematicalProgram.NonnegativePolynomial)</span> <span class="pre">-&gt;</span> <span class="pre">tuple[pydrake.symbolic.Polynomial,</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]],</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]]]</span></span></dt>
<dd><p>See even_degree_nonnegative_polynomial for more details. Variant that
produces different non-negative polynomials depending on <code class="docutils literal notranslate"><span class="pre">type</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">type</span></code>:</dt><dd><p>The returned polynomial p(x) can be either SOS, SDSOS or DSOS,
depending on <code class="docutils literal notranslate"><span class="pre">type</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.NewEvenDegreeSdsosPolynomial(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">indeterminates:</span> <span class="pre">pydrake.symbolic.Variables,</span> <span class="pre">degree:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">tuple[pydrake.symbolic.Polynomial,</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]],</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]]]</span></span></dt>
<dd><p>see even_degree_nonnegative_polynomial for details. Variant that
produces an SDSOS polynomial.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.NewEvenDegreeSosPolynomial(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">indeterminates:</span> <span class="pre">pydrake.symbolic.Variables,</span> <span class="pre">degree:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">tuple[pydrake.symbolic.Polynomial,</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]],</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]]]</span></span></dt>
<dd><p>See even_degree_nonnegative_polynomial for more details. Variant that
produces a SOS polynomial.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.NewFreePolynomial(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">indeterminates:</span> <span class="pre">pydrake.symbolic.Variables,</span> <span class="pre">deg:</span> <span class="pre">int,</span> <span class="pre">coeff_name:</span> <span class="pre">str</span> <span class="pre">=</span> <span class="pre">'a')</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Polynomial</span></span></dt>
<dd><p>Returns a free polynomial in a monomial basis over <code class="docutils literal notranslate"><span class="pre">indeterminates</span></code>
of a given <code class="docutils literal notranslate"><span class="pre">degree</span></code>. It uses <code class="docutils literal notranslate"><span class="pre">coeff_name</span></code> to make new decision
variables and use them as coefficients. For example,
<code class="docutils literal notranslate"><span class="pre">NewFreePolynomial({x₀,</span> <span class="pre">x₁},</span> <span class="pre">2)</span></code> returns a₀x₁² + a₁x₀x₁ + a₂x₀² +
a₃x₁ + a₄x₀ + a₅.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.NewIndeterminates(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>NewIndeterminates(self: pydrake.solvers.MathematicalProgram, rows: int, name: str = ‘x’) -&gt; numpy.ndarray[object[m, 1]]</p></li>
</ol>
<p>Adds indeterminates to this MathematicalProgram, with default name
“x”.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>NewIndeterminates(int rows, int cols, const
std::vector&lt;std::string&gt;&amp; names);</p>
</div>
<ol class="arabic simple" start="2">
<li><p>NewIndeterminates(self: pydrake.solvers.MathematicalProgram, rows: int, cols: int, name: str = ‘X’) -&gt; numpy.ndarray[object[m, n]]</p></li>
</ol>
<p>Adds indeterminates to this MathematicalProgram, with default name
“X”. The new variables are returned and viewed as a matrix, with size
<code class="docutils literal notranslate"><span class="pre">rows</span></code> x <code class="docutils literal notranslate"><span class="pre">cols</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>NewIndeterminates(int rows, int cols, const
std::vector&lt;std::string&gt;&amp; names);</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.NewOddDegreeFreePolynomial(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">indeterminates:</span> <span class="pre">pydrake.symbolic.Variables,</span> <span class="pre">degree:</span> <span class="pre">int,</span> <span class="pre">coeff_name:</span> <span class="pre">str</span> <span class="pre">=</span> <span class="pre">'a')</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Polynomial</span></span></dt>
<dd><p>Returns a free polynomial that only contains odd degree monomials. A
monomial is odd degree if its total degree (sum of all variables’
degree) is even. For example, xy is not an odd degree monomial (degree
2) while x²y is (degree 3).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">indeterminates</span></code>:</dt><dd><p>The monomial basis is over these indeterminates.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">degree</span></code>:</dt><dd><p>The highest degree of the polynomial.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">coeff_name</span></code>:</dt><dd><p>The coefficients of the polynomial are decision variables with
this name as a base. The variable name would be “a1”, “a2”, etc.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.NewSosPolynomial(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>NewSosPolynomial(self: pydrake.solvers.MathematicalProgram, monomial_basis: numpy.ndarray[object[m, 1]], type: pydrake.solvers.MathematicalProgram.NonnegativePolynomial = &lt;NonnegativePolynomial.kSos: 1&gt;, gram_name: str = ‘S’) -&gt; tuple[pydrake.symbolic.Polynomial, numpy.ndarray[object[m, n]]]</p></li>
</ol>
<p>Returns a pair of a SOS polynomial p = mᵀQm and the Gramian matrix Q,
where m is the <code class="docutils literal notranslate"><span class="pre">monomial</span></code> basis. For example,
<code class="docutils literal notranslate"><span class="pre">NewSosPolynomial(Vector2&lt;Monomial&gt;{x,y})</span></code> returns a polynomial p =
Q₍₀,₀₎x² + 2Q₍₁,₀₎xy + Q₍₁,₁₎y² and Q. Depending on the type of the
polynomial, we will impose different constraint on the polynomial. -
if type = kSos, we impose the polynomial being SOS. - if type =
kSdsos, we impose the polynomial being SDSOS. - if type = kDsos, we
impose the polynomial being DSOS.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">gram_name</span></code>:</dt><dd><p>The name of the gram matrix for print out.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Q is a symmetric monomial_basis.rows() x monomial_basis.rows()
matrix.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>NewSosPolynomial(self: pydrake.solvers.MathematicalProgram, gramian: numpy.ndarray[object[m, n], flags.f_contiguous], monomial_basis: numpy.ndarray[object[m, 1]], type: pydrake.solvers.MathematicalProgram.NonnegativePolynomial = &lt;NonnegativePolynomial.kSos: 1&gt;) -&gt; pydrake.symbolic.Polynomial</p></li>
</ol>
<p>Overloads NewSosPolynomial, except the Gramian matrix Q is an input
instead of an output.</p>
<ol class="arabic simple" start="3">
<li><p>NewSosPolynomial(self: pydrake.solvers.MathematicalProgram, indeterminates: pydrake.symbolic.Variables, degree: int, type: pydrake.solvers.MathematicalProgram.NonnegativePolynomial = &lt;NonnegativePolynomial.kSos: 1&gt;, gram_name: str = ‘S’) -&gt; tuple[pydrake.symbolic.Polynomial, numpy.ndarray[object[m, n]]]</p></li>
</ol>
<p>Overloads NewSosPolynomial. Returns a pair of a SOS polynomial p =
m(x)ᵀQm(x) of degree <code class="docutils literal notranslate"><span class="pre">degree</span></code> and the Gramian matrix Q that should
be PSD, where m(x) is the result of calling
<code class="docutils literal notranslate"><span class="pre">MonomialBasis(indeterminates,</span> <span class="pre">degree/2)</span></code>. For example,
<code class="docutils literal notranslate"><span class="pre">NewSosPolynomial({x},</span> <span class="pre">4)</span></code> returns a pair of a polynomial p =
Q₍₀,₀₎x⁴ + 2Q₍₁,₀₎ x³ + (2Q₍₂,₀₎ + Q₍₁,₁₎)x² + 2Q₍₂,₁₎x + Q₍₂,₂₎ and
Q.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">type</span></code>:</dt><dd><p>Depending on the type of the polynomial, we will impose different
constraint on the polynomial. - if type = kSos, we impose the
polynomial being SOS. - if type = kSdsos, we impose the polynomial
being SDSOS. - if type = kDsos, we impose the polynomial being
DSOS.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">gram_name</span></code>:</dt><dd><p>The name of the gram matrix for print out.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if degree is not a positive even integer.</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MonomialBasis.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.NewSymmetricContinuousVariables(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">rows:</span> <span class="pre">int,</span> <span class="pre">name:</span> <span class="pre">str</span> <span class="pre">=</span> <span class="pre">'Symmetric')</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>Adds a runtime sized symmetric matrix as decision variables to this
MathematicalProgram. The optimization will only use the stacked
columns of the lower triangular part of the symmetric matrix as
decision variables.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rows</span></code>:</dt><dd><p>The number of rows in the symmetric matrix.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>The name of the matrix. It is only used the for user to understand
the optimization program. The default name is “Symmetric”, and
each variable will be named as</p>
</dd>
</dl>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Symmetric</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">     </span><span class="n">Symmetric</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">     </span><span class="p">...</span><span class="w"> </span><span class="n">Symmetric</span><span class="p">(</span><span class="n">rows</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="n">Symmetric</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">     </span><span class="n">Symmetric</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">     </span><span class="p">...</span><span class="w"> </span><span class="n">Symmetric</span><span class="p">(</span><span class="n">rows</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">           </span><span class="p">...</span>
<span class="n">Symmetric</span><span class="p">(</span><span class="n">rows</span><span class="mi">-1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">Symmetric</span><span class="p">(</span><span class="n">rows</span><span class="mi">-1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">Symmetric</span><span class="p">(</span><span class="n">rows</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="n">rows</span><span class="mi">-1</span><span class="p">)</span>
</pre></div>
</div>
</details><p>Notice that the (i,j)’th entry and (j,i)’th entry has the same name.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The newly added decision variables.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.NonnegativePolynomial</span></span></dt>
<dd><p>Types of non-negative polynomial that can be found through conic
optimization. We currently support SOS, SDSOS and DSOS. For more
information about these polynomial types, please refer to “DSOS and
SDSOS Optimization: More Tractable Alternatives to Sum of Squares and
Semidefinite Optimization” by Amir Ali Ahmadi and Anirudha Majumdar,
with arXiv link <a class="reference external" href="https://arxiv.org/abs/1706.02586">https://arxiv.org/abs/1706.02586</a></p>
<p>Members:</p>
<blockquote>
<div><p>kSos : A sum-of-squares polynomial.</p>
<p>kSdsos : A scaled-diagonally dominant sum-of-squares polynomial.</p>
<p>kDsos : A diagonally dominant sum-of-squares polynomial.</p>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.NonnegativePolynomial.__init__(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram.NonnegativePolynomial,</span> <span class="pre">value:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.NonnegativePolynomial.kDsos</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.NonnegativePolynomial.kSdsos</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.NonnegativePolynomial.kSos</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.NonnegativePolynomial.name</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.NonnegativePolynomial.value</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.num_indeterminates(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Gets the number of indeterminates in the optimization program</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.num_vars(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Getter for number of variables in the optimization program</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.positive_semidefinite_constraints(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram)</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.solvers.Binding[PositiveSemidefiniteConstraint]]</span></span></dt>
<dd><p>Getter for positive semidefinite constraints.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.quadratic_constraints(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram)</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.solvers.Binding[QuadraticConstraint]]</span></span></dt>
<dd><p>Getter for quadratic constraints.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.quadratic_costs(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram)</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.solvers.Binding[QuadraticCost]]</span></span></dt>
<dd><p>Getter for quadratic costs.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.RelaxPsdConstraintToDdDualCone(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">constraint:</span> <span class="pre">pydrake.solvers.Binding[PositiveSemidefiniteConstraint])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.Binding[LinearConstraint]</span></span></dt>
<dd><p>1. Relaxes the positive semidefinite <code class="docutils literal notranslate"><span class="pre">constraint</span></code> with a diagonally
dominant dual cone constraint. 2. Adds the diagonally dominant dual
cone constraint into this MathematicalProgram. 3. Removes the positive
semidefinite <code class="docutils literal notranslate"><span class="pre">constraint</span></code>, if it had already been registered in this
MathematicalProgram.</p>
<p>This provides a polyhedral (i.e. linear) necessary, but not
sufficient, condition for the variables in <code class="docutils literal notranslate"><span class="pre">constraint</span></code> to be
positive semidefinite.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>The decision variables contained in constraint have been
registered with this MathematicalProgram.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The return of
AddPositiveDiagonallyDominantDualConeMatrixConstraint applied to
the variables in <code class="docutils literal notranslate"><span class="pre">constraint</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.RelaxPsdConstraintToSddDualCone(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">constraint:</span> <span class="pre">pydrake.solvers.Binding[PositiveSemidefiniteConstraint])</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.solvers.Binding[RotatedLorentzConeConstraint]]</span></span></dt>
<dd><p>1. Relaxes the positive semidefinite <code class="docutils literal notranslate"><span class="pre">constraint</span></code> with a scaled
diagonally dominant dual cone constraint. 2. Adds the scaled
diagonally dominant dual cone constraint into this
MathematicalProgram. 3. Removes the positive semidefinite
<code class="docutils literal notranslate"><span class="pre">constraint</span></code>, if it had already been registered in this
MathematicalProgram.</p>
<p>This provides a second-order cone necessary, but not sufficient,
condition for the variables in <code class="docutils literal notranslate"><span class="pre">constraint</span></code> to be positive
semidefinite.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>The decision variables contained in constraint have been
registered with this MathematicalProgram.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The return of AddScaledDiagonallyDominantDualConeMatrixConstraint
applied to the variables in <code class="docutils literal notranslate"><span class="pre">constraint</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.RemoveConstraint(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">constraint:</span> <span class="pre">pydrake.solvers.Binding[Constraint])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Removes <code class="docutils literal notranslate"><span class="pre">constraint</span></code> from this mathematical program. See
remove_cost_constraint “Remove costs, constraints or callbacks” for
more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>number of constraint objects removed from this program. If this
program doesn’t contain <code class="docutils literal notranslate"><span class="pre">constraint</span></code>, then returns 0. If this
program contains multiple <code class="docutils literal notranslate"><span class="pre">constraint</span></code> objects, then returns the
repetition of <code class="docutils literal notranslate"><span class="pre">constraint</span></code> in this program.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.RemoveCost(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">cost:</span> <span class="pre">pydrake.solvers.Binding[Cost])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Removes <code class="docutils literal notranslate"><span class="pre">cost</span></code> from this mathematical program. See
remove_cost_constraint “Remove costs, constraints or callbacks” for
more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>number of cost objects removed from this program. If this program
doesn’t contain <code class="docutils literal notranslate"><span class="pre">cost</span></code>, then returns 0. If this program contains
multiple <code class="docutils literal notranslate"><span class="pre">cost</span></code> objects, then returns the repetition of <code class="docutils literal notranslate"><span class="pre">cost</span></code>
in this program.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.RemoveDecisionVariable(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">var:</span> <span class="pre">pydrake.symbolic.Variable)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Remove <code class="docutils literal notranslate"><span class="pre">var</span></code> from this program’s decision variable.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>after removing the variable, the indices of some remaining
variables inside this MathematicalProgram will change.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the index of <code class="docutils literal notranslate"><span class="pre">var</span></code> in this optimization program. return -1 if
<code class="docutils literal notranslate"><span class="pre">var</span></code> is not a decision variable.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>exception if var is bound with any cost</strong><strong> or </strong><strong>constraint.</strong> – </p></li>
<li><p><strong>exception if var is not a decision variable</strong><strong> of </strong><strong>the program.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.RemoveVisualizationCallback(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">callback:</span> <span class="pre">pydrake.solvers.Binding[VisualizationCallback])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Removes <code class="docutils literal notranslate"><span class="pre">callback</span></code> from this mathematical program. See
remove_cost_constraint “Remove costs, constraints or callbacks” for
more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>number of callback objects removed from this program. If this
program doesn’t contain <code class="docutils literal notranslate"><span class="pre">callback</span></code>, then returns 0. If this
program contains multiple <code class="docutils literal notranslate"><span class="pre">callback</span></code> objects, then returns the
repetition of <code class="docutils literal notranslate"><span class="pre">callback</span></code> in this program.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.Reparse(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">p:</span> <span class="pre">pydrake.symbolic.Polynomial)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Reparses the polynomial <code class="docutils literal notranslate"><span class="pre">p</span></code> using this MathematicalProgram’s
indeterminates.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.required_capabilities(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram)</span> <span class="pre">-&gt;</span> <span class="pre">set[pydrake.solvers.ProgramAttribute]</span></span></dt>
<dd><p>Getter for the required capability on the solver, given the
cost/constraint/variable types in the program.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.rotated_lorentz_cone_constraints(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram)</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.solvers.Binding[RotatedLorentzConeConstraint]]</span></span></dt>
<dd><p>Getter for rotated Lorentz cone constraints.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.SetDecisionVariableValueInVector(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetDecisionVariableValueInVector(self: pydrake.solvers.MathematicalProgram, decision_variable: pydrake.symbolic.Variable, decision_variable_new_value: float, values: Optional[numpy.ndarray[numpy.float64[m, 1], flags.writeable]]) -&gt; None</p></li>
</ol>
<p>Updates the value of a single <code class="docutils literal notranslate"><span class="pre">decision_variable</span></code> inside the
<code class="docutils literal notranslate"><span class="pre">values</span></code> vector to be <code class="docutils literal notranslate"><span class="pre">decision_variable_new_value</span></code>. The other
decision variables’ values in <code class="docutils literal notranslate"><span class="pre">values</span></code> are unchanged.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">decision_variable</span></code>:</dt><dd><p>a registered decision variable in this program.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">decision_variable_new_value</span></code>:</dt><dd><p>the variable’s new values.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">values</span></code>:</dt><dd><p>The vector to be tweaked; must be of size num_vars().</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SetDecisionVariableValueInVector(self: pydrake.solvers.MathematicalProgram, decision_variables: numpy.ndarray[object[m, n], flags.f_contiguous], decision_variables_new_values: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], values: Optional[numpy.ndarray[numpy.float64[m, 1], flags.writeable]]) -&gt; None</p></li>
</ol>
<p>Updates the values of some <code class="docutils literal notranslate"><span class="pre">decision_variables</span></code> inside the
<code class="docutils literal notranslate"><span class="pre">values</span></code> vector to be <code class="docutils literal notranslate"><span class="pre">decision_variables_new_values</span></code>. The other
decision variables’ values in <code class="docutils literal notranslate"><span class="pre">values</span></code> are unchanged.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">decision_variables</span></code>:</dt><dd><p>registered decision variables in this program.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">decision_variables_new_values</span></code>:</dt><dd><p>the variables’ respective new values; must have the same rows()
and cols() sizes and <code class="docutils literal notranslate"><span class="pre">decision_variables</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">values</span></code>:</dt><dd><p>The vector to be tweaked; must be of size num_vars().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.SetInitialGuess(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetInitialGuess(self: pydrake.solvers.MathematicalProgram, arg0: pydrake.symbolic.Variable, arg1: float) -&gt; None</p></li>
</ol>
<p>Sets the initial guess for a single variable <code class="docutils literal notranslate"><span class="pre">decision_variable</span></code>.
The guess is stored as part of this program.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>decision_variable is a registered decision variable in the
program.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if precondition is not satisfied.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SetInitialGuess(self: pydrake.solvers.MathematicalProgram, arg0: numpy.ndarray[object[m, n]], arg1: numpy.ndarray[numpy.float64[m, n]]) -&gt; None</p></li>
</ol>
<p>Sets the initial guess for the decision variables stored in
<code class="docutils literal notranslate"><span class="pre">decision_variable_mat</span></code> to be <code class="docutils literal notranslate"><span class="pre">x0</span></code>. The guess is stored as part of
this program.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.SetInitialGuessForAllVariables(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">arg0:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Set the initial guess for ALL decision variables. Note that variables
begin with a default initial guess of NaN to indicate that no guess is
available.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">x0</span></code>:</dt><dd><p>A vector of appropriate size (num_vars() x 1).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.SetSolverOption(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetSolverOption(self: pydrake.solvers.MathematicalProgram, solver_id: pydrake.solvers.SolverId, solver_option: str, option_value: float) -&gt; None</p></li>
</ol>
<p>See set_solver_option for more details. Set the double-valued options.</p>
<ol class="arabic simple" start="2">
<li><p>SetSolverOption(self: pydrake.solvers.MathematicalProgram, solver_id: pydrake.solvers.SolverId, solver_option: str, option_value: int) -&gt; None</p></li>
</ol>
<p>See set_solver_option for more details. Set the integer-valued
options.</p>
<ol class="arabic simple" start="3">
<li><p>SetSolverOption(self: pydrake.solvers.MathematicalProgram, solver_id: pydrake.solvers.SolverId, solver_option: str, option_value: str) -&gt; None</p></li>
</ol>
<p>See set_solver_option for more details. Set the string-valued options.</p>
<ol class="arabic simple" start="4">
<li><p>SetSolverOption(self: pydrake.solvers.MathematicalProgram, arg0: pydrake.solvers.SolverType, arg1: str, arg2: float) -&gt; None</p></li>
</ol>
<p>See set_solver_option for more details. Set the double-valued options.</p>
<ol class="arabic simple" start="5">
<li><p>SetSolverOption(self: pydrake.solvers.MathematicalProgram, arg0: pydrake.solvers.SolverType, arg1: str, arg2: int) -&gt; None</p></li>
</ol>
<p>See set_solver_option for more details. Set the integer-valued
options.</p>
<ol class="arabic simple" start="6">
<li><p>SetSolverOption(self: pydrake.solvers.MathematicalProgram, arg0: pydrake.solvers.SolverType, arg1: str, arg2: str) -&gt; None</p></li>
</ol>
<p>See set_solver_option for more details. Set the string-valued options.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.SetSolverOptions(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">arg0:</span> <span class="pre">pydrake.solvers.SolverOptions)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Overwrite the stored solver options inside MathematicalProgram with
the provided solver options.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.SetVariableScaling(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">var:</span> <span class="pre">pydrake.symbolic.Variable,</span> <span class="pre">s:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Setter for the scaling <code class="docutils literal notranslate"><span class="pre">s</span></code> of decision variable <code class="docutils literal notranslate"><span class="pre">var</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">var</span></code>:</dt><dd><p>the decision variable to be scaled.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">s</span></code>:</dt><dd><p>scaling factor (must be positive).</p>
</dd>
</dl>
<p>See variable_scaling “Variable scaling” for more information.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.solver_options(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.SolverOptions</span></span></dt>
<dd><p>Returns the solver options stored inside MathematicalProgram.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.TightenPsdConstraintToDd(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">constraint:</span> <span class="pre">pydrake.solvers.Binding[PositiveSemidefiniteConstraint])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>1. Tightens the positive semidefinite <code class="docutils literal notranslate"><span class="pre">constraint</span></code> with a positive
diagonally dominant constraint. 2. Adds the positive diagonally
dominant constraint into this MathematicalProgram. 3. Removes the
positive semidefinite <code class="docutils literal notranslate"><span class="pre">constraint</span></code>, if it had already been
registered in this MathematicalProgram.</p>
<p>This provides a polyhedral (i.e. linear) sufficient, but not
necessary, condition for the variables in <code class="docutils literal notranslate"><span class="pre">constraint</span></code> to be
positive semidefinite.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>The decision variables contained in constraint have been
registered with this MathematicalProgram.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The return of AddPositiveDiagonallyDominantMatrixConstraint
applied to the variables in <code class="docutils literal notranslate"><span class="pre">constraint</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.TightenPsdConstraintToSdd(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">constraint:</span> <span class="pre">pydrake.solvers.Binding[PositiveSemidefiniteConstraint])</span> <span class="pre">-&gt;</span> <span class="pre">list[list[numpy.ndarray[object[2,</span> <span class="pre">2]]]]</span></span></dt>
<dd><p>1. Tightens the positive semidefinite <code class="docutils literal notranslate"><span class="pre">constraint</span></code> with a scaled
diagonally dominant constraint. 2. Adds the scaled diagonally dominant
constraint into this MathematicalProgram. 3. Removes the positive
semidefinite <code class="docutils literal notranslate"><span class="pre">constraint</span></code>, if it had already been registered in this
MathematicalProgram.</p>
<p>This provides a second-order cone sufficient, but not necessary,
condition for the variables in <code class="docutils literal notranslate"><span class="pre">constraint</span></code> to be positive
semidefinite.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>The decision variables contained in constraint have been
registered with this MathematicalProgram.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The return of AddScaledDiagonallyDominantMatrixConstraint applied
to the variables in <code class="docutils literal notranslate"><span class="pre">constraint</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.ToLatex(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">precision:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">3)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a string representation of this program in LaTeX.</p>
<p>This can be particularly useful e.g. in a Jupyter (python) notebook:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">from</span><span class="w"> </span><span class="n">IPython</span><span class="p">.</span><span class="n">display</span><span class="w"> </span><span class="k">import</span><span class="w"> </span><span class="n">Markdown</span><span class="p">,</span><span class="w"> </span><span class="n">display</span>
<span class="n">display</span><span class="p">(</span><span class="n">Markdown</span><span class="p">(</span><span class="n">prog</span><span class="p">.</span><span class="n">ToLatex</span><span class="p">()))</span>
</pre></div>
</div>
</details><p>Note that by default, we do not require variables to have unique
names. Providing useful variable names and calling
Evaluator::set_description() to describe the costs and constraints can
dramatically improve the readability of the output. See the tutorial
<code class="docutils literal notranslate"><span class="pre">debug_mathematical_program.ipynb</span></code> for more information.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgram.visualization_callbacks(self:</span> <span class="pre">pydrake.solvers.MathematicalProgram)</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.solvers.Binding[VisualizationCallback]]</span></span></dt>
<dd><p>Getter for all callbacks.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgramResult</span></span></dt>
<dd><p>The result returned by MathematicalProgram::Solve(). It stores the
solvers::SolutionResult (whether the program is solved to optimality,
detected infeasibility, etc), the optimal value for the decision
variables, the optimal cost, and solver specific details.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgramResult.__init__(self:</span> <span class="pre">pydrake.solvers.MathematicalProgramResult)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs the result.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The solver_details is set to nullptr.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgramResult.EvalBinding(self:</span> <span class="pre">pydrake.solvers.MathematicalProgramResult,</span> <span class="pre">arg0:</span> <span class="pre">pydrake.solvers.Binding[EvaluatorBase])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Evaluate a Binding at the solution.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">binding</span></code>:</dt><dd><p>A binding between a constraint/cost and the variables.</p>
</dd>
<dt>Precondition:</dt><dd><p>The binding.variables() must be the within the decision variables
in the MathematicalProgram that generated this
MathematicalProgramResult.</p>
</dd>
<dt>Precondition:</dt><dd><p>The user must have called set_decision_variable_index() function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgramResult.get_optimal_cost(self:</span> <span class="pre">pydrake.solvers.MathematicalProgramResult)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Gets the optimal cost.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgramResult.get_solution_result(self:</span> <span class="pre">pydrake.solvers.MathematicalProgramResult)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.SolutionResult</span></span></dt>
<dd><p>Gets SolutionResult.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgramResult.get_solver_details(self:</span> <span class="pre">pydrake.solvers.MathematicalProgramResult)</span> <span class="pre">-&gt;</span> <span class="pre">object</span></span></dt>
<dd><p>Gets the solver details for the <code class="docutils literal notranslate"><span class="pre">Solver</span></code> that solved the program.
Throws an error if the solver_details has not been set.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgramResult.get_solver_id(self:</span> <span class="pre">pydrake.solvers.MathematicalProgramResult)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.SolverId</span></span></dt>
<dd><p>Gets the solver ID.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgramResult.get_suboptimal_objective(self:</span> <span class="pre">pydrake.solvers.MathematicalProgramResult,</span> <span class="pre">solution_number:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Gets the suboptimal objective value. See solution_pools “solution
pools”.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">solution_number</span></code>:</dt><dd><p>The index of the sub-optimal solution.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">solution_number</span></code> should be in the range [0,
num_suboptimal_solution()).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgramResult.get_x_val(self:</span> <span class="pre">pydrake.solvers.MathematicalProgramResult)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Gets the decision variable values.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgramResult.GetDualSolution(self:</span> <span class="pre">pydrake.solvers.MathematicalProgramResult,</span> <span class="pre">arg0:</span> <span class="pre">pydrake.solvers.Binding[EvaluatorBase])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Gets the dual solution associated with a constraint.</p>
<p>For constraints in the form lower &lt;= f(x) &lt;= upper (including linear
inequality, linear equality, bounding box constraints, and general
nonlinear constraints), we interpret the dual variable value as the
“shadow price” of the original problem. Namely if we change the
constraint bound by one unit (each unit is infinitesimally small), the
change of the optimal cost is the value of the dual solution times the
unit. Mathematically dual_solution = ∂optimal_cost / ∂bound.</p>
<p>For a linear equality constraint Ax = b where b ∈ ℝⁿ, the vector of
dual variables has n rows, and dual_solution(i) is the value of the
dual variable for the constraint A(i,:)*x = b(i).</p>
<p>For a linear inequality constraint lower &lt;= A*x &lt;= upper where lower
and upper ∈ ℝⁿ, dual_solution also has n rows. dual_solution(i) is the
value of the dual variable for constraint lower(i) &lt;= A(i,:)*x &lt;=
upper(i). If neither side of the constraint is active, then
dual_solution(i) is 0. If the left hand-side lower(i) &lt;= A(i, :)*x is
active (meaning lower(i) = A(i, :)*x at the solution), then
dual_solution(i) is non-negative (because the objective is to minimize
a cost, increasing the lower bound means the constraint set is
tighter, hence the optimal solution cannot decrease. Thus the shadow
price is non-negative). If the right hand-side A(i, :)*x&lt;=upper(i) is
active (meaning A(i,:)*x=upper(i) at the solution), then
dual_solution(i) is non-positive.</p>
<p>For a bounding box constraint lower &lt;= x &lt;= upper, the interpretation
of the dual solution is the same as the linear inequality constraint.</p>
<p>For a Lorentz cone or rotated Lorentz cone constraint that Ax + b is
in the cone, depending on the solver, the dual solution has different
meanings: 1. If the solver is Gurobi, then the user can only obtain
the dual solution by explicitly setting the options for computing dual
solution.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span><span class="w"> </span><span class="n">constraint</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prog</span><span class="p">.</span><span class="n">AddLorentzConeConstraint</span><span class="p">(...);</span>
<span class="w">   </span><span class="n">GurobiSolver</span><span class="w"> </span><span class="n">solver</span><span class="p">;</span>
<span class="w">   </span><span class="c1">// Explicitly tell the solver to compute the dual solution for Lorentz</span>
<span class="w">   </span><span class="c1">// cone or rotated Lorentz cone constraint, check</span>
<span class="w">   </span><span class="c1">// https://www.gurobi.com/documentation/10.1/refman/qcpdual.html for</span>
<span class="w">   </span><span class="c1">// more information.</span>
<span class="w">   </span><span class="n">SolverOptions</span><span class="w"> </span><span class="n">options</span><span class="p">;</span>
<span class="w">   </span><span class="n">options</span><span class="p">.</span><span class="n">SetOption</span><span class="p">(</span><span class="n">GurobiSolver</span><span class="o">::</span><span class="n">id</span><span class="p">(),</span><span class="w"> </span><span class="s">&quot;QCPDual&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">   </span><span class="n">MathematicalProgramResult</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">solver</span><span class="p">.</span><span class="n">Solve</span><span class="p">(</span><span class="n">prog</span><span class="p">,</span><span class="w"> </span><span class="p">{},</span><span class="w"> </span><span class="n">options</span><span class="p">);</span>
<span class="w">   </span><span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXd</span><span class="w"> </span><span class="n">dual_solution</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">result</span><span class="p">.</span><span class="n">GetDualSolution</span><span class="p">(</span><span class="n">constraint</span><span class="p">);</span>
</pre></div>
</div>
</details><p>The dual solution has size 1, dual_solution(0) is the shadow price for
the constraint z₁² + … +zₙ² ≤ z₀² for Lorentz cone constraint, and
the shadow price for the constraint z₂² + … +zₙ² ≤ z₀z₁ for rotated
Lorentz cone constraint, where z is the slack variable representing z
= A*x+b and z in the Lorentz cone/rotated Lorentz cone. 2. For
nonlinear solvers like IPOPT, the dual solution for Lorentz cone
constraint (with EvalType::kConvex) is the shadow price for z₀ -
sqrt(z₁² + … +zₙ²) ≥ 0, where z = Ax+b. 3. For other convex conic
solver such as SCS, MOSEK<a href="/tm.html">™</a>, CSDP, etc, the dual solution to the
(rotated) Lorentz cone constraint doesn’t have the “shadow price”
interpretation, but should lie in the dual cone, and satisfy the KKT
condition. For more information, refer to
https://docs.mosek.com/10.1/capi/prob-def-conic.html#duality-for-conic-optimization
as an explanation.</p>
<p>The interpretation for the dual variable to conic constraint x ∈ K can
be different. Here K is a convex cone, including exponential cone,
power cone, psd cone, etc. When the problem is solved by a convex
solver (like SCS, MOSEK<a href="/tm.html">™</a>, CSDP, etc), often it has a dual variable z ∈
K*, where K* is the dual cone. Here the dual variable DOESN’T have the
interpretation of “shadow price”, but should satisfy the KKT
condition, while the dual variable stays inside the dual cone.</p>
<p>When K is a psd cone, the returned dual solution is the lower triangle
of the dual symmetric psd matrix. Namely for the primal problem</p>
<p>min trace(C*X) s.t A(X) = b X is psd</p>
<p>the dual is</p>
<p>max b’<a href="#id47"><span class="problematic" id="id48">*</span></a>y s.t A’(y) - C = Z Z is psd.</p>
<p>We return the lower triangular part of Z. You can call
drake::math::ToSymmetricMatrixFromLowerTriangularColumns to get the
matrix Z.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgramResult.GetInfeasibleConstraintNames(self:</span> <span class="pre">pydrake.solvers.MathematicalProgramResult,</span> <span class="pre">prog:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">tol:</span> <span class="pre">Optional[float]</span> <span class="pre">=</span> <span class="pre">None)</span> <span class="pre">-&gt;</span> <span class="pre">list[str]</span></span></dt>
<dd><p>See get_infeasible_constraints for more information.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">prog</span></code>:</dt><dd><p>The MathematicalProgram that was solved to obtain <code class="docutils literal notranslate"><span class="pre">this</span></code>
MathematicalProgramResult.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">tolerance</span></code>:</dt><dd><p>A positive tolerance to check the constraint violation. If no
tolerance is provided, this method will attempt to obtain the
constraint tolerance from the solver, or insert a conservative
default tolerance.</p>
</dd>
</dl>
<p>Note: Currently most constraints have the empty string as the
description, so the NiceTypeName of the Constraint is used instead.
Use e.g. <code class="docutils literal notranslate"><span class="pre">prog.AddConstraint(x</span> <span class="pre">==</span>
<span class="pre">1).evaluator().set_description(str)</span></code> to make this method more
specific/useful.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgramResult.GetInfeasibleConstraints(self:</span> <span class="pre">pydrake.solvers.MathematicalProgramResult,</span> <span class="pre">prog:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">tol:</span> <span class="pre">Optional[float]</span> <span class="pre">=</span> <span class="pre">None)</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.solvers.Binding[Constraint]]</span></span></dt>
<dd><p>See get_infeasible_constraints for more information.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">prog</span></code>:</dt><dd><p>The MathematicalProgram that was solved to obtain <code class="docutils literal notranslate"><span class="pre">this</span></code>
MathematicalProgramResult.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">tolerance</span></code>:</dt><dd><p>A positive tolerance to check the constraint violation. If no
tolerance is provided, this method will attempt to obtain the
constraint tolerance from the solver, or insert a conservative
default tolerance.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>infeasible_bindings A vector of all infeasible bindings
(constraints together with the associated variables) at the
best-effort solution.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgramResult.GetSolution(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetSolution(self: pydrake.solvers.MathematicalProgramResult) -&gt; numpy.ndarray[numpy.float64[m, 1]]</p></li>
</ol>
<p>Gets the solution of all decision variables.</p>
<ol class="arabic simple" start="2">
<li><p>GetSolution(self: pydrake.solvers.MathematicalProgramResult, arg0: pydrake.symbolic.Variable) -&gt; float</p></li>
</ol>
<p>Gets the solution of a single decision variable.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">var</span></code>:</dt><dd><p>The decision variable.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The value of the decision variable after solving the problem.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if var is not captured in the mapping</strong> – </p></li>
<li><p><strong>decision_variable_index`</strong><strong>, </strong><strong>as the input argument o</strong> – </p></li>
<li><p><strong>set_decision_variable_index</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>GetSolution(self: pydrake.solvers.MathematicalProgramResult, arg0: numpy.ndarray[object[m, 1]]) -&gt; numpy.ndarray[numpy.float64[m, 1]]</p></li>
</ol>
<p>Gets the solution of an Eigen matrix of decision variables.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">Derived</span></code>:</dt><dd><p>An Eigen matrix containing Variable.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">var</span></code>:</dt><dd><p>The decision variables.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The value of the decision variable after solving the problem.</p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>GetSolution(self: pydrake.solvers.MathematicalProgramResult, arg0: numpy.ndarray[object[m, n]]) -&gt; numpy.ndarray[numpy.float64[m, n]]</p></li>
</ol>
<p>Gets the solution of an Eigen matrix of decision variables.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">Derived</span></code>:</dt><dd><p>An Eigen matrix containing Variable.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">var</span></code>:</dt><dd><p>The decision variables.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The value of the decision variable after solving the problem.</p>
</dd>
</dl>
<ol class="arabic simple" start="5">
<li><p>GetSolution(self: pydrake.solvers.MathematicalProgramResult, arg0: pydrake.symbolic.Expression) -&gt; pydrake.symbolic.Expression</p></li>
</ol>
<p>Substitutes the value of all decision variables into the Expression.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">e</span></code>:</dt><dd><p>The decision variable.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the Expression that is the result of the substitution.</p>
</dd>
</dl>
<ol class="arabic simple" start="6">
<li><p>GetSolution(self: pydrake.solvers.MathematicalProgramResult, arg0: pydrake.symbolic.Polynomial) -&gt; pydrake.symbolic.Polynomial</p></li>
</ol>
<p>Substitutes the value of all decision variables into the coefficients
of the symbolic polynomial.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p</span></code>:</dt><dd><p>A symbolic polynomial. Its indeterminates can’t intersect with the
set of decision variables of the MathematicalProgram from which
this result is obtained.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the symbolic::Polynomial as the result of the substitution.</p>
</dd>
</dl>
<ol class="arabic simple" start="7">
<li><p>GetSolution(self: pydrake.solvers.MathematicalProgramResult, arg0: numpy.ndarray[object[m, n]]) -&gt; numpy.ndarray[object[m, n]]</p></li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgramResult.GetSuboptimalSolution(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetSuboptimalSolution(self: pydrake.solvers.MathematicalProgramResult, arg0: pydrake.symbolic.Variable, arg1: int) -&gt; float</p></li>
</ol>
<p>Gets the suboptimal solution of a decision variable. See
solution_pools “solution pools”</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">var</span></code>:</dt><dd><p>The decision variable.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">solution_number</span></code>:</dt><dd><p>The index of the sub-optimal solution.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">solution_number</span></code> should be in the range [0,
num_suboptimal_solution()).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The suboptimal value of the decision variable after solving the
problem.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetSuboptimalSolution(self: pydrake.solvers.MathematicalProgramResult, arg0: numpy.ndarray[object[m, 1]], arg1: int) -&gt; numpy.ndarray[numpy.float64[m, 1]]</p></li>
</ol>
<p>&#64;name Solution Pools Some solvers (like Gurobi, Cplex, etc) can store
a pool of (suboptimal) solutions for mixed integer programming model.
Gets the suboptimal solution corresponding to a matrix of decision
variables. See solution_pools “solution pools”</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">var</span></code>:</dt><dd><p>The decision variables.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">solution_number</span></code>:</dt><dd><p>The index of the sub-optimal solution.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">solution_number</span></code> should be in the range [0,
num_suboptimal_solution()).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The suboptimal values of the decision variables after solving the
problem.</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>GetSuboptimalSolution(self: pydrake.solvers.MathematicalProgramResult, arg0: numpy.ndarray[object[m, n]], arg1: int) -&gt; numpy.ndarray[numpy.float64[m, n]]</p></li>
</ol>
<p>&#64;name Solution Pools Some solvers (like Gurobi, Cplex, etc) can store
a pool of (suboptimal) solutions for mixed integer programming model.
Gets the suboptimal solution corresponding to a matrix of decision
variables. See solution_pools “solution pools”</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">var</span></code>:</dt><dd><p>The decision variables.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">solution_number</span></code>:</dt><dd><p>The index of the sub-optimal solution.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">solution_number</span></code> should be in the range [0,
num_suboptimal_solution()).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The suboptimal values of the decision variables after solving the
problem.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgramResult.is_success(self:</span> <span class="pre">pydrake.solvers.MathematicalProgramResult)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true if the optimization problem is solved successfully; false
otherwise. For more information on the solution status, the user could
call get_solver_details() to obtain the solver-specific solution
status.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgramResult.num_suboptimal_solution(self:</span> <span class="pre">pydrake.solvers.MathematicalProgramResult)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Number of suboptimal solutions stored inside
MathematicalProgramResult. See solution_pools “solution pools”.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgramResult.set_solution_result(self:</span> <span class="pre">pydrake.solvers.MathematicalProgramResult,</span> <span class="pre">arg0:</span> <span class="pre">pydrake.solvers.SolutionResult)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets SolutionResult.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgramResult.set_x_val(self:</span> <span class="pre">pydrake.solvers.MathematicalProgramResult,</span> <span class="pre">x_val:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the decision variable values.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MathematicalProgramResult.SetSolution(self:</span> <span class="pre">pydrake.solvers.MathematicalProgramResult,</span> <span class="pre">var:</span> <span class="pre">pydrake.symbolic.Variable,</span> <span class="pre">value:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Resets the solution of a single decision variable that is already
registered with this result.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if var is not captured in the mapping</strong> – </p></li>
<li><p><strong>decision_variable_index`</strong><strong>, </strong><strong>as the input argument o</strong> – </p></li>
<li><p><strong>set_decision_variable_index</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MinimumValueLowerBoundConstraint</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Constraint</span></code></p>
<p>Constrain min(v) &gt;= lb where v=f(x). Namely all elements of the vector
<code class="docutils literal notranslate"><span class="pre">v</span></code> returned by the user-provided function f(x) to be no smaller
than a specified value <code class="docutils literal notranslate"><span class="pre">lb</span></code>.</p>
<p>The formulation of the constraint is</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">SmoothOverMax</span><span class="p">(</span><span class="w"> </span><span class="n">φ</span><span class="p">((</span><span class="n">vᵢ</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">v_influence</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">v_influence</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">lb</span><span class="p">))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">φ</span><span class="p">(</span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="err">≤</span><span class="w"> </span><span class="mi">1</span>
</pre></div>
</div>
</details><p>where vᵢ is the i-th value returned by the user-provided function,
<code class="docutils literal notranslate"><span class="pre">lb</span></code> is the minimum allowable value. v_influence is the “influence
value” (the value below which an element influences the constraint or,
conversely, the value above which an element is ignored), φ is a
solvers::MinimumValuePenaltyFunction, and SmoothOverMax(v) is a
smooth, over approximation of max(v) (i.e. SmoothOverMax(v) &gt;= max(v),
for all v). We require that lb &lt; v_influence. The input scaling (vᵢ -
v_influence)/(v_influence - lb) ensures that at the boundary of the
feasible set (when vᵢ == lb), we evaluate the penalty function at -1,
where it is required to have a non-zero gradient. The user-provided
function may return a vector with up to <code class="docutils literal notranslate"><span class="pre">max_num_values</span></code> elements.
If it returns a vector with fewer than <code class="docutils literal notranslate"><span class="pre">max_num_values</span></code> elements,
the remaining elements are assumed to be greater than the “influence
value”.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MinimumValueLowerBoundConstraint.__init__(self:</span> <span class="pre">pydrake.solvers.MinimumValueLowerBoundConstraint,</span> <span class="pre">num_vars:</span> <span class="pre">int,</span> <span class="pre">minimum_value_lower:</span> <span class="pre">float,</span> <span class="pre">influence_value_offset:</span> <span class="pre">float,</span> <span class="pre">max_num_values:</span> <span class="pre">int,</span> <span class="pre">value_function:</span> <span class="pre">Callable[[numpy.ndarray[object[m,</span> <span class="pre">1]],</span> <span class="pre">float],</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]],</span> <span class="pre">value_function_double:</span> <span class="pre">Callable[[numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">float],</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]]</span> <span class="pre">=</span> <span class="pre">None)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a MinimumValueLowerBoundConstraint. min(v) &gt;= lb And we set
ub to infinity in min(v) &lt;= ub.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_vars</span></code>:</dt><dd><p>The number of inputs to <code class="docutils literal notranslate"><span class="pre">value_function</span></code></p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">minimum_value_lower</span></code>:</dt><dd><p>The minimum allowed value, lb, for all elements of the vector
returned by <code class="docutils literal notranslate"><span class="pre">value_function</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">influence_value_offset</span></code>:</dt><dd><p>The difference between the influence value, v_influence, and the
minimum value, lb (see class documentation). This value must be
finite and strictly positive, as it is used to scale the values
returned by <code class="docutils literal notranslate"><span class="pre">value_function</span></code>. Smaller values may decrease the
amount of computation required for each constraint evaluation if
<code class="docutils literal notranslate"><span class="pre">value_function</span></code> can quickly determine that some elements will
be larger than the influence value and skip the computation
associated with those elements.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">max_num_values</span></code>:</dt><dd><p>The maximum number of elements in the vector returned by
<code class="docutils literal notranslate"><span class="pre">value_function</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">value_function</span></code>:</dt><dd><p>User-provided function that takes a <code class="docutils literal notranslate"><span class="pre">num_vars</span></code>-element vector
and the influence distance as inputs and returns a vector with up
to <code class="docutils literal notranslate"><span class="pre">max_num_values</span></code> elements. The function can omit from the
return vector any elements larger than the provided influence
distance.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">value_function_double</span></code>:</dt><dd><p>Optional user-provide function that computes the same values as
<code class="docutils literal notranslate"><span class="pre">value_function</span></code> but for double rather than AutoDiffXd. If
omitted, <code class="docutils literal notranslate"><span class="pre">value_function</span></code> will be called (and the gradients
discarded) when this constraint is evaluated for doubles.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">value_function_double(ExtractValue(x),</span> <span class="pre">v_influence)</span> <span class="pre">==</span>
<span class="pre">ExtractValue(value_function(x,</span> <span class="pre">v_influence))</span></code> for all x.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">value_function(x).size()</span> <span class="pre">&lt;=</span> <span class="pre">max_num_values</span></code> for all x.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if influence_value_offset = ∞.</strong> – </p></li>
<li><p><strong>RuntimeError if influence_value_offset ≤ 0.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MinimumValueLowerBoundConstraint.influence_value(self:</span> <span class="pre">pydrake.solvers.MinimumValueLowerBoundConstraint)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Getter for the influence value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MinimumValueLowerBoundConstraint.minimum_value_lower(self:</span> <span class="pre">pydrake.solvers.MinimumValueLowerBoundConstraint)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Getter for the lower bound on the minimum value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MinimumValueLowerBoundConstraint.set_penalty_function(self:</span> <span class="pre">pydrake.solvers.MinimumValueLowerBoundConstraint,</span> <span class="pre">new_penalty_function:</span> <span class="pre">Callable[[float,</span> <span class="pre">bool],</span> <span class="pre">tuple])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Setter for the penalty function. The penalty function new_penalty_function(x: float, compute_grad: bool) -&gt; tuple[float, Optional[float]] returns [penalty_value, penalty_gradient] when compute_grad=True, or [penalty_value, None] when compute_grad=False. See minimum_value_constraint.h on the requirement on MinimumValuePenaltyFunction.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MinimumValueUpperBoundConstraint</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Constraint</span></code></p>
<p>Constrain min(v) &lt;= ub where v=f(x). Namely at least one element of
the vector <code class="docutils literal notranslate"><span class="pre">v</span></code> returned by the user-provided function f(x) to be no
larger than a specified value <code class="docutils literal notranslate"><span class="pre">ub</span></code>.</p>
<p>The formulation of the constraint is</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">SmoothUnderMax</span><span class="p">(</span><span class="w"> </span><span class="n">φ</span><span class="p">((</span><span class="n">vᵢ</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">v_influence</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">v_influence</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ub</span><span class="p">))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">φ</span><span class="p">(</span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="err">≥</span><span class="w"> </span><span class="mi">1</span>
</pre></div>
</div>
</details><p>where vᵢ is the i-th value returned by the user-provided function,
<code class="docutils literal notranslate"><span class="pre">ub</span></code> is the upper bound for the min(v). (Note that <code class="docutils literal notranslate"><span class="pre">ub</span></code> is NOT the
upper bound of <code class="docutils literal notranslate"><span class="pre">v</span></code>). v_influence is the “influence value” (the value
below which an element influences the constraint or, conversely, the
value above which an element is ignored), φ is a
solvers::MinimumValuePenaltyFunction. SmoothUnderMax(x) is a smooth,
under approximation of max(v) (i.e. SmoothUnderMax(v) &lt;= max(v) for
all v). We require that ub &lt; v_influence. The input scaling (vᵢ -
v_influence)/(v_influence - ub) ensures that at the boundary of the
feasible set (when vᵢ == ub), we evaluate the penalty function at -1,
where it is required to have a non-zero gradient. The user-provided
function may return a vector with up to <code class="docutils literal notranslate"><span class="pre">max_num_values</span></code> elements.
If it returns a vector with fewer than <code class="docutils literal notranslate"><span class="pre">max_num_values</span></code> elements,
the remaining elements are assumed to be greater than the “influence
value”.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MinimumValueUpperBoundConstraint.__init__(self:</span> <span class="pre">pydrake.solvers.MinimumValueUpperBoundConstraint,</span> <span class="pre">num_vars:</span> <span class="pre">int,</span> <span class="pre">minimum_value_upper:</span> <span class="pre">float,</span> <span class="pre">influence_value_offset:</span> <span class="pre">float,</span> <span class="pre">max_num_values:</span> <span class="pre">int,</span> <span class="pre">value_function:</span> <span class="pre">Callable[[numpy.ndarray[object[m,</span> <span class="pre">1]],</span> <span class="pre">float],</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]],</span> <span class="pre">value_function_double:</span> <span class="pre">Callable[[numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">float],</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]]</span> <span class="pre">=</span> <span class="pre">None)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a MinimumValueUpperBoundConstraint. min(v) &lt;= ub</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_vars</span></code>:</dt><dd><p>The number of inputs to <code class="docutils literal notranslate"><span class="pre">value_function</span></code></p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">minimum_value_upper</span></code>:</dt><dd><p>The upper bound on the minimum allowed value for all elements of
the vector returned by <code class="docutils literal notranslate"><span class="pre">value_function</span></code>, namely
min(value_function(x)) &lt;= minimum_value_upper</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">influence_value_offset</span></code>:</dt><dd><p>The difference between the influence value, v_influence, and
minimum_value_upper. This value must be finite and strictly
positive, as it is used to scale the values returned by
<code class="docutils literal notranslate"><span class="pre">value_function</span></code>. Larger values may increase the possibility of
finding a solution to the constraint. With a small v_influence,
the value_function will ignore the entries with value less than
v_influence. While it is possible that by changing x, that value
(that currently been ignored) can decrease to below ub with a
different x, by using a small v_influence, the gradient of that
entry is never considered if the entry is ignored. We strongly
suggest using a larger <code class="docutils literal notranslate"><span class="pre">v_influence</span></code> compared to the one used in
MinimumValueConstraint when constraining min(v) &gt;= lb.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">max_num_values</span></code>:</dt><dd><p>The maximum number of elements in the vector returned by
<code class="docutils literal notranslate"><span class="pre">value_function</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">value_function</span></code>:</dt><dd><p>User-provided function that takes a <code class="docutils literal notranslate"><span class="pre">num_vars</span></code>-element vector
and the influence distance as inputs and returns a vector with up
to <code class="docutils literal notranslate"><span class="pre">max_num_values</span></code> elements. The function can omit from the
return vector any elements larger than the provided influence
distance.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">value_function_double</span></code>:</dt><dd><p>Optional user-provide function that computes the same values as
<code class="docutils literal notranslate"><span class="pre">value_function</span></code> but for double rather than AutoDiffXd. If
omitted, <code class="docutils literal notranslate"><span class="pre">value_function</span></code> will be called (and the gradients
discarded) when this constraint is evaluated for doubles.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">value_function_double(ExtractValue(x),</span> <span class="pre">v_influence)</span> <span class="pre">==</span>
<span class="pre">ExtractValue(value_function(x,</span> <span class="pre">v_influence))</span></code> for all x.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">value_function(x).size()</span> <span class="pre">&lt;=</span> <span class="pre">max_num_values</span></code> for all x.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if influence_value_offset = ∞.</strong> – </p></li>
<li><p><strong>RuntimeError if influence_value_offset ≤ 0.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MinimumValueUpperBoundConstraint.influence_value(self:</span> <span class="pre">pydrake.solvers.MinimumValueUpperBoundConstraint)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Getter for the influence value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MinimumValueUpperBoundConstraint.minimum_value_upper(self:</span> <span class="pre">pydrake.solvers.MinimumValueUpperBoundConstraint)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Getter for the upper bound on the minimum value.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MinimumValueUpperBoundConstraint.set_penalty_function(self:</span> <span class="pre">pydrake.solvers.MinimumValueUpperBoundConstraint,</span> <span class="pre">new_penalty_function:</span> <span class="pre">Callable[[float,</span> <span class="pre">bool],</span> <span class="pre">tuple])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Setter for the penalty function. The penalty function new_penalty_function(x: float, compute_grad: bool) -&gt; tuple[float, Optional[float]] returns [penalty_value, penalty_gradient] when compute_grad=True, or [penalty_value, None] when compute_grad=False. See minimum_value_constraint.h on the requirement on MinimumValuePenaltyFunction.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MixedIntegerBranchAndBound</span></span></dt>
<dd><p>Given a mixed-integer optimization problem (MIP) (or more accurately,
mixed binary problem), solve this problem through branch-and-bound
process. We will first replace all the binary variables with
continuous variables, and relax the integral constraint on the binary
variables z ∈ {0, 1} with continuous constraints 0 ≤ z ≤ 1. In the
subsequent steps, at each node of the tree, we will fix some binary
variables to either 0 or 1, and solve the rest of the variables.
Notice that we will create a new set of variables in the
branch-and-bound process, since we need to replace the binary
variables with continuous variables.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MixedIntegerBranchAndBound.__init__(self:</span> <span class="pre">pydrake.solvers.MixedIntegerBranchAndBound,</span> <span class="pre">prog:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">solver_id:</span> <span class="pre">pydrake.solvers.SolverId,</span> <span class="pre">options:</span> <span class="pre">pydrake.solvers.MixedIntegerBranchAndBound.Options</span> <span class="pre">=</span> <span class="pre">Options(max_explored_nodes=-1))</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Construct a branch-and-bound tree from a mixed-integer optimization
program.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">prog</span></code>:</dt><dd><p>A mixed-integer optimization program.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">solver_id</span></code>:</dt><dd><p>The ID of the solver for the optimization.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MixedIntegerBranchAndBound.GetOptimalCost(self:</span> <span class="pre">pydrake.solvers.MixedIntegerBranchAndBound)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Get the optimal cost.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MixedIntegerBranchAndBound.GetSolution(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetSolution(self: pydrake.solvers.MixedIntegerBranchAndBound, mip_var: pydrake.symbolic.Variable, nth_best_solution: int = 0) -&gt; float</p></li>
</ol>
<p>Get the n’th best integral solution for a variable. The best solutions
are sorted in the ascending order based on their costs. Each solution
is found in a separate node in the branch-and-bound tree, so the
values of the binary variables are different in each solution.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mip_var</span></code>:</dt><dd><p>A variable in the original MIP.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">nth_best_solution</span></code>:</dt><dd><p>The index of the best integral solution.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">mip_var</span></code> is a variable in the original MIP.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">nth_best_solution</span></code> is between 0 and solutions().size().</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the preconditions are not satisfied.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetSolution(self: pydrake.solvers.MixedIntegerBranchAndBound, mip_vars: numpy.ndarray[object[m, 1]], nth_best_solution: int = 0) -&gt; numpy.ndarray[numpy.float64[m, 1]]</p></li>
</ol>
<p>Get the n’th best integral solution for some variables. The best
solutions are sorted in the ascending order based on their costs. Each
solution is found in a separate node in the branch-and-bound tree, so</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mip_vars</span></code>:</dt><dd><p>Variables in the original MIP.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">nth_best_solution</span></code>:</dt><dd><p>The index of the best integral solution.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">mip_vars</span></code> are variables in the original MIP.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">nth_best_solution</span></code> is between 0 and solutions().size().</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the preconditions are not satisfied.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>GetSolution(self: pydrake.solvers.MixedIntegerBranchAndBound, mip_vars: numpy.ndarray[object[m, n]], nth_best_solution: int = 0) -&gt; numpy.ndarray[numpy.float64[m, n]]</p></li>
</ol>
<p>Get the n’th best integral solution for some variables. The best
solutions are sorted in the ascending order based on their costs. Each
solution is found in a separate node in the branch-and-bound tree, so</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mip_vars</span></code>:</dt><dd><p>Variables in the original MIP.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">nth_best_solution</span></code>:</dt><dd><p>The index of the best integral solution.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">mip_vars</span></code> are variables in the original MIP.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">nth_best_solution</span></code> is between 0 and solutions().size().</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the preconditions are not satisfied.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MixedIntegerBranchAndBound.GetSubOptimalCost(self:</span> <span class="pre">pydrake.solvers.MixedIntegerBranchAndBound,</span> <span class="pre">nth_suboptimal_cost:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Get the n’th sub-optimal cost. The costs are sorted in the ascending
order. The sub-optimal costs do not include the optimal cost.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">nth_suboptimal_cost</span></code>:</dt><dd><p>The n’th sub-optimal cost.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">nth_suboptimal_cost</span></code> is between 0 and solutions().size() - 1.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the precondition is not satisfied.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MixedIntegerBranchAndBound.Options</span></span></dt>
<dd><p>Configuration settings for the MixedIntegerBranchAndBound constructor.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MixedIntegerBranchAndBound.Options.__init__(self:</span> <span class="pre">pydrake.solvers.MixedIntegerBranchAndBound.Options,</span> <span class="pre">**kwargs)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MixedIntegerBranchAndBound.Options.max_explored_nodes</span></span></dt>
<dd><p>The maximal number of explored nodes in the tree. The branch and bound
process will terminate if the tree has explored this number of nodes.
max_explored_nodes &lt;= 0 means that we don’t put an upper bound on the
number of explored nodes.</p>
</dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MixedIntegerBranchAndBound.Solve(self:</span> <span class="pre">pydrake.solvers.MixedIntegerBranchAndBound)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.SolutionResult</span></span></dt>
<dd><p>Solve the mixed-integer problem (MIP) through a branch and bound
process.</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">solution_result</span></code>:</dt><dd><p>If solution_result=SolutionResult::kSolutionFound, then the best
solutions are stored inside solutions(). The user can access the
value of each variable(s) through GetSolution(…). If
solution_result=SolutionResult::kInfeasibleConstraints, then the
mixed-integer problem is primal infeasible. If
solution_result=SolutionResult::kUnbounded, then the mixed-integer
problem is primal unbounded.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MixedIntegerRotationConstraintGenerator</span></span></dt>
<dd><p>We relax the non-convex SO(3) constraint on rotation matrix R to
mixed-integer linear constraints. The formulation of these constraints
are described in Global Inverse Kinematics via Mixed-integer Convex
Optimization by Hongkai Dai, Gregory Izatt and Russ Tedrake, ISRR,
2017</p>
<p>The SO(3) constraint on a rotation matrix R = [r₁, r₂, r₃], rᵢ∈ℝ³ is</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">rᵢᵀrᵢ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w">    </span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">rᵢᵀrⱼ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w">    </span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">r₁</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">r₂</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r₃</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</details><p>To relax SO(3) constraint on rotation matrix R, we divide the range
[-1, 1] (the range of each entry in R) into smaller intervals [φ(i),
φ(i+1)], and then relax the SO(3) constraint within each interval. We
provide 3 approaches for relaxation 1. By replacing each bilinear
product in constraint (1), (2) and (3) with a new variable, in the
McCormick envelope of the bilinear product w = x * y. 2. By
considering the intersection region between axis-aligned boxes, and
the surface of a unit sphere in 3D. 3. By combining the two approaches
above. This will result in a tighter relaxation.</p>
<p>These three approaches give different relaxation of SO(3) constraint
(the feasible sets for each relaxation are different), and different
computation speed. The users can switch between the approaches to find
the best fit for their problem.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you have several rotation matrices that all need to be relaxed
through mixed-integer constraint, then you can create a single
MixedIntegerRotationConstraintGenerator object, and add the
mixed-integer constraint to each rotation matrix, by calling
AddToProgram() function repeatedly.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MixedIntegerRotationConstraintGenerator.__init__(self:</span> <span class="pre">pydrake.solvers.MixedIntegerRotationConstraintGenerator,</span> <span class="pre">approach:</span> <span class="pre">pydrake.solvers.MixedIntegerRotationConstraintGenerator.Approach,</span> <span class="pre">num_intervals_per_half_axis:</span> <span class="pre">int,</span> <span class="pre">interval_binning:</span> <span class="pre">pydrake.solvers.IntervalBinning)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructor</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">approach</span></code>:</dt><dd><p>Refer to MixedIntegerRotationConstraintGenerator::Approach for the
details.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_intervals_per_half_axis</span></code>:</dt><dd><p>We will cut the range [-1, 1] evenly to 2 *
<code class="docutils literal notranslate"><span class="pre">num_intervals_per_half_axis</span></code> small intervals. The number of
binary variables will depend on the number of intervals.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">interval_binning</span></code>:</dt><dd><p>The binning scheme we use to add SOS2 constraint with binary
variables. If interval_binning = kLinear, then we will add 9 * 2 *
<code class="docutils literal notranslate"><span class="pre">num_intervals_per_half_axis</span> <span class="pre">binary</span></code> variables; if
interval_binning = kLogarithmic, then we will add 9 * (1 +
log₂(num_intervals_per_half_axis)) binary variables. Refer to
AddLogarithmicSos2Constraint and AddSos2Constraint for more
details.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MixedIntegerRotationConstraintGenerator.AddToProgram(self:</span> <span class="pre">pydrake.solvers.MixedIntegerRotationConstraintGenerator,</span> <span class="pre">R:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">3],</span> <span class="pre">flags.f_contiguous],</span> <span class="pre">prog:</span> <span class="pre">pydrake.solvers.MathematicalProgram)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.MixedIntegerRotationConstraintGenerator.ReturnType</span></span></dt>
<dd><p>Add the mixed-integer linear constraints to the optimization program,
as a relaxation of SO(3) constraint on the rotation matrix <code class="docutils literal notranslate"><span class="pre">R</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R</span></code>:</dt><dd><p>The rotation matrix on which the SO(3) constraint is imposed.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">prog</span></code>:</dt><dd><p>The optimization program to which the mixed-integer constraints
(and additional variables) are added.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MixedIntegerRotationConstraintGenerator.Approach</span></span></dt>
<dd><p>Members:</p>
<blockquote>
<div><p>kBoxSphereIntersection : Relax SO(3) constraint by considering the intersection between boxes</p>
</div></blockquote>
<p>and the unit sphere surface.</p>
<blockquote>
<div><p>kBilinearMcCormick : Relax SO(3) constraint by considering the McCormick envelope on the</p>
</div></blockquote>
<p>bilinear product.</p>
<blockquote>
<div><p>kBoth : Relax SO(3) constraint by considering both the intersection between</p>
</div></blockquote>
<p>boxes and the unit sphere surface, and the McCormick envelope on the
bilinear product.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MixedIntegerRotationConstraintGenerator.Approach.__init__(self:</span> <span class="pre">pydrake.solvers.MixedIntegerRotationConstraintGenerator.Approach,</span> <span class="pre">value:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MixedIntegerRotationConstraintGenerator.Approach.kBilinearMcCormick</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MixedIntegerRotationConstraintGenerator.Approach.kBoth</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MixedIntegerRotationConstraintGenerator.Approach.kBoxSphereIntersection</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MixedIntegerRotationConstraintGenerator.Approach.name</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MixedIntegerRotationConstraintGenerator.Approach.value</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MixedIntegerRotationConstraintGenerator.interval_binning(self:</span> <span class="pre">pydrake.solvers.MixedIntegerRotationConstraintGenerator)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.IntervalBinning</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MixedIntegerRotationConstraintGenerator.num_intervals_per_half_axis(self:</span> <span class="pre">pydrake.solvers.MixedIntegerRotationConstraintGenerator)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MixedIntegerRotationConstraintGenerator.phi(self:</span> <span class="pre">pydrake.solvers.MixedIntegerRotationConstraintGenerator)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Getter for φ.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MixedIntegerRotationConstraintGenerator.phi_nonnegative(self:</span> <span class="pre">pydrake.solvers.MixedIntegerRotationConstraintGenerator)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Getter for φ₊, the non-negative part of φ.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MixedIntegerRotationConstraintGenerator.ReturnType</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MixedIntegerRotationConstraintGenerator.ReturnType.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MixedIntegerRotationConstraintGenerator.ReturnType.B_</span></span></dt>
<dd><p><a href="#id65"><span class="problematic" id="id66">B_</span></a> contains the new binary variables added to the program. B_`i][j]
represents in which interval R(i, j) lies. If we use linear binning,
then B_[i][j] is of length 2 * <a href="#id67"><span class="problematic" id="id68">num_intervals_per_half_axis_</span></a>. B_[i][j
&lt;k&gt;`_ = 1 =&gt; φ(k) ≤ R(i, j) ≤ φ(k + 1) B_`i][j &lt;k&gt;`_ = 0 =&gt; R(i, j) ≥
φ(k + 1) or R(i, j) ≤ φ(k) If we use logarithmic binning, then
B_[i][j] is of length 1 + log₂(<a href="#id69"><span class="problematic" id="id70">num_intervals_per_half_axis_</span></a>). If
B_[i][j] represents integer k in reflected Gray code, then R(i, j) is
in the interval [φ(k), φ(k+1)].</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MixedIntegerRotationConstraintGenerator.ReturnType.lambda_</span></span></dt>
<dd><p>λ contains part of the new continuous variables added to the program.
λ_[i][j] is of length 2 * <a href="#id71"><span class="problematic" id="id72">num_intervals_per_half_axis_</span></a> + 1, such that
R(i, j) = φᵀ * λ_[i][j]. Notice that λ_[i][j] satisfies the special
ordered set of type 2 (SOS2) constraint. Namely at most two entries in
λ_[i][j] can be strictly positive, and these two entries have to be
consecutive. Mathematically</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="err">∑</span><span class="n">ₖ</span><span class="w"> </span><span class="n">λ_</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">](</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="n">λ_</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">](</span><span class="n">k</span><span class="p">)</span><span class="w"> </span><span class="err">≥</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="err">∀</span><span class="w"> </span><span class="n">k</span>
<span class="err">∃</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">t</span><span class="w"> </span><span class="n">λ_</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">](</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="err">≠</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="err">≠</span><span class="w"> </span><span class="n">m</span><span class="o">+</span><span class="mi">1</span>
</pre></div>
</div>
</details></dd></dl>

</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MobyLCPSolver</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.SolverInterface</span></code></p>
<p>A class for solving Linear Complementarity Problems (LCPs). Solving a
LCP requires finding a solution to the problem:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Mz</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">w</span>
<span class="n">z</span><span class="w"> </span><span class="err">≥</span><span class="w"> </span><span class="mi">0</span>
<span class="n">w</span><span class="w"> </span><span class="err">≥</span><span class="w"> </span><span class="mi">0</span>
<span class="n">zᵀw</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
</pre></div>
</div>
</details><p>(where M ∈ ℝⁿˣⁿ and q ∈ ℝⁿ are problem inputs and z ∈ ℝⁿ and w ∈ ℝⁿ
are unknown vectors) or correctly reporting that such a solution does
not exist. In spite of their linear structure, solving LCPs is NP-Hard
[Cottle 1992]. However, some LCPs are significantly easier to solve.
For instance, it can be seen that the LCP is solvable in worst-case
polynomial time for the case of symmetric positive-semi-definite M by
formulating it as the following convex quadratic program:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="nl">minimize</span><span class="p">:</span><span class="w">   </span><span class="n">f</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zᵀw</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">zᵀ</span><span class="p">(</span><span class="n">Mz</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">q</span><span class="p">)</span>
<span class="n">subject</span><span class="w"> </span><span class="n">to</span><span class="o">:</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="err">≥</span><span class="w"> </span><span class="mi">0</span>
<span class="w">            </span><span class="n">Mz</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="err">≥</span><span class="w"> </span><span class="mi">0</span>
</pre></div>
</div>
</details><p>Note that this quadratic program’s (QP) objective function at the
minimum z cannot be less than zero, and the LCP is only solved if the
objective function at the minimum is equal to zero. Since the seminal
result of Karmarkar, it has been known that convex QPs are solvable in
polynomial time [Karmarkar 1984].</p>
<p>The difficulty of solving an LCP is characterized by the properties of
its particular matrix, namely the class of matrices it belongs to.
Classes include, for example, Q, Q₀, P, P₀, copositive, and Z
matrices. [Cottle 1992] and [Murty 1998] (see pp. 224-230 in the
latter) describe relevant matrix classes in more detail.</p>
<ul class="simple">
<li><dl class="simple">
<dt>[Cottle 1992]     R. Cottle, J.-S. Pang, and R. Stone. The Linear</dt><dd><p>Complementarity Problem. Academic Press, 1992.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>[Karmarkar 1984]  N. Karmarkar. A New Polynomial-Time Algorithm for</dt><dd><p>Linear Programming. Combinatorica, 4(4), pp. 373-395.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>[Murty 1988]      K. Murty. Linear Complementarity, Linear and Nonlinear</dt><dd><p>Programming. Heldermann Verlag, 1988.</p>
</dd>
</dl>
</li>
</ul>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MobyLCPSolver.__init__(self:</span> <span class="pre">pydrake.solvers.MobyLCPSolver)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MobyLCPSolver.id()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.SolverId</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MosekSolver</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.SolverInterface</span></code></p>
<p>An implementation of SolverInterface for the commercially-licensed
MOSEK (TM) solver (<a class="reference external" href="https://www.mosek.com/">https://www.mosek.com/</a>).</p>
<p>Drake downloads and builds MOSEK<a href="/tm.html">™</a> automatically, but to enable it you
must set the location of your license file as described in the
documentation at <a class="reference external" href="https://drake.mit.edu/bazel.html#mosek">https://drake.mit.edu/bazel.html#mosek</a>.</p>
<p>The MOSEKLM_LICENSE_FILE environment variable controls whether or not
SolverInterface::enabled() returns true. Iff it is set to any
non-empty value, then the solver is enabled; otherwise, the solver is
not enabled.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>MOSEK<a href="/tm.html">™</a> only cares about the initial guess of integer variables.
The initial guess of continuous variables are not passed to
MOSEK<a href="/tm.html">™</a>. If all the integer variables are set to some integer
values, then MOSEK<a href="/tm.html">™</a> will be forced to compute the remaining
continuous variable values as the initial guess. (MOSEK<a href="/tm.html">™</a> might
change the values of the integer/binary variables in the
subsequent iterations.) If the specified integer solution is
infeasible or incomplete, MOSEK<a href="/tm.html">™</a> will simply ignore it. For more
details, check
<a class="reference external" href="https://docs.mosek.com/10.1/capi/tutorial-mio-shared.html?highlight=initial">https://docs.mosek.com/10.1/capi/tutorial-mio-shared.html?highlight=initial</a></p>
</div>
<p>MOSEK<a href="/tm.html">™</a> supports many solver parameters. You can refer to the full list
of parameters in
<a class="reference external" href="https://docs.mosek.com/10.1/capi/param-groups.html#doc-param-groups">https://docs.mosek.com/10.1/capi/param-groups.html#doc-param-groups</a>.
On top of these parameters, we also provide the following additional
parameters</p>
<ul class="simple">
<li><dl class="simple">
<dt>“writedata”</dt><dd><p>set to a file name so that MOSEK<a href="/tm.html">™</a> solver will write the
optimization model to this file. check
<a class="reference external" href="https://docs.mosek.com/10.1/capi/solver-io.html#saving-a-problem-to-a-file">https://docs.mosek.com/10.1/capi/solver-io.html#saving-a-problem-to-a-file</a>
for more details. The supported file extensions are listed in
<a class="reference external" href="https://docs.mosek.com/10.1/capi/supported-file-formats.html#doc-shared-file-formats">https://docs.mosek.com/10.1/capi/supported-file-formats.html#doc-shared-file-formats</a>.
Set this parameter to “” if you don’t want to write to a file. Default is
not to write to a file.</p>
</dd>
</dl>
</li>
</ul>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MosekSolver.__init__(self:</span> <span class="pre">pydrake.solvers.MosekSolver)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MosekSolver.AcquireLicense()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.MosekSolver.License</span></span></dt>
<dd><p>This acquires a MOSEK<a href="/tm.html">™</a> license environment shared among all
MosekSolver instances; the environment will stay valid as long as at
least one shared_ptr returned by this function is alive. Call this
ONLY if you must use different MathematicalProgram instances at
different instances in time, and repeatedly acquiring the license is
costly (e.g., requires contacting a license server).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A shared pointer to a license environment that will stay valid as
long as any shared_ptr returned by this function is alive. If
MOSEK<a href="/tm.html">™</a> is not available in your build, this will return a null
(empty) shared_ptr.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if MOSEK<a href="/tm.html">™</a> is available but a license cannot be</strong> – </p></li>
<li><p><strong>obtained.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MosekSolver.id()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.SolverId</span></span></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MosekSolver.License</span></span></dt>
<dd><p>Context-manageable license from <code class="docutils literal notranslate"><span class="pre">MosekSolver.AcquireLicense()</span></code>.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MosekSolver.License.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MosekSolver.License.is_valid(self:</span> <span class="pre">pydrake.solvers.MosekSolver.License)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Indicates that this has a valid license that has not been released.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MosekSolverDetails</span></span></dt>
<dd><p>The MOSEK<a href="/tm.html">™</a> solver details after calling Solve() function. The user can
call MathematicalProgramResult::get_solver_details&lt;MosekSolver&gt;() to
obtain the details.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MosekSolverDetails.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MosekSolverDetails.optimizer_time</span></span></dt>
<dd><p>The MOSEK<a href="/tm.html">™</a> optimization time. Please refer to MSK_DINF_OPTIMIZER_TIME
in
<a class="reference external" href="https://docs.mosek.com/10.1/capi/constants.html?highlight=msk_dinf_optimizer_time">https://docs.mosek.com/10.1/capi/constants.html?highlight=msk_dinf_optimizer_time</a></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MosekSolverDetails.rescode</span></span></dt>
<dd><p>The response code returned from MOSEK<a href="/tm.html">™</a> solver. Check
<a class="reference external" href="https://docs.mosek.com/10.1/capi/response-codes.html">https://docs.mosek.com/10.1/capi/response-codes.html</a> for the meaning
on the response code.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MosekSolverDetails.solution_status</span></span></dt>
<dd><p>The solution status after solving the problem. Check
<a class="reference external" href="https://docs.mosek.com/10.1/capi/accessing-solution.html">https://docs.mosek.com/10.1/capi/accessing-solution.html</a> and
<a class="reference external" href="https://docs.mosek.com/10.1/capi/constants.html#mosek.solsta">https://docs.mosek.com/10.1/capi/constants.html#mosek.solsta</a> for the
meaning on the solution status.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">NloptSolver</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.SolverInterface</span></code></p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">NloptSolver.__init__(self:</span> <span class="pre">pydrake.solvers.NloptSolver)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">NloptSolver.AlgorithmName()</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>The key name for the string-valued algorithm.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">NloptSolver.ConstraintToleranceName()</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>The key name for the double-valued constraint tolerance.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">NloptSolver.id()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.SolverId</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">NloptSolver.MaxEvalName()</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>The key name for int-valued maximum number of evaluations.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">NloptSolver.XAbsoluteToleranceName()</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>The key name for double-valued x absolute tolerance.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">NloptSolver.XRelativeToleranceName()</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>The key name for double-valued x relative tolerance.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">NloptSolverDetails</span></span></dt>
<dd><p>The NLopt solver details after calling Solve() function. The user can
call MathematicalProgramResult::get_solver_details&lt;NloptSolver&gt;() to
obtain the details.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">NloptSolverDetails.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">NloptSolverDetails.status</span></span></dt>
<dd><p>The return status of NLopt solver. Please refer to
<a class="reference external" href="https://nlopt.readthedocs.io/en/latest/NLopt_Reference/#return-values">https://nlopt.readthedocs.io/en/latest/NLopt_Reference/#return-values</a>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OsqpSolver</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.SolverInterface</span></code></p>
<p>A wrapper to call <a class="reference external" href="https://osqp.org/">OSQP</a> using Drake’s
MathematicalProgram.</p>
<p>For details about OSQP’s available options, refer to the <a class="reference external" href="https://osqp.org/docs/interfaces/solver_settings.html">OSQP manual</a>. Drake uses
OSQP’s default values for all options except following: - Drake
defaults to <code class="docutils literal notranslate"><span class="pre">polish=true</span></code> (upstream default is <code class="docutils literal notranslate"><span class="pre">False</span></code>). - Drake
defaults to <code class="docutils literal notranslate"><span class="pre">adaptive_rho_interval=ADAPTIVE_RHO_FIXED</span></code> to make the
output deterministic (upstream default is <code class="docutils literal notranslate"><span class="pre">0</span></code>, which uses
non-deterministic timing measurements to establish the interval). N.B.
Generally the interval should be an integer multiple of
<code class="docutils literal notranslate"><span class="pre">check_termination</span></code>, so if you choose to override either option you
should probably override both at once.</p>
<p>At the end of OsqpSolver::Solve() function, we always return the value
of the primal and dual variables inside the OSQP solver, regardless of
the solver status (whether it is optimal, infeasible, unbounded, etc),
except when the problem has an invalid input. Users should always
check the solver status before interpreting the returned primal and
dual variables.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OsqpSolver.__init__(self:</span> <span class="pre">pydrake.solvers.OsqpSolver)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OsqpSolver.id()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.SolverId</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OsqpSolverDetails</span></span></dt>
<dd><p>The OSQP solver details after calling Solve() function. The user can
call MathematicalProgramResult::get_solver_details&lt;OsqpSolver&gt;() to
obtain the details.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OsqpSolverDetails.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OsqpSolverDetails.dual_res</span></span></dt>
<dd><p>Norm of dual residue.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OsqpSolverDetails.iter</span></span></dt>
<dd><p>Number of iterations taken.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OsqpSolverDetails.polish_time</span></span></dt>
<dd><p>Time taken for polish phase (seconds).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OsqpSolverDetails.primal_res</span></span></dt>
<dd><p>Norm of primal residue.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OsqpSolverDetails.run_time</span></span></dt>
<dd><p>Total OSQP time (seconds).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OsqpSolverDetails.setup_time</span></span></dt>
<dd><p>Time taken for setup phase (seconds).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OsqpSolverDetails.solve_time</span></span></dt>
<dd><p>Time taken for solve phase (seconds).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OsqpSolverDetails.status_val</span></span></dt>
<dd><p>Status of the solver at termination. Please refer to
<a class="reference external" href="https://github.com/oxfordcontrol/osqp/blob/master/include/constants.h">https://github.com/oxfordcontrol/osqp/blob/master/include/constants.h</a></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OsqpSolverDetails.y</span></span></dt>
<dd><p>y contains the solution for the Lagrangian multiplier associated with
l &lt;= Ax &lt;= u. The Lagrangian multiplier is set only when OSQP solves
the problem. Notice that the order of the linear constraints are
linear inequality first, and then linear equality constraints.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PerspectiveQuadraticCost</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Cost</span></code></p>
<p>If <span class="math notranslate nohighlight">\(z = Ax + b,\)</span> implements a cost of the form:</p>
<div class="math notranslate nohighlight">
\[(z_1^2 + z_2^2 + ... + z_{n-1}^2) / z_0.\]</div>
<p>Note that this cost is convex when we additionally constrain z_0 &gt; 0.
It is treated as a generic nonlinear objective by most solvers.</p>
<p>Costs of this form are sometimes referred to as “quadratic over
linear”.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PerspectiveQuadraticCost.__init__(self:</span> <span class="pre">pydrake.solvers.PerspectiveQuadraticCost,</span> <span class="pre">A:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]],</span> <span class="pre">b:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Construct a cost of the form (z_1^2 + z_2^2 + … + z_{n-1}^2) / z_0
where z = Ax + b.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">A</span></code>:</dt><dd><p>Linear term.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>:</dt><dd><p>Constant term.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PerspectiveQuadraticCost.A(self:</span> <span class="pre">pydrake.solvers.PerspectiveQuadraticCost)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PerspectiveQuadraticCost.b(self:</span> <span class="pre">pydrake.solvers.PerspectiveQuadraticCost)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PerspectiveQuadraticCost.update_A_entry(self:</span> <span class="pre">pydrake.solvers.PerspectiveQuadraticCost,</span> <span class="pre">i:</span> <span class="pre">int,</span> <span class="pre">j:</span> <span class="pre">int,</span> <span class="pre">val:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Updates A(i, j) = val.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>if i</strong><strong> or </strong><strong>j are invalid indices.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PerspectiveQuadraticCost.update_b_entry(self:</span> <span class="pre">pydrake.solvers.PerspectiveQuadraticCost,</span> <span class="pre">i:</span> <span class="pre">int,</span> <span class="pre">val:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Updates b(i) = val.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>if i is an invalid index.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PerspectiveQuadraticCost.UpdateCoefficients(self:</span> <span class="pre">pydrake.solvers.PerspectiveQuadraticCost,</span> <span class="pre">new_A:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]],</span> <span class="pre">new_b:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Updates the coefficients of the cost. Note that the number of
variables (columns of A) cannot change.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_A</span></code>:</dt><dd><p>New linear term.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_b</span></code>:</dt><dd><p>New constant term.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PositiveSemidefiniteConstraint</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Constraint</span></code></p>
<p>Implements a positive semidefinite constraint on a symmetric matrix S</p>
<div class="math notranslate nohighlight">
\[\text{
S is p.s.d\]</div>
<p>}</p>
<p>namely, all eigen values of S are non-negative.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>if the matix S has 1 row, then it is better to impose a linear
inequality constraints; if it has 2 rows, then it is better to
impose a rotated Lorentz cone constraint, since a 2 x 2 matrix S
being p.s.d is equivalent to the constraint [S(0, 0), S(1, 1),
S(0, 1)] in the rotated Lorentz cone.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PositiveSemidefiniteConstraint.__init__(self:</span> <span class="pre">pydrake.solvers.PositiveSemidefiniteConstraint,</span> <span class="pre">rows:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Impose the constraint that a symmetric matrix with size <code class="docutils literal notranslate"><span class="pre">rows</span></code> x
<code class="docutils literal notranslate"><span class="pre">rows</span></code> is positive semidefinite.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MathematicalProgram::AddPositiveSemidefiniteConstraint() for how
to use this constraint on some decision variables. We currently
use this constraint as a place holder in MathematicalProgram, to
indicate the positive semidefiniteness of some decision variables.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">rows</span></code>:</dt><dd><p>The number of rows (and columns) of the symmetric matrix.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">rows</span></code> should be a positive integer. If <a href="#id49"><span class="problematic" id="id50">`</span></a>rows`==1 or <a href="#id51"><span class="problematic" id="id52">`</span></a>rows`==2,
then consider imposing a linear inequality or rotated Lorentz cone
constraint respectively.</p>
</div>
<p>Example:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Create a MathematicalProgram object.</span>
<span class="k">auto</span><span class="w"> </span><span class="n">prog</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MathematicalProgram</span><span class="p">();</span>

<span class="c1">// Add a 3 x 3 symmetric matrix S to optimization program as new decision</span>
<span class="c1">// variables.</span>
<span class="k">auto</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">prog</span><span class="p">.</span><span class="n">NewSymmetricContinuousVariables</span><span class="o">&lt;</span><span class="mi">3</span><span class="o">&gt;</span><span class="p">(</span><span class="s">&quot;S&quot;</span><span class="p">);</span>

<span class="c1">// Impose a positive semidefinite constraint on S.</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">PositiveSemidefiniteConstraint</span><span class="o">&gt;</span><span class="w"> </span><span class="n">psd_constraint</span><span class="w"> </span><span class="o">=</span>
<span class="w">    </span><span class="n">prog</span><span class="p">.</span><span class="n">AddPositiveSemidefiniteConstraint</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>

<span class="c1">/////////////////////////////////////////////////////////////</span>
<span class="c1">// Add more constraints to make the program more interesting,</span>
<span class="c1">// but this is not needed.</span>

<span class="c1">// Add the constraint that S(1, 0) = 1.</span>
<span class="n">prog</span><span class="p">.</span><span class="n">AddBoundingBoxConstraint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">S</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span>

<span class="c1">// Minimize S(0, 0) + S(1, 1) + S(2, 2).</span>
<span class="n">prog</span><span class="p">.</span><span class="n">AddLinearCost</span><span class="p">(</span><span class="n">Eigen</span><span class="o">::</span><span class="n">RowVector3d</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="p">{</span><span class="n">S</span><span class="p">.</span><span class="n">diagonal</span><span class="p">()});</span>

<span class="c1">/////////////////////////////////////////////////////////////</span>

<span class="c1">// Now solve the program.</span>
<span class="k">auto</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Solve</span><span class="p">(</span><span class="n">prog</span><span class="p">);</span>

<span class="c1">// Retrieve the solution of matrix S.</span>
<span class="k">auto</span><span class="w"> </span><span class="n">S_value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetSolution</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="w"> </span><span class="n">result</span><span class="p">);</span>

<span class="c1">// Compute the eigen values of the solution, to see if they are</span>
<span class="c1">// all non-negative.</span>
<span class="n">Vector6d</span><span class="w"> </span><span class="n">S_stacked</span><span class="p">;</span>
<span class="n">S_stacked</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">S_value</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span><span class="w"> </span><span class="n">S_value</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">S_value</span><span class="p">.</span><span class="n">col</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

<span class="n">Eigen</span><span class="o">::</span><span class="n">VectorXd</span><span class="w"> </span><span class="n">S_eigen_values</span><span class="p">;</span>
<span class="n">psd_constraint</span><span class="o">-&gt;</span><span class="n">Eval</span><span class="p">(</span><span class="n">S_stacked</span><span class="p">,</span><span class="w"> </span><span class="n">S_eigen_values</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;S solution is: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">&quot;The eigen value of S is &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">S_eigen_values</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
</details></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PositiveSemidefiniteConstraint.matrix_rows(self:</span> <span class="pre">pydrake.solvers.PositiveSemidefiniteConstraint)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProgramAttribute</span></span></dt>
<dd><p>Members:</p>
<blockquote>
<div><p>kGenericCost : A generic cost, doesn’t belong to any specific cost type</p>
<p>kGenericConstraint : A generic constraint, doesn’t belong to any specific</p>
<p>kQuadraticCost : A quadratic function as the cost.</p>
<p>kQuadraticConstraint : A constraint on a quadratic function.</p>
<p>kLinearCost : A linear function as the cost.</p>
<p>kLinearConstraint : A constraint on a linear function.</p>
<p>kLinearEqualityConstraint : An equality constraint on a linear function.</p>
<p>kLinearComplementarityConstraint : A linear complementarity constraint in</p>
<p>kLorentzConeConstraint : A Lorentz cone constraint.</p>
<p>kRotatedLorentzConeConstraint : A rotated Lorentz cone constraint.</p>
<p>kPositiveSemidefiniteConstraint : A positive semidefinite constraint.</p>
<p>kExponentialConeConstraint : An exponential cone constraint.</p>
<p>kL2NormCost : An L2 norm <a href="#id63"><span class="problematic" id="id64">|Ax+b|</span></a></p>
<p>kBinaryVariable : Variable taking binary value {0, 1}.</p>
<p>kCallback : Supports callback during solving the problem.</p>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProgramAttribute.__init__(self:</span> <span class="pre">pydrake.solvers.ProgramAttribute,</span> <span class="pre">value:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProgramAttribute.kBinaryVariable</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProgramAttribute.kCallback</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProgramAttribute.kExponentialConeConstraint</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProgramAttribute.kGenericConstraint</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProgramAttribute.kGenericCost</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProgramAttribute.kL2NormCost</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProgramAttribute.kLinearComplementarityConstraint</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProgramAttribute.kLinearConstraint</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProgramAttribute.kLinearCost</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProgramAttribute.kLinearEqualityConstraint</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProgramAttribute.kLorentzConeConstraint</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProgramAttribute.kPositiveSemidefiniteConstraint</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProgramAttribute.kQuadraticConstraint</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProgramAttribute.kQuadraticCost</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProgramAttribute.kRotatedLorentzConeConstraint</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProgramAttribute.name</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProgramAttribute.value</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProgramType</span></span></dt>
<dd><p>A coarse categorization of the optimization problem based on the type
of constraints/costs/variables. Notice that Drake chooses the solver
based on a finer category; for example we have a specific solver for
equality-constrained convex QP.</p>
<p>Members:</p>
<blockquote>
<div><p>kLP : Linear Programming, with a linear cost and linear constraints.</p>
<p>kQP : Quadratic Programming, with a convex quadratic cost and linear</p>
</div></blockquote>
<p>constraints.</p>
<blockquote>
<div><p>kSOCP : Second-order Cone Programming, with a linear cost and second-order</p>
</div></blockquote>
<p>cone constraints.</p>
<blockquote>
<div><p>kSDP : Semidefinite Programming, with a linear cost and positive semidefinite</p>
</div></blockquote>
<p>matrix constraints.</p>
<blockquote>
<div><p>kGP : Geometric Programming, with a linear cost and exponential cone</p>
</div></blockquote>
<p>constraints.</p>
<blockquote>
<div><p>kCGP : Conic Geometric Programming, this is a superset that unifies GP and</p>
</div></blockquote>
<p>SDP. Refer to <a class="reference external" href="http://people.lids.mit.edu/pari/cgp_preprint.pdf">http://people.lids.mit.edu/pari/cgp_preprint.pdf</a> for
more details.</p>
<blockquote>
<div><p>kMILP : Mixed-integer Linear Programming. LP with some variables taking binary</p>
</div></blockquote>
<p>values.</p>
<blockquote>
<div><p>kMIQP : Mixed-integer Quadratic Programming. QP with some variables taking</p>
</div></blockquote>
<p>binary values.</p>
<blockquote>
<div><p>kMISOCP : Mixed-integer Second-order Cone Programming. SOCP with some variables</p>
</div></blockquote>
<p>taking binary values.</p>
<blockquote>
<div><p>kMISDP : Mixed-integer Semidefinite Programming. SDP with some variables taking</p>
</div></blockquote>
<p>binary values.</p>
<blockquote>
<div><p>kQuadraticCostConicConstraint : convex quadratic cost with nonlinear conic constraints.</p>
<p>kNLP : nonlinear programming. Programs with generic costs or constraints.</p>
<p>kLCP : Linear Complementarity Programs. Programs with linear complementary</p>
</div></blockquote>
<p>constraints and no cost.</p>
<blockquote>
<div><p>kUnknown : Does not fall into any of the types above.</p>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProgramType.__init__(self:</span> <span class="pre">pydrake.solvers.ProgramType,</span> <span class="pre">value:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProgramType.kCGP</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProgramType.kGP</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProgramType.kLCP</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProgramType.kLP</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProgramType.kMILP</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProgramType.kMIQP</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProgramType.kMISDP</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProgramType.kMISOCP</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProgramType.kNLP</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProgramType.kQP</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProgramType.kQuadraticCostConicConstraint</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProgramType.kSDP</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProgramType.kSOCP</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProgramType.kUnknown</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProgramType.name</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProgramType.value</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProjectedGradientDescentSolver</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.SolverInterface</span></code></p>
<p>Solves a nonlinear program via the projected gradient descent
algorithm. The gradient is determined by differentiation of the costs,
or the user can supply a custom gradient function. The projection step
is itself an optimization problem in general, but the user can supply
a custom projection function. The user can also specify a specific
solver interface to be used to solve the projection problem.</p>
<p>The solver terminates if - the projection step fails to find a
feasible solution, - the 2-norm distance between subsequent iterates
is less than the user-specified tolerance (see
ProjectedGradientDescentSolver::ConvergenceTolOptionName
“ConvergenceTolOptionName”), or - a maximum number of iterations have
been run (see ProjectedGradientDescentSolver::MaxIterationsOptionName
“MaxIterationsOptionName”).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This feature is considered to be <strong>experimental</strong> and may change
or be removed at any time, without any deprecation notice ahead of
time.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProjectedGradientDescentSolver.__init__(self:</span> <span class="pre">pydrake.solvers.ProjectedGradientDescentSolver)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProjectedGradientDescentSolver.BacktrackingAlpha0OptionName()</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>string key for SolverOptions to set the value of alpha_0 to use
for the backtracking line search. Must be positive.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProjectedGradientDescentSolver.BacktrackingCOptionName()</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>string key for SolverOptions to set the value of c to use for the
backtracking line search. Must be between 0 and 1.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProjectedGradientDescentSolver.BacktrackingTauOptionName()</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>string key for SolverOptions to set the value of tau to use for
the backtracking line search. Must be between 0 and 1.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProjectedGradientDescentSolver.ConvergenceTolOptionName()</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>string key for SolverOptions to set the threshold used to
determine convergence. It must be positive.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProjectedGradientDescentSolver.id()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.SolverId</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProjectedGradientDescentSolver.kDefaultBacktrackingAlpha0</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProjectedGradientDescentSolver.kDefaultBacktrackingC</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProjectedGradientDescentSolver.kDefaultBacktrackingTau</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProjectedGradientDescentSolver.kDefaultConvergenceTol</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProjectedGradientDescentSolver.kDefaultMaxIterations</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProjectedGradientDescentSolver.kDefaultMaxLineSearchSteps</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProjectedGradientDescentSolver.MaxIterationsOptionName()</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>string key for SolverOptions to set the maximum number of
iterations. It must be a positive integer.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProjectedGradientDescentSolver.SetCustomGradientFunction(self:</span> <span class="pre">pydrake.solvers.ProjectedGradientDescentSolver,</span> <span class="pre">custom_gradient_function:</span> <span class="pre">Callable[[numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]],</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Specify a custom gradient function. Otherwise, this solver will
differentiate through the costs in the MathematicalProgram it’s used
to solve.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProjectedGradientDescentSolver.SetCustomProjectionFunction(self:</span> <span class="pre">pydrake.solvers.ProjectedGradientDescentSolver,</span> <span class="pre">custom_projection_function:</span> <span class="pre">Callable)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Specify a custom projection function. Otherwise, this solver will
attempt to solve the L2 projection onto the feasible set of the
MathematicalProgram it’s used to solve. The projection function
should return a tuple, whose first entry is a boolean value
indicating success or failure, and whose second value is the result
of the projection. It should take in as an argument the point we are
trying to stay close to.</p>
<p class="rubric">Example</p>
<p>You can define a custom projection function in Python, such as projecting onto the nonnegative orthant:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">nonnegative_projection</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="c1"># Project onto the set {x | x &gt;= 0}</span>
    <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ProjectedGradientDescentSolver.SetProjectionSolverInterface(self:</span> <span class="pre">pydrake.solvers.ProjectedGradientDescentSolver,</span> <span class="pre">projection_solver_interface:</span> <span class="pre">pydrake.solvers.SolverInterface)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Specify a solver interface to be used when solving the L2 projection
onto the feasible set of the MathematicalProgram it’s being used to
solve.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PyFunctionConstraint</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Constraint</span></code></p>
<p>Constraint with its evaluator as a Python function</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PyFunctionConstraint.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PyFunctionConstraint.set_bounds(self:</span> <span class="pre">pydrake.solvers.PyFunctionConstraint,</span> <span class="pre">lower_bound:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">upper_bound:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Set both the lower and upper bounds of the constraint.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PyFunctionConstraint.UpdateLowerBound(self:</span> <span class="pre">pydrake.solvers.PyFunctionConstraint,</span> <span class="pre">new_lb:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Update the lower bound of the constraint.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PyFunctionConstraint.UpdateUpperBound(self:</span> <span class="pre">pydrake.solvers.PyFunctionConstraint,</span> <span class="pre">new_ub:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Update the upper bound of the constraint.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuadraticConstraint</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Constraint</span></code></p>
<p>lb ≤ .5 xᵀQx + bᵀx ≤ ub Without loss of generality, the class stores a
symmetric matrix Q. For a non-symmetric matrix Q₀, we can define Q =
(Q₀ + Q₀ᵀ) / 2, since xᵀQ₀x = xᵀQ₀ᵀx = xᵀ*(Q₀+Q₀ᵀ)/2 <a href="#id53"><span class="problematic" id="id54">*</span></a>x. The first
equality holds because the transpose of a scalar is the scalar itself.
Hence we can always convert a non-symmetric matrix Q₀ to a symmetric
matrix Q.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuadraticConstraint.__init__(self:</span> <span class="pre">pydrake.solvers.QuadraticConstraint,</span> <span class="pre">Q0:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous],</span> <span class="pre">b:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">lb:</span> <span class="pre">float,</span> <span class="pre">ub:</span> <span class="pre">float,</span> <span class="pre">hessian_type:</span> <span class="pre">Optional[pydrake.solvers.QuadraticConstraint.HessianType]</span> <span class="pre">=</span> <span class="pre">None)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Construct a quadratic constraint.</p>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">DerivedQ</span></code>:</dt><dd><p>The type for Q.</p>
</dd>
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">Derivedb</span></code>:</dt><dd><p>The type for b.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Q0</span></code>:</dt><dd><p>The square matrix. Notice that Q₀ does not have to be symmetric.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>:</dt><dd><p>The linear coefficient.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lb</span></code>:</dt><dd><p>The lower bound.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">ub</span></code>:</dt><dd><p>The upper bound.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">hessian_type</span></code>:</dt><dd><p>(optional) Indicates the type of Hessian matrix Q0. If
hessian_type is not std::nullopt, then the user guarantees the
type of Q0. If hessian_type=std::nullopt, then QuadraticConstraint
will check the type of Q0. To speed up the constructor, set
hessian_type != std::nullopt if you can. If this type is set
incorrectly, then the downstream code (for example the solver)
will malfunction.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if Q0 isn't a square matrix</strong><strong>, or </strong><strong>b.rows</strong><strong>(</strong><strong>) </strong><strong>!=</strong> – </p></li>
<li><p><strong>Q0.rows</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuadraticConstraint.b(self:</span> <span class="pre">pydrake.solvers.QuadraticConstraint)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuadraticConstraint.hessian_type(self:</span> <span class="pre">pydrake.solvers.QuadraticConstraint)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.QuadraticConstraint.HessianType</span></span></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuadraticConstraint.HessianType</span></span></dt>
<dd><p>Whether the Hessian matrix is positive semidefinite, negative
semidefinite, indefinite or a zero-matrix.</p>
<p>Members:</p>
<blockquote>
<div><p>kPositiveSemidefinite :</p>
<p>kNegativeSemidefinite :</p>
<p>kIndefinite :</p>
<p>kZero :</p>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuadraticConstraint.HessianType.__init__(self:</span> <span class="pre">pydrake.solvers.QuadraticConstraint.HessianType,</span> <span class="pre">value:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuadraticConstraint.HessianType.kIndefinite</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuadraticConstraint.HessianType.kNegativeSemidefinite</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuadraticConstraint.HessianType.kPositiveSemidefinite</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuadraticConstraint.HessianType.kZero</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuadraticConstraint.HessianType.name</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuadraticConstraint.HessianType.value</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuadraticConstraint.is_convex(self:</span> <span class="pre">pydrake.solvers.QuadraticConstraint)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns if this quadratic constraint is convex.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuadraticConstraint.Q(self:</span> <span class="pre">pydrake.solvers.QuadraticConstraint)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>The symmetric matrix Q, being the Hessian of this constraint.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuadraticConstraint.UpdateCoefficients(self:</span> <span class="pre">pydrake.solvers.QuadraticConstraint,</span> <span class="pre">new_Q:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous],</span> <span class="pre">new_b:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">hessian_type:</span> <span class="pre">Optional[pydrake.solvers.QuadraticConstraint.HessianType]</span> <span class="pre">=</span> <span class="pre">None)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Updates the quadratic and linear term of the constraint. The new
matrices need to have the same dimension as before.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_Q</span></code>:</dt><dd><p>new quadratic term</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_b</span></code>:</dt><dd><p>new linear term</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">hessian_type</span></code>:</dt><dd><p>(optional) Indicates the type of Hessian matrix Q0. If
hessian_type is not std::nullopt, then the user guarantees the
type of Q0. If hessian_type=std::nullopt, then QuadraticConstraint
will check the type of Q0. To speed up the constructor, set
hessian_type != std::nullopt if you can.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuadraticCost</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Cost</span></code></p>
<p>Implements a cost of the form</p>
<div class="math notranslate nohighlight">
\[.5 x'Qx + b'x + c\]</div>
<p>.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuadraticCost.__init__(self:</span> <span class="pre">pydrake.solvers.QuadraticCost,</span> <span class="pre">Q:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]],</span> <span class="pre">b:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">c:</span> <span class="pre">float,</span> <span class="pre">is_convex:</span> <span class="pre">Optional[bool]</span> <span class="pre">=</span> <span class="pre">None)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a cost of the form</p>
<div class="math notranslate nohighlight">
\[.5 x'Qx + b'x + c\]</div>
<p>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Q</span></code>:</dt><dd><p>Quadratic term.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>:</dt><dd><p>Linear term.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">c</span></code>:</dt><dd><p>(optional) Constant term.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">is_hessian_psd</span></code>:</dt><dd><p>(optional) Indicates if the Hessian matrix Q is positive
semidefinite (psd) or not. If set to true, then the user
guarantees that Q is psd; if set to false, then the user
guarantees that Q is not psd. If set to std::nullopt, then the
constructor will check if Q is psd or not. The default is
std::nullopt. To speed up the constructor, set is_hessian_psd to
either true or false.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuadraticCost.b(self:</span> <span class="pre">pydrake.solvers.QuadraticCost)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuadraticCost.c(self:</span> <span class="pre">pydrake.solvers.QuadraticCost)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuadraticCost.is_convex(self:</span> <span class="pre">pydrake.solvers.QuadraticCost)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true if this cost is convex. A quadratic cost if convex if and
only if its Hessian matrix Q is positive semidefinite.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuadraticCost.Q(self:</span> <span class="pre">pydrake.solvers.QuadraticCost)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd><p>Returns the symmetric matrix Q, as the Hessian of the cost.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuadraticCost.update_constant_term(self:</span> <span class="pre">pydrake.solvers.QuadraticCost,</span> <span class="pre">new_c:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Updates the constant term to <code class="docutils literal notranslate"><span class="pre">new_c</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuadraticCost.update_linear_coefficient_entry(self:</span> <span class="pre">pydrake.solvers.QuadraticCost,</span> <span class="pre">i:</span> <span class="pre">int,</span> <span class="pre">val:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Updates b(i)=val.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuadraticCost.UpdateCoefficients(self:</span> <span class="pre">pydrake.solvers.QuadraticCost,</span> <span class="pre">new_Q:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]],</span> <span class="pre">new_b:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">new_c:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">is_convex:</span> <span class="pre">Optional[bool]</span> <span class="pre">=</span> <span class="pre">None)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Updates the quadratic and linear term of the constraint. The new
matrices need to have the same dimension as before.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_Q</span></code>:</dt><dd><p>New quadratic term.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_b</span></code>:</dt><dd><p>New linear term.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_c</span></code>:</dt><dd><p>(optional) New constant term.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">is_hessian_psd</span></code>:</dt><dd><p>(optional) Indicates if the Hessian matrix Q is positive
semidefinite (psd) or not. If set to true, then the user
guarantees that Q is psd; if set to false, then the user
guarantees that Q is not psd. If set to std::nullopt, then this
function will check if Q is psd or not. The default is
std::nullopt. To speed up the computation, set is_hessian_psd to
either true or false.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuadraticCost.UpdateHessianEntry(self:</span> <span class="pre">pydrake.solvers.QuadraticCost,</span> <span class="pre">i:</span> <span class="pre">int,</span> <span class="pre">j:</span> <span class="pre">int,</span> <span class="pre">val:</span> <span class="pre">float,</span> <span class="pre">is_hessian_psd:</span> <span class="pre">Optional[bool]</span> <span class="pre">=</span> <span class="pre">None)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Updates both Q(i, j) and Q(j, i) to val</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">is_hessian_psd</span></code>:</dt><dd><p>If this is <code class="docutils literal notranslate"><span class="pre">nullopt</span></code>, the new Hessian is checked (possibly
expensively) for PSD-ness. If this is set true/false, the cost’s
convexity is updated to that value without checking (it is the
user’s responsibility to make sure the flag is set correctly).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you have multiple entries in the Hessian matrix to update, and
you don’t specify is_hessian_psd, then it is much faster to call
UpdateCoefficients(new_A, new_b) where new_A contains all the
updated entries.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RemoveFreeVariableMethod</span></span></dt>
<dd><p>SDPA format doesn’t accept free variables, namely the problem it
solves is in this form P1</p>
<p>max tr(C * X) s.t tr(Aᵢ*X) = aᵢ X ≽ 0.</p>
<p>Notice that the decision variable X has to be in the proper cone X ≽
0, and it doesn’t accept free variable (without the conic constraint).
On the other hand, most real-world applications require free
variables, namely problems in this form P2</p>
<p>max tr(C * X) + dᵀs s.t tr(Aᵢ*X) + bᵢᵀs = aᵢ X ≽ 0 s is free.</p>
<p>In order to remove the free variables, we consider three approaches.
1. Replace a free variable s with two variables s = p - q, p ≥ 0, q ≥
0. 2. First write the dual of the problem P2 as D2</p>
<p>min aᵀy s.t ∑ᵢ yᵢAᵢ - C = Z Z ≽ 0 Bᵀ * y = d,</p>
<p>where bᵢᵀ is the i’th row of B. The last constraint Bᵀ * y = d means y
= ŷ + Nt, where Bᵀ * ŷ = d, and N is the null space of Bᵀ. Hence, D2
is equivalent to the following problem, D3</p>
<p>min aᵀNt + aᵀŷ s.t ∑ᵢ tᵢFᵢ - (C -∑ᵢ ŷᵢAᵢ) = Z Z ≽ 0,</p>
<p>where Fᵢ = ∑ⱼ NⱼᵢAⱼ. D3 is the dual of the following primal problem P3
without free variables</p>
<p>max tr((C-∑ᵢ ŷᵢAᵢ)*X̂) + aᵀŷ s.t tr(FᵢX̂) = (Nᵀa)(i) X̂ ≽ 0.</p>
<p>Then (X, s) = (X̂, B⁻¹(a - tr(Aᵢ X̂))) is the solution to the original
problem P2. 3. Add a slack variable t, with the Lorentz cone
constraint t ≥ sqrt(sᵀs).</p>
<p>Members:</p>
<blockquote>
<div><p>kNullspace : Approach 2, reformulate the dual problem by considering the nullspace</p>
</div></blockquote>
<p>of the linear constraint in the dual.</p>
<blockquote>
<div><p>kTwoSlackVariables : Approach 1, replace a free variable s as s = y⁺ - y⁻, y⁺ ≥ 0, y⁻ ≥ 0.</p>
<p>kLorentzConeSlack : Approach 3, add a slack variable t with the lorentz cone constraint t</p>
</div></blockquote>
<p>≥ sqrt(sᵀs).</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RemoveFreeVariableMethod.__init__(self:</span> <span class="pre">pydrake.solvers.RemoveFreeVariableMethod,</span> <span class="pre">value:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RemoveFreeVariableMethod.kLorentzConeSlack</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RemoveFreeVariableMethod.kNullspace</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RemoveFreeVariableMethod.kTwoSlackVariables</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RemoveFreeVariableMethod.name</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RemoveFreeVariableMethod.value</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotatedLorentzConeConstraint</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Constraint</span></code></p>
<p>Constraining that the linear expression <span class="math notranslate nohighlight">\(z=Ax+b\)</span> lies within
rotated Lorentz cone. A vector z ∈ ℝ ⁿ lies within rotated Lorentz
cone, if</p>
<div class="math notranslate nohighlight">
\[z_0 \ge 0\\]</div>
<p>z_1 ge 0z_0  z_1 ge z_2^2 + z_3^2 + … + z_{n-1}^2</p>
<p>where A ∈ ℝ ⁿˣᵐ, b ∈ ℝ ⁿ are given matrices.</p>
<p>For more information and visualization, please refer to
<a class="reference external" href="https://docs.mosek.com/modeling-cookbook/cqo.html">https://docs.mosek.com/modeling-cookbook/cqo.html</a> (Fig 3.1)</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotatedLorentzConeConstraint.__init__(self:</span> <span class="pre">pydrake.solvers.RotatedLorentzConeConstraint,</span> <span class="pre">A:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]],</span> <span class="pre">b:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if A.rows</strong><strong>(</strong><strong>) </strong><strong>&lt; 3.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotatedLorentzConeConstraint.A(self:</span> <span class="pre">pydrake.solvers.RotatedLorentzConeConstraint)</span> <span class="pre">-&gt;</span> <span class="pre">scipy.sparse.csc_matrix[numpy.float64]</span></span></dt>
<dd><p>Getter for A.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotatedLorentzConeConstraint.b(self:</span> <span class="pre">pydrake.solvers.RotatedLorentzConeConstraint)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Getter for b.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotatedLorentzConeConstraint.UpdateCoefficients(self:</span> <span class="pre">pydrake.solvers.RotatedLorentzConeConstraint,</span> <span class="pre">new_A:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous],</span> <span class="pre">new_b:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Updates the coefficients, the updated constraint is z=new_A * x +
new_b in the rotated Lorentz cone.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the new_A.cols</strong><strong>(</strong><strong>) </strong><strong>!= A.cols</strong><strong>(</strong><strong>)</strong><strong>, </strong><strong>namely the variable</strong> – </p></li>
<li><p><strong>size should not change.</strong> – </p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>new_A.rows() &gt;= 3 and new_A.rows() == new_b.rows().</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScsSolver</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.SolverInterface</span></code></p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScsSolver.__init__(self:</span> <span class="pre">pydrake.solvers.ScsSolver)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScsSolver.id()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.SolverId</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScsSolverDetails</span></span></dt>
<dd><p>The SCS solver details after calling Solve() function. The user can
call MathematicalProgramResult::get_solver_details&lt;ScsSolver&gt;() to
obtain the details.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScsSolverDetails.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScsSolverDetails.dual_objective</span></span></dt>
<dd><p>Dual objective value at termination. Equal to SCS_INFO.dobj</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScsSolverDetails.duality_gap</span></span></dt>
<dd><p>duality gap. Equal to SCS_INFO.gap.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScsSolverDetails.iter</span></span></dt>
<dd><p>These are the information returned by SCS at termination, please refer
to “SCS_INFO” struct in
<a class="reference external" href="https://github.com/cvxgrp/scs/blob/master/include/scs.h">https://github.com/cvxgrp/scs/blob/master/include/scs.h</a> Number of
iterations taken at termination. Equal to SCS_INFO.iter</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScsSolverDetails.primal_objective</span></span></dt>
<dd><p>Primal objective value at termination. Equal to SCS_INFO.pobj</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScsSolverDetails.primal_residue</span></span></dt>
<dd><p>Primal equality residue. Equal to SCS_INFO.res_pri</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScsSolverDetails.residue_infeasibility</span></span></dt>
<dd><p>infeasibility certificate residue. Equal to SCS_INFO.res_infeas</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScsSolverDetails.residue_unbounded_a</span></span></dt>
<dd><p>unbounded certificate residue. Equal to SCS_INFO.res_unbdd_a</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScsSolverDetails.residue_unbounded_p</span></span></dt>
<dd><p>unbounded certificate residue. Equal to SCS_INFO.res_unbdd_p</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScsSolverDetails.s</span></span></dt>
<dd><p>The primal equality constraint slack, namely Ax + s = b where x is the
primal variable.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScsSolverDetails.scs_setup_time</span></span></dt>
<dd><p>Time taken for SCS to setup in milliseconds. Equal to
SCS_INFO.setup_time.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScsSolverDetails.scs_solve_time</span></span></dt>
<dd><p>Time taken for SCS to solve in millisecond. Equal to
SCS_INFO.solve_time.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScsSolverDetails.scs_status</span></span></dt>
<dd><p>The status of the solver at termination. Please refer to
<a class="reference external" href="https://github.com/cvxgrp/scs/blob/master/include/glbopts.h">https://github.com/cvxgrp/scs/blob/master/include/glbopts.h</a> Note that
the SCS code on github master might be slightly more up-to-date than
the version used in Drake.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScsSolverDetails.y</span></span></dt>
<dd><p>The dual variable values at termination.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SemidefiniteRelaxationOptions</span></span></dt>
<dd><p>Configuration options for the MakeSemidefiniteRelaxation. Throughout
these options, we refer to the variables of the original optimization
program as y, and the semidefinite variable of the associate
relaxation as X.</p>
<p>X has the structure X = [Y, y] [yᵀ, one]</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SemidefiniteRelaxationOptions.__init__(self:</span> <span class="pre">pydrake.solvers.SemidefiniteRelaxationOptions,</span> <span class="pre">**kwargs)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SemidefiniteRelaxationOptions.add_implied_linear_constraints</span></span></dt>
<dd><p>Given a program with the linear equality constraints Ay = b, sets
whether to add the implied linear constraints [A, -b]X = 0 to the
semidefinite relaxation.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SemidefiniteRelaxationOptions.add_implied_linear_equality_constraints</span></span></dt>
<dd><p>Given a program with the linear constraints Ay ≤ b, sets whether to
add the implied linear constraints [A,-b]X[A,-b]ᵀ ≤ 0 to the
semidefinite relaxation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SemidefiniteRelaxationOptions.set_to_strongest(self:</span> <span class="pre">pydrake.solvers.SemidefiniteRelaxationOptions)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Configure the semidefinite relaxation options to provide the strongest
possible semidefinite relaxation that we currently support. This in
general will give the tightest convex relaxation we support, but the
longest solve times.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SemidefiniteRelaxationOptions.set_to_weakest(self:</span> <span class="pre">pydrake.solvers.SemidefiniteRelaxationOptions)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Configure the semidefinite relaxation options to provide the weakest
semidefinite relaxation that we currently support. This in general
will create the loosest convex relaxation we support, but the shortest
solve times. This is equivalent to the standard Shor Relaxation (see
Quadratic Optimization Problems by NZ Shor or Semidefinite Programming
by Vandenberghe and Boyd).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SnoptSolver</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.SolverInterface</span></code></p>
<p>An implementation of SolverInterface for the commercially-licensed
SNOPT solver (<a class="reference external" href="https://ccom.ucsd.edu/~optimizers/solvers/snopt/">https://ccom.ucsd.edu/~optimizers/solvers/snopt/</a>).</p>
<p>Builds of Drake from source do not compile SNOPT by default, so
therefore SolverInterface::available() will return false. You must
opt-in to build SNOPT per the documentation at
<a class="reference external" href="https://drake.mit.edu/bazel.html#snopt">https://drake.mit.edu/bazel.html#snopt</a>.</p>
<p><a class="reference external" href="https://drake.mit.edu/installation.html">Drake’s pre-compiled binary releases</a> do incorporate SNOPT, so
therefore SolverInterface::available() will return true. Thanks to
Philip E. Gill and Elizabeth Wong for their kind support.</p>
<p>There is no license configuration required to use SNOPT, but you may
set the environtment variable <code class="docutils literal notranslate"><span class="pre">DRAKE_SNOPT_SOLVER_ENABLED</span></code> to “0” to
force-disable SNOPT, in which case SolverInterface::enabled() will
return false.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SnoptSolver.__init__(self:</span> <span class="pre">pydrake.solvers.SnoptSolver)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SnoptSolver.id()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.SolverId</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SnoptSolverDetails</span></span></dt>
<dd><p>The SNOPT solver details after calling Solve() function. The user can
call MathematicalProgramResult::get_solver_details&lt;SnoptSolver&gt;() to
obtain the details.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SnoptSolverDetails.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SnoptSolverDetails.F</span></span></dt>
<dd><p>The final value of the vector of problem functions F(x).</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SnoptSolverDetails.Fmul</span></span></dt>
<dd><p>The final value of the dual variables (Lagrange multipliers) for the
general constraints F_lower &lt;= F(x) &lt;= F_upper.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SnoptSolverDetails.info</span></span></dt>
<dd><p>The snopt INFO field. Please refer to section 8.6 in “User’s Guide for
SNOPT Version 7: Software for Large-Scale Nonlinear Programming”
(<a class="reference external" href="https://web.stanford.edu/group/SOL/guides/sndoc7.pdf">https://web.stanford.edu/group/SOL/guides/sndoc7.pdf</a>) by Philip E.
Gill to interpret the INFO field.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SnoptSolverDetails.solve_time</span></span></dt>
<dd><p>The duration of the snopt solve in seconds.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SnoptSolverDetails.xmul</span></span></dt>
<dd><p>The final value of the dual variables for the bound constraint x_lower
&lt;= x &lt;= x_upper.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolutionResult</span></span></dt>
<dd><p>Members:</p>
<blockquote>
<div><p>kSolutionFound : Found the optimal solution.</p>
<p>kInvalidInput : Invalid input.</p>
<p>kInfeasibleConstraints : The primal is infeasible.</p>
<p>kUnbounded : The primal is unbounded.</p>
<p>kSolverSpecificError : Solver-specific error. (Try</p>
</div></blockquote>
<p>MathematicalProgramResult::get_solver_details() or enabling verbose
solver output.)</p>
<blockquote>
<div><p>kInfeasibleOrUnbounded : The primal is either infeasible or unbounded.</p>
<p>kIterationLimit : Reaches the iteration limits.</p>
<p>kDualInfeasible : Dual problem is infeasible. In this case we cannot infer the status of</p>
</div></blockquote>
<p>the primal problem.</p>
<blockquote>
<div><p>kSolutionResultNotSet : The initial (invalid) solution result. This value should be</p>
</div></blockquote>
<p>overwritten by the solver during Solve().</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolutionResult.__init__(self:</span> <span class="pre">pydrake.solvers.SolutionResult,</span> <span class="pre">value:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolutionResult.kDualInfeasible</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolutionResult.kInfeasibleConstraints</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolutionResult.kInfeasibleOrUnbounded</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolutionResult.kInvalidInput</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolutionResult.kIterationLimit</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolutionResult.kSolutionFound</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolutionResult.kSolutionResultNotSet</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolutionResult.kSolverSpecificError</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolutionResult.kUnbounded</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolutionResult.name</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolutionResult.value</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Solve(prog:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">initial_guess:</span> <span class="pre">Optional[numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]]</span> <span class="pre">=</span> <span class="pre">None,</span> <span class="pre">solver_options:</span> <span class="pre">Optional[pydrake.solvers.SolverOptions]</span> <span class="pre">=</span> <span class="pre">None)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.MathematicalProgramResult</span></span></dt>
<dd><p>Solves an optimization program, with optional initial guess and solver
options. This function first chooses the best solver depending on the
availability of the solver and the program formulation; it then
constructs that solver and call the Solve function of that solver. The
optimization result is stored in the return argument.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">prog</span></code>:</dt><dd><p>Contains the formulation of the program, and possibly solver
options.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">initial_guess</span></code>:</dt><dd><p>The initial guess for the decision variables.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">solver_options</span></code>:</dt><dd><p>The options in addition to those stored in <code class="docutils literal notranslate"><span class="pre">prog</span></code>. For each
option entry (like print out), there are 4 ways to set that
option, and the priority given to the solver options is as follows
(from lowest / least, to highest / most): 1. common option set on
the MathematicalProgram itself 2. common option passed as an
argument to Solve 3. solver-specific option set on the
MathematicalProgram itself 4. solver-specific option passed as an
argument to Solve</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>result The result of solving the program through the solver.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolveInParallel(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SolveInParallel(progs: list[pydrake.solvers.MathematicalProgram], initial_guesses: Optional[list[Optional[numpy.ndarray[numpy.float64[m, 1]]]]] = None, solver_options: Optional[list[Optional[pydrake.solvers.SolverOptions]]] = None, solver_ids: Optional[list[Optional[pydrake.solvers.SolverId]]] = None, parallelism: pydrake.common.Parallelism = Parallelism(num_threads=16), dynamic_schedule: bool = False) -&gt; list[pydrake.solvers.MathematicalProgramResult]</p></li>
</ol>
<p>Solves progs[i] into result[i], optionally using initial_guess[i] and
solver_options[i] if given, by invoking the solver at solver_ids[i] if
provided. If solver_ids[i] is nullopt then the best available solver
is selected for progs[i] depending on the availability of the solver
and the problem formulation. If solver_ids == nullptr then this is
done for every progs[i].</p>
<p>Uses at most parallelism cores, with static scheduling by default.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">dynamic_schedule</span></code>:</dt><dd><p>If dynamic_schedule is false then static scheduling is used and so
each core will solve approximately 1/parallelism of the programs.
This is most efficient when all the programs take approximately
the same amount of time to solve. If dynamic_schedule is true,
then dynamic scheduling is used and all the programs are queued
into a single pool and each core will take the next program off
the queue when it becomes available. This is best when each
program takes a dramatically different amount of time to solve.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When using a proprietary solver (e.g. Mosek) your organization may
have limited license seats. It is recommended that the number of
parallel solves does not exceed the total number of license seats.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Only programs which are thread safe are solved concurrently.
Programs that are not thread safe will be solved sequentially in a
thread safe manner.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if initial_guess and solver_options are provided and</strong> – </p></li>
<li><p><strong>not the same size as progs.</strong> – </p></li>
<li><p><strong>RuntimeError if any</strong><strong> of </strong><strong>the progs are nullptr.</strong> – </p></li>
<li><p><strong>RuntimeError if any</strong><strong> of </strong><strong>the programs cannot be solved.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>SolveInParallel(progs: list[pydrake.solvers.MathematicalProgram], initial_guesses: Optional[list[Optional[numpy.ndarray[numpy.float64[m, 1]]]]] = None, solver_options: pydrake.solvers.SolverOptions = None, solver_id: Optional[pydrake.solvers.SolverId] = None, parallelism: pydrake.common.Parallelism = Parallelism(num_threads=16), dynamic_schedule: bool = False) -&gt; list[pydrake.solvers.MathematicalProgramResult]</p></li>
</ol>
<p>Provides the same functionality as SolveInParallel, but allows for
specifying a single solver id and solver option that is used when
solving all programs.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the provided solver cannot solve all</strong><strong> of </strong><strong>progs.</strong> – </p></li>
<li><p><strong>RuntimeError if initial_guesses are provided and not the same size</strong> – </p></li>
<li><p><strong>as progs.</strong> – </p></li>
<li><p><strong>RuntimeError if any</strong><strong> of </strong><strong>the progs are nullptr.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolverId</span></span></dt>
<dd><p>Identifies a SolverInterface implementation.</p>
<p>A moved-from instance is guaranteed to be empty and will not compare
equal to any non-empty ID.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolverId.__init__(self:</span> <span class="pre">pydrake.solvers.SolverId,</span> <span class="pre">name:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a specific, known solver type. Internally, a hidden integer
is allocated and assigned to this instance; all instances that share
an integer (including copies of this instance) are considered equal.
The solver names are not enforced to be unique, though we recommend
that they remain so in practice.</p>
<p>For best performance, choose a name that is 15 characters or less, so
that it fits within the libstdc++ “small string” optimization (“SSO”).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolverId.name(self:</span> <span class="pre">pydrake.solvers.SolverId)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolverInterface</span></span></dt>
<dd><p>Interface used by implementations of individual solvers.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolverInterface.__init__(self:</span> <span class="pre">pydrake.solvers.SolverInterface)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolverInterface.AreProgramAttributesSatisfied(self:</span> <span class="pre">pydrake.solvers.SolverInterface,</span> <span class="pre">prog:</span> <span class="pre">pydrake.solvers.MathematicalProgram)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff the program’s attributes are compatible with this
solver’s capabilities.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolverInterface.available(self:</span> <span class="pre">pydrake.solvers.SolverInterface)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff support for this solver has been compiled into Drake.
When this method returns false, the Solve method will throw.</p>
<p>Most solver implementations will always return true, but certain
solvers may have been excluded at compile-time due to licensing
restrictions, or to narrow Drake’s dependency footprint. In Drake’s
default build, only commercially-licensed solvers might return false.</p>
<p>Contrast this with enabled(), which reflects whether a solver has been
configured for use at runtime (not compile-time).</p>
<p>For details on linking commercial solvers, refer to the solvers’ class
overview documentation, e.g., SnoptSolver, MosekSolver, GurobiSolver.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolverInterface.enabled(self:</span> <span class="pre">pydrake.solvers.SolverInterface)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff this solver is properly configured for use at
runtime. When this method returns false, the Solve method will throw.</p>
<p>Most solver implementation will always return true, but certain
solvers require additional configuration before they may be used,
e.g., setting an environment variable to specify a license file or
license server. In Drake’s default build, only commercially-licensed
solvers might return false.</p>
<p>Contrast this with available(), which reflects whether a solver has
been incorporated into Drake at compile-time (and has nothing to do
with the runtime configuration). A solver where available() returns
false may still return true for enabled() if it is properly
configured.</p>
<p>The mechanism to configure a particular solver implementation is
specific to the solver in question, but typically uses an environment
variable. For details on configuring commercial solvers, refer to the
solvers’ class overview documentation, e.g., SnoptSolver, MosekSolver,
GurobiSolver.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolverInterface.ExplainUnsatisfiedProgramAttributes(self:</span> <span class="pre">pydrake.solvers.SolverInterface,</span> <span class="pre">prog:</span> <span class="pre">pydrake.solvers.MathematicalProgram)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Describes the reasons (if any) why the program is incompatible with
this solver’s capabilities. If AreProgramAttributesSatisfied would
return true for the program, then this function returns the empty
string.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolverInterface.Solve(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>Solve(self: pydrake.solvers.SolverInterface, prog: pydrake.solvers.MathematicalProgram, initial_guess: Optional[numpy.ndarray[numpy.float64[m, 1]]], solver_options: Optional[pydrake.solvers.SolverOptions], result: pydrake.solvers.MathematicalProgramResult) -&gt; None</p></li>
</ol>
<p>Solves an optimization program with optional initial guess and solver
options. Note that these initial guess and solver options are not
written to <code class="docutils literal notranslate"><span class="pre">prog</span></code>. If the <code class="docutils literal notranslate"><span class="pre">prog</span></code> has set an option for a solver,
and <code class="docutils literal notranslate"><span class="pre">solver_options</span></code> contains a different value for the same option
on the same solver, then <code class="docutils literal notranslate"><span class="pre">solver_options</span></code> takes priority. Derived
implementations of this interface may elect to throw RuntimeError for
badly formed programs.</p>
<ol class="arabic simple" start="2">
<li><p>Solve(self: pydrake.solvers.SolverInterface, prog: pydrake.solvers.MathematicalProgram, initial_guess: Optional[numpy.ndarray[numpy.float64[m, 1]]] = None, solver_options: Optional[pydrake.solvers.SolverOptions] = None) -&gt; pydrake.solvers.MathematicalProgramResult</p></li>
</ol>
<p>Like SolverInterface::Solve(), but the result is a return value
instead of an output argument.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolverInterface.solver_id(self:</span> <span class="pre">pydrake.solvers.SolverInterface)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.SolverId</span></span></dt>
<dd><p>Returns the identifier of this solver.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolverInterface.solver_type(self:</span> <span class="pre">pydrake.solvers.SolverInterface)</span> <span class="pre">-&gt;</span> <span class="pre">Optional[pydrake.solvers.SolverType]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolverInterface.SolverName(self:</span> <span class="pre">pydrake.solvers.SolverInterface)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolverOptions</span></span></dt>
<dd><p>Stores options for multiple solvers. This interface does not do any
verification of solver parameters. It does not even verify that the
specified solver exists. Use this only when you have particular
knowledge of what solver is being invoked, and exactly what tuning is
required.</p>
<p>Supported solver names/options:</p>
<p>“SNOPT” – Parameter names and values as specified in SNOPT User’s
Guide section 7.7 “Description of the optional parameters”, used as
described in section 7.5 for snSet(). The SNOPT user guide can be
obtained from <a class="reference external" href="https://web.stanford.edu/group/SOL/guides/sndoc7.pdf">https://web.stanford.edu/group/SOL/guides/sndoc7.pdf</a></p>
<p>“IPOPT” – Parameter names and values as specified in IPOPT users
guide section “Options Reference”
<a class="reference external" href="https://coin-or.github.io/Ipopt/OPTIONS.html">https://coin-or.github.io/Ipopt/OPTIONS.html</a></p>
<p>“NLOPT” – Parameter names and values are specified in
<a class="reference external" href="https://nlopt.readthedocs.io/en/latest/NLopt_C-plus-plus_Reference/">https://nlopt.readthedocs.io/en/latest/NLopt_C-plus-plus_Reference/</a>
(in the Stopping criteria section). Besides these parameters, the user
can specify “algorithm” using a string of the algorithm name. The
complete set of algorithms is listed in “nlopt_algorithm_to_string()”
function in github.com/stevengj/nlopt/blob/master/src/api/general.c.
If you would like to use certain algorithm, for example
NLOPT_LD_SLSQP, call <code class="docutils literal notranslate"><span class="pre">SetOption(NloptSolver::id(),</span>
<span class="pre">NloptSolver::AlgorithmName(),</span> <span class="pre">&quot;LD_SLSQP&quot;);</span></code></p>
<p>“GUROBI” – Parameter name and values as specified in Gurobi Reference
Manual, section 10.2 “Parameter Descriptions”
<a class="reference external" href="https://www.gurobi.com/documentation/10.0/refman/parameters.html">https://www.gurobi.com/documentation/10.0/refman/parameters.html</a></p>
<p>“SCS” – Parameter name and values as specified in the struct
SCS_SETTINGS in SCS header file
<a class="reference external" href="https://github.com/cvxgrp/scs/blob/master/include/scs.h">https://github.com/cvxgrp/scs/blob/master/include/scs.h</a> Note that the
SCS code on github master might be more up-to-date than the version
used in Drake.</p>
<p>“MOSEK<a href="/tm.html">™</a>” – Parameter name and values as specified in Mosek Reference
<a class="reference external" href="https://docs.mosek.com/9.3/capi/parameters.html">https://docs.mosek.com/9.3/capi/parameters.html</a></p>
<p>“OSQP” – Parameter name and values as specified in OSQP Reference
<a class="reference external" href="https://osqp.org/docs/interfaces/solver_settings.html#solver-settings">https://osqp.org/docs/interfaces/solver_settings.html#solver-settings</a></p>
<p>“Clarabel” – Parameter name and values as specified in Clarabel
<a class="reference external" href="https://oxfordcontrol.github.io/ClarabelDocs/stable/api_settings/">https://oxfordcontrol.github.io/ClarabelDocs/stable/api_settings/</a> Note
that <code class="docutils literal notranslate"><span class="pre">direct_solve_method</span></code> is not supported in Drake yet. Clarabel’s
boolean options should be passed as integers (0 or 1).</p>
<p>“CSDP” – Parameter name and values as specified at
<a class="reference external" href="https://manpages.ubuntu.com/manpages/focal/en/man1/csdp-randgraph.1.html">https://manpages.ubuntu.com/manpages/focal/en/man1/csdp-randgraph.1.html</a></p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolverOptions.__init__(self:</span> <span class="pre">pydrake.solvers.SolverOptions,</span> <span class="pre">*,</span> <span class="pre">options:</span> <span class="pre">dict[str,</span> <span class="pre">dict[str,</span> <span class="pre">Union[float,</span> <span class="pre">int,</span> <span class="pre">str]]]</span> <span class="pre">=</span> <span class="pre">{})</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolverOptions.common_solver_options(self:</span> <span class="pre">pydrake.solvers.SolverOptions)</span> <span class="pre">-&gt;</span> <span class="pre">dict[pydrake.solvers.CommonSolverOption,</span> <span class="pre">Union[float,</span> <span class="pre">int,</span> <span class="pre">str]]</span></span></dt>
<dd><p>(Deprecated.)</p>
<dl class="simple">
<dt>Deprecated:</dt><dd><p>Access the ‘options’ directly, instead. This will be removed from
Drake on or after 2025-09-01.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolverOptions.get_max_threads(self:</span> <span class="pre">pydrake.solvers.SolverOptions)</span> <span class="pre">-&gt;</span> <span class="pre">Optional[int]</span></span></dt>
<dd><p>(Deprecated.)</p>
<dl class="simple">
<dt>Deprecated:</dt><dd><p>Access the ‘options’ directly, instead. This will be removed from
Drake on or after 2025-09-01.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolverOptions.get_print_file_name(self:</span> <span class="pre">pydrake.solvers.SolverOptions)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>(Deprecated.)</p>
<dl class="simple">
<dt>Deprecated:</dt><dd><p>Access the ‘options’ directly, instead. This will be removed from
Drake on or after 2025-09-01.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolverOptions.get_print_to_console(self:</span> <span class="pre">pydrake.solvers.SolverOptions)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>(Deprecated.)</p>
<dl class="simple">
<dt>Deprecated:</dt><dd><p>Access the ‘options’ directly, instead. This will be removed from
Drake on or after 2025-09-01.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolverOptions.get_standalone_reproduction_file_name(self:</span> <span class="pre">pydrake.solvers.SolverOptions)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolverOptions.GetOptions(self:</span> <span class="pre">pydrake.solvers.SolverOptions,</span> <span class="pre">solver_id:</span> <span class="pre">pydrake.solvers.SolverId)</span> <span class="pre">-&gt;</span> <span class="pre">dict</span></span></dt>
<dd><p>(Deprecated.)</p>
<dl class="simple">
<dt>Deprecated:</dt><dd><p>Access the ‘options’ directly, instead. This will be removed from
Drake on or after 2025-09-01.</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolverOptions.options</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolverOptions.SetOption(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>SetOption(self: pydrake.solvers.SolverOptions, solver_id: pydrake.solvers.SolverId, key: str, value: Union[float, int, str]) -&gt; None</p></li>
</ol>
<p>Sets a solver option for a specific solver. If the solver doesn’t
support the option, it will throw an exception during the Solve (not
when setting the option here).</p>
<ol class="arabic simple" start="2">
<li><p>SetOption(self: pydrake.solvers.SolverOptions, key: pydrake.solvers.CommonSolverOption, value: Union[float, int, str]) -&gt; None</p></li>
</ol>
<p>Sets a common option for all solvers supporting that option (for
example, printing the progress in each iteration). If the solver
doesn’t support the option, the option is ignored.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolverType</span></span></dt>
<dd><p>This type only exists for backwards compatibility, and should not be
used in new code.</p>
<p>Members:</p>
<blockquote>
<div><p>kClp :</p>
<p>kCsdp :</p>
<p>kEqualityConstrainedQP :</p>
<p>kGurobi :</p>
<p>kIpopt :</p>
<p>kLinearSystem :</p>
<p>kMobyLCP :</p>
<p>kMosek :</p>
<p>kNlopt :</p>
<p>kOsqp :</p>
<p>kScs :</p>
<p>kSnopt :</p>
<p>kUnrevisedLemke :</p>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolverType.__init__(self:</span> <span class="pre">pydrake.solvers.SolverType,</span> <span class="pre">value:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolverType.kClp</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolverType.kCsdp</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolverType.kEqualityConstrainedQP</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolverType.kGurobi</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolverType.kIpopt</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolverType.kLinearSystem</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolverType.kMobyLCP</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolverType.kMosek</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolverType.kNlopt</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolverType.kOsqp</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolverType.kScs</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolverType.kSnopt</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolverType.kUnrevisedLemke</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolverType.name</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SolverType.value</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnrevisedLemkeSolver</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.SolverInterface</span></code></p>
<p>A class for the Unrevised Implementation of Lemke Algorithm’s for
solving Linear Complementarity Problems (LCPs). See MobyLcpSolver for
a description of LCPs. This code makes extensive use of the following
document: [Dai 2018] Dai, H. and Drumwright, E. Computing the
Principal Pivoting Transform for Solving Linear Complementarity
Problems with Lemke’s Algorithm. (2018, located in
doc/pivot_column.pdf).</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnrevisedLemkeSolver.__init__(self:</span> <span class="pre">pydrake.solvers.UnrevisedLemkeSolver)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnrevisedLemkeSolver.id()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.SolverId</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VisualizationCallback</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.EvaluatorBase</span></code></p>
<p>Defines a simple evaluator with no outputs that takes a callback
function pointer. This is intended for debugging / visualization of
intermediate results during an optimization (for solvers that support
it).</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">VisualizationCallback.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="pydrake.polynomial.html" class="btn btn-neutral float-left" title="pydrake.polynomial" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="pydrake.symbolic.html" class="btn btn-neutral float-right" title="pydrake.symbolic" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p></p>
  </div>

  
</footer>
<script>
  /* Enables clicking for the mobile "hamburger" (three-line) menu item. */
  const siteHeader = document.querySelector('.site-header')
  const mobileButton = document.querySelector('.menu-mobile-toggle')
  const body = document.querySelector('body')

  mobileButton.addEventListener('click', function(event) {
    siteHeader.classList.toggle('open');
    body.classList.toggle('overflow-hidden');
  })
</script>
<footer class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg">
    </a>
    <div class="footer-menu">
      <ul>
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"></a>
        </li>
      </ul>
    </div>
  </div>


</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>