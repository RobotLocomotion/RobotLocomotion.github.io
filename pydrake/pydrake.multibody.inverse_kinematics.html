<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pydrake.multibody.inverse_kinematics &mdash; pydrake  documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=86f27845" />
      <link rel="stylesheet" type="text/css" href="_static/css/custom.css?v=6b576c25" />

  
  
        <script src="_static/jquery.js?v=8dae8fb0"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=7f41d439"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="pydrake.multibody.math" href="pydrake.multibody.math.html" />
    <link rel="prev" title="pydrake.multibody.fix_inertia" href="pydrake.multibody.fix_inertia.html" /> 
</head>

<body class="wy-body-for-nav">
<header class="site-header">
  <div class="site-header-inner contain">
    <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
    <div class="menu-mobile-toggle">
      <span></span>
    </div>
    <nav class="site-menu">
      <ul>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/">Home</a>
        </li>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/installation.html">Installation</a>
        </li>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/gallery.html">Gallery</a>
        </li>
        <li class="site-menu-item site-menu-item-main">API Documentation
          <div class="sub">
            <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a> <a class="site-menu-item" href="/pydrake/index.html">Python</a>
          </div>
        </li>
        <li class="site-menu-item site-menu-item-main">Resources
          <div class="sub">
            <a class="site-menu-item" href="/getting_help.html">Getting Help</a> <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/%2Findex.ipynb">Tutorials</a> <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a> <a class="site-menu-item" href="/developers.html">For Developers</a> <a class="site-menu-item" href="/credits.html">Credits</a>
          </div>
        </li>
        <li class="github-link">
          <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
        </li>
      </ul>
    </nav>
  </div>
</header>

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            pydrake
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search pydrake only…" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
    <input type="text" name="q" placeholder="Search all of Drake…" />
    <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu" />
  </form>
</div>

        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="pydrake.all.html">pydrake.all</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.autodiffutils.html">pydrake.autodiffutils</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.common.html">pydrake.common</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.examples.html">pydrake.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.forwarddiff.html">pydrake.forwarddiff</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.geometry.html">pydrake.geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.gym.html">pydrake.gym</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.lcm.html">pydrake.lcm</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.manipulation.html">pydrake.manipulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.math.html">pydrake.math</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="pydrake.multibody.html">pydrake.multibody</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.all.html">pydrake.multibody.all</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.benchmarks.html">pydrake.multibody.benchmarks</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.fem.html">pydrake.multibody.fem</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.fix_inertia.html">pydrake.multibody.fix_inertia</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">pydrake.multibody.inverse_kinematics</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.math.html">pydrake.multibody.math</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.mesh_to_model.html">pydrake.multibody.mesh_to_model</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.meshcat.html">pydrake.multibody.meshcat</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.optimization.html">pydrake.multibody.optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.parsing.html">pydrake.multibody.parsing</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.plant.html">pydrake.multibody.plant</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.rational.html">pydrake.multibody.rational</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.tree.html">pydrake.multibody.tree</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.perception.html">pydrake.perception</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.planning.html">pydrake.planning</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.polynomial.html">pydrake.polynomial</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.html">pydrake.solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.symbolic.html">pydrake.symbolic</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.systems.html">pydrake.systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.trajectories.html">pydrake.trajectories</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.tutorials.html">pydrake.tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.visualization.html">pydrake.visualization</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pydrake</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="pydrake.multibody.html">pydrake.multibody</a></li>
      <li class="breadcrumb-item active">pydrake.multibody.inverse_kinematics</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-pydrake.multibody.inverse_kinematics">
<span id="pydrake-multibody-inverse-kinematics"></span><h1>pydrake.multibody.inverse_kinematics<a class="headerlink" href="#module-pydrake.multibody.inverse_kinematics" title="Link to this heading"></a></h1>
<p>InverseKinematics module</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AddMultibodyPlantConstraints(plant:</span> <span class="pre">object,</span> <span class="pre">q:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]],</span> <span class="pre">prog:</span> <span class="pre">pydrake.solvers.MathematicalProgram,</span> <span class="pre">plant_context:</span> <span class="pre">pydrake.systems.framework.Context</span> <span class="pre">=</span> <span class="pre">None)</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.solvers.Binding[Constraint]]</span></span></dt>
<dd><p>For all kinematic constraints associated with <code class="docutils literal notranslate"><span class="pre">plant</span></code> adds a
corresponding solver::Constraint to <code class="docutils literal notranslate"><span class="pre">prog</span></code>, using decision variables
<code class="docutils literal notranslate"><span class="pre">q</span></code> to represent the generalized positions of the plant.</p>
<p>Adds joint limits constraints, unit quaternion constraints, and
constraints for any locked joints (via Joint::Lock()). Note that you
must pass a valid <code class="docutils literal notranslate"><span class="pre">plant_context</span></code> to use joint locking.</p>
<p>Adds constraints for coupler, distance, ball, and weld constraints.
The distance constraint is implemented here as a hard kinematic
constraint (i.e., d(q) == d₀), instead of a soft “spring” force.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>AddUnitQuaternionConstraintOnPlant() for the unit quaternion
constraints.</p>
</div>
<dl class="simple">
<dt>Precondition:</dt><dd><p>plant.is_finalized() == true.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if plant has constraints registered that are not</strong> – </p></li>
<li><p><strong>yet supported by this method.</strong> – </p></li>
<li><p><strong>RuntimeError if prog is nullptr.</strong> – </p></li>
<li><p><strong>RuntimeError if plant_context is nullptr and one</strong><strong> of </strong><strong>the</strong> – </p></li>
<li><p><strong>MultibodyPlant constraints requires it.</strong><strong> (</strong><strong>unit quaternion</strong> – </p></li>
<li><p><strong>constraints and coupler constraints do not</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AddUnitQuaternionConstraintOnPlant(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddUnitQuaternionConstraintOnPlant(plant: pydrake.multibody.plant.MultibodyPlant, q_vars: numpy.ndarray[object[m, 1]], prog: pydrake.solvers.MathematicalProgram) -&gt; list[pydrake.solvers.Binding[Constraint]]</p></li>
</ol>
<p>Add unit length constraints to all the variables representing
quaternion in <code class="docutils literal notranslate"><span class="pre">q_vars</span></code>. Namely the quaternions for floating base
joints in <code class="docutils literal notranslate"><span class="pre">plant</span></code> will be enforced to have a unit length, and all
quaternion variables will be bounded to be within [-1, 1].</p>
<p>Additionally, if the initial guess for the quaternion variables has
not been set (it is nan), then this method calls
MathematicalProgram::SetInitialGuess() with [1, 0, 0, 0], to help the
solver avoid singularities.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant</span></code>:</dt><dd><p>The plant on which we impose the unit quaternion constraints.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">q_vars</span></code>:</dt><dd><p>The decision variables for the generalized position of the plant.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">prog</span></code>:</dt><dd><p>The unit quaternion constraints are added to this prog.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>AddUnitQuaternionConstraintOnPlant(plant: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], q_vars: numpy.ndarray[object[m, 1]], prog: pydrake.solvers.MathematicalProgram) -&gt; list[pydrake.solvers.Binding[Constraint]]</p></li>
</ol>
<p>Add unit length constraints to all the variables representing
quaternion in <code class="docutils literal notranslate"><span class="pre">q_vars</span></code>. Namely the quaternions for floating base
joints in <code class="docutils literal notranslate"><span class="pre">plant</span></code> will be enforced to have a unit length, and all
quaternion variables will be bounded to be within [-1, 1].</p>
<p>Additionally, if the initial guess for the quaternion variables has
not been set (it is nan), then this method calls
MathematicalProgram::SetInitialGuess() with [1, 0, 0, 0], to help the
solver avoid singularities.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant</span></code>:</dt><dd><p>The plant on which we impose the unit quaternion constraints.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">q_vars</span></code>:</dt><dd><p>The decision variables for the generalized position of the plant.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">prog</span></code>:</dt><dd><p>The unit quaternion constraints are added to this prog.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AngleBetweenVectorsConstraint</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Constraint</span></code></p>
<p>Constrains that the angle between a vector <code class="docutils literal notranslate"><span class="pre">a</span></code> and another vector
<code class="docutils literal notranslate"><span class="pre">b</span></code> is between [θ_lower, θ_upper]. <code class="docutils literal notranslate"><span class="pre">a</span></code> is fixed to a frame A,
while <code class="docutils literal notranslate"><span class="pre">b</span></code> is fixed to a frame B. Mathematically, if we denote
a_unit_A as <code class="docutils literal notranslate"><span class="pre">a</span></code> expressed in frame A after normalization (a_unit_A
has unit length), and b_unit_B as <code class="docutils literal notranslate"><span class="pre">b</span></code> expressed in frame B after
normalization, the constraint is cos(θ_upper) ≤ a_unit_Aᵀ * R_AB *
b_unit_B ≤ cos(θ_lower)</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AngleBetweenVectorsConstraint.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.inverse_kinematics.AngleBetweenVectorsConstraint, plant: pydrake.multibody.plant.MultibodyPlant, frameA: pydrake.multibody.tree.Frame, a_A: numpy.ndarray[numpy.float64[3, 1]], frameB: pydrake.multibody.tree.Frame, b_B: numpy.ndarray[numpy.float64[3, 1]], angle_lower: float, angle_upper: float, plant_context: pydrake.systems.framework.Context) -&gt; None</p></li>
</ol>
<p>Constructs an AngleBetweenVectorsConstraint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant</span></code>:</dt><dd><p>The MultibodyPlant on which the constraint is imposed. <code class="docutils literal notranslate"><span class="pre">plant</span></code>
should be alive during the lifetime of this constraint.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameA</span></code>:</dt><dd><p>The Frame object for frame A.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">a_A</span></code>:</dt><dd><p>The vector <code class="docutils literal notranslate"><span class="pre">a</span></code> fixed to frame A, expressed in frame A.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameB</span></code>:</dt><dd><p>The Frame object for frame B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b_B</span></code>:</dt><dd><p>The vector <code class="docutils literal notranslate"><span class="pre">b</span></code> fixed to frame B, expressed in frameB.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angle_lower</span></code>:</dt><dd><p>The lower bound on the angle between <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>. It is
denoted as θ_lower in the class documentation.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angle_upper</span></code>:</dt><dd><p>The upper bound on the angle between <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>. it is
denoted as θ_upper in the class documentation.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant_context</span></code>:</dt><dd><p>The Context that has been allocated for this <code class="docutils literal notranslate"><span class="pre">plant</span></code>. We will
update the context when evaluating the constraint.
<code class="docutils literal notranslate"><span class="pre">plant_context</span></code> should be alive during the lifetime of this
constraint.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">frameA</span></code> and <code class="docutils literal notranslate"><span class="pre">frameB</span></code> must belong to <code class="docutils literal notranslate"><span class="pre">plant</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if plant is nullptr.</strong> – </p></li>
<li><p><strong>RuntimeError if a_A is close to zero.</strong> – </p></li>
<li><p><strong>RuntimeError if b_B is close to zero.</strong> – </p></li>
<li><p><strong>RuntimeError if angle_lower is negative.</strong> – </p></li>
<li><p><strong>RuntimeError if angle_upper ∉</strong><strong> [</strong><strong>angle_lower</strong><strong>, </strong><strong>π</strong><strong>]</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if plant_context is nullptr.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.inverse_kinematics.AngleBetweenVectorsConstraint, plant: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], frameA: pydrake.multibody.tree.Frame_[AutoDiffXd], a_A: numpy.ndarray[numpy.float64[3, 1]], frameB: pydrake.multibody.tree.Frame_[AutoDiffXd], b_B: numpy.ndarray[numpy.float64[3, 1]], angle_lower: float, angle_upper: float, plant_context: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Overloaded constructor. Use MultibodyPlant&lt;AutoDiffXd&gt; instead of
MultibodyPlant&lt;double&gt;.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AngleBetweenVectorsCost</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Cost</span></code></p>
<p>Implements a cost of the form c*(1-cosθ), where θ is the angle between
two vectors <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>. <cite>c</cite> is a constant scalar.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">AngleBetweenVectorsCost.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.inverse_kinematics.AngleBetweenVectorsCost, plant: pydrake.multibody.plant.MultibodyPlant, frameA: pydrake.multibody.tree.Frame, a_A: numpy.ndarray[numpy.float64[3, 1]], frameB: pydrake.multibody.tree.Frame, b_B: numpy.ndarray[numpy.float64[3, 1]], c: float, plant_context: pydrake.systems.framework.Context) -&gt; None</p></li>
</ol>
<p>Constructs an AngleBetweenVectorsCost.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant</span></code>:</dt><dd><p>The MultibodyPlant on which the cost is imposed. <code class="docutils literal notranslate"><span class="pre">plant</span></code> should
be alive during the lifetime of this cost.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameA</span></code>:</dt><dd><p>The Frame object for frame A.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">a_A</span></code>:</dt><dd><p>The vector <code class="docutils literal notranslate"><span class="pre">a</span></code> fixed to frame A, expressed in frame A.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameB</span></code>:</dt><dd><p>The Frame object for frame B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b_B</span></code>:</dt><dd><p>The vector <code class="docutils literal notranslate"><span class="pre">b</span></code> fixed to frame B, expressed in frameB.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">c</span></code>:</dt><dd><p>The cost is c*(1-cosθ).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant_context</span></code>:</dt><dd><p>The Context that has been allocated for this <code class="docutils literal notranslate"><span class="pre">plant</span></code>. We will
update the context when evaluating the constraint.
<code class="docutils literal notranslate"><span class="pre">plant_context</span></code> should be alive during the lifetime of this
cost.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">frameA</span></code> and <code class="docutils literal notranslate"><span class="pre">frameB</span></code> must belong to <code class="docutils literal notranslate"><span class="pre">plant</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if plant is nullptr.</strong> – </p></li>
<li><p><strong>RuntimeError if a_A is close to zero.</strong> – </p></li>
<li><p><strong>RuntimeError if b_B is close to zero.</strong> – </p></li>
<li><p><strong>RuntimeError if plant_context is nullptr.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.inverse_kinematics.AngleBetweenVectorsCost, plant: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], frameA: pydrake.multibody.tree.Frame_[AutoDiffXd], a_A: numpy.ndarray[numpy.float64[3, 1]], frameB: pydrake.multibody.tree.Frame_[AutoDiffXd], b_B: numpy.ndarray[numpy.float64[3, 1]], c: float, plant_context: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Overloaded constructor. Use MultibodyPlant&lt;AutoDiffXd&gt; instead of
MultibodyPlant&lt;double&gt;.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ComInPolyhedronConstraint</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Constraint</span></code></p>
<p>Constrains the center of mass to lie within a polyhedron lb &lt;= A *
p_EC &lt;= ub where p_EC is the position of the center-of-mass (C)
expressed in a frame E.</p>
<p>For example, if you set A as identity matrix, then this constraint
enforces a box-region on the CoM position p_EC. If you set the
expressed frame E as the robot foot frame, and choose A to describe
the foot support polygon, this constraint could enforce the projection
of CoM to be within the foot support polygon, which is commonly used
to ensure static equilibrium.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ComInPolyhedronConstraint.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.inverse_kinematics.ComInPolyhedronConstraint, plant: pydrake.multibody.plant.MultibodyPlant, model_instances: Optional[list[pydrake.multibody.tree.ModelInstanceIndex]], expressed_frame: pydrake.multibody.tree.Frame, A: numpy.ndarray[numpy.float64[m, 3], flags.f_contiguous], lb: numpy.ndarray[numpy.float64[m, 1]], ub: numpy.ndarray[numpy.float64[m, 1]], plant_context: pydrake.systems.framework.Context) -&gt; None</p></li>
</ol>
<p>Constructs a ComInPolyhedronConstraint object.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant</span></code>:</dt><dd><p>The MultibodyPlant on which the constraint is imposed. <code class="docutils literal notranslate"><span class="pre">plant</span></code>
must be alive during the lifetime of this constraint.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instances</span></code>:</dt><dd><p>The CoM of these model instances are computed. If model_instances
= std::nullopt, then we compute the CoM of all model instances
(except the world).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">expressed_frame</span></code>:</dt><dd><p>The frame in which the CoM is expressed.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">A</span></code>:</dt><dd><p>The CoM position p_EC satisfies lb &lt;= A * p_EC &lt;= ub</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lb</span></code>:</dt><dd><p>The CoM position p_EC satisfies lb &lt;= A * p_EC &lt;= ub</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">ub</span></code>:</dt><dd><p>The CoM position p_EC satisfies lb &lt;= A * p_EC &lt;= ub</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant_context</span></code>:</dt><dd><p>The Context that has been allocated for this <code class="docutils literal notranslate"><span class="pre">plant</span></code>. We will
update the context when evaluating the constraint.
<code class="docutils literal notranslate"><span class="pre">plant_context</span></code> must be alive during the lifetime of this
constraint.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.inverse_kinematics.ComInPolyhedronConstraint, plant: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instances: Optional[list[pydrake.multibody.tree.ModelInstanceIndex]], expressed_frame: pydrake.multibody.tree.Frame_[AutoDiffXd], A: numpy.ndarray[numpy.float64[m, 3], flags.f_contiguous], lb: numpy.ndarray[numpy.float64[m, 1]], ub: numpy.ndarray[numpy.float64[m, 1]], plant_context: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Overloaded constructor. Same as the constructor with the double
version (using MultibodyPlant&lt;double&gt; and Context&lt;double&gt;. Except the
gradient of the constraint is computed from autodiff.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>if model_instances is not std::nullopt, then all indices in
<code class="docutils literal notranslate"><span class="pre">model_instances</span></code> refer to valid model instances in <code class="docutils literal notranslate"><span class="pre">plant</span></code>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ComPositionConstraint</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Constraint</span></code></p>
<p>Impose the constraint p_EScm(q) - p_EC = 0, where p_EScm(q) is a
function that computes the center-of-mass (COM) position from robot
generalized position q, expressed in a frame E. p_EC ∈ ℝ³ is the
variable representing robot CoM (C) position expressed in frame E. The
evaluated variables are [q;r], where q is the generalized position
vector of the entire plant.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ComPositionConstraint.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.inverse_kinematics.ComPositionConstraint, plant: pydrake.multibody.plant.MultibodyPlant, model_instances: Optional[list[pydrake.multibody.tree.ModelInstanceIndex]], expressed_frame: pydrake.multibody.tree.Frame, plant_context: pydrake.systems.framework.Context) -&gt; None</p></li>
</ol>
<p>Constructor, constrain f(q) = p_EC, where f(q) evaluates the CoM
position expressed in frame E using the generalized position q.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant</span></code>:</dt><dd><p>The MultibodyPlant on which the constraint is imposed. <code class="docutils literal notranslate"><span class="pre">plant</span></code>
should be alive during the lifetime of this constraint.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instances</span></code>:</dt><dd><p>We compute the model with these model instances in <code class="docutils literal notranslate"><span class="pre">plant</span></code>. If
model_instances=std::nullopt, then we compute the CoM position of
all model instances except the world.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">expressed_frame</span></code>:</dt><dd><p>The frame in which the CoM position is expressed.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant_context</span></code>:</dt><dd><p>The Context that has been allocated for this <code class="docutils literal notranslate"><span class="pre">plant</span></code>. We will
update the context when evaluating the constraint.
<code class="docutils literal notranslate"><span class="pre">plant_context</span></code> should be alive during the lifetime of this
constraint.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if plant</strong><strong> or </strong><strong>plant_context is nullptr.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.inverse_kinematics.ComPositionConstraint, plant: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], model_instances: Optional[list[pydrake.multibody.tree.ModelInstanceIndex]], expressed_frame: pydrake.multibody.tree.Frame_[AutoDiffXd], plant_context: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Overloaded constructor with MultibodyPlant&lt;AutoDiffXd&gt; and
Context&lt;AutoDiffXd&gt;. It is preferable to use the constructor with
MBP&lt;double&gt; and Context&lt;double&gt;. But if you only have MBP&lt;AutoDiffXd&gt;
and Context&lt;AutoDiffXd&gt;, then use this constructor.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DifferentialInverseKinematicsIntegrator</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.systems.framework.LeafSystem</span></code></p>
<p>A LeafSystem that integrates successive calls to
DoDifferentialInverseKinematics (which produces joint velocity
commands) to produce joint position commands.</p>
<p>In each evaluation, DoDifferentialInverseKinematics uses a
linearization of the robot kinematics around a nominal position. The
nominal position is obtained by either: 1. If the optional boolean
(abstract-)valued input port <code class="docutils literal notranslate"><span class="pre">use_robot_state</span></code> is connected and set
to <code class="docutils literal notranslate"><span class="pre">True</span></code>, then differential IK is computed using the
<code class="docutils literal notranslate"><span class="pre">robot_state</span></code> input port (which must also be connected). Note: Using
measured joint positions in a feedback loop can lead to undamped
oscillations in the redundant joints; we hope to resolve this and are
tracking it in #9773. 2. Otherwise, differential IK is computed using
this System’s internal state, representing the current joint position
command. This is equivalent to integrating (open loop) the velocity
commands obtained from the differential IK solutions.</p>
<p>It is also important to set the initial state of the integrator: 1. If
the <code class="docutils literal notranslate"><span class="pre">robot_state</span></code> port is connected, then the initial state of the
integrator is set to match the positions from this port (the port
accepts the state vector with positions and velocities for easy of use
with MultibodyPlant, but only the positions are used). 2. Otherwise,
it is highly recommended that the user call SetPositions() to
initialize the integrator state.</p>
<table align=center cellpadding=0 cellspacing=0><tr align=center><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=right style="padding:5px 0px 5px 0px">X_AE_desired&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">robot_state (optional)&rarr;</td></tr><tr><td align=right style="padding:5px 0px 5px 0px">use_robot_state (optional)&rarr;</td></tr></table></td><td align=center style="border:solid;padding-left:20px;padding-right:20px;vertical-align:middle" bgcolor=#F0F0F0>DifferentialInverseKinematicsIntegrator</td><td style="vertical-align:middle"><table cellspacing=0 cellpadding=0><tr><td align=left style="padding:5px 0px 5px 0px">&rarr; joint_positions</td></tr></table></td></tr></table><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DifferentialInverseKinematicsIntegrator.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsIntegrator, robot: pydrake.multibody.plant.MultibodyPlant, frame_A: pydrake.multibody.tree.Frame, frame_E: pydrake.multibody.tree.Frame, time_step: float, parameters: pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsParameters, robot_context: pydrake.systems.framework.Context = None, log_only_when_result_state_changes: bool = True) -&gt; None</p></li>
</ol>
<p>Constructs the system.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">robot</span></code>:</dt><dd><p>A MultibodyPlant describing the robot.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>Reference frame (inertial or non-inertial).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>End-effector frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time_step</span></code>:</dt><dd><p>the discrete time step of the (Euler) integration.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">parameters</span></code>:</dt><dd><p>Collection of various problem specific constraints and constants.
The <code class="docutils literal notranslate"><span class="pre">time_step</span></code> parameter will be set to <code class="docutils literal notranslate"><span class="pre">time_step</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">robot_context</span></code>:</dt><dd><p>Optional Context of the MultibodyPlant. The position values of
this context will be overwritten during integration; you only need
to pass this in if the robot has any non-default parameters.
$*Default:* <code class="docutils literal notranslate"><span class="pre">robot.CreateDefaultContext()</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">log_only_when_result_state_changes</span></code>:</dt><dd><p>is a boolean that determines whether the system will log on every
differential IK failure, or only when the failure state changes.
When the value is <code class="docutils literal notranslate"><span class="pre">True</span></code>, it will cause the system to have an
additional discrete state variable to store the most recent
DifferentialInverseKinematicsStatus. Set this to <code class="docutils literal notranslate"><span class="pre">False</span></code> if you
want IsDifferenceEquationSystem() to return <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
</dd>
</dl>
<p>Note: All references must remain valid for the lifetime of this
system.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>frame_E != frame_A.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsIntegrator, robot: pydrake.multibody.plant.MultibodyPlant, frame_E: pydrake.multibody.tree.Frame, time_step: float, parameters: pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsParameters, robot_context: pydrake.systems.framework.Context = None, log_only_when_result_state_changes: bool = True) -&gt; None</p></li>
</ol>
<p>Constructs the system.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">robot</span></code>:</dt><dd><p>A MultibodyPlant describing the robot.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>End-effector frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">time_step</span></code>:</dt><dd><p>the discrete time step of the (Euler) integration.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">parameters</span></code>:</dt><dd><p>Collection of various problem specific constraints and constants.
The <code class="docutils literal notranslate"><span class="pre">time_step</span></code> parameter will be set to <code class="docutils literal notranslate"><span class="pre">time_step</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">robot_context</span></code>:</dt><dd><p>Optional Context of the MultibodyPlant. The position values of
this context will be overwritten during integration; you only need
to pass this in if the robot has any non-default parameters.
$*Default:* <code class="docutils literal notranslate"><span class="pre">robot.CreateDefaultContext()</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">log_only_when_result_state_changes</span></code>:</dt><dd><p>is a boolean that determines whether the system will log on every
differential IK failure, or only when the failure state changes.
When the value is <code class="docutils literal notranslate"><span class="pre">True</span></code>, it will cause the system to have an
additional discrete state variable to store the most recent
DifferentialInverseKinematicsStatus. Set this to <code class="docutils literal notranslate"><span class="pre">False</span></code> if you
want IsDifferenceEquationSystem() to return <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
</dd>
</dl>
<p>In this overload, the reference frame, A, is taken to be the world
frame.</p>
<p>Note: All references must remain valid for the lifetime of this
system.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>frame_E != robot.world_frame().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DifferentialInverseKinematicsIntegrator.ForwardKinematics(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsIntegrator,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RigidTransform</span></span></dt>
<dd><p>Provides X_AE as a function of the joint position set in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DifferentialInverseKinematicsIntegrator.get_mutable_parameters(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsIntegrator)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsParameters</span></span></dt>
<dd><p>Returns a mutable reference to the differential IK parameters owned by
this system.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DifferentialInverseKinematicsIntegrator.get_parameters(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsIntegrator)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsParameters</span></span></dt>
<dd><p>Returns a const reference to the differential IK parameters owned by
this system.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DifferentialInverseKinematicsIntegrator.SetPositions(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsIntegrator,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">positions:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the joint positions, which are stored as state in the context. It
is recommended that the user calls this method to initialize the
position commands to match the initial positions of the robot.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DifferentialInverseKinematicsParameters</span></span></dt>
<dd><p>Contains parameters for differential inverse kinematics.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DifferentialInverseKinematicsParameters.__init__(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsParameters,</span> <span class="pre">num_positions:</span> <span class="pre">int,</span> <span class="pre">num_velocities:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">None)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructor. Initializes the nominal joint position to zeros of size
<code class="docutils literal notranslate"><span class="pre">num_positions</span></code>. The time step is initialized to 1. The end effector
flags are initialized to True. The joint centering gains are
initialized to zero. All constraints are initialized to nullopt.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_positions</span></code>:</dt><dd><p>Number of generalized positions.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">num_velocities</span></code>:</dt><dd><p>Number of generalized velocities (by default it will be set to
num_positions).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DifferentialInverseKinematicsParameters.get_end_effector_angular_speed_limit(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsParameters)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DifferentialInverseKinematicsParameters.get_end_effector_translational_velocity_limits(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsParameters)</span> <span class="pre">-&gt;</span> <span class="pre">Optional[tuple[numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DifferentialInverseKinematicsParameters.get_end_effector_velocity_flag(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsParameters)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[bool[6,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DifferentialInverseKinematicsParameters.get_joint_acceleration_limits(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsParameters)</span> <span class="pre">-&gt;</span> <span class="pre">Optional[tuple[numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DifferentialInverseKinematicsParameters.get_joint_centering_gain(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsParameters)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DifferentialInverseKinematicsParameters.get_joint_position_limits(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsParameters)</span> <span class="pre">-&gt;</span> <span class="pre">Optional[tuple[numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DifferentialInverseKinematicsParameters.get_joint_velocity_limits(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsParameters)</span> <span class="pre">-&gt;</span> <span class="pre">Optional[tuple[numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DifferentialInverseKinematicsParameters.get_maximum_scaling_to_report_stuck(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsParameters)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DifferentialInverseKinematicsParameters.get_mutable_solver_options(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsParameters)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.SolverOptions</span></span></dt>
<dd><p>Provides mutable access to change the solver options, e.g., to tune
for speed vs accuracy.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DifferentialInverseKinematicsParameters.get_nominal_joint_position(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsParameters)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DifferentialInverseKinematicsParameters.get_num_positions(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsParameters)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DifferentialInverseKinematicsParameters.get_num_velocities(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsParameters)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DifferentialInverseKinematicsParameters.get_time_step(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsParameters)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>&#64;name Getters.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DifferentialInverseKinematicsParameters.set_end_effector_angular_speed_limit(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsParameters,</span> <span class="pre">speed:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>When calling DoDifferentialInverseKinematics with a desired
end-effector pose, this limits the magnitude of the angular velocity
vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DifferentialInverseKinematicsParameters.set_end_effector_translational_velocity_limits(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsParameters,</span> <span class="pre">lower:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">upper:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>When calling DoDifferentialInverseKinematics with a desired
end-effector pose, this sets limits on the translational velocity.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DifferentialInverseKinematicsParameters.set_end_effector_velocity_flag(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsParameters,</span> <span class="pre">flag_E:</span> <span class="pre">numpy.ndarray[bool[6,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the end effector flags in the body frame. If a spatial velocity
flag is set to false, it will not be included in the differential IK
formulation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DifferentialInverseKinematicsParameters.set_joint_acceleration_limits(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsParameters,</span> <span class="pre">arg0:</span> <span class="pre">tuple[numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the joint acceleration limits.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">vd_bounds</span></code>:</dt><dd><p>The first element is the lower bound, and the second is the upper
bound.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the first</strong><strong> or </strong><strong>second element</strong><strong> of </strong><strong>q_bounds has</strong> – </p></li>
<li><p><strong>the wrong dimension</strong><strong> or </strong><strong>any element</strong><strong> of </strong><strong>the second element is</strong> – </p></li>
<li><p><strong>smaller than its corresponding part in the first element.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DifferentialInverseKinematicsParameters.set_joint_centering_gain(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsParameters,</span> <span class="pre">K:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the joint centering gain, K, so that the joint centering command
is attempting to achieve v_next = N⁺(q) * K * (q_nominal - q_current).</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>K must be num_positions x num_positions.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DifferentialInverseKinematicsParameters.set_joint_position_limits(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsParameters,</span> <span class="pre">arg0:</span> <span class="pre">tuple[numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the joint position limits.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">q_bounds</span></code>:</dt><dd><p>The first element is the lower bound, and the second is the upper
bound.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the first</strong><strong> or </strong><strong>second element</strong><strong> of </strong><strong>q_bounds has</strong> – </p></li>
<li><p><strong>the wrong dimension</strong><strong> or </strong><strong>any element</strong><strong> of </strong><strong>the second element is</strong> – </p></li>
<li><p><strong>smaller than its corresponding part in the first element.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DifferentialInverseKinematicsParameters.set_joint_velocity_limits(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsParameters,</span> <span class="pre">arg0:</span> <span class="pre">tuple[numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the joint velocity limits.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v_bounds</span></code>:</dt><dd><p>The first element is the lower bound, and the second is the upper
bound.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the first</strong><strong> or </strong><strong>second element</strong><strong> of </strong><strong>q_bounds has</strong> – </p></li>
<li><p><strong>the wrong dimension</strong><strong> or </strong><strong>any element</strong><strong> of </strong><strong>the second element is</strong> – </p></li>
<li><p><strong>smaller than its corresponding part in the first element.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DifferentialInverseKinematicsParameters.set_maximum_scaling_to_report_stuck(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsParameters,</span> <span class="pre">scaling:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the threshold for α below which the status returned is
DifferentialInverseKinematicsStatus::kStuck. α is the scaling of the
commanded spatial velocity, so when α is small, it means that the
actual spatial velocity magnitude will be small proportional to the
commanded.</p>
<p><em>Default:</em> 0.01.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DifferentialInverseKinematicsParameters.set_nominal_joint_position(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsParameters,</span> <span class="pre">arg0:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the nominal joint position.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if nominal_joint_position's dimension differs.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DifferentialInverseKinematicsParameters.set_time_step(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsParameters,</span> <span class="pre">dt:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>&#64;name Setters. Sets time step to <code class="docutils literal notranslate"><span class="pre">dt</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if dt &lt;= 0.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DifferentialInverseKinematicsResult</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DifferentialInverseKinematicsResult.__init__(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsResult,</span> <span class="pre">**kwargs)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DifferentialInverseKinematicsResult.joint_velocities</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DifferentialInverseKinematicsResult.status</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DifferentialInverseKinematicsStatus</span></span></dt>
<dd><p>Members:</p>
<blockquote>
<div><p>kSolutionFound : Found the optimal solution.</p>
<p>kNoSolutionFound : Solver unable to find a solution.</p>
<p>kStuck : Unable to follow the desired velocity direction</p>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DifferentialInverseKinematicsStatus.__init__(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsStatus,</span> <span class="pre">value:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DifferentialInverseKinematicsStatus.kNoSolutionFound</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DifferentialInverseKinematicsStatus.kSolutionFound</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DifferentialInverseKinematicsStatus.kStuck</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DifferentialInverseKinematicsStatus.name</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DifferentialInverseKinematicsStatus.value</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DistanceConstraint</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Constraint</span></code></p>
<p>Constrains the distance between a pair of geometries to be within a
range [distance_lower, distance_upper].</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DistanceConstraint.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.inverse_kinematics.DistanceConstraint, plant: pydrake.multibody.plant.MultibodyPlant, geometry_pair: Tuple[pydrake.geometry.GeometryId], plant_context: pydrake.systems.framework.Context, distance_lower: float, distance_upper: float) -&gt; None</p></li>
</ol>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant</span></code>:</dt><dd><p>The plant to which the pair of geometries belong. <code class="docutils literal notranslate"><span class="pre">plant</span></code> should
outlive this DistanceConstraint object.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">geometry_pair</span></code>:</dt><dd><p>The pair of geometries between which the distance is constrained.
Notice that we only consider the distance between a static
geometry and a dynamic geometry, or a pair of dynamic geometries.
We don’t allow constraining the distance between two static
geometries.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant_context</span></code>:</dt><dd><p>The context for the plant. <code class="docutils literal notranslate"><span class="pre">plant_context</span></code> should outlive this
DistanceConstraint object.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">distance_lower</span></code>:</dt><dd><p>The lower bound on the distance.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">distance_upper</span></code>:</dt><dd><p>The upper bound on the distance.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.inverse_kinematics.DistanceConstraint, plant: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], geometry_pair: Tuple[pydrake.geometry.GeometryId], plant_context: pydrake.systems.framework.Context_[AutoDiffXd], distance_lower: float, distance_upper: float) -&gt; None</p></li>
</ol>
<p>Overloaded constructor. Constructs the constraint with
MultibodyPlant&lt;AutoDiffXd&gt;.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DoDifferentialInverseKinematics(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>DoDifferentialInverseKinematics(q_current: numpy.ndarray[numpy.float64[m, 1]], v_current: numpy.ndarray[numpy.float64[m, 1]], V: numpy.ndarray[numpy.float64[m, 1]], J: numpy.ndarray[numpy.float64[m, n]], parameters: pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsParameters, N: Optional[numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]] = None, Nplus: Optional[numpy.ndarray[numpy.float64[m, n], flags.f_contiguous]] = None) -&gt; pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsResult</p></li>
</ol>
<p>Computes a generalized velocity v_next, via the following
MathematicalProgram:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">min_</span><span class="p">{</span><span class="n">v_next</span><span class="p">,</span><span class="n">alpha</span><span class="p">}</span>
<span class="w">    </span><span class="mi">-100</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="o">|</span><span class="n">P</span><span class="err">⋅</span><span class="p">(</span><span class="n">v_next</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">N</span><span class="err">⁺</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="err">⋅</span><span class="n">K</span><span class="err">⋅</span><span class="p">(</span><span class="n">q_nominal</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">q_current</span><span class="p">))</span><span class="o">|</span><span class="n">²</span>

<span class="w">  </span><span class="n">s</span><span class="p">.</span><span class="n">t</span><span class="p">.</span>
<span class="w">    </span><span class="n">J</span><span class="err">⋅</span><span class="n">v_next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alpha</span><span class="err">⋅</span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="c1">// J⋅v_next has the same direction as V</span>
<span class="w">    </span><span class="mi">0</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">        </span><span class="c1">// Never go faster than V</span>
<span class="w">    </span><span class="n">joint_lim_min</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">q_current</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">N</span><span class="err">⋅</span><span class="n">v_next</span><span class="err">⋅</span><span class="n">dt</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">joint_lim_max</span><span class="p">,</span>
<span class="w">    </span><span class="n">joint_vel_lim_min</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">v_next</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">joint_vel_lim_max</span><span class="p">,</span>
<span class="w">    </span><span class="n">joint_accel_lim_min</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="p">(</span><span class="n">v_next</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">v_current</span><span class="p">)</span><span class="o">/</span><span class="n">dt</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">joint_accel_lim_max</span><span class="p">,</span>
<span class="w">    </span><span class="k">and</span><span class="w"> </span><span class="n">additional</span><span class="w"> </span><span class="n">linear</span><span class="w"> </span><span class="n">velocity</span><span class="w"> </span><span class="n">constraints</span><span class="p">,</span>
</pre></div>
</div>
</details><p>where: - The rows of P form an orthonormal basis for the nullspace of
J, - J.rows() == V.size(), - J.cols() == v_current.size() ==
v_next.size(), - V can have any size, with each element representing a
constraint on the solution (6 constraints specifying an end-effector
spatial velocity is typical, but not required), - K is the
joint_centering_gain, - the “additional linear velocity constraints”
are added via
DifferentialInverseKinematicsParameters::AddLinearVelocityConstraint().</p>
<p>Intuitively, this finds a v_next such that J*v_next is in the same
direction as V, and the difference between <a href="#id9"><span class="problematic" id="id10">|V|</span></a> and <a href="#id11"><span class="problematic" id="id12">|J * v_next|</span></a> is
minimized while all constraints in <code class="docutils literal notranslate"><span class="pre">parameters</span></code> are satisfied as
well. In the nullspace of this objective, we have a secondary
objective to minimize <a href="#id1"><span class="problematic" id="id2">|</span></a>v_next - N⁺(q)⋅K⋅(q_nominal - q_current)|².</p>
<p>For more details, see
<a class="reference external" href="https://manipulation.csail.mit.edu/pick.html#diff_ik_w_constraints">https://manipulation.csail.mit.edu/pick.html#diff_ik_w_constraints</a> .</p>
<p>If q_current is a feasible point, then v_next = 0 should always be a
feasible solution. If the problem data is bad (q_current is
infeasible, and no feasible velocities can restore feasibility in one
step), then it is possible that the solver cannot find a solution, in
which case, status will be set to kNoSolution in the returned
DifferentialInverseKinematicsResult. If the velocity scaling, alpha,
is very small, then the status will be set to kStuck.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">q_current</span></code>:</dt><dd><p>The current generalized position.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v_current</span></code>:</dt><dd><p>The current generalized position.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">V</span></code>:</dt><dd><p>Desired spatial velocity. It must have the same number of rows as
<code class="docutils literal notranslate"><span class="pre">J</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">J</span></code>:</dt><dd><p>Jacobian with respect to generalized velocities v. It must have
the same number of rows as <code class="docutils literal notranslate"><span class="pre">V</span></code>. J * v needs to represent the
same spatial velocity as <code class="docutils literal notranslate"><span class="pre">V</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">parameters</span></code>:</dt><dd><p>Collection of various problem specific constraints and constants.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">N</span></code>:</dt><dd><p>(optional) matrix which maps q̇ = N(q)⋅v. See
MultibodyPlant::MakeVelocityToQDotMap(). By default, it is taken
to be the identity matrix. If dim(q) != dim(v) and any joint
position limits are set in <code class="docutils literal notranslate"><span class="pre">parameters</span></code>, then you <em>must</em> provide
N.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Nplus</span></code>:</dt><dd><p>(optional) matrix which maps q̇ = N⁺(q)⋅v. See
MultibodyPlant::MakeQDotToVelocityMap(). By default, it is taken
to be the identity matrix. If dim(q) != dim(v) and J is not full
column rank, then you <em>must</em> provide Nplus.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>If the solver successfully finds a solution, joint_velocities will
be set to v, otherwise it will be nullopt.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>DoDifferentialInverseKinematics(robot: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, V_WE_desired: numpy.ndarray[numpy.float64[6, 1]], frame_E: pydrake.multibody.tree.Frame, parameters: pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsParameters) -&gt; pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsResult</p></li>
</ol>
<p>A wrapper over DoDifferentialInverseKinematics(q_current, v_current,
V, J, params) that tracks frame E’s spatial velocity. q_current and
v_current are taken from <code class="docutils literal notranslate"><span class="pre">context</span></code>. V and J are expressed in E, and
only the elements with non-zero gains in <code class="docutils literal notranslate"><span class="pre">parameters</span></code>
get_end_effector_velocity_gains() are used in the program.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">robot</span></code>:</dt><dd><p>A MultibodyPlant model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Must be the Context of the MultibodyPlant. Contains the current
generalized position and velocity.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">V_WE_desired</span></code>:</dt><dd><p>Desired world frame spatial velocity of <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>End effector frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">parameters</span></code>:</dt><dd><p>Collection of various problem specific constraints and constants.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>If the solver successfully finds a solution, joint_velocities will
be set to v, otherwise it will be nullopt.</p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>DoDifferentialInverseKinematics(robot: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, V_AE_desired: numpy.ndarray[numpy.float64[6, 1]], frame_A: pydrake.multibody.tree.Frame, frame_E: pydrake.multibody.tree.Frame, parameters: pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsParameters) -&gt; pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsResult</p></li>
</ol>
<p>A wrapper over DoDifferentialInverseKinematics(q_current, v_current,
V, J, params) that tracks frame E’s spatial velocity in frame A.
q_current and v_current are taken from <code class="docutils literal notranslate"><span class="pre">context</span></code>. V and J are
expressed in E, and only the elements with non-zero gains in
<code class="docutils literal notranslate"><span class="pre">parameters</span></code> get_end_effector_velocity_gains() are used in the
program.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">robot</span></code>:</dt><dd><p>A MultibodyPlant model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Must be the Context of the MultibodyPlant. Contains the current
generalized position and velocity.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">V_AE_desired</span></code>:</dt><dd><p>Desired spatial velocity of <code class="docutils literal notranslate"><span class="pre">frame_E</span></code> in <code class="docutils literal notranslate"><span class="pre">frame</span></code> A.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>Reference frame (inertial or non-inertial).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>End effector frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">parameters</span></code>:</dt><dd><p>Collection of various problem specific constraints and constants.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>If the solver successfully finds a solution, joint_velocities will
be set to v, otherwise it will be nullopt.</p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>DoDifferentialInverseKinematics(robot: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, X_WE_desired: pydrake.math.RigidTransform, frame_E: pydrake.multibody.tree.Frame, parameters: pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsParameters) -&gt; pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsResult</p></li>
</ol>
<p>A wrapper over DoDifferentialInverseKinematics(robot, context,
V_WE_desired, frame_E, params) that tracks frame E’s pose in the world
frame. q_current and v_current are taken from <code class="docutils literal notranslate"><span class="pre">context</span></code>.
V_WE_desired is computed by ComputePoseDiffInCommonFrame(X_WE,
X_WE_desired) / dt, where X_WE is computed from <code class="docutils literal notranslate"><span class="pre">context</span></code>, and dt is
taken from <code class="docutils literal notranslate"><span class="pre">parameters</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">robot</span></code>:</dt><dd><p>A MultibodyPlant model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Must be the Context of the MultibodyPlant. Contains the current
generalized position and velocity.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_WE_desired</span></code>:</dt><dd><p>Desired pose of <code class="docutils literal notranslate"><span class="pre">frame_E</span></code> in the world frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>End effector frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">parameters</span></code>:</dt><dd><p>Collection of various problem specific constraints and constants.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>If the solver successfully finds a solution, joint_velocities will
be set to v, otherwise it will be nullopt.</p>
</dd>
</dl>
<ol class="arabic simple" start="5">
<li><p>DoDifferentialInverseKinematics(robot: pydrake.multibody.plant.MultibodyPlant, context: pydrake.systems.framework.Context, X_AE_desired: pydrake.math.RigidTransform, frame_A: pydrake.multibody.tree.Frame, frame_E: pydrake.multibody.tree.Frame, parameters: pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsParameters) -&gt; pydrake.multibody.inverse_kinematics.DifferentialInverseKinematicsResult</p></li>
</ol>
<p>A wrapper over DoDifferentialInverseKinematics(robot, context,
V_AE_desired, frame_A, frame_E, params) that tracks frame E’s pose in
frame A. q_current and v_current are taken from <code class="docutils literal notranslate"><span class="pre">context</span></code>.
V_AE_desired is computed by ComputePoseDiffInCommonFrame(X_AE,
X_AE_desired) / dt, where X_WE is computed from <code class="docutils literal notranslate"><span class="pre">context</span></code>, and dt is
taken from <code class="docutils literal notranslate"><span class="pre">parameters</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">robot</span></code>:</dt><dd><p>A MultibodyPlant model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Must be the Context of the MultibodyPlant. Contains the current
generalized position and velocity.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_AE_desired</span></code>:</dt><dd><p>Desired pose of <code class="docutils literal notranslate"><span class="pre">frame_E</span></code> in <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_A</span></code>:</dt><dd><p>Reference frame (inertial or non-inertial).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>End effector frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">parameters</span></code>:</dt><dd><p>Collection of various problem specific constraints and constants.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>If the solver successfully finds a solution, joint_velocities will
be set to v, otherwise it will be nullopt.</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GazeTargetConstraint</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Constraint</span></code></p>
<p>Constrains a target point T to be within a cone K. The point T (“T”
stands for “target”) is fixed in a frame B, with position p_BT. The
cone originates from a point S (“S” stands for “source”), fixed in
frame A with position p_AS, with the axis of the cone being n, also
fixed in frame A. The half angle of the cone is θ. A common usage of
this constraint is that a camera should gaze at some target; namely
the target falls within a gaze cone, originating from the camera eye.</p>
<p>Mathematically the constraint is p_ST_Aᵀ * n_unit_A ≥ 0 (p_ST_Aᵀ *
n_unit_A)² ≥ (cosθ)²p_ST_Aᵀ * p_ST_A where p_ST_A is the vector from S
to T, expressed in frame A. n_unit_A is the unit length directional
vector representing the center ray of the cone.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GazeTargetConstraint.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.inverse_kinematics.GazeTargetConstraint, plant: pydrake.multibody.plant.MultibodyPlant, frameA: pydrake.multibody.tree.Frame, p_AS: numpy.ndarray[numpy.float64[3, 1]], n_A: numpy.ndarray[numpy.float64[3, 1]], frameB: pydrake.multibody.tree.Frame, p_BT: numpy.ndarray[numpy.float64[3, 1]], cone_half_angle: float, plant_context: pydrake.systems.framework.Context) -&gt; None</p></li>
</ol>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant</span></code>:</dt><dd><p>The MultibodyPlant on which the constraint is imposed. <code class="docutils literal notranslate"><span class="pre">plant</span></code>
should be alive during the lifetime of this constraint.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameA</span></code>:</dt><dd><p>The frame to which the gaze cone is fixed.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_AS</span></code>:</dt><dd><p>The position of the cone source point S, measured and expressed in
frame A.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">n_A</span></code>:</dt><dd><p>The directional vector representing the center ray of the cone,
expressed in frame A.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameB</span></code>:</dt><dd><p>The frame to which the target point T is fixed.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BT</span></code>:</dt><dd><p>The position of the target point T, measured and expressed in
frame B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">cone_half_angle</span></code>:</dt><dd><p>The half angle of the cone. We denote it as θ in the class
documentation. <code class="docutils literal notranslate"><span class="pre">cone_half_angle</span></code> is in radians.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant_context</span></code>:</dt><dd><p>The Context that has been allocated for this <code class="docutils literal notranslate"><span class="pre">plant</span></code>. We will
update the context when evaluating the constraint.
<code class="docutils literal notranslate"><span class="pre">plant_context</span></code> should be alive during the lifetime of this
constraint.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">frameA</span></code> and <code class="docutils literal notranslate"><span class="pre">frameB</span></code> must belong to <code class="docutils literal notranslate"><span class="pre">plant</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if plant is nullptr.</strong> – </p></li>
<li><p><strong>RuntimeError if n_A is close to zero.</strong> – </p></li>
<li><p><strong>RuntimeError if cone_half_angle ∉</strong><strong> [</strong><strong>0</strong><strong>, </strong><strong>π/2</strong><strong>]</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if plant_context is nullptr.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.inverse_kinematics.GazeTargetConstraint, plant: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], frameA: pydrake.multibody.tree.Frame_[AutoDiffXd], p_AS: numpy.ndarray[numpy.float64[3, 1]], n_A: numpy.ndarray[numpy.float64[3, 1]], frameB: pydrake.multibody.tree.Frame_[AutoDiffXd], p_BT: numpy.ndarray[numpy.float64[3, 1]], cone_half_angle: float, plant_context: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Overloaded constructor. Construct from MultibodyPlant&lt;AutoDiffXd&gt;
instead of MultibodyPlant&lt;double&gt;.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GlobalInverseKinematics</span></span></dt>
<dd><p>Solves the inverse kinematics problem as a mixed integer convex
optimization problem. We use a mixed-integer convex relaxation of the
rotation matrix. So if this global inverse kinematics problem says the
solution is infeasible, then it is guaranteed that the kinematics
constraints are not satisfiable. If the global inverse kinematics
returns a solution, the posture should approximately satisfy the
kinematics constraints, with some error. The approach is described in
Global Inverse Kinematics via Mixed-integer Convex Optimization by
Hongkai Dai, Gregory Izatt and Russ Tedrake, International Journal of
Robotics Research, 2019.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GlobalInverseKinematics.__init__(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.GlobalInverseKinematics,</span> <span class="pre">plant:</span> <span class="pre">pydrake.multibody.plant.MultibodyPlant,</span> <span class="pre">options:</span> <span class="pre">pydrake.multibody.inverse_kinematics.GlobalInverseKinematics.Options</span> <span class="pre">=</span> <span class="pre">GlobalInverseKinematics.Options(num_intervals_per_half_axis=2,</span> <span class="pre">approach=Approach.kBilinearMcCormick,</span> <span class="pre">interval_binning=IntervalBinning.kLogarithmic,</span> <span class="pre">linear_constraint_only=False))</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Parses the robot kinematics tree. The decision variables include the
pose for each body (position/orientation). This constructor loops
through each body inside the robot kinematics tree, adds the
constraint on each body pose, so that the adjacent bodies are
connected correctly by the joint in between the bodies.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant</span></code>:</dt><dd><p>The robot on which the inverse kinematics problem is solved. plant
must be alive for as long as this object is around.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">options</span></code>:</dt><dd><p>The options to relax SO(3) constraint as mixed-integer convex
constraints. Refer to MixedIntegerRotationConstraintGenerator for
more details on the parameters in options.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GlobalInverseKinematics.AddJointLimitConstraint(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.GlobalInverseKinematics,</span> <span class="pre">body_index:</span> <span class="pre">pydrake.multibody.tree.BodyIndex,</span> <span class="pre">joint_lower_bound:</span> <span class="pre">float,</span> <span class="pre">joint_upper_bound:</span> <span class="pre">float,</span> <span class="pre">linear_constraint_approximation:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">False)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Adds joint limits on a specified joint.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This method is called from the constructor.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_index</span></code>:</dt><dd><p>The joint connecting the parent link to this body will be
constrained.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">joint_lower_bound</span></code>:</dt><dd><p>The lower bound for the joint.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">joint_upper_bound</span></code>:</dt><dd><p>The upper bound for the joint.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">linear_constraint_approximation</span></code>:</dt><dd><p>If true, joint limits are approximated as linear constraints on
parent and child link orientations, otherwise they are imposed as
Lorentz cone constraints. With the Lorentz cone formulation, the
joint limit constraint would be tight if our mixed-integer
constraint on SO(3) were tight. By enforcing the joint limits as
linear constraint, the original inverse kinematics problem is
further relaxed, on top of SO(3) relaxation, but potentially with
faster computation. $*Default:* is false.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GlobalInverseKinematics.AddPostureCost(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.GlobalInverseKinematics,</span> <span class="pre">q_desired:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">body_position_cost:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">body_orientation_cost:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Penalizes the deviation to the desired posture.</p>
<p>For each body (except the world) in the kinematic tree, we add the
cost</p>
<p>∑ᵢ body_position_cost(i) * body_position_error(i) +
body_orientation_cost(i) * body_orientation_error(i) where
<code class="docutils literal notranslate"><span class="pre">body_position_error(i)</span></code> is computed as the Euclidean distance error
<a href="#id13"><span class="problematic" id="id14">|p_WBo(i) - p_WBo_desired(i)|</span></a> where - p_WBo(i) : position of body i’th
origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code> in the world frame <code class="docutils literal notranslate"><span class="pre">W</span></code>. - p_WBo_desired(i): position
of body i’th origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code> in the world frame <code class="docutils literal notranslate"><span class="pre">W</span></code>, computed from the
desired posture <code class="docutils literal notranslate"><span class="pre">q_desired</span></code>.</p>
<p>body_orientation_error(i) is computed as (1 - cos(θ)), where θ is the
angle between the orientation of body i’th frame and body i’th frame
using the desired posture. Notice that 1 - cos(θ) = θ²/2 + O(θ⁴), so
this cost is on the square of θ, when θ is small. Notice that since
body 0 is the world, the cost on that body is always 0, no matter what
value <code class="docutils literal notranslate"><span class="pre">body_position_cost(0)</span></code> and <code class="docutils literal notranslate"><span class="pre">body_orientation_cost(0)</span></code> take.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">q_desired</span></code>:</dt><dd><p>The desired posture.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_position_cost</span></code>:</dt><dd><p>The cost for each body’s position error. Unit is [1/m] (one over
meters).</p>
</dd>
</dl>
<p>Precondition:
1. body_position_cost.rows() == plant.num_bodies(), where <code class="docutils literal notranslate"><span class="pre">plant</span></code> is the</p>
<blockquote>
<div><p>input argument in the constructor of the class.</p>
</div></blockquote>
<ol class="arabic" start="2">
<li><p>body_position_cost(i) is non-negative.</p>
<blockquote>
<div><p>$Raises:</p>
</div></blockquote>
</li>
</ol>
<p>RuntimeError if the precondition is not satisfied.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_orientation_cost</span></code>:</dt><dd><p>The cost for each body’s orientation error.</p>
</dd>
</dl>
<p>Precondition:
1. body_orientation_cost.rows() == plant.num_bodies() , where <code class="docutils literal notranslate"><span class="pre">plant</span></code> is</p>
<blockquote>
<div><p>the input argument in the constructor of the class.</p>
</div></blockquote>
<ol class="arabic" start="2">
<li><p>body_position_cost(i) is non-negative.</p>
<blockquote>
<div><p>$Raises:</p>
</div></blockquote>
</li>
</ol>
<p>RuntimeError if the precondition is not satisfied.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GlobalInverseKinematics.AddWorldOrientationConstraint(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.GlobalInverseKinematics,</span> <span class="pre">body_index:</span> <span class="pre">pydrake.multibody.tree.BodyIndex,</span> <span class="pre">desired_orientation:</span> <span class="pre">pydrake.common.eigen_geometry.Quaternion,</span> <span class="pre">angle_tol:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.Binding[LinearConstraint]</span></span></dt>
<dd><p>Adds a constraint that the angle between the body orientation and the
desired orientation should not be larger than <code class="docutils literal notranslate"><span class="pre">angle_tol</span></code>. If we
denote the angle between two rotation matrices <code class="docutils literal notranslate"><span class="pre">R1</span></code> and <code class="docutils literal notranslate"><span class="pre">R2</span></code> as
<code class="docutils literal notranslate"><span class="pre">θ</span></code>, i.e. θ is the angle of the angle-axis representation of the
rotation matrix <code class="docutils literal notranslate"><span class="pre">R1ᵀ</span> <span class="pre">*</span> <span class="pre">R2</span></code>, we then know</p>
<p>trace(R1ᵀ * R2) = 2 * cos(θ) + 1 as in
<a class="reference external" href="http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/">http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/</a>
To constraint <code class="docutils literal notranslate"><span class="pre">θ</span> <span class="pre">&lt;</span> <span class="pre">angle_tol</span></code>, we can impose the following
constraint</p>
<p>2 * cos(angle_tol) + 1 &lt;= trace(R1ᵀ * R2) &lt;= 3</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_index</span></code>:</dt><dd><p>The index of the body whose orientation will be constrained.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">desired_orientation</span></code>:</dt><dd><p>The desired orientation of the body.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angle_tol</span></code>:</dt><dd><p>The tolerance on the angle between the body orientation and the
desired orientation. Unit is radians.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">binding</span></code>:</dt><dd><p>The newly added constraint, together with the bound variables.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GlobalInverseKinematics.AddWorldPositionConstraint(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.GlobalInverseKinematics,</span> <span class="pre">body_index:</span> <span class="pre">pydrake.multibody.tree.BodyIndex,</span> <span class="pre">p_BQ:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">box_lb_F:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">box_ub_F:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">X_WF:</span> <span class="pre">pydrake.math.RigidTransform</span> <span class="pre">=</span> <span class="pre">RigidTransform(</span> <span class="pre">R=RotationMatrix([</span> <span class="pre">[1.0,</span> <span class="pre">0.0,</span> <span class="pre">0.0],</span> <span class="pre">[0.0,</span> <span class="pre">1.0,</span> <span class="pre">0.0],</span> <span class="pre">[0.0,</span> <span class="pre">0.0,</span> <span class="pre">1.0],</span> <span class="pre">]),</span> <span class="pre">p=[0.0,</span> <span class="pre">0.0,</span> <span class="pre">0.0],</span> <span class="pre">))</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.Binding[LinearConstraint]</span></span></dt>
<dd><p>Adds the constraint that the position of a point <code class="docutils literal notranslate"><span class="pre">Q</span></code> on a body <code class="docutils literal notranslate"><span class="pre">B</span></code>
(whose index is <code class="docutils literal notranslate"><span class="pre">body_index</span></code>), is within a box in a specified frame
<code class="docutils literal notranslate"><span class="pre">F</span></code>. The constraint is that the point <code class="docutils literal notranslate"><span class="pre">Q`'s</span> <span class="pre">position</span> <span class="pre">should</span> <span class="pre">lie</span>
<span class="pre">within</span> <span class="pre">a</span> <span class="pre">bounding</span> <span class="pre">box</span> <span class="pre">in</span> <span class="pre">the</span> <span class="pre">frame</span> <span class="pre">`F</span></code>. Namely</p>
<p>box_lb_F &lt;= p_FQ &lt;= box_ub_F</p>
<p>where p_FQ is the position of the point Q measured and expressed in
the <code class="docutils literal notranslate"><span class="pre">F</span></code>, computed as</p>
<p>p_FQ = X_FW * (p_WBo + R_WB * p_BQ)</p>
<p>hence this is a linear constraint on the decision variables p_WBo and
R_WB. The inequality is imposed elementwise.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>since the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_WB</span></code> does not lie exactly on the
SO(3), due to the McCormick envelope relaxation, this constraint
is subject to the accumulated error from the root of the
kinematics tree.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_index</span></code>:</dt><dd><p>The index of the body on which the position of a point is
constrained.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BQ</span></code>:</dt><dd><p>The position of the point Q measured and expressed in the body
frame B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">box_lb_F</span></code>:</dt><dd><p>The lower bound of the box in frame <code class="docutils literal notranslate"><span class="pre">F</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">box_ub_F</span></code>:</dt><dd><p>The upper bound of the box in frame <code class="docutils literal notranslate"><span class="pre">F</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_WF</span></code>:</dt><dd><p>The frame in which the box is specified. This frame is represented
by a RigidTransform X_WF, the transform from the constraint frame
F to the world frame W. Namely if the position of the point <code class="docutils literal notranslate"><span class="pre">Q</span></code>
in the world frame is <code class="docutils literal notranslate"><span class="pre">p_WQ</span></code>, then the constraint is</p>
</dd>
</dl>
<p>box_lb_F &lt;= R_FW * (p_WQ-p_WFo) &lt;= box_ub_F where - R_FW is the
rotation matrix of frame <code class="docutils literal notranslate"><span class="pre">W</span></code> expressed and measured in frame <code class="docutils literal notranslate"><span class="pre">F</span></code>.
<cite>R_FW = X_WF.linear().transpose()`</cite>. - p_WFo is the position of frame
<cite>F</cite>’s origin, expressed and measured in frame <cite>W`</cite>. <cite>p_WFo =
X_WF.translation()</cite>.</p>
<dl class="simple">
<dt><em>Default:</em> is the identity transform.</dt><dd><p>$Returns <code class="docutils literal notranslate"><span class="pre">binding</span></code>:</p>
</dd>
</dl>
<p>The newly added constraint, together with the bound variables.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GlobalInverseKinematics.AddWorldRelativePositionConstraint(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.GlobalInverseKinematics,</span> <span class="pre">body_index_B:</span> <span class="pre">pydrake.multibody.tree.BodyIndex,</span> <span class="pre">p_BQ:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">body_index_A:</span> <span class="pre">pydrake.multibody.tree.BodyIndex,</span> <span class="pre">p_AP:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">box_lb_F:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">box_ub_F:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">X_WF:</span> <span class="pre">pydrake.math.RigidTransform</span> <span class="pre">=</span> <span class="pre">RigidTransform(</span> <span class="pre">R=RotationMatrix([</span> <span class="pre">[1.0,</span> <span class="pre">0.0,</span> <span class="pre">0.0],</span> <span class="pre">[0.0,</span> <span class="pre">1.0,</span> <span class="pre">0.0],</span> <span class="pre">[0.0,</span> <span class="pre">0.0,</span> <span class="pre">1.0],</span> <span class="pre">]),</span> <span class="pre">p=[0.0,</span> <span class="pre">0.0,</span> <span class="pre">0.0],</span> <span class="pre">))</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.Binding[LinearConstraint]</span></span></dt>
<dd><p>Adds the constraint that the position of a point <code class="docutils literal notranslate"><span class="pre">Q</span></code> on a body <code class="docutils literal notranslate"><span class="pre">B</span></code>
relative to a point <code class="docutils literal notranslate"><span class="pre">P</span></code> on body <code class="docutils literal notranslate"><span class="pre">A</span></code>, is within a box in a
specified frame <code class="docutils literal notranslate"><span class="pre">F</span></code>. Using monogram notation we have:</p>
<p>box_lb_F &lt;= p_FQ - p_FP &lt;= box_ub_F</p>
<p>where p_FQ and p_FP are the position of the points measured and
expressed in <code class="docutils literal notranslate"><span class="pre">F</span></code>. The inequality is imposed elementwise. See
AddWorldPositionConstraint for more details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_index_B</span></code>:</dt><dd><p>The index of the body B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BQ</span></code>:</dt><dd><p>The position of the point Q measured and expressed in the body
frame B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_index_A</span></code>:</dt><dd><p>The index of the body A.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_AP</span></code>:</dt><dd><p>The position of the point P measured and expressed in the body
frame A.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">box_lb_F</span></code>:</dt><dd><p>The lower bound of the box in frame <code class="docutils literal notranslate"><span class="pre">F</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">box_ub_F</span></code>:</dt><dd><p>The upper bound of the box in frame <code class="docutils literal notranslate"><span class="pre">F</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_WF</span></code>:</dt><dd><p>Defines the frame in which the box is specified. $*Default:* is
the identity transform.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">binding</span></code>:</dt><dd><p>The newly added constraint, together with the bound variables.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GlobalInverseKinematics.body_position(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.GlobalInverseKinematics,</span> <span class="pre">body_index:</span> <span class="pre">pydrake.multibody.tree.BodyIndex)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Getter for the decision variables on the position p_WBo of the body
B’s origin measured and expressed in the world frame.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_index</span></code>:</dt><dd><p>The index of the queried body. Notice that body 0 is the world,
and thus not a decision variable.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the index is smaller than 1</strong><strong>, or </strong><strong>greater than or</strong> – </p></li>
<li><p><strong>equal to the total number</strong><strong> of </strong><strong>bodies in the robot.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GlobalInverseKinematics.body_rotation_matrix(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.GlobalInverseKinematics,</span> <span class="pre">body_index:</span> <span class="pre">pydrake.multibody.tree.BodyIndex)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">3]]</span></span></dt>
<dd><p>Getter for the decision variables on the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_WB</span></code> for
a body with the specified index. This is the orientation of body i’s
frame measured and expressed in the world frame.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_index</span></code>:</dt><dd><p>The index of the queried body. Notice that body 0 is the world,
and thus not a decision variable.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the index is smaller than 1</strong><strong>, or </strong><strong>greater than or</strong> – </p></li>
<li><p><strong>equal to the total number</strong><strong> of </strong><strong>bodies in the robot.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GlobalInverseKinematics.BodyPointInOneOfRegions(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.GlobalInverseKinematics,</span> <span class="pre">body_index:</span> <span class="pre">pydrake.multibody.tree.BodyIndex,</span> <span class="pre">p_BQ:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">region_vertices:</span> <span class="pre">list[numpy.ndarray[numpy.float64[3,</span> <span class="pre">n]]])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Constrain the point <code class="docutils literal notranslate"><span class="pre">Q</span></code> lying within one of the convex polytopes.
Each convex polytope Pᵢ is represented by its vertices as Pᵢ =
ConvexHull(v_i1, v_i2, … v_in). Mathematically we want to impose the
constraint that the p_WQ, i.e., the position of point <code class="docutils literal notranslate"><span class="pre">Q</span></code> in world
frame <code class="docutils literal notranslate"><span class="pre">W</span></code>, satisfies</p>
<p>p_WQ ∈ Pᵢ for one i. To impose this constraint, we consider to
introduce binary variable zᵢ, and continuous variables w_i1, w_i2,
…, w_in for each vertex of Pᵢ, with the following constraints</p>
<p>p_WQ = sum_i (w_i1 * v_i1 + w_i2 * v_i2 + … + w_in * v_in) w_ij &gt;=
0, ∀i,j w_i1 + w_i2 + … + w_in = zᵢ sum_i zᵢ = 1 zᵢ ∈ {0, 1} Notice
that if zᵢ = 0, then w_i1 * v_i1 + w_i2 * v_i2 + … + w_in * v_in is
just 0. This function can be used for collision avoidance, where each
region Pᵢ is a free space region. It can also be used for grasping,
where each region Pᵢ is a surface patch on the grasped object. Note
this approach also works if the region Pᵢ overlaps with each other.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_index</span></code>:</dt><dd><p>The index of the body to on which point <code class="docutils literal notranslate"><span class="pre">Q</span></code> is attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BQ</span></code>:</dt><dd><p>The position of point <code class="docutils literal notranslate"><span class="pre">Q</span></code> in the body frame <code class="docutils literal notranslate"><span class="pre">B</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">region_vertices</span></code>:</dt><dd><p>region_vertices[i] is the vertices for the i’th region.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">z</span></code>:</dt><dd><p>The newly added binary variables. If point <code class="docutils literal notranslate"><span class="pre">Q</span></code> is in the i’th
region, z(i) = 1.</p>
</dd>
<dt>Precondition:</dt><dd><p>region_vertices[i] has at least 3 columns. Throw a RuntimeError if
the precondition is not satisfied.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GlobalInverseKinematics.BodySphereInOneOfPolytopes(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.GlobalInverseKinematics,</span> <span class="pre">body_index:</span> <span class="pre">pydrake.multibody.tree.BodyIndex,</span> <span class="pre">p_BQ:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">radius:</span> <span class="pre">float,</span> <span class="pre">polytopes:</span> <span class="pre">list[pydrake.multibody.inverse_kinematics.GlobalInverseKinematics.Polytope3D])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Adds the constraint that a sphere rigidly attached to a body has to be
within at least one of the given bounded polytopes. If the polytopes
don’t intersect, then the sphere is in one and only one polytope.
Otherwise the sphere is in at least one of the polytopes (could be in
the intersection of multiple polytopes.) If the i’th polytope is
described as</p>
<p>Aᵢ * x ≤ bᵢ where Aᵢ ∈ ℝⁿ ˣ ³, bᵢ ∈ ℝⁿ. Then a sphere with center
position p_WQ and radius r is within the i’th polytope, if</p>
<p>Aᵢ * p_WQ ≤ bᵢ - aᵢr where aᵢ(j) = Aᵢ.row(j).norm() To constrain that
the sphere is in one of the n polytopes, we introduce the binary
variable z ∈{0, 1}ⁿ, together with continuous variables yᵢ ∈ ℝ³, i =
1, …, n, such that p_WQ = y₁ + … + yₙ Aᵢ * yᵢ ≤ (bᵢ - aᵢr)zᵢ z₁ +
… +zₙ = 1 Notice that when zᵢ = 0, Aᵢ * yᵢ ≤ 0 implies that yᵢ = 0.
This is due to the boundedness of the polytope. If Aᵢ * yᵢ ≤ 0 has a
non-zero solution y̅, that y̅ ≠ 0 and Aᵢ * y̅ ≤ 0. Then for any point
x̂ in the polytope satisfying Aᵢ * x̂ ≤ bᵢ, we know the ray x̂ + ty̅,
∀ t ≥ 0 also satisfies Aᵢ * (x̂ + ty̅) ≤ bᵢ, thus the ray is within
the polytope, violating the boundedness assumption.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_index</span></code>:</dt><dd><p>The index of the body to which the sphere is attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BQ</span></code>:</dt><dd><p>The position of the sphere center in the body frame B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">radius</span></code>:</dt><dd><p>The radius of the sphere.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">polytopes</span></code>:</dt><dd><p>polytopes[i] = (Aᵢ, bᵢ). We assume that Aᵢx≤ bᵢ is a bounded
polytope. It is the user’s responsibility to guarantee the
boundedness.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">z</span></code>:</dt><dd><p>The newly added binary variables. If z(i) = 1, then the sphere is
in the i’th polytope. If two or more polytopes are intersecting,
and the sphere is in the intersection region, then it is up to the
solver to choose one of z(i) to be 1.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GlobalInverseKinematics.get_mutable_prog(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.GlobalInverseKinematics)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.MathematicalProgram</span></span></dt>
<dd></dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GlobalInverseKinematics.Options</span></span></dt>
<dd><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GlobalInverseKinematics.Options.__init__(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.GlobalInverseKinematics.Options)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GlobalInverseKinematics.Options.approach</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GlobalInverseKinematics.Options.interval_binning</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GlobalInverseKinematics.Options.linear_constraint_only</span></span></dt>
<dd><p>If true, add only mixed-integer linear constraints in the constructor
of GlobalInverseKinematics. The mixed-integer relaxation is tighter
with nonlinear constraints (such as Lorentz cone constraint) than with
linear constraints, but the optimization takes more time with
nonlinear constraints.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GlobalInverseKinematics.Options.num_intervals_per_half_axis</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GlobalInverseKinematics.Polytope3D</span></span></dt>
<dd><p>Describes a polytope in 3D as 𝐀 * 𝐱 ≤ 𝐛 (a set of half-spaces), where
𝐀 ∈ ℝⁿˣ³, 𝐱 ∈ ℝ³, 𝐛 ∈ ℝⁿ.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GlobalInverseKinematics.Polytope3D.__init__(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.GlobalInverseKinematics.Polytope3D,</span> <span class="pre">A:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">3],</span> <span class="pre">flags.f_contiguous],</span> <span class="pre">b:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GlobalInverseKinematics.Polytope3D.A</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GlobalInverseKinematics.Polytope3D.b</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GlobalInverseKinematics.prog(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.GlobalInverseKinematics)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.MathematicalProgram</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GlobalInverseKinematics.ReconstructGeneralizedPositionSolution(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.GlobalInverseKinematics,</span> <span class="pre">result:</span> <span class="pre">pydrake.solvers.MathematicalProgramResult)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>After solving the inverse kinematics problem and finding out the pose
of each body, reconstruct the robot generalized position (joint
angles, etc) that matches with the body poses. Notice that since the
rotation matrix is approximated, that the solution of body_rotmat()
might not be on SO(3) exactly, the reconstructed body posture might
not match with the body poses exactly, and the kinematics constraint
might not be satisfied exactly with this reconstructed posture.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Do not call this method if the problem is not solved successfully!
The returned value can be NaN or meaningless number if the problem
is not solved.</p>
</div>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">q</span></code>:</dt><dd><p>The reconstructed posture of the robot of the generalized
coordinates, corresponding to the RigidBodyTree on which the
inverse kinematics problem is solved.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GlobalInverseKinematics.SetInitialGuess(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.GlobalInverseKinematics,</span> <span class="pre">q:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets an initial guess for all variables (including the binary
variables) by evaluating the kinematics of the plant at <code class="docutils literal notranslate"><span class="pre">q</span></code>.
Currently, this is accomplished by solving the global IK problem
subject to constraints that the positions and rotation matrices match
the kinematics, which is dramatically faster than solving the original
problem.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if solving results in an infeasible program.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InverseKinematics</span></span></dt>
<dd><p>Solves an inverse kinematics (IK) problem on a MultibodyPlant, to find
the postures of the robot satisfying certain constraints. The decision
variables include the generalized position of the robot.</p>
<p>To perform IK on a subset of the plant, use the constructor overload
that takes a <code class="docutils literal notranslate"><span class="pre">plant_context</span></code> and use <code class="docutils literal notranslate"><span class="pre">Joint::Lock</span></code> on the joints
in that Context that should be fixed during IK.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InverseKinematics.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.inverse_kinematics.InverseKinematics, plant: pydrake.multibody.plant.MultibodyPlant, with_joint_limits: bool = True) -&gt; None</p></li>
</ol>
<p>Constructs an inverse kinematics problem for a MultibodyPlant. This
constructor will create and own a context for <code class="docutils literal notranslate"><span class="pre">plant</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant</span></code>:</dt><dd><p>The robot on which the inverse kinematics problem will be solved.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_joint_limits</span></code>:</dt><dd><p>If set to true, then the constructor imposes the joint limits
(obtained from plant.GetPositionLowerLimits() and
plant.GetPositionUpperLimits()). If set to false, then the
constructor does not impose the joint limit constraints in the
constructor.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The inverse kinematics problem constructed in this way doesn’t
permit collision related constraint (such as calling
AddMinimumDistanceConstraint). To enable collision related
constraint, call InverseKinematics(const MultibodyPlant&lt;double&gt;&amp;
plant, systems::Context&lt;double&gt;* plant_context);</p>
</div>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.inverse_kinematics.InverseKinematics, plant: pydrake.multibody.plant.MultibodyPlant, plant_context: pydrake.systems.framework.Context, with_joint_limits: bool = True) -&gt; None</p></li>
</ol>
<p>Constructs an inverse kinematics problem for a MultibodyPlant. If the
user wants to solve the problem with collision related constraint
(like calling AddMinimumDistanceConstraint), please use this
constructor.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant</span></code>:</dt><dd><p>The robot on which the inverse kinematics problem will be solved.
This plant should have been connected to a SceneGraph within a
Diagram</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant_context</span></code>:</dt><dd><p>The context for the plant. This context should be a part of the
Diagram context. Any locked joints in the <code class="docutils literal notranslate"><span class="pre">plant_context</span></code> will
remain fixed at their locked value. (This provides a convenient
way to perform IK on a subset of the plant.) To construct a plant
connected to a SceneGraph, with the corresponding plant_context,
the steps are:</p>
</dd>
</dl>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// 1. Add a diagram containing the MultibodyPlant and SceneGraph</span>
<span class="n">systems</span><span class="o">::</span><span class="n">DiagramBuilder</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">builder</span><span class="p">;</span>
<span class="k">auto</span><span class="w"> </span><span class="n">items</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">AddMultibodyPlantSceneGraph</span><span class="p">(</span><span class="o">&amp;</span><span class="n">builder</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0</span><span class="p">);</span>
<span class="c1">// 2. Add collision geometries to the plant</span>
<span class="n">Parser</span><span class="p">(</span><span class="o">&amp;</span><span class="n">builder</span><span class="p">).</span><span class="n">AddModels</span><span class="p">(</span><span class="s">&quot;model.sdf&quot;</span><span class="p">);</span>
<span class="c1">// 3. Construct the diagram</span>
<span class="k">auto</span><span class="w"> </span><span class="n">diagram</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">builder</span><span class="p">.</span><span class="n">Build</span><span class="p">();</span>
<span class="c1">// 4. Create diagram context.</span>
<span class="k">auto</span><span class="w"> </span><span class="n">diagram_context</span><span class="o">=</span><span class="w"> </span><span class="n">diagram</span><span class="o">-&gt;</span><span class="n">CreateDefaultContext</span><span class="p">();</span>
<span class="c1">// 5. Get the context for the plant.</span>
<span class="k">auto</span><span class="w"> </span><span class="n">plant_context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="p">(</span><span class="n">diagram</span><span class="o">-&gt;</span><span class="n">GetMutableSubsystemContext</span><span class="p">(</span><span class="n">items</span><span class="p">.</span><span class="n">plant</span><span class="p">,</span>
<span class="n">diagram_context</span><span class="p">.</span><span class="n">get</span><span class="p">()));</span>
</pre></div>
</div>
</details><p>This context will be modified during calling ik.prog.Solve(…). When
Solve() returns <code class="docutils literal notranslate"><span class="pre">result</span></code>, context will store the optimized posture,
namely plant.GetPositions(<a href="#id3"><span class="problematic" id="id4">*</span></a>context) will be the same as in
result.GetSolution(ik.q()). The user could then use this context to
perform kinematic computation (like computing the position of the
end-effector etc.).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">with_joint_limits</span></code>:</dt><dd><p>If set to true, then the constructor imposes the joint limits
(obtained from plant.GetPositionLowerLimits() and
plant.GetPositionUpperLimits(), and from any body/joint locks set
in <code class="docutils literal notranslate"><span class="pre">plant_context</span></code>). If set to false, then the constructor does
not impose the joint limit constraints in the constructor.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InverseKinematics.AddAngleBetweenVectorsConstraint(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.InverseKinematics,</span> <span class="pre">frameA:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">na_A:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">frameB:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">nb_B:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">angle_lower:</span> <span class="pre">float,</span> <span class="pre">angle_upper:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.Binding[Constraint]</span></span></dt>
<dd><p>Constrains that the angle between a vector na and another vector nb is
between [θ_lower, θ_upper]. na is fixed to a frame A, while nb is
fixed to a frame B. Mathematically, if we denote na_unit_A as na
expressed in frame A after normalization (na_unit_A has unit length),
and nb_unit_B as nb expressed in frame B after normalization, the
constraint is cos(θ_upper) ≤ na_unit_Aᵀ * R_AB * nb_unit_B ≤
cos(θ_lower), where R_AB is the rotation matrix, representing the
orientation of frame B expressed in frame A.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameA</span></code>:</dt><dd><p>The frame to which na is fixed.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">na_A</span></code>:</dt><dd><p>The vector na fixed to frame A, expressed in frame A.</p>
</dd>
<dt>Precondition:</dt><dd><p>na_A should be a non-zero vector.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if na_A is close to zero.</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameB</span></code>:</dt><dd><p>The frame to which nb is fixed.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">nb_B</span></code>:</dt><dd><p>The vector nb fixed to frame B, expressed in frame B.</p>
</dd>
<dt>Precondition:</dt><dd><p>nb_B should be a non-zero vector.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if nb_B is close to zero.</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angle_lower</span></code>:</dt><dd><p>The lower bound on the angle between na and nb. It is denoted as
θ_lower in the documentation. <code class="docutils literal notranslate"><span class="pre">angle_lower</span></code> is in radians.</p>
</dd>
<dt>Precondition:</dt><dd><p>angle_lower &gt;= 0.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if angle_lower is negative.</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angle_upper</span></code>:</dt><dd><p>The upper bound on the angle between na and nb. it is denoted as
θ_upper in the class documentation. <code class="docutils literal notranslate"><span class="pre">angle_upper</span></code> is in radians.</p>
</dd>
<dt>Precondition:</dt><dd><p>angle_lower &lt;= angle_upper &lt;= pi.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if angle_upper is outside the bounds.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InverseKinematics.AddAngleBetweenVectorsCost(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.InverseKinematics,</span> <span class="pre">frameA:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">na_A:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">frameB:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">nb_B:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">c:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.Binding[Cost]</span></span></dt>
<dd><p>Add a cost c * (1-cosθ) where θ is the angle between the vector <code class="docutils literal notranslate"><span class="pre">na</span></code>
and <code class="docutils literal notranslate"><span class="pre">nb</span></code>. na is fixed to a frame A, while nb is fixed to a frame B.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameA</span></code>:</dt><dd><p>The frame to which na is fixed.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">na_A</span></code>:</dt><dd><p>The vector na fixed to frame A, expressed in frame A.</p>
</dd>
<dt>Precondition:</dt><dd><p>na_A should be a non-zero vector.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if na_A is close to zero.</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameB</span></code>:</dt><dd><p>The frame to which nb is fixed.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">nb_B</span></code>:</dt><dd><p>The vector nb fixed to frame B, expressed in frame B.</p>
</dd>
<dt>Precondition:</dt><dd><p>nb_B should be a non-zero vector.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if nb_B is close to zero.</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">c</span></code>:</dt><dd><p>The cost is c * (1-cosθ).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InverseKinematics.AddDistanceConstraint(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.InverseKinematics,</span> <span class="pre">geometry_pair:</span> <span class="pre">Tuple[pydrake.geometry.GeometryId],</span> <span class="pre">distance_lower:</span> <span class="pre">float,</span> <span class="pre">distance_upper:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.Binding[Constraint]</span></span></dt>
<dd><p>Adds the constraint that the distance between a pair of geometries is
within some bounds.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">geometry_pair</span></code>:</dt><dd><p>The pair of geometries between which the distance is constrained.
Notice that we only consider the distance between a static
geometry and a dynamic geometry, or a pair of dynamic geometries.
We don’t allow constraining the distance between two static
geometries.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">distance_lower</span></code>:</dt><dd><p>The lower bound on the distance.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">distance_upper</span></code>:</dt><dd><p>The upper bound on the distance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InverseKinematics.AddGazeTargetConstraint(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.InverseKinematics,</span> <span class="pre">frameA:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">p_AS:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">n_A:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">frameB:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">p_BT:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">cone_half_angle:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.Binding[Constraint]</span></span></dt>
<dd><p>Constrains a target point T to be within a cone K. The point T (“T”
stands for “target”) is fixed in a frame B, with position p_BT. The
cone originates from a point S (“S” stands for “source”), fixed in
frame A with position p_AS, with the axis of the cone being n, also
fixed in frame A. The half angle of the cone is θ. A common usage of
this constraint is that a camera should gaze at some target; namely
the target falls within a gaze cone, originating from the camera eye.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameA</span></code>:</dt><dd><p>The frame where the gaze cone is fixed to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_AS</span></code>:</dt><dd><p>The position of the cone source point S, measured and expressed in
frame A.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">n_A</span></code>:</dt><dd><p>The directional vector representing the center ray of the cone,
expressed in frame A.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">n_A</span></code> cannot be a zero vector.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError is n_A is close to a zero vector.</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameB</span></code>:</dt><dd><p>The frame where the target point T is fixed to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BT</span></code>:</dt><dd><p>The position of the target point T, measured and expressed in
frame B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">cone_half_angle</span></code>:</dt><dd><p>The half angle of the cone. We denote it as θ in the
documentation. <code class="docutils literal notranslate"><span class="pre">cone_half_angle</span></code> is in radians.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">0</span></code> &lt;= cone_half_angle &lt;= pi.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if cone_half_angle is outside</strong><strong> of </strong><strong>the bound.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InverseKinematics.AddMinimumDistanceLowerBoundConstraint(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.InverseKinematics,</span> <span class="pre">bound:</span> <span class="pre">float,</span> <span class="pre">influence_distance_offset:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0.01)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.Binding[Constraint]</span></span></dt>
<dd><p>Adds the constraint that the pairwise distance between objects should
be no smaller than <code class="docutils literal notranslate"><span class="pre">bound</span></code>. We consider the distance between pairs
of 1. Anchored (static) object and a dynamic object. 2. A dynamic
object and another dynamic object, if one is not the parent link of
the other.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">bound</span></code>:</dt><dd><p>The minimum allowed value, dₘᵢₙ, of the signed distance between
any candidate pair of geometries.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">influence_distance_offset</span></code>:</dt><dd><p>See MinimumDistanceLowerBoundConstraint for explanation.</p>
</dd>
<dt>Precondition:</dt><dd><p>The MultibodyPlant passed to the constructor of <code class="docutils literal notranslate"><span class="pre">this</span></code> has
registered its geometry with a SceneGraph.</p>
</dd>
<dt>Precondition:</dt><dd><p>0 &lt; <code class="docutils literal notranslate"><span class="pre">influence_distance_offset</span></code> &lt; ∞</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InverseKinematics.AddMinimumDistanceUpperBoundConstraint(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.InverseKinematics,</span> <span class="pre">bound:</span> <span class="pre">float,</span> <span class="pre">influence_distance_offset:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.Binding[Constraint]</span></span></dt>
<dd><p>Adds the constraint that at least one pair of geometries has distance
no larger than <code class="docutils literal notranslate"><span class="pre">bound</span></code>. We consider the distance between pairs of 1.
Anchored (static) object and a dynamic object. 2. A dynamic object and
another dynamic object, if one is not the parent link of the other.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">bound</span></code>:</dt><dd><p>The upper bound of the minimum signed distance between any
candidate pair of geometries. Notice this is NOT the upper bound
of every distance, but the upper bound of the smallest distance.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">influence_distance_offset</span></code>:</dt><dd><p>See MinimumDistanceUpperBoundConstraint for more details on
influence_distance_offset.</p>
</dd>
<dt>Precondition:</dt><dd><p>The MultibodyPlant passed to the constructor of <code class="docutils literal notranslate"><span class="pre">this</span></code> has
registered its geometry with a SceneGraph.</p>
</dd>
<dt>Precondition:</dt><dd><p>0 &lt; <code class="docutils literal notranslate"><span class="pre">influence_distance_offset</span></code> &lt; ∞</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InverseKinematics.AddOrientationConstraint(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.InverseKinematics,</span> <span class="pre">frameAbar:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">R_AbarA:</span> <span class="pre">pydrake.math.RotationMatrix,</span> <span class="pre">frameBbar:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">R_BbarB:</span> <span class="pre">pydrake.math.RotationMatrix,</span> <span class="pre">theta_bound:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.Binding[Constraint]</span></span></dt>
<dd><p>Constrains that the angle difference θ between the orientation of
frame A and the orientation of frame B to satisfy θ ≤ θ_bound. Frame A
is fixed to frame A_bar, with orientation R_AbarA measured in frame
A_bar. Frame B is fixed to frame B_bar, with orientation R_BbarB
measured in frame B_bar. The angle difference between frame A’s
orientation R_WA and B’s orientation R_WB is θ, (θ ∈ [0, π]), if there
exists a rotation axis a, such that rotating frame A by angle θ about
axis a aligns it with frame B. Namely R_AB = I + sinθ â + (1-cosθ)â²
(1) where R_AB is the orientation of frame B expressed in frame A. â
is the skew symmetric matrix of the rotation axis a. Equation (1) is
the Rodrigues formula that computes the rotation matrix from a
rotation axis a and an angle θ,
<a class="reference external" href="https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula">https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula</a> If the
users want frame A and frame B to align perfectly, they can set
θ_bound = 0. Mathematically, this constraint is imposed as trace(R_AB)
≥ 2cos(θ_bound) + 1 (1) To derive (1), using Rodrigues formula R_AB =
I + sinθ â + (1-cosθ)â² where trace(R_AB) = 2cos(θ) + 1 ≥
2cos(θ_bound) + 1</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameAbar</span></code>:</dt><dd><p>frame A_bar, the frame A is fixed to frame A_bar.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_AbarA</span></code>:</dt><dd><p>The orientation of frame A measured in frame A_bar.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameBbar</span></code>:</dt><dd><p>frame B_bar, the frame B is fixed to frame B_bar.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_BbarB</span></code>:</dt><dd><p>The orientation of frame B measured in frame B_bar.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta_bound</span></code>:</dt><dd><p>The bound on the angle difference between frame A’s orientation
and frame B’s orientation. It is denoted as θ_bound in the
documentation. <code class="docutils literal notranslate"><span class="pre">theta_bound</span></code> is in radians.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InverseKinematics.AddOrientationCost(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.InverseKinematics,</span> <span class="pre">frameAbar:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">R_AbarA:</span> <span class="pre">pydrake.math.RotationMatrix,</span> <span class="pre">frameBbar:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">R_BbarB:</span> <span class="pre">pydrake.math.RotationMatrix,</span> <span class="pre">c:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.Binding[Cost]</span></span></dt>
<dd><p>Adds a cost of the form <code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">*</span> <span class="pre">(1</span> <span class="pre">-</span> <span class="pre">cos(θ))</span></code>, where θ is the angle
between the orientation of frame A and the orientation of frame B, and
<code class="docutils literal notranslate"><span class="pre">c</span></code> is a cost scaling.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameAbar</span></code>:</dt><dd><p>A frame on the MultibodyPlant.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_AbarA</span></code>:</dt><dd><p>The rotation matrix describing the orientation of frame A relative
to Abar.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameBbar</span></code>:</dt><dd><p>A frame on the MultibodyPlant.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_BbarB</span></code>:</dt><dd><p>The rotation matrix describing the orientation of frame B relative
to Bbar.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">c</span></code>:</dt><dd><p>A scalar cost weight.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InverseKinematics.AddPointToLineDistanceConstraint(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.InverseKinematics,</span> <span class="pre">frame_point:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">p_B1P:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">frame_line:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">p_B2Q:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">n_B2:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">distance_lower:</span> <span class="pre">float,</span> <span class="pre">distance_upper:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.Binding[Constraint]</span></span></dt>
<dd><p>Add a constraint that the distance between point P attached to
frame_point (denoted as B1) and a line attached to frame_line (denoted
as B2) is within the range [distance_lower, distance_upper]. The line
passes through a point Q with a directional vector n.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_point</span></code>:</dt><dd><p>The frame to which P is attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_B1P</span></code>:</dt><dd><p>The position of P measured and expressed in frame_point.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_line</span></code>:</dt><dd><p>The frame to which the line is attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_B2Q</span></code>:</dt><dd><p>The position of Q measured and expressed in frame_line, the line
passes through Q.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">n_B2</span></code>:</dt><dd><p>The direction vector of the line measured and expressed in
frame_line.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">distance_lower</span></code>:</dt><dd><p>The lower bound on the distance.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">distance_upper</span></code>:</dt><dd><p>The upper bound on the distance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InverseKinematics.AddPointToPointDistanceConstraint(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.InverseKinematics,</span> <span class="pre">frame1:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">p_B1P1:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">frame2:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">p_B2P2:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">distance_lower:</span> <span class="pre">float,</span> <span class="pre">distance_upper:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.Binding[Constraint]</span></span></dt>
<dd><p>Add a constraint that the distance between point P1 attached to frame
1 and point P2 attached to frame 2 is within the range
[distance_lower, distance_upper].</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame1</span></code>:</dt><dd><p>The frame to which P1 is attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_B1P1</span></code>:</dt><dd><p>The position of P1 measured and expressed in frame 1.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame2</span></code>:</dt><dd><p>The frame to which P2 is attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_B2P2</span></code>:</dt><dd><p>The position of P2 measured and expressed in frame 2.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">distance_lower</span></code>:</dt><dd><p>The lower bound on the distance.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">distance_upper</span></code>:</dt><dd><p>The upper bound on the distance.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InverseKinematics.AddPolyhedronConstraint(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.InverseKinematics,</span> <span class="pre">frameF:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">frameG:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">p_GP:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous],</span> <span class="pre">A:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous],</span> <span class="pre">b:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.Binding[Constraint]</span></span></dt>
<dd><p>Adds the constraint that the position of P1, …, Pn satisfy A *
[p_FP1; p_FP2; …; p_FPn] &lt;= b.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameF</span></code>:</dt><dd><p>The frame in which the position P is measured and expressed</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameG</span></code>:</dt><dd><p>The frame in which the point P is rigidly attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_GP</span></code>:</dt><dd><p>p_GP.col(i) is the position of the i’th point Pi measured and
expressed in frame G.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">A</span></code>:</dt><dd><p>We impose the constraint A * [p_FP1; p_FP2; …; p_FPn] &lt;= b.</p>
</dd>
<dt>Precondition:</dt><dd><p>A.cols() = 3 * p_GP.cols().</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>:</dt><dd><p>We impose the constraint A * [p_FP1; p_FP2; …; p_FPn] &lt;= b.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InverseKinematics.AddPositionConstraint(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>AddPositionConstraint(self: pydrake.multibody.inverse_kinematics.InverseKinematics, frameB: pydrake.multibody.tree.Frame, p_BQ: numpy.ndarray[numpy.float64[3, 1]], frameA: pydrake.multibody.tree.Frame, p_AQ_lower: numpy.ndarray[numpy.float64[3, 1]], p_AQ_upper: numpy.ndarray[numpy.float64[3, 1]]) -&gt; pydrake.solvers.Binding[Constraint]</p></li>
</ol>
<p>Adds the kinematic constraint that a point Q, fixed in frame B, should
lie within a bounding box expressed in another frame A as p_AQ_lower
&lt;= p_AQ &lt;= p_AQ_upper, where p_AQ is the position of point Q measured
and expressed in frame A.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameB</span></code>:</dt><dd><p>The frame in which point Q is fixed.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BQ</span></code>:</dt><dd><p>The position of the point Q, rigidly attached to frame B, measured
and expressed in frame B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameA</span></code>:</dt><dd><p>The frame in which the bounding box p_AQ_lower &lt;= p_AQ &lt;=
p_AQ_upper is expressed.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_AQ_lower</span></code>:</dt><dd><p>The lower bound on the position of point Q, measured and expressed
in frame A.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_AQ_upper</span></code>:</dt><dd><p>The upper bound on the position of point Q, measured and expressed
in frame A.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>AddPositionConstraint(self: pydrake.multibody.inverse_kinematics.InverseKinematics, frameB: pydrake.multibody.tree.Frame, p_BQ: numpy.ndarray[numpy.float64[3, 1]], frameAbar: pydrake.multibody.tree.Frame, X_AbarA: Optional[pydrake.math.RigidTransform], p_AQ_lower: numpy.ndarray[numpy.float64[3, 1]], p_AQ_upper: numpy.ndarray[numpy.float64[3, 1]]) -&gt; pydrake.solvers.Binding[Constraint]</p></li>
</ol>
<p>Adds the kinematic constraint that a point Q, fixed in frame B, should
lie within a bounding box expressed in another frame A as p_AQ_lower
&lt;= p_AQ &lt;= p_AQ_upper, where p_AQ is the position of point Q measured
and expressed in frame A.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameB</span></code>:</dt><dd><p>The frame in which point Q is fixed.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BQ</span></code>:</dt><dd><p>The position of the point Q, rigidly attached to frame B, measured
and expressed in frame B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameAbar</span></code>:</dt><dd><p>We will compute frame A from frame Abar. The bounding box
p_AQ_lower &lt;= p_AQ &lt;= p_AQ_upper is expressed in frame A.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_AbarA</span></code>:</dt><dd><p>The relative transform between frame Abar and A. If empty, then we
use the identity transform.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_AQ_lower</span></code>:</dt><dd><p>The lower bound on the position of point Q, measured and expressed
in frame A.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_AQ_upper</span></code>:</dt><dd><p>The upper bound on the position of point Q, measured and expressed
in frame A.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InverseKinematics.AddPositionCost(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.InverseKinematics,</span> <span class="pre">frameA:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">p_AP:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">frameB:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">p_BQ:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">C:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">3],</span> <span class="pre">flags.f_contiguous])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.Binding[Cost]</span></span></dt>
<dd><p>Adds a cost of the form (p_AP - p_AQ)ᵀ C (p_AP - p_AQ), where point P
is specified relative to frame A and point Q is specified relative to
frame B, and the cost is evaluated in frame A.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameA</span></code>:</dt><dd><p>The frame in which point P’s position is measured.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_AP</span></code>:</dt><dd><p>The point P.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameB</span></code>:</dt><dd><p>The frame in which point Q’s position is measured.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BQ</span></code>:</dt><dd><p>The point Q.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">C</span></code>:</dt><dd><p>A 3x3 matrix representing the cost in quadratic form.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InverseKinematics.context(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.InverseKinematics)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.Context</span></span></dt>
<dd><p>Getter for the plant context.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InverseKinematics.get_mutable_context(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.InverseKinematics)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.Context</span></span></dt>
<dd><p>Getter for the mutable plant context.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InverseKinematics.get_mutable_prog(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.InverseKinematics)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.MathematicalProgram</span></span></dt>
<dd><p>Getter for the optimization program constructed by InverseKinematics.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InverseKinematics.prog(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.InverseKinematics)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.solvers.MathematicalProgram</span></span></dt>
<dd><p>Getter for the optimization program constructed by InverseKinematics.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">InverseKinematics.q(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.InverseKinematics)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Getter for q. q is the decision variable for the generalized positions
of the robot.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MinimumDistanceLowerBoundConstraint</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Constraint</span></code></p>
<p>Constrain min(d) &gt;= lb, namely the signed distance between all
candidate pairs of geometries (according to the logic of
SceneGraphInspector::GetCollisionCandidates()) to be no smaller than a
specified minimum distance lb. This constraint should be bound to
decision variables corresponding to the configuration vector, q, of
the associated MultibodyPlant.</p>
<p>The formulation of the constraint is</p>
<p>SmoothOverMax( φ((dᵢ(q) - d_influence)/(d_influence - lb)) / φ(-1) ) ≤
1</p>
<p>where dᵢ(q) is the signed distance of the i-th pair, lb is the minimum
allowable distance, d_influence is the “influence distance” (the
distance below which a pair of geometries influences the constraint),
φ is a solvers::MinimumValuePenaltyFunction. SmoothOverMax(d) is
smooth over approximation of max(d). We require that lb &lt; d_influence.
The input scaling (dᵢ(q) - d_influence)/(d_influence - lb) ensures
that at the boundary of the feasible set (when dᵢ(q) == lb), we
evaluate the penalty function at -1, where it is required to have a
non-zero gradient.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MinimumDistanceLowerBoundConstraint.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.inverse_kinematics.MinimumDistanceLowerBoundConstraint, plant: pydrake.multibody.plant.MultibodyPlant, bound: float, plant_context: pydrake.systems.framework.Context, penalty_function: Callable[[float, bool], tuple] = None, influence_distance_offset: float = 0.01) -&gt; None</p></li>
</ol>
<p>Constructs a MinimumDistanceLowerBoundConstraint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant</span></code>:</dt><dd><p>The multibody system on which the constraint will be evaluated.
<code class="docutils literal notranslate"><span class="pre">plant</span></code> cannot be a nullptr. <code class="docutils literal notranslate"><span class="pre">plant</span></code> must outlive this
constraint.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">bound</span></code>:</dt><dd><p>The minimum allowed value, lb, of the signed distance between any
candidate pair of geometries.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">penalty_function</span></code>:</dt><dd><p>The penalty function formulation.</p>
</dd>
<dt><em>Default:</em> QuadraticallySmoothedHinge</dt><dd><p>$Parameter <code class="docutils literal notranslate"><span class="pre">plant_context</span></code>:</p>
</dd>
</dl>
<p>The context of <code class="docutils literal notranslate"><span class="pre">plant</span></code>. The context should be obtained as a
subsystem context from the diagram context, where the diagram (that
contains both the MultibodyPlant and SceneGraph) creates the diagram
context. <code class="docutils literal notranslate"><span class="pre">plant_context</span></code> cannot be a nullptr. <code class="docutils literal notranslate"><span class="pre">plant_context</span></code> must
outlive this constraint. An example code of getting the plant context
is</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">cc</span><span class="p">}</span>
<span class="k">auto</span><span class="w"> </span><span class="n">diagram_context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">diagram</span><span class="p">.</span><span class="n">CreateDefaultContext</span><span class="p">();</span>
<span class="k">auto</span><span class="w"> </span><span class="n">plant_context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">GetMyMutableContextFromRoot</span><span class="p">(</span><span class="n">diagram_context</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
</pre></div>
</div>
</details><dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">influence_distance_offset</span></code>:</dt><dd><p>The difference (in meters) between the influence distance,
d_influence, and the minimum distance, lb (see class
documentation), namely influence_distance = bound +
influence_distance_offset. This value must be finite and strictly
positive, as it is used to scale the signed distances between
pairs of geometries. Smaller values may improve performance, as
fewer pairs of geometries need to be considered in each constraint
evaluation. $*Default:* 0.01 meter. The chosen
influence_distance_offset can significantly affect the runtime and
optimization performance of using this constraint. Larger values
result in more expensive collision checks (since more potential
collision candidates must be considered) and may result in worse
optimization performance (the optimizer may not be able to find a
configuration that satisfies the constraint). In work at TRI, we
have used much lower values (e.g. 1e-6) for
influence_distance_offset with good results.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if plant has not registered its geometry with a</strong> – </p></li>
<li><p><strong>SceneGraph object.</strong> – </p></li>
<li><p><strong>RuntimeError if influence_distance_offset = ∞.</strong> – </p></li>
<li><p><strong>RuntimeError if influence_distance_offset ≤ 0.The penalty function `penalty_function</strong><strong>(</strong><strong>x</strong> – <p>float, compute_grad: bool) -&gt; tuple[float, Optional[float]]` returns <cite>[penalty_val,  penalty_gradient]</cite> when <cite>compute_grad=True</cite>, or <cite>[penalty_value, None]</cite> when <cite>compute_grad=False</cite>. See minimum_value_constraint.h on the requirement on MinimumValuePenaltyFunction. Set penalty_function=None and then the constraint will use the default penalty function.</p>
</p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.inverse_kinematics.MinimumDistanceLowerBoundConstraint, plant: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], bound: float, plant_context: pydrake.systems.framework.Context_[AutoDiffXd], penalty_function: Callable[[float, bool], tuple] = None, influence_distance_offset: float = 0.01) -&gt; None</p></li>
</ol>
<p>Overloaded constructor. Constructs the constraint using
MultibodyPlant&lt;AutoDiffXd&gt;.The penalty function <cite>penalty_function(x: float, compute_grad: bool) -&gt; tuple[float, Optional[float]]</cite> returns <cite>[penalty_val,  penalty_gradient]</cite> when <cite>compute_grad=True</cite>, or <cite>[penalty_value, None]</cite> when <cite>compute_grad=False</cite>. See minimum_value_constraint.h on the requirement on MinimumValuePenaltyFunction. Set penalty_function=None and then the constraint will use the default penalty function.</p>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.multibody.inverse_kinematics.MinimumDistanceLowerBoundConstraint, collision_checker: pydrake.planning.CollisionChecker, bound: float, collision_checker_context: pydrake.planning.CollisionCheckerContext, penalty_function: Callable[[float, bool], tuple] = None, influence_distance_offset: float = 0.01) -&gt; None</p></li>
</ol>
<p>Overloaded constructor. Constructs the constraint with
CollisionChecker instead of MultibodyPlant.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">collision_checker</span></code>:</dt><dd><p>collision_checker must outlive this constraint.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">collision_checker_context</span></code>:</dt><dd><p>The context for the collision checker. See CollisionChecker class
for more details.The penalty function <cite>penalty_function(x: float, compute_grad: bool) -&gt; tuple[float, Optional[float]]</cite> returns <cite>[penalty_val,  penalty_gradient]</cite> when <cite>compute_grad=True</cite>, or <cite>[penalty_value, None]</cite> when <cite>compute_grad=False</cite>. See minimum_value_constraint.h on the requirement on MinimumValuePenaltyFunction. Set penalty_function=None and then the constraint will use the default penalty function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MinimumDistanceLowerBoundConstraint.distance_bound(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.MinimumDistanceLowerBoundConstraint)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Getter for the lower bound of the minimum distance.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MinimumDistanceLowerBoundConstraint.influence_distance(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.MinimumDistanceLowerBoundConstraint)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Getter for the influence distance.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MinimumDistanceUpperBoundConstraint</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Constraint</span></code></p>
<p>Constrain min(d) &lt;= ub, namely at least one signed distance between a
candidate pairs of geometries (according to the logic of
SceneGraphInspector::GetCollisionCandidates()) to be no larger than a
specified ub. This constraint should be bound to decision variables
corresponding to the configuration vector, q, of the associated
MultibodyPlant.</p>
<p>The formulation of the constraint is</p>
<p>SmoothUnderMax( φ((dᵢ(q) - d_influence)/(d_influence - ub)) / φ(-1) )
≥ 1</p>
<p>where dᵢ(q) is the signed distance of the i-th pair, ub is the upper
bound of the minimum distance, d_influence is the “influence distance”
(the distance below which a pair of geometries influences the
constraint), φ is a solvers::MinimumValuePenaltyFunction.
SmoothUnderMax(d) is smooth under approximation of max(d). We require
that ub &lt; d_influence. The input scaling (dᵢ(q) -
d_influence)/(d_influence - ub) ensures that at the boundary of the
feasible set (when dᵢ(q) == ub), we evaluate the penalty function at
-1, where it is required to have a non-zero gradient.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MinimumDistanceUpperBoundConstraint.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.inverse_kinematics.MinimumDistanceUpperBoundConstraint, plant: pydrake.multibody.plant.MultibodyPlant, bound: float, plant_context: pydrake.systems.framework.Context, influence_distance_offset: float, penalty_function: Callable[[float, bool], tuple] = None) -&gt; None</p></li>
</ol>
<p>Constructs a MinimumDistanceUpperBoundConstraint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant</span></code>:</dt><dd><p>The multibody system on which the constraint will be evaluated.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">bound</span></code>:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">ub</span></code> in the class documentation. The upper bound minimum signed
distance between any candidate pair of geometries.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant_context</span></code>:</dt><dd><p>The context of <code class="docutils literal notranslate"><span class="pre">plant</span></code>. The context should be obtained as a
subsystem context from the diagram context, where the diagram
(that contains both the MultibodyPlant and SceneGraph) creates the
diagram context. <code class="docutils literal notranslate"><span class="pre">plant_context</span></code> cannot be a nullptr.
<code class="docutils literal notranslate"><span class="pre">plant_context</span></code> must outlive this constraint. An example code of
getting the plant context is</p>
</dd>
</dl>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="n">cc</span><span class="p">}</span>
<span class="k">auto</span><span class="w"> </span><span class="n">diagram_context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">diagram</span><span class="p">.</span><span class="n">CreateDefaultContext</span><span class="p">();</span>
<span class="k">auto</span><span class="w"> </span><span class="n">plant_context</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">plant</span><span class="p">.</span><span class="n">GetMyMutableContextFromRoot</span><span class="p">(</span><span class="n">diagram_context</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
</pre></div>
</div>
</details><dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">penalty_function</span></code>:</dt><dd><p>The penalty function formulation.</p>
</dd>
<dt><em>Default:</em> QuadraticallySmoothedHinge</dt><dd><p>$Parameter <code class="docutils literal notranslate"><span class="pre">influence_distance_offset</span></code>:</p>
</dd>
</dl>
<p>The difference (in meters) between the influence distance,
d_influence, and the minimum distance_upper, ub (see class
documentation), namely influence_distance = bound +
influence_distance_offset. This value must be finite and strictly
positive, as it is used to scale the signed distances between pairs of
geometries. Larger value might increase the possibility of finding a
solution through gradient based nonlinear optimization. This is
because a geometry pair with distance larger than
<code class="docutils literal notranslate"><span class="pre">influence_distance</span></code> is ignored, so is its gradient; hence the
gradient-based optimizer doesn’t know to actively reduce the distance
between that pair. We strongly suggest to use a different (and larger)
<code class="docutils literal notranslate"><span class="pre">influence_distance_offset</span></code> as the one used in
MinimumValueLowerBoundConstraint.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if plant has not registered its geometry with a</strong> – </p></li>
<li><p><strong>SceneGraph object.</strong> – </p></li>
<li><p><strong>RuntimeError if influence_distance_offset = ∞.</strong> – </p></li>
<li><p><strong>RuntimeError if influence_distance_offset ≤ 0.The penalty function `penalty_function</strong><strong>(</strong><strong>x</strong> – <p>float, compute_grad: bool) -&gt; tuple[float, Optional[float]]` returns <cite>[penalty_val,  penalty_gradient]</cite> when <cite>compute_grad=True</cite>, or <cite>[penalty_value, None]</cite> when <cite>compute_grad=False</cite>. See minimum_value_constraint.h on the requirement on MinimumValuePenaltyFunction. Set <cite>penalty_function=None</cite> and then the constraint will use the default penalty function.</p>
</p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.inverse_kinematics.MinimumDistanceUpperBoundConstraint, plant: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], bound: float, plant_context: pydrake.systems.framework.Context_[AutoDiffXd], influence_distance_offset: float, penalty_function: Callable[[float, bool], tuple] = None) -&gt; None</p></li>
</ol>
<p>Overloaded constructor. Constructs the constraint using
MultibodyPlant&lt;AutoDiffXd&gt;.The penalty function <cite>penalty_function(x: float, compute_grad: bool) -&gt; tuple[float, Optional[float]]</cite> returns <cite>[penalty_val,  penalty_gradient]</cite> when <cite>compute_grad=True</cite>, or <cite>[penalty_value, None]</cite> when <cite>compute_grad=False</cite>. See minimum_value_constraint.h on the requirement on MinimumValuePenaltyFunction. Set <cite>penalty_function=None</cite> and then the constraint will use the default penalty function.</p>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.multibody.inverse_kinematics.MinimumDistanceUpperBoundConstraint, collision_checker: pydrake.planning.CollisionChecker, bound: float, collision_checker_context: pydrake.planning.CollisionCheckerContext, influence_distance_offset: float, penalty_function: Callable[[float, bool], tuple] = None) -&gt; None</p></li>
</ol>
<p>Overloaded constructor. Constructs the constraint with
CollisionChecker instead of MultibodyPlant.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">collision_checker</span></code>:</dt><dd><p>collision_checker must outlive this constraint.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">collision_checker_context</span></code>:</dt><dd><p>The context for the collision checker. See CollisionChecker class
for more details.The penalty function <cite>penalty_function(x: float, compute_grad: bool) -&gt; tuple[float, Optional[float]]</cite> returns <cite>[penalty_val,  penalty_gradient]</cite> when <cite>compute_grad=True</cite>, or <cite>[penalty_value, None]</cite> when <cite>compute_grad=False</cite>. See minimum_value_constraint.h on the requirement on MinimumValuePenaltyFunction. Set <cite>penalty_function=None</cite> and then the constraint will use the default penalty function.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MinimumDistanceUpperBoundConstraint.distance_bound(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.MinimumDistanceUpperBoundConstraint)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Getter for the upper bound of the minimum distance.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MinimumDistanceUpperBoundConstraint.influence_distance(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.MinimumDistanceUpperBoundConstraint)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Getter for the influence distance.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OrientationConstraint</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Constraint</span></code></p>
<p>Constrains that the angle difference θ between the orientation of
frame A and the orientation of frame B to satisfy θ ≤ θ_bound. The
angle difference between frame A’s orientation R_WA and B’s
orientation R_WB is θ (θ ∈ [0, π]), if there exists a rotation axis a,
such that rotating frame A by angle θ about axis a aligns it with
frame B. Namely R_AB = I + sinθ â + (1-cosθ)â² (1) where R_AB is the
orientation of frame B expressed in frame A. â is the skew symmetric
matrix of the rotation axis a. Equation (1) is the Rodrigues formula
that computes the rotation matrix froma rotation axis a and an angle
θ, <a class="reference external" href="https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula">https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula</a> If the
users want frame A and frame B to align perfectly, they can set
θ_bound = 0. Mathematically, this constraint is imposed as trace(R_AB)
≥ 2cos(θ_bound) + 1 (1) To derive (1), using Rodrigues formula R_AB =
I + sinθ â + (1-cosθ)â² where trace(R_AB) = 2cos(θ) + 1 ≥
2cos(θ_bound) + 1</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OrientationConstraint.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.inverse_kinematics.OrientationConstraint, plant: pydrake.multibody.plant.MultibodyPlant, frameAbar: pydrake.multibody.tree.Frame, R_AbarA: pydrake.math.RotationMatrix, frameBbar: pydrake.multibody.tree.Frame, R_BbarB: pydrake.math.RotationMatrix, theta_bound: float, plant_context: pydrake.systems.framework.Context) -&gt; None</p></li>
</ol>
<p>Constructs an OrientationConstraint object. The frame A is fixed to a
frame A̅, with orientatation <code class="docutils literal notranslate"><span class="pre">R_AbarA</span></code> measured in frame A̅. The
frame B is fixed to a frame B̅, with orientation <code class="docutils literal notranslate"><span class="pre">R_BbarB</span></code> measured
in frame B. We constrain the angle between frame A and B to be less
than <code class="docutils literal notranslate"><span class="pre">theta_bound</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant</span></code>:</dt><dd><p>The MultibodyPlant on which the constraint is imposed. <code class="docutils literal notranslate"><span class="pre">plant</span></code>
should be alive during the lifetime of this constraint.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameAbar</span></code>:</dt><dd><p>The frame A̅ in the model to which frame A is fixed.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_AbarA</span></code>:</dt><dd><p>The orientation of frame A measured in frame A̅.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameBbar</span></code>:</dt><dd><p>The frame B̅ in the model to which frame B is fixed.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_BbarB</span></code>:</dt><dd><p>The orientation of frame B measured in frame B̅.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta_bound</span></code>:</dt><dd><p>The bound on the angle difference between frame A’s orientation
and frame B’s orientation. It is denoted as θ_bound in the class
documentation. <code class="docutils literal notranslate"><span class="pre">theta_bound</span></code> is in radians.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant_context</span></code>:</dt><dd><p>The Context that has been allocated for this <code class="docutils literal notranslate"><span class="pre">plant</span></code>. We will
update the context when evaluating the constraint.
<code class="docutils literal notranslate"><span class="pre">plant_context</span></code> should be alive during the lifetime of this
constraint.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if plant is nullptr.</strong> – </p></li>
<li><p><strong>RuntimeError if frameAbar</strong><strong> or </strong><strong>frameBbar does not belong to</strong> – </p></li>
<li><p><strong>plant`</strong> – </p></li>
<li><p><strong>RuntimeError if angle_bound &lt; 0.</strong> – </p></li>
<li><p><strong>RuntimeError if plant_context is nullptr.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.inverse_kinematics.OrientationConstraint, plant: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], frameAbar: pydrake.multibody.tree.Frame_[AutoDiffXd], R_AbarA: pydrake.math.RotationMatrix, frameBbar: pydrake.multibody.tree.Frame_[AutoDiffXd], R_BbarB: pydrake.math.RotationMatrix, theta_bound: float, plant_context: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Overloaded constructor. Constructs the constraint using
MultibodyPlant&lt;AutoDiffXd&gt;</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OrientationCost</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Cost</span></code></p>
<p>Implements a cost of the form <code class="docutils literal notranslate"><span class="pre">c</span> <span class="pre">*</span> <span class="pre">(1</span> <span class="pre">-</span> <span class="pre">cos(θ))</span></code>, where θ is the
angle between the orientation of frame A and the orientation of frame
B, and <code class="docutils literal notranslate"><span class="pre">c</span></code> is a cost scaling.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">OrientationCost.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.inverse_kinematics.OrientationCost, plant: pydrake.multibody.plant.MultibodyPlant, frameAbar: pydrake.multibody.tree.Frame, R_AbarA: pydrake.math.RotationMatrix, frameBbar: pydrake.multibody.tree.Frame, R_BbarB: pydrake.math.RotationMatrix, c: float, plant_context: pydrake.systems.framework.Context) -&gt; None</p></li>
</ol>
<p>Constructs OrientationCost object.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant</span></code>:</dt><dd><p>The MultibodyPlant on which the cost is implemented. <code class="docutils literal notranslate"><span class="pre">plant</span></code>
should be alive during the lifetime of this cost.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameAbar</span></code>:</dt><dd><p>A frame on the MultibodyPlant.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_AbarA</span></code>:</dt><dd><p>The rotation matrix describing the orientation of frame A relative
to Abar.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameBbar</span></code>:</dt><dd><p>A frame on the MultibodyPlant.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_BbarB</span></code>:</dt><dd><p>The rotation matrix describing the orientation of frame B relative
to Bbar.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">c</span></code>:</dt><dd><p>A scalar cost weight.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant_context</span></code>:</dt><dd><p>A context for the <code class="docutils literal notranslate"><span class="pre">plant</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if plant is nullptr.</strong> – </p></li>
<li><p><strong>RuntimeError if plant_context is nullptr.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.inverse_kinematics.OrientationCost, plant: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], frameAbar: pydrake.multibody.tree.Frame_[AutoDiffXd], R_AbarA: pydrake.math.RotationMatrix, frameBbar: pydrake.multibody.tree.Frame_[AutoDiffXd], R_BbarB: pydrake.math.RotationMatrix, c: float, plant_context: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Overloaded constructor. Same as the constructor with the double
version (using MultibodyPlant&lt;double&gt; and Context&lt;double&gt;). Except the
gradient of the cost is computed from autodiff.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PointToLineDistanceConstraint</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Constraint</span></code></p>
<p>Constrain that the distance between a point P on frame B1 and another
line L on frame B2 is within a range [distance_lower, distance_upper].</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PointToLineDistanceConstraint.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.inverse_kinematics.PointToLineDistanceConstraint, plant: pydrake.multibody.plant.MultibodyPlant, frame_point: pydrake.multibody.tree.Frame, p_B1P: numpy.ndarray[numpy.float64[3, 1]], frame_line: pydrake.multibody.tree.Frame, p_B2Q: numpy.ndarray[numpy.float64[3, 1]], n_B2: numpy.ndarray[numpy.float64[3, 1]], distance_lower: float, distance_upper: float, plant_context: pydrake.systems.framework.Context) -&gt; None</p></li>
</ol>
<p>Constrain the distance between a point P attached to frame_point
(denoted as B1) and the line L attached to frame_line (denoted as B2)
is within the range [distance_lower, distance_upper].</p>
<p>Mathematically, we impose the constraint distance_lower² &lt;=
distance(P, L)² &lt;= distance_upper². We impose the constraint on the
distance square instead of distance directly, because the gradient of
distance is not well defined at distance=0; on the other hand, the
gradient of the distance square is well defined everywhere.</p>
<p>We parameterize the line using a point Q on the line, and a
directional vector n along the line.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant</span></code>:</dt><dd><p>The MultibodyPlant on which the constraint is imposed. <code class="docutils literal notranslate"><span class="pre">plant</span></code>
must be alive during the lifetime of this constraint.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_point</span></code>:</dt><dd><p>The frame B1 to which the point P is attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_B1P</span></code>:</dt><dd><p>The position of point P measured and expressed in B1.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_line</span></code>:</dt><dd><p>The frame B2 to which the line is attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_B2Q</span></code>:</dt><dd><p>Q is a point on the line, p_B2Q is the position of this point Q
measured and expressed in B2.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">n_B2</span></code>:</dt><dd><p>n is the directional vector of the line, n_B2 is this vector
measured and expressed in B2.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">distance_lower</span></code>:</dt><dd><p>The lower bound on the distance, must be non-negative.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">distance_upper</span></code>:</dt><dd><p>The upper bound on the distance, must be non-negative.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant_context</span></code>:</dt><dd><p>The Context that has been allocated for this <code class="docutils literal notranslate"><span class="pre">plant</span></code>. We will
update the context when evaluating the constraint.
<code class="docutils literal notranslate"><span class="pre">plant_context</span></code> must be alive during the lifetime of this
constraint.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.inverse_kinematics.PointToLineDistanceConstraint, plant: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], frame_point: pydrake.multibody.tree.Frame_[AutoDiffXd], p_B1P: numpy.ndarray[numpy.float64[3, 1]], frame_line: pydrake.multibody.tree.Frame_[AutoDiffXd], p_B2Q: numpy.ndarray[numpy.float64[3, 1]], n_B2: numpy.ndarray[numpy.float64[3, 1]], distance_lower: float, distance_upper: float, plant_context: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Overloaded constructor. Same as the constructor with the double
version (using MultibodyPlant&lt;double&gt; and Context&lt;double&gt;), except the
gradient of the constraint is computed from autodiff.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PointToPointDistanceConstraint</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Constraint</span></code></p>
<p>Constrain that the distance between a point P1 on frame B1 and another
point P2 on frame B2 is within a range [distance_lower,
distance_upper].</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PointToPointDistanceConstraint.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.inverse_kinematics.PointToPointDistanceConstraint, plant: pydrake.multibody.plant.MultibodyPlant, frame1: pydrake.multibody.tree.Frame, p_B1P1: numpy.ndarray[numpy.float64[3, 1]], frame2: pydrake.multibody.tree.Frame, p_B2P2: numpy.ndarray[numpy.float64[3, 1]], distance_lower: float, distance_upper: float, plant_context: pydrake.systems.framework.Context) -&gt; None</p></li>
</ol>
<p>Constrain that the distance between a point P1 attached to frame B1
and another point P2 attached to frame B2 is within the range
[distance_lower, distance_upper]. Mathematically, we impose the
constraint distance_lower² &lt;= distance(P1, P2)² &lt;= distance_upper². We
impose the constraint on the distance square instead of distance
directly, because the gradient of distance is not well defined at
distance=0, the gradient of the distance square is well defined
everywhere.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant</span></code>:</dt><dd><p>The MultibodyPlant on which the constraint is imposed. <code class="docutils literal notranslate"><span class="pre">plant</span></code>
should be alive during the lifetime of this constraint.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame1</span></code>:</dt><dd><p>The frame in which P1 is attached to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_B1P1</span></code>:</dt><dd><p>The position of P1 measured and expressed in B1.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame2</span></code>:</dt><dd><p>The frame in which P2 is attached to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_B2P2</span></code>:</dt><dd><p>The position of P2 measured and expressed in B2.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">distance_lower</span></code>:</dt><dd><p>The lower bound on the distance, must be non-negative.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">distance_upper</span></code>:</dt><dd><p>The upper bound on the distance, must be non-negative.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant_context</span></code>:</dt><dd><p>The Context that has been allocated for this <code class="docutils literal notranslate"><span class="pre">plant</span></code>. We will
update the context when evaluating the constraint.
<code class="docutils literal notranslate"><span class="pre">plant_context</span></code> should be alive during the lifetime of this
constraint.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.inverse_kinematics.PointToPointDistanceConstraint, plant: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], frame1: pydrake.multibody.tree.Frame_[AutoDiffXd], p_B1P1: numpy.ndarray[numpy.float64[3, 1]], frame2: pydrake.multibody.tree.Frame_[AutoDiffXd], p_B2P2: numpy.ndarray[numpy.float64[3, 1]], distance_lower: float, distance_upper: float, plant_context: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Overloaded constructor. Same as the constructor with the double
version (using MultibodyPlant&lt;double&gt; and Context&lt;double&gt;), except the
gradient of the constraint is computed from autodiff.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PolyhedronConstraint</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Constraint</span></code></p>
<p>Constrain the position of points P1, P2, …, Pn to satisfy the
constraint A * [p_FP1; p_FP2; …; p_FPn] &lt;= b, where p_FPi is the
position of point Pi measured and expressed in frame F. Notice the
constraint is imposed on the stacked column vector [p_FP1; p_FP2; …;
p_FPn], not on each individual point.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PolyhedronConstraint.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.inverse_kinematics.PolyhedronConstraint, plant: pydrake.multibody.plant.MultibodyPlant, frameF: pydrake.multibody.tree.Frame, frameG: pydrake.multibody.tree.Frame, p_GP: numpy.ndarray[numpy.float64[3, n], flags.f_contiguous], A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[m, 1]], plant_context: pydrake.systems.framework.Context) -&gt; None</p></li>
</ol>
<p>Construct the constraint that the position of P1, …, Pn satisfy A *
[p_FP1; p_FP2; …; p_FPn] &lt;= b.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant</span></code>:</dt><dd><p>The MultibodyPlant on which the constraint is imposed. <code class="docutils literal notranslate"><span class="pre">plant</span></code>
should be alive during the lifetime of this constraint.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameF</span></code>:</dt><dd><p>The frame in which the position P is measured and expressed</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameG</span></code>:</dt><dd><p>The frame in which the point P is rigidly attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_GP</span></code>:</dt><dd><p>p_GP.col(i) is the position of the i’th point Pi measured and
expressed in frame G.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">A</span></code>:</dt><dd><p>We impose the constraint A * [p_FP1; p_FP2; …; p_FPn] &lt;= b.</p>
</dd>
<dt>Precondition:</dt><dd><p>A.cols() = 3 * p_GP.cols();</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>:</dt><dd><p>We impose the constraint A * [p_FP1; p_FP2; …; p_FPn] &lt;= b</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant_context</span></code>:</dt><dd><p>The Context that has been allocated for this <code class="docutils literal notranslate"><span class="pre">plant</span></code>. We will
update the context when evaluating the constraint.
<code class="docutils literal notranslate"><span class="pre">plant_context</span></code> should be alive during the lifetime of this
constraint.</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.inverse_kinematics.PolyhedronConstraint, plant: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], frameF: pydrake.multibody.tree.Frame_[AutoDiffXd], frameG: pydrake.multibody.tree.Frame_[AutoDiffXd], p_GP: numpy.ndarray[numpy.float64[3, n], flags.f_contiguous], A: numpy.ndarray[numpy.float64[m, n], flags.f_contiguous], b: numpy.ndarray[numpy.float64[m, 1]], plant_context: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Overloaded constructor. Same as the constructor with the double
version (using MultibodyPlant&lt;double&gt; and Context&lt;double&gt;). Except the
gradient of the constraint is computed from autodiff.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PositionConstraint</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Constraint</span></code></p>
<p>Constrains the position of a point Q, rigidly attached to a frame B,
to be within a bounding box measured and expressed in frame A. Namely
p_AQ_lower &lt;= p_AQ &lt;= p_AQ_upper.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PositionConstraint.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.inverse_kinematics.PositionConstraint, plant: pydrake.multibody.plant.MultibodyPlant, frameA: pydrake.multibody.tree.Frame, p_AQ_lower: numpy.ndarray[numpy.float64[3, 1]], p_AQ_upper: numpy.ndarray[numpy.float64[3, 1]], frameB: pydrake.multibody.tree.Frame, p_BQ: numpy.ndarray[numpy.float64[3, 1]], plant_context: pydrake.systems.framework.Context) -&gt; None</p></li>
</ol>
<p>Constructs PositionConstraint object.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant</span></code>:</dt><dd><p>The MultibodyPlant on which the constraint is imposed. <code class="docutils literal notranslate"><span class="pre">plant</span></code>
should be alive during the lifetime of this constraint.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameA</span></code>:</dt><dd><p>The frame in which point Q’s position is measured.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_AQ_lower</span></code>:</dt><dd><p>The lower bound on the position of point Q, measured and expressed
in frame A.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_AQ_upper</span></code>:</dt><dd><p>The upper bound on the position of point Q, measured and expressed
in frame A.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameB</span></code>:</dt><dd><p>The frame to which point Q is rigidly attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BQ</span></code>:</dt><dd><p>The position of the point Q, rigidly attached to frame B, measured
and expressed in frame B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant_context</span></code>:</dt><dd><p>The Context that has been allocated for this <code class="docutils literal notranslate"><span class="pre">plant</span></code>. We will
update the context when evaluating the constraint.
<code class="docutils literal notranslate"><span class="pre">plant_context</span></code> should be alive during the lifetime of this
constraint.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">frameA</span></code> and <code class="docutils literal notranslate"><span class="pre">frameB</span></code> must belong to <code class="docutils literal notranslate"><span class="pre">plant</span></code>.</p>
</dd>
<dt>Precondition:</dt><dd><p>p_AQ_lower(i) &lt;= p_AQ_upper(i) for i = 1, 2, 3.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if plant is nullptr.</strong> – </p></li>
<li><p><strong>RuntimeError if plant_context is nullptr.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.inverse_kinematics.PositionConstraint, plant: pydrake.multibody.plant.MultibodyPlant, frameAbar: pydrake.multibody.tree.Frame, X_AbarA: Optional[pydrake.math.RigidTransform], p_AQ_lower: numpy.ndarray[numpy.float64[3, 1]], p_AQ_upper: numpy.ndarray[numpy.float64[3, 1]], frameB: pydrake.multibody.tree.Frame, p_BQ: numpy.ndarray[numpy.float64[3, 1]], plant_context: pydrake.systems.framework.Context) -&gt; None</p></li>
</ol>
<p>Overloaded constructor. Except that the constructor takes in a frame
A̅ and a pose X_AAbar between the frame A and A̅. We will constrain
the position of point Q expressed in the frame A to lie within a
bounding box of A.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant</span></code>:</dt><dd><p>The MultibodyPlant on which the constraint is imposed. <code class="docutils literal notranslate"><span class="pre">plant</span></code>
should be alive during the lifetime of this constraint.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameAbar</span></code>:</dt><dd><p>The frame A̅ in which point Q’s position is measured.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_AbarA</span></code>:</dt><dd><p>relative transform between the frame A̅ and A. If empty, then we
use identity transform.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_AQ_lower</span></code>:</dt><dd><p>The lower bound on the position of point Q, measured and expressed
in frame A.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_AQ_upper</span></code>:</dt><dd><p>The upper bound on the position of point Q, measured and expressed
in frame A.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameB</span></code>:</dt><dd><p>The frame to which point Q is rigidly attached.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BQ</span></code>:</dt><dd><p>The position of the point Q, rigidly attached to frame B, measured
and expressed in frame B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant_context</span></code>:</dt><dd><p>The Context that has been allocated for this <code class="docutils literal notranslate"><span class="pre">plant</span></code>. We will
update the context when evaluating the constraint.
<code class="docutils literal notranslate"><span class="pre">plant_context</span></code> should be alive during the lifetime of this
constraint.</p>
</dd>
<dt>Precondition:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">frameA</span></code> and <code class="docutils literal notranslate"><span class="pre">frameB</span></code> must belong to <code class="docutils literal notranslate"><span class="pre">plant</span></code>.</p>
</dd>
<dt>Precondition:</dt><dd><p>p_AQ_lower(i) &lt;= p_AQ_upper(i) for i = 1, 2, 3.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if plant is nullptr.</strong> – </p></li>
<li><p><strong>RuntimeError if plant_context is nullptr.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.multibody.inverse_kinematics.PositionConstraint, plant: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], frameA: pydrake.multibody.tree.Frame_[AutoDiffXd], p_AQ_lower: numpy.ndarray[numpy.float64[3, 1]], p_AQ_upper: numpy.ndarray[numpy.float64[3, 1]], frameB: pydrake.multibody.tree.Frame_[AutoDiffXd], p_BQ: numpy.ndarray[numpy.float64[3, 1]], plant_context: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Overloaded constructor. Same as the constructor with the double
version (using MultibodyPlant&lt;double&gt; and Context&lt;double&gt;). Except the
gradient of the constraint is computed from autodiff.</p>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.multibody.inverse_kinematics.PositionConstraint, plant: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], frameAbar: pydrake.multibody.tree.Frame_[AutoDiffXd], X_AbarA: Optional[pydrake.math.RigidTransform], p_AQ_lower: numpy.ndarray[numpy.float64[3, 1]], p_AQ_upper: numpy.ndarray[numpy.float64[3, 1]], frameB: pydrake.multibody.tree.Frame_[AutoDiffXd], p_BQ: numpy.ndarray[numpy.float64[3, 1]], plant_context: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Overloaded constructor. Same as the constructor with the double
version (using MultibodyPlant&lt;double&gt; and Context&lt;double&gt;). Except the
gradient of the constraint is computed from autodiff.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PositionConstraint.set_bounds(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.PositionConstraint,</span> <span class="pre">new_lb:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">new_ub:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Set the upper and lower bounds of the constraint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_lb</span></code>:</dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">num_constraints</span></code> x 1 vector.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">new_ub</span></code>:</dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">num_constraints</span></code> x 1 vector.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the users want to expose this method in a sub-class, do using
Constraint::set_bounds, as in LinearConstraint.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PositionConstraint.UpdateLowerBound(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.PositionConstraint,</span> <span class="pre">new_lb:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Updates the lower bound.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>if the users want to expose this method in a sub-class, do using
Constraint::UpdateLowerBound, as in LinearConstraint.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PositionConstraint.UpdateUpperBound(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.PositionConstraint,</span> <span class="pre">new_ub:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Updates the upper bound.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>if the users want to expose this method in a sub-class, do using
Constraint::UpdateUpperBound, as in LinearConstraint.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PositionCost</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Cost</span></code></p>
<p>Implements a cost of the form (p_AP - p_AQ)ᵀ C (p_AP - p_AQ), where
point P is specified relative to frame A and point Q is specified
relative to frame B, and the cost is evaluated in frame A.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PositionCost.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.inverse_kinematics.PositionCost, plant: pydrake.multibody.plant.MultibodyPlant, frameA: pydrake.multibody.tree.Frame, p_AP: numpy.ndarray[numpy.float64[3, 1]], frameB: pydrake.multibody.tree.Frame, p_BQ: numpy.ndarray[numpy.float64[3, 1]], C: numpy.ndarray[numpy.float64[3, 3], flags.f_contiguous], plant_context: pydrake.systems.framework.Context) -&gt; None</p></li>
</ol>
<p>Constructs PositionCost object.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant</span></code>:</dt><dd><p>The MultibodyPlant on which the cost is implemented. <code class="docutils literal notranslate"><span class="pre">plant</span></code>
should be alive during the lifetime of this cost.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameA</span></code>:</dt><dd><p>The frame in which point P’s position is measured.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_AP</span></code>:</dt><dd><p>The point P.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameB</span></code>:</dt><dd><p>The frame in which point Q’s position is measured.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BQ</span></code>:</dt><dd><p>The point Q.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">C</span></code>:</dt><dd><p>A 3x3 matrix representing the cost in quadratic form.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">plant_context</span></code>:</dt><dd><p>A context for the <code class="docutils literal notranslate"><span class="pre">plant</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if plant is nullptr.</strong> – </p></li>
<li><p><strong>RuntimeError if plant_context is nullptr.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.inverse_kinematics.PositionCost, plant: pydrake.multibody.plant.MultibodyPlant_[AutoDiffXd], frameA: pydrake.multibody.tree.Frame_[AutoDiffXd], p_AP: numpy.ndarray[numpy.float64[3, 1]], frameB: pydrake.multibody.tree.Frame_[AutoDiffXd], p_BQ: numpy.ndarray[numpy.float64[3, 1]], C: numpy.ndarray[numpy.float64[3, 3], flags.f_contiguous], plant_context: pydrake.systems.framework.Context_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Overloaded constructor. Same as the constructor with the double
version (using MultibodyPlant&lt;double&gt; and Context&lt;double&gt;). Except the
gradient of the cost is computed from autodiff.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitQuaternionConstraint</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.solvers.Constraint</span></code></p>
<p>Constrains the quaternion to have a unit length.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>: It is highly recommended that in addition to adding this
constraint, you also call MathematicalProgram::SetInitialGuess(),
e.g.</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// Set a non-zero initial guess to help avoid singularities.</span>
<span class="n">prog_</span><span class="o">-&gt;</span><span class="n">SetInitialGuess</span><span class="p">(</span><span class="n">q_</span><span class="p">.</span><span class="n">segment</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">(</span><span class="n">quaternion_start</span><span class="p">),</span>
<span class="n">Eigen</span><span class="o">::</span><span class="n">Vector4d</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">});</span>
</pre></div>
</div>
</details><dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitQuaternionConstraint.__init__(self:</span> <span class="pre">pydrake.multibody.inverse_kinematics.UnitQuaternionConstraint)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="pydrake.multibody.fix_inertia.html" class="btn btn-neutral float-left" title="pydrake.multibody.fix_inertia" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="pydrake.multibody.math.html" class="btn btn-neutral float-right" title="pydrake.multibody.math" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p></p>
  </div>

  
</footer>
<script>
  /* Enables clicking for the mobile "hamburger" (three-line) menu item. */
  const siteHeader = document.querySelector('.site-header')
  const mobileButton = document.querySelector('.menu-mobile-toggle')
  const body = document.querySelector('body')

  mobileButton.addEventListener('click', function(event) {
    siteHeader.classList.toggle('open');
    body.classList.toggle('overflow-hidden');
  })
</script>
<footer class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg">
    </a>
    <div class="footer-menu">
      <ul>
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"></a>
        </li>
      </ul>
    </div>
  </div>


</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>