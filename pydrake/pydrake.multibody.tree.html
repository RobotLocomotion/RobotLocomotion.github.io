<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pydrake.multibody.tree &mdash; pydrake  documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=86f27845" />
      <link rel="stylesheet" type="text/css" href="_static/css/custom.css?v=6b576c25" />

  
  
        <script src="_static/jquery.js?v=8dae8fb0"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="_static/documentation_options.js?v=7f41d439"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="pydrake.perception" href="pydrake.perception.html" />
    <link rel="prev" title="pydrake.multibody.rational" href="pydrake.multibody.rational.html" /> 
</head>

<body class="wy-body-for-nav">
<header class="site-header">
  <div class="site-header-inner contain">
    <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
    <div class="menu-mobile-toggle">
      <span></span>
    </div>
    <nav class="site-menu">
      <ul>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/">Home</a>
        </li>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/installation.html">Installation</a>
        </li>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/gallery.html">Gallery</a>
        </li>
        <li class="site-menu-item site-menu-item-main">API Documentation
          <div class="sub">
            <a class="site-menu-item" href="/doxygen_cxx/index.html">C++</a> <a class="site-menu-item" href="/pydrake/index.html">Python</a>
          </div>
        </li>
        <li class="site-menu-item site-menu-item-main">Resources
          <div class="sub">
            <a class="site-menu-item" href="/getting_help.html">Getting Help</a> <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/%2Findex.ipynb">Tutorials</a> <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a> <a class="site-menu-item" href="/developers.html">For Developers</a> <a class="site-menu-item" href="/credits.html">Credits</a>
          </div>
        </li>
        <li class="github-link">
          <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
        </li>
      </ul>
    </nav>
  </div>
</header>

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            pydrake
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search pydrake only…" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
  <form id="search_form" class="wy_form" action="https://google.com/search" method="get">
    <input type="text" name="q" placeholder="Search all of Drake…" />
    <input type="hidden" name="q" value="site:drake.mit.edu OR site:underactuated.csail.mit.edu OR site:manipulation.csail.mit.edu" />
  </form>
</div>

        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="pydrake.all.html">pydrake.all</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.autodiffutils.html">pydrake.autodiffutils</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.common.html">pydrake.common</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.examples.html">pydrake.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.forwarddiff.html">pydrake.forwarddiff</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.geometry.html">pydrake.geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.gym.html">pydrake.gym</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.lcm.html">pydrake.lcm</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.manipulation.html">pydrake.manipulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.math.html">pydrake.math</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="pydrake.multibody.html">pydrake.multibody</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.all.html">pydrake.multibody.all</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.benchmarks.html">pydrake.multibody.benchmarks</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.fem.html">pydrake.multibody.fem</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.fix_inertia.html">pydrake.multibody.fix_inertia</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.inverse_kinematics.html">pydrake.multibody.inverse_kinematics</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.math.html">pydrake.multibody.math</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.mesh_to_model.html">pydrake.multibody.mesh_to_model</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.meshcat.html">pydrake.multibody.meshcat</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.optimization.html">pydrake.multibody.optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.parsing.html">pydrake.multibody.parsing</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.plant.html">pydrake.multibody.plant</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.rational.html">pydrake.multibody.rational</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">pydrake.multibody.tree</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.perception.html">pydrake.perception</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.planning.html">pydrake.planning</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.polynomial.html">pydrake.polynomial</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.html">pydrake.solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.symbolic.html">pydrake.symbolic</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.systems.html">pydrake.systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.trajectories.html">pydrake.trajectories</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.tutorials.html">pydrake.tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.visualization.html">pydrake.visualization</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pydrake</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="pydrake.multibody.html">pydrake.multibody</a></li>
      <li class="breadcrumb-item active">pydrake.multibody.tree</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-pydrake.multibody.tree">
<span id="pydrake-multibody-tree"></span><h1>pydrake.multibody.tree<a class="headerlink" href="#module-pydrake.multibody.tree" title="Link to this heading"></a></h1>
<p>Bindings for MultibodyTree and related components.</p>
<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BallRpyJoint</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint</span></code></p>
<p>This Joint allows two bodies to rotate freely relative to one another.
That is, given a frame F attached to the parent body P and a frame M
attached to the child body B (see the Joint class’s documentation),
this Joint allows frame M to rotate freely with respect to F, while
the origins, Mo and Fo, of frames M and F respectively remain
coincident. The orientation of M relative to F is parameterized with
space <code class="docutils literal notranslate"><span class="pre">x-y-z</span></code> Euler angles.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">BallRpyJoint_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BallRpyJoint.__init__(self:</span> <span class="pre">pydrake.multibody.tree.BallRpyJoint,</span> <span class="pre">name:</span> <span class="pre">str,</span> <span class="pre">frame_on_parent:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">frame_on_child:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">damping:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructor to create a ball rpy joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B rotate freely relative to one another. See this class’s
documentation for further details on the definition of these frames,
get_angles() for an explanation of the angles defining orientation,
and get_angular_velocity() for an explanation of the generalized
velocities. This constructor signature creates a joint with no joint
limits, i.e. the joint position, velocity and acceleration limits are
the pair <code class="docutils literal notranslate"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. These can be set using the Joint methods
set_position_limits(), set_velocity_limits() and
set_acceleration_limits(). The first three arguments to this
constructor are those of the Joint class constructor. See the Joint
class’s documentation for details. The additional parameters are:</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>Viscous damping coefficient, in N⋅m⋅s, used to model losses within
the joint. See documentation of default_damping() for details on
modelling of the damping torque.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if damping is negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BallRpyJoint.default_damping(self:</span> <span class="pre">pydrake.multibody.tree.BallRpyJoint)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s default damping constant in N⋅m⋅s. The
damping torque (in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span> <span class="pre">-damping⋅ω</span></code>, i.e.
opposing motion, with ω the angular velocity of frame M in F (see
get_angular_velocity()) and τ the torque on child body B (to which M
is rigidly attached).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BallRpyJoint.get_angles(self:</span> <span class="pre">pydrake.multibody.tree.BallRpyJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Gets the rotation angles of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<p>The orientation <code class="docutils literal notranslate"><span class="pre">R_FM</span></code> of the child frame M in parent frame F is
parameterized with space <code class="docutils literal notranslate"><span class="pre">x-y-z</span></code> Euler angles (also known as
extrinsic angles). That is, the angles θr, θp, θy, correspond to a
sequence of rotations about the x̂, ŷ, ẑ axes of parent frame F,
respectively. Mathematically, rotation <code class="docutils literal notranslate"><span class="pre">R_FM</span></code> is given in terms of
angles θr, θp, θy by:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">R_FM</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rz</span><span class="p">(</span><span class="n">θy</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Ry</span><span class="p">(</span><span class="n">θp</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Rx</span><span class="p">(</span><span class="n">θr</span><span class="p">)</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">Rx(θ)</span></code>, <cite>Ry(θ)</cite> and <code class="docutils literal notranslate"><span class="pre">Rz(θ)</span></code> correspond to the elemental
rotations in amount of θ about the x, y and z axes respectively. Zero
θr, θp, θy angles corresponds to frames F and M being coincident.
Angles θr, θp, θy are defined to be positive according to the
right-hand-rule with the thumb aligned in the direction of their
respective axes.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Space <code class="docutils literal notranslate"><span class="pre">x-y-z</span></code> angles (extrinsic) are equivalent to Body
<code class="docutils literal notranslate"><span class="pre">z-y-x</span></code> angles (intrinsic).</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This particular choice of angles θr, θp, θy for this joint are
many times referred to as the roll, pitch and yaw angles by many
dynamicists. They are also known as the Tait-Bryan angles or
Cardan angles.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The angle coordinates of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code>
ordered as θr, θp, θy.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BallRpyJoint.get_angular_velocity(self:</span> <span class="pre">pydrake.multibody.tree.BallRpyJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Retrieves from <code class="docutils literal notranslate"><span class="pre">context</span></code> the angular velocity <code class="docutils literal notranslate"><span class="pre">w_FM</span></code> of the child
frame M in the parent frame F, expressed in F.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">w_FM</span></code>:</dt><dd><p>A vector in ℝ³ with the angular velocity of the child frame M in
the parent frame F, expressed in F. Refer to this class’s
documentation for further details and definitions of these frames.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BallRpyJoint.get_default_angles(self:</span> <span class="pre">pydrake.multibody.tree.BallRpyJoint)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Gets the default angles for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint. Wrapper for the more
general <code class="docutils literal notranslate"><span class="pre">Joint::default_positions()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The default angles of <code class="docutils literal notranslate"><span class="pre">this</span></code> stored in <code class="docutils literal notranslate"><span class="pre">default_positions_</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BallRpyJoint.kTypeName</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BallRpyJoint.set_angles(self:</span> <span class="pre">pydrake.multibody.tree.BallRpyJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">angles:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.BallRpyJoint</span></span></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the generalized coordinates corresponding
to the rotation angles of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals <code class="docutils literal notranslate"><span class="pre">angles</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angles</span></code>:</dt><dd><p>The desired angles in radians to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> ordered
as θr, θp, θy. See get_angles() for details.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BallRpyJoint.set_angular_velocity(self:</span> <span class="pre">pydrake.multibody.tree.BallRpyJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">w_FM:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.BallRpyJoint</span></span></dt>
<dd><p>Sets in <code class="docutils literal notranslate"><span class="pre">context</span></code> the state for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint so that the angular
velocity of the child frame M in the parent frame F is <code class="docutils literal notranslate"><span class="pre">w_FM</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">w_FM</span></code>:</dt><dd><p>A vector in ℝ³ with the angular velocity of the child frame M in
the parent frame F, expressed in F. Refer to this class’s
documentation for further details and definitions of these frames.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BallRpyJoint.set_default_angles(self:</span> <span class="pre">pydrake.multibody.tree.BallRpyJoint,</span> <span class="pre">angles:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default angles of this joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angles</span></code>:</dt><dd><p>The desired default angles of the joint</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BallRpyJoint.set_random_angles_distribution(self:</span> <span class="pre">pydrake.multibody.tree.BallRpyJoint,</span> <span class="pre">angles:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the random distribution that angles of this joint will be
randomly sampled from. See get_angles() for details on the angle
representation.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BallRpyJoint_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">BallRpyJoint_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">BallRpyJoint_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">BallRpyJoint_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BallRpyJoint_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd]</span></code></p>
<p>This Joint allows two bodies to rotate freely relative to one another.
That is, given a frame F attached to the parent body P and a frame M
attached to the child body B (see the Joint class’s documentation),
this Joint allows frame M to rotate freely with respect to F, while
the origins, Mo and Fo, of frames M and F respectively remain
coincident. The orientation of M relative to F is parameterized with
space <code class="docutils literal notranslate"><span class="pre">x-y-z</span></code> Euler angles.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BallRpyJoint_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd],</span> <span class="pre">name:</span> <span class="pre">str,</span> <span class="pre">frame_on_parent:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">frame_on_child:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">damping:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructor to create a ball rpy joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B rotate freely relative to one another. See this class’s
documentation for further details on the definition of these frames,
get_angles() for an explanation of the angles defining orientation,
and get_angular_velocity() for an explanation of the generalized
velocities. This constructor signature creates a joint with no joint
limits, i.e. the joint position, velocity and acceleration limits are
the pair <code class="docutils literal notranslate"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. These can be set using the Joint methods
set_position_limits(), set_velocity_limits() and
set_acceleration_limits(). The first three arguments to this
constructor are those of the Joint class constructor. See the Joint
class’s documentation for details. The additional parameters are:</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>Viscous damping coefficient, in N⋅m⋅s, used to model losses within
the joint. See documentation of default_damping() for details on
modelling of the damping torque.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if damping is negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BallRpyJoint_[AutoDiffXd].default_damping(self:</span> <span class="pre">pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s default damping constant in N⋅m⋅s. The
damping torque (in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span> <span class="pre">-damping⋅ω</span></code>, i.e.
opposing motion, with ω the angular velocity of frame M in F (see
get_angular_velocity()) and τ the torque on child body B (to which M
is rigidly attached).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BallRpyJoint_[AutoDiffXd].get_angles(self:</span> <span class="pre">pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Gets the rotation angles of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<p>The orientation <code class="docutils literal notranslate"><span class="pre">R_FM</span></code> of the child frame M in parent frame F is
parameterized with space <code class="docutils literal notranslate"><span class="pre">x-y-z</span></code> Euler angles (also known as
extrinsic angles). That is, the angles θr, θp, θy, correspond to a
sequence of rotations about the x̂, ŷ, ẑ axes of parent frame F,
respectively. Mathematically, rotation <code class="docutils literal notranslate"><span class="pre">R_FM</span></code> is given in terms of
angles θr, θp, θy by:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">R_FM</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rz</span><span class="p">(</span><span class="n">θy</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Ry</span><span class="p">(</span><span class="n">θp</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Rx</span><span class="p">(</span><span class="n">θr</span><span class="p">)</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">Rx(θ)</span></code>, <cite>Ry(θ)</cite> and <code class="docutils literal notranslate"><span class="pre">Rz(θ)</span></code> correspond to the elemental
rotations in amount of θ about the x, y and z axes respectively. Zero
θr, θp, θy angles corresponds to frames F and M being coincident.
Angles θr, θp, θy are defined to be positive according to the
right-hand-rule with the thumb aligned in the direction of their
respective axes.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Space <code class="docutils literal notranslate"><span class="pre">x-y-z</span></code> angles (extrinsic) are equivalent to Body
<code class="docutils literal notranslate"><span class="pre">z-y-x</span></code> angles (intrinsic).</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This particular choice of angles θr, θp, θy for this joint are
many times referred to as the roll, pitch and yaw angles by many
dynamicists. They are also known as the Tait-Bryan angles or
Cardan angles.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The angle coordinates of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code>
ordered as θr, θp, θy.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BallRpyJoint_[AutoDiffXd].get_angular_velocity(self:</span> <span class="pre">pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Retrieves from <code class="docutils literal notranslate"><span class="pre">context</span></code> the angular velocity <code class="docutils literal notranslate"><span class="pre">w_FM</span></code> of the child
frame M in the parent frame F, expressed in F.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">w_FM</span></code>:</dt><dd><p>A vector in ℝ³ with the angular velocity of the child frame M in
the parent frame F, expressed in F. Refer to this class’s
documentation for further details and definitions of these frames.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BallRpyJoint_[AutoDiffXd].get_default_angles(self:</span> <span class="pre">pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Gets the default angles for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint. Wrapper for the more
general <code class="docutils literal notranslate"><span class="pre">Joint::default_positions()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The default angles of <code class="docutils literal notranslate"><span class="pre">this</span></code> stored in <code class="docutils literal notranslate"><span class="pre">default_positions_</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BallRpyJoint_[AutoDiffXd].kTypeName</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BallRpyJoint_[AutoDiffXd].set_angles(self:</span> <span class="pre">pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">angles:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd]</span></span></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the generalized coordinates corresponding
to the rotation angles of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals <code class="docutils literal notranslate"><span class="pre">angles</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angles</span></code>:</dt><dd><p>The desired angles in radians to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> ordered
as θr, θp, θy. See get_angles() for details.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BallRpyJoint_[AutoDiffXd].set_angular_velocity(self:</span> <span class="pre">pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">w_FM:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd]</span></span></dt>
<dd><p>Sets in <code class="docutils literal notranslate"><span class="pre">context</span></code> the state for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint so that the angular
velocity of the child frame M in the parent frame F is <code class="docutils literal notranslate"><span class="pre">w_FM</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">w_FM</span></code>:</dt><dd><p>A vector in ℝ³ with the angular velocity of the child frame M in
the parent frame F, expressed in F. Refer to this class’s
documentation for further details and definitions of these frames.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BallRpyJoint_[AutoDiffXd].set_default_angles(self:</span> <span class="pre">pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd],</span> <span class="pre">angles:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default angles of this joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angles</span></code>:</dt><dd><p>The desired default angles of the joint</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BallRpyJoint_[AutoDiffXd].set_random_angles_distribution(self:</span> <span class="pre">pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd],</span> <span class="pre">angles:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the random distribution that angles of this joint will be
randomly sampled from. See get_angles() for details on the angle
representation.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BallRpyJoint_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[Expression]</span></code></p>
<p>This Joint allows two bodies to rotate freely relative to one another.
That is, given a frame F attached to the parent body P and a frame M
attached to the child body B (see the Joint class’s documentation),
this Joint allows frame M to rotate freely with respect to F, while
the origins, Mo and Fo, of frames M and F respectively remain
coincident. The orientation of M relative to F is parameterized with
space <code class="docutils literal notranslate"><span class="pre">x-y-z</span></code> Euler angles.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BallRpyJoint_[Expression].__init__(self:</span> <span class="pre">pydrake.multibody.tree.BallRpyJoint_[Expression],</span> <span class="pre">name:</span> <span class="pre">str,</span> <span class="pre">frame_on_parent:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">frame_on_child:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">damping:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructor to create a ball rpy joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B rotate freely relative to one another. See this class’s
documentation for further details on the definition of these frames,
get_angles() for an explanation of the angles defining orientation,
and get_angular_velocity() for an explanation of the generalized
velocities. This constructor signature creates a joint with no joint
limits, i.e. the joint position, velocity and acceleration limits are
the pair <code class="docutils literal notranslate"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. These can be set using the Joint methods
set_position_limits(), set_velocity_limits() and
set_acceleration_limits(). The first three arguments to this
constructor are those of the Joint class constructor. See the Joint
class’s documentation for details. The additional parameters are:</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>Viscous damping coefficient, in N⋅m⋅s, used to model losses within
the joint. See documentation of default_damping() for details on
modelling of the damping torque.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if damping is negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BallRpyJoint_[Expression].default_damping(self:</span> <span class="pre">pydrake.multibody.tree.BallRpyJoint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s default damping constant in N⋅m⋅s. The
damping torque (in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span> <span class="pre">-damping⋅ω</span></code>, i.e.
opposing motion, with ω the angular velocity of frame M in F (see
get_angular_velocity()) and τ the torque on child body B (to which M
is rigidly attached).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BallRpyJoint_[Expression].get_angles(self:</span> <span class="pre">pydrake.multibody.tree.BallRpyJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Gets the rotation angles of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<p>The orientation <code class="docutils literal notranslate"><span class="pre">R_FM</span></code> of the child frame M in parent frame F is
parameterized with space <code class="docutils literal notranslate"><span class="pre">x-y-z</span></code> Euler angles (also known as
extrinsic angles). That is, the angles θr, θp, θy, correspond to a
sequence of rotations about the x̂, ŷ, ẑ axes of parent frame F,
respectively. Mathematically, rotation <code class="docutils literal notranslate"><span class="pre">R_FM</span></code> is given in terms of
angles θr, θp, θy by:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">R_FM</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rz</span><span class="p">(</span><span class="n">θy</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Ry</span><span class="p">(</span><span class="n">θp</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Rx</span><span class="p">(</span><span class="n">θr</span><span class="p">)</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">Rx(θ)</span></code>, <cite>Ry(θ)</cite> and <code class="docutils literal notranslate"><span class="pre">Rz(θ)</span></code> correspond to the elemental
rotations in amount of θ about the x, y and z axes respectively. Zero
θr, θp, θy angles corresponds to frames F and M being coincident.
Angles θr, θp, θy are defined to be positive according to the
right-hand-rule with the thumb aligned in the direction of their
respective axes.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Space <code class="docutils literal notranslate"><span class="pre">x-y-z</span></code> angles (extrinsic) are equivalent to Body
<code class="docutils literal notranslate"><span class="pre">z-y-x</span></code> angles (intrinsic).</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This particular choice of angles θr, θp, θy for this joint are
many times referred to as the roll, pitch and yaw angles by many
dynamicists. They are also known as the Tait-Bryan angles or
Cardan angles.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The angle coordinates of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code>
ordered as θr, θp, θy.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BallRpyJoint_[Expression].get_angular_velocity(self:</span> <span class="pre">pydrake.multibody.tree.BallRpyJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Retrieves from <code class="docutils literal notranslate"><span class="pre">context</span></code> the angular velocity <code class="docutils literal notranslate"><span class="pre">w_FM</span></code> of the child
frame M in the parent frame F, expressed in F.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">w_FM</span></code>:</dt><dd><p>A vector in ℝ³ with the angular velocity of the child frame M in
the parent frame F, expressed in F. Refer to this class’s
documentation for further details and definitions of these frames.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BallRpyJoint_[Expression].get_default_angles(self:</span> <span class="pre">pydrake.multibody.tree.BallRpyJoint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Gets the default angles for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint. Wrapper for the more
general <code class="docutils literal notranslate"><span class="pre">Joint::default_positions()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The default angles of <code class="docutils literal notranslate"><span class="pre">this</span></code> stored in <code class="docutils literal notranslate"><span class="pre">default_positions_</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BallRpyJoint_[Expression].kTypeName</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BallRpyJoint_[Expression].set_angles(self:</span> <span class="pre">pydrake.multibody.tree.BallRpyJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">angles:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.BallRpyJoint_[Expression]</span></span></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the generalized coordinates corresponding
to the rotation angles of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals <code class="docutils literal notranslate"><span class="pre">angles</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angles</span></code>:</dt><dd><p>The desired angles in radians to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> ordered
as θr, θp, θy. See get_angles() for details.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BallRpyJoint_[Expression].set_angular_velocity(self:</span> <span class="pre">pydrake.multibody.tree.BallRpyJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">w_FM:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.BallRpyJoint_[Expression]</span></span></dt>
<dd><p>Sets in <code class="docutils literal notranslate"><span class="pre">context</span></code> the state for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint so that the angular
velocity of the child frame M in the parent frame F is <code class="docutils literal notranslate"><span class="pre">w_FM</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">w_FM</span></code>:</dt><dd><p>A vector in ℝ³ with the angular velocity of the child frame M in
the parent frame F, expressed in F. Refer to this class’s
documentation for further details and definitions of these frames.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BallRpyJoint_[Expression].set_default_angles(self:</span> <span class="pre">pydrake.multibody.tree.BallRpyJoint_[Expression],</span> <span class="pre">angles:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default angles of this joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angles</span></code>:</dt><dd><p>The desired default angles of the joint</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BallRpyJoint_[Expression].set_random_angles_distribution(self:</span> <span class="pre">pydrake.multibody.tree.BallRpyJoint_[Expression],</span> <span class="pre">angles:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the random distribution that angles of this joint will be
randomly sampled from. See get_angles() for details on the angle
representation.</p>
</dd></dl>

</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Body</span></span></dt>
<dd><p>alias of <code class="xref py py-class docutils literal notranslate"><span class="pre">RigidBody</span></code></p>
</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Body_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">RigidBody_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">RigidBody_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">RigidBody_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BodyIndex</span></span></dt>
<dd><p>Type used to identify RigidBodies (a.k.a. Links) by index in a
multibody plant. Interchangeable with LinkIndex.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BodyIndex.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.tree.BodyIndex) -&gt; None</p></li>
</ol>
<p>Default constructor; the result is an <em>invalid</em> index. This only
exists to serve applications which require a default constructor.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.tree.BodyIndex, arg0: int) -&gt; None</p></li>
</ol>
<p>Construction from a non-negative <code class="docutils literal notranslate"><span class="pre">int</span></code> value. The value must lie in
the range of [0, 2³¹). Constructor only promises to test validity in
Debug build.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">BodyIndex.is_valid(self:</span> <span class="pre">pydrake.multibody.tree.BodyIndex)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Reports if the index is valid–the only operation on an invalid index
that doesn’t throw an exception in Debug builds.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">CalcSpatialInertia(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>CalcSpatialInertia(shape: pydrake.geometry.Shape, density: float) -&gt; drake::multibody::SpatialInertia&lt;double&gt;</p></li>
</ol>
<p>Computes the SpatialInertia of a body made up of a homogeneous
material (of given <code class="docutils literal notranslate"><span class="pre">density</span></code> in kg/m³) uniformly distributed in the
volume of the given <code class="docutils literal notranslate"><span class="pre">shape</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">shape</span></code> is defined in its canonical frame S and the body in
frame B. The two frames are coincident and aligned (i.e., X_SB = I).</p>
<p>Most shapes are defined such that their center of mass is coincident
with So (and, therefore, Bo). These are the shapes that have symmetry
across So along each of the axes Sx, Sy, Sz (e.g., geometry::Box,
geometry::Sphere, etc.) For meshes, it depends on how the mesh is
defined. For more discussion on the nuances of geometry::Mesh and
geometry::Convex calculations CalcSpatialInertia(const
geometry::TriangleSurfaceMesh&lt;double&gt;&amp;,double) “see below”.</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>The spatial inertia of the hypothetical body implied by the given
<code class="docutils literal notranslate"><span class="pre">shape</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if shape is an instance</strong><strong> of </strong><strong>geometry::HalfSpace or</strong> – </p></li>
<li><p><strong>geometry::MeshcatCone.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>CalcSpatialInertia(mesh: pydrake.geometry.TriangleSurfaceMesh, density: float) -&gt; drake::multibody::SpatialInertia&lt;double&gt;</p></li>
</ol>
<p>Computes the SpatialInertia of a body made up of a homogeneous
material (of given <code class="docutils literal notranslate"><span class="pre">density</span></code> in kg/m³) uniformly distributed in the
volume of the given <code class="docutils literal notranslate"><span class="pre">mesh</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">mesh</span></code> is defined in its canonical frame M and the body in frame
B. The two frames are coincident and aligned (i.e., X_MB = I).</p>
<p>For the resultant spatial inertia to be meaningful, the <code class="docutils literal notranslate"><span class="pre">mesh</span></code> must
satisfy certain requirements:</p>
<ul class="simple">
<li><p>The mesh must <em>fully</em> enclose a volume (no cracks, no open manifolds,</p></li>
</ul>
<p>etc.).
- All triangles must be “wound” such that their normals point outward
(according to the right-hand rule based on vertex winding).</p>
<p>Drake currently doesn’t validate these requirements on the mesh.
Instead, it does a best-faith effort to compute a spatial inertia. For
some “bad” meshes, the SpatialInertia will be objectively physically
invalid. For others, the SpatialInertia will appear physically valid,
but be meaningless because it does not accurately represent the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the resulting spatial inertia is obviously</strong> – </p></li>
<li><p><strong>physically invalid. See</strong> – </p></li>
<li><p><strong>multibody::SpatialInertia::IsPhysicallyValid</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">default_model_instance()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></span></dt>
<dd><p>Returns the model instance which contains all tree elements with no
explicit model instance specified.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DeformableBody</span></span></dt>
<dd><p>The DeformableBody class represents a single deformable element within
a MultibodyPlant. It encapsulates the mesh, physical properties, and
finite-element model required to simulate deformable behavior. It
manages: - Unique identification (DeformableBodyIndex,
DeformableBodyId) and naming - Geometry association for collision and
visualization - Construction of a FEM model with configurable
constitutive parameters - Storage of reference vertex positions and
system state indices - Application of boundary conditions and
constraints - Registration and retrieval of external forces (including
gravity) - Enabling/disabling of dynamics at runtime</p>
<p>This class is not meant to be created by end users and it must be
created exclusively by DeformableModel through
DeformableModel::RegisterDeformableBody.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DeformableBody.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DeformableBody.AddFixedConstraint(self:</span> <span class="pre">pydrake.multibody.tree.DeformableBody,</span> <span class="pre">body_B:</span> <span class="pre">pydrake.multibody.tree.RigidBody,</span> <span class="pre">X_BA:</span> <span class="pre">pydrake.math.RigidTransform,</span> <span class="pre">shape_G:</span> <span class="pre">pydrake.geometry.Shape,</span> <span class="pre">X_BG:</span> <span class="pre">pydrake.math.RigidTransform)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></span></dt>
<dd><p>Defines a fixed constraint between this deformable body and a rigid
body B. Such a fixed constraint is modeled as distance holonomic
constraints:</p>
<p>p_PᵢQᵢ(q) = 0 for each constrained vertex Pᵢ</p>
<p>where Pᵢ is the i-th vertex of the deformable body (A) under
constraint and Qᵢ is a point rigidly affixed to the rigid body B. To
specify the constraint, we put the reference mesh M of this body A in
B’s body frame with the given pose <code class="docutils literal notranslate"><span class="pre">X_BA</span></code> and prescribe a shape G
with pose <code class="docutils literal notranslate"><span class="pre">X_BG</span></code> in B’s body frame. All vertices Pᵢ in M that are
inside (or on the surface of) G are subject to the fixed constraints
with Qᵢ being coincident with Pᵢ when M is in pose X_BA. p_PᵢQᵢ(q)
denotes the relative position of point Qᵢ with respect to point Pᵢ as
a function of the configuration of the model q. Imposing this
constraint forces Pᵢ and Qᵢ to be coincident for each vertex i of the
deformable body specified to be under constraint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_B</span></code>:</dt><dd><p>The rigid body under constraint.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_BA</span></code>:</dt><dd><p>The pose of this deformable body A’s reference mesh in B’s body
frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">shape_G</span></code>:</dt><dd><p>The prescribed geometry shape, attached to rigid body B, used to
determine which vertices of this deformable body A is under
constraint.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_BG</span></code>:</dt><dd><p>The fixed pose of the geometry frame of the given <code class="docutils literal notranslate"><span class="pre">shape</span></code> in
body B’s frame.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the unique id of the newly added constraint.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError unless body_B is registered with the same</strong> – </p></li>
<li><p><strong>multibody tree owning this deformable body.</strong> – </p></li>
<li><p><strong>RuntimeError if no constraint is added</strong><strong> (</strong><strong>i.e. no vertex</strong><strong> of </strong><strong>the</strong> – </p></li>
<li><p><strong>deformable body is inside the given shape with the given</strong> – </p></li>
<li><p><strong>poses</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DeformableBody.body_id(self:</span> <span class="pre">pydrake.multibody.tree.DeformableBody)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.DeformableBodyId</span></span></dt>
<dd><p>Returns the unique body id.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DeformableBody.CalcCenterOfMassPositionInWorld(self:</span> <span class="pre">pydrake.multibody.tree.DeformableBody,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Calculates the body’s center of mass position in world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context associated with the MultibodyPlant that owns this
body.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_WBcm_W</span></code>:</dt><dd><p>the body’s center of mass position, measured and expressed in the
world frame W.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not belong to the MultibodyPlant</strong> – </p></li>
<li><p><strong>that owns this body.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DeformableBody.CalcCenterOfMassTranslationalVelocityInWorld(self:</span> <span class="pre">pydrake.multibody.tree.DeformableBody,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Calculates the body’s center of mass translational velocity in world
frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context associated with the MultibodyPlant that owns this
body.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">v_WScm_W</span></code>:</dt><dd><p>Scm’s translational velocity in frame W, expressed in W, where Scm
is the center of mass of this body.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not belong to the MultibodyPlant</strong> – </p></li>
<li><p><strong>that owns this body.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DeformableBody.CalcEffectiveAngularVelocity(self:</span> <span class="pre">pydrake.multibody.tree.DeformableBody,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Using an angular momentum analogy, calculates an “effective” angular
velocity for this body about its center of mass, measured and
expressed in the world frame W. The effective angular velocity is
computed using an angular momentum equation that assumes the body is a
rigid body (albeit we know it is deformable).</p>
<p>H_WBcm_W = I_BBcm_W * w_WBcm_W</p>
<p>for which when solved for w_WBcm_W gives</p>
<p>w_WBcm_W = inverse(I_BBcm_W) * H_WBcm_W</p>
<p>where H_WBcm_W is the body’s angular momentum about its center of mass
Bcm measured and expressed in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context associated with the MultibodyPlant that owns this
body.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">w_WBcm_W</span></code>:</dt><dd><p>the body’s effective angular velocity about Bcm, measured and
expressed in the world frame W.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not belong to the MultibodyPlant</strong> – </p></li>
<li><p><strong>that owns this body.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DeformableBody.config(self:</span> <span class="pre">pydrake.multibody.tree.DeformableBody)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.fem.DeformableBodyConfig</span></span></dt>
<dd><p>Returns physical parameters of this deformable body.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DeformableBody.Disable(self:</span> <span class="pre">pydrake.multibody.tree.DeformableBody,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Disables this deformable body in the given context. Disabling a
deformable body sets its vertex velocities and accelerations to zero
and freezes its vertex positions. A disabled deformable body is not
subject to any constraint (e.g. frictional contact constraint or fixed
constraint); it does not move under the influence of external forces
(e.g. gravity); and it does not necessarily satisfy the prescribed
boundary condition (if any). On the flip side, a disabled deformable
body does not affect the dynamics of other bodies, even if the
collision between the disabled body’s geometry and other geometries is
not filtered. Effectively, the physics of the deformable body stop
being computed. The deformable body can be enabled by calling
Enable(). Calling Disable() on a body which is already disabled has no
effect.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Enable().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the passed in context isn't compatible with the</strong> – </p></li>
<li><p><strong>MultibodyPlant that owns this body.</strong> – </p></li>
<li><p><strong>RuntimeError if context is null.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DeformableBody.discrete_state_index(self:</span> <span class="pre">pydrake.multibody.tree.DeformableBody)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.DiscreteStateIndex</span></span></dt>
<dd><p>Returns the index of the discrete state associated with this
deformable body in the MultibodyPlant that owns the body.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DeformableBody.Enable(self:</span> <span class="pre">pydrake.multibody.tree.DeformableBody,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Enables this deformable body in the given context. Calling Enable() on
a body which is already enabled has no effect.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Disable().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the passed in context isn't compatible with the</strong> – </p></li>
<li><p><strong>MultibodyPlant that owns this body.</strong> – </p></li>
<li><p><strong>RuntimeError if context is null.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DeformableBody.external_forces(self:</span> <span class="pre">pydrake.multibody.tree.DeformableBody)</span> <span class="pre">-&gt;</span> <span class="pre">list[pydrake.multibody.fem.ForceDensityFieldBase]</span></span></dt>
<dd><p>Returns all the external forces acting on this deformable body.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DeformableBody.geometry_id(self:</span> <span class="pre">pydrake.multibody.tree.DeformableBody)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.geometry.GeometryId</span></span></dt>
<dd><p>Returns the geometry id of the deformable geometry used to simulate
this deformable body.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DeformableBody.get_default_pose(self:</span> <span class="pre">pydrake.multibody.tree.DeformableBody)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RigidTransform</span></span></dt>
<dd><p>Returns the default pose of the simulated geometry (in its reference
configuration) in the world frame W. This returns pose last set by
set_default_pose(), or the pose of the geometry in the world frame W
when the body is registered if set_default_pose() has not been called.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DeformableBody.GetParentPlant(self:</span> <span class="pre">pydrake.multibody.tree.DeformableBody)</span> <span class="pre">-&gt;</span> <span class="pre">drake::multibody::MultibodyPlant&lt;double&gt;</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DeformableBody.GetPositions(self:</span> <span class="pre">pydrake.multibody.tree.DeformableBody,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">n]]</span></span></dt>
<dd><p>Copies out the matrix of vertex positions for this deformable body in
the provided <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context associated with the MultibodyPlant that owns this
body.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">q</span></code>:</dt><dd><p>A 3×N matrix containing the positions of all vertices of the body.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not belong to the MultibodyPlant</strong> – </p></li>
<li><p><strong>that owns this body.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DeformableBody.GetPositionsAndVelocities(self:</span> <span class="pre">pydrake.multibody.tree.DeformableBody,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">n]]</span></span></dt>
<dd><p>Copies out the matrix of vertex positions and velocities for this
deformable body in the provided <code class="docutils literal notranslate"><span class="pre">context</span></code>. The first N columns are
the positions and the next N columns are the velocities.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context associated with the MultibodyPlant that owns this
body.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A 3x2N matrix containing the positions and velocities of all
vertices of the body.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if context does not belong to the MultibodyPlant</strong> – </p></li>
<li><p><strong>that owns this body.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DeformableBody.GetVelocities(self:</span> <span class="pre">pydrake.multibody.tree.DeformableBody,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">n]]</span></span></dt>
<dd><p>Copies out the matrix of vertex velocities for this deformable body in
the provided <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context associated with the MultibodyPlant that owns this
body.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">v</span></code>:</dt><dd><p>A 3×N matrix containing the velocities of all vertices of the
body.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if context does not belong to the MultibodyPlant</strong> – </p></li>
<li><p><strong>that owns this body.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DeformableBody.has_fixed_constraint(self:</span> <span class="pre">pydrake.multibody.tree.DeformableBody)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true if this deformable body is under any fixed constraint.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DeformableBody.index(self:</span> <span class="pre">pydrake.multibody.tree.DeformableBody)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.DeformableBodyIndex</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DeformableBody.is_enabled(self:</span> <span class="pre">pydrake.multibody.tree.DeformableBody,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>true if this deformable body is enabled.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if the passed in context isn't compatible with the</strong> – </p></li>
<li><p><strong>MultibodyPlant that owns this body.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DeformableBody.is_enabled_parameter_index(self:</span> <span class="pre">pydrake.multibody.tree.DeformableBody)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.AbstractParameterIndex</span></span></dt>
<dd><p>Returns the index of the boolean parameter indicating whether this
deformable body is enabled.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DeformableBody.is_ephemeral(self:</span> <span class="pre">pydrake.multibody.tree.DeformableBody)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DeformableBody.model_instance(self:</span> <span class="pre">pydrake.multibody.tree.DeformableBody)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DeformableBody.name(self:</span> <span class="pre">pydrake.multibody.tree.DeformableBody)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns the name of the body.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DeformableBody.num_dofs(self:</span> <span class="pre">pydrake.multibody.tree.DeformableBody)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of degrees of freedom (DoFs) of this body.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DeformableBody.reference_positions(self:</span> <span class="pre">pydrake.multibody.tree.DeformableBody)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the reference positions of the vertices of the deformable body
identified by the given <code class="docutils literal notranslate"><span class="pre">id</span></code>. The reference positions are the
positions of the vertices of the mesh geometry representing the body
at registration time, measured and expressed in the world frame. The
reference positions are represented as a VectorX with 3N values where
N is the number of vertices. The x-, y-, and z-positions (measured and
expressed in the world frame) of the j-th vertex are 3j, 3j + 1, and
3j + 2 in the VectorX.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DeformableBody.scoped_name(self:</span> <span class="pre">pydrake.multibody.tree.DeformableBody)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.ScopedName</span></span></dt>
<dd><p>Returns scoped name of this body. Neither of the two pieces of the
name will be empty (the scope name and the element name).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DeformableBody.set_default_pose(self:</span> <span class="pre">pydrake.multibody.tree.DeformableBody,</span> <span class="pre">X_WD:</span> <span class="pre">pydrake.math.RigidTransform)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default pose of the simulated geometry (in its reference
configuration) in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_WD</span></code>:</dt><dd><p>The default pose of the simulated geometry in the world frame W.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DeformableBody.SetPositions(self:</span> <span class="pre">pydrake.multibody.tree.DeformableBody,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">q:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the vertex positions of this deformable body in the provided
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">out</span></code>:</dt><dd><p>] context The context associated with the MultibodyPlant that owns
this body.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">q</span></code>:</dt><dd><p>A 3×N matrix of vertex positions.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if any</strong><strong> of </strong><strong>the following conditions are met</strong> – <ol class="arabic simple">
<li></li>
</ol>
</p></li>
<li><p><strong>context` is nullptr. 2. context does not belong to th</strong> – </p></li>
<li><p><strong>MultibodyPlant that owns this body. 3. The number</strong><strong> of </strong><strong>columns of</strong> – </p></li>
<li><p><strong>q` does not match the number</strong><strong> of </strong><strong>vertices</strong><strong> of </strong><strong>this body. 4. ``q`</strong> – </p></li>
<li><p><strong>contains non-finite values.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DeformableBody.SetPositionsAndVelocities(self:</span> <span class="pre">pydrake.multibody.tree.DeformableBody,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">q:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous],</span> <span class="pre">v:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the vertex positions and velocities of this deformable body in
the provided <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">out</span></code>:</dt><dd><p>] context The context associated with the MultibodyPlant that owns
this body.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">q</span></code>:</dt><dd><p>A 3×N matrix of vertex positions.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v</span></code>:</dt><dd><p>A 3×N matrix of vertex velocities.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if any</strong><strong> of </strong><strong>the following conditions are met</strong> – <ol class="arabic simple">
<li></li>
</ol>
</p></li>
<li><p><strong>context` is nullptr. 2. context does not belong to th</strong> – </p></li>
<li><p><strong>MultibodyPlant that owns this body. 3. The number</strong><strong> of </strong><strong>columns of</strong> – </p></li>
<li><p><strong>q`</strong><strong> or </strong><strong>v does not match the number</strong><strong> of </strong><strong>vertices</strong><strong> of </strong><strong>this body</strong> – </p></li>
<li><p><strong>4. q</strong><strong> or </strong><strong>v contains non-finite values.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DeformableBody.SetVelocities(self:</span> <span class="pre">pydrake.multibody.tree.DeformableBody,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">v:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">n],</span> <span class="pre">flags.f_contiguous])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the vertex velocities of this deformable body in the provided
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">out</span></code>:</dt><dd><p>] context The context associated with the MultibodyPlant that owns
this body.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v</span></code>:</dt><dd><p>A 3×N matrix of vertex velocities.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if any</strong><strong> of </strong><strong>the following conditions are met</strong> – <ol class="arabic simple">
<li></li>
</ol>
</p></li>
<li><p><strong>context` is nullptr. 2. context does not belong to th</strong> – </p></li>
<li><p><strong>MultibodyPlant that owns this body. 3. The number</strong><strong> of </strong><strong>columns of</strong> – </p></li>
<li><p><strong>v` does not match the number</strong><strong> of </strong><strong>vertices</strong><strong> of </strong><strong>this body. 4. ``v`</strong> – </p></li>
<li><p><strong>contains non-finite values.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DeformableBody.SetWallBoundaryCondition(self:</span> <span class="pre">pydrake.multibody.tree.DeformableBody,</span> <span class="pre">p_WQ:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">n_W:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets wall boundary conditions for this deformable body. All vertices
of the mesh of the deformable body whose reference positions are
inside the prescribed open half space are put under zero displacement
boundary conditions. The open half space is defined by a plane with
outward normal n_W. A vertex V is considered to be subject to the
boundary condition if n̂ ⋅ p_QV &lt; 0 where Q is a point on the plane
and n̂ is normalized n_W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_WQ</span></code>:</dt><dd><p>The position of a point Q on the plane in the world frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">n_W</span></code>:</dt><dd><p>Outward normal to the half space expressed in the world frame.</p>
</dd>
<dt>Precondition:</dt><dd><p>n_W.norm() &gt; 1e-10.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Roundoff error may cause a point very near the defining plane to
be mischaracterized as to which side of the plane it is on.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DeformableBodyId</span></span></dt>
<dd><p>Type used to identify a deformable body by id within a multibody
plant.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DeformableBodyId.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DeformableBodyId.get_new_id()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.DeformableBodyId</span></span></dt>
<dd><p>Generates a new identifier for this id type. This new identifier will
be different from all previous identifiers created. This method does
<em>not</em> make any guarantees about the values of ids from successive
invocations. This method is guaranteed to be thread safe.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DeformableBodyId.get_value(self:</span> <span class="pre">pydrake.multibody.tree.DeformableBodyId)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Extracts the underlying representation from the identifier. This is
considered invalid for invalid ids and is strictly enforced in Debug
builds.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DeformableBodyId.is_valid(self:</span> <span class="pre">pydrake.multibody.tree.DeformableBodyId)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Reports if the id is valid.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DeformableBodyIndex</span></span></dt>
<dd><p>Type used to identify a deformable body by index within a multibody
plant.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DeformableBodyIndex.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.tree.DeformableBodyIndex) -&gt; None</p></li>
</ol>
<p>Default constructor; the result is an <em>invalid</em> index. This only
exists to serve applications which require a default constructor.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.tree.DeformableBodyIndex, arg0: int) -&gt; None</p></li>
</ol>
<p>Construction from a non-negative <code class="docutils literal notranslate"><span class="pre">int</span></code> value. The value must lie in
the range of [0, 2³¹). Constructor only promises to test validity in
Debug build.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DeformableBodyIndex.is_valid(self:</span> <span class="pre">pydrake.multibody.tree.DeformableBodyIndex)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Reports if the index is valid–the only operation on an invalid index
that doesn’t throw an exception in Debug builds.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DoorHinge</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ForceElement</span></code></p>
<p>This ForceElement models a revolute DoorHinge joint that could exhibit
different force/torque characteristics at different states due to the
existence of different type of torques on the joint. This class
implements a “christmas tree” accumulation of these different torques
in an empirical and unprincipled way. Specifically, different curves
are assigned to different torques to mimic their evolution based on
the joint state and some prespecified parameters.</p>
<p>Torques considered in this implementation include: * torsional spring
torque (τ_ts) – position dependent * catch torque (τ_c) – position
dependent * dynamic friction torque (τ_df) – velocity dependent *
static friction torque (τ_sf) – velocity dependent * viscous friction
torque (τ_vf) – velocity dependent</p>
<p>We then implement two curves to approximate the progression of
different torques. A curve <code class="docutils literal notranslate"><span class="pre">s(t,</span> <span class="pre">x)</span> <span class="pre">=</span> <span class="pre">tanh(x/t)</span></code> uses the <code class="docutils literal notranslate"><span class="pre">tanh</span></code>
function to approximate a step curve ({<cite>x&lt;0</cite>: -1 ; <code class="docutils literal notranslate"><span class="pre">x&gt;0</span></code>: 1})
outside of <code class="docutils literal notranslate"><span class="pre">-t</span> <span class="pre">&lt;</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">t</span></code>. The curve <code class="docutils literal notranslate"><span class="pre">doublet(t,</span> <span class="pre">x)</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">s</span> <span class="pre">*</span> <span class="pre">(1</span> <span class="pre">−</span>
<span class="pre">s²)</span></code> is the second derivative of <code class="docutils literal notranslate"><span class="pre">s</span></code> scaled by <code class="docutils literal notranslate"><span class="pre">-t²</span></code>, which
yields a lump at negative <code class="docutils literal notranslate"><span class="pre">x</span></code> that integrates to -1 and a lump at
positive <code class="docutils literal notranslate"><span class="pre">x</span></code> that integrates to 1. Finally, the total external
torque on the hinge joint would be:</p>
<p><code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span> <span class="pre">τ_ts</span> <span class="pre">+</span> <span class="pre">τ_c</span> <span class="pre">+</span> <span class="pre">τ_df</span> <span class="pre">+</span> <span class="pre">τ_sf</span> <span class="pre">+</span> <span class="pre">τ_vf</span></code>.</p>
<p>where <code class="docutils literal notranslate"><span class="pre">τ_ts</span> <span class="pre">=</span> <span class="pre">-k_ts</span> <span class="pre">*</span> <span class="pre">(q</span> <span class="pre">−</span> <span class="pre">qs₀)</span></code>, <cite>τ_c = k_c * doublet(qc₀/2, q −
qc₀/2)`</cite>, <cite>τ_df = -k_df * s(k_q̇₀, q̇)`</cite>, <cite>τ_sf = -k_sf *
doublet(k_q̇₀, q̇)</cite> and <code class="docutils literal notranslate"><span class="pre">τ_vf</span> <span class="pre">=</span> <span class="pre">-k_vf</span> <span class="pre">*</span> <span class="pre">q̇</span></code>. The door is assumed to
be closed at <code class="docutils literal notranslate"><span class="pre">q=0</span></code>, opening in the positive-q direction. Note that,
the sign of the torques depends on two elements: one is the sign of
the torque related constants and another one is the sign of the
assigned curves. For example, as defined above, the static friction
torque <code class="docutils literal notranslate"><span class="pre">τ_sf</span></code> should be opposite to the direction of the velocity
q̇. The catch torque <code class="docutils literal notranslate"><span class="pre">τ_c</span></code> should be negative when <code class="docutils literal notranslate"><span class="pre">q</span> <span class="pre">&lt;</span> <span class="pre">qc₀/2</span></code> and
positive otherwise. This class applies all hinge-originating forces,
so it can be used instead of the SDF viscous damping. The users could
change the values of these different elements to obtain different
characteristics for the DoorHinge joint that the users want to model.
A jupyter notebook tool is also provided to help the users visualize
the curves and design parameters. Run <code class="docutils literal notranslate"><span class="pre">bazel</span> <span class="pre">run</span>
<span class="pre">//bindings/pydrake/multibody:examples/door_hinge_inspector</span></code> to bring
up the notebook.</p>
<p><strong>To give an example</strong>, a common dishwasher door has a frictional
torque sufficient for it to rest motionless at any angle, a catch at
the top to hold it in place, a dashpot (viscous friction source) to
prevent it from swinging too fast, and a spring to counteract some of
its mass. Two figures are provided to illustrate the dishwasher
DoorHinge torque with the given default parameters. Figure 1 shows the
static characteristic of the dishwasher door. At q = 0, there exists a
negative catch torque to prevent the door from moving. After that, the
torsional spring torque will dominate to compensate part of the door
gravity. Figure 2 shows the dynamic feature of the dishwasher door at
q = 30 deg. It shows the door can be closed easily since the torque is
small when the velocity is negative. However, whenever the door
intends to open further, there will be a counter torque to prevent
that movement, which therefore keeps the door at rest. Note that, due
to the gravity, the dishwasher door will be fully open eventually.
This process can be really slow because of the default
<code class="docutils literal notranslate"><span class="pre">motion_threshold</span></code> is set to be very small. You can change the
<code class="docutils literal notranslate"><span class="pre">motion_threshold</span></code> parameter to adjust the time. &#64;image html
drake/multibody/tree/images/torque_vs_angle.svg “Figure 1” &#64;image html
drake/multibody/tree/images/torque_vs_velocity.svg “Figure 2”</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">DoorHinge_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DoorHinge.__init__(self:</span> <span class="pre">pydrake.multibody.tree.DoorHinge,</span> <span class="pre">joint:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint,</span> <span class="pre">config:</span> <span class="pre">pydrake.multibody.tree.DoorHingeConfig)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a hinge force element with parameters <code class="docutils literal notranslate"><span class="pre">config</span></code> applied to
the specified <code class="docutils literal notranslate"><span class="pre">joint</span></code>. It will throw an exception if the
DoorHingeConfig is invalid.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DoorHinge.CalcHingeFrictionalTorque(self:</span> <span class="pre">pydrake.multibody.tree.DoorHinge,</span> <span class="pre">angular_rate:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Calculates the total frictional torque with the given <code class="docutils literal notranslate"><span class="pre">angular_rate</span></code>
and the internal DoorHingeConfig.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DoorHinge.CalcHingeSpringTorque(self:</span> <span class="pre">pydrake.multibody.tree.DoorHinge,</span> <span class="pre">angle:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Calculate the total spring related torque with the given <code class="docutils literal notranslate"><span class="pre">angle</span></code> and
the internal DoorHingeConfig.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DoorHinge.CalcHingeTorque(self:</span> <span class="pre">pydrake.multibody.tree.DoorHinge,</span> <span class="pre">angle:</span> <span class="pre">float,</span> <span class="pre">angular_rate:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Calculate the total torque with the given <code class="docutils literal notranslate"><span class="pre">angle</span></code> and
<code class="docutils literal notranslate"><span class="pre">angular_rate</span></code> and the internal DoorHingeConfig.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DoorHinge.config(self:</span> <span class="pre">pydrake.multibody.tree.DoorHinge)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.DoorHingeConfig</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DoorHinge.joint(self:</span> <span class="pre">pydrake.multibody.tree.DoorHinge)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DoorHinge_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">DoorHinge_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">DoorHinge_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">DoorHinge_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DoorHinge_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ForceElement_[AutoDiffXd]</span></code></p>
<p>This ForceElement models a revolute DoorHinge joint that could exhibit
different force/torque characteristics at different states due to the
existence of different type of torques on the joint. This class
implements a “christmas tree” accumulation of these different torques
in an empirical and unprincipled way. Specifically, different curves
are assigned to different torques to mimic their evolution based on
the joint state and some prespecified parameters.</p>
<p>Torques considered in this implementation include: * torsional spring
torque (τ_ts) – position dependent * catch torque (τ_c) – position
dependent * dynamic friction torque (τ_df) – velocity dependent *
static friction torque (τ_sf) – velocity dependent * viscous friction
torque (τ_vf) – velocity dependent</p>
<p>We then implement two curves to approximate the progression of
different torques. A curve <code class="docutils literal notranslate"><span class="pre">s(t,</span> <span class="pre">x)</span> <span class="pre">=</span> <span class="pre">tanh(x/t)</span></code> uses the <code class="docutils literal notranslate"><span class="pre">tanh</span></code>
function to approximate a step curve ({<cite>x&lt;0</cite>: -1 ; <code class="docutils literal notranslate"><span class="pre">x&gt;0</span></code>: 1})
outside of <code class="docutils literal notranslate"><span class="pre">-t</span> <span class="pre">&lt;</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">t</span></code>. The curve <code class="docutils literal notranslate"><span class="pre">doublet(t,</span> <span class="pre">x)</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">s</span> <span class="pre">*</span> <span class="pre">(1</span> <span class="pre">−</span>
<span class="pre">s²)</span></code> is the second derivative of <code class="docutils literal notranslate"><span class="pre">s</span></code> scaled by <code class="docutils literal notranslate"><span class="pre">-t²</span></code>, which
yields a lump at negative <code class="docutils literal notranslate"><span class="pre">x</span></code> that integrates to -1 and a lump at
positive <code class="docutils literal notranslate"><span class="pre">x</span></code> that integrates to 1. Finally, the total external
torque on the hinge joint would be:</p>
<p><code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span> <span class="pre">τ_ts</span> <span class="pre">+</span> <span class="pre">τ_c</span> <span class="pre">+</span> <span class="pre">τ_df</span> <span class="pre">+</span> <span class="pre">τ_sf</span> <span class="pre">+</span> <span class="pre">τ_vf</span></code>.</p>
<p>where <code class="docutils literal notranslate"><span class="pre">τ_ts</span> <span class="pre">=</span> <span class="pre">-k_ts</span> <span class="pre">*</span> <span class="pre">(q</span> <span class="pre">−</span> <span class="pre">qs₀)</span></code>, <cite>τ_c = k_c * doublet(qc₀/2, q −
qc₀/2)`</cite>, <cite>τ_df = -k_df * s(k_q̇₀, q̇)`</cite>, <cite>τ_sf = -k_sf *
doublet(k_q̇₀, q̇)</cite> and <code class="docutils literal notranslate"><span class="pre">τ_vf</span> <span class="pre">=</span> <span class="pre">-k_vf</span> <span class="pre">*</span> <span class="pre">q̇</span></code>. The door is assumed to
be closed at <code class="docutils literal notranslate"><span class="pre">q=0</span></code>, opening in the positive-q direction. Note that,
the sign of the torques depends on two elements: one is the sign of
the torque related constants and another one is the sign of the
assigned curves. For example, as defined above, the static friction
torque <code class="docutils literal notranslate"><span class="pre">τ_sf</span></code> should be opposite to the direction of the velocity
q̇. The catch torque <code class="docutils literal notranslate"><span class="pre">τ_c</span></code> should be negative when <code class="docutils literal notranslate"><span class="pre">q</span> <span class="pre">&lt;</span> <span class="pre">qc₀/2</span></code> and
positive otherwise. This class applies all hinge-originating forces,
so it can be used instead of the SDF viscous damping. The users could
change the values of these different elements to obtain different
characteristics for the DoorHinge joint that the users want to model.
A jupyter notebook tool is also provided to help the users visualize
the curves and design parameters. Run <code class="docutils literal notranslate"><span class="pre">bazel</span> <span class="pre">run</span>
<span class="pre">//bindings/pydrake/multibody:examples/door_hinge_inspector</span></code> to bring
up the notebook.</p>
<p><strong>To give an example</strong>, a common dishwasher door has a frictional
torque sufficient for it to rest motionless at any angle, a catch at
the top to hold it in place, a dashpot (viscous friction source) to
prevent it from swinging too fast, and a spring to counteract some of
its mass. Two figures are provided to illustrate the dishwasher
DoorHinge torque with the given default parameters. Figure 1 shows the
static characteristic of the dishwasher door. At q = 0, there exists a
negative catch torque to prevent the door from moving. After that, the
torsional spring torque will dominate to compensate part of the door
gravity. Figure 2 shows the dynamic feature of the dishwasher door at
q = 30 deg. It shows the door can be closed easily since the torque is
small when the velocity is negative. However, whenever the door
intends to open further, there will be a counter torque to prevent
that movement, which therefore keeps the door at rest. Note that, due
to the gravity, the dishwasher door will be fully open eventually.
This process can be really slow because of the default
<code class="docutils literal notranslate"><span class="pre">motion_threshold</span></code> is set to be very small. You can change the
<code class="docutils literal notranslate"><span class="pre">motion_threshold</span></code> parameter to adjust the time. &#64;image html
drake/multibody/tree/images/torque_vs_angle.svg “Figure 1” &#64;image html
drake/multibody/tree/images/torque_vs_velocity.svg “Figure 2”</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DoorHinge_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.multibody.tree.DoorHinge_[AutoDiffXd],</span> <span class="pre">joint:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd],</span> <span class="pre">config:</span> <span class="pre">pydrake.multibody.tree.DoorHingeConfig)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a hinge force element with parameters <code class="docutils literal notranslate"><span class="pre">config</span></code> applied to
the specified <code class="docutils literal notranslate"><span class="pre">joint</span></code>. It will throw an exception if the
DoorHingeConfig is invalid.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DoorHinge_[AutoDiffXd].CalcHingeFrictionalTorque(self:</span> <span class="pre">pydrake.multibody.tree.DoorHinge_[AutoDiffXd],</span> <span class="pre">angular_rate:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd</span></span></dt>
<dd><p>Calculates the total frictional torque with the given <code class="docutils literal notranslate"><span class="pre">angular_rate</span></code>
and the internal DoorHingeConfig.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DoorHinge_[AutoDiffXd].CalcHingeSpringTorque(self:</span> <span class="pre">pydrake.multibody.tree.DoorHinge_[AutoDiffXd],</span> <span class="pre">angle:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd</span></span></dt>
<dd><p>Calculate the total spring related torque with the given <code class="docutils literal notranslate"><span class="pre">angle</span></code> and
the internal DoorHingeConfig.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DoorHinge_[AutoDiffXd].CalcHingeTorque(self:</span> <span class="pre">pydrake.multibody.tree.DoorHinge_[AutoDiffXd],</span> <span class="pre">angle:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">angular_rate:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd</span></span></dt>
<dd><p>Calculate the total torque with the given <code class="docutils literal notranslate"><span class="pre">angle</span></code> and
<code class="docutils literal notranslate"><span class="pre">angular_rate</span></code> and the internal DoorHingeConfig.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DoorHinge_[AutoDiffXd].config(self:</span> <span class="pre">pydrake.multibody.tree.DoorHinge_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.DoorHingeConfig</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DoorHinge_[AutoDiffXd].joint(self:</span> <span class="pre">pydrake.multibody.tree.DoorHinge_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DoorHinge_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ForceElement_[Expression]</span></code></p>
<p>This ForceElement models a revolute DoorHinge joint that could exhibit
different force/torque characteristics at different states due to the
existence of different type of torques on the joint. This class
implements a “christmas tree” accumulation of these different torques
in an empirical and unprincipled way. Specifically, different curves
are assigned to different torques to mimic their evolution based on
the joint state and some prespecified parameters.</p>
<p>Torques considered in this implementation include: * torsional spring
torque (τ_ts) – position dependent * catch torque (τ_c) – position
dependent * dynamic friction torque (τ_df) – velocity dependent *
static friction torque (τ_sf) – velocity dependent * viscous friction
torque (τ_vf) – velocity dependent</p>
<p>We then implement two curves to approximate the progression of
different torques. A curve <code class="docutils literal notranslate"><span class="pre">s(t,</span> <span class="pre">x)</span> <span class="pre">=</span> <span class="pre">tanh(x/t)</span></code> uses the <code class="docutils literal notranslate"><span class="pre">tanh</span></code>
function to approximate a step curve ({<cite>x&lt;0</cite>: -1 ; <code class="docutils literal notranslate"><span class="pre">x&gt;0</span></code>: 1})
outside of <code class="docutils literal notranslate"><span class="pre">-t</span> <span class="pre">&lt;</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">t</span></code>. The curve <code class="docutils literal notranslate"><span class="pre">doublet(t,</span> <span class="pre">x)</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">s</span> <span class="pre">*</span> <span class="pre">(1</span> <span class="pre">−</span>
<span class="pre">s²)</span></code> is the second derivative of <code class="docutils literal notranslate"><span class="pre">s</span></code> scaled by <code class="docutils literal notranslate"><span class="pre">-t²</span></code>, which
yields a lump at negative <code class="docutils literal notranslate"><span class="pre">x</span></code> that integrates to -1 and a lump at
positive <code class="docutils literal notranslate"><span class="pre">x</span></code> that integrates to 1. Finally, the total external
torque on the hinge joint would be:</p>
<p><code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span> <span class="pre">τ_ts</span> <span class="pre">+</span> <span class="pre">τ_c</span> <span class="pre">+</span> <span class="pre">τ_df</span> <span class="pre">+</span> <span class="pre">τ_sf</span> <span class="pre">+</span> <span class="pre">τ_vf</span></code>.</p>
<p>where <code class="docutils literal notranslate"><span class="pre">τ_ts</span> <span class="pre">=</span> <span class="pre">-k_ts</span> <span class="pre">*</span> <span class="pre">(q</span> <span class="pre">−</span> <span class="pre">qs₀)</span></code>, <cite>τ_c = k_c * doublet(qc₀/2, q −
qc₀/2)`</cite>, <cite>τ_df = -k_df * s(k_q̇₀, q̇)`</cite>, <cite>τ_sf = -k_sf *
doublet(k_q̇₀, q̇)</cite> and <code class="docutils literal notranslate"><span class="pre">τ_vf</span> <span class="pre">=</span> <span class="pre">-k_vf</span> <span class="pre">*</span> <span class="pre">q̇</span></code>. The door is assumed to
be closed at <code class="docutils literal notranslate"><span class="pre">q=0</span></code>, opening in the positive-q direction. Note that,
the sign of the torques depends on two elements: one is the sign of
the torque related constants and another one is the sign of the
assigned curves. For example, as defined above, the static friction
torque <code class="docutils literal notranslate"><span class="pre">τ_sf</span></code> should be opposite to the direction of the velocity
q̇. The catch torque <code class="docutils literal notranslate"><span class="pre">τ_c</span></code> should be negative when <code class="docutils literal notranslate"><span class="pre">q</span> <span class="pre">&lt;</span> <span class="pre">qc₀/2</span></code> and
positive otherwise. This class applies all hinge-originating forces,
so it can be used instead of the SDF viscous damping. The users could
change the values of these different elements to obtain different
characteristics for the DoorHinge joint that the users want to model.
A jupyter notebook tool is also provided to help the users visualize
the curves and design parameters. Run <code class="docutils literal notranslate"><span class="pre">bazel</span> <span class="pre">run</span>
<span class="pre">//bindings/pydrake/multibody:examples/door_hinge_inspector</span></code> to bring
up the notebook.</p>
<p><strong>To give an example</strong>, a common dishwasher door has a frictional
torque sufficient for it to rest motionless at any angle, a catch at
the top to hold it in place, a dashpot (viscous friction source) to
prevent it from swinging too fast, and a spring to counteract some of
its mass. Two figures are provided to illustrate the dishwasher
DoorHinge torque with the given default parameters. Figure 1 shows the
static characteristic of the dishwasher door. At q = 0, there exists a
negative catch torque to prevent the door from moving. After that, the
torsional spring torque will dominate to compensate part of the door
gravity. Figure 2 shows the dynamic feature of the dishwasher door at
q = 30 deg. It shows the door can be closed easily since the torque is
small when the velocity is negative. However, whenever the door
intends to open further, there will be a counter torque to prevent
that movement, which therefore keeps the door at rest. Note that, due
to the gravity, the dishwasher door will be fully open eventually.
This process can be really slow because of the default
<code class="docutils literal notranslate"><span class="pre">motion_threshold</span></code> is set to be very small. You can change the
<code class="docutils literal notranslate"><span class="pre">motion_threshold</span></code> parameter to adjust the time. &#64;image html
drake/multibody/tree/images/torque_vs_angle.svg “Figure 1” &#64;image html
drake/multibody/tree/images/torque_vs_velocity.svg “Figure 2”</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DoorHinge_[Expression].__init__(self:</span> <span class="pre">pydrake.multibody.tree.DoorHinge_[Expression],</span> <span class="pre">joint:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[Expression],</span> <span class="pre">config:</span> <span class="pre">pydrake.multibody.tree.DoorHingeConfig)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a hinge force element with parameters <code class="docutils literal notranslate"><span class="pre">config</span></code> applied to
the specified <code class="docutils literal notranslate"><span class="pre">joint</span></code>. It will throw an exception if the
DoorHingeConfig is invalid.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DoorHinge_[Expression].CalcHingeFrictionalTorque(self:</span> <span class="pre">pydrake.multibody.tree.DoorHinge_[Expression],</span> <span class="pre">angular_rate:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd><p>Calculates the total frictional torque with the given <code class="docutils literal notranslate"><span class="pre">angular_rate</span></code>
and the internal DoorHingeConfig.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DoorHinge_[Expression].CalcHingeSpringTorque(self:</span> <span class="pre">pydrake.multibody.tree.DoorHinge_[Expression],</span> <span class="pre">angle:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd><p>Calculate the total spring related torque with the given <code class="docutils literal notranslate"><span class="pre">angle</span></code> and
the internal DoorHingeConfig.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DoorHinge_[Expression].CalcHingeTorque(self:</span> <span class="pre">pydrake.multibody.tree.DoorHinge_[Expression],</span> <span class="pre">angle:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">angular_rate:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd><p>Calculate the total torque with the given <code class="docutils literal notranslate"><span class="pre">angle</span></code> and
<code class="docutils literal notranslate"><span class="pre">angular_rate</span></code> and the internal DoorHingeConfig.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DoorHinge_[Expression].config(self:</span> <span class="pre">pydrake.multibody.tree.DoorHinge_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.DoorHingeConfig</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DoorHinge_[Expression].joint(self:</span> <span class="pre">pydrake.multibody.tree.DoorHinge_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[Expression]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DoorHingeConfig</span></span></dt>
<dd><p>Configuration structure for the DoorHinge.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DoorHingeConfig.__init__(self:</span> <span class="pre">pydrake.multibody.tree.DoorHingeConfig,</span> <span class="pre">**kwargs)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Initialize to empirically reasonable values measured approximately by
banging on the door of a dishwasher with a force gauge.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DoorHingeConfig.catch_torque</span></span></dt>
<dd><p>k_c maximum catch torque applied over <code class="docutils literal notranslate"><span class="pre">catch_width</span></code> [Nm]. It should
be non-negative.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DoorHingeConfig.catch_width</span></span></dt>
<dd><p>qc₀ measured from closed (q=0) position [radian]. It should be
non-negative.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DoorHingeConfig.dynamic_friction_torque</span></span></dt>
<dd><p>k_df maximum dynamic friction torque measured opposite direction of
motion [Nm]. It should be non-negative.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DoorHingeConfig.motion_threshold</span></span></dt>
<dd><p>k_q̇₀ motion threshold to start to apply friction torques [rad/s]. It
should be non-negative. Realistic frictional force is very stiff,
reversing entirely over zero change in position or velocity, which
kills integrators. We approximate it with a continuous function. This
constant [rad/s] is the scaling factor on that function – very
approximately the rad/s at which half of the full frictional force is
applied. This number is nonphysical; make it small but not so small
that the simulation vibrates or explodes.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DoorHingeConfig.spring_constant</span></span></dt>
<dd><p>k_ts torsional spring constant measured toward the spring zero angle
[Nm/rad]. It should be non-negative.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DoorHingeConfig.spring_zero_angle_rad</span></span></dt>
<dd><p>qs₀ measured outward from the closed position [radian].</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DoorHingeConfig.static_friction_torque</span></span></dt>
<dd><p>k_sf maximum static friction measured opposite direction of motion
[Nm]. It should be non-negative.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">DoorHingeConfig.viscous_friction</span></span></dt>
<dd><p>k_vf viscous friction measured opposite direction of motion [Nm]. It
should be non-negative.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FixedOffsetFrame</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Frame</span></code></p>
<p>%FixedOffsetFrame represents a material frame F whose pose is fixed
with respect to a <em>parent</em> material frame P. The pose offset is given
by a spatial transform <code class="docutils literal notranslate"><span class="pre">X_PF</span></code>, which is constant after construction.
For instance, we could rigidly attach a frame F to move with a rigid
body B at a fixed pose <code class="docutils literal notranslate"><span class="pre">X_BF</span></code>, where B is the RigidBodyFrame
associated with body B. Thus, the World frame pose <code class="docutils literal notranslate"><span class="pre">X_WF</span></code> of a
FixedOffsetFrame F depends only on the World frame pose <code class="docutils literal notranslate"><span class="pre">X_WP</span></code> of
its parent P, and the constant pose <code class="docutils literal notranslate"><span class="pre">X_PF</span></code>, with <code class="docutils literal notranslate"><span class="pre">X_WF=X_WP*X_PF</span></code>.</p>
<p>For more information about spatial transforms, see
multibody_spatial_pose.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">FixedOffsetFrame_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FixedOffsetFrame.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.tree.FixedOffsetFrame, name: str, P: pydrake.multibody.tree.Frame, X_PF: pydrake.math.RigidTransform, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = None) -&gt; None</p></li>
</ol>
<p>Creates a material Frame F whose pose is fixed with respect to its
parent material Frame P. The pose is given by a spatial transform
<code class="docutils literal notranslate"><span class="pre">X_PF</span></code>; see class documentation for more information.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>The name of this frame. Cannot be empty.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">P</span></code>:</dt><dd><p>The frame to which this frame is attached with a fixed pose.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_PF</span></code>:</dt><dd><p>The <em>default</em> transform giving the pose of F in P, therefore only
the value (as a RigidTransform&lt;double&gt;) is provided.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>:</dt><dd><p>The model instance to which this frame belongs to. If unspecified,
will use P.model_instance().</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.tree.FixedOffsetFrame, name: str, bodyB: drake::multibody::RigidBody&lt;double&gt;, X_BF: pydrake.math.RigidTransform) -&gt; None</p></li>
</ol>
<p>Creates a material Frame F whose pose is fixed with respect to the
RigidBodyFrame B of the given RigidBody, which serves as F’s parent
frame. The pose is given by a RigidTransform <code class="docutils literal notranslate"><span class="pre">X_BF</span></code>; see class
documentation for more information.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>The name of this frame. Cannot be empty.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">bodyB</span></code>:</dt><dd><p>The body whose RigidBodyFrame B is to be F’s parent frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_BF</span></code>:</dt><dd><p>The transform giving the pose of F in B.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FixedOffsetFrame.GetPoseInParentFrame(self:</span> <span class="pre">pydrake.multibody.tree.FixedOffsetFrame,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RigidTransform</span></span></dt>
<dd><p>Returns the rigid transform X_PF that characterizes <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s
pose in its parent frame P.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>of the multibody plant associated with this frame.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FixedOffsetFrame.SetPoseInParentFrame(self:</span> <span class="pre">pydrake.multibody.tree.FixedOffsetFrame,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">X_PF:</span> <span class="pre">pydrake.math.RigidTransform)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the pose of <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F in its parent frame P.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>of the multibody plant associated with this frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_PF</span></code>:</dt><dd><p>Rigid transform that characterizes <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s pose
(orientation and position) in its parent frame P.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FixedOffsetFrame_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">FixedOffsetFrame_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">FixedOffsetFrame_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">FixedOffsetFrame_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FixedOffsetFrame_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd]</span></code></p>
<p>%FixedOffsetFrame represents a material frame F whose pose is fixed
with respect to a <em>parent</em> material frame P. The pose offset is given
by a spatial transform <code class="docutils literal notranslate"><span class="pre">X_PF</span></code>, which is constant after construction.
For instance, we could rigidly attach a frame F to move with a rigid
body B at a fixed pose <code class="docutils literal notranslate"><span class="pre">X_BF</span></code>, where B is the RigidBodyFrame
associated with body B. Thus, the World frame pose <code class="docutils literal notranslate"><span class="pre">X_WF</span></code> of a
FixedOffsetFrame F depends only on the World frame pose <code class="docutils literal notranslate"><span class="pre">X_WP</span></code> of
its parent P, and the constant pose <code class="docutils literal notranslate"><span class="pre">X_PF</span></code>, with <code class="docutils literal notranslate"><span class="pre">X_WF=X_WP*X_PF</span></code>.</p>
<p>For more information about spatial transforms, see
multibody_spatial_pose.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FixedOffsetFrame_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.tree.FixedOffsetFrame_[AutoDiffXd], name: str, P: pydrake.multibody.tree.Frame_[AutoDiffXd], X_PF: pydrake.math.RigidTransform, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = None) -&gt; None</p></li>
</ol>
<p>Creates a material Frame F whose pose is fixed with respect to its
parent material Frame P. The pose is given by a spatial transform
<code class="docutils literal notranslate"><span class="pre">X_PF</span></code>; see class documentation for more information.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>The name of this frame. Cannot be empty.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">P</span></code>:</dt><dd><p>The frame to which this frame is attached with a fixed pose.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_PF</span></code>:</dt><dd><p>The <em>default</em> transform giving the pose of F in P, therefore only
the value (as a RigidTransform&lt;double&gt;) is provided.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>:</dt><dd><p>The model instance to which this frame belongs to. If unspecified,
will use P.model_instance().</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.tree.FixedOffsetFrame_[AutoDiffXd], name: str, bodyB: drake::multibody::RigidBody&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;, X_BF: pydrake.math.RigidTransform) -&gt; None</p></li>
</ol>
<p>Creates a material Frame F whose pose is fixed with respect to the
RigidBodyFrame B of the given RigidBody, which serves as F’s parent
frame. The pose is given by a RigidTransform <code class="docutils literal notranslate"><span class="pre">X_BF</span></code>; see class
documentation for more information.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>The name of this frame. Cannot be empty.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">bodyB</span></code>:</dt><dd><p>The body whose RigidBodyFrame B is to be F’s parent frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_BF</span></code>:</dt><dd><p>The transform giving the pose of F in B.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FixedOffsetFrame_[AutoDiffXd].GetPoseInParentFrame(self:</span> <span class="pre">pydrake.multibody.tree.FixedOffsetFrame_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RigidTransform_[AutoDiffXd]</span></span></dt>
<dd><p>Returns the rigid transform X_PF that characterizes <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s
pose in its parent frame P.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>of the multibody plant associated with this frame.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FixedOffsetFrame_[AutoDiffXd].SetPoseInParentFrame(self:</span> <span class="pre">pydrake.multibody.tree.FixedOffsetFrame_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">X_PF:</span> <span class="pre">pydrake.math.RigidTransform_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the pose of <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F in its parent frame P.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>of the multibody plant associated with this frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_PF</span></code>:</dt><dd><p>Rigid transform that characterizes <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s pose
(orientation and position) in its parent frame P.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FixedOffsetFrame_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Frame_[Expression]</span></code></p>
<p>%FixedOffsetFrame represents a material frame F whose pose is fixed
with respect to a <em>parent</em> material frame P. The pose offset is given
by a spatial transform <code class="docutils literal notranslate"><span class="pre">X_PF</span></code>, which is constant after construction.
For instance, we could rigidly attach a frame F to move with a rigid
body B at a fixed pose <code class="docutils literal notranslate"><span class="pre">X_BF</span></code>, where B is the RigidBodyFrame
associated with body B. Thus, the World frame pose <code class="docutils literal notranslate"><span class="pre">X_WF</span></code> of a
FixedOffsetFrame F depends only on the World frame pose <code class="docutils literal notranslate"><span class="pre">X_WP</span></code> of
its parent P, and the constant pose <code class="docutils literal notranslate"><span class="pre">X_PF</span></code>, with <code class="docutils literal notranslate"><span class="pre">X_WF=X_WP*X_PF</span></code>.</p>
<p>For more information about spatial transforms, see
multibody_spatial_pose.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FixedOffsetFrame_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.tree.FixedOffsetFrame_[Expression], name: str, P: pydrake.multibody.tree.Frame_[Expression], X_PF: pydrake.math.RigidTransform, model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = None) -&gt; None</p></li>
</ol>
<p>Creates a material Frame F whose pose is fixed with respect to its
parent material Frame P. The pose is given by a spatial transform
<code class="docutils literal notranslate"><span class="pre">X_PF</span></code>; see class documentation for more information.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>The name of this frame. Cannot be empty.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">P</span></code>:</dt><dd><p>The frame to which this frame is attached with a fixed pose.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_PF</span></code>:</dt><dd><p>The <em>default</em> transform giving the pose of F in P, therefore only
the value (as a RigidTransform&lt;double&gt;) is provided.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>:</dt><dd><p>The model instance to which this frame belongs to. If unspecified,
will use P.model_instance().</p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.tree.FixedOffsetFrame_[Expression], name: str, bodyB: drake::multibody::RigidBody&lt;drake::symbolic::Expression&gt;, X_BF: pydrake.math.RigidTransform) -&gt; None</p></li>
</ol>
<p>Creates a material Frame F whose pose is fixed with respect to the
RigidBodyFrame B of the given RigidBody, which serves as F’s parent
frame. The pose is given by a RigidTransform <code class="docutils literal notranslate"><span class="pre">X_BF</span></code>; see class
documentation for more information.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt><dd><p>The name of this frame. Cannot be empty.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">bodyB</span></code>:</dt><dd><p>The body whose RigidBodyFrame B is to be F’s parent frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_BF</span></code>:</dt><dd><p>The transform giving the pose of F in B.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FixedOffsetFrame_[Expression].GetPoseInParentFrame(self:</span> <span class="pre">pydrake.multibody.tree.FixedOffsetFrame_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RigidTransform_[Expression]</span></span></dt>
<dd><p>Returns the rigid transform X_PF that characterizes <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s
pose in its parent frame P.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>of the multibody plant associated with this frame.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FixedOffsetFrame_[Expression].SetPoseInParentFrame(self:</span> <span class="pre">pydrake.multibody.tree.FixedOffsetFrame_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">X_PF:</span> <span class="pre">pydrake.math.RigidTransform_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the pose of <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F in its parent frame P.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>of the multibody plant associated with this frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_PF</span></code>:</dt><dd><p>Rigid transform that characterizes <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s pose
(orientation and position) in its parent frame P.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceDensityField</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.fem.ForceDensityFieldBase</span></code></p>
<p>Implementations of the ForceDensityFieldBase class should inherit from
this class. This class provides the functionality for a force density
field to depend on context-dependent quantities. It also provides the
functionality to declare system resources in a MultibodyPlant.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">ForceDensityField_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceDensityField.__init__(self:</span> <span class="pre">pydrake.multibody.tree.ForceDensityField,</span> <span class="pre">density_type:</span> <span class="pre">pydrake.multibody.fem.ForceDensityType</span> <span class="pre">=</span> <span class="pre">&lt;ForceDensityType.kPerCurrentVolume:</span> <span class="pre">0&gt;)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceDensityField.DeclareAbstractInputPort(plant:</span> <span class="pre">drake::multibody::MultibodyPlant&lt;double&gt;,</span> <span class="pre">name:</span> <span class="pre">str,</span> <span class="pre">model_value:</span> <span class="pre">pydrake.common.value.AbstractValue)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.InputPort</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceDensityField.DeclareCacheEntry(plant:</span> <span class="pre">drake::multibody::MultibodyPlant&lt;double&gt;,</span> <span class="pre">description:</span> <span class="pre">str,</span> <span class="pre">value_producer:</span> <span class="pre">pydrake.systems.framework.ValueProducer,</span> <span class="pre">prerequisites_of_calc:</span> <span class="pre">set[pydrake.systems.framework.DependencyTicket])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.CacheEntry</span></span></dt>
<dd><p>Protected LeafSystem methods exposed to declare system resources in a
MultibodyPlant. DoDeclareCacheEntries() and DoDeclareInputPorts() can
use these to declare cache entries and input ports.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceDensityField.DeclareVectorInputPort(plant:</span> <span class="pre">drake::multibody::MultibodyPlant&lt;double&gt;,</span> <span class="pre">name:</span> <span class="pre">str,</span> <span class="pre">model_vector:</span> <span class="pre">pydrake.systems.framework.BasicVector)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.InputPort</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceDensityField.has_parent_system(self:</span> <span class="pre">pydrake.multibody.tree.ForceDensityField)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff <code class="docutils literal notranslate"><span class="pre">this</span></code> external force is owned by a MultibodyPlant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceDensityField.parent_system_or_throw(self:</span> <span class="pre">pydrake.multibody.tree.ForceDensityField)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.LeafSystem</span></span></dt>
<dd><p>Returns the owning MultibodyPlant LeafSystem.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if this force density field is not owned by any</strong> – </p></li>
<li><p><strong>system.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceDensityField_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">ForceDensityField_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ForceDensityField_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ForceDensityField_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceDensityField_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.fem.ForceDensityFieldBase_[AutoDiffXd]</span></code></p>
<p>Implementations of the ForceDensityFieldBase class should inherit from
this class. This class provides the functionality for a force density
field to depend on context-dependent quantities. It also provides the
functionality to declare system resources in a MultibodyPlant.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceDensityField_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.multibody.tree.ForceDensityField_[AutoDiffXd],</span> <span class="pre">density_type:</span> <span class="pre">pydrake.multibody.fem.ForceDensityType</span> <span class="pre">=</span> <span class="pre">&lt;ForceDensityType.kPerCurrentVolume:</span> <span class="pre">0&gt;)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceDensityField_[AutoDiffXd].DeclareAbstractInputPort(plant:</span> <span class="pre">drake::multibody::MultibodyPlant&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double,</span> <span class="pre">-1,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">-1,</span> <span class="pre">1&gt;</span> <span class="pre">&gt;</span> <span class="pre">&gt;,</span> <span class="pre">name:</span> <span class="pre">str,</span> <span class="pre">model_value:</span> <span class="pre">pydrake.common.value.AbstractValue)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.InputPort_[AutoDiffXd]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceDensityField_[AutoDiffXd].DeclareCacheEntry(plant:</span> <span class="pre">drake::multibody::MultibodyPlant&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double,</span> <span class="pre">-1,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">-1,</span> <span class="pre">1&gt;</span> <span class="pre">&gt;</span> <span class="pre">&gt;,</span> <span class="pre">description:</span> <span class="pre">str,</span> <span class="pre">value_producer:</span> <span class="pre">pydrake.systems.framework.ValueProducer,</span> <span class="pre">prerequisites_of_calc:</span> <span class="pre">set[pydrake.systems.framework.DependencyTicket])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.CacheEntry</span></span></dt>
<dd><p>Protected LeafSystem methods exposed to declare system resources in a
MultibodyPlant. DoDeclareCacheEntries() and DoDeclareInputPorts() can
use these to declare cache entries and input ports.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceDensityField_[AutoDiffXd].DeclareVectorInputPort(plant:</span> <span class="pre">drake::multibody::MultibodyPlant&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double,</span> <span class="pre">-1,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">-1,</span> <span class="pre">1&gt;</span> <span class="pre">&gt;</span> <span class="pre">&gt;,</span> <span class="pre">name:</span> <span class="pre">str,</span> <span class="pre">model_vector:</span> <span class="pre">pydrake.systems.framework.BasicVector_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.InputPort_[AutoDiffXd]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceDensityField_[AutoDiffXd].has_parent_system(self:</span> <span class="pre">pydrake.multibody.tree.ForceDensityField_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff <code class="docutils literal notranslate"><span class="pre">this</span></code> external force is owned by a MultibodyPlant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceDensityField_[AutoDiffXd].parent_system_or_throw(self:</span> <span class="pre">pydrake.multibody.tree.ForceDensityField_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.LeafSystem_[AutoDiffXd]</span></span></dt>
<dd><p>Returns the owning MultibodyPlant LeafSystem.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if this force density field is not owned by any</strong> – </p></li>
<li><p><strong>system.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceDensityField_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.fem.ForceDensityFieldBase_[Expression]</span></code></p>
<p>Implementations of the ForceDensityFieldBase class should inherit from
this class. This class provides the functionality for a force density
field to depend on context-dependent quantities. It also provides the
functionality to declare system resources in a MultibodyPlant.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceDensityField_[Expression].__init__(self:</span> <span class="pre">pydrake.multibody.tree.ForceDensityField_[Expression],</span> <span class="pre">density_type:</span> <span class="pre">pydrake.multibody.fem.ForceDensityType</span> <span class="pre">=</span> <span class="pre">&lt;ForceDensityType.kPerCurrentVolume:</span> <span class="pre">0&gt;)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceDensityField_[Expression].DeclareAbstractInputPort(plant:</span> <span class="pre">drake::multibody::MultibodyPlant&lt;drake::symbolic::Expression&gt;,</span> <span class="pre">name:</span> <span class="pre">str,</span> <span class="pre">model_value:</span> <span class="pre">pydrake.common.value.AbstractValue)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.InputPort_[Expression]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceDensityField_[Expression].DeclareCacheEntry(plant:</span> <span class="pre">drake::multibody::MultibodyPlant&lt;drake::symbolic::Expression&gt;,</span> <span class="pre">description:</span> <span class="pre">str,</span> <span class="pre">value_producer:</span> <span class="pre">pydrake.systems.framework.ValueProducer,</span> <span class="pre">prerequisites_of_calc:</span> <span class="pre">set[pydrake.systems.framework.DependencyTicket])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.CacheEntry</span></span></dt>
<dd><p>Protected LeafSystem methods exposed to declare system resources in a
MultibodyPlant. DoDeclareCacheEntries() and DoDeclareInputPorts() can
use these to declare cache entries and input ports.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceDensityField_[Expression].DeclareVectorInputPort(plant:</span> <span class="pre">drake::multibody::MultibodyPlant&lt;drake::symbolic::Expression&gt;,</span> <span class="pre">name:</span> <span class="pre">str,</span> <span class="pre">model_vector:</span> <span class="pre">pydrake.systems.framework.BasicVector_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.InputPort_[Expression]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceDensityField_[Expression].has_parent_system(self:</span> <span class="pre">pydrake.multibody.tree.ForceDensityField_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true iff <code class="docutils literal notranslate"><span class="pre">this</span></code> external force is owned by a MultibodyPlant.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceDensityField_[Expression].parent_system_or_throw(self:</span> <span class="pre">pydrake.multibody.tree.ForceDensityField_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.systems.framework.LeafSystem_[Expression]</span></span></dt>
<dd><p>Returns the owning MultibodyPlant LeafSystem.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if this force density field is not owned by any</strong> – </p></li>
<li><p><strong>system.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceElement</span></span></dt>
<dd><p>A ForceElement allows modeling state and time dependent forces in a
MultibodyTree model. Examples of such forces are springs, dampers,
drag and gravity. Forces that depend on accelerations such as virtual
mass cannot be modeled with a ForceElement. This abstract class
provides an API that all force elements subclasses must implement in
order to be fully defined. These are:</p>
<ul class="simple">
<li><p>CalcAndAddForceContribution(): computes the force contribution of a force
element in a MultibodyTree model.</p></li>
<li><p>CalcPotentialEnergy(): computes a force element potential energy
contribution.</p></li>
<li><p>CalcConservativePower(): computes the power generated by conservative
forces.</p></li>
<li><p>CalcNonConservativePower(): computes the power dissipated by
non-conservative forces.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">ForceElement_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceElement.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceElement.GetParentPlant(self:</span> <span class="pre">pydrake.multibody.tree.ForceElement)</span> <span class="pre">-&gt;</span> <span class="pre">drake::multibody::MultibodyPlant&lt;double&gt;</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceElement.index(self:</span> <span class="pre">pydrake.multibody.tree.ForceElement)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.ForceElementIndex</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceElement.is_ephemeral(self:</span> <span class="pre">pydrake.multibody.tree.ForceElement)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceElement.model_instance(self:</span> <span class="pre">pydrake.multibody.tree.ForceElement)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceElement_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">ForceElement_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ForceElement_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ForceElement_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceElement_[AutoDiffXd]</span></span></dt>
<dd><p>A ForceElement allows modeling state and time dependent forces in a
MultibodyTree model. Examples of such forces are springs, dampers,
drag and gravity. Forces that depend on accelerations such as virtual
mass cannot be modeled with a ForceElement. This abstract class
provides an API that all force elements subclasses must implement in
order to be fully defined. These are:</p>
<ul class="simple">
<li><p>CalcAndAddForceContribution(): computes the force contribution of a force
element in a MultibodyTree model.</p></li>
<li><p>CalcPotentialEnergy(): computes a force element potential energy
contribution.</p></li>
<li><p>CalcConservativePower(): computes the power generated by conservative
forces.</p></li>
<li><p>CalcNonConservativePower(): computes the power dissipated by
non-conservative forces.</p></li>
</ul>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceElement_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceElement_[AutoDiffXd].GetParentPlant(self:</span> <span class="pre">pydrake.multibody.tree.ForceElement_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">drake::multibody::MultibodyPlant&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double,</span> <span class="pre">-1,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">-1,</span> <span class="pre">1&gt;</span> <span class="pre">&gt;</span> <span class="pre">&gt;</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceElement_[AutoDiffXd].index(self:</span> <span class="pre">pydrake.multibody.tree.ForceElement_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.ForceElementIndex</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceElement_[AutoDiffXd].is_ephemeral(self:</span> <span class="pre">pydrake.multibody.tree.ForceElement_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceElement_[AutoDiffXd].model_instance(self:</span> <span class="pre">pydrake.multibody.tree.ForceElement_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceElement_[Expression]</span></span></dt>
<dd><p>A ForceElement allows modeling state and time dependent forces in a
MultibodyTree model. Examples of such forces are springs, dampers,
drag and gravity. Forces that depend on accelerations such as virtual
mass cannot be modeled with a ForceElement. This abstract class
provides an API that all force elements subclasses must implement in
order to be fully defined. These are:</p>
<ul class="simple">
<li><p>CalcAndAddForceContribution(): computes the force contribution of a force
element in a MultibodyTree model.</p></li>
<li><p>CalcPotentialEnergy(): computes a force element potential energy
contribution.</p></li>
<li><p>CalcConservativePower(): computes the power generated by conservative
forces.</p></li>
<li><p>CalcNonConservativePower(): computes the power dissipated by
non-conservative forces.</p></li>
</ul>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceElement_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceElement_[Expression].GetParentPlant(self:</span> <span class="pre">pydrake.multibody.tree.ForceElement_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">drake::multibody::MultibodyPlant&lt;drake::symbolic::Expression&gt;</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceElement_[Expression].index(self:</span> <span class="pre">pydrake.multibody.tree.ForceElement_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.ForceElementIndex</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceElement_[Expression].is_ephemeral(self:</span> <span class="pre">pydrake.multibody.tree.ForceElement_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceElement_[Expression].model_instance(self:</span> <span class="pre">pydrake.multibody.tree.ForceElement_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceElementIndex</span></span></dt>
<dd><p>Type used to identify force elements by index within a multibody
plant.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceElementIndex.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.tree.ForceElementIndex) -&gt; None</p></li>
</ol>
<p>Default constructor; the result is an <em>invalid</em> index. This only
exists to serve applications which require a default constructor.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.tree.ForceElementIndex, arg0: int) -&gt; None</p></li>
</ol>
<p>Construction from a non-negative <code class="docutils literal notranslate"><span class="pre">int</span></code> value. The value must lie in
the range of [0, 2³¹). Constructor only promises to test validity in
Debug build.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ForceElementIndex.is_valid(self:</span> <span class="pre">pydrake.multibody.tree.ForceElementIndex)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Reports if the index is valid–the only operation on an invalid index
that doesn’t throw an exception in Debug builds.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame</span></span></dt>
<dd><p>%Frame is an abstract class representing a <em>material frame</em> (also
called a <em>physical frame</em>) of its underlying RigidBody. The Frame’s
origin is a material point of its RigidBody, and its axes have fixed
directions in that body. A Frame’s pose (position and orientation)
with respect to its RigidBodyFrame may be parameterized, but is fixed
(not time or state dependent) once parameters have been set.</p>
<p>An important characteristic of a Frame is that forces or torques
applied to a Frame are applied to the Frame’s underlying RigidBody.
Force-producing elements like joints, actuators, and constraints
usually employ two Frames, with one Frame connected to one body and
the other connected to a different body. Every Frame F can report the
RigidBody B to which it is attached and its pose X_BF with respect to
B’s RigidBodyFrame.</p>
<p>A Frame’s pose in World (or relative to other frames) is always
calculated starting with its pose relative to its underlying
RigidBodyFrame. Subclasses derived from Frame differ in how kinematic
calculations are performed. For example, the angular velocity of a
FixedOffsetFrame or RigidBodyFrame is identical to the angular
velocity of its underlying body, whereas the translational velocity of
a FixedOffsetFrame differs from that of a RigidBodyFrame.</p>
<p>Frame provides methods for obtaining its current orientation,
position, motion, etc. from a Context passed to those methods.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">Frame_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame.body(self:</span> <span class="pre">pydrake.multibody.tree.Frame)</span> <span class="pre">-&gt;</span> <span class="pre">drake::multibody::RigidBody&lt;double&gt;</span></span></dt>
<dd><p>Returns a const reference to the body associated to this Frame.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame.CalcAngularVelocity(self:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">measured_in_frame:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">expressed_in_frame:</span> <span class="pre">pydrake.multibody.tree.Frame)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s angular velocity measured in a frame M,
expressed in a frame E.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">measured_in_frame</span></code>:</dt><dd><p>which is frame M (the frame in which <code class="docutils literal notranslate"><span class="pre">this</span></code> angular velocity is
to be measured).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">expressed_in_frame</span></code>:</dt><dd><p>which is frame E (the frame in which the returned angular velocity
is to be expressed).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>ω_MF_E, <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s angular velocity ω measured in frame M,
expressed in frame E.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>EvalAngularVelocityInWorld() to evaluate ω_WF_W (<code class="docutils literal notranslate"><span class="pre">this</span></code> frame
F’s angular velocity ω measured and expressed in the world frame
W).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame.CalcOffsetPoseInBody(self:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">X_FQ:</span> <span class="pre">pydrake.math.RigidTransform)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RigidTransform</span></span></dt>
<dd><p>Given the offset pose <code class="docutils literal notranslate"><span class="pre">X_FQ</span></code> of a frame Q in <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F, this
method computes the pose <code class="docutils literal notranslate"><span class="pre">X_BQ</span></code> of frame Q in the body frame B to
which this frame is attached. In other words, if the pose of <code class="docutils literal notranslate"><span class="pre">this</span></code>
frame F in the body frame B is <code class="docutils literal notranslate"><span class="pre">X_BF</span></code>, this method computes the pose
<code class="docutils literal notranslate"><span class="pre">X_BQ</span></code> of frame Q in the body frame B as <code class="docutils literal notranslate"><span class="pre">X_BQ</span> <span class="pre">=</span> <span class="pre">X_BF</span> <span class="pre">*</span> <span class="pre">X_FQ</span></code>. In
particular, if <code class="docutils literal notranslate"><span class="pre">this</span></code> <a href="#id5"><span class="problematic" id="id6">**</span></a>is**` the body frame B, i.e. <code class="docutils literal notranslate"><span class="pre">X_BF</span></code> is the
identity transformation, this method directly returns <code class="docutils literal notranslate"><span class="pre">X_FQ</span></code>.
Specific frame subclasses can override this method to provide faster
implementations if needed.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame.CalcOffsetRotationMatrixInBody(self:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">R_FQ:</span> <span class="pre">pydrake.math.RotationMatrix)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RotationMatrix</span></span></dt>
<dd><p>Calculates and returns the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_BQ</span></code> that relates body
frame B to frame Q via <code class="docutils literal notranslate"><span class="pre">this</span></code> intermediate frame F, i.e., <code class="docutils literal notranslate"><span class="pre">R_BQ</span> <span class="pre">=</span>
<span class="pre">R_BF</span> <span class="pre">*</span> <span class="pre">R_FQ</span></code> (B is the body frame to which <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F is
attached).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_FQ</span></code>:</dt><dd><p>rotation matrix that relates frame F to frame Q.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame.CalcPose(self:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">frame_M:</span> <span class="pre">pydrake.multibody.tree.Frame)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RigidTransform</span></span></dt>
<dd><p>Computes and returns the pose <code class="docutils literal notranslate"><span class="pre">X_MF</span></code> of <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F in measured
in <code class="docutils literal notranslate"><span class="pre">frame_M</span></code> as a function of the state of the model stored in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcPoseInWorld().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame.CalcPoseInBodyFrame(self:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RigidTransform</span></span></dt>
<dd><p>Returns the pose <code class="docutils literal notranslate"><span class="pre">X_BF</span></code> of <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F in the body frame B
associated with this frame. In particular, if <code class="docutils literal notranslate"><span class="pre">this</span></code> <strong>is</strong> the body
frame B, this method directly returns the identity transformation.
Note that this ONLY depends on the Parameters in the context; it does
not depend on time, input, state, etc.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame.CalcPoseInWorld(self:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RigidTransform</span></span></dt>
<dd><p>Computes and returns the pose <code class="docutils literal notranslate"><span class="pre">X_WF</span></code> of <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F in the
world frame W as a function of the state of the model stored in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>RigidBody::EvalPoseInWorld() provides a more efficient way to
obtain the pose for a body frame.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame.CalcRelativeSpatialAcceleration(self:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">other_frame:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">measured_in_frame:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">expressed_in_frame:</span> <span class="pre">pydrake.multibody.tree.Frame)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.math.SpatialAcceleration</span></span></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame C’s spatial acceleration relative to another
frame B, measured in a frame M, expressed in a frame E.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other_frame</span></code>:</dt><dd><p>which is frame B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">measured_in_frame</span></code>:</dt><dd><p>which is frame M.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">expressed_in_frame</span></code>:</dt><dd><p>which is frame E.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A_M_BC_E = A_MC_E - A_MB_E, frame C’s spatial acceleration
relative to frame B, measured in frame M, expressed in frame E.</p>
</dd>
</dl>
<p>In general, A_M_BC = DtW(V_M_BC), the time-derivative in frame M of
frame C’s spatial velocity relative to frame B. The rotational part of
the returned quantity is α_MC_E - α_MB_E = DtM(ω_BC)_E. Note: For 3D
analysis, DtM(ω_BC) ≠ α_BC. The translational part of the returned
quantity is a_M_BoCo_E (Co’s translational acceleration relative to
Bo, measured in frame M, expressed in frame E).</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">α_MC_E</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">α_MB_E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DtM</span><span class="p">(</span><span class="n">ω_MC</span><span class="p">)</span><span class="n">_E</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">DtM</span><span class="p">(</span><span class="n">ω_MB</span><span class="p">)</span><span class="n">_E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DtM</span><span class="p">(</span><span class="n">ω_BC</span><span class="p">)</span><span class="n">_E</span>
<span class="w"> </span><span class="n">a_M_BoCo_E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_MCo_E</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a_MBo_E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DtM</span><span class="p">(</span><span class="n">v_MCo</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">DtM</span><span class="p">(</span><span class="n">v_MBo</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Dt²M</span><span class="p">(</span><span class="n">p_BoCo</span><span class="p">)</span><span class="n">_E</span>
</pre></div>
</div>
</details><p>where Dt²M(p_BoCo)_E is the 2ⁿᵈ time-derivative in frame M of p_BoCo
(the position vector from Bo to Co), and this result is expressed in
frame E.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The calculation of the 2ⁿᵈ time-derivative of the distance between
Bo and Co can be done with relative translational acceleration,
but this calculation does not depend on the measured-in-frame,
hence in this case, consider
CalcRelativeSpatialAccelerationInWorld() since it is faster.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcSpatialAccelerationInWorld(), CalcSpatialAcceleration(), and
CalcRelativeSpatialAccelerationInWorld().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame.CalcRelativeSpatialAccelerationInWorld(self:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">other_frame:</span> <span class="pre">pydrake.multibody.tree.Frame)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.math.SpatialAcceleration</span></span></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame C’s spatial acceleration relative to another
frame B, measured and expressed in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other_frame</span></code>:</dt><dd><p>which is frame B.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A_W_BC_W = A_WC_W - A_WB_W, frame C’s spatial acceleration
relative to frame B, measured and expressed in the world frame W.</p>
</dd>
</dl>
<p>In general, A_W_BC = DtW(V_W_BC), the time-derivative in the world
frame W of frame C’s spatial velocity relative to frame B. The
rotational part of the returned quantity is α_WC_W - α_WB_W =
DtW(ω_BC)_W. For 3D analysis, DtW(ω_BC) ≠ α_BC. The translational part
of the returned quantity is a_W_BoCo_W (Co’s translational
acceleration relative to Bo, measured and expressed in world frame W).</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">α_WC_W</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">α_WB_W</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DtW</span><span class="p">(</span><span class="n">ω_WC</span><span class="p">)</span><span class="n">_W</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">DtW</span><span class="p">(</span><span class="n">ω_WB</span><span class="p">)</span><span class="n">_W</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DtW</span><span class="p">(</span><span class="n">ω_BC</span><span class="p">)</span><span class="n">_W</span>
<span class="w"> </span><span class="n">a_W_BoCo_W</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_WCo_W</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a_WBo_W</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DtW</span><span class="p">(</span><span class="n">v_WCo</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">DtW</span><span class="p">(</span><span class="n">v_WBo</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Dt²W</span><span class="p">(</span><span class="n">p_BoCo</span><span class="p">)</span><span class="n">_W</span>
</pre></div>
</div>
</details><p>where Dt²W(p_BoCo)_W is the 2ⁿᵈ time-derivative in frame W of p_BoCo
(the position vector from Bo to Co), and this result is expressed in
frame W.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The method CalcSpatialAccelerationInWorld() is more efficient and
coherent if any of <code class="docutils literal notranslate"><span class="pre">this</span></code>, other_frame, or the world frame W are
the same.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcSpatialAccelerationInWorld(),
CalcRelativeSpatialAcceleration().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame.CalcRelativeSpatialVelocity(self:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">other_frame:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">measured_in_frame:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">expressed_in_frame:</span> <span class="pre">pydrake.multibody.tree.Frame)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.math.SpatialVelocity</span></span></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame C’s spatial velocity relative to another
frame B, measured in a frame M, expressed in a frame E.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other_frame</span></code>:</dt><dd><p>which is frame B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">measured_in_frame</span></code>:</dt><dd><p>which is frame M.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">expressed_in_frame</span></code>:</dt><dd><p>which is frame E.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>V_M_BC_E = V_MC_E - V_MB_E, frame C’s spatial velocity relative to
frame B, measured in frame M, expressed in frame E. The rotational
part of the returned quantity is ω_BC_E (C’s angular velocity
measured in B and expressed in E). The translational part is
v_M_BoCo_E (Co’s translational velocity relative to Bo, measured
in M, and expressed in E).</p>
</dd>
</dl>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ω_BC_E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ω_MC_E</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ω_MB_E</span>
<span class="w"> </span><span class="n">v_M_BoCo_E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v_MCo_E</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">v_MBo_E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DtM</span><span class="p">(</span><span class="n">p_BoCo</span><span class="p">)</span>
</pre></div>
</div>
</details><p>where DtM(p_BoCo) is the time-derivative in frame M of p_BoCo
(position vector from Bo to Co), and this vector is expressed in frame
E.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The method CalcSpatialVelocity() is more efficient and coherent if
any of <code class="docutils literal notranslate"><span class="pre">this</span></code>, other_frame, or measured_in_frame are the same.
Also, the value of V_M_BoCo does not depend on the
measured_in_frame if Bo and Co are coincident (i.e., p_BoCo = 0),
in which case consider the more efficient method
CalcRelativeSpatialVelocityInWorld(). Lastly, the calculation of
elongation between Bo and Co can be done with relative
translational velocity, but elongation does not depend on the
measured-in-frame (hence consider
CalcRelativeSpatialVelocityInWorld()).</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcSpatialVelocityInWorld(), CalcSpatialVelocity(), and
CalcRelativeSpatialVelocityInWorld().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame.CalcRelativeSpatialVelocityInWorld(self:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">other_frame:</span> <span class="pre">pydrake.multibody.tree.Frame)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.math.SpatialVelocity</span></span></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame C’s spatial velocity relative to another
frame B, measured and expressed in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other_frame</span></code>:</dt><dd><p>which is frame B.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>V_W_BC_W = V_WC_W - V_WB_W, frame C’s spatial velocity relative to
frame B, measured and expressed in the world frame W. The
rotational part of the returned quantity is ω_BC_W (C’s angular
velocity measured in B and expressed in W). The translational part
is v_W_BoCo_W (Co’s translational velocity relative to Bo,
measured and expressed in world frame W).</p>
</dd>
</dl>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ω_BC_W</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">ω_WC_W</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ω_WB_W</span>
<span class="w"> </span><span class="n">v_W_BoCo_W</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v_WCo_W</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">v_WBo_W</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DtW</span><span class="p">(</span><span class="n">p_BoCo</span><span class="p">)</span>
</pre></div>
</div>
</details><p>where DtW(p_BoCo) is the time-derivative in frame W of p_BoCo
(position vector from Bo to Co), and this vector is expressed in frame
W.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The method CalcSpatialVelocityInWorld() is more efficient and
coherent if any of <code class="docutils literal notranslate"><span class="pre">this</span></code>, other_frame, or the world frame W are
the same.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcSpatialVelocityInWorld() and CalcRelativeSpatialVelocity().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame.CalcRotationMatrix(self:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">frame_M:</span> <span class="pre">pydrake.multibody.tree.Frame)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RotationMatrix</span></span></dt>
<dd><p>Calculates and returns the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_MF</span></code> that relates
<code class="docutils literal notranslate"><span class="pre">frame_M</span></code> and <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F as a function of the state stored in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame.CalcRotationMatrixInBodyFrame(self:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RotationMatrix</span></span></dt>
<dd><p>Returns the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_BF</span></code> that relates body frame B to
<code class="docutils literal notranslate"><span class="pre">this</span></code> frame F (B is the body frame to which <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F is
attached).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code class="docutils literal notranslate"><span class="pre">this</span></code> is B, this method returns the identity RotationMatrix.
Note that this ONLY depends on the Parameters in the context; it
does not depend on time, input, state, etc.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame.CalcRotationMatrixInWorld(self:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RotationMatrix</span></span></dt>
<dd><p>Calculates and returns the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_WF</span></code> that relates the
world frame W and <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F as a function of the state stored
in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame.CalcSpatialAcceleration(self:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">measured_in_frame:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">expressed_in_frame:</span> <span class="pre">pydrake.multibody.tree.Frame)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.math.SpatialAcceleration</span></span></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial acceleration measured in a frame
M, expressed in a frame E.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">measured_in_frame</span></code>:</dt><dd><p>which is frame M.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">expressed_in_frame</span></code>:</dt><dd><p>which is frame E.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A_MF_E, <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial acceleration measured in frame
M, expressed in frame E. The rotational part of the returned
quantity is α_MF_E (frame F’s angular acceleration α measured in
frame M, expressed in frame E). The translational part is a_MFo_E
(translational acceleration of frame F’s origin point Fo, measured
in frame M, expressed in frame E). Although α_MF is defined below
in terms of DtM(ω_MF), the time-derivative in frame M of ω_MF, the
actual calculation of α_MF avoids differentiation. Similarly for
the definition vs. calculation for a_MFo.</p>
</dd>
</dl>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">α_MF</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DtM</span><span class="p">(</span><span class="n">ω_MF</span><span class="p">)</span><span class="w">           </span><span class="n">ω_MF</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">frame</span><span class="w"> </span><span class="n">F</span><span class="err">&#39;</span><span class="n">s</span><span class="w"> </span><span class="n">angular</span><span class="w"> </span><span class="n">velocity</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">frame</span><span class="w"> </span><span class="n">M</span><span class="p">.</span>
<span class="w"> </span><span class="n">a_MFo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DtM</span><span class="p">(</span><span class="n">v_MFo</span><span class="p">)</span><span class="w">    </span><span class="n">v_MF</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">Fo</span><span class="err">&#39;</span><span class="n">s</span><span class="w"> </span><span class="n">translational</span><span class="w"> </span><span class="n">acceleration</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">frame</span><span class="w"> </span><span class="n">M</span><span class="p">.</span>
</pre></div>
</div>
</details><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcSpatialAccelerationInWorld() and CalcSpatialVelocity().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame.CalcSpatialAccelerationInWorld(self:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.math.SpatialAcceleration</span></span></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial acceleration measured and
expressed in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A_WF_W, <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial acceleration measured and
expressed in the world frame W. The rotational part of the
returned quantity is α_WF_E (frame F’s angular acceleration α
measured and expressed in the world frame W). The translational
part is a_WFo_W (translational acceleration of frame F’s origin
point Fo, measured and expressed in the world frame W).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>RigidBody::EvalSpatialAccelerationInWorld() provides a more
efficient way to obtain a body frame’s spatial acceleration
measured in the world frame.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When cached values are out of sync with the state stored in
context, this method performs an expensive forward dynamics
computation, whereas once evaluated, successive calls to this
method are inexpensive.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcSpatialAcceleration() and CalcSpatialVelocityInWorld().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame.CalcSpatialVelocity(self:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">frame_M:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">frame_E:</span> <span class="pre">pydrake.multibody.tree.Frame)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.math.SpatialVelocity</span></span></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial velocity measured in a frame M,
expressed in a frame E.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_M</span></code>:</dt><dd><p>which is the measured_in_frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>which is the expressed_in_frame.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>V_MF_E, <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial velocity measured in frame M,
expressed in frame E. The rotational part of the returned quantity
is ω_MF_E (frame F’s angular velocity ω measured in frame M,
expressed in frame E). The translational part is v_MFo_E
(translational velocity v of frame F’s origin point Fo, measured
in frame M, expressed in frame E).</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcSpatialVelocityInWorld(), CalcRelativeSpatialVelocity(), and
CalcSpatialAcceleration().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame.CalcSpatialVelocityInWorld(self:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.math.SpatialVelocity</span></span></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial velocity measured and expressed
in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>V_WF_W, <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial velocity measured and expressed
in the world frame W. The rotational part of the returned quantity
is ω_WF_W (frame F’s angular velocity ω measured and expressed in
the world frame W). The translational part is v_WFo_W
(translational velocity v of frame F’s origin point Fo, measured
and expressed in the world frame W).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>RigidBody::EvalSpatialVelocityInWorld() provides a more efficient
way to obtain a body frame’s spatial velocity measured in the
world frame.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcSpatialVelocity(), CalcRelativeSpatialVelocityInWorld(), and
CalcSpatialAccelerationInWorld().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame.EvalAngularVelocityInWorld(self:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Evaluates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s angular velocity measured and expressed
in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>ω_WF_W (frame F’s angular velocity ω measured and expressed in the
world frame W).</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcAngularVelocity() to calculate ω_MF_E (<code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s
angular velocity ω measured in a frame M and expressed in a frame
E).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame.GetFixedOffsetPoseInBody(self:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">X_FQ:</span> <span class="pre">pydrake.math.RigidTransform)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RigidTransform</span></span></dt>
<dd><p>Variant of CalcOffsetPoseInBody() that given the offset pose <code class="docutils literal notranslate"><span class="pre">X_FQ</span></code>
of a frame Q in <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F, returns the pose <code class="docutils literal notranslate"><span class="pre">X_BQ</span></code> of frame Q
in the body frame B to which this frame is attached.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called on a Frame that does not have a fixed</strong> – </p></li>
<li><p><strong>offset in the body frame.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame.GetFixedPoseInBodyFrame(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetFixedPoseInBodyFrame(self: pydrake.multibody.tree.Frame) -&gt; pydrake.math.RigidTransform</p></li>
</ol>
<p>Variant of CalcPoseInBodyFrame() that returns the fixed pose <code class="docutils literal notranslate"><span class="pre">X_BF</span></code>
of <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F in the body frame B associated with this frame.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called on a Frame that does not have a fixed</strong> – </p></li>
<li><p><strong>offset in the body frame.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetFixedPoseInBodyFrame(self: pydrake.multibody.tree.Frame) -&gt; pydrake.math.RigidTransform</p></li>
</ol>
<p>Variant of CalcPoseInBodyFrame() that returns the fixed pose <code class="docutils literal notranslate"><span class="pre">X_BF</span></code>
of <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F in the body frame B associated with this frame.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called on a Frame that does not have a fixed</strong> – </p></li>
<li><p><strong>offset in the body frame.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame.GetFixedRotationMatrixInBody(self:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">R_FQ:</span> <span class="pre">pydrake.math.RotationMatrix)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RotationMatrix</span></span></dt>
<dd><p>Calculates and returns the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_BQ</span></code> that relates body
frame B to frame Q via <code class="docutils literal notranslate"><span class="pre">this</span></code> intermediate frame F, i.e., <code class="docutils literal notranslate"><span class="pre">R_BQ</span> <span class="pre">=</span>
<span class="pre">R_BF</span> <span class="pre">*</span> <span class="pre">R_FQ</span></code> (B is the body frame to which <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F is
attached).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_FQ</span></code>:</dt><dd><p>rotation matrix that relates frame F to frame Q.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if this frame F is a Frame that does not have a</strong> – </p></li>
<li><p><strong>fixed offset in the body frame B</strong><strong> (</strong><strong>i.e.</strong><strong>, </strong><strong>R_BF is not constant</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame.GetFixedRotationMatrixInBodyFrame(self:</span> <span class="pre">pydrake.multibody.tree.Frame)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RotationMatrix</span></span></dt>
<dd><p>Returns the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_BF</span></code> that relates body frame B to
<code class="docutils literal notranslate"><span class="pre">this</span></code> frame F (B is the body frame to which <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F is
attached).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if this frame F is a Frame that does not have a</strong> – </p></li>
<li><p><strong>fixed offset in the body frame B</strong><strong> (</strong><strong>i.e.</strong><strong>, </strong><strong>R_BF is not constant</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>Frame sub-classes that have a constant R_BF must override this</strong> – </p></li>
<li><p><strong>method. An example</strong><strong> of </strong><strong>a frame sub-class not implementing this</strong> – </p></li>
<li><p><strong>method would be that</strong><strong> of </strong><strong>a frame on a soft body</strong><strong>, </strong><strong>for which its pose</strong> – </p></li>
<li><p><strong>in the body frame depends on the state</strong><strong> of </strong><strong>deformation</strong><strong> of </strong><strong>the body.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame.GetParentPlant(self:</span> <span class="pre">pydrake.multibody.tree.Frame)</span> <span class="pre">-&gt;</span> <span class="pre">drake::multibody::MultibodyPlant&lt;double&gt;</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame.index(self:</span> <span class="pre">pydrake.multibody.tree.Frame)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.FrameIndex</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame.is_body_frame(self:</span> <span class="pre">pydrake.multibody.tree.Frame)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true if <code class="docutils literal notranslate"><span class="pre">this</span></code> is the body frame.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame.is_ephemeral(self:</span> <span class="pre">pydrake.multibody.tree.Frame)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame.is_world_frame(self:</span> <span class="pre">pydrake.multibody.tree.Frame)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true if <code class="docutils literal notranslate"><span class="pre">this</span></code> is the world frame.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame.model_instance(self:</span> <span class="pre">pydrake.multibody.tree.Frame)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame.name(self:</span> <span class="pre">pydrake.multibody.tree.Frame)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns the name of this frame. The name will never be empty.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame.scoped_name(self:</span> <span class="pre">pydrake.multibody.tree.Frame)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.ScopedName</span></span></dt>
<dd><p>Returns scoped name of this frame. Neither of the two pieces of the
name will be empty (the scope name and the element name).</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">Frame_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Frame_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Frame_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[AutoDiffXd]</span></span></dt>
<dd><p>%Frame is an abstract class representing a <em>material frame</em> (also
called a <em>physical frame</em>) of its underlying RigidBody. The Frame’s
origin is a material point of its RigidBody, and its axes have fixed
directions in that body. A Frame’s pose (position and orientation)
with respect to its RigidBodyFrame may be parameterized, but is fixed
(not time or state dependent) once parameters have been set.</p>
<p>An important characteristic of a Frame is that forces or torques
applied to a Frame are applied to the Frame’s underlying RigidBody.
Force-producing elements like joints, actuators, and constraints
usually employ two Frames, with one Frame connected to one body and
the other connected to a different body. Every Frame F can report the
RigidBody B to which it is attached and its pose X_BF with respect to
B’s RigidBodyFrame.</p>
<p>A Frame’s pose in World (or relative to other frames) is always
calculated starting with its pose relative to its underlying
RigidBodyFrame. Subclasses derived from Frame differ in how kinematic
calculations are performed. For example, the angular velocity of a
FixedOffsetFrame or RigidBodyFrame is identical to the angular
velocity of its underlying body, whereas the translational velocity of
a FixedOffsetFrame differs from that of a RigidBodyFrame.</p>
<p>Frame provides methods for obtaining its current orientation,
position, motion, etc. from a Context passed to those methods.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[AutoDiffXd].body(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">drake::multibody::RigidBody&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double,</span> <span class="pre">-1,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">-1,</span> <span class="pre">1&gt;</span> <span class="pre">&gt;</span> <span class="pre">&gt;</span></span></dt>
<dd><p>Returns a const reference to the body associated to this Frame.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[AutoDiffXd].CalcAngularVelocity(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">measured_in_frame:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">expressed_in_frame:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s angular velocity measured in a frame M,
expressed in a frame E.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">measured_in_frame</span></code>:</dt><dd><p>which is frame M (the frame in which <code class="docutils literal notranslate"><span class="pre">this</span></code> angular velocity is
to be measured).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">expressed_in_frame</span></code>:</dt><dd><p>which is frame E (the frame in which the returned angular velocity
is to be expressed).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>ω_MF_E, <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s angular velocity ω measured in frame M,
expressed in frame E.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>EvalAngularVelocityInWorld() to evaluate ω_WF_W (<code class="docutils literal notranslate"><span class="pre">this</span></code> frame
F’s angular velocity ω measured and expressed in the world frame
W).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[AutoDiffXd].CalcOffsetPoseInBody(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">X_FQ:</span> <span class="pre">pydrake.math.RigidTransform_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RigidTransform_[AutoDiffXd]</span></span></dt>
<dd><p>Given the offset pose <code class="docutils literal notranslate"><span class="pre">X_FQ</span></code> of a frame Q in <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F, this
method computes the pose <code class="docutils literal notranslate"><span class="pre">X_BQ</span></code> of frame Q in the body frame B to
which this frame is attached. In other words, if the pose of <code class="docutils literal notranslate"><span class="pre">this</span></code>
frame F in the body frame B is <code class="docutils literal notranslate"><span class="pre">X_BF</span></code>, this method computes the pose
<code class="docutils literal notranslate"><span class="pre">X_BQ</span></code> of frame Q in the body frame B as <code class="docutils literal notranslate"><span class="pre">X_BQ</span> <span class="pre">=</span> <span class="pre">X_BF</span> <span class="pre">*</span> <span class="pre">X_FQ</span></code>. In
particular, if <code class="docutils literal notranslate"><span class="pre">this</span></code> <a href="#id7"><span class="problematic" id="id8">**</span></a>is**` the body frame B, i.e. <code class="docutils literal notranslate"><span class="pre">X_BF</span></code> is the
identity transformation, this method directly returns <code class="docutils literal notranslate"><span class="pre">X_FQ</span></code>.
Specific frame subclasses can override this method to provide faster
implementations if needed.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[AutoDiffXd].CalcOffsetRotationMatrixInBody(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">R_FQ:</span> <span class="pre">pydrake.math.RotationMatrix_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RotationMatrix_[AutoDiffXd]</span></span></dt>
<dd><p>Calculates and returns the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_BQ</span></code> that relates body
frame B to frame Q via <code class="docutils literal notranslate"><span class="pre">this</span></code> intermediate frame F, i.e., <code class="docutils literal notranslate"><span class="pre">R_BQ</span> <span class="pre">=</span>
<span class="pre">R_BF</span> <span class="pre">*</span> <span class="pre">R_FQ</span></code> (B is the body frame to which <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F is
attached).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_FQ</span></code>:</dt><dd><p>rotation matrix that relates frame F to frame Q.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[AutoDiffXd].CalcPose(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">frame_M:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RigidTransform_[AutoDiffXd]</span></span></dt>
<dd><p>Computes and returns the pose <code class="docutils literal notranslate"><span class="pre">X_MF</span></code> of <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F in measured
in <code class="docutils literal notranslate"><span class="pre">frame_M</span></code> as a function of the state of the model stored in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcPoseInWorld().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[AutoDiffXd].CalcPoseInBodyFrame(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RigidTransform_[AutoDiffXd]</span></span></dt>
<dd><p>Returns the pose <code class="docutils literal notranslate"><span class="pre">X_BF</span></code> of <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F in the body frame B
associated with this frame. In particular, if <code class="docutils literal notranslate"><span class="pre">this</span></code> <strong>is</strong> the body
frame B, this method directly returns the identity transformation.
Note that this ONLY depends on the Parameters in the context; it does
not depend on time, input, state, etc.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[AutoDiffXd].CalcPoseInWorld(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RigidTransform_[AutoDiffXd]</span></span></dt>
<dd><p>Computes and returns the pose <code class="docutils literal notranslate"><span class="pre">X_WF</span></code> of <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F in the
world frame W as a function of the state of the model stored in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>RigidBody::EvalPoseInWorld() provides a more efficient way to
obtain the pose for a body frame.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[AutoDiffXd].CalcRelativeSpatialAcceleration(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">other_frame:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">measured_in_frame:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">expressed_in_frame:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]</span></span></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame C’s spatial acceleration relative to another
frame B, measured in a frame M, expressed in a frame E.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other_frame</span></code>:</dt><dd><p>which is frame B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">measured_in_frame</span></code>:</dt><dd><p>which is frame M.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">expressed_in_frame</span></code>:</dt><dd><p>which is frame E.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A_M_BC_E = A_MC_E - A_MB_E, frame C’s spatial acceleration
relative to frame B, measured in frame M, expressed in frame E.</p>
</dd>
</dl>
<p>In general, A_M_BC = DtW(V_M_BC), the time-derivative in frame M of
frame C’s spatial velocity relative to frame B. The rotational part of
the returned quantity is α_MC_E - α_MB_E = DtM(ω_BC)_E. Note: For 3D
analysis, DtM(ω_BC) ≠ α_BC. The translational part of the returned
quantity is a_M_BoCo_E (Co’s translational acceleration relative to
Bo, measured in frame M, expressed in frame E).</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">α_MC_E</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">α_MB_E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DtM</span><span class="p">(</span><span class="n">ω_MC</span><span class="p">)</span><span class="n">_E</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">DtM</span><span class="p">(</span><span class="n">ω_MB</span><span class="p">)</span><span class="n">_E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DtM</span><span class="p">(</span><span class="n">ω_BC</span><span class="p">)</span><span class="n">_E</span>
<span class="w"> </span><span class="n">a_M_BoCo_E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_MCo_E</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a_MBo_E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DtM</span><span class="p">(</span><span class="n">v_MCo</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">DtM</span><span class="p">(</span><span class="n">v_MBo</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Dt²M</span><span class="p">(</span><span class="n">p_BoCo</span><span class="p">)</span><span class="n">_E</span>
</pre></div>
</div>
</details><p>where Dt²M(p_BoCo)_E is the 2ⁿᵈ time-derivative in frame M of p_BoCo
(the position vector from Bo to Co), and this result is expressed in
frame E.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The calculation of the 2ⁿᵈ time-derivative of the distance between
Bo and Co can be done with relative translational acceleration,
but this calculation does not depend on the measured-in-frame,
hence in this case, consider
CalcRelativeSpatialAccelerationInWorld() since it is faster.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcSpatialAccelerationInWorld(), CalcSpatialAcceleration(), and
CalcRelativeSpatialAccelerationInWorld().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[AutoDiffXd].CalcRelativeSpatialAccelerationInWorld(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">other_frame:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]</span></span></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame C’s spatial acceleration relative to another
frame B, measured and expressed in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other_frame</span></code>:</dt><dd><p>which is frame B.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A_W_BC_W = A_WC_W - A_WB_W, frame C’s spatial acceleration
relative to frame B, measured and expressed in the world frame W.</p>
</dd>
</dl>
<p>In general, A_W_BC = DtW(V_W_BC), the time-derivative in the world
frame W of frame C’s spatial velocity relative to frame B. The
rotational part of the returned quantity is α_WC_W - α_WB_W =
DtW(ω_BC)_W. For 3D analysis, DtW(ω_BC) ≠ α_BC. The translational part
of the returned quantity is a_W_BoCo_W (Co’s translational
acceleration relative to Bo, measured and expressed in world frame W).</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">α_WC_W</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">α_WB_W</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DtW</span><span class="p">(</span><span class="n">ω_WC</span><span class="p">)</span><span class="n">_W</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">DtW</span><span class="p">(</span><span class="n">ω_WB</span><span class="p">)</span><span class="n">_W</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DtW</span><span class="p">(</span><span class="n">ω_BC</span><span class="p">)</span><span class="n">_W</span>
<span class="w"> </span><span class="n">a_W_BoCo_W</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_WCo_W</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a_WBo_W</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DtW</span><span class="p">(</span><span class="n">v_WCo</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">DtW</span><span class="p">(</span><span class="n">v_WBo</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Dt²W</span><span class="p">(</span><span class="n">p_BoCo</span><span class="p">)</span><span class="n">_W</span>
</pre></div>
</div>
</details><p>where Dt²W(p_BoCo)_W is the 2ⁿᵈ time-derivative in frame W of p_BoCo
(the position vector from Bo to Co), and this result is expressed in
frame W.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The method CalcSpatialAccelerationInWorld() is more efficient and
coherent if any of <code class="docutils literal notranslate"><span class="pre">this</span></code>, other_frame, or the world frame W are
the same.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcSpatialAccelerationInWorld(),
CalcRelativeSpatialAcceleration().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[AutoDiffXd].CalcRelativeSpatialVelocity(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">other_frame:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">measured_in_frame:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">expressed_in_frame:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]</span></span></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame C’s spatial velocity relative to another
frame B, measured in a frame M, expressed in a frame E.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other_frame</span></code>:</dt><dd><p>which is frame B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">measured_in_frame</span></code>:</dt><dd><p>which is frame M.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">expressed_in_frame</span></code>:</dt><dd><p>which is frame E.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>V_M_BC_E = V_MC_E - V_MB_E, frame C’s spatial velocity relative to
frame B, measured in frame M, expressed in frame E. The rotational
part of the returned quantity is ω_BC_E (C’s angular velocity
measured in B and expressed in E). The translational part is
v_M_BoCo_E (Co’s translational velocity relative to Bo, measured
in M, and expressed in E).</p>
</dd>
</dl>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ω_BC_E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ω_MC_E</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ω_MB_E</span>
<span class="w"> </span><span class="n">v_M_BoCo_E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v_MCo_E</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">v_MBo_E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DtM</span><span class="p">(</span><span class="n">p_BoCo</span><span class="p">)</span>
</pre></div>
</div>
</details><p>where DtM(p_BoCo) is the time-derivative in frame M of p_BoCo
(position vector from Bo to Co), and this vector is expressed in frame
E.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The method CalcSpatialVelocity() is more efficient and coherent if
any of <code class="docutils literal notranslate"><span class="pre">this</span></code>, other_frame, or measured_in_frame are the same.
Also, the value of V_M_BoCo does not depend on the
measured_in_frame if Bo and Co are coincident (i.e., p_BoCo = 0),
in which case consider the more efficient method
CalcRelativeSpatialVelocityInWorld(). Lastly, the calculation of
elongation between Bo and Co can be done with relative
translational velocity, but elongation does not depend on the
measured-in-frame (hence consider
CalcRelativeSpatialVelocityInWorld()).</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcSpatialVelocityInWorld(), CalcSpatialVelocity(), and
CalcRelativeSpatialVelocityInWorld().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[AutoDiffXd].CalcRelativeSpatialVelocityInWorld(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">other_frame:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]</span></span></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame C’s spatial velocity relative to another
frame B, measured and expressed in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other_frame</span></code>:</dt><dd><p>which is frame B.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>V_W_BC_W = V_WC_W - V_WB_W, frame C’s spatial velocity relative to
frame B, measured and expressed in the world frame W. The
rotational part of the returned quantity is ω_BC_W (C’s angular
velocity measured in B and expressed in W). The translational part
is v_W_BoCo_W (Co’s translational velocity relative to Bo,
measured and expressed in world frame W).</p>
</dd>
</dl>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ω_BC_W</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">ω_WC_W</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ω_WB_W</span>
<span class="w"> </span><span class="n">v_W_BoCo_W</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v_WCo_W</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">v_WBo_W</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DtW</span><span class="p">(</span><span class="n">p_BoCo</span><span class="p">)</span>
</pre></div>
</div>
</details><p>where DtW(p_BoCo) is the time-derivative in frame W of p_BoCo
(position vector from Bo to Co), and this vector is expressed in frame
W.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The method CalcSpatialVelocityInWorld() is more efficient and
coherent if any of <code class="docutils literal notranslate"><span class="pre">this</span></code>, other_frame, or the world frame W are
the same.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcSpatialVelocityInWorld() and CalcRelativeSpatialVelocity().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[AutoDiffXd].CalcRotationMatrix(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">frame_M:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RotationMatrix_[AutoDiffXd]</span></span></dt>
<dd><p>Calculates and returns the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_MF</span></code> that relates
<code class="docutils literal notranslate"><span class="pre">frame_M</span></code> and <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F as a function of the state stored in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[AutoDiffXd].CalcRotationMatrixInBodyFrame(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RotationMatrix_[AutoDiffXd]</span></span></dt>
<dd><p>Returns the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_BF</span></code> that relates body frame B to
<code class="docutils literal notranslate"><span class="pre">this</span></code> frame F (B is the body frame to which <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F is
attached).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code class="docutils literal notranslate"><span class="pre">this</span></code> is B, this method returns the identity RotationMatrix.
Note that this ONLY depends on the Parameters in the context; it
does not depend on time, input, state, etc.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[AutoDiffXd].CalcRotationMatrixInWorld(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RotationMatrix_[AutoDiffXd]</span></span></dt>
<dd><p>Calculates and returns the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_WF</span></code> that relates the
world frame W and <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F as a function of the state stored
in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[AutoDiffXd].CalcSpatialAcceleration(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">measured_in_frame:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">expressed_in_frame:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]</span></span></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial acceleration measured in a frame
M, expressed in a frame E.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">measured_in_frame</span></code>:</dt><dd><p>which is frame M.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">expressed_in_frame</span></code>:</dt><dd><p>which is frame E.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A_MF_E, <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial acceleration measured in frame
M, expressed in frame E. The rotational part of the returned
quantity is α_MF_E (frame F’s angular acceleration α measured in
frame M, expressed in frame E). The translational part is a_MFo_E
(translational acceleration of frame F’s origin point Fo, measured
in frame M, expressed in frame E). Although α_MF is defined below
in terms of DtM(ω_MF), the time-derivative in frame M of ω_MF, the
actual calculation of α_MF avoids differentiation. Similarly for
the definition vs. calculation for a_MFo.</p>
</dd>
</dl>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">α_MF</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DtM</span><span class="p">(</span><span class="n">ω_MF</span><span class="p">)</span><span class="w">           </span><span class="n">ω_MF</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">frame</span><span class="w"> </span><span class="n">F</span><span class="err">&#39;</span><span class="n">s</span><span class="w"> </span><span class="n">angular</span><span class="w"> </span><span class="n">velocity</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">frame</span><span class="w"> </span><span class="n">M</span><span class="p">.</span>
<span class="w"> </span><span class="n">a_MFo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DtM</span><span class="p">(</span><span class="n">v_MFo</span><span class="p">)</span><span class="w">    </span><span class="n">v_MF</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">Fo</span><span class="err">&#39;</span><span class="n">s</span><span class="w"> </span><span class="n">translational</span><span class="w"> </span><span class="n">acceleration</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">frame</span><span class="w"> </span><span class="n">M</span><span class="p">.</span>
</pre></div>
</div>
</details><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcSpatialAccelerationInWorld() and CalcSpatialVelocity().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[AutoDiffXd].CalcSpatialAccelerationInWorld(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]</span></span></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial acceleration measured and
expressed in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A_WF_W, <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial acceleration measured and
expressed in the world frame W. The rotational part of the
returned quantity is α_WF_E (frame F’s angular acceleration α
measured and expressed in the world frame W). The translational
part is a_WFo_W (translational acceleration of frame F’s origin
point Fo, measured and expressed in the world frame W).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>RigidBody::EvalSpatialAccelerationInWorld() provides a more
efficient way to obtain a body frame’s spatial acceleration
measured in the world frame.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When cached values are out of sync with the state stored in
context, this method performs an expensive forward dynamics
computation, whereas once evaluated, successive calls to this
method are inexpensive.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcSpatialAcceleration() and CalcSpatialVelocityInWorld().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[AutoDiffXd].CalcSpatialVelocity(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">frame_M:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">frame_E:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]</span></span></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial velocity measured in a frame M,
expressed in a frame E.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_M</span></code>:</dt><dd><p>which is the measured_in_frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>which is the expressed_in_frame.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>V_MF_E, <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial velocity measured in frame M,
expressed in frame E. The rotational part of the returned quantity
is ω_MF_E (frame F’s angular velocity ω measured in frame M,
expressed in frame E). The translational part is v_MFo_E
(translational velocity v of frame F’s origin point Fo, measured
in frame M, expressed in frame E).</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcSpatialVelocityInWorld(), CalcRelativeSpatialVelocity(), and
CalcSpatialAcceleration().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[AutoDiffXd].CalcSpatialVelocityInWorld(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]</span></span></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial velocity measured and expressed
in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>V_WF_W, <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial velocity measured and expressed
in the world frame W. The rotational part of the returned quantity
is ω_WF_W (frame F’s angular velocity ω measured and expressed in
the world frame W). The translational part is v_WFo_W
(translational velocity v of frame F’s origin point Fo, measured
and expressed in the world frame W).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>RigidBody::EvalSpatialVelocityInWorld() provides a more efficient
way to obtain a body frame’s spatial velocity measured in the
world frame.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcSpatialVelocity(), CalcRelativeSpatialVelocityInWorld(), and
CalcSpatialAccelerationInWorld().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[AutoDiffXd].EvalAngularVelocityInWorld(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Evaluates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s angular velocity measured and expressed
in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>ω_WF_W (frame F’s angular velocity ω measured and expressed in the
world frame W).</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcAngularVelocity() to calculate ω_MF_E (<code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s
angular velocity ω measured in a frame M and expressed in a frame
E).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[AutoDiffXd].GetFixedOffsetPoseInBody(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">X_FQ:</span> <span class="pre">pydrake.math.RigidTransform_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RigidTransform_[AutoDiffXd]</span></span></dt>
<dd><p>Variant of CalcOffsetPoseInBody() that given the offset pose <code class="docutils literal notranslate"><span class="pre">X_FQ</span></code>
of a frame Q in <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F, returns the pose <code class="docutils literal notranslate"><span class="pre">X_BQ</span></code> of frame Q
in the body frame B to which this frame is attached.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called on a Frame that does not have a fixed</strong> – </p></li>
<li><p><strong>offset in the body frame.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[AutoDiffXd].GetFixedPoseInBodyFrame(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetFixedPoseInBodyFrame(self: pydrake.multibody.tree.Frame_[AutoDiffXd]) -&gt; pydrake.math.RigidTransform_[AutoDiffXd]</p></li>
</ol>
<p>Variant of CalcPoseInBodyFrame() that returns the fixed pose <code class="docutils literal notranslate"><span class="pre">X_BF</span></code>
of <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F in the body frame B associated with this frame.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called on a Frame that does not have a fixed</strong> – </p></li>
<li><p><strong>offset in the body frame.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetFixedPoseInBodyFrame(self: pydrake.multibody.tree.Frame_[AutoDiffXd]) -&gt; pydrake.math.RigidTransform_[AutoDiffXd]</p></li>
</ol>
<p>Variant of CalcPoseInBodyFrame() that returns the fixed pose <code class="docutils literal notranslate"><span class="pre">X_BF</span></code>
of <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F in the body frame B associated with this frame.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called on a Frame that does not have a fixed</strong> – </p></li>
<li><p><strong>offset in the body frame.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[AutoDiffXd].GetFixedRotationMatrixInBody(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">R_FQ:</span> <span class="pre">pydrake.math.RotationMatrix_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RotationMatrix_[AutoDiffXd]</span></span></dt>
<dd><p>Calculates and returns the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_BQ</span></code> that relates body
frame B to frame Q via <code class="docutils literal notranslate"><span class="pre">this</span></code> intermediate frame F, i.e., <code class="docutils literal notranslate"><span class="pre">R_BQ</span> <span class="pre">=</span>
<span class="pre">R_BF</span> <span class="pre">*</span> <span class="pre">R_FQ</span></code> (B is the body frame to which <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F is
attached).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_FQ</span></code>:</dt><dd><p>rotation matrix that relates frame F to frame Q.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if this frame F is a Frame that does not have a</strong> – </p></li>
<li><p><strong>fixed offset in the body frame B</strong><strong> (</strong><strong>i.e.</strong><strong>, </strong><strong>R_BF is not constant</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[AutoDiffXd].GetFixedRotationMatrixInBodyFrame(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RotationMatrix_[AutoDiffXd]</span></span></dt>
<dd><p>Returns the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_BF</span></code> that relates body frame B to
<code class="docutils literal notranslate"><span class="pre">this</span></code> frame F (B is the body frame to which <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F is
attached).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if this frame F is a Frame that does not have a</strong> – </p></li>
<li><p><strong>fixed offset in the body frame B</strong><strong> (</strong><strong>i.e.</strong><strong>, </strong><strong>R_BF is not constant</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>Frame sub-classes that have a constant R_BF must override this</strong> – </p></li>
<li><p><strong>method. An example</strong><strong> of </strong><strong>a frame sub-class not implementing this</strong> – </p></li>
<li><p><strong>method would be that</strong><strong> of </strong><strong>a frame on a soft body</strong><strong>, </strong><strong>for which its pose</strong> – </p></li>
<li><p><strong>in the body frame depends on the state</strong><strong> of </strong><strong>deformation</strong><strong> of </strong><strong>the body.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[AutoDiffXd].GetParentPlant(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">drake::multibody::MultibodyPlant&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double,</span> <span class="pre">-1,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">-1,</span> <span class="pre">1&gt;</span> <span class="pre">&gt;</span> <span class="pre">&gt;</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[AutoDiffXd].index(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.FrameIndex</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[AutoDiffXd].is_body_frame(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true if <code class="docutils literal notranslate"><span class="pre">this</span></code> is the body frame.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[AutoDiffXd].is_ephemeral(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[AutoDiffXd].is_world_frame(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true if <code class="docutils literal notranslate"><span class="pre">this</span></code> is the world frame.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[AutoDiffXd].model_instance(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[AutoDiffXd].name(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns the name of this frame. The name will never be empty.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[AutoDiffXd].scoped_name(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.ScopedName</span></span></dt>
<dd><p>Returns scoped name of this frame. Neither of the two pieces of the
name will be empty (the scope name and the element name).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[Expression]</span></span></dt>
<dd><p>%Frame is an abstract class representing a <em>material frame</em> (also
called a <em>physical frame</em>) of its underlying RigidBody. The Frame’s
origin is a material point of its RigidBody, and its axes have fixed
directions in that body. A Frame’s pose (position and orientation)
with respect to its RigidBodyFrame may be parameterized, but is fixed
(not time or state dependent) once parameters have been set.</p>
<p>An important characteristic of a Frame is that forces or torques
applied to a Frame are applied to the Frame’s underlying RigidBody.
Force-producing elements like joints, actuators, and constraints
usually employ two Frames, with one Frame connected to one body and
the other connected to a different body. Every Frame F can report the
RigidBody B to which it is attached and its pose X_BF with respect to
B’s RigidBodyFrame.</p>
<p>A Frame’s pose in World (or relative to other frames) is always
calculated starting with its pose relative to its underlying
RigidBodyFrame. Subclasses derived from Frame differ in how kinematic
calculations are performed. For example, the angular velocity of a
FixedOffsetFrame or RigidBodyFrame is identical to the angular
velocity of its underlying body, whereas the translational velocity of
a FixedOffsetFrame differs from that of a RigidBodyFrame.</p>
<p>Frame provides methods for obtaining its current orientation,
position, motion, etc. from a Context passed to those methods.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[Expression].body(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">drake::multibody::RigidBody&lt;drake::symbolic::Expression&gt;</span></span></dt>
<dd><p>Returns a const reference to the body associated to this Frame.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[Expression].CalcAngularVelocity(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">measured_in_frame:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">expressed_in_frame:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s angular velocity measured in a frame M,
expressed in a frame E.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">measured_in_frame</span></code>:</dt><dd><p>which is frame M (the frame in which <code class="docutils literal notranslate"><span class="pre">this</span></code> angular velocity is
to be measured).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">expressed_in_frame</span></code>:</dt><dd><p>which is frame E (the frame in which the returned angular velocity
is to be expressed).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>ω_MF_E, <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s angular velocity ω measured in frame M,
expressed in frame E.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>EvalAngularVelocityInWorld() to evaluate ω_WF_W (<code class="docutils literal notranslate"><span class="pre">this</span></code> frame
F’s angular velocity ω measured and expressed in the world frame
W).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[Expression].CalcOffsetPoseInBody(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">X_FQ:</span> <span class="pre">pydrake.math.RigidTransform_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RigidTransform_[Expression]</span></span></dt>
<dd><p>Given the offset pose <code class="docutils literal notranslate"><span class="pre">X_FQ</span></code> of a frame Q in <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F, this
method computes the pose <code class="docutils literal notranslate"><span class="pre">X_BQ</span></code> of frame Q in the body frame B to
which this frame is attached. In other words, if the pose of <code class="docutils literal notranslate"><span class="pre">this</span></code>
frame F in the body frame B is <code class="docutils literal notranslate"><span class="pre">X_BF</span></code>, this method computes the pose
<code class="docutils literal notranslate"><span class="pre">X_BQ</span></code> of frame Q in the body frame B as <code class="docutils literal notranslate"><span class="pre">X_BQ</span> <span class="pre">=</span> <span class="pre">X_BF</span> <span class="pre">*</span> <span class="pre">X_FQ</span></code>. In
particular, if <code class="docutils literal notranslate"><span class="pre">this</span></code> <a href="#id9"><span class="problematic" id="id10">**</span></a>is**` the body frame B, i.e. <code class="docutils literal notranslate"><span class="pre">X_BF</span></code> is the
identity transformation, this method directly returns <code class="docutils literal notranslate"><span class="pre">X_FQ</span></code>.
Specific frame subclasses can override this method to provide faster
implementations if needed.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[Expression].CalcOffsetRotationMatrixInBody(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">R_FQ:</span> <span class="pre">pydrake.math.RotationMatrix_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RotationMatrix_[Expression]</span></span></dt>
<dd><p>Calculates and returns the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_BQ</span></code> that relates body
frame B to frame Q via <code class="docutils literal notranslate"><span class="pre">this</span></code> intermediate frame F, i.e., <code class="docutils literal notranslate"><span class="pre">R_BQ</span> <span class="pre">=</span>
<span class="pre">R_BF</span> <span class="pre">*</span> <span class="pre">R_FQ</span></code> (B is the body frame to which <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F is
attached).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_FQ</span></code>:</dt><dd><p>rotation matrix that relates frame F to frame Q.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[Expression].CalcPose(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">frame_M:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RigidTransform_[Expression]</span></span></dt>
<dd><p>Computes and returns the pose <code class="docutils literal notranslate"><span class="pre">X_MF</span></code> of <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F in measured
in <code class="docutils literal notranslate"><span class="pre">frame_M</span></code> as a function of the state of the model stored in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcPoseInWorld().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[Expression].CalcPoseInBodyFrame(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RigidTransform_[Expression]</span></span></dt>
<dd><p>Returns the pose <code class="docutils literal notranslate"><span class="pre">X_BF</span></code> of <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F in the body frame B
associated with this frame. In particular, if <code class="docutils literal notranslate"><span class="pre">this</span></code> <strong>is</strong> the body
frame B, this method directly returns the identity transformation.
Note that this ONLY depends on the Parameters in the context; it does
not depend on time, input, state, etc.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[Expression].CalcPoseInWorld(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RigidTransform_[Expression]</span></span></dt>
<dd><p>Computes and returns the pose <code class="docutils literal notranslate"><span class="pre">X_WF</span></code> of <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F in the
world frame W as a function of the state of the model stored in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>RigidBody::EvalPoseInWorld() provides a more efficient way to
obtain the pose for a body frame.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[Expression].CalcRelativeSpatialAcceleration(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">other_frame:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">measured_in_frame:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">expressed_in_frame:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.math.SpatialAcceleration_[Expression]</span></span></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame C’s spatial acceleration relative to another
frame B, measured in a frame M, expressed in a frame E.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other_frame</span></code>:</dt><dd><p>which is frame B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">measured_in_frame</span></code>:</dt><dd><p>which is frame M.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">expressed_in_frame</span></code>:</dt><dd><p>which is frame E.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A_M_BC_E = A_MC_E - A_MB_E, frame C’s spatial acceleration
relative to frame B, measured in frame M, expressed in frame E.</p>
</dd>
</dl>
<p>In general, A_M_BC = DtW(V_M_BC), the time-derivative in frame M of
frame C’s spatial velocity relative to frame B. The rotational part of
the returned quantity is α_MC_E - α_MB_E = DtM(ω_BC)_E. Note: For 3D
analysis, DtM(ω_BC) ≠ α_BC. The translational part of the returned
quantity is a_M_BoCo_E (Co’s translational acceleration relative to
Bo, measured in frame M, expressed in frame E).</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">α_MC_E</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">α_MB_E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DtM</span><span class="p">(</span><span class="n">ω_MC</span><span class="p">)</span><span class="n">_E</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">DtM</span><span class="p">(</span><span class="n">ω_MB</span><span class="p">)</span><span class="n">_E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DtM</span><span class="p">(</span><span class="n">ω_BC</span><span class="p">)</span><span class="n">_E</span>
<span class="w"> </span><span class="n">a_M_BoCo_E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_MCo_E</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a_MBo_E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DtM</span><span class="p">(</span><span class="n">v_MCo</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">DtM</span><span class="p">(</span><span class="n">v_MBo</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Dt²M</span><span class="p">(</span><span class="n">p_BoCo</span><span class="p">)</span><span class="n">_E</span>
</pre></div>
</div>
</details><p>where Dt²M(p_BoCo)_E is the 2ⁿᵈ time-derivative in frame M of p_BoCo
(the position vector from Bo to Co), and this result is expressed in
frame E.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The calculation of the 2ⁿᵈ time-derivative of the distance between
Bo and Co can be done with relative translational acceleration,
but this calculation does not depend on the measured-in-frame,
hence in this case, consider
CalcRelativeSpatialAccelerationInWorld() since it is faster.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcSpatialAccelerationInWorld(), CalcSpatialAcceleration(), and
CalcRelativeSpatialAccelerationInWorld().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[Expression].CalcRelativeSpatialAccelerationInWorld(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">other_frame:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.math.SpatialAcceleration_[Expression]</span></span></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame C’s spatial acceleration relative to another
frame B, measured and expressed in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other_frame</span></code>:</dt><dd><p>which is frame B.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A_W_BC_W = A_WC_W - A_WB_W, frame C’s spatial acceleration
relative to frame B, measured and expressed in the world frame W.</p>
</dd>
</dl>
<p>In general, A_W_BC = DtW(V_W_BC), the time-derivative in the world
frame W of frame C’s spatial velocity relative to frame B. The
rotational part of the returned quantity is α_WC_W - α_WB_W =
DtW(ω_BC)_W. For 3D analysis, DtW(ω_BC) ≠ α_BC. The translational part
of the returned quantity is a_W_BoCo_W (Co’s translational
acceleration relative to Bo, measured and expressed in world frame W).</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">α_WC_W</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">α_WB_W</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DtW</span><span class="p">(</span><span class="n">ω_WC</span><span class="p">)</span><span class="n">_W</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">DtW</span><span class="p">(</span><span class="n">ω_WB</span><span class="p">)</span><span class="n">_W</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DtW</span><span class="p">(</span><span class="n">ω_BC</span><span class="p">)</span><span class="n">_W</span>
<span class="w"> </span><span class="n">a_W_BoCo_W</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_WCo_W</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a_WBo_W</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DtW</span><span class="p">(</span><span class="n">v_WCo</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">DtW</span><span class="p">(</span><span class="n">v_WBo</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Dt²W</span><span class="p">(</span><span class="n">p_BoCo</span><span class="p">)</span><span class="n">_W</span>
</pre></div>
</div>
</details><p>where Dt²W(p_BoCo)_W is the 2ⁿᵈ time-derivative in frame W of p_BoCo
(the position vector from Bo to Co), and this result is expressed in
frame W.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The method CalcSpatialAccelerationInWorld() is more efficient and
coherent if any of <code class="docutils literal notranslate"><span class="pre">this</span></code>, other_frame, or the world frame W are
the same.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcSpatialAccelerationInWorld(),
CalcRelativeSpatialAcceleration().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[Expression].CalcRelativeSpatialVelocity(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">other_frame:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">measured_in_frame:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">expressed_in_frame:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.math.SpatialVelocity_[Expression]</span></span></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame C’s spatial velocity relative to another
frame B, measured in a frame M, expressed in a frame E.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other_frame</span></code>:</dt><dd><p>which is frame B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">measured_in_frame</span></code>:</dt><dd><p>which is frame M.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">expressed_in_frame</span></code>:</dt><dd><p>which is frame E.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>V_M_BC_E = V_MC_E - V_MB_E, frame C’s spatial velocity relative to
frame B, measured in frame M, expressed in frame E. The rotational
part of the returned quantity is ω_BC_E (C’s angular velocity
measured in B and expressed in E). The translational part is
v_M_BoCo_E (Co’s translational velocity relative to Bo, measured
in M, and expressed in E).</p>
</dd>
</dl>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ω_BC_E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ω_MC_E</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ω_MB_E</span>
<span class="w"> </span><span class="n">v_M_BoCo_E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v_MCo_E</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">v_MBo_E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DtM</span><span class="p">(</span><span class="n">p_BoCo</span><span class="p">)</span>
</pre></div>
</div>
</details><p>where DtM(p_BoCo) is the time-derivative in frame M of p_BoCo
(position vector from Bo to Co), and this vector is expressed in frame
E.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The method CalcSpatialVelocity() is more efficient and coherent if
any of <code class="docutils literal notranslate"><span class="pre">this</span></code>, other_frame, or measured_in_frame are the same.
Also, the value of V_M_BoCo does not depend on the
measured_in_frame if Bo and Co are coincident (i.e., p_BoCo = 0),
in which case consider the more efficient method
CalcRelativeSpatialVelocityInWorld(). Lastly, the calculation of
elongation between Bo and Co can be done with relative
translational velocity, but elongation does not depend on the
measured-in-frame (hence consider
CalcRelativeSpatialVelocityInWorld()).</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcSpatialVelocityInWorld(), CalcSpatialVelocity(), and
CalcRelativeSpatialVelocityInWorld().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[Expression].CalcRelativeSpatialVelocityInWorld(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">other_frame:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.math.SpatialVelocity_[Expression]</span></span></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame C’s spatial velocity relative to another
frame B, measured and expressed in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other_frame</span></code>:</dt><dd><p>which is frame B.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>V_W_BC_W = V_WC_W - V_WB_W, frame C’s spatial velocity relative to
frame B, measured and expressed in the world frame W. The
rotational part of the returned quantity is ω_BC_W (C’s angular
velocity measured in B and expressed in W). The translational part
is v_W_BoCo_W (Co’s translational velocity relative to Bo,
measured and expressed in world frame W).</p>
</dd>
</dl>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">ω_BC_W</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">ω_WC_W</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ω_WB_W</span>
<span class="w"> </span><span class="n">v_W_BoCo_W</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v_WCo_W</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">v_WBo_W</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DtW</span><span class="p">(</span><span class="n">p_BoCo</span><span class="p">)</span>
</pre></div>
</div>
</details><p>where DtW(p_BoCo) is the time-derivative in frame W of p_BoCo
(position vector from Bo to Co), and this vector is expressed in frame
W.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The method CalcSpatialVelocityInWorld() is more efficient and
coherent if any of <code class="docutils literal notranslate"><span class="pre">this</span></code>, other_frame, or the world frame W are
the same.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcSpatialVelocityInWorld() and CalcRelativeSpatialVelocity().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[Expression].CalcRotationMatrix(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">frame_M:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RotationMatrix_[Expression]</span></span></dt>
<dd><p>Calculates and returns the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_MF</span></code> that relates
<code class="docutils literal notranslate"><span class="pre">frame_M</span></code> and <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F as a function of the state stored in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[Expression].CalcRotationMatrixInBodyFrame(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RotationMatrix_[Expression]</span></span></dt>
<dd><p>Returns the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_BF</span></code> that relates body frame B to
<code class="docutils literal notranslate"><span class="pre">this</span></code> frame F (B is the body frame to which <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F is
attached).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <code class="docutils literal notranslate"><span class="pre">this</span></code> is B, this method returns the identity RotationMatrix.
Note that this ONLY depends on the Parameters in the context; it
does not depend on time, input, state, etc.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[Expression].CalcRotationMatrixInWorld(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RotationMatrix_[Expression]</span></span></dt>
<dd><p>Calculates and returns the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_WF</span></code> that relates the
world frame W and <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F as a function of the state stored
in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[Expression].CalcSpatialAcceleration(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">measured_in_frame:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">expressed_in_frame:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.math.SpatialAcceleration_[Expression]</span></span></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial acceleration measured in a frame
M, expressed in a frame E.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">measured_in_frame</span></code>:</dt><dd><p>which is frame M.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">expressed_in_frame</span></code>:</dt><dd><p>which is frame E.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A_MF_E, <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial acceleration measured in frame
M, expressed in frame E. The rotational part of the returned
quantity is α_MF_E (frame F’s angular acceleration α measured in
frame M, expressed in frame E). The translational part is a_MFo_E
(translational acceleration of frame F’s origin point Fo, measured
in frame M, expressed in frame E). Although α_MF is defined below
in terms of DtM(ω_MF), the time-derivative in frame M of ω_MF, the
actual calculation of α_MF avoids differentiation. Similarly for
the definition vs. calculation for a_MFo.</p>
</dd>
</dl>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">α_MF</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DtM</span><span class="p">(</span><span class="n">ω_MF</span><span class="p">)</span><span class="w">           </span><span class="n">ω_MF</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">frame</span><span class="w"> </span><span class="n">F</span><span class="err">&#39;</span><span class="n">s</span><span class="w"> </span><span class="n">angular</span><span class="w"> </span><span class="n">velocity</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">frame</span><span class="w"> </span><span class="n">M</span><span class="p">.</span>
<span class="w"> </span><span class="n">a_MFo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DtM</span><span class="p">(</span><span class="n">v_MFo</span><span class="p">)</span><span class="w">    </span><span class="n">v_MF</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">Fo</span><span class="err">&#39;</span><span class="n">s</span><span class="w"> </span><span class="n">translational</span><span class="w"> </span><span class="n">acceleration</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">frame</span><span class="w"> </span><span class="n">M</span><span class="p">.</span>
</pre></div>
</div>
</details><div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcSpatialAccelerationInWorld() and CalcSpatialVelocity().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[Expression].CalcSpatialAccelerationInWorld(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.math.SpatialAcceleration_[Expression]</span></span></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial acceleration measured and
expressed in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>A_WF_W, <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial acceleration measured and
expressed in the world frame W. The rotational part of the
returned quantity is α_WF_E (frame F’s angular acceleration α
measured and expressed in the world frame W). The translational
part is a_WFo_W (translational acceleration of frame F’s origin
point Fo, measured and expressed in the world frame W).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>RigidBody::EvalSpatialAccelerationInWorld() provides a more
efficient way to obtain a body frame’s spatial acceleration
measured in the world frame.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When cached values are out of sync with the state stored in
context, this method performs an expensive forward dynamics
computation, whereas once evaluated, successive calls to this
method are inexpensive.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcSpatialAcceleration() and CalcSpatialVelocityInWorld().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[Expression].CalcSpatialVelocity(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">frame_M:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">frame_E:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.math.SpatialVelocity_[Expression]</span></span></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial velocity measured in a frame M,
expressed in a frame E.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_M</span></code>:</dt><dd><p>which is the measured_in_frame.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>which is the expressed_in_frame.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>V_MF_E, <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial velocity measured in frame M,
expressed in frame E. The rotational part of the returned quantity
is ω_MF_E (frame F’s angular velocity ω measured in frame M,
expressed in frame E). The translational part is v_MFo_E
(translational velocity v of frame F’s origin point Fo, measured
in frame M, expressed in frame E).</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcSpatialVelocityInWorld(), CalcRelativeSpatialVelocity(), and
CalcSpatialAcceleration().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[Expression].CalcSpatialVelocityInWorld(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.math.SpatialVelocity_[Expression]</span></span></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial velocity measured and expressed
in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>V_WF_W, <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial velocity measured and expressed
in the world frame W. The rotational part of the returned quantity
is ω_WF_W (frame F’s angular velocity ω measured and expressed in
the world frame W). The translational part is v_WFo_W
(translational velocity v of frame F’s origin point Fo, measured
and expressed in the world frame W).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>RigidBody::EvalSpatialVelocityInWorld() provides a more efficient
way to obtain a body frame’s spatial velocity measured in the
world frame.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcSpatialVelocity(), CalcRelativeSpatialVelocityInWorld(), and
CalcSpatialAccelerationInWorld().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[Expression].EvalAngularVelocityInWorld(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Evaluates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s angular velocity measured and expressed
in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>ω_WF_W (frame F’s angular velocity ω measured and expressed in the
world frame W).</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcAngularVelocity() to calculate ω_MF_E (<code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s
angular velocity ω measured in a frame M and expressed in a frame
E).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[Expression].GetFixedOffsetPoseInBody(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">X_FQ:</span> <span class="pre">pydrake.math.RigidTransform_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RigidTransform_[Expression]</span></span></dt>
<dd><p>Variant of CalcOffsetPoseInBody() that given the offset pose <code class="docutils literal notranslate"><span class="pre">X_FQ</span></code>
of a frame Q in <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F, returns the pose <code class="docutils literal notranslate"><span class="pre">X_BQ</span></code> of frame Q
in the body frame B to which this frame is attached.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called on a Frame that does not have a fixed</strong> – </p></li>
<li><p><strong>offset in the body frame.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[Expression].GetFixedPoseInBodyFrame(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>GetFixedPoseInBodyFrame(self: pydrake.multibody.tree.Frame_[Expression]) -&gt; pydrake.math.RigidTransform_[Expression]</p></li>
</ol>
<p>Variant of CalcPoseInBodyFrame() that returns the fixed pose <code class="docutils literal notranslate"><span class="pre">X_BF</span></code>
of <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F in the body frame B associated with this frame.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called on a Frame that does not have a fixed</strong> – </p></li>
<li><p><strong>offset in the body frame.</strong> – </p></li>
</ul>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>GetFixedPoseInBodyFrame(self: pydrake.multibody.tree.Frame_[Expression]) -&gt; pydrake.math.RigidTransform_[Expression]</p></li>
</ol>
<p>Variant of CalcPoseInBodyFrame() that returns the fixed pose <code class="docutils literal notranslate"><span class="pre">X_BF</span></code>
of <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F in the body frame B associated with this frame.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called on a Frame that does not have a fixed</strong> – </p></li>
<li><p><strong>offset in the body frame.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[Expression].GetFixedRotationMatrixInBody(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">R_FQ:</span> <span class="pre">pydrake.math.RotationMatrix_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RotationMatrix_[Expression]</span></span></dt>
<dd><p>Calculates and returns the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_BQ</span></code> that relates body
frame B to frame Q via <code class="docutils literal notranslate"><span class="pre">this</span></code> intermediate frame F, i.e., <code class="docutils literal notranslate"><span class="pre">R_BQ</span> <span class="pre">=</span>
<span class="pre">R_BF</span> <span class="pre">*</span> <span class="pre">R_FQ</span></code> (B is the body frame to which <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F is
attached).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_FQ</span></code>:</dt><dd><p>rotation matrix that relates frame F to frame Q.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if this frame F is a Frame that does not have a</strong> – </p></li>
<li><p><strong>fixed offset in the body frame B</strong><strong> (</strong><strong>i.e.</strong><strong>, </strong><strong>R_BF is not constant</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[Expression].GetFixedRotationMatrixInBodyFrame(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RotationMatrix_[Expression]</span></span></dt>
<dd><p>Returns the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_BF</span></code> that relates body frame B to
<code class="docutils literal notranslate"><span class="pre">this</span></code> frame F (B is the body frame to which <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F is
attached).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if this frame F is a Frame that does not have a</strong> – </p></li>
<li><p><strong>fixed offset in the body frame B</strong><strong> (</strong><strong>i.e.</strong><strong>, </strong><strong>R_BF is not constant</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>Frame sub-classes that have a constant R_BF must override this</strong> – </p></li>
<li><p><strong>method. An example</strong><strong> of </strong><strong>a frame sub-class not implementing this</strong> – </p></li>
<li><p><strong>method would be that</strong><strong> of </strong><strong>a frame on a soft body</strong><strong>, </strong><strong>for which its pose</strong> – </p></li>
<li><p><strong>in the body frame depends on the state</strong><strong> of </strong><strong>deformation</strong><strong> of </strong><strong>the body.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[Expression].GetParentPlant(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">drake::multibody::MultibodyPlant&lt;drake::symbolic::Expression&gt;</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[Expression].index(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.FrameIndex</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[Expression].is_body_frame(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true if <code class="docutils literal notranslate"><span class="pre">this</span></code> is the body frame.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[Expression].is_ephemeral(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[Expression].is_world_frame(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true if <code class="docutils literal notranslate"><span class="pre">this</span></code> is the world frame.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[Expression].model_instance(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[Expression].name(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns the name of this frame. The name will never be empty.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Frame_[Expression].scoped_name(self:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.ScopedName</span></span></dt>
<dd><p>Returns scoped name of this frame. Neither of the two pieces of the
name will be empty (the scope name and the element name).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FrameIndex</span></span></dt>
<dd><p>Type used to identify frames by index in a multibody plant.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FrameIndex.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.tree.FrameIndex) -&gt; None</p></li>
</ol>
<p>Default constructor; the result is an <em>invalid</em> index. This only
exists to serve applications which require a default constructor.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.tree.FrameIndex, arg0: int) -&gt; None</p></li>
</ol>
<p>Construction from a non-negative <code class="docutils literal notranslate"><span class="pre">int</span></code> value. The value must lie in
the range of [0, 2³¹). Constructor only promises to test validity in
Debug build.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">FrameIndex.is_valid(self:</span> <span class="pre">pydrake.multibody.tree.FrameIndex)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Reports if the index is valid–the only operation on an invalid index
that doesn’t throw an exception in Debug builds.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GravityForceField</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ForceDensityField</span></code></p>
<p>A uniform gravitational force density field for a uniform density
object. The force density f [N/m³] is given by the product of mass
density ρ [kg/m³] and gravity vector g [m/s²].</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">GravityForceField_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GravityForceField.__init__(self:</span> <span class="pre">pydrake.multibody.tree.GravityForceField,</span> <span class="pre">gravity_vector:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">mass_density:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a uniform gravitational force density field for a uniform
density object with the given <code class="docutils literal notranslate"><span class="pre">gravity_vector</span></code> [m/s²] and
<code class="docutils literal notranslate"><span class="pre">mass_density</span></code> [kg/m³] in the reference (undeformed) configuration
where the reference (undeformed) configuration is defined by the input
mesh provided by the user.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GravityForceField_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">GravityForceField_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">GravityForceField_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">GravityForceField_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GravityForceField_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ForceDensityField_[AutoDiffXd]</span></code></p>
<p>A uniform gravitational force density field for a uniform density
object. The force density f [N/m³] is given by the product of mass
density ρ [kg/m³] and gravity vector g [m/s²].</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GravityForceField_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.multibody.tree.GravityForceField_[AutoDiffXd],</span> <span class="pre">gravity_vector:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]],</span> <span class="pre">mass_density:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a uniform gravitational force density field for a uniform
density object with the given <code class="docutils literal notranslate"><span class="pre">gravity_vector</span></code> [m/s²] and
<code class="docutils literal notranslate"><span class="pre">mass_density</span></code> [kg/m³] in the reference (undeformed) configuration
where the reference (undeformed) configuration is defined by the input
mesh provided by the user.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GravityForceField_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ForceDensityField_[Expression]</span></code></p>
<p>A uniform gravitational force density field for a uniform density
object. The force density f [N/m³] is given by the product of mass
density ρ [kg/m³] and gravity vector g [m/s²].</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">GravityForceField_[Expression].__init__(self:</span> <span class="pre">pydrake.multibody.tree.GravityForceField_[Expression],</span> <span class="pre">gravity_vector:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]],</span> <span class="pre">mass_density:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a uniform gravitational force density field for a uniform
density object with the given <code class="docutils literal notranslate"><span class="pre">gravity_vector</span></code> [m/s²] and
<code class="docutils literal notranslate"><span class="pre">mass_density</span></code> [kg/m³] in the reference (undeformed) configuration
where the reference (undeformed) configuration is defined by the input
mesh provided by the user.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JacobianWrtVariable</span></span></dt>
<dd><p>Enumeration that indicates whether the Jacobian is partial
differentiation with respect to q̇ (time-derivatives of generalized
positions) or with respect to v (generalized velocities).</p>
<p>Members:</p>
<blockquote>
<div><p>kQDot : J = ∂V/∂q̇</p>
<p>kV : J = ∂V/∂v</p>
</div></blockquote>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JacobianWrtVariable.__init__(self:</span> <span class="pre">pydrake.multibody.tree.JacobianWrtVariable,</span> <span class="pre">value:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JacobianWrtVariable.kQDot</span></span></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JacobianWrtVariable.kV</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JacobianWrtVariable.name</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JacobianWrtVariable.value</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint</span></span></dt>
<dd><p>A Joint models the kinematical relationship which characterizes the
possible relative motion between two bodies. The two bodies connected
by this Joint object are referred to as <em>parent</em> and <em>child</em> bodies.
The parent/child ordering defines the sign conventions for the
generalized coordinates and the coordinate ordering for multi-DOF
joints. A Joint is a model of a physical kinematic constraint between
two bodies, a constraint that in the real physical system does not
specify a tree ordering. &#64;image html
drake/multibody/plant/images/BodyParentChildJoint.png width=50%</p>
<p>In Drake we define a frame F rigidly attached to the parent body P
with pose <code class="docutils literal notranslate"><span class="pre">X_PF</span></code> and a frame M rigidly attached to the child body B
with pose <code class="docutils literal notranslate"><span class="pre">X_BM</span></code>. A Joint object specifies a kinematic relation
between frames F and M, which in turn imposes a kinematic relation
between bodies P and B.</p>
<p>Typical joints include the ball joint, to allow unrestricted rotations
about a given point, the revolute joint, that constraints two bodies
to rotate about a given common axis, etc.</p>
<p>Consider the following example to build a simple pendulum system:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">plant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
<span class="c1">// ... Code here to setup quantities below as mass, com, etc. ...</span>
<span class="k">const</span><span class="w"> </span><span class="n">RigidBody</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">pendulum</span><span class="w"> </span><span class="o">=</span>
<span class="w">  </span><span class="n">plant</span><span class="p">.</span><span class="n">AddRigidBody</span><span class="p">(</span><span class="n">SpatialInertia</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mass</span><span class="p">,</span><span class="w"> </span><span class="n">com</span><span class="p">,</span><span class="w"> </span><span class="n">unit_inertia</span><span class="p">));</span>
<span class="c1">// We will connect the pendulum body to the world using a RevoluteJoint.</span>
<span class="c1">// In this simple case the parent body P is the model&#39;s world body and frame</span>
<span class="c1">// F IS the world frame.</span>
<span class="c1">// Additionally, we need to specify the pose of frame M on the pendulum&#39;s</span>
<span class="c1">// body frame B.</span>
<span class="c1">// Say we declared and initialized X_BM...</span>
<span class="k">const</span><span class="w"> </span><span class="n">RevoluteJoint</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">elbow</span><span class="w"> </span><span class="o">=</span>
<span class="w">  </span><span class="n">plant</span><span class="p">.</span><span class="n">AddJoint</span><span class="o">&lt;</span><span class="n">RevoluteJoint</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">    </span><span class="s">&quot;Elbow&quot;</span><span class="p">,</span><span class="w">                </span><span class="cm">/* joint name</span>
<span class="cm">    plant.world_body(),     /* parent body</span>
<span class="cm">    {},                     /* frame F IS the world frame W</span>
<span class="cm">    pendulum,               /* child body, the pendulum</span>
<span class="cm">    X_BM,                   /* pose of frame M in the body frame B</span>
<span class="cm">    Vector3d::UnitZ());     /* revolute axis in this case</span>
</pre></div>
</div>
</details><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Do not ever attempt to instantiate and manipulate Joint objects on
the stack; it will fail. Add joints to your plant using the
provided API MultibodyPlant::AddJoint() as in the example above.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To developers: this is the base class for all concrete Joint
types. Extending this class to add a new Joint type necessarily
requires working with internal implementation classes for which we
cannot guarantee API stability due to the need for ongoing
improvements to these performance-critical classes. So while our
usual stability guarantees apply to the Joint <code class="docutils literal notranslate"><span class="pre">public</span></code> API, the
<code class="docutils literal notranslate"><span class="pre">protected</span></code> API here is subject to change when the underlying
internal objects change. Our release notes will say when we have
made changes that might affect your Joint implementations, but we
won’t necessarily be able to provide a deprecation period.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">Joint_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.acceleration_lower_limits(self:</span> <span class="pre">pydrake.multibody.tree.Joint)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the acceleration lower limits.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.acceleration_upper_limits(self:</span> <span class="pre">pydrake.multibody.tree.Joint)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the acceleration upper limits.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.AddInDamping(self:</span> <span class="pre">pydrake.multibody.tree.Joint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">forces:</span> <span class="pre">pydrake.multibody.tree.MultibodyForces)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Adds into <code class="docutils literal notranslate"><span class="pre">forces</span></code> the force due to damping within <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> joint belongs.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">forces</span></code>:</dt><dd><p>On return, this method will add the force due to damping within
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint. This method aborts if <code class="docutils literal notranslate"><span class="pre">forces</span></code> is <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> or
if <code class="docutils literal notranslate"><span class="pre">forces</span></code> does not have the right sizes to accommodate a set
of forces for the model to which this joint belongs.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.AddInOneForce(self:</span> <span class="pre">pydrake.multibody.tree.Joint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">joint_dof:</span> <span class="pre">int,</span> <span class="pre">joint_tau:</span> <span class="pre">float,</span> <span class="pre">forces:</span> <span class="pre">pydrake.multibody.tree.MultibodyForces)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Adds into <code class="docutils literal notranslate"><span class="pre">forces</span></code> a force along the one of the joint’s degrees of
freedom indicated by index <code class="docutils literal notranslate"><span class="pre">joint_dof</span></code>. The meaning for this degree
of freedom and even its dimensional units depend on the specific joint
sub-class. For a RevoluteJoint for instance, <code class="docutils literal notranslate"><span class="pre">joint_dof</span></code> can only be
0 since revolute joints’s motion subspace only has one degree of
freedom, while the units of <code class="docutils literal notranslate"><span class="pre">joint_tau</span></code> are those of torque (N⋅m in
the MKS system of units). For multi-dof joints please refer to the
documentation provided by specific joint sub-classes regarding the
meaning of <code class="docutils literal notranslate"><span class="pre">joint_dof</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> joint belongs.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">joint_dof</span></code>:</dt><dd><p>Index specifying one of the degrees of freedom for this joint. The
index must be in the range <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">joint_dof</span> <span class="pre">&lt;</span> <span class="pre">num_velocities()</span></code>
or otherwise this method will abort.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">joint_tau</span></code>:</dt><dd><p>Generalized force corresponding to the degree of freedom indicated
by <code class="docutils literal notranslate"><span class="pre">joint_dof</span></code> to be added into <code class="docutils literal notranslate"><span class="pre">forces</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">forces</span></code>:</dt><dd><p>On return, this method will add force <code class="docutils literal notranslate"><span class="pre">joint_tau</span></code> for the degree
of freedom <code class="docutils literal notranslate"><span class="pre">joint_dof</span></code> into the output <code class="docutils literal notranslate"><span class="pre">forces</span></code>. This method
aborts if <code class="docutils literal notranslate"><span class="pre">forces</span></code> is <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> or if <code class="docutils literal notranslate"><span class="pre">forces</span></code> doest not
have the right sizes to accommodate a set of forces for the model
to which this joint belongs.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.can_rotate(self:</span> <span class="pre">pydrake.multibody.tree.Joint)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true if this joint’s mobility allows relative rotation of the
two frames associated with this joint.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>the MultibodyPlant must be finalized.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>can_translate()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.can_translate(self:</span> <span class="pre">pydrake.multibody.tree.Joint)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true if this joint’s mobility allows relative translation of
the two frames associated with this joint.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>the MultibodyPlant must be finalized.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>can_rotate()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.child_body(self:</span> <span class="pre">pydrake.multibody.tree.Joint)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RigidBody</span></span></dt>
<dd><p>Returns a const reference to the child body B.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.default_damping_vector(self:</span> <span class="pre">pydrake.multibody.tree.Joint)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns all default damping coefficients for joints that model viscous
damping, of size num_velocities(). Joints that do not model damping
return a zero vector of size num_velocities(). If vj is the vector of
generalized velocities for this joint, of size num_velocities(),
viscous damping models a generalized force at the joint of the form
tau = -diag(dj)⋅vj, with dj the vector returned by this function. The
units of the coefficients will depend on the specific joint type. For
instance, for a revolute joint where vj is an angular velocity with
units of rad/s and tau having units of N⋅m, the coefficient of viscous
damping has units of N⋅m⋅s. Refer to each joint’s documentation for
further details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.default_positions(self:</span> <span class="pre">pydrake.multibody.tree.Joint)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the default generalized position coordinates q₀. These will be
the values set with set_default_positions() if any; otherwise, they
will be the “zero configuration” for this joint type (as defined by
the particular joint type).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The default generalized velocities v₀ are zero for every joint.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.frame_on_child(self:</span> <span class="pre">pydrake.multibody.tree.Joint)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.Frame</span></span></dt>
<dd><p>Returns a const reference to the frame M attached on the child body B.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.frame_on_parent(self:</span> <span class="pre">pydrake.multibody.tree.Joint)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.Frame</span></span></dt>
<dd><p>Returns a const reference to the frame F attached on the parent body
P.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.GetDampingVector(self:</span> <span class="pre">pydrake.multibody.tree.Joint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the Context dependent damping coefficients stored as
parameters in <code class="docutils literal notranslate"><span class="pre">context</span></code>. Refer to default_damping_vector() for
details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> joint belongs.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.GetDefaultPose(self:</span> <span class="pre">pydrake.multibody.tree.Joint)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RigidTransform</span></span></dt>
<dd><p>Returns this joint’s default pose as a RigidTransform X_FM.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently this is implemented only for floating (6 dof) joints
which can represent any pose.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called for any joint type that does not implement</strong> – </p></li>
<li><p><strong>this function.</strong> – </p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">X_FM</span></code>:</dt><dd><p>The default pose as a rigid transform.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>default_positions() to see the generalized positions q₀ that this
joint used to generate the returned transform.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetDefaultPosePair() for an alternative using a quaternion</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.GetDefaultPosePair(self:</span> <span class="pre">pydrake.multibody.tree.Joint)</span> <span class="pre">-&gt;</span> <span class="pre">tuple[pydrake.common.eigen_geometry.Quaternion,</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]]</span></span></dt>
<dd><p>(Advanced) This is the same as GetDefaultPose() except it returns this
joint’s default pose as a (quaternion, translation vector) pair.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently this is implemented only for floating (6 dof) joints
which can represent any pose.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For a QuaternionFloatingJoint the return will be bit-identical to
the pose provided to SetDefaultPosePair(). For any other floating
(6 dof) joint the pose will be numerically equivalent (i.e. within
roundoff) but not identical. For other joint types it will be some
approximation.</p>
</div>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">q_FM</span></code>:</dt><dd><p>,p_FM The default pose as a (quaternion, translation) pair.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called for any joint type that does not implement</strong> – </p></li>
<li><p><strong>this function.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetDefaultPose()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.GetOnePosition(self:</span> <span class="pre">pydrake.multibody.tree.Joint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the position coordinate for joints with a single degree of
freedom.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the joint does not have a single degree of</strong> – </p></li>
<li><p><strong>freedom.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.GetOneVelocity(self:</span> <span class="pre">pydrake.multibody.tree.Joint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the velocity coordinate for joints with a single degree of
freedom.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the joint does not have a single degree of</strong> – </p></li>
<li><p><strong>freedom.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.GetParentPlant(self:</span> <span class="pre">pydrake.multibody.tree.Joint)</span> <span class="pre">-&gt;</span> <span class="pre">drake::multibody::MultibodyPlant&lt;double&gt;</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.index(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>index(self: pydrake.multibody.tree.Joint) -&gt; pydrake.multibody.tree.JointIndex</p></li>
<li><p>index(self: pydrake.multibody.tree.Joint) -&gt; pydrake.multibody.tree.JointIndex</p></li>
</ol>
<p>Returns this element’s unique index.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.is_ephemeral(self:</span> <span class="pre">pydrake.multibody.tree.Joint)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.is_locked(self:</span> <span class="pre">pydrake.multibody.tree.Joint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>true if the joint is locked, false otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.Lock(self:</span> <span class="pre">pydrake.multibody.tree.Joint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Lock the joint. Its generalized velocities will be 0 until it is
unlocked.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.model_instance(self:</span> <span class="pre">pydrake.multibody.tree.Joint)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.name(self:</span> <span class="pre">pydrake.multibody.tree.Joint)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns the name of this joint.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.num_positions(self:</span> <span class="pre">pydrake.multibody.tree.Joint)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of generalized positions describing this joint.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.num_velocities(self:</span> <span class="pre">pydrake.multibody.tree.Joint)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of generalized velocities describing this joint.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.parent_body(self:</span> <span class="pre">pydrake.multibody.tree.Joint)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RigidBody</span></span></dt>
<dd><p>Returns a const reference to the parent body P.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.position_lower_limits(self:</span> <span class="pre">pydrake.multibody.tree.Joint)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the position lower limits.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.position_start(self:</span> <span class="pre">pydrake.multibody.tree.Joint)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the index to the first generalized position for this joint
within the vector q of generalized positions for the full multibody
system.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.position_suffix(self:</span> <span class="pre">pydrake.multibody.tree.Joint,</span> <span class="pre">arg0:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a string suffix (e.g. to be appended to the name()) to
identify the <cite>k`th position in this joint. ``position_index_in_joint`</cite>
must be in [0, num_positions()).</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>the MultibodyPlant must be finalized.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.position_upper_limits(self:</span> <span class="pre">pydrake.multibody.tree.Joint)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the position upper limits.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.set_acceleration_limits(self:</span> <span class="pre">pydrake.multibody.tree.Joint,</span> <span class="pre">lower_limits:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">upper_limits:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the acceleration limits to <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> and <code class="docutils literal notranslate"><span class="pre">upper_limits</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the dimension</strong><strong> of </strong><strong>lower_limits or</strong> – </p></li>
<li><p><strong>upper_limits` does not match num_velocities</strong><strong>(</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if any</strong><strong> of </strong><strong>lower_limits is larger than the</strong> – </p></li>
<li><p><strong>corresponding term in upper_limits.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.set_default_damping_vector(self:</span> <span class="pre">pydrake.multibody.tree.Joint,</span> <span class="pre">damping:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default value of the viscous damping coefficients for this
joint. Refer to default_damping_vector() for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if damping.size</strong><strong>(</strong><strong>) </strong><strong>!= num_velocities</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if any</strong><strong> of </strong><strong>the damping coefficients is negative.</strong> – </p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>the MultibodyPlant must not be finalized.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.set_default_positions(self:</span> <span class="pre">pydrake.multibody.tree.Joint,</span> <span class="pre">default_positions:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default generalized position coordinates q₀ to
<code class="docutils literal notranslate"><span class="pre">default_positions</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The values in <code class="docutils literal notranslate"><span class="pre">default_positions</span></code> are NOT constrained to be
within position_lower_limits() and position_upper_limits().</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The default generalized velocities v₀ are zero for every joint.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the dimension</strong><strong> of </strong><strong>default_positions does not</strong> – </p></li>
<li><p><strong>match num_positions</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.set_position_limits(self:</span> <span class="pre">pydrake.multibody.tree.Joint,</span> <span class="pre">lower_limits:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">upper_limits:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the position limits to <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> and <code class="docutils literal notranslate"><span class="pre">upper_limits</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the dimension</strong><strong> of </strong><strong>lower_limits or</strong> – </p></li>
<li><p><strong>upper_limits` does not match num_positions</strong><strong>(</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if any</strong><strong> of </strong><strong>lower_limits is larger than the</strong> – </p></li>
<li><p><strong>corresponding term in upper_limits.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Setting the position limits does not affect the
<code class="docutils literal notranslate"><span class="pre">default_positions()</span></code>, regardless of whether the current
<code class="docutils literal notranslate"><span class="pre">default_positions()</span></code> satisfy the new position limits.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.set_velocity_limits(self:</span> <span class="pre">pydrake.multibody.tree.Joint,</span> <span class="pre">lower_limits:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">upper_limits:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the velocity limits to <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> and <code class="docutils literal notranslate"><span class="pre">upper_limits</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the dimension</strong><strong> of </strong><strong>lower_limits or</strong> – </p></li>
<li><p><strong>upper_limits` does not match num_velocities</strong><strong>(</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if any</strong><strong> of </strong><strong>lower_limits is larger than the</strong> – </p></li>
<li><p><strong>corresponding term in upper_limits.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.SetDampingVector(self:</span> <span class="pre">pydrake.multibody.tree.Joint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">damping:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the value of the viscous damping coefficients for this joint,
stored as parameters in <code class="docutils literal notranslate"><span class="pre">context</span></code>. Refer to default_damping_vector()
for details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> joint belongs.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>The vector of damping values.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if damping.size</strong><strong>(</strong><strong>) </strong><strong>!= num_velocities</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if any</strong><strong> of </strong><strong>the damping coefficients is negative.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Some multi-dof joints may have specific semantics for their
damping vector that are not enforced here. For instance,
QuaternionFloatingJoint assumes identical damping values for all 3
angular velocity components and identical damping values for all 3
translational velocity components. It will thus use
<code class="docutils literal notranslate"><span class="pre">angular_damping</span> <span class="pre">=</span> <span class="pre">damping[0]</span></code> and <code class="docutils literal notranslate"><span class="pre">translational_damping</span> <span class="pre">=</span>
<span class="pre">damping[3]</span></code>. Refer to the particular subclass for more semantic
information.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.SetDefaultPose(self:</span> <span class="pre">pydrake.multibody.tree.Joint,</span> <span class="pre">X_FM:</span> <span class="pre">pydrake.math.RigidTransform)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets this joint’s default generalized positions q₀ such that the pose
of the child frame M in the parent frame F best matches the given
pose. The pose is given by a RigidTransform <code class="docutils literal notranslate"><span class="pre">X_FM</span></code>, but a joint will
represent pose differently.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently this is implemented only for floating (6 dof) joints
which can represent any pose.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called for any joint type that does not implement</strong> – </p></li>
<li><p><strong>this function.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>default_positions() to see the resulting q₀ after this call.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SetDefaultPosePair() for an alternative using a quaternion</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.SetDefaultPosePair(self:</span> <span class="pre">pydrake.multibody.tree.Joint,</span> <span class="pre">q_FM:</span> <span class="pre">pydrake.common.eigen_geometry.Quaternion,</span> <span class="pre">p_FM:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>(Advanced) This is the same as SetDefaultPose() except it takes the
pose as a (quaternion, translation vector) pair. A
QuaternionFloatingJoint will store this pose bit-identically; an
RpyFloatingJoint will store it to within floating point precision; any
other joint will approximate it consistent with that joint’s mobility.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently this is implemented only for floating (6 dof) joints
which can represent any pose.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called for any joint type that does not implement</strong> – </p></li>
<li><p><strong>this function.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SetDefaultPose()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.type_name(self:</span> <span class="pre">pydrake.multibody.tree.Joint)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a string identifying the type of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint, such as
“revolute” or “prismatic”.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.Unlock(self:</span> <span class="pre">pydrake.multibody.tree.Joint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Unlock the joint.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.velocity_lower_limits(self:</span> <span class="pre">pydrake.multibody.tree.Joint)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the velocity lower limits.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.velocity_start(self:</span> <span class="pre">pydrake.multibody.tree.Joint)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the index to the first generalized velocity for this joint
within the vector v of generalized velocities for the full multibody
system.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.velocity_suffix(self:</span> <span class="pre">pydrake.multibody.tree.Joint,</span> <span class="pre">arg0:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a string suffix (e.g. to be appended to the name()) to
identify the <cite>k`th velocity in this joint. ``velocity_index_in_joint`</cite>
must be in [0, num_velocities()).</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>the MultibodyPlant must be finalized.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint.velocity_upper_limits(self:</span> <span class="pre">pydrake.multibody.tree.Joint)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the velocity upper limits.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">Joint_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Joint_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Joint_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd]</span></span></dt>
<dd><p>A Joint models the kinematical relationship which characterizes the
possible relative motion between two bodies. The two bodies connected
by this Joint object are referred to as <em>parent</em> and <em>child</em> bodies.
The parent/child ordering defines the sign conventions for the
generalized coordinates and the coordinate ordering for multi-DOF
joints. A Joint is a model of a physical kinematic constraint between
two bodies, a constraint that in the real physical system does not
specify a tree ordering. &#64;image html
drake/multibody/plant/images/BodyParentChildJoint.png width=50%</p>
<p>In Drake we define a frame F rigidly attached to the parent body P
with pose <code class="docutils literal notranslate"><span class="pre">X_PF</span></code> and a frame M rigidly attached to the child body B
with pose <code class="docutils literal notranslate"><span class="pre">X_BM</span></code>. A Joint object specifies a kinematic relation
between frames F and M, which in turn imposes a kinematic relation
between bodies P and B.</p>
<p>Typical joints include the ball joint, to allow unrestricted rotations
about a given point, the revolute joint, that constraints two bodies
to rotate about a given common axis, etc.</p>
<p>Consider the following example to build a simple pendulum system:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">plant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
<span class="c1">// ... Code here to setup quantities below as mass, com, etc. ...</span>
<span class="k">const</span><span class="w"> </span><span class="n">RigidBody</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">pendulum</span><span class="w"> </span><span class="o">=</span>
<span class="w">  </span><span class="n">plant</span><span class="p">.</span><span class="n">AddRigidBody</span><span class="p">(</span><span class="n">SpatialInertia</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mass</span><span class="p">,</span><span class="w"> </span><span class="n">com</span><span class="p">,</span><span class="w"> </span><span class="n">unit_inertia</span><span class="p">));</span>
<span class="c1">// We will connect the pendulum body to the world using a RevoluteJoint.</span>
<span class="c1">// In this simple case the parent body P is the model&#39;s world body and frame</span>
<span class="c1">// F IS the world frame.</span>
<span class="c1">// Additionally, we need to specify the pose of frame M on the pendulum&#39;s</span>
<span class="c1">// body frame B.</span>
<span class="c1">// Say we declared and initialized X_BM...</span>
<span class="k">const</span><span class="w"> </span><span class="n">RevoluteJoint</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">elbow</span><span class="w"> </span><span class="o">=</span>
<span class="w">  </span><span class="n">plant</span><span class="p">.</span><span class="n">AddJoint</span><span class="o">&lt;</span><span class="n">RevoluteJoint</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">    </span><span class="s">&quot;Elbow&quot;</span><span class="p">,</span><span class="w">                </span><span class="cm">/* joint name</span>
<span class="cm">    plant.world_body(),     /* parent body</span>
<span class="cm">    {},                     /* frame F IS the world frame W</span>
<span class="cm">    pendulum,               /* child body, the pendulum</span>
<span class="cm">    X_BM,                   /* pose of frame M in the body frame B</span>
<span class="cm">    Vector3d::UnitZ());     /* revolute axis in this case</span>
</pre></div>
</div>
</details><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Do not ever attempt to instantiate and manipulate Joint objects on
the stack; it will fail. Add joints to your plant using the
provided API MultibodyPlant::AddJoint() as in the example above.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To developers: this is the base class for all concrete Joint
types. Extending this class to add a new Joint type necessarily
requires working with internal implementation classes for which we
cannot guarantee API stability due to the need for ongoing
improvements to these performance-critical classes. So while our
usual stability guarantees apply to the Joint <code class="docutils literal notranslate"><span class="pre">public</span></code> API, the
<code class="docutils literal notranslate"><span class="pre">protected</span></code> API here is subject to change when the underlying
internal objects change. Our release notes will say when we have
made changes that might affect your Joint implementations, but we
won’t necessarily be able to provide a deprecation period.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].acceleration_lower_limits(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the acceleration lower limits.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].acceleration_upper_limits(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the acceleration upper limits.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].AddInDamping(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">forces:</span> <span class="pre">pydrake.multibody.tree.MultibodyForces_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Adds into <code class="docutils literal notranslate"><span class="pre">forces</span></code> the force due to damping within <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> joint belongs.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">forces</span></code>:</dt><dd><p>On return, this method will add the force due to damping within
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint. This method aborts if <code class="docutils literal notranslate"><span class="pre">forces</span></code> is <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> or
if <code class="docutils literal notranslate"><span class="pre">forces</span></code> does not have the right sizes to accommodate a set
of forces for the model to which this joint belongs.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].AddInOneForce(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">joint_dof:</span> <span class="pre">int,</span> <span class="pre">joint_tau:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">forces:</span> <span class="pre">pydrake.multibody.tree.MultibodyForces_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Adds into <code class="docutils literal notranslate"><span class="pre">forces</span></code> a force along the one of the joint’s degrees of
freedom indicated by index <code class="docutils literal notranslate"><span class="pre">joint_dof</span></code>. The meaning for this degree
of freedom and even its dimensional units depend on the specific joint
sub-class. For a RevoluteJoint for instance, <code class="docutils literal notranslate"><span class="pre">joint_dof</span></code> can only be
0 since revolute joints’s motion subspace only has one degree of
freedom, while the units of <code class="docutils literal notranslate"><span class="pre">joint_tau</span></code> are those of torque (N⋅m in
the MKS system of units). For multi-dof joints please refer to the
documentation provided by specific joint sub-classes regarding the
meaning of <code class="docutils literal notranslate"><span class="pre">joint_dof</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> joint belongs.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">joint_dof</span></code>:</dt><dd><p>Index specifying one of the degrees of freedom for this joint. The
index must be in the range <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">joint_dof</span> <span class="pre">&lt;</span> <span class="pre">num_velocities()</span></code>
or otherwise this method will abort.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">joint_tau</span></code>:</dt><dd><p>Generalized force corresponding to the degree of freedom indicated
by <code class="docutils literal notranslate"><span class="pre">joint_dof</span></code> to be added into <code class="docutils literal notranslate"><span class="pre">forces</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">forces</span></code>:</dt><dd><p>On return, this method will add force <code class="docutils literal notranslate"><span class="pre">joint_tau</span></code> for the degree
of freedom <code class="docutils literal notranslate"><span class="pre">joint_dof</span></code> into the output <code class="docutils literal notranslate"><span class="pre">forces</span></code>. This method
aborts if <code class="docutils literal notranslate"><span class="pre">forces</span></code> is <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> or if <code class="docutils literal notranslate"><span class="pre">forces</span></code> doest not
have the right sizes to accommodate a set of forces for the model
to which this joint belongs.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].can_rotate(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true if this joint’s mobility allows relative rotation of the
two frames associated with this joint.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>the MultibodyPlant must be finalized.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>can_translate()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].can_translate(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true if this joint’s mobility allows relative translation of
the two frames associated with this joint.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>the MultibodyPlant must be finalized.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>can_rotate()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].child_body(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RigidBody_[AutoDiffXd]</span></span></dt>
<dd><p>Returns a const reference to the child body B.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].default_damping_vector(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns all default damping coefficients for joints that model viscous
damping, of size num_velocities(). Joints that do not model damping
return a zero vector of size num_velocities(). If vj is the vector of
generalized velocities for this joint, of size num_velocities(),
viscous damping models a generalized force at the joint of the form
tau = -diag(dj)⋅vj, with dj the vector returned by this function. The
units of the coefficients will depend on the specific joint type. For
instance, for a revolute joint where vj is an angular velocity with
units of rad/s and tau having units of N⋅m, the coefficient of viscous
damping has units of N⋅m⋅s. Refer to each joint’s documentation for
further details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].default_positions(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the default generalized position coordinates q₀. These will be
the values set with set_default_positions() if any; otherwise, they
will be the “zero configuration” for this joint type (as defined by
the particular joint type).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The default generalized velocities v₀ are zero for every joint.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].frame_on_child(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd]</span></span></dt>
<dd><p>Returns a const reference to the frame M attached on the child body B.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].frame_on_parent(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd]</span></span></dt>
<dd><p>Returns a const reference to the frame F attached on the parent body
P.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].GetDampingVector(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the Context dependent damping coefficients stored as
parameters in <code class="docutils literal notranslate"><span class="pre">context</span></code>. Refer to default_damping_vector() for
details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> joint belongs.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].GetDefaultPose(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RigidTransform</span></span></dt>
<dd><p>Returns this joint’s default pose as a RigidTransform X_FM.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently this is implemented only for floating (6 dof) joints
which can represent any pose.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called for any joint type that does not implement</strong> – </p></li>
<li><p><strong>this function.</strong> – </p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">X_FM</span></code>:</dt><dd><p>The default pose as a rigid transform.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>default_positions() to see the generalized positions q₀ that this
joint used to generate the returned transform.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetDefaultPosePair() for an alternative using a quaternion</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].GetDefaultPosePair(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">tuple[pydrake.common.eigen_geometry.Quaternion,</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]]</span></span></dt>
<dd><p>(Advanced) This is the same as GetDefaultPose() except it returns this
joint’s default pose as a (quaternion, translation vector) pair.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently this is implemented only for floating (6 dof) joints
which can represent any pose.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For a QuaternionFloatingJoint the return will be bit-identical to
the pose provided to SetDefaultPosePair(). For any other floating
(6 dof) joint the pose will be numerically equivalent (i.e. within
roundoff) but not identical. For other joint types it will be some
approximation.</p>
</div>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">q_FM</span></code>:</dt><dd><p>,p_FM The default pose as a (quaternion, translation) pair.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called for any joint type that does not implement</strong> – </p></li>
<li><p><strong>this function.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetDefaultPose()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].GetOnePosition(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd</span></span></dt>
<dd><p>Returns the position coordinate for joints with a single degree of
freedom.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the joint does not have a single degree of</strong> – </p></li>
<li><p><strong>freedom.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].GetOneVelocity(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd</span></span></dt>
<dd><p>Returns the velocity coordinate for joints with a single degree of
freedom.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the joint does not have a single degree of</strong> – </p></li>
<li><p><strong>freedom.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].GetParentPlant(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">drake::multibody::MultibodyPlant&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double,</span> <span class="pre">-1,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">-1,</span> <span class="pre">1&gt;</span> <span class="pre">&gt;</span> <span class="pre">&gt;</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].index(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>index(self: pydrake.multibody.tree.Joint_[AutoDiffXd]) -&gt; pydrake.multibody.tree.JointIndex</p></li>
<li><p>index(self: pydrake.multibody.tree.Joint_[AutoDiffXd]) -&gt; pydrake.multibody.tree.JointIndex</p></li>
</ol>
<p>Returns this element’s unique index.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].is_ephemeral(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].is_locked(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>true if the joint is locked, false otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].Lock(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Lock the joint. Its generalized velocities will be 0 until it is
unlocked.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].model_instance(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].name(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns the name of this joint.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].num_positions(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of generalized positions describing this joint.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].num_velocities(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of generalized velocities describing this joint.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].parent_body(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RigidBody_[AutoDiffXd]</span></span></dt>
<dd><p>Returns a const reference to the parent body P.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].position_lower_limits(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the position lower limits.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].position_start(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the index to the first generalized position for this joint
within the vector q of generalized positions for the full multibody
system.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].position_suffix(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd],</span> <span class="pre">arg0:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a string suffix (e.g. to be appended to the name()) to
identify the <cite>k`th position in this joint. ``position_index_in_joint`</cite>
must be in [0, num_positions()).</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>the MultibodyPlant must be finalized.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].position_upper_limits(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the position upper limits.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].set_acceleration_limits(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd],</span> <span class="pre">lower_limits:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">upper_limits:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the acceleration limits to <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> and <code class="docutils literal notranslate"><span class="pre">upper_limits</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the dimension</strong><strong> of </strong><strong>lower_limits or</strong> – </p></li>
<li><p><strong>upper_limits` does not match num_velocities</strong><strong>(</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if any</strong><strong> of </strong><strong>lower_limits is larger than the</strong> – </p></li>
<li><p><strong>corresponding term in upper_limits.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].set_default_damping_vector(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd],</span> <span class="pre">damping:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default value of the viscous damping coefficients for this
joint. Refer to default_damping_vector() for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if damping.size</strong><strong>(</strong><strong>) </strong><strong>!= num_velocities</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if any</strong><strong> of </strong><strong>the damping coefficients is negative.</strong> – </p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>the MultibodyPlant must not be finalized.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].set_default_positions(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd],</span> <span class="pre">default_positions:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default generalized position coordinates q₀ to
<code class="docutils literal notranslate"><span class="pre">default_positions</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The values in <code class="docutils literal notranslate"><span class="pre">default_positions</span></code> are NOT constrained to be
within position_lower_limits() and position_upper_limits().</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The default generalized velocities v₀ are zero for every joint.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the dimension</strong><strong> of </strong><strong>default_positions does not</strong> – </p></li>
<li><p><strong>match num_positions</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].set_position_limits(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd],</span> <span class="pre">lower_limits:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">upper_limits:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the position limits to <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> and <code class="docutils literal notranslate"><span class="pre">upper_limits</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the dimension</strong><strong> of </strong><strong>lower_limits or</strong> – </p></li>
<li><p><strong>upper_limits` does not match num_positions</strong><strong>(</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if any</strong><strong> of </strong><strong>lower_limits is larger than the</strong> – </p></li>
<li><p><strong>corresponding term in upper_limits.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Setting the position limits does not affect the
<code class="docutils literal notranslate"><span class="pre">default_positions()</span></code>, regardless of whether the current
<code class="docutils literal notranslate"><span class="pre">default_positions()</span></code> satisfy the new position limits.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].set_velocity_limits(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd],</span> <span class="pre">lower_limits:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">upper_limits:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the velocity limits to <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> and <code class="docutils literal notranslate"><span class="pre">upper_limits</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the dimension</strong><strong> of </strong><strong>lower_limits or</strong> – </p></li>
<li><p><strong>upper_limits` does not match num_velocities</strong><strong>(</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if any</strong><strong> of </strong><strong>lower_limits is larger than the</strong> – </p></li>
<li><p><strong>corresponding term in upper_limits.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].SetDampingVector(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">damping:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the value of the viscous damping coefficients for this joint,
stored as parameters in <code class="docutils literal notranslate"><span class="pre">context</span></code>. Refer to default_damping_vector()
for details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> joint belongs.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>The vector of damping values.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if damping.size</strong><strong>(</strong><strong>) </strong><strong>!= num_velocities</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if any</strong><strong> of </strong><strong>the damping coefficients is negative.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Some multi-dof joints may have specific semantics for their
damping vector that are not enforced here. For instance,
QuaternionFloatingJoint assumes identical damping values for all 3
angular velocity components and identical damping values for all 3
translational velocity components. It will thus use
<code class="docutils literal notranslate"><span class="pre">angular_damping</span> <span class="pre">=</span> <span class="pre">damping[0]</span></code> and <code class="docutils literal notranslate"><span class="pre">translational_damping</span> <span class="pre">=</span>
<span class="pre">damping[3]</span></code>. Refer to the particular subclass for more semantic
information.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].SetDefaultPose(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd],</span> <span class="pre">X_FM:</span> <span class="pre">pydrake.math.RigidTransform)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets this joint’s default generalized positions q₀ such that the pose
of the child frame M in the parent frame F best matches the given
pose. The pose is given by a RigidTransform <code class="docutils literal notranslate"><span class="pre">X_FM</span></code>, but a joint will
represent pose differently.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently this is implemented only for floating (6 dof) joints
which can represent any pose.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called for any joint type that does not implement</strong> – </p></li>
<li><p><strong>this function.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>default_positions() to see the resulting q₀ after this call.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SetDefaultPosePair() for an alternative using a quaternion</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].SetDefaultPosePair(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd],</span> <span class="pre">q_FM:</span> <span class="pre">pydrake.common.eigen_geometry.Quaternion,</span> <span class="pre">p_FM:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>(Advanced) This is the same as SetDefaultPose() except it takes the
pose as a (quaternion, translation vector) pair. A
QuaternionFloatingJoint will store this pose bit-identically; an
RpyFloatingJoint will store it to within floating point precision; any
other joint will approximate it consistent with that joint’s mobility.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently this is implemented only for floating (6 dof) joints
which can represent any pose.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called for any joint type that does not implement</strong> – </p></li>
<li><p><strong>this function.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SetDefaultPose()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].type_name(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a string identifying the type of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint, such as
“revolute” or “prismatic”.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].Unlock(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Unlock the joint.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].velocity_lower_limits(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the velocity lower limits.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].velocity_start(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the index to the first generalized velocity for this joint
within the vector v of generalized velocities for the full multibody
system.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].velocity_suffix(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd],</span> <span class="pre">arg0:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a string suffix (e.g. to be appended to the name()) to
identify the <cite>k`th velocity in this joint. ``velocity_index_in_joint`</cite>
must be in [0, num_velocities()).</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>the MultibodyPlant must be finalized.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[AutoDiffXd].velocity_upper_limits(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the velocity upper limits.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression]</span></span></dt>
<dd><p>A Joint models the kinematical relationship which characterizes the
possible relative motion between two bodies. The two bodies connected
by this Joint object are referred to as <em>parent</em> and <em>child</em> bodies.
The parent/child ordering defines the sign conventions for the
generalized coordinates and the coordinate ordering for multi-DOF
joints. A Joint is a model of a physical kinematic constraint between
two bodies, a constraint that in the real physical system does not
specify a tree ordering. &#64;image html
drake/multibody/plant/images/BodyParentChildJoint.png width=50%</p>
<p>In Drake we define a frame F rigidly attached to the parent body P
with pose <code class="docutils literal notranslate"><span class="pre">X_PF</span></code> and a frame M rigidly attached to the child body B
with pose <code class="docutils literal notranslate"><span class="pre">X_BM</span></code>. A Joint object specifies a kinematic relation
between frames F and M, which in turn imposes a kinematic relation
between bodies P and B.</p>
<p>Typical joints include the ball joint, to allow unrestricted rotations
about a given point, the revolute joint, that constraints two bodies
to rotate about a given common axis, etc.</p>
<p>Consider the following example to build a simple pendulum system:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">plant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
<span class="c1">// ... Code here to setup quantities below as mass, com, etc. ...</span>
<span class="k">const</span><span class="w"> </span><span class="n">RigidBody</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">pendulum</span><span class="w"> </span><span class="o">=</span>
<span class="w">  </span><span class="n">plant</span><span class="p">.</span><span class="n">AddRigidBody</span><span class="p">(</span><span class="n">SpatialInertia</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mass</span><span class="p">,</span><span class="w"> </span><span class="n">com</span><span class="p">,</span><span class="w"> </span><span class="n">unit_inertia</span><span class="p">));</span>
<span class="c1">// We will connect the pendulum body to the world using a RevoluteJoint.</span>
<span class="c1">// In this simple case the parent body P is the model&#39;s world body and frame</span>
<span class="c1">// F IS the world frame.</span>
<span class="c1">// Additionally, we need to specify the pose of frame M on the pendulum&#39;s</span>
<span class="c1">// body frame B.</span>
<span class="c1">// Say we declared and initialized X_BM...</span>
<span class="k">const</span><span class="w"> </span><span class="n">RevoluteJoint</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">elbow</span><span class="w"> </span><span class="o">=</span>
<span class="w">  </span><span class="n">plant</span><span class="p">.</span><span class="n">AddJoint</span><span class="o">&lt;</span><span class="n">RevoluteJoint</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">    </span><span class="s">&quot;Elbow&quot;</span><span class="p">,</span><span class="w">                </span><span class="cm">/* joint name</span>
<span class="cm">    plant.world_body(),     /* parent body</span>
<span class="cm">    {},                     /* frame F IS the world frame W</span>
<span class="cm">    pendulum,               /* child body, the pendulum</span>
<span class="cm">    X_BM,                   /* pose of frame M in the body frame B</span>
<span class="cm">    Vector3d::UnitZ());     /* revolute axis in this case</span>
</pre></div>
</div>
</details><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Do not ever attempt to instantiate and manipulate Joint objects on
the stack; it will fail. Add joints to your plant using the
provided API MultibodyPlant::AddJoint() as in the example above.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To developers: this is the base class for all concrete Joint
types. Extending this class to add a new Joint type necessarily
requires working with internal implementation classes for which we
cannot guarantee API stability due to the need for ongoing
improvements to these performance-critical classes. So while our
usual stability guarantees apply to the Joint <code class="docutils literal notranslate"><span class="pre">public</span></code> API, the
<code class="docutils literal notranslate"><span class="pre">protected</span></code> API here is subject to change when the underlying
internal objects change. Our release notes will say when we have
made changes that might affect your Joint implementations, but we
won’t necessarily be able to provide a deprecation period.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].acceleration_lower_limits(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the acceleration lower limits.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].acceleration_upper_limits(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the acceleration upper limits.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].AddInDamping(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">forces:</span> <span class="pre">pydrake.multibody.tree.MultibodyForces_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Adds into <code class="docutils literal notranslate"><span class="pre">forces</span></code> the force due to damping within <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> joint belongs.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">forces</span></code>:</dt><dd><p>On return, this method will add the force due to damping within
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint. This method aborts if <code class="docutils literal notranslate"><span class="pre">forces</span></code> is <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> or
if <code class="docutils literal notranslate"><span class="pre">forces</span></code> does not have the right sizes to accommodate a set
of forces for the model to which this joint belongs.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].AddInOneForce(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">joint_dof:</span> <span class="pre">int,</span> <span class="pre">joint_tau:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">forces:</span> <span class="pre">pydrake.multibody.tree.MultibodyForces_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Adds into <code class="docutils literal notranslate"><span class="pre">forces</span></code> a force along the one of the joint’s degrees of
freedom indicated by index <code class="docutils literal notranslate"><span class="pre">joint_dof</span></code>. The meaning for this degree
of freedom and even its dimensional units depend on the specific joint
sub-class. For a RevoluteJoint for instance, <code class="docutils literal notranslate"><span class="pre">joint_dof</span></code> can only be
0 since revolute joints’s motion subspace only has one degree of
freedom, while the units of <code class="docutils literal notranslate"><span class="pre">joint_tau</span></code> are those of torque (N⋅m in
the MKS system of units). For multi-dof joints please refer to the
documentation provided by specific joint sub-classes regarding the
meaning of <code class="docutils literal notranslate"><span class="pre">joint_dof</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> joint belongs.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">joint_dof</span></code>:</dt><dd><p>Index specifying one of the degrees of freedom for this joint. The
index must be in the range <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">joint_dof</span> <span class="pre">&lt;</span> <span class="pre">num_velocities()</span></code>
or otherwise this method will abort.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">joint_tau</span></code>:</dt><dd><p>Generalized force corresponding to the degree of freedom indicated
by <code class="docutils literal notranslate"><span class="pre">joint_dof</span></code> to be added into <code class="docutils literal notranslate"><span class="pre">forces</span></code>.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">forces</span></code>:</dt><dd><p>On return, this method will add force <code class="docutils literal notranslate"><span class="pre">joint_tau</span></code> for the degree
of freedom <code class="docutils literal notranslate"><span class="pre">joint_dof</span></code> into the output <code class="docutils literal notranslate"><span class="pre">forces</span></code>. This method
aborts if <code class="docutils literal notranslate"><span class="pre">forces</span></code> is <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> or if <code class="docutils literal notranslate"><span class="pre">forces</span></code> doest not
have the right sizes to accommodate a set of forces for the model
to which this joint belongs.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].can_rotate(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true if this joint’s mobility allows relative rotation of the
two frames associated with this joint.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>the MultibodyPlant must be finalized.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>can_translate()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].can_translate(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns true if this joint’s mobility allows relative translation of
the two frames associated with this joint.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>the MultibodyPlant must be finalized.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>can_rotate()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].child_body(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RigidBody_[Expression]</span></span></dt>
<dd><p>Returns a const reference to the child body B.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].default_damping_vector(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns all default damping coefficients for joints that model viscous
damping, of size num_velocities(). Joints that do not model damping
return a zero vector of size num_velocities(). If vj is the vector of
generalized velocities for this joint, of size num_velocities(),
viscous damping models a generalized force at the joint of the form
tau = -diag(dj)⋅vj, with dj the vector returned by this function. The
units of the coefficients will depend on the specific joint type. For
instance, for a revolute joint where vj is an angular velocity with
units of rad/s and tau having units of N⋅m, the coefficient of viscous
damping has units of N⋅m⋅s. Refer to each joint’s documentation for
further details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].default_positions(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the default generalized position coordinates q₀. These will be
the values set with set_default_positions() if any; otherwise, they
will be the “zero configuration” for this joint type (as defined by
the particular joint type).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The default generalized velocities v₀ are zero for every joint.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].frame_on_child(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression]</span></span></dt>
<dd><p>Returns a const reference to the frame M attached on the child body B.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].frame_on_parent(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression]</span></span></dt>
<dd><p>Returns a const reference to the frame F attached on the parent body
P.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].GetDampingVector(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the Context dependent damping coefficients stored as
parameters in <code class="docutils literal notranslate"><span class="pre">context</span></code>. Refer to default_damping_vector() for
details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> joint belongs.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].GetDefaultPose(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RigidTransform</span></span></dt>
<dd><p>Returns this joint’s default pose as a RigidTransform X_FM.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently this is implemented only for floating (6 dof) joints
which can represent any pose.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called for any joint type that does not implement</strong> – </p></li>
<li><p><strong>this function.</strong> – </p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">X_FM</span></code>:</dt><dd><p>The default pose as a rigid transform.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>default_positions() to see the generalized positions q₀ that this
joint used to generate the returned transform.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetDefaultPosePair() for an alternative using a quaternion</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].GetDefaultPosePair(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">tuple[pydrake.common.eigen_geometry.Quaternion,</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]]</span></span></dt>
<dd><p>(Advanced) This is the same as GetDefaultPose() except it returns this
joint’s default pose as a (quaternion, translation vector) pair.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently this is implemented only for floating (6 dof) joints
which can represent any pose.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For a QuaternionFloatingJoint the return will be bit-identical to
the pose provided to SetDefaultPosePair(). For any other floating
(6 dof) joint the pose will be numerically equivalent (i.e. within
roundoff) but not identical. For other joint types it will be some
approximation.</p>
</div>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">q_FM</span></code>:</dt><dd><p>,p_FM The default pose as a (quaternion, translation) pair.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called for any joint type that does not implement</strong> – </p></li>
<li><p><strong>this function.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>GetDefaultPose()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].GetOnePosition(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd><p>Returns the position coordinate for joints with a single degree of
freedom.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the joint does not have a single degree of</strong> – </p></li>
<li><p><strong>freedom.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].GetOneVelocity(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd><p>Returns the velocity coordinate for joints with a single degree of
freedom.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the joint does not have a single degree of</strong> – </p></li>
<li><p><strong>freedom.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].GetParentPlant(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">drake::multibody::MultibodyPlant&lt;drake::symbolic::Expression&gt;</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].index(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>index(self: pydrake.multibody.tree.Joint_[Expression]) -&gt; pydrake.multibody.tree.JointIndex</p></li>
<li><p>index(self: pydrake.multibody.tree.Joint_[Expression]) -&gt; pydrake.multibody.tree.JointIndex</p></li>
</ol>
<p>Returns this element’s unique index.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].is_ephemeral(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].is_locked(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>true if the joint is locked, false otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].Lock(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Lock the joint. Its generalized velocities will be 0 until it is
unlocked.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].model_instance(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].name(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns the name of this joint.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].num_positions(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of generalized positions describing this joint.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].num_velocities(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of generalized velocities describing this joint.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].parent_body(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RigidBody_[Expression]</span></span></dt>
<dd><p>Returns a const reference to the parent body P.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].position_lower_limits(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the position lower limits.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].position_start(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the index to the first generalized position for this joint
within the vector q of generalized positions for the full multibody
system.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].position_suffix(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression],</span> <span class="pre">arg0:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a string suffix (e.g. to be appended to the name()) to
identify the <cite>k`th position in this joint. ``position_index_in_joint`</cite>
must be in [0, num_positions()).</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>the MultibodyPlant must be finalized.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].position_upper_limits(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the position upper limits.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].set_acceleration_limits(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression],</span> <span class="pre">lower_limits:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">upper_limits:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the acceleration limits to <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> and <code class="docutils literal notranslate"><span class="pre">upper_limits</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the dimension</strong><strong> of </strong><strong>lower_limits or</strong> – </p></li>
<li><p><strong>upper_limits` does not match num_velocities</strong><strong>(</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if any</strong><strong> of </strong><strong>lower_limits is larger than the</strong> – </p></li>
<li><p><strong>corresponding term in upper_limits.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].set_default_damping_vector(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression],</span> <span class="pre">damping:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default value of the viscous damping coefficients for this
joint. Refer to default_damping_vector() for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if damping.size</strong><strong>(</strong><strong>) </strong><strong>!= num_velocities</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if any</strong><strong> of </strong><strong>the damping coefficients is negative.</strong> – </p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>the MultibodyPlant must not be finalized.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].set_default_positions(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression],</span> <span class="pre">default_positions:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default generalized position coordinates q₀ to
<code class="docutils literal notranslate"><span class="pre">default_positions</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The values in <code class="docutils literal notranslate"><span class="pre">default_positions</span></code> are NOT constrained to be
within position_lower_limits() and position_upper_limits().</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The default generalized velocities v₀ are zero for every joint.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the dimension</strong><strong> of </strong><strong>default_positions does not</strong> – </p></li>
<li><p><strong>match num_positions</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].set_position_limits(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression],</span> <span class="pre">lower_limits:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">upper_limits:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the position limits to <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> and <code class="docutils literal notranslate"><span class="pre">upper_limits</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the dimension</strong><strong> of </strong><strong>lower_limits or</strong> – </p></li>
<li><p><strong>upper_limits` does not match num_positions</strong><strong>(</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if any</strong><strong> of </strong><strong>lower_limits is larger than the</strong> – </p></li>
<li><p><strong>corresponding term in upper_limits.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Setting the position limits does not affect the
<code class="docutils literal notranslate"><span class="pre">default_positions()</span></code>, regardless of whether the current
<code class="docutils literal notranslate"><span class="pre">default_positions()</span></code> satisfy the new position limits.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].set_velocity_limits(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression],</span> <span class="pre">lower_limits:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">upper_limits:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the velocity limits to <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> and <code class="docutils literal notranslate"><span class="pre">upper_limits</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the dimension</strong><strong> of </strong><strong>lower_limits or</strong> – </p></li>
<li><p><strong>upper_limits` does not match num_velocities</strong><strong>(</strong><strong>)</strong> – </p></li>
<li><p><strong>RuntimeError if any</strong><strong> of </strong><strong>lower_limits is larger than the</strong> – </p></li>
<li><p><strong>corresponding term in upper_limits.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].SetDampingVector(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">damping:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the value of the viscous damping coefficients for this joint,
stored as parameters in <code class="docutils literal notranslate"><span class="pre">context</span></code>. Refer to default_damping_vector()
for details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> joint belongs.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>The vector of damping values.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if damping.size</strong><strong>(</strong><strong>) </strong><strong>!= num_velocities</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if any</strong><strong> of </strong><strong>the damping coefficients is negative.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Some multi-dof joints may have specific semantics for their
damping vector that are not enforced here. For instance,
QuaternionFloatingJoint assumes identical damping values for all 3
angular velocity components and identical damping values for all 3
translational velocity components. It will thus use
<code class="docutils literal notranslate"><span class="pre">angular_damping</span> <span class="pre">=</span> <span class="pre">damping[0]</span></code> and <code class="docutils literal notranslate"><span class="pre">translational_damping</span> <span class="pre">=</span>
<span class="pre">damping[3]</span></code>. Refer to the particular subclass for more semantic
information.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].SetDefaultPose(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression],</span> <span class="pre">X_FM:</span> <span class="pre">pydrake.math.RigidTransform)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets this joint’s default generalized positions q₀ such that the pose
of the child frame M in the parent frame F best matches the given
pose. The pose is given by a RigidTransform <code class="docutils literal notranslate"><span class="pre">X_FM</span></code>, but a joint will
represent pose differently.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently this is implemented only for floating (6 dof) joints
which can represent any pose.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called for any joint type that does not implement</strong> – </p></li>
<li><p><strong>this function.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>default_positions() to see the resulting q₀ after this call.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SetDefaultPosePair() for an alternative using a quaternion</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].SetDefaultPosePair(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression],</span> <span class="pre">q_FM:</span> <span class="pre">pydrake.common.eigen_geometry.Quaternion,</span> <span class="pre">p_FM:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>(Advanced) This is the same as SetDefaultPose() except it takes the
pose as a (quaternion, translation vector) pair. A
QuaternionFloatingJoint will store this pose bit-identically; an
RpyFloatingJoint will store it to within floating point precision; any
other joint will approximate it consistent with that joint’s mobility.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently this is implemented only for floating (6 dof) joints
which can represent any pose.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if called for any joint type that does not implement</strong> – </p></li>
<li><p><strong>this function.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SetDefaultPose()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].type_name(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a string identifying the type of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint, such as
“revolute” or “prismatic”.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].Unlock(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Unlock the joint.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].velocity_lower_limits(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the velocity lower limits.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].velocity_start(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the index to the first generalized velocity for this joint
within the vector v of generalized velocities for the full multibody
system.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].velocity_suffix(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression],</span> <span class="pre">arg0:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a string suffix (e.g. to be appended to the name()) to
identify the <cite>k`th velocity in this joint. ``velocity_index_in_joint`</cite>
must be in [0, num_velocities()).</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>the MultibodyPlant must be finalized.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">Joint_[Expression].velocity_upper_limits(self:</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the velocity upper limits.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator</span></span></dt>
<dd><p>The JointActuator class is mostly a simple bookkeeping structure to
represent an actuator acting on a given Joint. It helps to flag
whether a given Joint is actuated or not so that MultibodyTree clients
can apply forces on actuated joints through their actuators, see
AddInOneForce().</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">JointActuator_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator.calc_reflected_inertia(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Calculates the reflected inertia value for this actuator in
<code class="docutils literal notranslate"><span class="pre">context</span></code>. See reflected_inertia. Note that this ONLY depends on the
Parameters in the context; it does not depend on time, input, state,
etc.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator.default_gear_ratio(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Gets the default value for this actuator’s gear ratio. See
reflected_inertia.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator.default_reflected_inertia(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the default value for this actuator’s reflected inertia. It is
calculated as ρ²⋅Iᵣ, where ρ is the default gear ratio and Iᵣ is the
default rotor inertia for this actuator. See reflected_inertia.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator.default_rotor_inertia(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Gets the default value for this actuator’s rotor inertia. See
reflected_inertia.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator.effort_limit(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the actuator effort limit.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator.gear_ratio(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the associated gear ratio value for this actuator, stored in
<code class="docutils literal notranslate"><span class="pre">context</span></code>. See reflected_inertia. Note that this ONLY depends on the
Parameters in the context; it does not depend on time, input, state,
etc.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator.get_actuation_vector(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator,</span> <span class="pre">u:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Gets the actuation values for <code class="docutils literal notranslate"><span class="pre">this</span></code> actuator from the actuation
vector u for the entire plant model.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a reference to a nv-dimensional vector, where nv is the number of
velocity variables of joint().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator.get_controller_gains(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.PdControllerGains</span></span></dt>
<dd><p>Returns a reference to the controller gains for this actuator.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>has_controller() is <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator.GetParentPlant(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator)</span> <span class="pre">-&gt;</span> <span class="pre">drake::multibody::MultibodyPlant&lt;double&gt;</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator.has_controller(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if any non-zero controller gains have been specified
with a call to set_controller_gains().</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A controller for a given model instance can be <em>disarmed</em> if the
desired state input port for its model instance is not connected.
When a PD controller is disarmed, it has no effect on the
MultibodyPlant’s dynamics, as if there was no PD controller
(still, this method returns <code class="docutils literal notranslate"><span class="pre">True</span></code> whenever non-zero gains were
set with set_controller_gains().) See pd_controllers_and_ports for
further details.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator.index(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.JointActuatorIndex</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator.input_start(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the index to the first element for this joint actuator /
within the vector of actuation inputs for the full multibody / system.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the MultibodyTree model is not finalized.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator.is_ephemeral(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator.joint(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.Joint</span></span></dt>
<dd><p>Returns a reference to the joint actuated by this JointActuator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator.model_instance(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator.name(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns the name of the actuator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator.num_inputs(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of inputs associated with this actuator.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the MultibodyTree model is not finalized.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator.rotor_inertia(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the associated rotor inertia value for this actuator, stored
in <code class="docutils literal notranslate"><span class="pre">context</span></code>. See reflected_inertia. Note that this ONLY depends on
the Parameters in the context; it does not depend on time, input,
state, etc.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator.set_actuation_vector(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator,</span> <span class="pre">u_actuator:</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]],</span> <span class="pre">u:</span> <span class="pre">Optional[numpy.ndarray[numpy.float64[m,</span> <span class="pre">1],</span> <span class="pre">flags.writeable]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Given the actuation values <code class="docutils literal notranslate"><span class="pre">u_actuator</span></code> for <code class="docutils literal notranslate"><span class="pre">this</span></code> actuator,
updates the actuation vector <code class="docutils literal notranslate"><span class="pre">u</span></code> for the entire multibody model to
which this actuator belongs to.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">u_actuator</span></code>:</dt><dd><p>Actuation values for <code class="docutils literal notranslate"><span class="pre">this</span></code> actuator. It must be of size equal
to num_inputs(). For units and sign conventions refer to the
specific Joint sub-class documentation.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">u</span></code>:</dt><dd><p>Actuation values for the entire plant model to which <code class="docutils literal notranslate"><span class="pre">this</span></code>
actuator belongs to. The actuation value in <code class="docutils literal notranslate"><span class="pre">u</span></code> for <code class="docutils literal notranslate"><span class="pre">this</span></code>
actuator must be found at offset input_start(). Only values
corresponding to this actuator are changed.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if u_actuator.size</strong><strong>(</strong><strong>) </strong><strong>!= this-&gt;num_inputs</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if u is nullptr.</strong> – </p></li>
<li><p><strong>RuntimeError if ``u.size</strong><strong>(</strong><strong>) </strong><strong>!=</strong> – </p></li>
<li><p><strong>this-&gt;GetParentPlant</strong><strong>(</strong><strong>)</strong><strong>.num_actuated_dofs</strong><strong>(</strong><strong>)</strong><strong>``.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator.set_controller_gains(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator,</span> <span class="pre">gains:</span> <span class="pre">pydrake.multibody.tree.PdControllerGains)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Set controller gains for this joint actuator. This enables the
modeling of a simple PD controller of the form: ũ = -Kp⋅(q − qd) -
Kd⋅(v − vd) + u_ff u = max(−e, min(e, ũ)) where qd and vd are the
desired configuration and velocity for joint(), Kp and Kd are the
proportional and derivative gains specified in <code class="docutils literal notranslate"><span class="pre">gains</span></code>, u_ff is the
feedforward actuation and <code class="docutils literal notranslate"><span class="pre">e</span></code> corresponds to effort_limit().</p>
<p>The gains must be finite and non-negative. Setting both gains to zero
will remove the controller (has_controller() will return false).</p>
<p>For simulation, feedforward actuation can be provided through
MultibodyPlant::get_actuation_input_port(). Desired configuration and
velocity are specified through
MultibodyPlant::get_desired_state_input_port().</p>
<p>PD control is currently only supported for a discrete time plant.
Attempting to use non-zero gains on a continuous time plant will
result in an exception. See pd_controllers_and_ports for further
details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator.set_default_gear_ratio(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator,</span> <span class="pre">gear_ratio:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default value for this actuator’s gear ratio. See
reflected_inertia.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator.set_default_rotor_inertia(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator,</span> <span class="pre">rotor_inertia:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default value for this actuator’s rotor inertia. See
reflected_inertia.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator.SetGearRatio(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">gear_ratio:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the associated gear ratio value for this actuator in <code class="docutils literal notranslate"><span class="pre">context</span></code>.
See reflected_inertia.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator.SetRotorInertia(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">rotor_inertia:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the associated rotor inertia value for this actuator in
<code class="docutils literal notranslate"><span class="pre">context</span></code>. See reflected_inertia.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">JointActuator_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">JointActuator_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">JointActuator_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[AutoDiffXd]</span></span></dt>
<dd><p>The JointActuator class is mostly a simple bookkeeping structure to
represent an actuator acting on a given Joint. It helps to flag
whether a given Joint is actuated or not so that MultibodyTree clients
can apply forces on actuated joints through their actuators, see
AddInOneForce().</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[AutoDiffXd].calc_reflected_inertia(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd</span></span></dt>
<dd><p>Calculates the reflected inertia value for this actuator in
<code class="docutils literal notranslate"><span class="pre">context</span></code>. See reflected_inertia. Note that this ONLY depends on the
Parameters in the context; it does not depend on time, input, state,
etc.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[AutoDiffXd].default_gear_ratio(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Gets the default value for this actuator’s gear ratio. See
reflected_inertia.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[AutoDiffXd].default_reflected_inertia(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the default value for this actuator’s reflected inertia. It is
calculated as ρ²⋅Iᵣ, where ρ is the default gear ratio and Iᵣ is the
default rotor inertia for this actuator. See reflected_inertia.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[AutoDiffXd].default_rotor_inertia(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Gets the default value for this actuator’s rotor inertia. See
reflected_inertia.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[AutoDiffXd].effort_limit(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the actuator effort limit.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[AutoDiffXd].gear_ratio(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd</span></span></dt>
<dd><p>Returns the associated gear ratio value for this actuator, stored in
<code class="docutils literal notranslate"><span class="pre">context</span></code>. See reflected_inertia. Note that this ONLY depends on the
Parameters in the context; it does not depend on time, input, state,
etc.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[AutoDiffXd].get_actuation_vector(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[AutoDiffXd],</span> <span class="pre">u:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Gets the actuation values for <code class="docutils literal notranslate"><span class="pre">this</span></code> actuator from the actuation
vector u for the entire plant model.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a reference to a nv-dimensional vector, where nv is the number of
velocity variables of joint().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[AutoDiffXd].get_controller_gains(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.PdControllerGains</span></span></dt>
<dd><p>Returns a reference to the controller gains for this actuator.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>has_controller() is <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[AutoDiffXd].GetParentPlant(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">drake::multibody::MultibodyPlant&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double,</span> <span class="pre">-1,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">-1,</span> <span class="pre">1&gt;</span> <span class="pre">&gt;</span> <span class="pre">&gt;</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[AutoDiffXd].has_controller(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if any non-zero controller gains have been specified
with a call to set_controller_gains().</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A controller for a given model instance can be <em>disarmed</em> if the
desired state input port for its model instance is not connected.
When a PD controller is disarmed, it has no effect on the
MultibodyPlant’s dynamics, as if there was no PD controller
(still, this method returns <code class="docutils literal notranslate"><span class="pre">True</span></code> whenever non-zero gains were
set with set_controller_gains().) See pd_controllers_and_ports for
further details.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[AutoDiffXd].index(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.JointActuatorIndex</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[AutoDiffXd].input_start(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the index to the first element for this joint actuator /
within the vector of actuation inputs for the full multibody / system.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the MultibodyTree model is not finalized.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[AutoDiffXd].is_ephemeral(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[AutoDiffXd].joint(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd]</span></span></dt>
<dd><p>Returns a reference to the joint actuated by this JointActuator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[AutoDiffXd].model_instance(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[AutoDiffXd].name(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns the name of the actuator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[AutoDiffXd].num_inputs(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of inputs associated with this actuator.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the MultibodyTree model is not finalized.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[AutoDiffXd].rotor_inertia(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd</span></span></dt>
<dd><p>Returns the associated rotor inertia value for this actuator, stored
in <code class="docutils literal notranslate"><span class="pre">context</span></code>. See reflected_inertia. Note that this ONLY depends on
the Parameters in the context; it does not depend on time, input,
state, etc.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[AutoDiffXd].set_actuation_vector(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[AutoDiffXd],</span> <span class="pre">u_actuator:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]],</span> <span class="pre">u:</span> <span class="pre">Optional[numpy.ndarray[object[m,</span> <span class="pre">1],</span> <span class="pre">flags.writeable]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Given the actuation values <code class="docutils literal notranslate"><span class="pre">u_actuator</span></code> for <code class="docutils literal notranslate"><span class="pre">this</span></code> actuator,
updates the actuation vector <code class="docutils literal notranslate"><span class="pre">u</span></code> for the entire multibody model to
which this actuator belongs to.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">u_actuator</span></code>:</dt><dd><p>Actuation values for <code class="docutils literal notranslate"><span class="pre">this</span></code> actuator. It must be of size equal
to num_inputs(). For units and sign conventions refer to the
specific Joint sub-class documentation.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">u</span></code>:</dt><dd><p>Actuation values for the entire plant model to which <code class="docutils literal notranslate"><span class="pre">this</span></code>
actuator belongs to. The actuation value in <code class="docutils literal notranslate"><span class="pre">u</span></code> for <code class="docutils literal notranslate"><span class="pre">this</span></code>
actuator must be found at offset input_start(). Only values
corresponding to this actuator are changed.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if u_actuator.size</strong><strong>(</strong><strong>) </strong><strong>!= this-&gt;num_inputs</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if u is nullptr.</strong> – </p></li>
<li><p><strong>RuntimeError if ``u.size</strong><strong>(</strong><strong>) </strong><strong>!=</strong> – </p></li>
<li><p><strong>this-&gt;GetParentPlant</strong><strong>(</strong><strong>)</strong><strong>.num_actuated_dofs</strong><strong>(</strong><strong>)</strong><strong>``.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[AutoDiffXd].set_controller_gains(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[AutoDiffXd],</span> <span class="pre">gains:</span> <span class="pre">pydrake.multibody.tree.PdControllerGains)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Set controller gains for this joint actuator. This enables the
modeling of a simple PD controller of the form: ũ = -Kp⋅(q − qd) -
Kd⋅(v − vd) + u_ff u = max(−e, min(e, ũ)) where qd and vd are the
desired configuration and velocity for joint(), Kp and Kd are the
proportional and derivative gains specified in <code class="docutils literal notranslate"><span class="pre">gains</span></code>, u_ff is the
feedforward actuation and <code class="docutils literal notranslate"><span class="pre">e</span></code> corresponds to effort_limit().</p>
<p>The gains must be finite and non-negative. Setting both gains to zero
will remove the controller (has_controller() will return false).</p>
<p>For simulation, feedforward actuation can be provided through
MultibodyPlant::get_actuation_input_port(). Desired configuration and
velocity are specified through
MultibodyPlant::get_desired_state_input_port().</p>
<p>PD control is currently only supported for a discrete time plant.
Attempting to use non-zero gains on a continuous time plant will
result in an exception. See pd_controllers_and_ports for further
details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[AutoDiffXd].set_default_gear_ratio(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[AutoDiffXd],</span> <span class="pre">gear_ratio:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default value for this actuator’s gear ratio. See
reflected_inertia.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[AutoDiffXd].set_default_rotor_inertia(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[AutoDiffXd],</span> <span class="pre">rotor_inertia:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default value for this actuator’s rotor inertia. See
reflected_inertia.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[AutoDiffXd].SetGearRatio(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">gear_ratio:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the associated gear ratio value for this actuator in <code class="docutils literal notranslate"><span class="pre">context</span></code>.
See reflected_inertia.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[AutoDiffXd].SetRotorInertia(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">rotor_inertia:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the associated rotor inertia value for this actuator in
<code class="docutils literal notranslate"><span class="pre">context</span></code>. See reflected_inertia.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[Expression]</span></span></dt>
<dd><p>The JointActuator class is mostly a simple bookkeeping structure to
represent an actuator acting on a given Joint. It helps to flag
whether a given Joint is actuated or not so that MultibodyTree clients
can apply forces on actuated joints through their actuators, see
AddInOneForce().</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[Expression].calc_reflected_inertia(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd><p>Calculates the reflected inertia value for this actuator in
<code class="docutils literal notranslate"><span class="pre">context</span></code>. See reflected_inertia. Note that this ONLY depends on the
Parameters in the context; it does not depend on time, input, state,
etc.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[Expression].default_gear_ratio(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Gets the default value for this actuator’s gear ratio. See
reflected_inertia.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[Expression].default_reflected_inertia(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the default value for this actuator’s reflected inertia. It is
calculated as ρ²⋅Iᵣ, where ρ is the default gear ratio and Iᵣ is the
default rotor inertia for this actuator. See reflected_inertia.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[Expression].default_rotor_inertia(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Gets the default value for this actuator’s rotor inertia. See
reflected_inertia.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[Expression].effort_limit(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the actuator effort limit.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[Expression].gear_ratio(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd><p>Returns the associated gear ratio value for this actuator, stored in
<code class="docutils literal notranslate"><span class="pre">context</span></code>. See reflected_inertia. Note that this ONLY depends on the
Parameters in the context; it does not depend on time, input, state,
etc.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[Expression].get_actuation_vector(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[Expression],</span> <span class="pre">u:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Gets the actuation values for <code class="docutils literal notranslate"><span class="pre">this</span></code> actuator from the actuation
vector u for the entire plant model.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a reference to a nv-dimensional vector, where nv is the number of
velocity variables of joint().</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[Expression].get_controller_gains(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.PdControllerGains</span></span></dt>
<dd><p>Returns a reference to the controller gains for this actuator.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>has_controller() is <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[Expression].GetParentPlant(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">drake::multibody::MultibodyPlant&lt;drake::symbolic::Expression&gt;</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[Expression].has_controller(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if any non-zero controller gains have been specified
with a call to set_controller_gains().</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A controller for a given model instance can be <em>disarmed</em> if the
desired state input port for its model instance is not connected.
When a PD controller is disarmed, it has no effect on the
MultibodyPlant’s dynamics, as if there was no PD controller
(still, this method returns <code class="docutils literal notranslate"><span class="pre">True</span></code> whenever non-zero gains were
set with set_controller_gains().) See pd_controllers_and_ports for
further details.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[Expression].index(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.JointActuatorIndex</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[Expression].input_start(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the index to the first element for this joint actuator /
within the vector of actuation inputs for the full multibody / system.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the MultibodyTree model is not finalized.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[Expression].is_ephemeral(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[Expression].joint(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.Joint_[Expression]</span></span></dt>
<dd><p>Returns a reference to the joint actuated by this JointActuator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[Expression].model_instance(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[Expression].name(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns the name of the actuator.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[Expression].num_inputs(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of inputs associated with this actuator.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the MultibodyTree model is not finalized.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[Expression].rotor_inertia(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd><p>Returns the associated rotor inertia value for this actuator, stored
in <code class="docutils literal notranslate"><span class="pre">context</span></code>. See reflected_inertia. Note that this ONLY depends on
the Parameters in the context; it does not depend on time, input,
state, etc.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[Expression].set_actuation_vector(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[Expression],</span> <span class="pre">u_actuator:</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]],</span> <span class="pre">u:</span> <span class="pre">Optional[numpy.ndarray[object[m,</span> <span class="pre">1],</span> <span class="pre">flags.writeable]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Given the actuation values <code class="docutils literal notranslate"><span class="pre">u_actuator</span></code> for <code class="docutils literal notranslate"><span class="pre">this</span></code> actuator,
updates the actuation vector <code class="docutils literal notranslate"><span class="pre">u</span></code> for the entire multibody model to
which this actuator belongs to.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">u_actuator</span></code>:</dt><dd><p>Actuation values for <code class="docutils literal notranslate"><span class="pre">this</span></code> actuator. It must be of size equal
to num_inputs(). For units and sign conventions refer to the
specific Joint sub-class documentation.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">u</span></code>:</dt><dd><p>Actuation values for the entire plant model to which <code class="docutils literal notranslate"><span class="pre">this</span></code>
actuator belongs to. The actuation value in <code class="docutils literal notranslate"><span class="pre">u</span></code> for <code class="docutils literal notranslate"><span class="pre">this</span></code>
actuator must be found at offset input_start(). Only values
corresponding to this actuator are changed.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if u_actuator.size</strong><strong>(</strong><strong>) </strong><strong>!= this-&gt;num_inputs</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
<li><p><strong>RuntimeError if u is nullptr.</strong> – </p></li>
<li><p><strong>RuntimeError if ``u.size</strong><strong>(</strong><strong>) </strong><strong>!=</strong> – </p></li>
<li><p><strong>this-&gt;GetParentPlant</strong><strong>(</strong><strong>)</strong><strong>.num_actuated_dofs</strong><strong>(</strong><strong>)</strong><strong>``.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[Expression].set_controller_gains(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[Expression],</span> <span class="pre">gains:</span> <span class="pre">pydrake.multibody.tree.PdControllerGains)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Set controller gains for this joint actuator. This enables the
modeling of a simple PD controller of the form: ũ = -Kp⋅(q − qd) -
Kd⋅(v − vd) + u_ff u = max(−e, min(e, ũ)) where qd and vd are the
desired configuration and velocity for joint(), Kp and Kd are the
proportional and derivative gains specified in <code class="docutils literal notranslate"><span class="pre">gains</span></code>, u_ff is the
feedforward actuation and <code class="docutils literal notranslate"><span class="pre">e</span></code> corresponds to effort_limit().</p>
<p>The gains must be finite and non-negative. Setting both gains to zero
will remove the controller (has_controller() will return false).</p>
<p>For simulation, feedforward actuation can be provided through
MultibodyPlant::get_actuation_input_port(). Desired configuration and
velocity are specified through
MultibodyPlant::get_desired_state_input_port().</p>
<p>PD control is currently only supported for a discrete time plant.
Attempting to use non-zero gains on a continuous time plant will
result in an exception. See pd_controllers_and_ports for further
details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[Expression].set_default_gear_ratio(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[Expression],</span> <span class="pre">gear_ratio:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default value for this actuator’s gear ratio. See
reflected_inertia.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[Expression].set_default_rotor_inertia(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[Expression],</span> <span class="pre">rotor_inertia:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default value for this actuator’s rotor inertia. See
reflected_inertia.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[Expression].SetGearRatio(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">gear_ratio:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the associated gear ratio value for this actuator in <code class="docutils literal notranslate"><span class="pre">context</span></code>.
See reflected_inertia.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuator_[Expression].SetRotorInertia(self:</span> <span class="pre">pydrake.multibody.tree.JointActuator_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">rotor_inertia:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the associated rotor inertia value for this actuator in
<code class="docutils literal notranslate"><span class="pre">context</span></code>. See reflected_inertia.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuatorIndex</span></span></dt>
<dd><p>Type used to identify actuators by index within a multibody plant.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuatorIndex.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.tree.JointActuatorIndex) -&gt; None</p></li>
</ol>
<p>Default constructor; the result is an <em>invalid</em> index. This only
exists to serve applications which require a default constructor.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.tree.JointActuatorIndex, arg0: int) -&gt; None</p></li>
</ol>
<p>Construction from a non-negative <code class="docutils literal notranslate"><span class="pre">int</span></code> value. The value must lie in
the range of [0, 2³¹). Constructor only promises to test validity in
Debug build.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointActuatorIndex.is_valid(self:</span> <span class="pre">pydrake.multibody.tree.JointActuatorIndex)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Reports if the index is valid–the only operation on an invalid index
that doesn’t throw an exception in Debug builds.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointIndex</span></span></dt>
<dd><p>Type used to identify joints by index within a multibody plant.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointIndex.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.tree.JointIndex) -&gt; None</p></li>
</ol>
<p>Default constructor; the result is an <em>invalid</em> index. This only
exists to serve applications which require a default constructor.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.tree.JointIndex, arg0: int) -&gt; None</p></li>
</ol>
<p>Construction from a non-negative <code class="docutils literal notranslate"><span class="pre">int</span></code> value. The value must lie in
the range of [0, 2³¹). Constructor only promises to test validity in
Debug build.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">JointIndex.is_valid(self:</span> <span class="pre">pydrake.multibody.tree.JointIndex)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Reports if the index is valid–the only operation on an invalid index
that doesn’t throw an exception in Debug builds.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ForceElement</span></code></p>
<p>This ForceElement models a massless flexible bushing that connects a
frame A of a link (body) L0 to a frame C of a link (body) L1. The
bushing can apply a torque and force due to stiffness (spring) and
dissipation (damper) properties. Frame B is the bushing frame whose
origin Bo is halfway between Ao (A’s origin) and Co (C’s origin) and
whose unit vectors 𝐁𝐱, 𝐁𝐲, 𝐁𝐳 are “halfway” (in an angle-axis sense)
between the unit vectors of frame A and frame C. Frame B is a
“floating” frame in the sense that it is calculated from the position
and orientation of frames A and C (B is not welded to the bushing).</p>
<p>&#64;image html drake/multibody/tree/images/LinearBushingRollPitchYaw.png
width=80%</p>
<p>The set of forces on frame C from the bushing is equivalent to a
torque 𝐭 on frame C and a force 𝐟 applied to a point Cp of C. The set
of forces on frame A from the bushing is equivalent to a torque −𝐭 on
frame A and a force −𝐟 applied to a point Ap of A. Points Ap and Cp
are coincident with Bo (frame B’s origin).</p>
<p>This “quasi-symmetric” bushing force/torque model was developed at
Toyota Research Institute and has advantages compared to traditional
bushing models because it employs a bushing-centered “symmetric” frame
B and it ensures the moment of −𝐟 on A about Ao is equal to the moment
of 𝐟 on C about Co. Traditional models differ as they lack a
“symmetric” frame B and apply −𝐟 at Ao, which means the moment of −𝐟
on A about Ao is always zero. Note: This bushing model is not fully
symmetric since the orientation between frames A and C is
parameterized with roll-pitch-yaw angles [q₀ q₁ q₂]. Since these
angles have an inherent sequence, they are not mathematically
symmetric.</p>
<p>The torque model depends on spring-damper “gimbal” torques <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">≜</span> <span class="pre">[τ₀</span>
<span class="pre">τ₁</span> <span class="pre">τ₂]</span></code> which themselves depend on roll-pitch-yaw angles <code class="docutils literal notranslate"><span class="pre">q</span> <span class="pre">≜</span> <span class="pre">[q₀</span> <span class="pre">q₁</span>
<span class="pre">q₂]</span></code> and rates <code class="docutils literal notranslate"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">[q̇₀</span> <span class="pre">q̇₁</span> <span class="pre">q̇₂]</span></code> via a diagonal torque-stiffness
matrix K₀₁₂ and a diagonal torque-damping matrix D₀₁₂ as</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="err">⌈</span><span class="w"> </span><span class="n">τ₀</span><span class="w"> </span><span class="err">⌉</span><span class="w">     </span><span class="err">⌈</span><span class="n">k₀</span><span class="w">    </span><span class="mi">0</span><span class="w">    </span><span class="mi">0</span><span class="err">⌉</span><span class="w"> </span><span class="err">⌈</span><span class="w"> </span><span class="n">q₀</span><span class="w"> </span><span class="err">⌉</span><span class="w">     </span><span class="err">⌈</span><span class="n">d₀</span><span class="w">    </span><span class="mi">0</span><span class="w">    </span><span class="mi">0</span><span class="err">⌉</span><span class="w"> </span><span class="err">⌈</span><span class="w"> </span><span class="n">q</span><span class="err">̇</span><span class="n">₀</span><span class="w"> </span><span class="err">⌉</span>
<span class="n">τ</span><span class="w"> </span><span class="err">≜</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">τ₁</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">−</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">0</span><span class="w">   </span><span class="n">k₁</span><span class="w">    </span><span class="mi">0</span><span class="o">|</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">q₁</span><span class="w"> </span><span class="o">|</span><span class="w">  </span><span class="err">−</span><span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="mi">0</span><span class="w">   </span><span class="n">d₁</span><span class="w">    </span><span class="mi">0</span><span class="o">|</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">q</span><span class="err">̇</span><span class="n">₁</span><span class="w"> </span><span class="o">|</span>
<span class="w">    </span><span class="err">⌊</span><span class="w"> </span><span class="n">τ₂</span><span class="w"> </span><span class="err">⌋</span><span class="w">     </span><span class="err">⌊</span><span class="w"> </span><span class="mi">0</span><span class="w">    </span><span class="mi">0</span><span class="w">   </span><span class="n">k₂</span><span class="err">⌋</span><span class="w"> </span><span class="err">⌊</span><span class="w"> </span><span class="n">q₂</span><span class="w"> </span><span class="err">⌋</span><span class="w">     </span><span class="err">⌊</span><span class="w"> </span><span class="mi">0</span><span class="w">    </span><span class="mi">0</span><span class="w">   </span><span class="n">d₂</span><span class="err">⌋</span><span class="w"> </span><span class="err">⌊</span><span class="w"> </span><span class="n">q</span><span class="err">̇</span><span class="n">₂</span><span class="w"> </span><span class="err">⌋</span>
</pre></div>
</div>
</details><p>where k₀, k₁, k₂ and d₀, d₁, d₂ are torque stiffness and damping
constants and must have non-negative values.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>τ does not represent a vector expressed in one frame. Instead it
is regarded as a 3x1 array of torque scalars associated with
roll-pitch yaw.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As discussed in the Advanced section below, τ is not 𝐭 <code class="docutils literal notranslate"><span class="pre">(τ</span> <span class="pre">≠</span>
<span class="pre">𝐭)</span></code>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is a “linear” bushing model as gimbal torque τ varies
linearly with q and q̇ as τ = τᴋ + τᴅ where τᴋ = −K₀₁₂ ⋅ q and τᴅ
= −D₀₁₂ ⋅ q̇.</p>
</div>
<p>The bushing model for the net force 𝐟 on frame C from the bushing
depends on scalars x, y, z which are defined so 𝐫 (the position vector
from Ao to Co) can be expressed in frame B as <code class="docutils literal notranslate"><span class="pre">𝐫</span> <span class="pre">≜</span> <span class="pre">p_AoCo</span> <span class="pre">=</span> <span class="pre">[x</span> <span class="pre">y</span> <span class="pre">z]ʙ</span>
<span class="pre">=</span> <span class="pre">x</span> <span class="pre">𝐁𝐱</span> <span class="pre">+</span> <span class="pre">y</span> <span class="pre">𝐁𝐲</span> <span class="pre">+</span> <span class="pre">z</span> <span class="pre">𝐁𝐳</span></code>. The model for 𝐟 uses a diagonal
force-stiffness matrix Kxyᴢ, a diagonal force-damping matrix Dxyᴢ, and
defines fx, fy, fz so <code class="docutils literal notranslate"><span class="pre">𝐟</span> <span class="pre">=</span> <span class="pre">[fx</span> <span class="pre">fy</span> <span class="pre">fz]ʙ</span></code>.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="err">⌈</span><span class="w"> </span><span class="n">fx</span><span class="w"> </span><span class="err">⌉</span><span class="w">      </span><span class="err">⌈</span><span class="n">kx</span><span class="w">    </span><span class="mi">0</span><span class="w">    </span><span class="mi">0</span><span class="err">⌉</span><span class="w"> </span><span class="err">⌈</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="err">⌉</span><span class="w">     </span><span class="err">⌈</span><span class="n">dx</span><span class="w">    </span><span class="mi">0</span><span class="w">    </span><span class="mi">0</span><span class="err">⌉</span><span class="w"> </span><span class="err">⌈</span><span class="w"> </span><span class="n">x</span><span class="err">̇</span><span class="w"> </span><span class="err">⌉</span>
<span class="o">|</span><span class="w"> </span><span class="n">fy</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="err">−</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">0</span><span class="w">   </span><span class="n">ky</span><span class="w">    </span><span class="mi">0</span><span class="o">|</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">|</span><span class="w">  </span><span class="err">−</span><span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="mi">0</span><span class="w">   </span><span class="n">dy</span><span class="w">    </span><span class="mi">0</span><span class="o">|</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">y</span><span class="err">̇</span><span class="w"> </span><span class="o">|</span>
<span class="err">⌊</span><span class="w"> </span><span class="n">fz</span><span class="w"> </span><span class="err">⌋</span><span class="w">      </span><span class="err">⌊</span><span class="w"> </span><span class="mi">0</span><span class="w">    </span><span class="mi">0</span><span class="w">   </span><span class="n">kz</span><span class="err">⌋</span><span class="w"> </span><span class="err">⌊</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="err">⌋</span><span class="w">     </span><span class="err">⌊</span><span class="w"> </span><span class="mi">0</span><span class="w">    </span><span class="mi">0</span><span class="w">   </span><span class="n">dz</span><span class="err">⌋</span><span class="w"> </span><span class="err">⌊</span><span class="w"> </span><span class="n">z</span><span class="err">̇</span><span class="w"> </span><span class="err">⌋</span>
</pre></div>
</div>
</details><p>where kx, ky, kz and dx, dy, dz are force stiffness and damping
constants and must have non-negative values.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is a “linear” bushing model as the force 𝐟 varies linearly
with 𝐫 and 𝐫̇̇ as 𝐟 = 𝐟ᴋ + 𝐟ᴅ where 𝐟ᴋ = −Kxyz ⋅ 𝐫 and 𝐟ᴅ = −Dxyz
⋅ 𝐫̇̇.</p>
</div>
<p>This bushing’s constructor sets the torque stiffness/damping constants
<code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> and <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">d₂]</span></code> and the force stiffness/damping
constants <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> and <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code>. The examples below
demonstrate how to model various joints that have a flexible (e.g.,
rubber) mount. The damping values below with ? may be set to 0 or a
reasonable positive number.</p>
<p>Bushing type | torque constants | force constants
——————————–<a href="#id47"><span class="problematic" id="id48">|:--------------------|</span></a>:——————
z-axis revolute joint | k₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">0]</span></code> | kxyz = <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> ^
| d₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">?]</span></code> | dxyz = <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code> x-axis prismatic joint
| k₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> | kxyz = <code class="docutils literal notranslate"><span class="pre">[0</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> ^ | d₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span>
<span class="pre">d₂]</span></code> | dxyz = <code class="docutils literal notranslate"><span class="pre">[?</span> <span class="pre">dy</span> <span class="pre">dz]</span></code> Ball and socket joint | k₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[0</span> <span class="pre">0</span>
<span class="pre">0]</span></code> | kxyz = <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> ^ | d₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[?</span> <span class="pre">?</span> <span class="pre">?]</span></code> | dxyz = <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span>
<span class="pre">dz]</span></code> Weld/fixed joint | k₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> | kxyz = <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code>
^ | d₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">d₂]</span></code> | dxyz = <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code></p>
<p>Angles q₀, q₁, q₂ are calculated from frame C’s orientation relative
to frame A, with <code class="docutils literal notranslate"><span class="pre">[−π</span> <span class="pre">&lt;</span> <span class="pre">q₀</span> <span class="pre">≤</span> <span class="pre">π,</span> <span class="pre">−π/2</span> <span class="pre">≤</span> <span class="pre">q₁</span> <span class="pre">≤</span> <span class="pre">π/2,</span> <span class="pre">−π</span> <span class="pre">&lt;</span> <span class="pre">q₂</span> <span class="pre">≤</span> <span class="pre">π]</span></code>,
hence, there is no angle wrapping and torque stiffness has a limited
range. Gimbal torques τ can be discontinuous if one of q₀, q₁, q₂ is
discontinuous and its associated torque spring constant is nonzero.
For example, τ₂ is discontinuous if <code class="docutils literal notranslate"><span class="pre">k₂</span> <span class="pre">≠</span> <span class="pre">0</span></code> and the bushing has a
large rotation so q₂ jumps from <code class="docutils literal notranslate"><span class="pre">≈</span> <span class="pre">−π</span> <span class="pre">to</span> <span class="pre">π</span></code>. τ can also be
discontinuous if one of q̇₀, q̇₁, q̇₂ is discontinuous and its
associated torque damper constant is nonzero. For example, τ₀ is
discontinuous if <code class="docutils literal notranslate"><span class="pre">d₀</span> <span class="pre">≠</span> <span class="pre">0</span></code> and q̇₀ is undefined (which occurs when
<code class="docutils literal notranslate"><span class="pre">pitch</span> <span class="pre">=</span> <span class="pre">q₁</span> <span class="pre">=</span> <span class="pre">π/2</span></code>). Note: Due to the relationship of 𝐭 to τ shown
below, 𝐭 is discontinuous if τ is discontinuous.</p>
<p>As shown below, there are multiple ways to estimate torque and force
stiffness and damping constants. Use a method or combination of
methods appropriate for your application. For example, some methods
are more useful for a real physical bushing whereas other methods
(called “penalty methods”) can be more useful when replacing an ideal
joint (such as a revolute or fixed/weld joint) with a bushing.</p>
<p>Consider a penalty method if you want a bushing to substitute for a
“hard” constraint (e.g., an ideal joint). Since a bushing is
inherently compliant it will violate a hard constraint somewhat. The
stiffer the bushing, the more accurately it enforces the hard
constraint, but at a cost of more computational time. To balance
accuracy versus time, consider your tolerance for constraint errors.
For example, is it OK for your bushing to displace xₘₐₓ = 1 mm for an
estimated Fxₘₐₓ = 100 N? Also, one way to choose a force damping
constant dx is by choosing a “reasonably small” settling time tₛ,
where settling time tₛ is the interval of time for a system to settle
to within 1% (0.01) of an equilibrium solution). Is tₛ = 0.01 s
negligible for a robot arm with a 10 s reach maneuver?</p>
<p><a href="#id17"><span class="problematic" id="id18">**</span></a>** How to choose a torque stiffness constant k₀ or damping constant
d₀. The estimate of stiffness k₀ depends on whether you are modeling a
physical bushing (consider stiffness methods 1 or 2 below) or whether
you are using a bushing to replace an ideal joint such as a revolute
or fixed/weld joint (consider stiffness “penalty methods” 3 or 4
below). 1. Use a static experiment, e.g., apply a known moment load
Mx, measure the associated angular displacement Δq (radians), and
estimate k₀ = Mx / Δq. 2. Use FEA (finite element analysis) software
to estimate k₀. 3. Pick a desired maximum angular displacement qₘₐₓ,
estimate a maximum moment load Mxₘₐₓ, and estimate <code class="docutils literal notranslate"><span class="pre">k₀</span> <span class="pre">=</span> <span class="pre">Mxₘₐₓ</span> <span class="pre">/</span>
<span class="pre">qₘₐₓ</span></code> (units of N*m/rad). 4. Choose a characteristic moment of
inertia I₀ (directionally dependent), choose a desired angular
frequency ωₙ &gt; 0 (in rad/s) and estimate <code class="docutils literal notranslate"><span class="pre">k₀</span> <span class="pre">=</span> <span class="pre">I₀</span> <span class="pre">ωₙ²</span></code> (units of
N*m/rad).</p>
<p>The estimate of damping d₀ depends on whether you are modeling a
physical bushing (consider damping method 1 below) or whether you are
using a bushing to enforce a constraint (consider damping methods 2 or
3 below). 1. Use experiments to estimate a damping ratio ζ and
settling time tₛ. Compute “undamped natural frequency” ωₙ from ζ and
tₛ (as shown below in the Advanced section), then <code class="docutils literal notranslate"><span class="pre">d₀</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">ζ</span> <span class="pre">k₀</span> <span class="pre">/</span> <span class="pre">ωₙ</span></code>
(units of N*m*s/rad). 2. Choose a damping ratio ζ (e.g., ζ = 1,
critical damping) and a desired settling time tₛ, calculate ωₙ (as
shown below in the Advanced section), then <code class="docutils literal notranslate"><span class="pre">d₀</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">ζ</span> <span class="pre">k₀</span> <span class="pre">/</span> <span class="pre">ωₙ</span></code> (units
of N*m*s/rad). 3. Choose a damping ratio ζ (e.g., ζ = 1, critical
damping), estimate a characteristic moment of inertia and calculate
<code class="docutils literal notranslate"><span class="pre">d₀</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">ζ</span> <span class="pre">√(I₀</span> <span class="pre">k₀)</span></code>.</p>
<p>Refer to Advanced_bushing_stiffness_and_damping “Advanced bushing
stiffness and damping” for more details.</p>
<p><a href="#id19"><span class="problematic" id="id20">**</span></a>** How to choose a force stiffness constant kx or damping constant
dx. The estimate of stiffness kx depends on whether you are modeling a
real bushing (consider stiffness methods 1 or 2 below) or whether you
are using a bushing to replace an ideal joint such as a revolute or
fixed/weld joint (consider stiffness “penalty methods” 3 or 4 below).
1. Use a static experiment, e.g., apply a known force load Fx, measure
the associated displacement (stretch) Δx (in meters), and estimate kx
= Fx / Δx. 2. Use FEA (finite element analysis) software to estimate
kx (units of N/m). 3. Pick a desired maximum displacement xₘₐₓ,
estimate a maximum force load Fxₘₐₓ, and estimate <code class="docutils literal notranslate"><span class="pre">kx</span> <span class="pre">=</span> <span class="pre">Fxₘₐₓ</span> <span class="pre">/</span>
<span class="pre">xₘₐₓ</span></code> (units of N/m). 4. Choose a characteristic mass m (which may be
directionally dependent), choose a desired angular frequency ωₙ &gt; 0
(in rad/s) and estimate <code class="docutils literal notranslate"><span class="pre">kx</span> <span class="pre">=</span> <span class="pre">m</span> <span class="pre">ωₙ²</span></code> (units of N/m).</p>
<p>The estimate of damping dx depends on whether you are modeling a
physical bushing (consider damping method 1 below) or whether you are
using a bushing to enforce a constraint (consider damping methods 2 or
3 below). 1. Use experiments to estimate a damping ratio ζ and
settling time tₛ. Compute “undamped natural frequency” ωₙ from ζ and
tₛ (as shown below in the Advanced section), then <code class="docutils literal notranslate"><span class="pre">dx</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">ζ</span> <span class="pre">kx</span> <span class="pre">/</span> <span class="pre">ωₙ</span></code>
(units of N*s/m). 2. Choose a damping ratio ζ (e.g., ζ = 1, critical
damping) and a desired settling time tₛ, calculate ωₙ (as shown below
in the Advanced section), then <code class="docutils literal notranslate"><span class="pre">dx</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">ζ</span> <span class="pre">kx</span> <span class="pre">/</span> <span class="pre">ωₙ</span></code> (units of N*s/m).
3. Choose a damping ratio ζ (e.g., ζ = 1, critical damping), estimate
a characteristic mass m and calculate <code class="docutils literal notranslate"><span class="pre">dx</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">ζ</span> <span class="pre">√(m</span> <span class="pre">kx)</span></code> (units of
N*s/m).</p>
<p>Refer to Advanced_bushing_stiffness_and_damping “Advanced bushing
stiffness and damping” for more details.</p>
<p><a href="#id21"><span class="problematic" id="id22">**</span></a>** Advanced: Relationship of 𝐭 to τ. To understand how “gimbal
torques” τ relate to 𝐭, it helps to remember that the RollPitchYaw
class documentation states that a Space-fixed (extrinsic) X-Y-Z
rotation with roll-pitch-yaw angles [q₀ q₁ q₂] is equivalent to a
Body-fixed (intrinsic) Z-Y-X rotation by yaw-pitch-roll angles [q₂ q₁
q₀]. In the context of “gimbal torques”, the Body-fixed Z-Y-X rotation
sequence with angles [q₂ q₁ q₀] is physical meaningful as it produces
torques associated with successive frames in a gimbal as τ₂ 𝐀𝐳, τ₁ 𝐏𝐲,
τ₀ 𝐂𝐱, where each of 𝐀𝐳, 𝐏𝐲, 𝐂𝐱 are unit vectors associated with a
frame in the yaw-pitch-roll rotation sequence and 𝐏𝐲 is a unit vector
of the “pitch” intermediate frame. As described earlier, torque 𝐭 is
the moment of the bushing forces on frame C about Cp. Scalars tx, ty,
tz are defined so 𝐭 can be expressed <code class="docutils literal notranslate"><span class="pre">𝐭</span> <span class="pre">=</span> <span class="pre">[tx</span> <span class="pre">ty</span> <span class="pre">tz]ᴀ</span> <span class="pre">=</span> <span class="pre">tx</span> <span class="pre">𝐀𝐱</span> <span class="pre">+</span> <span class="pre">ty</span> <span class="pre">𝐀𝐲</span>
<span class="pre">+</span> <span class="pre">tz</span> <span class="pre">𝐀𝐳</span></code>. As shown in code documentation, the relationship of [tx ty
tz] to [τ₀ τ₁ τ₂] was found by equating 𝐭’s power to τ’s power as 𝐭 ⋅
w_AC = τ ⋅ q̇.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="err">⌈</span><span class="w"> </span><span class="n">tx</span><span class="w"> </span><span class="err">⌉</span><span class="w">      </span><span class="err">⌈</span><span class="w"> </span><span class="n">τ₀</span><span class="w"> </span><span class="err">⌉</span><span class="w">            </span><span class="err">⌈</span><span class="w"> </span><span class="n">cos</span><span class="p">(</span><span class="n">q₂</span><span class="p">)</span><span class="o">/</span><span class="n">cos</span><span class="p">(</span><span class="n">q₁</span><span class="p">)</span><span class="w">  </span><span class="n">sin</span><span class="p">(</span><span class="n">q₂</span><span class="p">)</span><span class="o">/</span><span class="n">cos</span><span class="p">(</span><span class="n">q₁</span><span class="p">)</span><span class="w">   </span><span class="mi">0</span><span class="w"> </span><span class="err">⌉</span>
<span class="o">|</span><span class="w"> </span><span class="n">ty</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Nᵀ</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">τ₁</span><span class="w"> </span><span class="o">|</span><span class="w">  </span><span class="n">where</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="w">   </span><span class="err">−</span><span class="n">sin</span><span class="p">(</span><span class="n">q2</span><span class="p">)</span><span class="w">            </span><span class="n">cos</span><span class="p">(</span><span class="n">q2</span><span class="p">)</span><span class="w">      </span><span class="mi">0</span><span class="w"> </span><span class="o">|</span>
<span class="err">⌊</span><span class="w"> </span><span class="n">tz</span><span class="w"> </span><span class="err">⌋</span><span class="w">      </span><span class="err">⌊</span><span class="w"> </span><span class="n">τ₂</span><span class="w"> </span><span class="err">⌋</span><span class="w">            </span><span class="err">⌊</span><span class="w"> </span><span class="n">cos</span><span class="p">(</span><span class="n">q₂</span><span class="p">)</span><span class="o">*</span><span class="n">tan</span><span class="p">(</span><span class="n">q₁</span><span class="p">)</span><span class="w">   </span><span class="n">sin</span><span class="p">(</span><span class="n">q₂</span><span class="p">)</span><span class="o">*</span><span class="n">tan</span><span class="p">(</span><span class="n">q₁</span><span class="p">)</span><span class="w">  </span><span class="mi">1</span><span class="w"> </span><span class="err">⌋</span>
</pre></div>
</div>
</details><p><a href="#id23"><span class="problematic" id="id24">**</span></a>** Advanced: More on how to choose bushing stiffness and damping
constants. The basics on how to choose bushing stiffness and damping
constants are at: - Basic_bushing_torque_stiffness_and_damping “How to
choose torque stiffness and damping constants” -
Basic_bushing_force_stiffness_and_damping “How to choose force
stiffness and damping constants”</p>
<p>The list below provides more detail on: The performance tradeoff
between high stiffness and long simulation time; loads that affect
estimates of Mxₘₐₓ or Fxₘₐₓ; and how a linear 2ⁿᵈ-order ODE provides
insight on how to experimentally determine stiffness and damping
constants. - Stiffness [k₀ k₁ k₂] and [kx ky kz] affect simulation
time and accuracy. Generally, a stiffer bushing better resembles an
ideal joint (e.g., a revolute joint or fixed/weld joint). However
(depending on integrator), a stiffer bushing usually increases
numerical integration time. - An estimate for a maximum load Mxₘₐₓ or
Fxₘₐₓ accounts for gravity forces, applied forces, inertia forces
(centripetal, Coriolis, gyroscopic), etc. - One way to determine
physical stiffness and damping constants is through the mathematical
intermediaries ωₙ (units of rad/s) and ζ (no units). The constant ωₙ
(called “undamped natural frequency” or “angular frequency”) and
constant ζ (called “damping ratio”) relate to the physical constants
mass m, damping constant dx, and stiffness constant kx via the
following prototypical linear constant-coefficient 2ⁿᵈ-order ODEs.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">m</span><span class="w"> </span><span class="n">x</span><span class="err">̈</span><span class="w"> </span><span class="o">+</span><span class="w">     </span><span class="n">dx</span><span class="w"> </span><span class="n">x</span><span class="err">̇</span><span class="w"> </span><span class="o">+</span><span class="w">  </span><span class="n">kx</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w">   </span><span class="k">or</span><span class="w"> </span><span class="n">alternatively</span><span class="w"> </span><span class="n">as</span>
<span class="w">   </span><span class="n">x</span><span class="err">̈</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">ζ</span><span class="w"> </span><span class="n">ωₙ</span><span class="w"> </span><span class="n">x</span><span class="err">̇</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ωₙ²</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w">   </span><span class="n">where</span><span class="w"> </span><span class="n">ωₙ²</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kx</span><span class="o">/</span><span class="n">m</span><span class="p">,</span><span class="w">  </span><span class="n">ζ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dx</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="err">√</span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="n">kx</span><span class="p">))</span>
</pre></div>
</div>
</details><p>ωₙ and ζ also appear in the related ODEs for rotational systems,
namely</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">I₀</span><span class="w"> </span><span class="n">q</span><span class="err">̈</span><span class="w"> </span><span class="o">+</span><span class="w">     </span><span class="n">d₀</span><span class="w"> </span><span class="n">q</span><span class="err">̇</span><span class="w"> </span><span class="o">+</span><span class="w">  </span><span class="n">k₀</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w">   </span><span class="k">or</span><span class="w"> </span><span class="n">alternatively</span><span class="w"> </span><span class="n">as</span>
<span class="w">    </span><span class="n">q</span><span class="err">̈</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">ζ</span><span class="w"> </span><span class="n">ωₙ</span><span class="w"> </span><span class="n">q</span><span class="err">̇</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ωₙ²</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w">   </span><span class="n">where</span><span class="w"> </span><span class="n">ωₙ²</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k₀</span><span class="o">/</span><span class="n">I₀</span><span class="p">,</span><span class="w">  </span><span class="n">ζ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d₀</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="err">√</span><span class="p">(</span><span class="n">I₀</span><span class="w"> </span><span class="n">k₀</span><span class="p">))</span>
</pre></div>
</div>
</details><p>One way to determine ωₙ is from settling time tₛ which approximates
the time for a system to settle to within a specified settling ratio
of an equilibrium solutions. Typical values for settling ratio are 1%
(0.01), 2% (0.02), 5% (0.05), and 10% (0.10). - When ζ &lt; 0.7
(underdamped), a commonly used approximation is ωₙ ≈
-ln(settling_ratio) / (ζ tₛ) which for settling ratios 0.01 and 0.05
give ωₙ ≈ 4.6 / (ζ tₛ) and ωₙ ≈ 3 / (ζ tₛ). Another commonly used
approximation is ωₙ ≈ -ln(settling_ratio √(1- ζ²)) / (ζ tₛ). See
<a class="reference external" href="https://en.wikipedia.org/wiki/Settling_time">https://en.wikipedia.org/wiki/Settling_time</a> or the book Modern Control
Engineering by Katsuhiko Ogata. Although these approximate formulas
for ωₙ are common, they are somewhat inaccurate. Settling time for
underdamped systems is discontinuous and requires solving a nonlinear
algebraic equation (an iterative process). For more information, see
<a class="reference external" href="http://www.scielo.org.co/pdf/rfiua/n66/n66a09.pdf">http://www.scielo.org.co/pdf/rfiua/n66/n66a09.pdf</a> [Ramos-Paja, et. al
2012], “Accurate calculation of settling time in second order systems:
a photovoltaic application”. Another reference is
<a class="reference external" href="https://courses.grainger.illinois.edu/ece486/sp2020/laboratory/docs/lab2/estimates.html">https://courses.grainger.illinois.edu/ece486/sp2020/laboratory/docs/lab2/estimates.html</a>
- When ζ ≈ 1 (critically damped), ωₙ is determined by choosing a
settling ratio and then solving for (ωₙ tₛ) via the nonlinear
algebraic equation (1 + ωₙ tₛ)*exp(-ωₙ tₛ) = settling_ratio. Settling
ratio | ωₙ ————– | ————- 0.01 | 6.64 / tₛ 0.02 | 5.83
/ tₛ 0.05 | 4.74 / tₛ 0.10 | 3.89 / tₛ See
<a class="reference external" href="https://electronics.stackexchange.com/questions/296567/over-and-critically-damped-systems-settling-time">https://electronics.stackexchange.com/questions/296567/over-and-critically-damped-systems-settling-time</a>
- When ζ ≥ 1.01 (overdamped), ωₙ ≈ -ln(2 settling_ratio sz/s₂) / (s₁
tₛ) where sz = √(ζ² - 1), s₁ = ζ - sz, s₂ = ζ + sz. The derivation and
approximation error estimates for this overdamped settling time
formula is ApproximateOverdampedSettlingTime “below”.</p>
<ul class="simple">
<li><p>For a real physical bushing, an experiment is one way to estimate damping</p></li>
</ul>
<p>constants.  For example, to estimate a torque damping constant d₀ associated
with underdamped vibrations (damping ratio 0 &lt; ζ &lt; 1), attach the bushing to
a massive rod, initially displace the rod by angle Δq, release the rod and
measure q(t).  From the q(t) measurement, estimate decay ratio (the ratio of
successive peak heights above the final steady-state value) calculate
logarithmic decrement δ = -ln(decay_ratio), calculate damping ratio
ζ = √(δ² / (4π² + δ²)), then calculate d₀ using d₀ = 2 ζ √(I₀ k₀) or
d₀ = 2 ζ k₀ / ωₙ. For more information, see
<a class="reference external" href="https://en.wikipedia.org/wiki/Damping_ratio#Logarithmic_decrement">https://en.wikipedia.org/wiki/Damping_ratio#Logarithmic_decrement</a></p>
<p><a href="#id25"><span class="problematic" id="id26">**</span></a>** Derivation: Approximate formula for overdamped settling time.
Since a literature reference for this formula was not found, the
derivation below was done at TRI (it has not been peer reviewed). This
formula results from the “dominant pole” solution in the prototypical
constant-coefficient linear 2ⁿᵈ-order ODE. For ẋ(0) = 0, mathematics
shows poles p₁ = -ωₙ s₁, p₂ = -ωₙ s₂, where sz = √(ζ² - 1), s₁ = ζ -
sz, s₂ = ζ + sz. and</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p₂</span><span class="o">/</span><span class="p">(</span><span class="n">p₂</span><span class="o">-</span><span class="n">p₁</span><span class="p">)</span><span class="w"> </span><span class="n">exp</span><span class="p">(</span><span class="n">p₁</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">p₁</span><span class="o">/</span><span class="p">(</span><span class="n">p₂</span><span class="o">-</span><span class="n">p₁</span><span class="p">)</span><span class="w"> </span><span class="n">exp</span><span class="p">(</span><span class="n">p₂</span><span class="w"> </span><span class="n">t</span><span class="p">)</span>
<span class="w">             </span><span class="o">=</span><span class="w"> </span><span class="n">s₂</span><span class="o">/</span><span class="p">(</span><span class="n">s₂</span><span class="o">-</span><span class="n">s₁</span><span class="p">)</span><span class="w"> </span><span class="n">exp</span><span class="p">(</span><span class="n">p₁</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">s₁</span><span class="o">/</span><span class="p">(</span><span class="n">s₂</span><span class="o">-</span><span class="n">s₁</span><span class="p">)</span><span class="w"> </span><span class="n">exp</span><span class="p">(</span><span class="n">p₂</span><span class="w"> </span><span class="n">t</span><span class="p">)</span>
<span class="w">             </span><span class="o">=</span><span class="w">  </span><span class="n">k</span><span class="o">/</span><span class="p">(</span><span class="w"> </span><span class="n">k</span><span class="mi">-1</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">exp</span><span class="p">(</span><span class="n">p₁</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w">  </span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="w"> </span><span class="n">k</span><span class="mi">-1</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">exp</span><span class="p">(</span><span class="n">p₂</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="n">where</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s₂</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">s₁</span>
<span class="w">             </span><span class="err">≈</span><span class="w">  </span><span class="n">k</span><span class="o">/</span><span class="p">(</span><span class="w"> </span><span class="n">k</span><span class="mi">-1</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">exp</span><span class="p">(</span><span class="n">p₁</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w">                        </span><span class="n">since</span><span class="w"> </span><span class="n">p₁</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">p₂</span>
</pre></div>
</div>
</details><p>Note: k = s₂ / s₁ is real, k &gt; 0, s₂ = k s₁, and p₁ &gt; p₂ (p₁ is less
negative then p₂), so exp(p₁ t) decays to zero slower than exp(p₂ t)
and exp(p₁ t) ≫ exp(p₂ t) for sufficiently large t. Hence we assume
exp(p₂ t) ≈ 0 (which is why p₁ is called the “dominant pole”). Next,</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">k</span><span class="o">/</span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s₂</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">s₁</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">s₂</span><span class="o">/</span><span class="n">s₁</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s₂</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">s₂</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">s₁</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s₂</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="n">sz</span><span class="p">),</span><span class="w">  </span><span class="n">so</span>
<span class="w">  </span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w">  </span><span class="err">≈</span><span class="w">  </span><span class="n">s₂</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="n">sz</span><span class="p">)</span><span class="w"> </span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">s₁</span><span class="w"> </span><span class="n">ωₙ</span><span class="w"> </span><span class="n">t</span><span class="p">),</span><span class="w">                        </span><span class="n">hence</span>
<span class="w">  </span><span class="n">settling_ratio</span><span class="w"> </span><span class="err">≈</span><span class="w"> </span><span class="n">s₂</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="n">sz</span><span class="p">)</span><span class="w"> </span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">s₁</span><span class="w"> </span><span class="n">ωₙ</span><span class="w"> </span><span class="n">tₛ</span><span class="p">),</span><span class="w">                      </span><span class="n">finally</span>
<span class="w">  </span><span class="n">ωₙ</span><span class="w"> </span><span class="err">≈</span><span class="w"> </span><span class="o">-</span><span class="n">ln</span><span class="p">(</span><span class="n">settling_ratio</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">sz</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">s₂</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">s₁</span><span class="w"> </span><span class="n">tₛ</span><span class="p">)</span>
</pre></div>
</div>
</details><p>The table below shows that there is little error in this approximate
formula for various settling ratios and ζ, particularly for ζ ≥ 1.1.
For 1.0 ≤ ζ &lt; 1.1, the critical damping estimates of ωₙ work well.
Settling ratio | ζ = 1.01 | ζ = 1.1 | ζ = 1.2 | ζ = 1.3 | ζ = 1.5
————– | ——– | ——- | ——- | ——- | ——–
0.01 | 1.98% | 0.005% | 2.9E-5% | 1.6E-7% | 2.4E-12% 0.02 | 2.91% |
0.016% | 1.8E-4% | 2.1E-6% | 1.6E-10% 0.05 | 5.10% | 0.076% | 2.3E-3%
| 7.0E-5% | 4.4E-8% 0.10 | 8.28% | 0.258% | 1.6E-2% | 1.0E-3% |
3.3E-6% Note: There is a related derivation in the reference below,
however, it needlessly makes the oversimplified approximation k/(k -
1) ≈ 1.
<a class="reference external" href="https://electronics.stackexchange.com/questions/296567/over-and-critically-damped-systems-settling-time">https://electronics.stackexchange.com/questions/296567/over-and-critically-damped-systems-settling-time</a></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The complete theory for this bushing is documented in the source
code. Please look there if you want more information.</p>
</div>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">T</span></code>:</dt><dd><p>The underlying scalar type. Must be a valid Eigen scalar.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>math::RollPitchYaw for definitions of roll, pitch, yaw <code class="docutils literal notranslate"><span class="pre">[q₀</span> <span class="pre">q₁</span>
<span class="pre">q₂]</span></code>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Per issue #12982, do not directly or indirectly call the following
methods as they have not yet been implemented and throw an
exception: CalcPotentialEnergy(), CalcConservativePower(),
CalcNonConservativePower().</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">LinearBushingRollPitchYaw_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw.__init__(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw,</span> <span class="pre">frameA:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">frameC:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">torque_stiffness_constants:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">torque_damping_constants:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">force_stiffness_constants:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">force_damping_constants:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Construct a LinearBushingRollPitchYaw B that connects frames A and C,
where frame A is welded to a link L0 and frame C is welded to a link
L1.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameA</span></code>:</dt><dd><p>frame A of link (body) L0 that connects to bushing B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameC</span></code>:</dt><dd><p>frame C of link (body) L1 that connects to bushing B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">torque_stiffness_constants</span></code>:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> multiply the roll-pitch-yaw angles <code class="docutils literal notranslate"><span class="pre">[q₀</span> <span class="pre">q₁</span> <span class="pre">q₂]</span></code>
to produce the spring portion of the “gimbal” torques τ₀, τ₁, τ₂.
The SI units of <code class="docutils literal notranslate"><span class="pre">k₀,</span> <span class="pre">k₁,</span> <span class="pre">k₂</span></code> are N*m/rad.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">torque_damping_constants</span></code>:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">d₂]</span></code> multiply the roll-pitch-yaw rates <code class="docutils literal notranslate"><span class="pre">[q̇₀</span> <span class="pre">q̇₁</span> <span class="pre">q̇₂]</span></code>
to produce the damper portion of the “gimbal” torques τ₀, τ₁, τ₂.
The SI units of <code class="docutils literal notranslate"><span class="pre">d₀,</span> <span class="pre">d₁,</span> <span class="pre">d₂</span></code> are N*m*s/rad.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">force_stiffness_constants</span></code>:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> multiply the bushing displacements <code class="docutils literal notranslate"><span class="pre">[x</span> <span class="pre">y</span> <span class="pre">z]</span></code> to
form 𝐟ᴋ, the spring portion of the force 𝐟 = [fx fy fz]ʙ. The SI
units of <code class="docutils literal notranslate"><span class="pre">kx,</span> <span class="pre">ky,</span> <span class="pre">kz</span></code> are N/m.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">force_damping_constants</span></code>:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code> multiply the bushing displacement rates <code class="docutils literal notranslate"><span class="pre">[ẋ</span> <span class="pre">ẏ</span>
<span class="pre">ż]</span></code> to form 𝐟ᴅ, the damper portion of the force 𝐟 = [fx fy fz]ʙ.
The SI units of <code class="docutils literal notranslate"><span class="pre">dx,</span> <span class="pre">dy,</span> <span class="pre">dz</span></code> are N*s/m.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The LinearBushingRollPitchYaw class documentation describes the
stiffness and damping constants.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The net moment on C about Co is affected by both the gimbal torque
and the moment of 𝐟 about Co. Similarly, for the net moment on A
about Ao.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>math::RollPitchYaw describes the roll pitch yaw angles q₀, q₁, q₂.
The position from Ao to Co is p_AoCo_B = x 𝐁𝐱 + y 𝐁𝐲 + z 𝐁𝐳 = [x y
z]ʙ.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The ModelInstanceIndex assigned to this by the constructor is the
one assigned to frame C, i.e., frameC.model_instance().</p>
</div>
<dl class="simple">
<dt>Precondition:</dt><dd><p>All the stiffness and damping constants must be non-negative.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw.CalcBushingSpatialForceOnFrameA(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.math.SpatialForce</span></span></dt>
<dd><p>Calculate F_A_A, the bushing’s spatial force on frame A expressed in
A. F_A_A contains two vectors: the moment of all bushing forces on A
about Ao (−𝐭 + p_AoAp × −𝐟) and the net bushing force on A (−𝐟
expressed in A).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcBushingSpatialForceOnFrameC().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if pitch angle is near gimbal-lock. For more info</strong><strong>,</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RollPitchYaw::DoesCosPitchAngleViolateGimbalLockTolerance().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw.CalcBushingSpatialForceOnFrameC(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.math.SpatialForce</span></span></dt>
<dd><p>Calculate F_C_C, the bushing’s spatial force on frame C expressed in
C. F_C_C contains two vectors: the moment of all bushing forces on C
about Co (𝐭 + p_CoCp × 𝐟) and the resultant bushing force on C (𝐟
expressed in C).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcBushingSpatialForceOnFrameA().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if pitch angle is near gimbal-lock. For more info</strong><strong>,</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RollPitchYaw::DoesCosPitchAngleViolateGimbalLockTolerance().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw.force_damping_constants(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the default force damping constants <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code> (units of
N*s/m). Refer to Basic_bushing_force_stiffness_and_damping “How to
choose force stiffness and damping constants” for more details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw.force_stiffness_constants(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the default force stiffness constants <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> (units of
N/m). Refer to Basic_bushing_force_stiffness_and_damping “How to
choose force stiffness and damping constants” for more details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw.frameA(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.Frame</span></span></dt>
<dd><p>Returns frame A, which is the frame that is welded to link (body) L0
and attached to the bushing.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw.frameC(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.Frame</span></span></dt>
<dd><p>Returns frame C, which is the frame that is welded to link (body) L1
and attached to the bushing.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw.GetForceDampingConstants(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the force damping constants <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code> (units of N*s/m)
stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw.GetForceStiffnessConstants(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the force stiffness constants <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> (units of N/m)
stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw.GetTorqueDampingConstants(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the torque damping constants <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">d₂]</span></code> (units of
N*m*s/rad) stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw.GetTorqueStiffnessConstants(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the torque stiffness constants <code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> (units of
N*m/rad) stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw.link0(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RigidBody</span></span></dt>
<dd><p>Returns link (body) L0 (frame A is welded to link L0).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw.link1(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RigidBody</span></span></dt>
<dd><p>Returns link (body) L1 (frame C is welded to link L1).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw.SetForceDampingConstants(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">force_damping:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the force damping constants <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code> (units of N*s/m) in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw.SetForceStiffnessConstants(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">force_stiffness:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the force stiffness constants <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> (units of N/m) in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw.SetTorqueDampingConstants(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">torque_damping:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the torque damping constants <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">d₂]</span></code> (units of N*m*s/rad)
in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw.SetTorqueStiffnessConstants(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">torque_stiffness:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the torque stiffness constants <code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> (units of N*m/rad)
in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw.torque_damping_constants(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the default torque damping constants <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">d₂]</span></code> (units of
N*m*s/rad). Refer to Basic_bushing_torque_stiffness_and_damping “How
to choose torque stiffness and damping constants” for more details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw.torque_stiffness_constants(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the default torque stiffness constants <code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> (units
of N*m/rad). Refer to Basic_bushing_torque_stiffness_and_damping “How
to choose torque stiffness and damping constants” for more details.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">LinearBushingRollPitchYaw_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">LinearBushingRollPitchYaw_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">LinearBushingRollPitchYaw_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ForceElement_[AutoDiffXd]</span></code></p>
<p>This ForceElement models a massless flexible bushing that connects a
frame A of a link (body) L0 to a frame C of a link (body) L1. The
bushing can apply a torque and force due to stiffness (spring) and
dissipation (damper) properties. Frame B is the bushing frame whose
origin Bo is halfway between Ao (A’s origin) and Co (C’s origin) and
whose unit vectors 𝐁𝐱, 𝐁𝐲, 𝐁𝐳 are “halfway” (in an angle-axis sense)
between the unit vectors of frame A and frame C. Frame B is a
“floating” frame in the sense that it is calculated from the position
and orientation of frames A and C (B is not welded to the bushing).</p>
<p>&#64;image html drake/multibody/tree/images/LinearBushingRollPitchYaw.png
width=80%</p>
<p>The set of forces on frame C from the bushing is equivalent to a
torque 𝐭 on frame C and a force 𝐟 applied to a point Cp of C. The set
of forces on frame A from the bushing is equivalent to a torque −𝐭 on
frame A and a force −𝐟 applied to a point Ap of A. Points Ap and Cp
are coincident with Bo (frame B’s origin).</p>
<p>This “quasi-symmetric” bushing force/torque model was developed at
Toyota Research Institute and has advantages compared to traditional
bushing models because it employs a bushing-centered “symmetric” frame
B and it ensures the moment of −𝐟 on A about Ao is equal to the moment
of 𝐟 on C about Co. Traditional models differ as they lack a
“symmetric” frame B and apply −𝐟 at Ao, which means the moment of −𝐟
on A about Ao is always zero. Note: This bushing model is not fully
symmetric since the orientation between frames A and C is
parameterized with roll-pitch-yaw angles [q₀ q₁ q₂]. Since these
angles have an inherent sequence, they are not mathematically
symmetric.</p>
<p>The torque model depends on spring-damper “gimbal” torques <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">≜</span> <span class="pre">[τ₀</span>
<span class="pre">τ₁</span> <span class="pre">τ₂]</span></code> which themselves depend on roll-pitch-yaw angles <code class="docutils literal notranslate"><span class="pre">q</span> <span class="pre">≜</span> <span class="pre">[q₀</span> <span class="pre">q₁</span>
<span class="pre">q₂]</span></code> and rates <code class="docutils literal notranslate"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">[q̇₀</span> <span class="pre">q̇₁</span> <span class="pre">q̇₂]</span></code> via a diagonal torque-stiffness
matrix K₀₁₂ and a diagonal torque-damping matrix D₀₁₂ as</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="err">⌈</span><span class="w"> </span><span class="n">τ₀</span><span class="w"> </span><span class="err">⌉</span><span class="w">     </span><span class="err">⌈</span><span class="n">k₀</span><span class="w">    </span><span class="mi">0</span><span class="w">    </span><span class="mi">0</span><span class="err">⌉</span><span class="w"> </span><span class="err">⌈</span><span class="w"> </span><span class="n">q₀</span><span class="w"> </span><span class="err">⌉</span><span class="w">     </span><span class="err">⌈</span><span class="n">d₀</span><span class="w">    </span><span class="mi">0</span><span class="w">    </span><span class="mi">0</span><span class="err">⌉</span><span class="w"> </span><span class="err">⌈</span><span class="w"> </span><span class="n">q</span><span class="err">̇</span><span class="n">₀</span><span class="w"> </span><span class="err">⌉</span>
<span class="n">τ</span><span class="w"> </span><span class="err">≜</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">τ₁</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">−</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">0</span><span class="w">   </span><span class="n">k₁</span><span class="w">    </span><span class="mi">0</span><span class="o">|</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">q₁</span><span class="w"> </span><span class="o">|</span><span class="w">  </span><span class="err">−</span><span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="mi">0</span><span class="w">   </span><span class="n">d₁</span><span class="w">    </span><span class="mi">0</span><span class="o">|</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">q</span><span class="err">̇</span><span class="n">₁</span><span class="w"> </span><span class="o">|</span>
<span class="w">    </span><span class="err">⌊</span><span class="w"> </span><span class="n">τ₂</span><span class="w"> </span><span class="err">⌋</span><span class="w">     </span><span class="err">⌊</span><span class="w"> </span><span class="mi">0</span><span class="w">    </span><span class="mi">0</span><span class="w">   </span><span class="n">k₂</span><span class="err">⌋</span><span class="w"> </span><span class="err">⌊</span><span class="w"> </span><span class="n">q₂</span><span class="w"> </span><span class="err">⌋</span><span class="w">     </span><span class="err">⌊</span><span class="w"> </span><span class="mi">0</span><span class="w">    </span><span class="mi">0</span><span class="w">   </span><span class="n">d₂</span><span class="err">⌋</span><span class="w"> </span><span class="err">⌊</span><span class="w"> </span><span class="n">q</span><span class="err">̇</span><span class="n">₂</span><span class="w"> </span><span class="err">⌋</span>
</pre></div>
</div>
</details><p>where k₀, k₁, k₂ and d₀, d₁, d₂ are torque stiffness and damping
constants and must have non-negative values.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>τ does not represent a vector expressed in one frame. Instead it
is regarded as a 3x1 array of torque scalars associated with
roll-pitch yaw.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As discussed in the Advanced section below, τ is not 𝐭 <code class="docutils literal notranslate"><span class="pre">(τ</span> <span class="pre">≠</span>
<span class="pre">𝐭)</span></code>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is a “linear” bushing model as gimbal torque τ varies
linearly with q and q̇ as τ = τᴋ + τᴅ where τᴋ = −K₀₁₂ ⋅ q and τᴅ
= −D₀₁₂ ⋅ q̇.</p>
</div>
<p>The bushing model for the net force 𝐟 on frame C from the bushing
depends on scalars x, y, z which are defined so 𝐫 (the position vector
from Ao to Co) can be expressed in frame B as <code class="docutils literal notranslate"><span class="pre">𝐫</span> <span class="pre">≜</span> <span class="pre">p_AoCo</span> <span class="pre">=</span> <span class="pre">[x</span> <span class="pre">y</span> <span class="pre">z]ʙ</span>
<span class="pre">=</span> <span class="pre">x</span> <span class="pre">𝐁𝐱</span> <span class="pre">+</span> <span class="pre">y</span> <span class="pre">𝐁𝐲</span> <span class="pre">+</span> <span class="pre">z</span> <span class="pre">𝐁𝐳</span></code>. The model for 𝐟 uses a diagonal
force-stiffness matrix Kxyᴢ, a diagonal force-damping matrix Dxyᴢ, and
defines fx, fy, fz so <code class="docutils literal notranslate"><span class="pre">𝐟</span> <span class="pre">=</span> <span class="pre">[fx</span> <span class="pre">fy</span> <span class="pre">fz]ʙ</span></code>.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="err">⌈</span><span class="w"> </span><span class="n">fx</span><span class="w"> </span><span class="err">⌉</span><span class="w">      </span><span class="err">⌈</span><span class="n">kx</span><span class="w">    </span><span class="mi">0</span><span class="w">    </span><span class="mi">0</span><span class="err">⌉</span><span class="w"> </span><span class="err">⌈</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="err">⌉</span><span class="w">     </span><span class="err">⌈</span><span class="n">dx</span><span class="w">    </span><span class="mi">0</span><span class="w">    </span><span class="mi">0</span><span class="err">⌉</span><span class="w"> </span><span class="err">⌈</span><span class="w"> </span><span class="n">x</span><span class="err">̇</span><span class="w"> </span><span class="err">⌉</span>
<span class="o">|</span><span class="w"> </span><span class="n">fy</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="err">−</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">0</span><span class="w">   </span><span class="n">ky</span><span class="w">    </span><span class="mi">0</span><span class="o">|</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">|</span><span class="w">  </span><span class="err">−</span><span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="mi">0</span><span class="w">   </span><span class="n">dy</span><span class="w">    </span><span class="mi">0</span><span class="o">|</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">y</span><span class="err">̇</span><span class="w"> </span><span class="o">|</span>
<span class="err">⌊</span><span class="w"> </span><span class="n">fz</span><span class="w"> </span><span class="err">⌋</span><span class="w">      </span><span class="err">⌊</span><span class="w"> </span><span class="mi">0</span><span class="w">    </span><span class="mi">0</span><span class="w">   </span><span class="n">kz</span><span class="err">⌋</span><span class="w"> </span><span class="err">⌊</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="err">⌋</span><span class="w">     </span><span class="err">⌊</span><span class="w"> </span><span class="mi">0</span><span class="w">    </span><span class="mi">0</span><span class="w">   </span><span class="n">dz</span><span class="err">⌋</span><span class="w"> </span><span class="err">⌊</span><span class="w"> </span><span class="n">z</span><span class="err">̇</span><span class="w"> </span><span class="err">⌋</span>
</pre></div>
</div>
</details><p>where kx, ky, kz and dx, dy, dz are force stiffness and damping
constants and must have non-negative values.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is a “linear” bushing model as the force 𝐟 varies linearly
with 𝐫 and 𝐫̇̇ as 𝐟 = 𝐟ᴋ + 𝐟ᴅ where 𝐟ᴋ = −Kxyz ⋅ 𝐫 and 𝐟ᴅ = −Dxyz
⋅ 𝐫̇̇.</p>
</div>
<p>This bushing’s constructor sets the torque stiffness/damping constants
<code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> and <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">d₂]</span></code> and the force stiffness/damping
constants <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> and <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code>. The examples below
demonstrate how to model various joints that have a flexible (e.g.,
rubber) mount. The damping values below with ? may be set to 0 or a
reasonable positive number.</p>
<p>Bushing type | torque constants | force constants
——————————–<a href="#id49"><span class="problematic" id="id50">|:--------------------|</span></a>:——————
z-axis revolute joint | k₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">0]</span></code> | kxyz = <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> ^
| d₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">?]</span></code> | dxyz = <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code> x-axis prismatic joint
| k₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> | kxyz = <code class="docutils literal notranslate"><span class="pre">[0</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> ^ | d₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span>
<span class="pre">d₂]</span></code> | dxyz = <code class="docutils literal notranslate"><span class="pre">[?</span> <span class="pre">dy</span> <span class="pre">dz]</span></code> Ball and socket joint | k₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[0</span> <span class="pre">0</span>
<span class="pre">0]</span></code> | kxyz = <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> ^ | d₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[?</span> <span class="pre">?</span> <span class="pre">?]</span></code> | dxyz = <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span>
<span class="pre">dz]</span></code> Weld/fixed joint | k₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> | kxyz = <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code>
^ | d₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">d₂]</span></code> | dxyz = <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code></p>
<p>Angles q₀, q₁, q₂ are calculated from frame C’s orientation relative
to frame A, with <code class="docutils literal notranslate"><span class="pre">[−π</span> <span class="pre">&lt;</span> <span class="pre">q₀</span> <span class="pre">≤</span> <span class="pre">π,</span> <span class="pre">−π/2</span> <span class="pre">≤</span> <span class="pre">q₁</span> <span class="pre">≤</span> <span class="pre">π/2,</span> <span class="pre">−π</span> <span class="pre">&lt;</span> <span class="pre">q₂</span> <span class="pre">≤</span> <span class="pre">π]</span></code>,
hence, there is no angle wrapping and torque stiffness has a limited
range. Gimbal torques τ can be discontinuous if one of q₀, q₁, q₂ is
discontinuous and its associated torque spring constant is nonzero.
For example, τ₂ is discontinuous if <code class="docutils literal notranslate"><span class="pre">k₂</span> <span class="pre">≠</span> <span class="pre">0</span></code> and the bushing has a
large rotation so q₂ jumps from <code class="docutils literal notranslate"><span class="pre">≈</span> <span class="pre">−π</span> <span class="pre">to</span> <span class="pre">π</span></code>. τ can also be
discontinuous if one of q̇₀, q̇₁, q̇₂ is discontinuous and its
associated torque damper constant is nonzero. For example, τ₀ is
discontinuous if <code class="docutils literal notranslate"><span class="pre">d₀</span> <span class="pre">≠</span> <span class="pre">0</span></code> and q̇₀ is undefined (which occurs when
<code class="docutils literal notranslate"><span class="pre">pitch</span> <span class="pre">=</span> <span class="pre">q₁</span> <span class="pre">=</span> <span class="pre">π/2</span></code>). Note: Due to the relationship of 𝐭 to τ shown
below, 𝐭 is discontinuous if τ is discontinuous.</p>
<p>As shown below, there are multiple ways to estimate torque and force
stiffness and damping constants. Use a method or combination of
methods appropriate for your application. For example, some methods
are more useful for a real physical bushing whereas other methods
(called “penalty methods”) can be more useful when replacing an ideal
joint (such as a revolute or fixed/weld joint) with a bushing.</p>
<p>Consider a penalty method if you want a bushing to substitute for a
“hard” constraint (e.g., an ideal joint). Since a bushing is
inherently compliant it will violate a hard constraint somewhat. The
stiffer the bushing, the more accurately it enforces the hard
constraint, but at a cost of more computational time. To balance
accuracy versus time, consider your tolerance for constraint errors.
For example, is it OK for your bushing to displace xₘₐₓ = 1 mm for an
estimated Fxₘₐₓ = 100 N? Also, one way to choose a force damping
constant dx is by choosing a “reasonably small” settling time tₛ,
where settling time tₛ is the interval of time for a system to settle
to within 1% (0.01) of an equilibrium solution). Is tₛ = 0.01 s
negligible for a robot arm with a 10 s reach maneuver?</p>
<p><a href="#id27"><span class="problematic" id="id28">**</span></a>** How to choose a torque stiffness constant k₀ or damping constant
d₀. The estimate of stiffness k₀ depends on whether you are modeling a
physical bushing (consider stiffness methods 1 or 2 below) or whether
you are using a bushing to replace an ideal joint such as a revolute
or fixed/weld joint (consider stiffness “penalty methods” 3 or 4
below). 1. Use a static experiment, e.g., apply a known moment load
Mx, measure the associated angular displacement Δq (radians), and
estimate k₀ = Mx / Δq. 2. Use FEA (finite element analysis) software
to estimate k₀. 3. Pick a desired maximum angular displacement qₘₐₓ,
estimate a maximum moment load Mxₘₐₓ, and estimate <code class="docutils literal notranslate"><span class="pre">k₀</span> <span class="pre">=</span> <span class="pre">Mxₘₐₓ</span> <span class="pre">/</span>
<span class="pre">qₘₐₓ</span></code> (units of N*m/rad). 4. Choose a characteristic moment of
inertia I₀ (directionally dependent), choose a desired angular
frequency ωₙ &gt; 0 (in rad/s) and estimate <code class="docutils literal notranslate"><span class="pre">k₀</span> <span class="pre">=</span> <span class="pre">I₀</span> <span class="pre">ωₙ²</span></code> (units of
N*m/rad).</p>
<p>The estimate of damping d₀ depends on whether you are modeling a
physical bushing (consider damping method 1 below) or whether you are
using a bushing to enforce a constraint (consider damping methods 2 or
3 below). 1. Use experiments to estimate a damping ratio ζ and
settling time tₛ. Compute “undamped natural frequency” ωₙ from ζ and
tₛ (as shown below in the Advanced section), then <code class="docutils literal notranslate"><span class="pre">d₀</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">ζ</span> <span class="pre">k₀</span> <span class="pre">/</span> <span class="pre">ωₙ</span></code>
(units of N*m*s/rad). 2. Choose a damping ratio ζ (e.g., ζ = 1,
critical damping) and a desired settling time tₛ, calculate ωₙ (as
shown below in the Advanced section), then <code class="docutils literal notranslate"><span class="pre">d₀</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">ζ</span> <span class="pre">k₀</span> <span class="pre">/</span> <span class="pre">ωₙ</span></code> (units
of N*m*s/rad). 3. Choose a damping ratio ζ (e.g., ζ = 1, critical
damping), estimate a characteristic moment of inertia and calculate
<code class="docutils literal notranslate"><span class="pre">d₀</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">ζ</span> <span class="pre">√(I₀</span> <span class="pre">k₀)</span></code>.</p>
<p>Refer to Advanced_bushing_stiffness_and_damping “Advanced bushing
stiffness and damping” for more details.</p>
<p><a href="#id29"><span class="problematic" id="id30">**</span></a>** How to choose a force stiffness constant kx or damping constant
dx. The estimate of stiffness kx depends on whether you are modeling a
real bushing (consider stiffness methods 1 or 2 below) or whether you
are using a bushing to replace an ideal joint such as a revolute or
fixed/weld joint (consider stiffness “penalty methods” 3 or 4 below).
1. Use a static experiment, e.g., apply a known force load Fx, measure
the associated displacement (stretch) Δx (in meters), and estimate kx
= Fx / Δx. 2. Use FEA (finite element analysis) software to estimate
kx (units of N/m). 3. Pick a desired maximum displacement xₘₐₓ,
estimate a maximum force load Fxₘₐₓ, and estimate <code class="docutils literal notranslate"><span class="pre">kx</span> <span class="pre">=</span> <span class="pre">Fxₘₐₓ</span> <span class="pre">/</span>
<span class="pre">xₘₐₓ</span></code> (units of N/m). 4. Choose a characteristic mass m (which may be
directionally dependent), choose a desired angular frequency ωₙ &gt; 0
(in rad/s) and estimate <code class="docutils literal notranslate"><span class="pre">kx</span> <span class="pre">=</span> <span class="pre">m</span> <span class="pre">ωₙ²</span></code> (units of N/m).</p>
<p>The estimate of damping dx depends on whether you are modeling a
physical bushing (consider damping method 1 below) or whether you are
using a bushing to enforce a constraint (consider damping methods 2 or
3 below). 1. Use experiments to estimate a damping ratio ζ and
settling time tₛ. Compute “undamped natural frequency” ωₙ from ζ and
tₛ (as shown below in the Advanced section), then <code class="docutils literal notranslate"><span class="pre">dx</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">ζ</span> <span class="pre">kx</span> <span class="pre">/</span> <span class="pre">ωₙ</span></code>
(units of N*s/m). 2. Choose a damping ratio ζ (e.g., ζ = 1, critical
damping) and a desired settling time tₛ, calculate ωₙ (as shown below
in the Advanced section), then <code class="docutils literal notranslate"><span class="pre">dx</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">ζ</span> <span class="pre">kx</span> <span class="pre">/</span> <span class="pre">ωₙ</span></code> (units of N*s/m).
3. Choose a damping ratio ζ (e.g., ζ = 1, critical damping), estimate
a characteristic mass m and calculate <code class="docutils literal notranslate"><span class="pre">dx</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">ζ</span> <span class="pre">√(m</span> <span class="pre">kx)</span></code> (units of
N*s/m).</p>
<p>Refer to Advanced_bushing_stiffness_and_damping “Advanced bushing
stiffness and damping” for more details.</p>
<p><a href="#id31"><span class="problematic" id="id32">**</span></a>** Advanced: Relationship of 𝐭 to τ. To understand how “gimbal
torques” τ relate to 𝐭, it helps to remember that the RollPitchYaw
class documentation states that a Space-fixed (extrinsic) X-Y-Z
rotation with roll-pitch-yaw angles [q₀ q₁ q₂] is equivalent to a
Body-fixed (intrinsic) Z-Y-X rotation by yaw-pitch-roll angles [q₂ q₁
q₀]. In the context of “gimbal torques”, the Body-fixed Z-Y-X rotation
sequence with angles [q₂ q₁ q₀] is physical meaningful as it produces
torques associated with successive frames in a gimbal as τ₂ 𝐀𝐳, τ₁ 𝐏𝐲,
τ₀ 𝐂𝐱, where each of 𝐀𝐳, 𝐏𝐲, 𝐂𝐱 are unit vectors associated with a
frame in the yaw-pitch-roll rotation sequence and 𝐏𝐲 is a unit vector
of the “pitch” intermediate frame. As described earlier, torque 𝐭 is
the moment of the bushing forces on frame C about Cp. Scalars tx, ty,
tz are defined so 𝐭 can be expressed <code class="docutils literal notranslate"><span class="pre">𝐭</span> <span class="pre">=</span> <span class="pre">[tx</span> <span class="pre">ty</span> <span class="pre">tz]ᴀ</span> <span class="pre">=</span> <span class="pre">tx</span> <span class="pre">𝐀𝐱</span> <span class="pre">+</span> <span class="pre">ty</span> <span class="pre">𝐀𝐲</span>
<span class="pre">+</span> <span class="pre">tz</span> <span class="pre">𝐀𝐳</span></code>. As shown in code documentation, the relationship of [tx ty
tz] to [τ₀ τ₁ τ₂] was found by equating 𝐭’s power to τ’s power as 𝐭 ⋅
w_AC = τ ⋅ q̇.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="err">⌈</span><span class="w"> </span><span class="n">tx</span><span class="w"> </span><span class="err">⌉</span><span class="w">      </span><span class="err">⌈</span><span class="w"> </span><span class="n">τ₀</span><span class="w"> </span><span class="err">⌉</span><span class="w">            </span><span class="err">⌈</span><span class="w"> </span><span class="n">cos</span><span class="p">(</span><span class="n">q₂</span><span class="p">)</span><span class="o">/</span><span class="n">cos</span><span class="p">(</span><span class="n">q₁</span><span class="p">)</span><span class="w">  </span><span class="n">sin</span><span class="p">(</span><span class="n">q₂</span><span class="p">)</span><span class="o">/</span><span class="n">cos</span><span class="p">(</span><span class="n">q₁</span><span class="p">)</span><span class="w">   </span><span class="mi">0</span><span class="w"> </span><span class="err">⌉</span>
<span class="o">|</span><span class="w"> </span><span class="n">ty</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Nᵀ</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">τ₁</span><span class="w"> </span><span class="o">|</span><span class="w">  </span><span class="n">where</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="w">   </span><span class="err">−</span><span class="n">sin</span><span class="p">(</span><span class="n">q2</span><span class="p">)</span><span class="w">            </span><span class="n">cos</span><span class="p">(</span><span class="n">q2</span><span class="p">)</span><span class="w">      </span><span class="mi">0</span><span class="w"> </span><span class="o">|</span>
<span class="err">⌊</span><span class="w"> </span><span class="n">tz</span><span class="w"> </span><span class="err">⌋</span><span class="w">      </span><span class="err">⌊</span><span class="w"> </span><span class="n">τ₂</span><span class="w"> </span><span class="err">⌋</span><span class="w">            </span><span class="err">⌊</span><span class="w"> </span><span class="n">cos</span><span class="p">(</span><span class="n">q₂</span><span class="p">)</span><span class="o">*</span><span class="n">tan</span><span class="p">(</span><span class="n">q₁</span><span class="p">)</span><span class="w">   </span><span class="n">sin</span><span class="p">(</span><span class="n">q₂</span><span class="p">)</span><span class="o">*</span><span class="n">tan</span><span class="p">(</span><span class="n">q₁</span><span class="p">)</span><span class="w">  </span><span class="mi">1</span><span class="w"> </span><span class="err">⌋</span>
</pre></div>
</div>
</details><p><a href="#id33"><span class="problematic" id="id34">**</span></a>** Advanced: More on how to choose bushing stiffness and damping
constants. The basics on how to choose bushing stiffness and damping
constants are at: - Basic_bushing_torque_stiffness_and_damping “How to
choose torque stiffness and damping constants” -
Basic_bushing_force_stiffness_and_damping “How to choose force
stiffness and damping constants”</p>
<p>The list below provides more detail on: The performance tradeoff
between high stiffness and long simulation time; loads that affect
estimates of Mxₘₐₓ or Fxₘₐₓ; and how a linear 2ⁿᵈ-order ODE provides
insight on how to experimentally determine stiffness and damping
constants. - Stiffness [k₀ k₁ k₂] and [kx ky kz] affect simulation
time and accuracy. Generally, a stiffer bushing better resembles an
ideal joint (e.g., a revolute joint or fixed/weld joint). However
(depending on integrator), a stiffer bushing usually increases
numerical integration time. - An estimate for a maximum load Mxₘₐₓ or
Fxₘₐₓ accounts for gravity forces, applied forces, inertia forces
(centripetal, Coriolis, gyroscopic), etc. - One way to determine
physical stiffness and damping constants is through the mathematical
intermediaries ωₙ (units of rad/s) and ζ (no units). The constant ωₙ
(called “undamped natural frequency” or “angular frequency”) and
constant ζ (called “damping ratio”) relate to the physical constants
mass m, damping constant dx, and stiffness constant kx via the
following prototypical linear constant-coefficient 2ⁿᵈ-order ODEs.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">m</span><span class="w"> </span><span class="n">x</span><span class="err">̈</span><span class="w"> </span><span class="o">+</span><span class="w">     </span><span class="n">dx</span><span class="w"> </span><span class="n">x</span><span class="err">̇</span><span class="w"> </span><span class="o">+</span><span class="w">  </span><span class="n">kx</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w">   </span><span class="k">or</span><span class="w"> </span><span class="n">alternatively</span><span class="w"> </span><span class="n">as</span>
<span class="w">   </span><span class="n">x</span><span class="err">̈</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">ζ</span><span class="w"> </span><span class="n">ωₙ</span><span class="w"> </span><span class="n">x</span><span class="err">̇</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ωₙ²</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w">   </span><span class="n">where</span><span class="w"> </span><span class="n">ωₙ²</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kx</span><span class="o">/</span><span class="n">m</span><span class="p">,</span><span class="w">  </span><span class="n">ζ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dx</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="err">√</span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="n">kx</span><span class="p">))</span>
</pre></div>
</div>
</details><p>ωₙ and ζ also appear in the related ODEs for rotational systems,
namely</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">I₀</span><span class="w"> </span><span class="n">q</span><span class="err">̈</span><span class="w"> </span><span class="o">+</span><span class="w">     </span><span class="n">d₀</span><span class="w"> </span><span class="n">q</span><span class="err">̇</span><span class="w"> </span><span class="o">+</span><span class="w">  </span><span class="n">k₀</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w">   </span><span class="k">or</span><span class="w"> </span><span class="n">alternatively</span><span class="w"> </span><span class="n">as</span>
<span class="w">    </span><span class="n">q</span><span class="err">̈</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">ζ</span><span class="w"> </span><span class="n">ωₙ</span><span class="w"> </span><span class="n">q</span><span class="err">̇</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ωₙ²</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w">   </span><span class="n">where</span><span class="w"> </span><span class="n">ωₙ²</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k₀</span><span class="o">/</span><span class="n">I₀</span><span class="p">,</span><span class="w">  </span><span class="n">ζ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d₀</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="err">√</span><span class="p">(</span><span class="n">I₀</span><span class="w"> </span><span class="n">k₀</span><span class="p">))</span>
</pre></div>
</div>
</details><p>One way to determine ωₙ is from settling time tₛ which approximates
the time for a system to settle to within a specified settling ratio
of an equilibrium solutions. Typical values for settling ratio are 1%
(0.01), 2% (0.02), 5% (0.05), and 10% (0.10). - When ζ &lt; 0.7
(underdamped), a commonly used approximation is ωₙ ≈
-ln(settling_ratio) / (ζ tₛ) which for settling ratios 0.01 and 0.05
give ωₙ ≈ 4.6 / (ζ tₛ) and ωₙ ≈ 3 / (ζ tₛ). Another commonly used
approximation is ωₙ ≈ -ln(settling_ratio √(1- ζ²)) / (ζ tₛ). See
<a class="reference external" href="https://en.wikipedia.org/wiki/Settling_time">https://en.wikipedia.org/wiki/Settling_time</a> or the book Modern Control
Engineering by Katsuhiko Ogata. Although these approximate formulas
for ωₙ are common, they are somewhat inaccurate. Settling time for
underdamped systems is discontinuous and requires solving a nonlinear
algebraic equation (an iterative process). For more information, see
<a class="reference external" href="http://www.scielo.org.co/pdf/rfiua/n66/n66a09.pdf">http://www.scielo.org.co/pdf/rfiua/n66/n66a09.pdf</a> [Ramos-Paja, et. al
2012], “Accurate calculation of settling time in second order systems:
a photovoltaic application”. Another reference is
<a class="reference external" href="https://courses.grainger.illinois.edu/ece486/sp2020/laboratory/docs/lab2/estimates.html">https://courses.grainger.illinois.edu/ece486/sp2020/laboratory/docs/lab2/estimates.html</a>
- When ζ ≈ 1 (critically damped), ωₙ is determined by choosing a
settling ratio and then solving for (ωₙ tₛ) via the nonlinear
algebraic equation (1 + ωₙ tₛ)*exp(-ωₙ tₛ) = settling_ratio. Settling
ratio | ωₙ ————– | ————- 0.01 | 6.64 / tₛ 0.02 | 5.83
/ tₛ 0.05 | 4.74 / tₛ 0.10 | 3.89 / tₛ See
<a class="reference external" href="https://electronics.stackexchange.com/questions/296567/over-and-critically-damped-systems-settling-time">https://electronics.stackexchange.com/questions/296567/over-and-critically-damped-systems-settling-time</a>
- When ζ ≥ 1.01 (overdamped), ωₙ ≈ -ln(2 settling_ratio sz/s₂) / (s₁
tₛ) where sz = √(ζ² - 1), s₁ = ζ - sz, s₂ = ζ + sz. The derivation and
approximation error estimates for this overdamped settling time
formula is ApproximateOverdampedSettlingTime “below”.</p>
<ul class="simple">
<li><p>For a real physical bushing, an experiment is one way to estimate damping</p></li>
</ul>
<p>constants.  For example, to estimate a torque damping constant d₀ associated
with underdamped vibrations (damping ratio 0 &lt; ζ &lt; 1), attach the bushing to
a massive rod, initially displace the rod by angle Δq, release the rod and
measure q(t).  From the q(t) measurement, estimate decay ratio (the ratio of
successive peak heights above the final steady-state value) calculate
logarithmic decrement δ = -ln(decay_ratio), calculate damping ratio
ζ = √(δ² / (4π² + δ²)), then calculate d₀ using d₀ = 2 ζ √(I₀ k₀) or
d₀ = 2 ζ k₀ / ωₙ. For more information, see
<a class="reference external" href="https://en.wikipedia.org/wiki/Damping_ratio#Logarithmic_decrement">https://en.wikipedia.org/wiki/Damping_ratio#Logarithmic_decrement</a></p>
<p><a href="#id35"><span class="problematic" id="id36">**</span></a>** Derivation: Approximate formula for overdamped settling time.
Since a literature reference for this formula was not found, the
derivation below was done at TRI (it has not been peer reviewed). This
formula results from the “dominant pole” solution in the prototypical
constant-coefficient linear 2ⁿᵈ-order ODE. For ẋ(0) = 0, mathematics
shows poles p₁ = -ωₙ s₁, p₂ = -ωₙ s₂, where sz = √(ζ² - 1), s₁ = ζ -
sz, s₂ = ζ + sz. and</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p₂</span><span class="o">/</span><span class="p">(</span><span class="n">p₂</span><span class="o">-</span><span class="n">p₁</span><span class="p">)</span><span class="w"> </span><span class="n">exp</span><span class="p">(</span><span class="n">p₁</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">p₁</span><span class="o">/</span><span class="p">(</span><span class="n">p₂</span><span class="o">-</span><span class="n">p₁</span><span class="p">)</span><span class="w"> </span><span class="n">exp</span><span class="p">(</span><span class="n">p₂</span><span class="w"> </span><span class="n">t</span><span class="p">)</span>
<span class="w">             </span><span class="o">=</span><span class="w"> </span><span class="n">s₂</span><span class="o">/</span><span class="p">(</span><span class="n">s₂</span><span class="o">-</span><span class="n">s₁</span><span class="p">)</span><span class="w"> </span><span class="n">exp</span><span class="p">(</span><span class="n">p₁</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">s₁</span><span class="o">/</span><span class="p">(</span><span class="n">s₂</span><span class="o">-</span><span class="n">s₁</span><span class="p">)</span><span class="w"> </span><span class="n">exp</span><span class="p">(</span><span class="n">p₂</span><span class="w"> </span><span class="n">t</span><span class="p">)</span>
<span class="w">             </span><span class="o">=</span><span class="w">  </span><span class="n">k</span><span class="o">/</span><span class="p">(</span><span class="w"> </span><span class="n">k</span><span class="mi">-1</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">exp</span><span class="p">(</span><span class="n">p₁</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w">  </span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="w"> </span><span class="n">k</span><span class="mi">-1</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">exp</span><span class="p">(</span><span class="n">p₂</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="n">where</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s₂</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">s₁</span>
<span class="w">             </span><span class="err">≈</span><span class="w">  </span><span class="n">k</span><span class="o">/</span><span class="p">(</span><span class="w"> </span><span class="n">k</span><span class="mi">-1</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">exp</span><span class="p">(</span><span class="n">p₁</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w">                        </span><span class="n">since</span><span class="w"> </span><span class="n">p₁</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">p₂</span>
</pre></div>
</div>
</details><p>Note: k = s₂ / s₁ is real, k &gt; 0, s₂ = k s₁, and p₁ &gt; p₂ (p₁ is less
negative then p₂), so exp(p₁ t) decays to zero slower than exp(p₂ t)
and exp(p₁ t) ≫ exp(p₂ t) for sufficiently large t. Hence we assume
exp(p₂ t) ≈ 0 (which is why p₁ is called the “dominant pole”). Next,</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">k</span><span class="o">/</span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s₂</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">s₁</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">s₂</span><span class="o">/</span><span class="n">s₁</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s₂</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">s₂</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">s₁</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s₂</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="n">sz</span><span class="p">),</span><span class="w">  </span><span class="n">so</span>
<span class="w">  </span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w">  </span><span class="err">≈</span><span class="w">  </span><span class="n">s₂</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="n">sz</span><span class="p">)</span><span class="w"> </span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">s₁</span><span class="w"> </span><span class="n">ωₙ</span><span class="w"> </span><span class="n">t</span><span class="p">),</span><span class="w">                        </span><span class="n">hence</span>
<span class="w">  </span><span class="n">settling_ratio</span><span class="w"> </span><span class="err">≈</span><span class="w"> </span><span class="n">s₂</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="n">sz</span><span class="p">)</span><span class="w"> </span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">s₁</span><span class="w"> </span><span class="n">ωₙ</span><span class="w"> </span><span class="n">tₛ</span><span class="p">),</span><span class="w">                      </span><span class="n">finally</span>
<span class="w">  </span><span class="n">ωₙ</span><span class="w"> </span><span class="err">≈</span><span class="w"> </span><span class="o">-</span><span class="n">ln</span><span class="p">(</span><span class="n">settling_ratio</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">sz</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">s₂</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">s₁</span><span class="w"> </span><span class="n">tₛ</span><span class="p">)</span>
</pre></div>
</div>
</details><p>The table below shows that there is little error in this approximate
formula for various settling ratios and ζ, particularly for ζ ≥ 1.1.
For 1.0 ≤ ζ &lt; 1.1, the critical damping estimates of ωₙ work well.
Settling ratio | ζ = 1.01 | ζ = 1.1 | ζ = 1.2 | ζ = 1.3 | ζ = 1.5
————– | ——– | ——- | ——- | ——- | ——–
0.01 | 1.98% | 0.005% | 2.9E-5% | 1.6E-7% | 2.4E-12% 0.02 | 2.91% |
0.016% | 1.8E-4% | 2.1E-6% | 1.6E-10% 0.05 | 5.10% | 0.076% | 2.3E-3%
| 7.0E-5% | 4.4E-8% 0.10 | 8.28% | 0.258% | 1.6E-2% | 1.0E-3% |
3.3E-6% Note: There is a related derivation in the reference below,
however, it needlessly makes the oversimplified approximation k/(k -
1) ≈ 1.
<a class="reference external" href="https://electronics.stackexchange.com/questions/296567/over-and-critically-damped-systems-settling-time">https://electronics.stackexchange.com/questions/296567/over-and-critically-damped-systems-settling-time</a></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The complete theory for this bushing is documented in the source
code. Please look there if you want more information.</p>
</div>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">T</span></code>:</dt><dd><p>The underlying scalar type. Must be a valid Eigen scalar.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>math::RollPitchYaw for definitions of roll, pitch, yaw <code class="docutils literal notranslate"><span class="pre">[q₀</span> <span class="pre">q₁</span>
<span class="pre">q₂]</span></code>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Per issue #12982, do not directly or indirectly call the following
methods as they have not yet been implemented and throw an
exception: CalcPotentialEnergy(), CalcConservativePower(),
CalcNonConservativePower().</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd],</span> <span class="pre">frameA:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">frameC:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">torque_stiffness_constants:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">torque_damping_constants:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">force_stiffness_constants:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">force_damping_constants:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Construct a LinearBushingRollPitchYaw B that connects frames A and C,
where frame A is welded to a link L0 and frame C is welded to a link
L1.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameA</span></code>:</dt><dd><p>frame A of link (body) L0 that connects to bushing B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameC</span></code>:</dt><dd><p>frame C of link (body) L1 that connects to bushing B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">torque_stiffness_constants</span></code>:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> multiply the roll-pitch-yaw angles <code class="docutils literal notranslate"><span class="pre">[q₀</span> <span class="pre">q₁</span> <span class="pre">q₂]</span></code>
to produce the spring portion of the “gimbal” torques τ₀, τ₁, τ₂.
The SI units of <code class="docutils literal notranslate"><span class="pre">k₀,</span> <span class="pre">k₁,</span> <span class="pre">k₂</span></code> are N*m/rad.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">torque_damping_constants</span></code>:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">d₂]</span></code> multiply the roll-pitch-yaw rates <code class="docutils literal notranslate"><span class="pre">[q̇₀</span> <span class="pre">q̇₁</span> <span class="pre">q̇₂]</span></code>
to produce the damper portion of the “gimbal” torques τ₀, τ₁, τ₂.
The SI units of <code class="docutils literal notranslate"><span class="pre">d₀,</span> <span class="pre">d₁,</span> <span class="pre">d₂</span></code> are N*m*s/rad.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">force_stiffness_constants</span></code>:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> multiply the bushing displacements <code class="docutils literal notranslate"><span class="pre">[x</span> <span class="pre">y</span> <span class="pre">z]</span></code> to
form 𝐟ᴋ, the spring portion of the force 𝐟 = [fx fy fz]ʙ. The SI
units of <code class="docutils literal notranslate"><span class="pre">kx,</span> <span class="pre">ky,</span> <span class="pre">kz</span></code> are N/m.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">force_damping_constants</span></code>:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code> multiply the bushing displacement rates <code class="docutils literal notranslate"><span class="pre">[ẋ</span> <span class="pre">ẏ</span>
<span class="pre">ż]</span></code> to form 𝐟ᴅ, the damper portion of the force 𝐟 = [fx fy fz]ʙ.
The SI units of <code class="docutils literal notranslate"><span class="pre">dx,</span> <span class="pre">dy,</span> <span class="pre">dz</span></code> are N*s/m.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The LinearBushingRollPitchYaw class documentation describes the
stiffness and damping constants.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The net moment on C about Co is affected by both the gimbal torque
and the moment of 𝐟 about Co. Similarly, for the net moment on A
about Ao.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>math::RollPitchYaw describes the roll pitch yaw angles q₀, q₁, q₂.
The position from Ao to Co is p_AoCo_B = x 𝐁𝐱 + y 𝐁𝐲 + z 𝐁𝐳 = [x y
z]ʙ.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The ModelInstanceIndex assigned to this by the constructor is the
one assigned to frame C, i.e., frameC.model_instance().</p>
</div>
<dl class="simple">
<dt>Precondition:</dt><dd><p>All the stiffness and damping constants must be non-negative.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw_[AutoDiffXd].CalcBushingSpatialForceOnFrameA(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.math.SpatialForce_[AutoDiffXd]</span></span></dt>
<dd><p>Calculate F_A_A, the bushing’s spatial force on frame A expressed in
A. F_A_A contains two vectors: the moment of all bushing forces on A
about Ao (−𝐭 + p_AoAp × −𝐟) and the net bushing force on A (−𝐟
expressed in A).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcBushingSpatialForceOnFrameC().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if pitch angle is near gimbal-lock. For more info</strong><strong>,</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RollPitchYaw::DoesCosPitchAngleViolateGimbalLockTolerance().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw_[AutoDiffXd].CalcBushingSpatialForceOnFrameC(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.math.SpatialForce_[AutoDiffXd]</span></span></dt>
<dd><p>Calculate F_C_C, the bushing’s spatial force on frame C expressed in
C. F_C_C contains two vectors: the moment of all bushing forces on C
about Co (𝐭 + p_CoCp × 𝐟) and the resultant bushing force on C (𝐟
expressed in C).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcBushingSpatialForceOnFrameA().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if pitch angle is near gimbal-lock. For more info</strong><strong>,</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RollPitchYaw::DoesCosPitchAngleViolateGimbalLockTolerance().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw_[AutoDiffXd].force_damping_constants(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the default force damping constants <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code> (units of
N*s/m). Refer to Basic_bushing_force_stiffness_and_damping “How to
choose force stiffness and damping constants” for more details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw_[AutoDiffXd].force_stiffness_constants(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the default force stiffness constants <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> (units of
N/m). Refer to Basic_bushing_force_stiffness_and_damping “How to
choose force stiffness and damping constants” for more details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw_[AutoDiffXd].frameA(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd]</span></span></dt>
<dd><p>Returns frame A, which is the frame that is welded to link (body) L0
and attached to the bushing.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw_[AutoDiffXd].frameC(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd]</span></span></dt>
<dd><p>Returns frame C, which is the frame that is welded to link (body) L1
and attached to the bushing.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw_[AutoDiffXd].GetForceDampingConstants(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the force damping constants <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code> (units of N*s/m)
stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw_[AutoDiffXd].GetForceStiffnessConstants(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the force stiffness constants <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> (units of N/m)
stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw_[AutoDiffXd].GetTorqueDampingConstants(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the torque damping constants <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">d₂]</span></code> (units of
N*m*s/rad) stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw_[AutoDiffXd].GetTorqueStiffnessConstants(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the torque stiffness constants <code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> (units of
N*m/rad) stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw_[AutoDiffXd].link0(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RigidBody_[AutoDiffXd]</span></span></dt>
<dd><p>Returns link (body) L0 (frame A is welded to link L0).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw_[AutoDiffXd].link1(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RigidBody_[AutoDiffXd]</span></span></dt>
<dd><p>Returns link (body) L1 (frame C is welded to link L1).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw_[AutoDiffXd].SetForceDampingConstants(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">force_damping:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the force damping constants <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code> (units of N*s/m) in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw_[AutoDiffXd].SetForceStiffnessConstants(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">force_stiffness:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the force stiffness constants <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> (units of N/m) in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw_[AutoDiffXd].SetTorqueDampingConstants(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">torque_damping:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the torque damping constants <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">d₂]</span></code> (units of N*m*s/rad)
in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw_[AutoDiffXd].SetTorqueStiffnessConstants(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">torque_stiffness:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the torque stiffness constants <code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> (units of N*m/rad)
in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw_[AutoDiffXd].torque_damping_constants(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the default torque damping constants <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">d₂]</span></code> (units of
N*m*s/rad). Refer to Basic_bushing_torque_stiffness_and_damping “How
to choose torque stiffness and damping constants” for more details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw_[AutoDiffXd].torque_stiffness_constants(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the default torque stiffness constants <code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> (units
of N*m/rad). Refer to Basic_bushing_torque_stiffness_and_damping “How
to choose torque stiffness and damping constants” for more details.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ForceElement_[Expression]</span></code></p>
<p>This ForceElement models a massless flexible bushing that connects a
frame A of a link (body) L0 to a frame C of a link (body) L1. The
bushing can apply a torque and force due to stiffness (spring) and
dissipation (damper) properties. Frame B is the bushing frame whose
origin Bo is halfway between Ao (A’s origin) and Co (C’s origin) and
whose unit vectors 𝐁𝐱, 𝐁𝐲, 𝐁𝐳 are “halfway” (in an angle-axis sense)
between the unit vectors of frame A and frame C. Frame B is a
“floating” frame in the sense that it is calculated from the position
and orientation of frames A and C (B is not welded to the bushing).</p>
<p>&#64;image html drake/multibody/tree/images/LinearBushingRollPitchYaw.png
width=80%</p>
<p>The set of forces on frame C from the bushing is equivalent to a
torque 𝐭 on frame C and a force 𝐟 applied to a point Cp of C. The set
of forces on frame A from the bushing is equivalent to a torque −𝐭 on
frame A and a force −𝐟 applied to a point Ap of A. Points Ap and Cp
are coincident with Bo (frame B’s origin).</p>
<p>This “quasi-symmetric” bushing force/torque model was developed at
Toyota Research Institute and has advantages compared to traditional
bushing models because it employs a bushing-centered “symmetric” frame
B and it ensures the moment of −𝐟 on A about Ao is equal to the moment
of 𝐟 on C about Co. Traditional models differ as they lack a
“symmetric” frame B and apply −𝐟 at Ao, which means the moment of −𝐟
on A about Ao is always zero. Note: This bushing model is not fully
symmetric since the orientation between frames A and C is
parameterized with roll-pitch-yaw angles [q₀ q₁ q₂]. Since these
angles have an inherent sequence, they are not mathematically
symmetric.</p>
<p>The torque model depends on spring-damper “gimbal” torques <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">≜</span> <span class="pre">[τ₀</span>
<span class="pre">τ₁</span> <span class="pre">τ₂]</span></code> which themselves depend on roll-pitch-yaw angles <code class="docutils literal notranslate"><span class="pre">q</span> <span class="pre">≜</span> <span class="pre">[q₀</span> <span class="pre">q₁</span>
<span class="pre">q₂]</span></code> and rates <code class="docutils literal notranslate"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">[q̇₀</span> <span class="pre">q̇₁</span> <span class="pre">q̇₂]</span></code> via a diagonal torque-stiffness
matrix K₀₁₂ and a diagonal torque-damping matrix D₀₁₂ as</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="err">⌈</span><span class="w"> </span><span class="n">τ₀</span><span class="w"> </span><span class="err">⌉</span><span class="w">     </span><span class="err">⌈</span><span class="n">k₀</span><span class="w">    </span><span class="mi">0</span><span class="w">    </span><span class="mi">0</span><span class="err">⌉</span><span class="w"> </span><span class="err">⌈</span><span class="w"> </span><span class="n">q₀</span><span class="w"> </span><span class="err">⌉</span><span class="w">     </span><span class="err">⌈</span><span class="n">d₀</span><span class="w">    </span><span class="mi">0</span><span class="w">    </span><span class="mi">0</span><span class="err">⌉</span><span class="w"> </span><span class="err">⌈</span><span class="w"> </span><span class="n">q</span><span class="err">̇</span><span class="n">₀</span><span class="w"> </span><span class="err">⌉</span>
<span class="n">τ</span><span class="w"> </span><span class="err">≜</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">τ₁</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">−</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">0</span><span class="w">   </span><span class="n">k₁</span><span class="w">    </span><span class="mi">0</span><span class="o">|</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">q₁</span><span class="w"> </span><span class="o">|</span><span class="w">  </span><span class="err">−</span><span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="mi">0</span><span class="w">   </span><span class="n">d₁</span><span class="w">    </span><span class="mi">0</span><span class="o">|</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">q</span><span class="err">̇</span><span class="n">₁</span><span class="w"> </span><span class="o">|</span>
<span class="w">    </span><span class="err">⌊</span><span class="w"> </span><span class="n">τ₂</span><span class="w"> </span><span class="err">⌋</span><span class="w">     </span><span class="err">⌊</span><span class="w"> </span><span class="mi">0</span><span class="w">    </span><span class="mi">0</span><span class="w">   </span><span class="n">k₂</span><span class="err">⌋</span><span class="w"> </span><span class="err">⌊</span><span class="w"> </span><span class="n">q₂</span><span class="w"> </span><span class="err">⌋</span><span class="w">     </span><span class="err">⌊</span><span class="w"> </span><span class="mi">0</span><span class="w">    </span><span class="mi">0</span><span class="w">   </span><span class="n">d₂</span><span class="err">⌋</span><span class="w"> </span><span class="err">⌊</span><span class="w"> </span><span class="n">q</span><span class="err">̇</span><span class="n">₂</span><span class="w"> </span><span class="err">⌋</span>
</pre></div>
</div>
</details><p>where k₀, k₁, k₂ and d₀, d₁, d₂ are torque stiffness and damping
constants and must have non-negative values.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>τ does not represent a vector expressed in one frame. Instead it
is regarded as a 3x1 array of torque scalars associated with
roll-pitch yaw.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>As discussed in the Advanced section below, τ is not 𝐭 <code class="docutils literal notranslate"><span class="pre">(τ</span> <span class="pre">≠</span>
<span class="pre">𝐭)</span></code>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is a “linear” bushing model as gimbal torque τ varies
linearly with q and q̇ as τ = τᴋ + τᴅ where τᴋ = −K₀₁₂ ⋅ q and τᴅ
= −D₀₁₂ ⋅ q̇.</p>
</div>
<p>The bushing model for the net force 𝐟 on frame C from the bushing
depends on scalars x, y, z which are defined so 𝐫 (the position vector
from Ao to Co) can be expressed in frame B as <code class="docutils literal notranslate"><span class="pre">𝐫</span> <span class="pre">≜</span> <span class="pre">p_AoCo</span> <span class="pre">=</span> <span class="pre">[x</span> <span class="pre">y</span> <span class="pre">z]ʙ</span>
<span class="pre">=</span> <span class="pre">x</span> <span class="pre">𝐁𝐱</span> <span class="pre">+</span> <span class="pre">y</span> <span class="pre">𝐁𝐲</span> <span class="pre">+</span> <span class="pre">z</span> <span class="pre">𝐁𝐳</span></code>. The model for 𝐟 uses a diagonal
force-stiffness matrix Kxyᴢ, a diagonal force-damping matrix Dxyᴢ, and
defines fx, fy, fz so <code class="docutils literal notranslate"><span class="pre">𝐟</span> <span class="pre">=</span> <span class="pre">[fx</span> <span class="pre">fy</span> <span class="pre">fz]ʙ</span></code>.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="err">⌈</span><span class="w"> </span><span class="n">fx</span><span class="w"> </span><span class="err">⌉</span><span class="w">      </span><span class="err">⌈</span><span class="n">kx</span><span class="w">    </span><span class="mi">0</span><span class="w">    </span><span class="mi">0</span><span class="err">⌉</span><span class="w"> </span><span class="err">⌈</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="err">⌉</span><span class="w">     </span><span class="err">⌈</span><span class="n">dx</span><span class="w">    </span><span class="mi">0</span><span class="w">    </span><span class="mi">0</span><span class="err">⌉</span><span class="w"> </span><span class="err">⌈</span><span class="w"> </span><span class="n">x</span><span class="err">̇</span><span class="w"> </span><span class="err">⌉</span>
<span class="o">|</span><span class="w"> </span><span class="n">fy</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="err">−</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">0</span><span class="w">   </span><span class="n">ky</span><span class="w">    </span><span class="mi">0</span><span class="o">|</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">|</span><span class="w">  </span><span class="err">−</span><span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="mi">0</span><span class="w">   </span><span class="n">dy</span><span class="w">    </span><span class="mi">0</span><span class="o">|</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">y</span><span class="err">̇</span><span class="w"> </span><span class="o">|</span>
<span class="err">⌊</span><span class="w"> </span><span class="n">fz</span><span class="w"> </span><span class="err">⌋</span><span class="w">      </span><span class="err">⌊</span><span class="w"> </span><span class="mi">0</span><span class="w">    </span><span class="mi">0</span><span class="w">   </span><span class="n">kz</span><span class="err">⌋</span><span class="w"> </span><span class="err">⌊</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="err">⌋</span><span class="w">     </span><span class="err">⌊</span><span class="w"> </span><span class="mi">0</span><span class="w">    </span><span class="mi">0</span><span class="w">   </span><span class="n">dz</span><span class="err">⌋</span><span class="w"> </span><span class="err">⌊</span><span class="w"> </span><span class="n">z</span><span class="err">̇</span><span class="w"> </span><span class="err">⌋</span>
</pre></div>
</div>
</details><p>where kx, ky, kz and dx, dy, dz are force stiffness and damping
constants and must have non-negative values.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is a “linear” bushing model as the force 𝐟 varies linearly
with 𝐫 and 𝐫̇̇ as 𝐟 = 𝐟ᴋ + 𝐟ᴅ where 𝐟ᴋ = −Kxyz ⋅ 𝐫 and 𝐟ᴅ = −Dxyz
⋅ 𝐫̇̇.</p>
</div>
<p>This bushing’s constructor sets the torque stiffness/damping constants
<code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> and <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">d₂]</span></code> and the force stiffness/damping
constants <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> and <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code>. The examples below
demonstrate how to model various joints that have a flexible (e.g.,
rubber) mount. The damping values below with ? may be set to 0 or a
reasonable positive number.</p>
<p>Bushing type | torque constants | force constants
——————————–<a href="#id51"><span class="problematic" id="id52">|:--------------------|</span></a>:——————
z-axis revolute joint | k₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">0]</span></code> | kxyz = <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> ^
| d₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">?]</span></code> | dxyz = <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code> x-axis prismatic joint
| k₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> | kxyz = <code class="docutils literal notranslate"><span class="pre">[0</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> ^ | d₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span>
<span class="pre">d₂]</span></code> | dxyz = <code class="docutils literal notranslate"><span class="pre">[?</span> <span class="pre">dy</span> <span class="pre">dz]</span></code> Ball and socket joint | k₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[0</span> <span class="pre">0</span>
<span class="pre">0]</span></code> | kxyz = <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> ^ | d₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[?</span> <span class="pre">?</span> <span class="pre">?]</span></code> | dxyz = <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span>
<span class="pre">dz]</span></code> Weld/fixed joint | k₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> | kxyz = <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code>
^ | d₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">d₂]</span></code> | dxyz = <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code></p>
<p>Angles q₀, q₁, q₂ are calculated from frame C’s orientation relative
to frame A, with <code class="docutils literal notranslate"><span class="pre">[−π</span> <span class="pre">&lt;</span> <span class="pre">q₀</span> <span class="pre">≤</span> <span class="pre">π,</span> <span class="pre">−π/2</span> <span class="pre">≤</span> <span class="pre">q₁</span> <span class="pre">≤</span> <span class="pre">π/2,</span> <span class="pre">−π</span> <span class="pre">&lt;</span> <span class="pre">q₂</span> <span class="pre">≤</span> <span class="pre">π]</span></code>,
hence, there is no angle wrapping and torque stiffness has a limited
range. Gimbal torques τ can be discontinuous if one of q₀, q₁, q₂ is
discontinuous and its associated torque spring constant is nonzero.
For example, τ₂ is discontinuous if <code class="docutils literal notranslate"><span class="pre">k₂</span> <span class="pre">≠</span> <span class="pre">0</span></code> and the bushing has a
large rotation so q₂ jumps from <code class="docutils literal notranslate"><span class="pre">≈</span> <span class="pre">−π</span> <span class="pre">to</span> <span class="pre">π</span></code>. τ can also be
discontinuous if one of q̇₀, q̇₁, q̇₂ is discontinuous and its
associated torque damper constant is nonzero. For example, τ₀ is
discontinuous if <code class="docutils literal notranslate"><span class="pre">d₀</span> <span class="pre">≠</span> <span class="pre">0</span></code> and q̇₀ is undefined (which occurs when
<code class="docutils literal notranslate"><span class="pre">pitch</span> <span class="pre">=</span> <span class="pre">q₁</span> <span class="pre">=</span> <span class="pre">π/2</span></code>). Note: Due to the relationship of 𝐭 to τ shown
below, 𝐭 is discontinuous if τ is discontinuous.</p>
<p>As shown below, there are multiple ways to estimate torque and force
stiffness and damping constants. Use a method or combination of
methods appropriate for your application. For example, some methods
are more useful for a real physical bushing whereas other methods
(called “penalty methods”) can be more useful when replacing an ideal
joint (such as a revolute or fixed/weld joint) with a bushing.</p>
<p>Consider a penalty method if you want a bushing to substitute for a
“hard” constraint (e.g., an ideal joint). Since a bushing is
inherently compliant it will violate a hard constraint somewhat. The
stiffer the bushing, the more accurately it enforces the hard
constraint, but at a cost of more computational time. To balance
accuracy versus time, consider your tolerance for constraint errors.
For example, is it OK for your bushing to displace xₘₐₓ = 1 mm for an
estimated Fxₘₐₓ = 100 N? Also, one way to choose a force damping
constant dx is by choosing a “reasonably small” settling time tₛ,
where settling time tₛ is the interval of time for a system to settle
to within 1% (0.01) of an equilibrium solution). Is tₛ = 0.01 s
negligible for a robot arm with a 10 s reach maneuver?</p>
<p><a href="#id37"><span class="problematic" id="id38">**</span></a>** How to choose a torque stiffness constant k₀ or damping constant
d₀. The estimate of stiffness k₀ depends on whether you are modeling a
physical bushing (consider stiffness methods 1 or 2 below) or whether
you are using a bushing to replace an ideal joint such as a revolute
or fixed/weld joint (consider stiffness “penalty methods” 3 or 4
below). 1. Use a static experiment, e.g., apply a known moment load
Mx, measure the associated angular displacement Δq (radians), and
estimate k₀ = Mx / Δq. 2. Use FEA (finite element analysis) software
to estimate k₀. 3. Pick a desired maximum angular displacement qₘₐₓ,
estimate a maximum moment load Mxₘₐₓ, and estimate <code class="docutils literal notranslate"><span class="pre">k₀</span> <span class="pre">=</span> <span class="pre">Mxₘₐₓ</span> <span class="pre">/</span>
<span class="pre">qₘₐₓ</span></code> (units of N*m/rad). 4. Choose a characteristic moment of
inertia I₀ (directionally dependent), choose a desired angular
frequency ωₙ &gt; 0 (in rad/s) and estimate <code class="docutils literal notranslate"><span class="pre">k₀</span> <span class="pre">=</span> <span class="pre">I₀</span> <span class="pre">ωₙ²</span></code> (units of
N*m/rad).</p>
<p>The estimate of damping d₀ depends on whether you are modeling a
physical bushing (consider damping method 1 below) or whether you are
using a bushing to enforce a constraint (consider damping methods 2 or
3 below). 1. Use experiments to estimate a damping ratio ζ and
settling time tₛ. Compute “undamped natural frequency” ωₙ from ζ and
tₛ (as shown below in the Advanced section), then <code class="docutils literal notranslate"><span class="pre">d₀</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">ζ</span> <span class="pre">k₀</span> <span class="pre">/</span> <span class="pre">ωₙ</span></code>
(units of N*m*s/rad). 2. Choose a damping ratio ζ (e.g., ζ = 1,
critical damping) and a desired settling time tₛ, calculate ωₙ (as
shown below in the Advanced section), then <code class="docutils literal notranslate"><span class="pre">d₀</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">ζ</span> <span class="pre">k₀</span> <span class="pre">/</span> <span class="pre">ωₙ</span></code> (units
of N*m*s/rad). 3. Choose a damping ratio ζ (e.g., ζ = 1, critical
damping), estimate a characteristic moment of inertia and calculate
<code class="docutils literal notranslate"><span class="pre">d₀</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">ζ</span> <span class="pre">√(I₀</span> <span class="pre">k₀)</span></code>.</p>
<p>Refer to Advanced_bushing_stiffness_and_damping “Advanced bushing
stiffness and damping” for more details.</p>
<p><a href="#id39"><span class="problematic" id="id40">**</span></a>** How to choose a force stiffness constant kx or damping constant
dx. The estimate of stiffness kx depends on whether you are modeling a
real bushing (consider stiffness methods 1 or 2 below) or whether you
are using a bushing to replace an ideal joint such as a revolute or
fixed/weld joint (consider stiffness “penalty methods” 3 or 4 below).
1. Use a static experiment, e.g., apply a known force load Fx, measure
the associated displacement (stretch) Δx (in meters), and estimate kx
= Fx / Δx. 2. Use FEA (finite element analysis) software to estimate
kx (units of N/m). 3. Pick a desired maximum displacement xₘₐₓ,
estimate a maximum force load Fxₘₐₓ, and estimate <code class="docutils literal notranslate"><span class="pre">kx</span> <span class="pre">=</span> <span class="pre">Fxₘₐₓ</span> <span class="pre">/</span>
<span class="pre">xₘₐₓ</span></code> (units of N/m). 4. Choose a characteristic mass m (which may be
directionally dependent), choose a desired angular frequency ωₙ &gt; 0
(in rad/s) and estimate <code class="docutils literal notranslate"><span class="pre">kx</span> <span class="pre">=</span> <span class="pre">m</span> <span class="pre">ωₙ²</span></code> (units of N/m).</p>
<p>The estimate of damping dx depends on whether you are modeling a
physical bushing (consider damping method 1 below) or whether you are
using a bushing to enforce a constraint (consider damping methods 2 or
3 below). 1. Use experiments to estimate a damping ratio ζ and
settling time tₛ. Compute “undamped natural frequency” ωₙ from ζ and
tₛ (as shown below in the Advanced section), then <code class="docutils literal notranslate"><span class="pre">dx</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">ζ</span> <span class="pre">kx</span> <span class="pre">/</span> <span class="pre">ωₙ</span></code>
(units of N*s/m). 2. Choose a damping ratio ζ (e.g., ζ = 1, critical
damping) and a desired settling time tₛ, calculate ωₙ (as shown below
in the Advanced section), then <code class="docutils literal notranslate"><span class="pre">dx</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">ζ</span> <span class="pre">kx</span> <span class="pre">/</span> <span class="pre">ωₙ</span></code> (units of N*s/m).
3. Choose a damping ratio ζ (e.g., ζ = 1, critical damping), estimate
a characteristic mass m and calculate <code class="docutils literal notranslate"><span class="pre">dx</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">ζ</span> <span class="pre">√(m</span> <span class="pre">kx)</span></code> (units of
N*s/m).</p>
<p>Refer to Advanced_bushing_stiffness_and_damping “Advanced bushing
stiffness and damping” for more details.</p>
<p><a href="#id41"><span class="problematic" id="id42">**</span></a>** Advanced: Relationship of 𝐭 to τ. To understand how “gimbal
torques” τ relate to 𝐭, it helps to remember that the RollPitchYaw
class documentation states that a Space-fixed (extrinsic) X-Y-Z
rotation with roll-pitch-yaw angles [q₀ q₁ q₂] is equivalent to a
Body-fixed (intrinsic) Z-Y-X rotation by yaw-pitch-roll angles [q₂ q₁
q₀]. In the context of “gimbal torques”, the Body-fixed Z-Y-X rotation
sequence with angles [q₂ q₁ q₀] is physical meaningful as it produces
torques associated with successive frames in a gimbal as τ₂ 𝐀𝐳, τ₁ 𝐏𝐲,
τ₀ 𝐂𝐱, where each of 𝐀𝐳, 𝐏𝐲, 𝐂𝐱 are unit vectors associated with a
frame in the yaw-pitch-roll rotation sequence and 𝐏𝐲 is a unit vector
of the “pitch” intermediate frame. As described earlier, torque 𝐭 is
the moment of the bushing forces on frame C about Cp. Scalars tx, ty,
tz are defined so 𝐭 can be expressed <code class="docutils literal notranslate"><span class="pre">𝐭</span> <span class="pre">=</span> <span class="pre">[tx</span> <span class="pre">ty</span> <span class="pre">tz]ᴀ</span> <span class="pre">=</span> <span class="pre">tx</span> <span class="pre">𝐀𝐱</span> <span class="pre">+</span> <span class="pre">ty</span> <span class="pre">𝐀𝐲</span>
<span class="pre">+</span> <span class="pre">tz</span> <span class="pre">𝐀𝐳</span></code>. As shown in code documentation, the relationship of [tx ty
tz] to [τ₀ τ₁ τ₂] was found by equating 𝐭’s power to τ’s power as 𝐭 ⋅
w_AC = τ ⋅ q̇.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="err">⌈</span><span class="w"> </span><span class="n">tx</span><span class="w"> </span><span class="err">⌉</span><span class="w">      </span><span class="err">⌈</span><span class="w"> </span><span class="n">τ₀</span><span class="w"> </span><span class="err">⌉</span><span class="w">            </span><span class="err">⌈</span><span class="w"> </span><span class="n">cos</span><span class="p">(</span><span class="n">q₂</span><span class="p">)</span><span class="o">/</span><span class="n">cos</span><span class="p">(</span><span class="n">q₁</span><span class="p">)</span><span class="w">  </span><span class="n">sin</span><span class="p">(</span><span class="n">q₂</span><span class="p">)</span><span class="o">/</span><span class="n">cos</span><span class="p">(</span><span class="n">q₁</span><span class="p">)</span><span class="w">   </span><span class="mi">0</span><span class="w"> </span><span class="err">⌉</span>
<span class="o">|</span><span class="w"> </span><span class="n">ty</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Nᵀ</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">τ₁</span><span class="w"> </span><span class="o">|</span><span class="w">  </span><span class="n">where</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="w">   </span><span class="err">−</span><span class="n">sin</span><span class="p">(</span><span class="n">q2</span><span class="p">)</span><span class="w">            </span><span class="n">cos</span><span class="p">(</span><span class="n">q2</span><span class="p">)</span><span class="w">      </span><span class="mi">0</span><span class="w"> </span><span class="o">|</span>
<span class="err">⌊</span><span class="w"> </span><span class="n">tz</span><span class="w"> </span><span class="err">⌋</span><span class="w">      </span><span class="err">⌊</span><span class="w"> </span><span class="n">τ₂</span><span class="w"> </span><span class="err">⌋</span><span class="w">            </span><span class="err">⌊</span><span class="w"> </span><span class="n">cos</span><span class="p">(</span><span class="n">q₂</span><span class="p">)</span><span class="o">*</span><span class="n">tan</span><span class="p">(</span><span class="n">q₁</span><span class="p">)</span><span class="w">   </span><span class="n">sin</span><span class="p">(</span><span class="n">q₂</span><span class="p">)</span><span class="o">*</span><span class="n">tan</span><span class="p">(</span><span class="n">q₁</span><span class="p">)</span><span class="w">  </span><span class="mi">1</span><span class="w"> </span><span class="err">⌋</span>
</pre></div>
</div>
</details><p><a href="#id43"><span class="problematic" id="id44">**</span></a>** Advanced: More on how to choose bushing stiffness and damping
constants. The basics on how to choose bushing stiffness and damping
constants are at: - Basic_bushing_torque_stiffness_and_damping “How to
choose torque stiffness and damping constants” -
Basic_bushing_force_stiffness_and_damping “How to choose force
stiffness and damping constants”</p>
<p>The list below provides more detail on: The performance tradeoff
between high stiffness and long simulation time; loads that affect
estimates of Mxₘₐₓ or Fxₘₐₓ; and how a linear 2ⁿᵈ-order ODE provides
insight on how to experimentally determine stiffness and damping
constants. - Stiffness [k₀ k₁ k₂] and [kx ky kz] affect simulation
time and accuracy. Generally, a stiffer bushing better resembles an
ideal joint (e.g., a revolute joint or fixed/weld joint). However
(depending on integrator), a stiffer bushing usually increases
numerical integration time. - An estimate for a maximum load Mxₘₐₓ or
Fxₘₐₓ accounts for gravity forces, applied forces, inertia forces
(centripetal, Coriolis, gyroscopic), etc. - One way to determine
physical stiffness and damping constants is through the mathematical
intermediaries ωₙ (units of rad/s) and ζ (no units). The constant ωₙ
(called “undamped natural frequency” or “angular frequency”) and
constant ζ (called “damping ratio”) relate to the physical constants
mass m, damping constant dx, and stiffness constant kx via the
following prototypical linear constant-coefficient 2ⁿᵈ-order ODEs.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">m</span><span class="w"> </span><span class="n">x</span><span class="err">̈</span><span class="w"> </span><span class="o">+</span><span class="w">     </span><span class="n">dx</span><span class="w"> </span><span class="n">x</span><span class="err">̇</span><span class="w"> </span><span class="o">+</span><span class="w">  </span><span class="n">kx</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w">   </span><span class="k">or</span><span class="w"> </span><span class="n">alternatively</span><span class="w"> </span><span class="n">as</span>
<span class="w">   </span><span class="n">x</span><span class="err">̈</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">ζ</span><span class="w"> </span><span class="n">ωₙ</span><span class="w"> </span><span class="n">x</span><span class="err">̇</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ωₙ²</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w">   </span><span class="n">where</span><span class="w"> </span><span class="n">ωₙ²</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kx</span><span class="o">/</span><span class="n">m</span><span class="p">,</span><span class="w">  </span><span class="n">ζ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dx</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="err">√</span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="n">kx</span><span class="p">))</span>
</pre></div>
</div>
</details><p>ωₙ and ζ also appear in the related ODEs for rotational systems,
namely</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">I₀</span><span class="w"> </span><span class="n">q</span><span class="err">̈</span><span class="w"> </span><span class="o">+</span><span class="w">     </span><span class="n">d₀</span><span class="w"> </span><span class="n">q</span><span class="err">̇</span><span class="w"> </span><span class="o">+</span><span class="w">  </span><span class="n">k₀</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w">   </span><span class="k">or</span><span class="w"> </span><span class="n">alternatively</span><span class="w"> </span><span class="n">as</span>
<span class="w">    </span><span class="n">q</span><span class="err">̈</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">ζ</span><span class="w"> </span><span class="n">ωₙ</span><span class="w"> </span><span class="n">q</span><span class="err">̇</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">ωₙ²</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w">   </span><span class="n">where</span><span class="w"> </span><span class="n">ωₙ²</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">k₀</span><span class="o">/</span><span class="n">I₀</span><span class="p">,</span><span class="w">  </span><span class="n">ζ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d₀</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="err">√</span><span class="p">(</span><span class="n">I₀</span><span class="w"> </span><span class="n">k₀</span><span class="p">))</span>
</pre></div>
</div>
</details><p>One way to determine ωₙ is from settling time tₛ which approximates
the time for a system to settle to within a specified settling ratio
of an equilibrium solutions. Typical values for settling ratio are 1%
(0.01), 2% (0.02), 5% (0.05), and 10% (0.10). - When ζ &lt; 0.7
(underdamped), a commonly used approximation is ωₙ ≈
-ln(settling_ratio) / (ζ tₛ) which for settling ratios 0.01 and 0.05
give ωₙ ≈ 4.6 / (ζ tₛ) and ωₙ ≈ 3 / (ζ tₛ). Another commonly used
approximation is ωₙ ≈ -ln(settling_ratio √(1- ζ²)) / (ζ tₛ). See
<a class="reference external" href="https://en.wikipedia.org/wiki/Settling_time">https://en.wikipedia.org/wiki/Settling_time</a> or the book Modern Control
Engineering by Katsuhiko Ogata. Although these approximate formulas
for ωₙ are common, they are somewhat inaccurate. Settling time for
underdamped systems is discontinuous and requires solving a nonlinear
algebraic equation (an iterative process). For more information, see
<a class="reference external" href="http://www.scielo.org.co/pdf/rfiua/n66/n66a09.pdf">http://www.scielo.org.co/pdf/rfiua/n66/n66a09.pdf</a> [Ramos-Paja, et. al
2012], “Accurate calculation of settling time in second order systems:
a photovoltaic application”. Another reference is
<a class="reference external" href="https://courses.grainger.illinois.edu/ece486/sp2020/laboratory/docs/lab2/estimates.html">https://courses.grainger.illinois.edu/ece486/sp2020/laboratory/docs/lab2/estimates.html</a>
- When ζ ≈ 1 (critically damped), ωₙ is determined by choosing a
settling ratio and then solving for (ωₙ tₛ) via the nonlinear
algebraic equation (1 + ωₙ tₛ)*exp(-ωₙ tₛ) = settling_ratio. Settling
ratio | ωₙ ————– | ————- 0.01 | 6.64 / tₛ 0.02 | 5.83
/ tₛ 0.05 | 4.74 / tₛ 0.10 | 3.89 / tₛ See
<a class="reference external" href="https://electronics.stackexchange.com/questions/296567/over-and-critically-damped-systems-settling-time">https://electronics.stackexchange.com/questions/296567/over-and-critically-damped-systems-settling-time</a>
- When ζ ≥ 1.01 (overdamped), ωₙ ≈ -ln(2 settling_ratio sz/s₂) / (s₁
tₛ) where sz = √(ζ² - 1), s₁ = ζ - sz, s₂ = ζ + sz. The derivation and
approximation error estimates for this overdamped settling time
formula is ApproximateOverdampedSettlingTime “below”.</p>
<ul class="simple">
<li><p>For a real physical bushing, an experiment is one way to estimate damping</p></li>
</ul>
<p>constants.  For example, to estimate a torque damping constant d₀ associated
with underdamped vibrations (damping ratio 0 &lt; ζ &lt; 1), attach the bushing to
a massive rod, initially displace the rod by angle Δq, release the rod and
measure q(t).  From the q(t) measurement, estimate decay ratio (the ratio of
successive peak heights above the final steady-state value) calculate
logarithmic decrement δ = -ln(decay_ratio), calculate damping ratio
ζ = √(δ² / (4π² + δ²)), then calculate d₀ using d₀ = 2 ζ √(I₀ k₀) or
d₀ = 2 ζ k₀ / ωₙ. For more information, see
<a class="reference external" href="https://en.wikipedia.org/wiki/Damping_ratio#Logarithmic_decrement">https://en.wikipedia.org/wiki/Damping_ratio#Logarithmic_decrement</a></p>
<p><a href="#id45"><span class="problematic" id="id46">**</span></a>** Derivation: Approximate formula for overdamped settling time.
Since a literature reference for this formula was not found, the
derivation below was done at TRI (it has not been peer reviewed). This
formula results from the “dominant pole” solution in the prototypical
constant-coefficient linear 2ⁿᵈ-order ODE. For ẋ(0) = 0, mathematics
shows poles p₁ = -ωₙ s₁, p₂ = -ωₙ s₂, where sz = √(ζ² - 1), s₁ = ζ -
sz, s₂ = ζ + sz. and</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p₂</span><span class="o">/</span><span class="p">(</span><span class="n">p₂</span><span class="o">-</span><span class="n">p₁</span><span class="p">)</span><span class="w"> </span><span class="n">exp</span><span class="p">(</span><span class="n">p₁</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">p₁</span><span class="o">/</span><span class="p">(</span><span class="n">p₂</span><span class="o">-</span><span class="n">p₁</span><span class="p">)</span><span class="w"> </span><span class="n">exp</span><span class="p">(</span><span class="n">p₂</span><span class="w"> </span><span class="n">t</span><span class="p">)</span>
<span class="w">             </span><span class="o">=</span><span class="w"> </span><span class="n">s₂</span><span class="o">/</span><span class="p">(</span><span class="n">s₂</span><span class="o">-</span><span class="n">s₁</span><span class="p">)</span><span class="w"> </span><span class="n">exp</span><span class="p">(</span><span class="n">p₁</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">s₁</span><span class="o">/</span><span class="p">(</span><span class="n">s₂</span><span class="o">-</span><span class="n">s₁</span><span class="p">)</span><span class="w"> </span><span class="n">exp</span><span class="p">(</span><span class="n">p₂</span><span class="w"> </span><span class="n">t</span><span class="p">)</span>
<span class="w">             </span><span class="o">=</span><span class="w">  </span><span class="n">k</span><span class="o">/</span><span class="p">(</span><span class="w"> </span><span class="n">k</span><span class="mi">-1</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">exp</span><span class="p">(</span><span class="n">p₁</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w">  </span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="w"> </span><span class="n">k</span><span class="mi">-1</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">exp</span><span class="p">(</span><span class="n">p₂</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="n">where</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s₂</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">s₁</span>
<span class="w">             </span><span class="err">≈</span><span class="w">  </span><span class="n">k</span><span class="o">/</span><span class="p">(</span><span class="w"> </span><span class="n">k</span><span class="mi">-1</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="n">exp</span><span class="p">(</span><span class="n">p₁</span><span class="w"> </span><span class="n">t</span><span class="p">)</span><span class="w">                        </span><span class="n">since</span><span class="w"> </span><span class="n">p₁</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">p₂</span>
</pre></div>
</div>
</details><p>Note: k = s₂ / s₁ is real, k &gt; 0, s₂ = k s₁, and p₁ &gt; p₂ (p₁ is less
negative then p₂), so exp(p₁ t) decays to zero slower than exp(p₂ t)
and exp(p₁ t) ≫ exp(p₂ t) for sufficiently large t. Hence we assume
exp(p₂ t) ≈ 0 (which is why p₁ is called the “dominant pole”). Next,</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">k</span><span class="o">/</span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s₂</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">s₁</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">s₂</span><span class="o">/</span><span class="n">s₁</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s₂</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">s₂</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">s₁</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s₂</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="n">sz</span><span class="p">),</span><span class="w">  </span><span class="n">so</span>
<span class="w">  </span><span class="n">x</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w">  </span><span class="err">≈</span><span class="w">  </span><span class="n">s₂</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="n">sz</span><span class="p">)</span><span class="w"> </span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">s₁</span><span class="w"> </span><span class="n">ωₙ</span><span class="w"> </span><span class="n">t</span><span class="p">),</span><span class="w">                        </span><span class="n">hence</span>
<span class="w">  </span><span class="n">settling_ratio</span><span class="w"> </span><span class="err">≈</span><span class="w"> </span><span class="n">s₂</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="n">sz</span><span class="p">)</span><span class="w"> </span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">s₁</span><span class="w"> </span><span class="n">ωₙ</span><span class="w"> </span><span class="n">tₛ</span><span class="p">),</span><span class="w">                      </span><span class="n">finally</span>
<span class="w">  </span><span class="n">ωₙ</span><span class="w"> </span><span class="err">≈</span><span class="w"> </span><span class="o">-</span><span class="n">ln</span><span class="p">(</span><span class="n">settling_ratio</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">sz</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">s₂</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">s₁</span><span class="w"> </span><span class="n">tₛ</span><span class="p">)</span>
</pre></div>
</div>
</details><p>The table below shows that there is little error in this approximate
formula for various settling ratios and ζ, particularly for ζ ≥ 1.1.
For 1.0 ≤ ζ &lt; 1.1, the critical damping estimates of ωₙ work well.
Settling ratio | ζ = 1.01 | ζ = 1.1 | ζ = 1.2 | ζ = 1.3 | ζ = 1.5
————– | ——– | ——- | ——- | ——- | ——–
0.01 | 1.98% | 0.005% | 2.9E-5% | 1.6E-7% | 2.4E-12% 0.02 | 2.91% |
0.016% | 1.8E-4% | 2.1E-6% | 1.6E-10% 0.05 | 5.10% | 0.076% | 2.3E-3%
| 7.0E-5% | 4.4E-8% 0.10 | 8.28% | 0.258% | 1.6E-2% | 1.0E-3% |
3.3E-6% Note: There is a related derivation in the reference below,
however, it needlessly makes the oversimplified approximation k/(k -
1) ≈ 1.
<a class="reference external" href="https://electronics.stackexchange.com/questions/296567/over-and-critically-damped-systems-settling-time">https://electronics.stackexchange.com/questions/296567/over-and-critically-damped-systems-settling-time</a></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The complete theory for this bushing is documented in the source
code. Please look there if you want more information.</p>
</div>
<dl class="simple">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">T</span></code>:</dt><dd><p>The underlying scalar type. Must be a valid Eigen scalar.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>math::RollPitchYaw for definitions of roll, pitch, yaw <code class="docutils literal notranslate"><span class="pre">[q₀</span> <span class="pre">q₁</span>
<span class="pre">q₂]</span></code>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Per issue #12982, do not directly or indirectly call the following
methods as they have not yet been implemented and throw an
exception: CalcPotentialEnergy(), CalcConservativePower(),
CalcNonConservativePower().</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw_[Expression].__init__(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression],</span> <span class="pre">frameA:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">frameC:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">torque_stiffness_constants:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">torque_damping_constants:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">force_stiffness_constants:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">force_damping_constants:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Construct a LinearBushingRollPitchYaw B that connects frames A and C,
where frame A is welded to a link L0 and frame C is welded to a link
L1.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameA</span></code>:</dt><dd><p>frame A of link (body) L0 that connects to bushing B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameC</span></code>:</dt><dd><p>frame C of link (body) L1 that connects to bushing B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">torque_stiffness_constants</span></code>:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> multiply the roll-pitch-yaw angles <code class="docutils literal notranslate"><span class="pre">[q₀</span> <span class="pre">q₁</span> <span class="pre">q₂]</span></code>
to produce the spring portion of the “gimbal” torques τ₀, τ₁, τ₂.
The SI units of <code class="docutils literal notranslate"><span class="pre">k₀,</span> <span class="pre">k₁,</span> <span class="pre">k₂</span></code> are N*m/rad.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">torque_damping_constants</span></code>:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">d₂]</span></code> multiply the roll-pitch-yaw rates <code class="docutils literal notranslate"><span class="pre">[q̇₀</span> <span class="pre">q̇₁</span> <span class="pre">q̇₂]</span></code>
to produce the damper portion of the “gimbal” torques τ₀, τ₁, τ₂.
The SI units of <code class="docutils literal notranslate"><span class="pre">d₀,</span> <span class="pre">d₁,</span> <span class="pre">d₂</span></code> are N*m*s/rad.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">force_stiffness_constants</span></code>:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> multiply the bushing displacements <code class="docutils literal notranslate"><span class="pre">[x</span> <span class="pre">y</span> <span class="pre">z]</span></code> to
form 𝐟ᴋ, the spring portion of the force 𝐟 = [fx fy fz]ʙ. The SI
units of <code class="docutils literal notranslate"><span class="pre">kx,</span> <span class="pre">ky,</span> <span class="pre">kz</span></code> are N/m.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">force_damping_constants</span></code>:</dt><dd><p><code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code> multiply the bushing displacement rates <code class="docutils literal notranslate"><span class="pre">[ẋ</span> <span class="pre">ẏ</span>
<span class="pre">ż]</span></code> to form 𝐟ᴅ, the damper portion of the force 𝐟 = [fx fy fz]ʙ.
The SI units of <code class="docutils literal notranslate"><span class="pre">dx,</span> <span class="pre">dy,</span> <span class="pre">dz</span></code> are N*s/m.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The LinearBushingRollPitchYaw class documentation describes the
stiffness and damping constants.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The net moment on C about Co is affected by both the gimbal torque
and the moment of 𝐟 about Co. Similarly, for the net moment on A
about Ao.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>math::RollPitchYaw describes the roll pitch yaw angles q₀, q₁, q₂.
The position from Ao to Co is p_AoCo_B = x 𝐁𝐱 + y 𝐁𝐲 + z 𝐁𝐳 = [x y
z]ʙ.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The ModelInstanceIndex assigned to this by the constructor is the
one assigned to frame C, i.e., frameC.model_instance().</p>
</div>
<dl class="simple">
<dt>Precondition:</dt><dd><p>All the stiffness and damping constants must be non-negative.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw_[Expression].CalcBushingSpatialForceOnFrameA(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.math.SpatialForce_[Expression]</span></span></dt>
<dd><p>Calculate F_A_A, the bushing’s spatial force on frame A expressed in
A. F_A_A contains two vectors: the moment of all bushing forces on A
about Ao (−𝐭 + p_AoAp × −𝐟) and the net bushing force on A (−𝐟
expressed in A).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcBushingSpatialForceOnFrameC().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if pitch angle is near gimbal-lock. For more info</strong><strong>,</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RollPitchYaw::DoesCosPitchAngleViolateGimbalLockTolerance().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw_[Expression].CalcBushingSpatialForceOnFrameC(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.math.SpatialForce_[Expression]</span></span></dt>
<dd><p>Calculate F_C_C, the bushing’s spatial force on frame C expressed in
C. F_C_C contains two vectors: the moment of all bushing forces on C
about Co (𝐭 + p_CoCp × 𝐟) and the resultant bushing force on C (𝐟
expressed in C).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The state of the multibody system.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcBushingSpatialForceOnFrameA().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if pitch angle is near gimbal-lock. For more info</strong><strong>,</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RollPitchYaw::DoesCosPitchAngleViolateGimbalLockTolerance().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw_[Expression].force_damping_constants(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the default force damping constants <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code> (units of
N*s/m). Refer to Basic_bushing_force_stiffness_and_damping “How to
choose force stiffness and damping constants” for more details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw_[Expression].force_stiffness_constants(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the default force stiffness constants <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> (units of
N/m). Refer to Basic_bushing_force_stiffness_and_damping “How to
choose force stiffness and damping constants” for more details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw_[Expression].frameA(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression]</span></span></dt>
<dd><p>Returns frame A, which is the frame that is welded to link (body) L0
and attached to the bushing.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw_[Expression].frameC(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression]</span></span></dt>
<dd><p>Returns frame C, which is the frame that is welded to link (body) L1
and attached to the bushing.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw_[Expression].GetForceDampingConstants(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the force damping constants <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code> (units of N*s/m)
stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw_[Expression].GetForceStiffnessConstants(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the force stiffness constants <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> (units of N/m)
stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw_[Expression].GetTorqueDampingConstants(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the torque damping constants <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">d₂]</span></code> (units of
N*m*s/rad) stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw_[Expression].GetTorqueStiffnessConstants(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the torque stiffness constants <code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> (units of
N*m/rad) stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw_[Expression].link0(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RigidBody_[Expression]</span></span></dt>
<dd><p>Returns link (body) L0 (frame A is welded to link L0).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw_[Expression].link1(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RigidBody_[Expression]</span></span></dt>
<dd><p>Returns link (body) L1 (frame C is welded to link L1).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw_[Expression].SetForceDampingConstants(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">force_damping:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the force damping constants <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code> (units of N*s/m) in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw_[Expression].SetForceStiffnessConstants(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">force_stiffness:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the force stiffness constants <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> (units of N/m) in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw_[Expression].SetTorqueDampingConstants(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">torque_damping:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the torque damping constants <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">d₂]</span></code> (units of N*m*s/rad)
in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw_[Expression].SetTorqueStiffnessConstants(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">torque_stiffness:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the torque stiffness constants <code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> (units of N*m/rad)
in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw_[Expression].torque_damping_constants(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the default torque damping constants <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">d₂]</span></code> (units of
N*m*s/rad). Refer to Basic_bushing_torque_stiffness_and_damping “How
to choose torque stiffness and damping constants” for more details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearBushingRollPitchYaw_[Expression].torque_stiffness_constants(self:</span> <span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the default torque stiffness constants <code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> (units
of N*m/rad). Refer to Basic_bushing_torque_stiffness_and_damping “How
to choose torque stiffness and damping constants” for more details.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearSpringDamper</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ForceElement</span></code></p>
<p>This ForceElement models a spring-damper attached between two points
on two different bodies. Given a point P on a body A and a point Q on
a body B with positions p_AP and p_BQ, respectively, this
spring-damper applies equal and opposite forces on bodies A and B
according to:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">f_AP</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="err">⋅</span><span class="p">(</span><span class="n">ℓ</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ℓ₀</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c</span><span class="err">⋅</span><span class="n">dℓ</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span><span class="err">⋅</span><span class="n">r</span><span class="err">̂</span>
<span class="w">  </span><span class="n">f_BQ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">f_AP</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">ℓ</span> <span class="pre">=</span> <span class="pre">‖p_WQ</span> <span class="pre">-</span> <span class="pre">p_WP‖</span></code> is the current length of the spring, dℓ/dt
its rate of change, <code class="docutils literal notranslate"><span class="pre">r̂</span> <span class="pre">=</span> <span class="pre">(p_WQ</span> <span class="pre">-</span> <span class="pre">p_WP)</span> <span class="pre">/</span> <span class="pre">ℓ</span></code> is the normalized
vector from P to Q, ℓ₀ is the free length of the spring and k and c
are the stiffness and damping of the spring-damper, respectively. This
ForceElement is meant to model finite free length springs attached
between two points. In this typical arrangement springs are usually
pre-loaded, meaning they apply a non-zero spring force in the static
configuration of the system. Thus, neither the free length ℓ₀ nor the
current length ℓ of the spring can ever be zero. The length of the
spring approaching zero would incur in a non-physical configuration
and therefore this element throws a RuntimeError exception in that
case. Note that:</p>
<ul class="simple">
<li><p>The applied force is always along the line connecting points P and</p></li>
</ul>
<p>Q. - Damping always dissipates energy. - Forces on bodies A and B are
equal and opposite according to Newton’s third law.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">LinearSpringDamper_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearSpringDamper.__init__(self:</span> <span class="pre">pydrake.multibody.tree.LinearSpringDamper,</span> <span class="pre">bodyA:</span> <span class="pre">pydrake.multibody.tree.RigidBody,</span> <span class="pre">p_AP:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">bodyB:</span> <span class="pre">pydrake.multibody.tree.RigidBody,</span> <span class="pre">p_BQ:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">free_length:</span> <span class="pre">float,</span> <span class="pre">stiffness:</span> <span class="pre">float,</span> <span class="pre">damping:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructor for a spring-damper between a point P on <code class="docutils literal notranslate"><span class="pre">bodyA</span></code> and a
point Q on <code class="docutils literal notranslate"><span class="pre">bodyB</span></code>. Point P is defined by its position <code class="docutils literal notranslate"><span class="pre">p_AP</span></code> as
measured and expressed in the body frame A and similarly, point Q is
defined by its position p_BQ as measured and expressed in body frame
B. The remaining parameters define:</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">free_length</span></code>:</dt><dd><p>The free length of the spring ℓ₀, in meters, at which the spring
applies no forces. Since this force element is meant to model
finite length springs, ℓ₀ must be strictly positive.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">stiffness</span></code>:</dt><dd><p>The stiffness k of the spring in N/m. It must be non-negative.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>The damping c of the damper in N⋅s/m. It must be non-negative.
Refer to this class’s documentation for further details.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if free_length is negative</strong><strong> or </strong><strong>zero.</strong> – </p></li>
<li><p><strong>RuntimeError if stiffness is negative.</strong> – </p></li>
<li><p><strong>RuntimeError if damping is negative.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearSpringDamper.bodyA(self:</span> <span class="pre">pydrake.multibody.tree.LinearSpringDamper)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RigidBody</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearSpringDamper.bodyB(self:</span> <span class="pre">pydrake.multibody.tree.LinearSpringDamper)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RigidBody</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearSpringDamper.damping(self:</span> <span class="pre">pydrake.multibody.tree.LinearSpringDamper)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearSpringDamper.free_length(self:</span> <span class="pre">pydrake.multibody.tree.LinearSpringDamper)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearSpringDamper.p_AP(self:</span> <span class="pre">pydrake.multibody.tree.LinearSpringDamper)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>The position p_AP of point P on body A as measured and expressed in
body frame A.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearSpringDamper.p_BQ(self:</span> <span class="pre">pydrake.multibody.tree.LinearSpringDamper)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>The position p_BQ of point Q on body B as measured and expressed in
body frame B.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearSpringDamper.stiffness(self:</span> <span class="pre">pydrake.multibody.tree.LinearSpringDamper)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearSpringDamper_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">LinearSpringDamper_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">LinearSpringDamper_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">LinearSpringDamper_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearSpringDamper_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ForceElement_[AutoDiffXd]</span></code></p>
<p>This ForceElement models a spring-damper attached between two points
on two different bodies. Given a point P on a body A and a point Q on
a body B with positions p_AP and p_BQ, respectively, this
spring-damper applies equal and opposite forces on bodies A and B
according to:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">f_AP</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="err">⋅</span><span class="p">(</span><span class="n">ℓ</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ℓ₀</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c</span><span class="err">⋅</span><span class="n">dℓ</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span><span class="err">⋅</span><span class="n">r</span><span class="err">̂</span>
<span class="w">  </span><span class="n">f_BQ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">f_AP</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">ℓ</span> <span class="pre">=</span> <span class="pre">‖p_WQ</span> <span class="pre">-</span> <span class="pre">p_WP‖</span></code> is the current length of the spring, dℓ/dt
its rate of change, <code class="docutils literal notranslate"><span class="pre">r̂</span> <span class="pre">=</span> <span class="pre">(p_WQ</span> <span class="pre">-</span> <span class="pre">p_WP)</span> <span class="pre">/</span> <span class="pre">ℓ</span></code> is the normalized
vector from P to Q, ℓ₀ is the free length of the spring and k and c
are the stiffness and damping of the spring-damper, respectively. This
ForceElement is meant to model finite free length springs attached
between two points. In this typical arrangement springs are usually
pre-loaded, meaning they apply a non-zero spring force in the static
configuration of the system. Thus, neither the free length ℓ₀ nor the
current length ℓ of the spring can ever be zero. The length of the
spring approaching zero would incur in a non-physical configuration
and therefore this element throws a RuntimeError exception in that
case. Note that:</p>
<ul class="simple">
<li><p>The applied force is always along the line connecting points P and</p></li>
</ul>
<p>Q. - Damping always dissipates energy. - Forces on bodies A and B are
equal and opposite according to Newton’s third law.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearSpringDamper_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd],</span> <span class="pre">bodyA:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[AutoDiffXd],</span> <span class="pre">p_AP:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">bodyB:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[AutoDiffXd],</span> <span class="pre">p_BQ:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">free_length:</span> <span class="pre">float,</span> <span class="pre">stiffness:</span> <span class="pre">float,</span> <span class="pre">damping:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructor for a spring-damper between a point P on <code class="docutils literal notranslate"><span class="pre">bodyA</span></code> and a
point Q on <code class="docutils literal notranslate"><span class="pre">bodyB</span></code>. Point P is defined by its position <code class="docutils literal notranslate"><span class="pre">p_AP</span></code> as
measured and expressed in the body frame A and similarly, point Q is
defined by its position p_BQ as measured and expressed in body frame
B. The remaining parameters define:</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">free_length</span></code>:</dt><dd><p>The free length of the spring ℓ₀, in meters, at which the spring
applies no forces. Since this force element is meant to model
finite length springs, ℓ₀ must be strictly positive.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">stiffness</span></code>:</dt><dd><p>The stiffness k of the spring in N/m. It must be non-negative.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>The damping c of the damper in N⋅s/m. It must be non-negative.
Refer to this class’s documentation for further details.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if free_length is negative</strong><strong> or </strong><strong>zero.</strong> – </p></li>
<li><p><strong>RuntimeError if stiffness is negative.</strong> – </p></li>
<li><p><strong>RuntimeError if damping is negative.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearSpringDamper_[AutoDiffXd].bodyA(self:</span> <span class="pre">pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RigidBody_[AutoDiffXd]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearSpringDamper_[AutoDiffXd].bodyB(self:</span> <span class="pre">pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RigidBody_[AutoDiffXd]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearSpringDamper_[AutoDiffXd].damping(self:</span> <span class="pre">pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearSpringDamper_[AutoDiffXd].free_length(self:</span> <span class="pre">pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearSpringDamper_[AutoDiffXd].p_AP(self:</span> <span class="pre">pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>The position p_AP of point P on body A as measured and expressed in
body frame A.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearSpringDamper_[AutoDiffXd].p_BQ(self:</span> <span class="pre">pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>The position p_BQ of point Q on body B as measured and expressed in
body frame B.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearSpringDamper_[AutoDiffXd].stiffness(self:</span> <span class="pre">pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearSpringDamper_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ForceElement_[Expression]</span></code></p>
<p>This ForceElement models a spring-damper attached between two points
on two different bodies. Given a point P on a body A and a point Q on
a body B with positions p_AP and p_BQ, respectively, this
spring-damper applies equal and opposite forces on bodies A and B
according to:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">f_AP</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="err">⋅</span><span class="p">(</span><span class="n">ℓ</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">ℓ₀</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c</span><span class="err">⋅</span><span class="n">dℓ</span><span class="o">/</span><span class="n">dt</span><span class="p">)</span><span class="err">⋅</span><span class="n">r</span><span class="err">̂</span>
<span class="w">  </span><span class="n">f_BQ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">f_AP</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">ℓ</span> <span class="pre">=</span> <span class="pre">‖p_WQ</span> <span class="pre">-</span> <span class="pre">p_WP‖</span></code> is the current length of the spring, dℓ/dt
its rate of change, <code class="docutils literal notranslate"><span class="pre">r̂</span> <span class="pre">=</span> <span class="pre">(p_WQ</span> <span class="pre">-</span> <span class="pre">p_WP)</span> <span class="pre">/</span> <span class="pre">ℓ</span></code> is the normalized
vector from P to Q, ℓ₀ is the free length of the spring and k and c
are the stiffness and damping of the spring-damper, respectively. This
ForceElement is meant to model finite free length springs attached
between two points. In this typical arrangement springs are usually
pre-loaded, meaning they apply a non-zero spring force in the static
configuration of the system. Thus, neither the free length ℓ₀ nor the
current length ℓ of the spring can ever be zero. The length of the
spring approaching zero would incur in a non-physical configuration
and therefore this element throws a RuntimeError exception in that
case. Note that:</p>
<ul class="simple">
<li><p>The applied force is always along the line connecting points P and</p></li>
</ul>
<p>Q. - Damping always dissipates energy. - Forces on bodies A and B are
equal and opposite according to Newton’s third law.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearSpringDamper_[Expression].__init__(self:</span> <span class="pre">pydrake.multibody.tree.LinearSpringDamper_[Expression],</span> <span class="pre">bodyA:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[Expression],</span> <span class="pre">p_AP:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">bodyB:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[Expression],</span> <span class="pre">p_BQ:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">free_length:</span> <span class="pre">float,</span> <span class="pre">stiffness:</span> <span class="pre">float,</span> <span class="pre">damping:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructor for a spring-damper between a point P on <code class="docutils literal notranslate"><span class="pre">bodyA</span></code> and a
point Q on <code class="docutils literal notranslate"><span class="pre">bodyB</span></code>. Point P is defined by its position <code class="docutils literal notranslate"><span class="pre">p_AP</span></code> as
measured and expressed in the body frame A and similarly, point Q is
defined by its position p_BQ as measured and expressed in body frame
B. The remaining parameters define:</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">free_length</span></code>:</dt><dd><p>The free length of the spring ℓ₀, in meters, at which the spring
applies no forces. Since this force element is meant to model
finite length springs, ℓ₀ must be strictly positive.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">stiffness</span></code>:</dt><dd><p>The stiffness k of the spring in N/m. It must be non-negative.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>The damping c of the damper in N⋅s/m. It must be non-negative.
Refer to this class’s documentation for further details.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if free_length is negative</strong><strong> or </strong><strong>zero.</strong> – </p></li>
<li><p><strong>RuntimeError if stiffness is negative.</strong> – </p></li>
<li><p><strong>RuntimeError if damping is negative.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearSpringDamper_[Expression].bodyA(self:</span> <span class="pre">pydrake.multibody.tree.LinearSpringDamper_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RigidBody_[Expression]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearSpringDamper_[Expression].bodyB(self:</span> <span class="pre">pydrake.multibody.tree.LinearSpringDamper_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RigidBody_[Expression]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearSpringDamper_[Expression].damping(self:</span> <span class="pre">pydrake.multibody.tree.LinearSpringDamper_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearSpringDamper_[Expression].free_length(self:</span> <span class="pre">pydrake.multibody.tree.LinearSpringDamper_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearSpringDamper_[Expression].p_AP(self:</span> <span class="pre">pydrake.multibody.tree.LinearSpringDamper_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>The position p_AP of point P on body A as measured and expressed in
body frame A.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearSpringDamper_[Expression].p_BQ(self:</span> <span class="pre">pydrake.multibody.tree.LinearSpringDamper_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>The position p_BQ of point Q on body B as measured and expressed in
body frame B.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">LinearSpringDamper_[Expression].stiffness(self:</span> <span class="pre">pydrake.multibody.tree.LinearSpringDamper_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ModelInstanceIndex</span></span></dt>
<dd><p>Type used to identify model instances by index within a multibody
plant.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ModelInstanceIndex.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.tree.ModelInstanceIndex) -&gt; None</p></li>
</ol>
<p>Default constructor; the result is an <em>invalid</em> index. This only
exists to serve applications which require a default constructor.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.tree.ModelInstanceIndex, arg0: int) -&gt; None</p></li>
</ol>
<p>Construction from a non-negative <code class="docutils literal notranslate"><span class="pre">int</span></code> value. The value must lie in
the range of [0, 2³¹). Constructor only promises to test validity in
Debug build.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ModelInstanceIndex.is_valid(self:</span> <span class="pre">pydrake.multibody.tree.ModelInstanceIndex)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Reports if the index is valid–the only operation on an invalid index
that doesn’t throw an exception in Debug builds.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultibodyConstraintId</span></span></dt>
<dd><p>Type used to identify constraint by id within a multibody plant.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultibodyConstraintId.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultibodyConstraintId.get_new_id()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.MultibodyConstraintId</span></span></dt>
<dd><p>Generates a new identifier for this id type. This new identifier will
be different from all previous identifiers created. This method does
<em>not</em> make any guarantees about the values of ids from successive
invocations. This method is guaranteed to be thread safe.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultibodyConstraintId.get_value(self:</span> <span class="pre">pydrake.multibody.tree.MultibodyConstraintId)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Extracts the underlying representation from the identifier. This is
considered invalid for invalid ids and is strictly enforced in Debug
builds.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultibodyConstraintId.is_valid(self:</span> <span class="pre">pydrake.multibody.tree.MultibodyConstraintId)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Reports if the id is valid.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultibodyForces</span></span></dt>
<dd><p>A class to hold a set of forces applied to a MultibodyTree system.
Forces can include generalized forces as well as body spatial forces.
MultibodyPlant::CalcGeneralizedForces() can be used to compute the
<em>total</em> generalized force, combining generalized_forces() and
body_forces().</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">MultibodyForces_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultibodyForces.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.tree.MultibodyForces, plant: drake::multibody::MultibodyPlant&lt;double&gt;) -&gt; None</p></li>
</ol>
<p>Constructs a force object to store a set of forces to be applied to
the multibody model for <code class="docutils literal notranslate"><span class="pre">plant</span></code>. Forces are initialized to zero,
meaning no forces are applied. <code class="docutils literal notranslate"><span class="pre">plant</span></code> must have been already
finalized with MultibodyPlant::Finalize() or this constructor will
abort.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.tree.MultibodyForces, nb: int, nv: int) -&gt; None</p></li>
</ol>
<p>Number of bodies and number of generalized velocities overload. This
constructor is useful for constructing the MultibodyForces structure
before a MultibodyPlant has been constructed.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultibodyForces.AddInForces(self:</span> <span class="pre">pydrake.multibody.tree.MultibodyForces,</span> <span class="pre">addend:</span> <span class="pre">pydrake.multibody.tree.MultibodyForces)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Adds into <code class="docutils literal notranslate"><span class="pre">this</span></code> the force contribution stored in <code class="docutils literal notranslate"><span class="pre">addend</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultibodyForces.generalized_forces(self:</span> <span class="pre">pydrake.multibody.tree.MultibodyForces)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>(Advanced) Returns a constant reference to the vector of generalized
forces stored by <code class="docutils literal notranslate"><span class="pre">this</span></code> forces object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultibodyForces.mutable_generalized_forces(self:</span> <span class="pre">pydrake.multibody.tree.MultibodyForces)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>(Advanced) Mutable version of generalized_forces().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultibodyForces.num_bodies(self:</span> <span class="pre">pydrake.multibody.tree.MultibodyForces)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of bodies for which <code class="docutils literal notranslate"><span class="pre">this</span></code> force object applies.
Determined at construction from the given model MultibodyTree object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultibodyForces.num_velocities(self:</span> <span class="pre">pydrake.multibody.tree.MultibodyForces)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of generalized velocities for the model to which
these forces apply. The number of generalized forces in a multibody
model always equals the number of generalized velocities. Determined
at construction from the given model MultibodyTree object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultibodyForces.SetZero(self:</span> <span class="pre">pydrake.multibody.tree.MultibodyForces)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.MultibodyForces</span></span></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> to store zero forces (no applied forces).</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultibodyForces_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">MultibodyForces_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">MultibodyForces_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">MultibodyForces_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultibodyForces_[AutoDiffXd]</span></span></dt>
<dd><p>A class to hold a set of forces applied to a MultibodyTree system.
Forces can include generalized forces as well as body spatial forces.
MultibodyPlant::CalcGeneralizedForces() can be used to compute the
<em>total</em> generalized force, combining generalized_forces() and
body_forces().</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultibodyForces_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.tree.MultibodyForces_[AutoDiffXd], plant: drake::multibody::MultibodyPlant&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;) -&gt; None</p></li>
</ol>
<p>Constructs a force object to store a set of forces to be applied to
the multibody model for <code class="docutils literal notranslate"><span class="pre">plant</span></code>. Forces are initialized to zero,
meaning no forces are applied. <code class="docutils literal notranslate"><span class="pre">plant</span></code> must have been already
finalized with MultibodyPlant::Finalize() or this constructor will
abort.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.tree.MultibodyForces_[AutoDiffXd], nb: int, nv: int) -&gt; None</p></li>
</ol>
<p>Number of bodies and number of generalized velocities overload. This
constructor is useful for constructing the MultibodyForces structure
before a MultibodyPlant has been constructed.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultibodyForces_[AutoDiffXd].AddInForces(self:</span> <span class="pre">pydrake.multibody.tree.MultibodyForces_[AutoDiffXd],</span> <span class="pre">addend:</span> <span class="pre">pydrake.multibody.tree.MultibodyForces_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Adds into <code class="docutils literal notranslate"><span class="pre">this</span></code> the force contribution stored in <code class="docutils literal notranslate"><span class="pre">addend</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultibodyForces_[AutoDiffXd].generalized_forces(self:</span> <span class="pre">pydrake.multibody.tree.MultibodyForces_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>(Advanced) Returns a constant reference to the vector of generalized
forces stored by <code class="docutils literal notranslate"><span class="pre">this</span></code> forces object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultibodyForces_[AutoDiffXd].mutable_generalized_forces(self:</span> <span class="pre">pydrake.multibody.tree.MultibodyForces_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>(Advanced) Mutable version of generalized_forces().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultibodyForces_[AutoDiffXd].num_bodies(self:</span> <span class="pre">pydrake.multibody.tree.MultibodyForces_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of bodies for which <code class="docutils literal notranslate"><span class="pre">this</span></code> force object applies.
Determined at construction from the given model MultibodyTree object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultibodyForces_[AutoDiffXd].num_velocities(self:</span> <span class="pre">pydrake.multibody.tree.MultibodyForces_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of generalized velocities for the model to which
these forces apply. The number of generalized forces in a multibody
model always equals the number of generalized velocities. Determined
at construction from the given model MultibodyTree object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultibodyForces_[AutoDiffXd].SetZero(self:</span> <span class="pre">pydrake.multibody.tree.MultibodyForces_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.MultibodyForces_[AutoDiffXd]</span></span></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> to store zero forces (no applied forces).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultibodyForces_[Expression]</span></span></dt>
<dd><p>A class to hold a set of forces applied to a MultibodyTree system.
Forces can include generalized forces as well as body spatial forces.
MultibodyPlant::CalcGeneralizedForces() can be used to compute the
<em>total</em> generalized force, combining generalized_forces() and
body_forces().</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultibodyForces_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.tree.MultibodyForces_[Expression], plant: drake::multibody::MultibodyPlant&lt;drake::symbolic::Expression&gt;) -&gt; None</p></li>
</ol>
<p>Constructs a force object to store a set of forces to be applied to
the multibody model for <code class="docutils literal notranslate"><span class="pre">plant</span></code>. Forces are initialized to zero,
meaning no forces are applied. <code class="docutils literal notranslate"><span class="pre">plant</span></code> must have been already
finalized with MultibodyPlant::Finalize() or this constructor will
abort.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.tree.MultibodyForces_[Expression], nb: int, nv: int) -&gt; None</p></li>
</ol>
<p>Number of bodies and number of generalized velocities overload. This
constructor is useful for constructing the MultibodyForces structure
before a MultibodyPlant has been constructed.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultibodyForces_[Expression].AddInForces(self:</span> <span class="pre">pydrake.multibody.tree.MultibodyForces_[Expression],</span> <span class="pre">addend:</span> <span class="pre">pydrake.multibody.tree.MultibodyForces_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Adds into <code class="docutils literal notranslate"><span class="pre">this</span></code> the force contribution stored in <code class="docutils literal notranslate"><span class="pre">addend</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultibodyForces_[Expression].generalized_forces(self:</span> <span class="pre">pydrake.multibody.tree.MultibodyForces_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>(Advanced) Returns a constant reference to the vector of generalized
forces stored by <code class="docutils literal notranslate"><span class="pre">this</span></code> forces object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultibodyForces_[Expression].mutable_generalized_forces(self:</span> <span class="pre">pydrake.multibody.tree.MultibodyForces_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>(Advanced) Mutable version of generalized_forces().</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultibodyForces_[Expression].num_bodies(self:</span> <span class="pre">pydrake.multibody.tree.MultibodyForces_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of bodies for which <code class="docutils literal notranslate"><span class="pre">this</span></code> force object applies.
Determined at construction from the given model MultibodyTree object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultibodyForces_[Expression].num_velocities(self:</span> <span class="pre">pydrake.multibody.tree.MultibodyForces_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>Returns the number of generalized velocities for the model to which
these forces apply. The number of generalized forces in a multibody
model always equals the number of generalized velocities. Determined
at construction from the given model MultibodyTree object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">MultibodyForces_[Expression].SetZero(self:</span> <span class="pre">pydrake.multibody.tree.MultibodyForces_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.MultibodyForces_[Expression]</span></span></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> to store zero forces (no applied forces).</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PdControllerGains</span></span></dt>
<dd><p>PD controller gains. This enables the modeling of a simple low level
PD controllers, see JointActuator::set_controller_gains().</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PdControllerGains.__init__(self:</span> <span class="pre">pydrake.multibody.tree.PdControllerGains,</span> <span class="pre">**kwargs)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PdControllerGains.d</span></span></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PdControllerGains.p</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint</span></code></p>
<p>This joint models a planar joint allowing two bodies to translate and
rotate relative to one another in a plane with three degrees of
freedom. That is, given a frame F attached to the parent body P and a
frame M attached to the child body B (see the Joint class’s
documentation), this joint allows frame M to translate within the x-y
plane of frame F and to rotate about the z-axis, with M’s z-axis Mz
and F’s z-axis Fz coincident at all times. The translations along the
x- and y-axes of F, the rotation about the z-axis and their rates
specify the state of the joint. Zero (x, y, θ) corresponds to frames F
and M being coincident and aligned. Translation (x, y) is defined to
be positive in the direction of the respective axes and the rotation θ
is defined to be positive according to the right-hand-rule with the
thumb aligned in the direction of frame F’s z-axis.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">PlanarJoint_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint.__init__(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint,</span> <span class="pre">name:</span> <span class="pre">str,</span> <span class="pre">frame_on_parent:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">frame_on_child:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">damping:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span> <span class="pre">=</span> <span class="pre">array([0.,</span> <span class="pre">0.,</span> <span class="pre">0.]))</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructor to create a planar joint between two bodies so that frame
F attached to the parent body P and frame M attached to the child body
B translate and rotate as described in the class’s documentation. This
constructor signature creates a joint with no joint limits, i.e. the
joint position, velocity and acceleration limits are the pair <code class="docutils literal notranslate"><span class="pre">(-∞,</span>
<span class="pre">∞)</span></code>. These can be set using the Joint methods set_position_limits(),
set_velocity_limits() and set_acceleration_limits(). The first three
arguments to this constructor are those of the Joint class
constructor. See the Joint class’s documentation for details. The
additional parameters are:</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>Viscous damping coefficient, in N⋅s/m for translation and N⋅m⋅s
for rotation, used to model losses within the joint. See
documentation of default_damping() for details on modelling of the
damping force and torque.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if any element</strong><strong> of </strong><strong>damping is negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint.default_damping(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s default damping constant in N⋅s/m for the
translational degrees and N⋅m⋅s for the rotational degree. The damping
force (in N) is modeled as <code class="docutils literal notranslate"><span class="pre">fᵢ</span> <span class="pre">=</span> <span class="pre">-dampingᵢ⋅vᵢ,</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">2</span></code> i.e.
opposing motion, with vᵢ the translation rates along the i-th axis for
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see get_translational_velocity()) and fᵢ the force on
child body B at Mo and expressed in F. That is, f_BMo_F = (f₁, f₂).
The damping torque (in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span> <span class="pre">-damping₃⋅ω</span></code> i.e.
opposing motion, with ω the angular rate for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see
get_angular_velocity()) and τ the torque on child body B expressed in
frame F as t_B_F = τ⋅Fz_F.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint.get_angular_velocity(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Gets the rate of change, in radians per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
angle θ from <code class="docutils literal notranslate"><span class="pre">context</span></code>. See class documentation for the definition
of this angle.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>:</dt><dd><p>The rate of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s angle θ as stored in the
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint.get_default_rotation(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Gets the default angle for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt><dd><p>The default angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint.get_default_translation(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[2,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Gets the default position for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>:</dt><dd><p>The default position of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint.get_rotation(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Gets the angle θ of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt><dd><p>The angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code>. See class
documentation for details.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint.get_translation(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[2,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Gets the position of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>:</dt><dd><p>The position of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code> ordered
as (x, y). See class documentation for details.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint.get_translational_velocity(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[2,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Gets the translational velocity v_FoMo_F, in meters per second, of
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s Mo measured and expressed in frame F from
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">v_FoMo_F</span></code>:</dt><dd><p>The translational velocity of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint as stored in the
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint.kTypeName</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint.set_angular_velocity(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">theta_dot:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.PlanarJoint</span></span></dt>
<dd><p>Sets the rate of change, in radians per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
angle θ (see class documentation) to <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>. The new rate of
change gets stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>:</dt><dd><p>The desired rates of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s angle in radians
per second.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint.set_default_pose(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint,</span> <span class="pre">p_FoMo_F:</span> <span class="pre">numpy.ndarray[numpy.float64[2,</span> <span class="pre">1]],</span> <span class="pre">theta:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default position and angle of this joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>:</dt><dd><p>The desired default position of the joint</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt><dd><p>The desired default angle of the joint</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint.set_default_rotation(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint,</span> <span class="pre">theta:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default angle of this joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt><dd><p>The desired default angle of the joint</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint.set_default_translation(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint,</span> <span class="pre">p_FoMo_F:</span> <span class="pre">numpy.ndarray[numpy.float64[2,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default position of this joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>:</dt><dd><p>The desired default position of the joint</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint.set_pose(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">p_FoMo_F:</span> <span class="pre">numpy.ndarray[numpy.float64[2,</span> <span class="pre">1]],</span> <span class="pre">theta:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.PlanarJoint</span></span></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the position of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals
<code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code> and its angle equals <code class="docutils literal notranslate"><span class="pre">theta</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>:</dt><dd><p>The desired position in meters to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> ordered
as (x, y). See class documentation for details.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt><dd><p>The desired angle in radians to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>. See
class documentation for details.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint.set_random_pose_distribution(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint,</span> <span class="pre">p_FoMo_F:</span> <span class="pre">numpy.ndarray[object[2,</span> <span class="pre">1]],</span> <span class="pre">theta:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the random distribution that the position and angle of this joint
will be randomly sampled from. See class documentation for details on
the definition of the position and angle.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint.set_rotation(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">theta:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.PlanarJoint</span></span></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the angle θ of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals
<code class="docutils literal notranslate"><span class="pre">theta</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt><dd><p>The desired angle in radians to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>. See
class documentation for details.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint.set_translation(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">p_FoMo_F:</span> <span class="pre">numpy.ndarray[numpy.float64[2,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.PlanarJoint</span></span></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the position of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals
<code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>:</dt><dd><p>The desired position in meters to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> ordered
as (x, y). See class documentation for details.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint.set_translational_velocity(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">v_FoMo_F:</span> <span class="pre">numpy.ndarray[numpy.float64[2,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.PlanarJoint</span></span></dt>
<dd><p>Sets the translational velocity, in meters per second, of this
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s Mo measured and expressed in frame F to <code class="docutils literal notranslate"><span class="pre">v_FoMo_F</span></code>.
The new translational velocity gets stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v_FoMo_F</span></code>:</dt><dd><p>The desired translational velocity of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters per
second.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">PlanarJoint_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">PlanarJoint_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">PlanarJoint_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd]</span></code></p>
<p>This joint models a planar joint allowing two bodies to translate and
rotate relative to one another in a plane with three degrees of
freedom. That is, given a frame F attached to the parent body P and a
frame M attached to the child body B (see the Joint class’s
documentation), this joint allows frame M to translate within the x-y
plane of frame F and to rotate about the z-axis, with M’s z-axis Mz
and F’s z-axis Fz coincident at all times. The translations along the
x- and y-axes of F, the rotation about the z-axis and their rates
specify the state of the joint. Zero (x, y, θ) corresponds to frames F
and M being coincident and aligned. Translation (x, y) is defined to
be positive in the direction of the respective axes and the rotation θ
is defined to be positive according to the right-hand-rule with the
thumb aligned in the direction of frame F’s z-axis.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[AutoDiffXd],</span> <span class="pre">name:</span> <span class="pre">str,</span> <span class="pre">frame_on_parent:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">frame_on_child:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">damping:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span> <span class="pre">=</span> <span class="pre">array([0.,</span> <span class="pre">0.,</span> <span class="pre">0.]))</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructor to create a planar joint between two bodies so that frame
F attached to the parent body P and frame M attached to the child body
B translate and rotate as described in the class’s documentation. This
constructor signature creates a joint with no joint limits, i.e. the
joint position, velocity and acceleration limits are the pair <code class="docutils literal notranslate"><span class="pre">(-∞,</span>
<span class="pre">∞)</span></code>. These can be set using the Joint methods set_position_limits(),
set_velocity_limits() and set_acceleration_limits(). The first three
arguments to this constructor are those of the Joint class
constructor. See the Joint class’s documentation for details. The
additional parameters are:</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>Viscous damping coefficient, in N⋅s/m for translation and N⋅m⋅s
for rotation, used to model losses within the joint. See
documentation of default_damping() for details on modelling of the
damping force and torque.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if any element</strong><strong> of </strong><strong>damping is negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint_[AutoDiffXd].default_damping(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s default damping constant in N⋅s/m for the
translational degrees and N⋅m⋅s for the rotational degree. The damping
force (in N) is modeled as <code class="docutils literal notranslate"><span class="pre">fᵢ</span> <span class="pre">=</span> <span class="pre">-dampingᵢ⋅vᵢ,</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">2</span></code> i.e.
opposing motion, with vᵢ the translation rates along the i-th axis for
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see get_translational_velocity()) and fᵢ the force on
child body B at Mo and expressed in F. That is, f_BMo_F = (f₁, f₂).
The damping torque (in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span> <span class="pre">-damping₃⋅ω</span></code> i.e.
opposing motion, with ω the angular rate for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see
get_angular_velocity()) and τ the torque on child body B expressed in
frame F as t_B_F = τ⋅Fz_F.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint_[AutoDiffXd].get_angular_velocity(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd</span></span></dt>
<dd><p>Gets the rate of change, in radians per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
angle θ from <code class="docutils literal notranslate"><span class="pre">context</span></code>. See class documentation for the definition
of this angle.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>:</dt><dd><p>The rate of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s angle θ as stored in the
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint_[AutoDiffXd].get_default_rotation(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Gets the default angle for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt><dd><p>The default angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint_[AutoDiffXd].get_default_translation(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[2,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Gets the default position for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>:</dt><dd><p>The default position of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint_[AutoDiffXd].get_rotation(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd</span></span></dt>
<dd><p>Gets the angle θ of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt><dd><p>The angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code>. See class
documentation for details.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint_[AutoDiffXd].get_translation(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[2,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Gets the position of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>:</dt><dd><p>The position of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code> ordered
as (x, y). See class documentation for details.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint_[AutoDiffXd].get_translational_velocity(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[2,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Gets the translational velocity v_FoMo_F, in meters per second, of
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s Mo measured and expressed in frame F from
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">v_FoMo_F</span></code>:</dt><dd><p>The translational velocity of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint as stored in the
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint_[AutoDiffXd].kTypeName</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint_[AutoDiffXd].set_angular_velocity(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">theta_dot:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[AutoDiffXd]</span></span></dt>
<dd><p>Sets the rate of change, in radians per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
angle θ (see class documentation) to <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>. The new rate of
change gets stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>:</dt><dd><p>The desired rates of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s angle in radians
per second.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint_[AutoDiffXd].set_default_pose(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[AutoDiffXd],</span> <span class="pre">p_FoMo_F:</span> <span class="pre">numpy.ndarray[numpy.float64[2,</span> <span class="pre">1]],</span> <span class="pre">theta:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default position and angle of this joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>:</dt><dd><p>The desired default position of the joint</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt><dd><p>The desired default angle of the joint</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint_[AutoDiffXd].set_default_rotation(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[AutoDiffXd],</span> <span class="pre">theta:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default angle of this joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt><dd><p>The desired default angle of the joint</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint_[AutoDiffXd].set_default_translation(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[AutoDiffXd],</span> <span class="pre">p_FoMo_F:</span> <span class="pre">numpy.ndarray[numpy.float64[2,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default position of this joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>:</dt><dd><p>The desired default position of the joint</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint_[AutoDiffXd].set_pose(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">p_FoMo_F:</span> <span class="pre">numpy.ndarray[object[2,</span> <span class="pre">1]],</span> <span class="pre">theta:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[AutoDiffXd]</span></span></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the position of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals
<code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code> and its angle equals <code class="docutils literal notranslate"><span class="pre">theta</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>:</dt><dd><p>The desired position in meters to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> ordered
as (x, y). See class documentation for details.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt><dd><p>The desired angle in radians to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>. See
class documentation for details.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint_[AutoDiffXd].set_random_pose_distribution(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[AutoDiffXd],</span> <span class="pre">p_FoMo_F:</span> <span class="pre">numpy.ndarray[object[2,</span> <span class="pre">1]],</span> <span class="pre">theta:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the random distribution that the position and angle of this joint
will be randomly sampled from. See class documentation for details on
the definition of the position and angle.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint_[AutoDiffXd].set_rotation(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">theta:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[AutoDiffXd]</span></span></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the angle θ of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals
<code class="docutils literal notranslate"><span class="pre">theta</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt><dd><p>The desired angle in radians to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>. See
class documentation for details.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint_[AutoDiffXd].set_translation(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">p_FoMo_F:</span> <span class="pre">numpy.ndarray[object[2,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[AutoDiffXd]</span></span></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the position of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals
<code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>:</dt><dd><p>The desired position in meters to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> ordered
as (x, y). See class documentation for details.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint_[AutoDiffXd].set_translational_velocity(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">v_FoMo_F:</span> <span class="pre">numpy.ndarray[object[2,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[AutoDiffXd]</span></span></dt>
<dd><p>Sets the translational velocity, in meters per second, of this
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s Mo measured and expressed in frame F to <code class="docutils literal notranslate"><span class="pre">v_FoMo_F</span></code>.
The new translational velocity gets stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v_FoMo_F</span></code>:</dt><dd><p>The desired translational velocity of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters per
second.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[Expression]</span></code></p>
<p>This joint models a planar joint allowing two bodies to translate and
rotate relative to one another in a plane with three degrees of
freedom. That is, given a frame F attached to the parent body P and a
frame M attached to the child body B (see the Joint class’s
documentation), this joint allows frame M to translate within the x-y
plane of frame F and to rotate about the z-axis, with M’s z-axis Mz
and F’s z-axis Fz coincident at all times. The translations along the
x- and y-axes of F, the rotation about the z-axis and their rates
specify the state of the joint. Zero (x, y, θ) corresponds to frames F
and M being coincident and aligned. Translation (x, y) is defined to
be positive in the direction of the respective axes and the rotation θ
is defined to be positive according to the right-hand-rule with the
thumb aligned in the direction of frame F’s z-axis.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint_[Expression].__init__(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[Expression],</span> <span class="pre">name:</span> <span class="pre">str,</span> <span class="pre">frame_on_parent:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">frame_on_child:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">damping:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span> <span class="pre">=</span> <span class="pre">array([0.,</span> <span class="pre">0.,</span> <span class="pre">0.]))</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructor to create a planar joint between two bodies so that frame
F attached to the parent body P and frame M attached to the child body
B translate and rotate as described in the class’s documentation. This
constructor signature creates a joint with no joint limits, i.e. the
joint position, velocity and acceleration limits are the pair <code class="docutils literal notranslate"><span class="pre">(-∞,</span>
<span class="pre">∞)</span></code>. These can be set using the Joint methods set_position_limits(),
set_velocity_limits() and set_acceleration_limits(). The first three
arguments to this constructor are those of the Joint class
constructor. See the Joint class’s documentation for details. The
additional parameters are:</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>Viscous damping coefficient, in N⋅s/m for translation and N⋅m⋅s
for rotation, used to model losses within the joint. See
documentation of default_damping() for details on modelling of the
damping force and torque.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if any element</strong><strong> of </strong><strong>damping is negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint_[Expression].default_damping(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s default damping constant in N⋅s/m for the
translational degrees and N⋅m⋅s for the rotational degree. The damping
force (in N) is modeled as <code class="docutils literal notranslate"><span class="pre">fᵢ</span> <span class="pre">=</span> <span class="pre">-dampingᵢ⋅vᵢ,</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">2</span></code> i.e.
opposing motion, with vᵢ the translation rates along the i-th axis for
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see get_translational_velocity()) and fᵢ the force on
child body B at Mo and expressed in F. That is, f_BMo_F = (f₁, f₂).
The damping torque (in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span> <span class="pre">-damping₃⋅ω</span></code> i.e.
opposing motion, with ω the angular rate for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see
get_angular_velocity()) and τ the torque on child body B expressed in
frame F as t_B_F = τ⋅Fz_F.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint_[Expression].get_angular_velocity(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd><p>Gets the rate of change, in radians per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
angle θ from <code class="docutils literal notranslate"><span class="pre">context</span></code>. See class documentation for the definition
of this angle.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>:</dt><dd><p>The rate of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s angle θ as stored in the
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint_[Expression].get_default_rotation(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Gets the default angle for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt><dd><p>The default angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint_[Expression].get_default_translation(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[2,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Gets the default position for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>:</dt><dd><p>The default position of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint_[Expression].get_rotation(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd><p>Gets the angle θ of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt><dd><p>The angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code>. See class
documentation for details.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint_[Expression].get_translation(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[2,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Gets the position of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>:</dt><dd><p>The position of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code> ordered
as (x, y). See class documentation for details.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint_[Expression].get_translational_velocity(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[2,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Gets the translational velocity v_FoMo_F, in meters per second, of
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s Mo measured and expressed in frame F from
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">v_FoMo_F</span></code>:</dt><dd><p>The translational velocity of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint as stored in the
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint_[Expression].kTypeName</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint_[Expression].set_angular_velocity(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">theta_dot:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[Expression]</span></span></dt>
<dd><p>Sets the rate of change, in radians per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
angle θ (see class documentation) to <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>. The new rate of
change gets stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>:</dt><dd><p>The desired rates of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s angle in radians
per second.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint_[Expression].set_default_pose(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[Expression],</span> <span class="pre">p_FoMo_F:</span> <span class="pre">numpy.ndarray[numpy.float64[2,</span> <span class="pre">1]],</span> <span class="pre">theta:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default position and angle of this joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>:</dt><dd><p>The desired default position of the joint</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt><dd><p>The desired default angle of the joint</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint_[Expression].set_default_rotation(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[Expression],</span> <span class="pre">theta:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default angle of this joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt><dd><p>The desired default angle of the joint</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint_[Expression].set_default_translation(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[Expression],</span> <span class="pre">p_FoMo_F:</span> <span class="pre">numpy.ndarray[numpy.float64[2,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default position of this joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>:</dt><dd><p>The desired default position of the joint</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint_[Expression].set_pose(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">p_FoMo_F:</span> <span class="pre">numpy.ndarray[object[2,</span> <span class="pre">1]],</span> <span class="pre">theta:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[Expression]</span></span></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the position of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals
<code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code> and its angle equals <code class="docutils literal notranslate"><span class="pre">theta</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>:</dt><dd><p>The desired position in meters to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> ordered
as (x, y). See class documentation for details.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt><dd><p>The desired angle in radians to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>. See
class documentation for details.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint_[Expression].set_random_pose_distribution(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[Expression],</span> <span class="pre">p_FoMo_F:</span> <span class="pre">numpy.ndarray[object[2,</span> <span class="pre">1]],</span> <span class="pre">theta:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the random distribution that the position and angle of this joint
will be randomly sampled from. See class documentation for details on
the definition of the position and angle.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint_[Expression].set_rotation(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">theta:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[Expression]</span></span></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the angle θ of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals
<code class="docutils literal notranslate"><span class="pre">theta</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt><dd><p>The desired angle in radians to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>. See
class documentation for details.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint_[Expression].set_translation(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">p_FoMo_F:</span> <span class="pre">numpy.ndarray[object[2,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[Expression]</span></span></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the position of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals
<code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>:</dt><dd><p>The desired position in meters to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> ordered
as (x, y). See class documentation for details.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PlanarJoint_[Expression].set_translational_velocity(self:</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">v_FoMo_F:</span> <span class="pre">numpy.ndarray[object[2,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.PlanarJoint_[Expression]</span></span></dt>
<dd><p>Sets the translational velocity, in meters per second, of this
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s Mo measured and expressed in frame F to <code class="docutils literal notranslate"><span class="pre">v_FoMo_F</span></code>.
The new translational velocity gets stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v_FoMo_F</span></code>:</dt><dd><p>The desired translational velocity of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters per
second.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint</span></code></p>
<p>This Joint allows two bodies to translate relative to one another
along a common axis. That is, given a frame Jp attached to the parent
body P and a frame Jc attached to the child body C (see the Joint
class’s documentation), this Joint allows frames Jp and Jc to
translate with respect to each other along an axis â. The translation
distance is defined positive when child body C translates along the
direction of â. Axis vector â is constant and has the same
components in both frames Jp and Jc, that is, <code class="docutils literal notranslate"><span class="pre">â_Jp</span> <span class="pre">=</span> <span class="pre">â_Jc</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">PrismaticJoint_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint.__init__(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint,</span> <span class="pre">name:</span> <span class="pre">str,</span> <span class="pre">frame_on_parent:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">frame_on_child:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">axis:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">pos_lower_limit:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">-inf,</span> <span class="pre">pos_upper_limit:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">inf,</span> <span class="pre">damping:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructor to create a prismatic joint between two bodies so that
frame Jp attached to the parent body P and frame Jc attached to the
child body C, translate relatively to one another along a common axis.
See this class’s documentation for further details on the definition
of these frames and translation distance. The first three arguments to
this constructor are those of the Joint class constructor. See the
Joint class’s documentation for details. The additional parameter
<code class="docutils literal notranslate"><span class="pre">axis</span></code> is:</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">axis</span></code>:</dt><dd><p>A vector in ℝ³ specifying the translation axis for this joint.
Given that frame Jc only translates with respect to Jp and there
is no relative rotation, the components of <code class="docutils literal notranslate"><span class="pre">axis</span></code> in either
frame Jp or Jc are exactly the same, that is, <code class="docutils literal notranslate"><span class="pre">axis_Jp</span> <span class="pre">=</span>
<span class="pre">axis_Jc</span></code>. This vector can have any length, only the direction is
used.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pos_lower_limit</span></code>:</dt><dd><p>Lower position limit, in meters, for the translation coordinate
(see get_translation()).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pos_upper_limit</span></code>:</dt><dd><p>Upper position limit, in meters, for the translation coordinate
(see get_translation()).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>Viscous damping coefficient, in N⋅s/m, used to model losses within
the joint. The damping force (in N) is modeled as <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">=</span>
<span class="pre">-damping⋅v</span></code>, i.e. opposing motion, with v the translational speed
for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see get_translation_rate()).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the L2 norm</strong><strong> of </strong><strong>axis is less than the square</strong> – </p></li>
<li><p><strong>root</strong><strong> of </strong><strong>machine epsilon.</strong> – </p></li>
<li><p><strong>RuntimeError if damping is negative.</strong> – </p></li>
<li><p><strong>RuntimeError if pos_lower_limit &gt; pos_upper_limit.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint.acceleration_lower_limit(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the acceleration lower limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters per
second squared.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint.acceleration_upper_limit(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the acceleration upper limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters per
second squared.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint.default_damping(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s default damping constant in N⋅s/m.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint.get_default_translation(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Gets the default translation. Wrapper for the more general
<code class="docutils literal notranslate"><span class="pre">Joint::default_positions()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The default translation of <code class="docutils literal notranslate"><span class="pre">this</span></code> stored in
<code class="docutils literal notranslate"><span class="pre">default_positions_</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint.get_translation(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Gets the translation distance of <code class="docutils literal notranslate"><span class="pre">this</span></code> mobilizer from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the MultibodyTree this joint belongs to.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The translation coordinate of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint read from
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint.get_translation_rate(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Gets the rate of change, in meters per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
translation distance (see get_translation()) from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the MultibodyTree this joint belongs to.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The rate of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s translation read from
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint.GetDamping(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the Context dependent damping coefficient stored as a
parameter in <code class="docutils literal notranslate"><span class="pre">context</span></code>. Refer to default_damping() for details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> joint belongs.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint.kTypeName</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint.position_lower_limit(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the position lower limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint.position_upper_limit(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the position upper limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint.set_default_damping(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint,</span> <span class="pre">damping:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default value of viscous damping for this joint, in N⋅s/m.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if damping is negative.</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>the MultibodyPlant must not be finalized.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint.set_default_translation(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint,</span> <span class="pre">translation:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">default_positions</span></code> of this joint (in this case a single
translation)</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">translation</span></code>:</dt><dd><p>The desired default translation of the joint</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint.set_random_translation_distribution(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint,</span> <span class="pre">translation:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint.set_translation(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">translation:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint</span></span></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the generalized coordinate corresponding to
the translation distance of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals <code class="docutils literal notranslate"><span class="pre">translation</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the MultibodyTree this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">translation</span></code>:</dt><dd><p>The desired translation in meters to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint.set_translation_rate(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">translation_dot:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint</span></span></dt>
<dd><p>Sets the rate of change, in meters per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
translation distance to <code class="docutils literal notranslate"><span class="pre">translation_dot</span></code>. The new rate of change
<code class="docutils literal notranslate"><span class="pre">translation_dot</span></code> gets stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the MultibodyTree this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">translation_dot</span></code>:</dt><dd><p>The desired rate of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joints’s translation in
meters per second.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint.SetDamping(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">damping:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the value of the viscous damping coefficient for this joint,
stored as a parameter in <code class="docutils literal notranslate"><span class="pre">context</span></code>. Refer to default_damping() for
details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> joint belongs.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>The damping value.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if damping is negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint.translation_axis(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the axis of translation for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint as a unit vector.
Since the components of this axis in either frame Jp or Jc are the
same (see this class’s documentation for frame definitions) then,
<code class="docutils literal notranslate"><span class="pre">axis</span> <span class="pre">=</span> <span class="pre">axis_Jp</span> <span class="pre">=</span> <span class="pre">axis_Jc</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint.velocity_lower_limit(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the velocity lower limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters per
second.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint.velocity_upper_limit(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the velocity upper limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters per
second.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">PrismaticJoint_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">PrismaticJoint_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">PrismaticJoint_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd]</span></code></p>
<p>This Joint allows two bodies to translate relative to one another
along a common axis. That is, given a frame Jp attached to the parent
body P and a frame Jc attached to the child body C (see the Joint
class’s documentation), this Joint allows frames Jp and Jc to
translate with respect to each other along an axis â. The translation
distance is defined positive when child body C translates along the
direction of â. Axis vector â is constant and has the same
components in both frames Jp and Jc, that is, <code class="docutils literal notranslate"><span class="pre">â_Jp</span> <span class="pre">=</span> <span class="pre">â_Jc</span></code>.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd],</span> <span class="pre">name:</span> <span class="pre">str,</span> <span class="pre">frame_on_parent:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">frame_on_child:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">axis:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">pos_lower_limit:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">-inf,</span> <span class="pre">pos_upper_limit:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">inf,</span> <span class="pre">damping:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructor to create a prismatic joint between two bodies so that
frame Jp attached to the parent body P and frame Jc attached to the
child body C, translate relatively to one another along a common axis.
See this class’s documentation for further details on the definition
of these frames and translation distance. The first three arguments to
this constructor are those of the Joint class constructor. See the
Joint class’s documentation for details. The additional parameter
<code class="docutils literal notranslate"><span class="pre">axis</span></code> is:</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">axis</span></code>:</dt><dd><p>A vector in ℝ³ specifying the translation axis for this joint.
Given that frame Jc only translates with respect to Jp and there
is no relative rotation, the components of <code class="docutils literal notranslate"><span class="pre">axis</span></code> in either
frame Jp or Jc are exactly the same, that is, <code class="docutils literal notranslate"><span class="pre">axis_Jp</span> <span class="pre">=</span>
<span class="pre">axis_Jc</span></code>. This vector can have any length, only the direction is
used.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pos_lower_limit</span></code>:</dt><dd><p>Lower position limit, in meters, for the translation coordinate
(see get_translation()).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pos_upper_limit</span></code>:</dt><dd><p>Upper position limit, in meters, for the translation coordinate
(see get_translation()).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>Viscous damping coefficient, in N⋅s/m, used to model losses within
the joint. The damping force (in N) is modeled as <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">=</span>
<span class="pre">-damping⋅v</span></code>, i.e. opposing motion, with v the translational speed
for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see get_translation_rate()).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the L2 norm</strong><strong> of </strong><strong>axis is less than the square</strong> – </p></li>
<li><p><strong>root</strong><strong> of </strong><strong>machine epsilon.</strong> – </p></li>
<li><p><strong>RuntimeError if damping is negative.</strong> – </p></li>
<li><p><strong>RuntimeError if pos_lower_limit &gt; pos_upper_limit.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_[AutoDiffXd].acceleration_lower_limit(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the acceleration lower limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters per
second squared.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_[AutoDiffXd].acceleration_upper_limit(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the acceleration upper limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters per
second squared.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_[AutoDiffXd].default_damping(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s default damping constant in N⋅s/m.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_[AutoDiffXd].get_default_translation(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Gets the default translation. Wrapper for the more general
<code class="docutils literal notranslate"><span class="pre">Joint::default_positions()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The default translation of <code class="docutils literal notranslate"><span class="pre">this</span></code> stored in
<code class="docutils literal notranslate"><span class="pre">default_positions_</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_[AutoDiffXd].get_translation(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd</span></span></dt>
<dd><p>Gets the translation distance of <code class="docutils literal notranslate"><span class="pre">this</span></code> mobilizer from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the MultibodyTree this joint belongs to.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The translation coordinate of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint read from
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_[AutoDiffXd].get_translation_rate(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd</span></span></dt>
<dd><p>Gets the rate of change, in meters per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
translation distance (see get_translation()) from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the MultibodyTree this joint belongs to.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The rate of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s translation read from
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_[AutoDiffXd].GetDamping(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd</span></span></dt>
<dd><p>Returns the Context dependent damping coefficient stored as a
parameter in <code class="docutils literal notranslate"><span class="pre">context</span></code>. Refer to default_damping() for details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> joint belongs.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_[AutoDiffXd].kTypeName</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_[AutoDiffXd].position_lower_limit(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the position lower limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_[AutoDiffXd].position_upper_limit(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the position upper limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_[AutoDiffXd].set_default_damping(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd],</span> <span class="pre">damping:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default value of viscous damping for this joint, in N⋅s/m.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if damping is negative.</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>the MultibodyPlant must not be finalized.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_[AutoDiffXd].set_default_translation(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd],</span> <span class="pre">translation:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">default_positions</span></code> of this joint (in this case a single
translation)</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">translation</span></code>:</dt><dd><p>The desired default translation of the joint</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_[AutoDiffXd].set_random_translation_distribution(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd],</span> <span class="pre">translation:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_[AutoDiffXd].set_translation(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">translation:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd]</span></span></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the generalized coordinate corresponding to
the translation distance of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals <code class="docutils literal notranslate"><span class="pre">translation</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the MultibodyTree this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">translation</span></code>:</dt><dd><p>The desired translation in meters to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_[AutoDiffXd].set_translation_rate(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">translation_dot:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd]</span></span></dt>
<dd><p>Sets the rate of change, in meters per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
translation distance to <code class="docutils literal notranslate"><span class="pre">translation_dot</span></code>. The new rate of change
<code class="docutils literal notranslate"><span class="pre">translation_dot</span></code> gets stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the MultibodyTree this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">translation_dot</span></code>:</dt><dd><p>The desired rate of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joints’s translation in
meters per second.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_[AutoDiffXd].SetDamping(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">damping:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the value of the viscous damping coefficient for this joint,
stored as a parameter in <code class="docutils literal notranslate"><span class="pre">context</span></code>. Refer to default_damping() for
details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> joint belongs.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>The damping value.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if damping is negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_[AutoDiffXd].translation_axis(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the axis of translation for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint as a unit vector.
Since the components of this axis in either frame Jp or Jc are the
same (see this class’s documentation for frame definitions) then,
<code class="docutils literal notranslate"><span class="pre">axis</span> <span class="pre">=</span> <span class="pre">axis_Jp</span> <span class="pre">=</span> <span class="pre">axis_Jc</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_[AutoDiffXd].velocity_lower_limit(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the velocity lower limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters per
second.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_[AutoDiffXd].velocity_upper_limit(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the velocity upper limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters per
second.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[Expression]</span></code></p>
<p>This Joint allows two bodies to translate relative to one another
along a common axis. That is, given a frame Jp attached to the parent
body P and a frame Jc attached to the child body C (see the Joint
class’s documentation), this Joint allows frames Jp and Jc to
translate with respect to each other along an axis â. The translation
distance is defined positive when child body C translates along the
direction of â. Axis vector â is constant and has the same
components in both frames Jp and Jc, that is, <code class="docutils literal notranslate"><span class="pre">â_Jp</span> <span class="pre">=</span> <span class="pre">â_Jc</span></code>.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_[Expression].__init__(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[Expression],</span> <span class="pre">name:</span> <span class="pre">str,</span> <span class="pre">frame_on_parent:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">frame_on_child:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">axis:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">pos_lower_limit:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">-inf,</span> <span class="pre">pos_upper_limit:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">inf,</span> <span class="pre">damping:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructor to create a prismatic joint between two bodies so that
frame Jp attached to the parent body P and frame Jc attached to the
child body C, translate relatively to one another along a common axis.
See this class’s documentation for further details on the definition
of these frames and translation distance. The first three arguments to
this constructor are those of the Joint class constructor. See the
Joint class’s documentation for details. The additional parameter
<code class="docutils literal notranslate"><span class="pre">axis</span></code> is:</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">axis</span></code>:</dt><dd><p>A vector in ℝ³ specifying the translation axis for this joint.
Given that frame Jc only translates with respect to Jp and there
is no relative rotation, the components of <code class="docutils literal notranslate"><span class="pre">axis</span></code> in either
frame Jp or Jc are exactly the same, that is, <code class="docutils literal notranslate"><span class="pre">axis_Jp</span> <span class="pre">=</span>
<span class="pre">axis_Jc</span></code>. This vector can have any length, only the direction is
used.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pos_lower_limit</span></code>:</dt><dd><p>Lower position limit, in meters, for the translation coordinate
(see get_translation()).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pos_upper_limit</span></code>:</dt><dd><p>Upper position limit, in meters, for the translation coordinate
(see get_translation()).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>Viscous damping coefficient, in N⋅s/m, used to model losses within
the joint. The damping force (in N) is modeled as <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">=</span>
<span class="pre">-damping⋅v</span></code>, i.e. opposing motion, with v the translational speed
for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see get_translation_rate()).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the L2 norm</strong><strong> of </strong><strong>axis is less than the square</strong> – </p></li>
<li><p><strong>root</strong><strong> of </strong><strong>machine epsilon.</strong> – </p></li>
<li><p><strong>RuntimeError if damping is negative.</strong> – </p></li>
<li><p><strong>RuntimeError if pos_lower_limit &gt; pos_upper_limit.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_[Expression].acceleration_lower_limit(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the acceleration lower limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters per
second squared.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_[Expression].acceleration_upper_limit(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the acceleration upper limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters per
second squared.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_[Expression].default_damping(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s default damping constant in N⋅s/m.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_[Expression].get_default_translation(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Gets the default translation. Wrapper for the more general
<code class="docutils literal notranslate"><span class="pre">Joint::default_positions()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The default translation of <code class="docutils literal notranslate"><span class="pre">this</span></code> stored in
<code class="docutils literal notranslate"><span class="pre">default_positions_</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_[Expression].get_translation(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd><p>Gets the translation distance of <code class="docutils literal notranslate"><span class="pre">this</span></code> mobilizer from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the MultibodyTree this joint belongs to.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The translation coordinate of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint read from
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_[Expression].get_translation_rate(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd><p>Gets the rate of change, in meters per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
translation distance (see get_translation()) from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the MultibodyTree this joint belongs to.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The rate of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s translation read from
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_[Expression].GetDamping(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd><p>Returns the Context dependent damping coefficient stored as a
parameter in <code class="docutils literal notranslate"><span class="pre">context</span></code>. Refer to default_damping() for details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> joint belongs.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_[Expression].kTypeName</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_[Expression].position_lower_limit(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the position lower limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_[Expression].position_upper_limit(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the position upper limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_[Expression].set_default_damping(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[Expression],</span> <span class="pre">damping:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default value of viscous damping for this joint, in N⋅s/m.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if damping is negative.</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>the MultibodyPlant must not be finalized.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_[Expression].set_default_translation(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[Expression],</span> <span class="pre">translation:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">default_positions</span></code> of this joint (in this case a single
translation)</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">translation</span></code>:</dt><dd><p>The desired default translation of the joint</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_[Expression].set_random_translation_distribution(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[Expression],</span> <span class="pre">translation:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_[Expression].set_translation(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">translation:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[Expression]</span></span></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the generalized coordinate corresponding to
the translation distance of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals <code class="docutils literal notranslate"><span class="pre">translation</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the MultibodyTree this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">translation</span></code>:</dt><dd><p>The desired translation in meters to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_[Expression].set_translation_rate(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">translation_dot:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[Expression]</span></span></dt>
<dd><p>Sets the rate of change, in meters per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
translation distance to <code class="docutils literal notranslate"><span class="pre">translation_dot</span></code>. The new rate of change
<code class="docutils literal notranslate"><span class="pre">translation_dot</span></code> gets stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the MultibodyTree this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">translation_dot</span></code>:</dt><dd><p>The desired rate of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joints’s translation in
meters per second.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_[Expression].SetDamping(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">damping:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the value of the viscous damping coefficient for this joint,
stored as a parameter in <code class="docutils literal notranslate"><span class="pre">context</span></code>. Refer to default_damping() for
details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> joint belongs.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>The damping value.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if damping is negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_[Expression].translation_axis(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the axis of translation for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint as a unit vector.
Since the components of this axis in either frame Jp or Jc are the
same (see this class’s documentation for frame definitions) then,
<code class="docutils literal notranslate"><span class="pre">axis</span> <span class="pre">=</span> <span class="pre">axis_Jp</span> <span class="pre">=</span> <span class="pre">axis_Jc</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_[Expression].velocity_lower_limit(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the velocity lower limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters per
second.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticJoint_[Expression].velocity_upper_limit(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the velocity upper limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters per
second.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticSpring</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ForceElement</span></code></p>
<p>This ForceElement models a linear spring attached to a PrismaticJoint
and applies a force to that joint according to</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">k</span><span class="err">⋅</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x₀</span><span class="p">)</span>
</pre></div>
</div>
</details><p>where x₀ is the nominal (zero spring force) position in meters, x is
the joint position in meters, f is the spring force in Newtons and k
is the spring constant in N/m. Note that joint damping exists within
the PrismaticJoint itself, and so is not included here.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is different from the LinearSpringDamper: this
PrismaticSpring is associated with a joint, while the
LinearSpringDamper connects two bodies.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">PrismaticSpring_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticSpring.__init__(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticSpring,</span> <span class="pre">joint:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint,</span> <span class="pre">nominal_position:</span> <span class="pre">float,</span> <span class="pre">stiffness:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructor for a linear spring attached to the given prismatic joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">nominal_position</span></code>:</dt><dd><p>The nominal position of the spring x₀, in meters, at which the
spring applies no force. This is measured the same way as the
generalized position of the prismatic joint.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">stiffness</span></code>:</dt><dd><p>The stiffness k of the spring in N/m.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if stiffness is</strong><strong> (</strong><strong>strictly</strong><strong>) </strong><strong>negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticSpring.joint(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticSpring)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticSpring.nominal_position(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticSpring)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticSpring.stiffness(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticSpring)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticSpring_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">PrismaticSpring_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">PrismaticSpring_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">PrismaticSpring_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticSpring_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ForceElement_[AutoDiffXd]</span></code></p>
<p>This ForceElement models a linear spring attached to a PrismaticJoint
and applies a force to that joint according to</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">k</span><span class="err">⋅</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x₀</span><span class="p">)</span>
</pre></div>
</div>
</details><p>where x₀ is the nominal (zero spring force) position in meters, x is
the joint position in meters, f is the spring force in Newtons and k
is the spring constant in N/m. Note that joint damping exists within
the PrismaticJoint itself, and so is not included here.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is different from the LinearSpringDamper: this
PrismaticSpring is associated with a joint, while the
LinearSpringDamper connects two bodies.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticSpring_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticSpring_[AutoDiffXd],</span> <span class="pre">joint:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd],</span> <span class="pre">nominal_position:</span> <span class="pre">float,</span> <span class="pre">stiffness:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructor for a linear spring attached to the given prismatic joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">nominal_position</span></code>:</dt><dd><p>The nominal position of the spring x₀, in meters, at which the
spring applies no force. This is measured the same way as the
generalized position of the prismatic joint.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">stiffness</span></code>:</dt><dd><p>The stiffness k of the spring in N/m.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if stiffness is</strong><strong> (</strong><strong>strictly</strong><strong>) </strong><strong>negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticSpring_[AutoDiffXd].joint(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticSpring_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticSpring_[AutoDiffXd].nominal_position(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticSpring_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticSpring_[AutoDiffXd].stiffness(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticSpring_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticSpring_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ForceElement_[Expression]</span></code></p>
<p>This ForceElement models a linear spring attached to a PrismaticJoint
and applies a force to that joint according to</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">k</span><span class="err">⋅</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x₀</span><span class="p">)</span>
</pre></div>
</div>
</details><p>where x₀ is the nominal (zero spring force) position in meters, x is
the joint position in meters, f is the spring force in Newtons and k
is the spring constant in N/m. Note that joint damping exists within
the PrismaticJoint itself, and so is not included here.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is different from the LinearSpringDamper: this
PrismaticSpring is associated with a joint, while the
LinearSpringDamper connects two bodies.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticSpring_[Expression].__init__(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticSpring_[Expression],</span> <span class="pre">joint:</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[Expression],</span> <span class="pre">nominal_position:</span> <span class="pre">float,</span> <span class="pre">stiffness:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructor for a linear spring attached to the given prismatic joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">nominal_position</span></code>:</dt><dd><p>The nominal position of the spring x₀, in meters, at which the
spring applies no force. This is measured the same way as the
generalized position of the prismatic joint.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">stiffness</span></code>:</dt><dd><p>The stiffness k of the spring in N/m.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if stiffness is</strong><strong> (</strong><strong>strictly</strong><strong>) </strong><strong>negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticSpring_[Expression].joint(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticSpring_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.PrismaticJoint_[Expression]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticSpring_[Expression].nominal_position(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticSpring_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">PrismaticSpring_[Expression].stiffness(self:</span> <span class="pre">pydrake.multibody.tree.PrismaticSpring_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint</span></code></p>
<p>This Joint allows two bodies to move freely relatively to one another.
That is, given a frame F attached to the parent body P and a frame M
attached to the child body B (see the Joint class’s documentation),
this Joint allows frame M to translate and rotate freely with respect
to F, introducing six degrees of freedom. This Joint introduces four
generalized positions to describe the orientation <code class="docutils literal notranslate"><span class="pre">R_FM</span></code> of frame M
in F with a quaternion <code class="docutils literal notranslate"><span class="pre">q_FM</span></code>, and three generalized positions to
describe the translation of frame M’s origin in F with a position
vector <code class="docutils literal notranslate"><span class="pre">p_FM</span></code>. The seven entries of the configuration vector q are
ordered <code class="docutils literal notranslate"><span class="pre">(q_FM,</span> <span class="pre">p_FM)</span></code> with the quaternion, ordered wxyz (scalar
then vector), preceding the translation vector. As generalized
velocities, this Joint introduces the angular velocity <code class="docutils literal notranslate"><span class="pre">w_FM</span></code> of
frame M in F and the linear velocity <code class="docutils literal notranslate"><span class="pre">v_FM</span></code> of frame M’s origin in
frame F, ordered <code class="docutils literal notranslate"><span class="pre">(w_FM,</span> <span class="pre">v_FM)</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">QuaternionFloatingJoint_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint.__init__(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint,</span> <span class="pre">name:</span> <span class="pre">str,</span> <span class="pre">frame_on_parent:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">frame_on_child:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">angular_damping:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">translational_damping:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructor for a QuaternionFloatingJoint granting six degrees of
freedom to an outboard frame M attached to the child body B with
respect to an inboard frame F attached to the parent body P. The
orientation of frame M in F is represented by a quaternion <code class="docutils literal notranslate"><span class="pre">q_FM</span></code>
while the position of F in M is given by a position vector <code class="docutils literal notranslate"><span class="pre">p_FM</span></code>
expressed in frame F. See this class’s documentation for further
details on the definition of these frames, get_quaternion() and
get_translation() for an explanation of the configuration of this
joint, and get_angular_velocity() and get_translational_velocity() for
an explanation of the generalized velocities.</p>
<p>This constructor signature creates a joint with no joint limits, i.e.
the joint position, velocity and acceleration limits are the pair
<code class="docutils literal notranslate"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. These can be set using the Joint methods
set_position_limits(), set_velocity_limits() and
set_acceleration_limits().</p>
<p>The first three arguments to this constructor are those of the Joint
class constructor. See the Joint class’s documentation for details.
The additional parameters are:</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angular_damping</span></code>:</dt><dd><p>Viscous damping coefficient in N⋅m⋅s for the angular component of
this joint’s velocity, used to model losses within the joint. See
documentation of default_angular_damping() for details on
modelling of the damping force.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">translational_damping</span></code>:</dt><dd><p>Viscous damping coefficient in N⋅s/m for the translational
component of this joint’s velocity, used to model losses within
the joint. See documentation of default_translational_damping()
for details on modelling of the damping force.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if angular_damping is negative.</strong> – </p></li>
<li><p><strong>RuntimeError if translational_damping is negative.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint.default_angular_damping(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s default angular damping constant in N⋅m⋅s.
The damping torque (in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span> <span class="pre">-damping⋅ω</span></code>, i.e.
opposing motion, with ω the angular velocity of frame M in F (see
get_angular_velocity()) and τ the torque on child body B (to which M
is rigidly attached).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint.default_translational_damping(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s default translational damping constant in
N⋅s/m. The damping force (in N) is modeled as <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">-damping⋅v</span></code> i.e.
opposing motion, with v the translational velocity of frame M in F
(see get_translational_velocity()) and f the force on child body B at
Mo.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint.get_angular_velocity(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Retrieves from <code class="docutils literal notranslate"><span class="pre">context</span></code> the angular velocity <code class="docutils literal notranslate"><span class="pre">w_FM</span></code> of the child
frame M in the parent frame F, expressed in F.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">w_FM</span></code>:</dt><dd><p>A vector in ℝ³ with the angular velocity of the child frame M in
the parent frame F, expressed in F. Refer to this class’s
documentation for further details and definitions of these frames.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint.get_default_quaternion(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.eigen_geometry.Quaternion</span></span></dt>
<dd><p>Gets the default quaternion <code class="docutils literal notranslate"><span class="pre">q_FM</span></code> for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The default quaternion <code class="docutils literal notranslate"><span class="pre">q_FM</span></code> of <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint.get_default_translation(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns this joint’s default translation as the position vector
p_FoMo_F from Fo (inboard frame F’s origin) to Mo (outboard frame M’s
origin), expressed in inboard frame F.</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">This</span></code>:</dt><dd><p>joint’s default translation as the position vector p_FM.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint.get_quaternion(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.eigen_geometry.Quaternion</span></span></dt>
<dd><p>Gets the quaternion <code class="docutils literal notranslate"><span class="pre">q_FM</span></code> that represents the orientation of
outboard frame M in the inboard frame F. Refer to the documentation
for this class for details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">q_FM</span></code>:</dt><dd><p>The quaternion representing the orientation of frame M in F.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint.get_translation(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the position vector p_FoMo_F from Fo (inboard frame F’s
origin) to Mo (outboard frame M’s origin), expressed in inboard frame
F.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Class documentation describes inboard frame F and outboard frame
M.</p>
</div>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_FM</span></code>:</dt><dd><p>The position vector from Fo (frame F’s origin) to Mo (frame M’s
origin), expressed in frame F.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint.get_translational_velocity(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Retrieves from <code class="docutils literal notranslate"><span class="pre">context</span></code> the translational velocity <code class="docutils literal notranslate"><span class="pre">v_FM</span></code> of the
child frame M’s origin as measured and expressed in the parent frame
F.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">v_FM</span></code>:</dt><dd><p>A vector in ℝ³ with the translational velocity of the origin of
child frame M in the parent frame F, expressed in F. Refer to this
class’s documentation for further details and definitions of these
frames.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint.GetPose(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RigidTransform</span></span></dt>
<dd><p>Returns the pose <code class="docutils literal notranslate"><span class="pre">X_FM</span></code> of the outboard frame M as measured and
expressed in the inboard frame F. Refer to the documentation for this
class for details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">X_FM</span></code>:</dt><dd><p>The pose of frame M in frame F.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint.kTypeName</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint.set_angular_velocity(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">w_FM:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint</span></span></dt>
<dd><p>Sets in <code class="docutils literal notranslate"><span class="pre">context</span></code> the state for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint so that the angular
velocity of the child frame M in the parent frame F is <code class="docutils literal notranslate"><span class="pre">w_FM</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">w_FM</span></code>:</dt><dd><p>A vector in ℝ³ with the angular velocity of the child frame M in
the parent frame F, expressed in F. Refer to this class’s
documentation for further details and definitions of these frames.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint.set_default_quaternion(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint,</span> <span class="pre">q_FM:</span> <span class="pre">pydrake.common.eigen_geometry.Quaternion)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default quaternion <code class="docutils literal notranslate"><span class="pre">q_FM</span></code> of this joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">q_FM</span></code>:</dt><dd><p>The desired default quaternion of the joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint.set_default_translation(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint,</span> <span class="pre">translation:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets this joint’s default position vector <code class="docutils literal notranslate"><span class="pre">p_FM</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_FM</span></code>:</dt><dd><p>position vector p_FoMo_F from Fo (inboard frame F’s origin) to Mo
(outboard frame M’s origin), expressed in frame F.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint.set_random_quaternion_distribution(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint,</span> <span class="pre">q_FM:</span> <span class="pre">pydrake.common.eigen_geometry.Quaternion_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>(Advanced) Sets the random distribution that the orientation of this
joint will be randomly sampled from. If a translation (position)
distribution has already been set with stochastic variables, it will
remain so. Otherwise translation will be set to this joint’s zero
configuration. See get_quaternion() for details on the orientation
representation.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Use caution when setting a quaternion distribution. A naive
uniform sampling of each component will not lead to a uniform
sampling of the unit sphere. See
<code class="docutils literal notranslate"><span class="pre">set_random_quaternion_distribution_to_uniform()</span></code> for the most
common case of uniformly sampling rotations.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint.set_random_quaternion_distribution_to_uniform(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the random distribution such that the orientation of this joint
will be randomly sampled using uniformly sampled rotations.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint.set_random_translation_distribution(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint,</span> <span class="pre">translation:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>For this joint, sets the random distribution that the translation of
this joint will be randomly sampled from. If a quaternion distribution
has already been set with stochastic variables, it will remain so.
Otherwise the quaternion will be set to this joint’s zero orientation.
See get_translation() for details on the translation representation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint.set_translational_velocity(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">v_FM:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint</span></span></dt>
<dd><p>Sets in <code class="docutils literal notranslate"><span class="pre">context</span></code> the state for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint so that the
translational velocity of the child frame M’s origin in the parent
frame F is <code class="docutils literal notranslate"><span class="pre">v_FM</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v_FM</span></code>:</dt><dd><p>A vector in ℝ³ with the translational velocity of the child frame
M’s origin in the parent frame F, expressed in F. Refer to this
class’s documentation for further details and definitions of these
frames.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint.SetOrientation(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">R:</span> <span class="pre">pydrake.math.RotationMatrix)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint</span></span></dt>
<dd><p>Sets the quaternion in <code class="docutils literal notranslate"><span class="pre">context</span></code> so this joint’s orientation is
consistent with the given <code class="docutils literal notranslate"><span class="pre">R_FM</span></code> rotation matrix.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_FM</span></code>:</dt><dd><p>The rotation matrix relating the orientation of frame F and frame
M.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint.SetPose(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">X_FM:</span> <span class="pre">pydrake.math.RigidTransform)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint</span></span></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">context</span></code> to store <code class="docutils literal notranslate"><span class="pre">X_FM</span></code> the pose of frame M measured and
expressed in frame F.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_FM</span></code>:</dt><dd><p>The desired pose of frame M in frame F to be stored in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint.SetQuaternion(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">q_FM:</span> <span class="pre">pydrake.common.eigen_geometry.Quaternion)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint</span></span></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the orientation of frame M in F is given by
the input quaternion <code class="docutils literal notranslate"><span class="pre">q_FM</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">q_FM</span></code>:</dt><dd><p>Quaternion relating frames F and M to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint.SetTranslation(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">p_FM:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint</span></span></dt>
<dd><p>For this joint, stores the position vector <code class="docutils literal notranslate"><span class="pre">p_FM</span></code> in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_FM</span></code>:</dt><dd><p>position vector p_FoMo_F from Fo (inboard frame F’s origin) to Mo
(outboard frame M’s origin), expressed in frame F.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">QuaternionFloatingJoint_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QuaternionFloatingJoint_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">QuaternionFloatingJoint_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd]</span></code></p>
<p>This Joint allows two bodies to move freely relatively to one another.
That is, given a frame F attached to the parent body P and a frame M
attached to the child body B (see the Joint class’s documentation),
this Joint allows frame M to translate and rotate freely with respect
to F, introducing six degrees of freedom. This Joint introduces four
generalized positions to describe the orientation <code class="docutils literal notranslate"><span class="pre">R_FM</span></code> of frame M
in F with a quaternion <code class="docutils literal notranslate"><span class="pre">q_FM</span></code>, and three generalized positions to
describe the translation of frame M’s origin in F with a position
vector <code class="docutils literal notranslate"><span class="pre">p_FM</span></code>. The seven entries of the configuration vector q are
ordered <code class="docutils literal notranslate"><span class="pre">(q_FM,</span> <span class="pre">p_FM)</span></code> with the quaternion, ordered wxyz (scalar
then vector), preceding the translation vector. As generalized
velocities, this Joint introduces the angular velocity <code class="docutils literal notranslate"><span class="pre">w_FM</span></code> of
frame M in F and the linear velocity <code class="docutils literal notranslate"><span class="pre">v_FM</span></code> of frame M’s origin in
frame F, ordered <code class="docutils literal notranslate"><span class="pre">(w_FM,</span> <span class="pre">v_FM)</span></code>.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[AutoDiffXd],</span> <span class="pre">name:</span> <span class="pre">str,</span> <span class="pre">frame_on_parent:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">frame_on_child:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">angular_damping:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">translational_damping:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructor for a QuaternionFloatingJoint granting six degrees of
freedom to an outboard frame M attached to the child body B with
respect to an inboard frame F attached to the parent body P. The
orientation of frame M in F is represented by a quaternion <code class="docutils literal notranslate"><span class="pre">q_FM</span></code>
while the position of F in M is given by a position vector <code class="docutils literal notranslate"><span class="pre">p_FM</span></code>
expressed in frame F. See this class’s documentation for further
details on the definition of these frames, get_quaternion() and
get_translation() for an explanation of the configuration of this
joint, and get_angular_velocity() and get_translational_velocity() for
an explanation of the generalized velocities.</p>
<p>This constructor signature creates a joint with no joint limits, i.e.
the joint position, velocity and acceleration limits are the pair
<code class="docutils literal notranslate"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. These can be set using the Joint methods
set_position_limits(), set_velocity_limits() and
set_acceleration_limits().</p>
<p>The first three arguments to this constructor are those of the Joint
class constructor. See the Joint class’s documentation for details.
The additional parameters are:</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angular_damping</span></code>:</dt><dd><p>Viscous damping coefficient in N⋅m⋅s for the angular component of
this joint’s velocity, used to model losses within the joint. See
documentation of default_angular_damping() for details on
modelling of the damping force.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">translational_damping</span></code>:</dt><dd><p>Viscous damping coefficient in N⋅s/m for the translational
component of this joint’s velocity, used to model losses within
the joint. See documentation of default_translational_damping()
for details on modelling of the damping force.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if angular_damping is negative.</strong> – </p></li>
<li><p><strong>RuntimeError if translational_damping is negative.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[AutoDiffXd].default_angular_damping(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s default angular damping constant in N⋅m⋅s.
The damping torque (in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span> <span class="pre">-damping⋅ω</span></code>, i.e.
opposing motion, with ω the angular velocity of frame M in F (see
get_angular_velocity()) and τ the torque on child body B (to which M
is rigidly attached).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[AutoDiffXd].default_translational_damping(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s default translational damping constant in
N⋅s/m. The damping force (in N) is modeled as <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">-damping⋅v</span></code> i.e.
opposing motion, with v the translational velocity of frame M in F
(see get_translational_velocity()) and f the force on child body B at
Mo.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[AutoDiffXd].get_angular_velocity(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Retrieves from <code class="docutils literal notranslate"><span class="pre">context</span></code> the angular velocity <code class="docutils literal notranslate"><span class="pre">w_FM</span></code> of the child
frame M in the parent frame F, expressed in F.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">w_FM</span></code>:</dt><dd><p>A vector in ℝ³ with the angular velocity of the child frame M in
the parent frame F, expressed in F. Refer to this class’s
documentation for further details and definitions of these frames.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[AutoDiffXd].get_default_quaternion(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.eigen_geometry.Quaternion</span></span></dt>
<dd><p>Gets the default quaternion <code class="docutils literal notranslate"><span class="pre">q_FM</span></code> for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The default quaternion <code class="docutils literal notranslate"><span class="pre">q_FM</span></code> of <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[AutoDiffXd].get_default_translation(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns this joint’s default translation as the position vector
p_FoMo_F from Fo (inboard frame F’s origin) to Mo (outboard frame M’s
origin), expressed in inboard frame F.</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">This</span></code>:</dt><dd><p>joint’s default translation as the position vector p_FM.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[AutoDiffXd].get_quaternion(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.eigen_geometry.Quaternion_[AutoDiffXd]</span></span></dt>
<dd><p>Gets the quaternion <code class="docutils literal notranslate"><span class="pre">q_FM</span></code> that represents the orientation of
outboard frame M in the inboard frame F. Refer to the documentation
for this class for details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">q_FM</span></code>:</dt><dd><p>The quaternion representing the orientation of frame M in F.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[AutoDiffXd].get_translation(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the position vector p_FoMo_F from Fo (inboard frame F’s
origin) to Mo (outboard frame M’s origin), expressed in inboard frame
F.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Class documentation describes inboard frame F and outboard frame
M.</p>
</div>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_FM</span></code>:</dt><dd><p>The position vector from Fo (frame F’s origin) to Mo (frame M’s
origin), expressed in frame F.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[AutoDiffXd].get_translational_velocity(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Retrieves from <code class="docutils literal notranslate"><span class="pre">context</span></code> the translational velocity <code class="docutils literal notranslate"><span class="pre">v_FM</span></code> of the
child frame M’s origin as measured and expressed in the parent frame
F.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">v_FM</span></code>:</dt><dd><p>A vector in ℝ³ with the translational velocity of the origin of
child frame M in the parent frame F, expressed in F. Refer to this
class’s documentation for further details and definitions of these
frames.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[AutoDiffXd].GetPose(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RigidTransform_[AutoDiffXd]</span></span></dt>
<dd><p>Returns the pose <code class="docutils literal notranslate"><span class="pre">X_FM</span></code> of the outboard frame M as measured and
expressed in the inboard frame F. Refer to the documentation for this
class for details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">X_FM</span></code>:</dt><dd><p>The pose of frame M in frame F.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[AutoDiffXd].kTypeName</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[AutoDiffXd].set_angular_velocity(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">w_FM:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[AutoDiffXd]</span></span></dt>
<dd><p>Sets in <code class="docutils literal notranslate"><span class="pre">context</span></code> the state for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint so that the angular
velocity of the child frame M in the parent frame F is <code class="docutils literal notranslate"><span class="pre">w_FM</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">w_FM</span></code>:</dt><dd><p>A vector in ℝ³ with the angular velocity of the child frame M in
the parent frame F, expressed in F. Refer to this class’s
documentation for further details and definitions of these frames.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[AutoDiffXd].set_default_quaternion(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[AutoDiffXd],</span> <span class="pre">q_FM:</span> <span class="pre">pydrake.common.eigen_geometry.Quaternion)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default quaternion <code class="docutils literal notranslate"><span class="pre">q_FM</span></code> of this joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">q_FM</span></code>:</dt><dd><p>The desired default quaternion of the joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[AutoDiffXd].set_default_translation(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[AutoDiffXd],</span> <span class="pre">translation:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets this joint’s default position vector <code class="docutils literal notranslate"><span class="pre">p_FM</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_FM</span></code>:</dt><dd><p>position vector p_FoMo_F from Fo (inboard frame F’s origin) to Mo
(outboard frame M’s origin), expressed in frame F.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[AutoDiffXd].set_random_quaternion_distribution(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[AutoDiffXd],</span> <span class="pre">q_FM:</span> <span class="pre">pydrake.common.eigen_geometry.Quaternion_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>(Advanced) Sets the random distribution that the orientation of this
joint will be randomly sampled from. If a translation (position)
distribution has already been set with stochastic variables, it will
remain so. Otherwise translation will be set to this joint’s zero
configuration. See get_quaternion() for details on the orientation
representation.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Use caution when setting a quaternion distribution. A naive
uniform sampling of each component will not lead to a uniform
sampling of the unit sphere. See
<code class="docutils literal notranslate"><span class="pre">set_random_quaternion_distribution_to_uniform()</span></code> for the most
common case of uniformly sampling rotations.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[AutoDiffXd].set_random_quaternion_distribution_to_uniform(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the random distribution such that the orientation of this joint
will be randomly sampled using uniformly sampled rotations.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[AutoDiffXd].set_random_translation_distribution(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[AutoDiffXd],</span> <span class="pre">translation:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>For this joint, sets the random distribution that the translation of
this joint will be randomly sampled from. If a quaternion distribution
has already been set with stochastic variables, it will remain so.
Otherwise the quaternion will be set to this joint’s zero orientation.
See get_translation() for details on the translation representation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[AutoDiffXd].set_translational_velocity(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">v_FM:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[AutoDiffXd]</span></span></dt>
<dd><p>Sets in <code class="docutils literal notranslate"><span class="pre">context</span></code> the state for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint so that the
translational velocity of the child frame M’s origin in the parent
frame F is <code class="docutils literal notranslate"><span class="pre">v_FM</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v_FM</span></code>:</dt><dd><p>A vector in ℝ³ with the translational velocity of the child frame
M’s origin in the parent frame F, expressed in F. Refer to this
class’s documentation for further details and definitions of these
frames.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[AutoDiffXd].SetOrientation(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">R:</span> <span class="pre">pydrake.math.RotationMatrix_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[AutoDiffXd]</span></span></dt>
<dd><p>Sets the quaternion in <code class="docutils literal notranslate"><span class="pre">context</span></code> so this joint’s orientation is
consistent with the given <code class="docutils literal notranslate"><span class="pre">R_FM</span></code> rotation matrix.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_FM</span></code>:</dt><dd><p>The rotation matrix relating the orientation of frame F and frame
M.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[AutoDiffXd].SetPose(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">X_FM:</span> <span class="pre">pydrake.math.RigidTransform_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[AutoDiffXd]</span></span></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">context</span></code> to store <code class="docutils literal notranslate"><span class="pre">X_FM</span></code> the pose of frame M measured and
expressed in frame F.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_FM</span></code>:</dt><dd><p>The desired pose of frame M in frame F to be stored in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[AutoDiffXd].SetQuaternion(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">q_FM:</span> <span class="pre">pydrake.common.eigen_geometry.Quaternion_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[AutoDiffXd]</span></span></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the orientation of frame M in F is given by
the input quaternion <code class="docutils literal notranslate"><span class="pre">q_FM</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">q_FM</span></code>:</dt><dd><p>Quaternion relating frames F and M to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[AutoDiffXd].SetTranslation(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">p_FM:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[AutoDiffXd]</span></span></dt>
<dd><p>For this joint, stores the position vector <code class="docutils literal notranslate"><span class="pre">p_FM</span></code> in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_FM</span></code>:</dt><dd><p>position vector p_FoMo_F from Fo (inboard frame F’s origin) to Mo
(outboard frame M’s origin), expressed in frame F.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[Expression]</span></code></p>
<p>This Joint allows two bodies to move freely relatively to one another.
That is, given a frame F attached to the parent body P and a frame M
attached to the child body B (see the Joint class’s documentation),
this Joint allows frame M to translate and rotate freely with respect
to F, introducing six degrees of freedom. This Joint introduces four
generalized positions to describe the orientation <code class="docutils literal notranslate"><span class="pre">R_FM</span></code> of frame M
in F with a quaternion <code class="docutils literal notranslate"><span class="pre">q_FM</span></code>, and three generalized positions to
describe the translation of frame M’s origin in F with a position
vector <code class="docutils literal notranslate"><span class="pre">p_FM</span></code>. The seven entries of the configuration vector q are
ordered <code class="docutils literal notranslate"><span class="pre">(q_FM,</span> <span class="pre">p_FM)</span></code> with the quaternion, ordered wxyz (scalar
then vector), preceding the translation vector. As generalized
velocities, this Joint introduces the angular velocity <code class="docutils literal notranslate"><span class="pre">w_FM</span></code> of
frame M in F and the linear velocity <code class="docutils literal notranslate"><span class="pre">v_FM</span></code> of frame M’s origin in
frame F, ordered <code class="docutils literal notranslate"><span class="pre">(w_FM,</span> <span class="pre">v_FM)</span></code>.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[Expression].__init__(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[Expression],</span> <span class="pre">name:</span> <span class="pre">str,</span> <span class="pre">frame_on_parent:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">frame_on_child:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">angular_damping:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">translational_damping:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructor for a QuaternionFloatingJoint granting six degrees of
freedom to an outboard frame M attached to the child body B with
respect to an inboard frame F attached to the parent body P. The
orientation of frame M in F is represented by a quaternion <code class="docutils literal notranslate"><span class="pre">q_FM</span></code>
while the position of F in M is given by a position vector <code class="docutils literal notranslate"><span class="pre">p_FM</span></code>
expressed in frame F. See this class’s documentation for further
details on the definition of these frames, get_quaternion() and
get_translation() for an explanation of the configuration of this
joint, and get_angular_velocity() and get_translational_velocity() for
an explanation of the generalized velocities.</p>
<p>This constructor signature creates a joint with no joint limits, i.e.
the joint position, velocity and acceleration limits are the pair
<code class="docutils literal notranslate"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. These can be set using the Joint methods
set_position_limits(), set_velocity_limits() and
set_acceleration_limits().</p>
<p>The first three arguments to this constructor are those of the Joint
class constructor. See the Joint class’s documentation for details.
The additional parameters are:</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angular_damping</span></code>:</dt><dd><p>Viscous damping coefficient in N⋅m⋅s for the angular component of
this joint’s velocity, used to model losses within the joint. See
documentation of default_angular_damping() for details on
modelling of the damping force.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">translational_damping</span></code>:</dt><dd><p>Viscous damping coefficient in N⋅s/m for the translational
component of this joint’s velocity, used to model losses within
the joint. See documentation of default_translational_damping()
for details on modelling of the damping force.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if angular_damping is negative.</strong> – </p></li>
<li><p><strong>RuntimeError if translational_damping is negative.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[Expression].default_angular_damping(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s default angular damping constant in N⋅m⋅s.
The damping torque (in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span> <span class="pre">-damping⋅ω</span></code>, i.e.
opposing motion, with ω the angular velocity of frame M in F (see
get_angular_velocity()) and τ the torque on child body B (to which M
is rigidly attached).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[Expression].default_translational_damping(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s default translational damping constant in
N⋅s/m. The damping force (in N) is modeled as <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">-damping⋅v</span></code> i.e.
opposing motion, with v the translational velocity of frame M in F
(see get_translational_velocity()) and f the force on child body B at
Mo.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[Expression].get_angular_velocity(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Retrieves from <code class="docutils literal notranslate"><span class="pre">context</span></code> the angular velocity <code class="docutils literal notranslate"><span class="pre">w_FM</span></code> of the child
frame M in the parent frame F, expressed in F.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">w_FM</span></code>:</dt><dd><p>A vector in ℝ³ with the angular velocity of the child frame M in
the parent frame F, expressed in F. Refer to this class’s
documentation for further details and definitions of these frames.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[Expression].get_default_quaternion(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.eigen_geometry.Quaternion</span></span></dt>
<dd><p>Gets the default quaternion <code class="docutils literal notranslate"><span class="pre">q_FM</span></code> for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The default quaternion <code class="docutils literal notranslate"><span class="pre">q_FM</span></code> of <code class="docutils literal notranslate"><span class="pre">this</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[Expression].get_default_translation(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns this joint’s default translation as the position vector
p_FoMo_F from Fo (inboard frame F’s origin) to Mo (outboard frame M’s
origin), expressed in inboard frame F.</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">This</span></code>:</dt><dd><p>joint’s default translation as the position vector p_FM.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[Expression].get_quaternion(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.common.eigen_geometry.Quaternion_[Expression]</span></span></dt>
<dd><p>Gets the quaternion <code class="docutils literal notranslate"><span class="pre">q_FM</span></code> that represents the orientation of
outboard frame M in the inboard frame F. Refer to the documentation
for this class for details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">q_FM</span></code>:</dt><dd><p>The quaternion representing the orientation of frame M in F.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[Expression].get_translation(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the position vector p_FoMo_F from Fo (inboard frame F’s
origin) to Mo (outboard frame M’s origin), expressed in inboard frame
F.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Class documentation describes inboard frame F and outboard frame
M.</p>
</div>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_FM</span></code>:</dt><dd><p>The position vector from Fo (frame F’s origin) to Mo (frame M’s
origin), expressed in frame F.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[Expression].get_translational_velocity(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Retrieves from <code class="docutils literal notranslate"><span class="pre">context</span></code> the translational velocity <code class="docutils literal notranslate"><span class="pre">v_FM</span></code> of the
child frame M’s origin as measured and expressed in the parent frame
F.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">v_FM</span></code>:</dt><dd><p>A vector in ℝ³ with the translational velocity of the origin of
child frame M in the parent frame F, expressed in F. Refer to this
class’s documentation for further details and definitions of these
frames.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[Expression].GetPose(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RigidTransform_[Expression]</span></span></dt>
<dd><p>Returns the pose <code class="docutils literal notranslate"><span class="pre">X_FM</span></code> of the outboard frame M as measured and
expressed in the inboard frame F. Refer to the documentation for this
class for details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">X_FM</span></code>:</dt><dd><p>The pose of frame M in frame F.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[Expression].kTypeName</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[Expression].set_angular_velocity(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">w_FM:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[Expression]</span></span></dt>
<dd><p>Sets in <code class="docutils literal notranslate"><span class="pre">context</span></code> the state for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint so that the angular
velocity of the child frame M in the parent frame F is <code class="docutils literal notranslate"><span class="pre">w_FM</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">w_FM</span></code>:</dt><dd><p>A vector in ℝ³ with the angular velocity of the child frame M in
the parent frame F, expressed in F. Refer to this class’s
documentation for further details and definitions of these frames.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[Expression].set_default_quaternion(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[Expression],</span> <span class="pre">q_FM:</span> <span class="pre">pydrake.common.eigen_geometry.Quaternion)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default quaternion <code class="docutils literal notranslate"><span class="pre">q_FM</span></code> of this joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">q_FM</span></code>:</dt><dd><p>The desired default quaternion of the joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[Expression].set_default_translation(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[Expression],</span> <span class="pre">translation:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets this joint’s default position vector <code class="docutils literal notranslate"><span class="pre">p_FM</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_FM</span></code>:</dt><dd><p>position vector p_FoMo_F from Fo (inboard frame F’s origin) to Mo
(outboard frame M’s origin), expressed in frame F.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[Expression].set_random_quaternion_distribution(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[Expression],</span> <span class="pre">q_FM:</span> <span class="pre">pydrake.common.eigen_geometry.Quaternion_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>(Advanced) Sets the random distribution that the orientation of this
joint will be randomly sampled from. If a translation (position)
distribution has already been set with stochastic variables, it will
remain so. Otherwise translation will be set to this joint’s zero
configuration. See get_quaternion() for details on the orientation
representation.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Use caution when setting a quaternion distribution. A naive
uniform sampling of each component will not lead to a uniform
sampling of the unit sphere. See
<code class="docutils literal notranslate"><span class="pre">set_random_quaternion_distribution_to_uniform()</span></code> for the most
common case of uniformly sampling rotations.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[Expression].set_random_quaternion_distribution_to_uniform(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the random distribution such that the orientation of this joint
will be randomly sampled using uniformly sampled rotations.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[Expression].set_random_translation_distribution(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[Expression],</span> <span class="pre">translation:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>For this joint, sets the random distribution that the translation of
this joint will be randomly sampled from. If a quaternion distribution
has already been set with stochastic variables, it will remain so.
Otherwise the quaternion will be set to this joint’s zero orientation.
See get_translation() for details on the translation representation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[Expression].set_translational_velocity(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">v_FM:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[Expression]</span></span></dt>
<dd><p>Sets in <code class="docutils literal notranslate"><span class="pre">context</span></code> the state for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint so that the
translational velocity of the child frame M’s origin in the parent
frame F is <code class="docutils literal notranslate"><span class="pre">v_FM</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v_FM</span></code>:</dt><dd><p>A vector in ℝ³ with the translational velocity of the child frame
M’s origin in the parent frame F, expressed in F. Refer to this
class’s documentation for further details and definitions of these
frames.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[Expression].SetOrientation(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">R:</span> <span class="pre">pydrake.math.RotationMatrix_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[Expression]</span></span></dt>
<dd><p>Sets the quaternion in <code class="docutils literal notranslate"><span class="pre">context</span></code> so this joint’s orientation is
consistent with the given <code class="docutils literal notranslate"><span class="pre">R_FM</span></code> rotation matrix.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_FM</span></code>:</dt><dd><p>The rotation matrix relating the orientation of frame F and frame
M.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[Expression].SetPose(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">X_FM:</span> <span class="pre">pydrake.math.RigidTransform_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[Expression]</span></span></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">context</span></code> to store <code class="docutils literal notranslate"><span class="pre">X_FM</span></code> the pose of frame M measured and
expressed in frame F.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_FM</span></code>:</dt><dd><p>The desired pose of frame M in frame F to be stored in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[Expression].SetQuaternion(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">q_FM:</span> <span class="pre">pydrake.common.eigen_geometry.Quaternion_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[Expression]</span></span></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the orientation of frame M in F is given by
the input quaternion <code class="docutils literal notranslate"><span class="pre">q_FM</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">q_FM</span></code>:</dt><dd><p>Quaternion relating frames F and M to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">QuaternionFloatingJoint_[Expression].SetTranslation(self:</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">p_FM:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.QuaternionFloatingJoint_[Expression]</span></span></dt>
<dd><p>For this joint, stores the position vector <code class="docutils literal notranslate"><span class="pre">p_FM</span></code> in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_FM</span></code>:</dt><dd><p>position vector p_FoMo_F from Fo (inboard frame F’s origin) to Mo
(outboard frame M’s origin), expressed in frame F.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint</span></code></p>
<p>This Joint allows two bodies to rotate relatively to one another
around a common axis. That is, given a frame Jp attached to the parent
body P and a frame Jc attached to the child body C (see the Joint
class’s documentation), this Joint allows frames Jp and Jc to rotate
with respect to each other about an axis â. The rotation angle’s sign
is defined such that child body C rotates about axis â according to
the right hand rule, with thumb aligned in the axis direction. Axis
vector â is constant and has the same components in both frames Jp
and Jc, that is, <code class="docutils literal notranslate"><span class="pre">â_Jp</span> <span class="pre">=</span> <span class="pre">â_Jc</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">RevoluteJoint_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.tree.RevoluteJoint, name: str, frame_on_parent: pydrake.multibody.tree.Frame, frame_on_child: pydrake.multibody.tree.Frame, axis: numpy.ndarray[numpy.float64[3, 1]], damping: float = 0) -&gt; None</p></li>
</ol>
<p>Constructor to create a revolute joint between two bodies so that
frame Jp attached to the parent body P and frame Jc attached to the
child body C, rotate relatively to one another about a common axis.
See this class’s documentation for further details on the definition
of these frames and rotation angle. This constructor signature creates
a joint with no joint limits, i.e. the joint position, velocity and
acceleration limits are the pair <code class="docutils literal notranslate"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. The first three
arguments to this constructor are those of the Joint class
constructor. See the Joint class’s documentation for details. The
additional parameters are:</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">axis</span></code>:</dt><dd><p>A vector in ℝ³ specifying the axis of revolution for this joint.
Given that frame Jc only rotates with respect to Jp and their
origins are coincident at all times, the components of <code class="docutils literal notranslate"><span class="pre">axis</span></code> in
either frame Jp or Jc are exactly the same, that is, <code class="docutils literal notranslate"><span class="pre">axis_Jp</span> <span class="pre">=</span>
<span class="pre">axis_Jc</span></code>. In other words, <code class="docutils literal notranslate"><span class="pre">axis_Jp</span></code> (or <code class="docutils literal notranslate"><span class="pre">axis_Jc</span></code>) is the
eigenvector of <code class="docutils literal notranslate"><span class="pre">R_JpJc</span></code> with eigenvalue equal to one. This
vector can have any length, only the direction is used. This
method aborts if <code class="docutils literal notranslate"><span class="pre">axis</span></code> is the zero vector.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>Viscous damping coefficient, in N⋅m⋅s, used to model losses within
the joint. The damping torque (in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span>
<span class="pre">-damping⋅ω</span></code>, i.e. opposing motion, with ω the angular rate for
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see get_angular_rate()).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if damping is negative.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.tree.RevoluteJoint, name: str, frame_on_parent: pydrake.multibody.tree.Frame, frame_on_child: pydrake.multibody.tree.Frame, axis: numpy.ndarray[numpy.float64[3, 1]], pos_lower_limit: float, pos_upper_limit: float, damping: float = 0.0) -&gt; None</p></li>
</ol>
<p>Constructor to create a revolute joint between two bodies so that
frame Jp attached to the parent body P and frame Jc attached to the
child body C, rotate relatively to one another about a common axis.
See this class’s documentation for further details on the definition
of these frames and rotation angle. The first three arguments to this
constructor are those of the Joint class constructor. See the Joint
class’s documentation for details. The additional parameters are:</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">axis</span></code>:</dt><dd><p>A vector in ℝ³ specifying the axis of revolution for this joint.
Given that frame Jc only rotates with respect to Jp and their
origins are coincident at all times, the components of <code class="docutils literal notranslate"><span class="pre">axis</span></code> in
either frame Jp or Jc are exactly the same, that is, <code class="docutils literal notranslate"><span class="pre">axis_Jp</span> <span class="pre">=</span>
<span class="pre">axis_Jc</span></code>. In other words, <code class="docutils literal notranslate"><span class="pre">axis_Jp</span></code> (or <code class="docutils literal notranslate"><span class="pre">axis_Jc</span></code>) is the
eigenvector of <code class="docutils literal notranslate"><span class="pre">R_JpJc</span></code> with eigenvalue equal to one. This
vector can have any length, only the direction is used.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pos_lower_limit</span></code>:</dt><dd><p>Lower position limit, in radians, for the rotation coordinate (see
get_angle()).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pos_upper_limit</span></code>:</dt><dd><p>Upper position limit, in radians, for the rotation coordinate (see
get_angle()).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>Viscous damping coefficient, in N⋅m⋅s, used to model losses within
the joint. The damping torque (in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span>
<span class="pre">-damping⋅ω</span></code>, i.e. opposing motion, with ω the angular rate for
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see get_angular_rate()).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the L2 norm</strong><strong> of </strong><strong>axis is less than the square</strong> – </p></li>
<li><p><strong>root</strong><strong> of </strong><strong>machine epsilon.</strong> – </p></li>
<li><p><strong>RuntimeError if damping is negative.</strong> – </p></li>
<li><p><strong>RuntimeError if pos_lower_limit &gt; pos_upper_limit.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint.acceleration_lower_limit(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the acceleration lower limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in radians /
s².</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint.acceleration_upper_limit(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the acceleration upper limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in radians /
s².</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint.default_damping(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s default damping constant in N⋅m⋅s.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint.get_angle(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Gets the rotation angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> mobilizer from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the MultibodyTree this joint belongs to.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The angle coordinate of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint.get_angular_rate(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Gets the rate of change, in radians per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
angle (see get_angle()) from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the MultibodyTree this joint belongs to.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The rate of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s angle as stored in the
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint.get_default_angle(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Gets the default rotation angle. Wrapper for the more general
<code class="docutils literal notranslate"><span class="pre">Joint::default_positions()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The default angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> stored in <code class="docutils literal notranslate"><span class="pre">default_positions_</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint.GetDamping(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the Context dependent damping coefficient stored as a
parameter in <code class="docutils literal notranslate"><span class="pre">context</span></code>. Refer to default_damping() for details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> joint belongs.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint.kTypeName</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint.position_lower_limit(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the position lower limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in radians.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint.position_upper_limit(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the position upper limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in radians.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint.revolute_axis(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the axis of revolution of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint as a unit vector.
Since the measures of this axis in either frame F or M are the same
(see this class’s documentation for frame definitions) then, <code class="docutils literal notranslate"><span class="pre">axis</span> <span class="pre">=</span>
<span class="pre">axis_Jp</span> <span class="pre">=</span> <span class="pre">axis_Jc</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint.set_angle(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">angle:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint</span></span></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the generalized coordinate corresponding
to the rotation angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals <code class="docutils literal notranslate"><span class="pre">angle</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the MultibodyTree this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angle</span></code>:</dt><dd><p>The desired angle in radians to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint.set_angular_rate(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">angle:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint</span></span></dt>
<dd><p>Sets the rate of change, in radians per second, of this <code class="docutils literal notranslate"><span class="pre">this</span></code>
joint’s angle to <code class="docutils literal notranslate"><span class="pre">angle</span></code>. The new rate of change <code class="docutils literal notranslate"><span class="pre">angle</span></code> gets
stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the MultibodyTree this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angle</span></code>:</dt><dd><p>The desired rate of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joints’s angle in radians
per second. (Should have been named <code class="docutils literal notranslate"><span class="pre">rate</span></code> or <code class="docutils literal notranslate"><span class="pre">angular_rate</span></code>.)</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint.set_default_angle(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint,</span> <span class="pre">angle:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">default_positions</span></code> of this joint (in this case a single
angle).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angle</span></code>:</dt><dd><p>The desired default angle of the joint</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint.set_default_damping(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint,</span> <span class="pre">damping:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default value of viscous damping for this joint, in N⋅m⋅s.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if damping is negative.</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>the MultibodyPlant must not be finalized.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint.set_random_angle_distribution(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint,</span> <span class="pre">angle:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint.SetDamping(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">damping:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the value of the viscous damping coefficient for this joint,
stored as a parameter in <code class="docutils literal notranslate"><span class="pre">context</span></code>. Refer to default_damping() for
details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> joint belongs.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>The damping value.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if damping is negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint.velocity_lower_limit(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the velocity lower limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in radians / s.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint.velocity_upper_limit(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the velocity upper limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in radians / s.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">RevoluteJoint_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">RevoluteJoint_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">RevoluteJoint_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd]</span></code></p>
<p>This Joint allows two bodies to rotate relatively to one another
around a common axis. That is, given a frame Jp attached to the parent
body P and a frame Jc attached to the child body C (see the Joint
class’s documentation), this Joint allows frames Jp and Jc to rotate
with respect to each other about an axis â. The rotation angle’s sign
is defined such that child body C rotates about axis â according to
the right hand rule, with thumb aligned in the axis direction. Axis
vector â is constant and has the same components in both frames Jp
and Jc, that is, <code class="docutils literal notranslate"><span class="pre">â_Jp</span> <span class="pre">=</span> <span class="pre">â_Jc</span></code>.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_on_child: pydrake.multibody.tree.Frame_[AutoDiffXd], axis: numpy.ndarray[numpy.float64[3, 1]], damping: float = 0) -&gt; None</p></li>
</ol>
<p>Constructor to create a revolute joint between two bodies so that
frame Jp attached to the parent body P and frame Jc attached to the
child body C, rotate relatively to one another about a common axis.
See this class’s documentation for further details on the definition
of these frames and rotation angle. This constructor signature creates
a joint with no joint limits, i.e. the joint position, velocity and
acceleration limits are the pair <code class="docutils literal notranslate"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. The first three
arguments to this constructor are those of the Joint class
constructor. See the Joint class’s documentation for details. The
additional parameters are:</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">axis</span></code>:</dt><dd><p>A vector in ℝ³ specifying the axis of revolution for this joint.
Given that frame Jc only rotates with respect to Jp and their
origins are coincident at all times, the components of <code class="docutils literal notranslate"><span class="pre">axis</span></code> in
either frame Jp or Jc are exactly the same, that is, <code class="docutils literal notranslate"><span class="pre">axis_Jp</span> <span class="pre">=</span>
<span class="pre">axis_Jc</span></code>. In other words, <code class="docutils literal notranslate"><span class="pre">axis_Jp</span></code> (or <code class="docutils literal notranslate"><span class="pre">axis_Jc</span></code>) is the
eigenvector of <code class="docutils literal notranslate"><span class="pre">R_JpJc</span></code> with eigenvalue equal to one. This
vector can have any length, only the direction is used. This
method aborts if <code class="docutils literal notranslate"><span class="pre">axis</span></code> is the zero vector.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>Viscous damping coefficient, in N⋅m⋅s, used to model losses within
the joint. The damping torque (in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span>
<span class="pre">-damping⋅ω</span></code>, i.e. opposing motion, with ω the angular rate for
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see get_angular_rate()).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if damping is negative.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_on_child: pydrake.multibody.tree.Frame_[AutoDiffXd], axis: numpy.ndarray[numpy.float64[3, 1]], pos_lower_limit: float, pos_upper_limit: float, damping: float = 0.0) -&gt; None</p></li>
</ol>
<p>Constructor to create a revolute joint between two bodies so that
frame Jp attached to the parent body P and frame Jc attached to the
child body C, rotate relatively to one another about a common axis.
See this class’s documentation for further details on the definition
of these frames and rotation angle. The first three arguments to this
constructor are those of the Joint class constructor. See the Joint
class’s documentation for details. The additional parameters are:</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">axis</span></code>:</dt><dd><p>A vector in ℝ³ specifying the axis of revolution for this joint.
Given that frame Jc only rotates with respect to Jp and their
origins are coincident at all times, the components of <code class="docutils literal notranslate"><span class="pre">axis</span></code> in
either frame Jp or Jc are exactly the same, that is, <code class="docutils literal notranslate"><span class="pre">axis_Jp</span> <span class="pre">=</span>
<span class="pre">axis_Jc</span></code>. In other words, <code class="docutils literal notranslate"><span class="pre">axis_Jp</span></code> (or <code class="docutils literal notranslate"><span class="pre">axis_Jc</span></code>) is the
eigenvector of <code class="docutils literal notranslate"><span class="pre">R_JpJc</span></code> with eigenvalue equal to one. This
vector can have any length, only the direction is used.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pos_lower_limit</span></code>:</dt><dd><p>Lower position limit, in radians, for the rotation coordinate (see
get_angle()).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pos_upper_limit</span></code>:</dt><dd><p>Upper position limit, in radians, for the rotation coordinate (see
get_angle()).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>Viscous damping coefficient, in N⋅m⋅s, used to model losses within
the joint. The damping torque (in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span>
<span class="pre">-damping⋅ω</span></code>, i.e. opposing motion, with ω the angular rate for
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see get_angular_rate()).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the L2 norm</strong><strong> of </strong><strong>axis is less than the square</strong> – </p></li>
<li><p><strong>root</strong><strong> of </strong><strong>machine epsilon.</strong> – </p></li>
<li><p><strong>RuntimeError if damping is negative.</strong> – </p></li>
<li><p><strong>RuntimeError if pos_lower_limit &gt; pos_upper_limit.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_[AutoDiffXd].acceleration_lower_limit(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the acceleration lower limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in radians /
s².</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_[AutoDiffXd].acceleration_upper_limit(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the acceleration upper limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in radians /
s².</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_[AutoDiffXd].default_damping(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s default damping constant in N⋅m⋅s.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_[AutoDiffXd].get_angle(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd</span></span></dt>
<dd><p>Gets the rotation angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> mobilizer from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the MultibodyTree this joint belongs to.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The angle coordinate of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_[AutoDiffXd].get_angular_rate(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd</span></span></dt>
<dd><p>Gets the rate of change, in radians per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
angle (see get_angle()) from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the MultibodyTree this joint belongs to.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The rate of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s angle as stored in the
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_[AutoDiffXd].get_default_angle(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Gets the default rotation angle. Wrapper for the more general
<code class="docutils literal notranslate"><span class="pre">Joint::default_positions()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The default angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> stored in <code class="docutils literal notranslate"><span class="pre">default_positions_</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_[AutoDiffXd].GetDamping(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd</span></span></dt>
<dd><p>Returns the Context dependent damping coefficient stored as a
parameter in <code class="docutils literal notranslate"><span class="pre">context</span></code>. Refer to default_damping() for details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> joint belongs.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_[AutoDiffXd].kTypeName</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_[AutoDiffXd].position_lower_limit(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the position lower limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in radians.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_[AutoDiffXd].position_upper_limit(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the position upper limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in radians.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_[AutoDiffXd].revolute_axis(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the axis of revolution of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint as a unit vector.
Since the measures of this axis in either frame F or M are the same
(see this class’s documentation for frame definitions) then, <code class="docutils literal notranslate"><span class="pre">axis</span> <span class="pre">=</span>
<span class="pre">axis_Jp</span> <span class="pre">=</span> <span class="pre">axis_Jc</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_[AutoDiffXd].set_angle(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">angle:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd]</span></span></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the generalized coordinate corresponding
to the rotation angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals <code class="docutils literal notranslate"><span class="pre">angle</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the MultibodyTree this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angle</span></code>:</dt><dd><p>The desired angle in radians to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_[AutoDiffXd].set_angular_rate(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">angle:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd]</span></span></dt>
<dd><p>Sets the rate of change, in radians per second, of this <code class="docutils literal notranslate"><span class="pre">this</span></code>
joint’s angle to <code class="docutils literal notranslate"><span class="pre">angle</span></code>. The new rate of change <code class="docutils literal notranslate"><span class="pre">angle</span></code> gets
stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the MultibodyTree this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angle</span></code>:</dt><dd><p>The desired rate of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joints’s angle in radians
per second. (Should have been named <code class="docutils literal notranslate"><span class="pre">rate</span></code> or <code class="docutils literal notranslate"><span class="pre">angular_rate</span></code>.)</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_[AutoDiffXd].set_default_angle(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd],</span> <span class="pre">angle:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">default_positions</span></code> of this joint (in this case a single
angle).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angle</span></code>:</dt><dd><p>The desired default angle of the joint</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_[AutoDiffXd].set_default_damping(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd],</span> <span class="pre">damping:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default value of viscous damping for this joint, in N⋅m⋅s.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if damping is negative.</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>the MultibodyPlant must not be finalized.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_[AutoDiffXd].set_random_angle_distribution(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd],</span> <span class="pre">angle:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_[AutoDiffXd].SetDamping(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">damping:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the value of the viscous damping coefficient for this joint,
stored as a parameter in <code class="docutils literal notranslate"><span class="pre">context</span></code>. Refer to default_damping() for
details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> joint belongs.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>The damping value.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if damping is negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_[AutoDiffXd].velocity_lower_limit(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the velocity lower limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in radians / s.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_[AutoDiffXd].velocity_upper_limit(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the velocity upper limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in radians / s.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[Expression]</span></code></p>
<p>This Joint allows two bodies to rotate relatively to one another
around a common axis. That is, given a frame Jp attached to the parent
body P and a frame Jc attached to the child body C (see the Joint
class’s documentation), this Joint allows frames Jp and Jc to rotate
with respect to each other about an axis â. The rotation angle’s sign
is defined such that child body C rotates about axis â according to
the right hand rule, with thumb aligned in the axis direction. Axis
vector â is constant and has the same components in both frames Jp
and Jc, that is, <code class="docutils literal notranslate"><span class="pre">â_Jp</span> <span class="pre">=</span> <span class="pre">â_Jc</span></code>.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.tree.RevoluteJoint_[Expression], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[Expression], frame_on_child: pydrake.multibody.tree.Frame_[Expression], axis: numpy.ndarray[numpy.float64[3, 1]], damping: float = 0) -&gt; None</p></li>
</ol>
<p>Constructor to create a revolute joint between two bodies so that
frame Jp attached to the parent body P and frame Jc attached to the
child body C, rotate relatively to one another about a common axis.
See this class’s documentation for further details on the definition
of these frames and rotation angle. This constructor signature creates
a joint with no joint limits, i.e. the joint position, velocity and
acceleration limits are the pair <code class="docutils literal notranslate"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. The first three
arguments to this constructor are those of the Joint class
constructor. See the Joint class’s documentation for details. The
additional parameters are:</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">axis</span></code>:</dt><dd><p>A vector in ℝ³ specifying the axis of revolution for this joint.
Given that frame Jc only rotates with respect to Jp and their
origins are coincident at all times, the components of <code class="docutils literal notranslate"><span class="pre">axis</span></code> in
either frame Jp or Jc are exactly the same, that is, <code class="docutils literal notranslate"><span class="pre">axis_Jp</span> <span class="pre">=</span>
<span class="pre">axis_Jc</span></code>. In other words, <code class="docutils literal notranslate"><span class="pre">axis_Jp</span></code> (or <code class="docutils literal notranslate"><span class="pre">axis_Jc</span></code>) is the
eigenvector of <code class="docutils literal notranslate"><span class="pre">R_JpJc</span></code> with eigenvalue equal to one. This
vector can have any length, only the direction is used. This
method aborts if <code class="docutils literal notranslate"><span class="pre">axis</span></code> is the zero vector.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>Viscous damping coefficient, in N⋅m⋅s, used to model losses within
the joint. The damping torque (in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span>
<span class="pre">-damping⋅ω</span></code>, i.e. opposing motion, with ω the angular rate for
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see get_angular_rate()).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if damping is negative.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.tree.RevoluteJoint_[Expression], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[Expression], frame_on_child: pydrake.multibody.tree.Frame_[Expression], axis: numpy.ndarray[numpy.float64[3, 1]], pos_lower_limit: float, pos_upper_limit: float, damping: float = 0.0) -&gt; None</p></li>
</ol>
<p>Constructor to create a revolute joint between two bodies so that
frame Jp attached to the parent body P and frame Jc attached to the
child body C, rotate relatively to one another about a common axis.
See this class’s documentation for further details on the definition
of these frames and rotation angle. The first three arguments to this
constructor are those of the Joint class constructor. See the Joint
class’s documentation for details. The additional parameters are:</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">axis</span></code>:</dt><dd><p>A vector in ℝ³ specifying the axis of revolution for this joint.
Given that frame Jc only rotates with respect to Jp and their
origins are coincident at all times, the components of <code class="docutils literal notranslate"><span class="pre">axis</span></code> in
either frame Jp or Jc are exactly the same, that is, <code class="docutils literal notranslate"><span class="pre">axis_Jp</span> <span class="pre">=</span>
<span class="pre">axis_Jc</span></code>. In other words, <code class="docutils literal notranslate"><span class="pre">axis_Jp</span></code> (or <code class="docutils literal notranslate"><span class="pre">axis_Jc</span></code>) is the
eigenvector of <code class="docutils literal notranslate"><span class="pre">R_JpJc</span></code> with eigenvalue equal to one. This
vector can have any length, only the direction is used.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pos_lower_limit</span></code>:</dt><dd><p>Lower position limit, in radians, for the rotation coordinate (see
get_angle()).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pos_upper_limit</span></code>:</dt><dd><p>Upper position limit, in radians, for the rotation coordinate (see
get_angle()).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>Viscous damping coefficient, in N⋅m⋅s, used to model losses within
the joint. The damping torque (in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span>
<span class="pre">-damping⋅ω</span></code>, i.e. opposing motion, with ω the angular rate for
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see get_angular_rate()).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the L2 norm</strong><strong> of </strong><strong>axis is less than the square</strong> – </p></li>
<li><p><strong>root</strong><strong> of </strong><strong>machine epsilon.</strong> – </p></li>
<li><p><strong>RuntimeError if damping is negative.</strong> – </p></li>
<li><p><strong>RuntimeError if pos_lower_limit &gt; pos_upper_limit.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_[Expression].acceleration_lower_limit(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the acceleration lower limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in radians /
s².</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_[Expression].acceleration_upper_limit(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the acceleration upper limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in radians /
s².</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_[Expression].default_damping(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s default damping constant in N⋅m⋅s.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_[Expression].get_angle(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd><p>Gets the rotation angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> mobilizer from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the MultibodyTree this joint belongs to.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The angle coordinate of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_[Expression].get_angular_rate(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd><p>Gets the rate of change, in radians per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
angle (see get_angle()) from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the MultibodyTree this joint belongs to.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The rate of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s angle as stored in the
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_[Expression].get_default_angle(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Gets the default rotation angle. Wrapper for the more general
<code class="docutils literal notranslate"><span class="pre">Joint::default_positions()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The default angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> stored in <code class="docutils literal notranslate"><span class="pre">default_positions_</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_[Expression].GetDamping(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd><p>Returns the Context dependent damping coefficient stored as a
parameter in <code class="docutils literal notranslate"><span class="pre">context</span></code>. Refer to default_damping() for details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> joint belongs.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_[Expression].kTypeName</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_[Expression].position_lower_limit(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the position lower limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in radians.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_[Expression].position_upper_limit(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the position upper limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in radians.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_[Expression].revolute_axis(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the axis of revolution of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint as a unit vector.
Since the measures of this axis in either frame F or M are the same
(see this class’s documentation for frame definitions) then, <code class="docutils literal notranslate"><span class="pre">axis</span> <span class="pre">=</span>
<span class="pre">axis_Jp</span> <span class="pre">=</span> <span class="pre">axis_Jc</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_[Expression].set_angle(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">angle:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[Expression]</span></span></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the generalized coordinate corresponding
to the rotation angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals <code class="docutils literal notranslate"><span class="pre">angle</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the MultibodyTree this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angle</span></code>:</dt><dd><p>The desired angle in radians to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_[Expression].set_angular_rate(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">angle:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[Expression]</span></span></dt>
<dd><p>Sets the rate of change, in radians per second, of this <code class="docutils literal notranslate"><span class="pre">this</span></code>
joint’s angle to <code class="docutils literal notranslate"><span class="pre">angle</span></code>. The new rate of change <code class="docutils literal notranslate"><span class="pre">angle</span></code> gets
stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the MultibodyTree this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angle</span></code>:</dt><dd><p>The desired rate of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joints’s angle in radians
per second. (Should have been named <code class="docutils literal notranslate"><span class="pre">rate</span></code> or <code class="docutils literal notranslate"><span class="pre">angular_rate</span></code>.)</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_[Expression].set_default_angle(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[Expression],</span> <span class="pre">angle:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">default_positions</span></code> of this joint (in this case a single
angle).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angle</span></code>:</dt><dd><p>The desired default angle of the joint</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_[Expression].set_default_damping(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[Expression],</span> <span class="pre">damping:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default value of viscous damping for this joint, in N⋅m⋅s.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if damping is negative.</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>the MultibodyPlant must not be finalized.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_[Expression].set_random_angle_distribution(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[Expression],</span> <span class="pre">angle:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_[Expression].SetDamping(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">damping:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the value of the viscous damping coefficient for this joint,
stored as a parameter in <code class="docutils literal notranslate"><span class="pre">context</span></code>. Refer to default_damping() for
details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> joint belongs.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>The damping value.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if damping is negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_[Expression].velocity_lower_limit(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the velocity lower limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in radians / s.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteJoint_[Expression].velocity_upper_limit(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the velocity upper limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in radians / s.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteSpring</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ForceElement</span></code></p>
<p>This ForceElement models a torsional spring attached to a
RevoluteJoint and applies a torque to that joint</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">τ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">k</span><span class="err">⋅</span><span class="p">(</span><span class="n">θ</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">θ₀</span><span class="p">)</span>
</pre></div>
</div>
</details><p>where θ₀ is the nominal joint position. Note that joint damping exists
within the RevoluteJoint itself, and so is not included here.</p>
<p>The k (stiffness) and θ₀ (nominal angle) specified in the constructor
are kept as default values. These parameters are stored within the
context and can be accessed and set by context dependent
getters/setters.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">RevoluteSpring_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteSpring.__init__(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteSpring,</span> <span class="pre">joint:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint,</span> <span class="pre">nominal_angle:</span> <span class="pre">float,</span> <span class="pre">stiffness:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructor for a spring attached to the given joint</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">nominal_angle</span></code>:</dt><dd><p>The nominal angle of the spring θ₀, in radians, at which the
spring applies no moment.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">stiffness</span></code>:</dt><dd><p>The stiffness k of the spring in N⋅m/rad.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if stiffness is negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteSpring.default_nominal_angle(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteSpring)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the default spring reference angle θ₀ in radians.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteSpring.default_stiffness(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteSpring)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the default stiffness constant k in N⋅m/rad.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteSpring.GetNominalAngle(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteSpring,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the Context dependent nominal angle θ₀ stored as a parameter
in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> spring belongs.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">returns</span></code>:</dt><dd><p>the nominal angle θ₀ in radians.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteSpring.GetStiffness(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteSpring,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the Context dependent stiffness coefficient k stored as a
parameter in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> spring belongs.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">returns</span></code>:</dt><dd><p>the stiffness k in N⋅m/rad stored within the context.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteSpring.joint(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteSpring)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteSpring.nominal_angle(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteSpring)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>(Deprecated.)</p>
<dl class="simple">
<dt>Deprecated:</dt><dd><p>Use the ‘default_nominal_angle()’ method instead. This will be
removed from Drake on or after 2025-09-01.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteSpring.SetNominalAngle(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteSpring,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">nominal_angle:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the value of the nominal angle θ₀ for this force element, stored
as a parameter in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> spring belongs.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">nominal_angle</span></code>:</dt><dd><p>The nominal angle θ₀ in radians stored within the context.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteSpring.SetStiffness(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteSpring,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">stiffness:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the value of the linear stiffness coefficient k for this force
element, stored as a parameter in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> spring belongs.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">stiffness</span></code>:</dt><dd><p>The stiffness value k with units N⋅m/rad.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if stiffness is negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteSpring.stiffness(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteSpring)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>(Deprecated.)</p>
<dl class="simple">
<dt>Deprecated:</dt><dd><p>Use the ‘default_stiffness()’ method instead. This will be removed
from Drake on or after 2025-09-01.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteSpring_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">RevoluteSpring_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">RevoluteSpring_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">RevoluteSpring_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteSpring_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ForceElement_[AutoDiffXd]</span></code></p>
<p>This ForceElement models a torsional spring attached to a
RevoluteJoint and applies a torque to that joint</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">τ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">k</span><span class="err">⋅</span><span class="p">(</span><span class="n">θ</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">θ₀</span><span class="p">)</span>
</pre></div>
</div>
</details><p>where θ₀ is the nominal joint position. Note that joint damping exists
within the RevoluteJoint itself, and so is not included here.</p>
<p>The k (stiffness) and θ₀ (nominal angle) specified in the constructor
are kept as default values. These parameters are stored within the
context and can be accessed and set by context dependent
getters/setters.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteSpring_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteSpring_[AutoDiffXd],</span> <span class="pre">joint:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd],</span> <span class="pre">nominal_angle:</span> <span class="pre">float,</span> <span class="pre">stiffness:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructor for a spring attached to the given joint</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">nominal_angle</span></code>:</dt><dd><p>The nominal angle of the spring θ₀, in radians, at which the
spring applies no moment.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">stiffness</span></code>:</dt><dd><p>The stiffness k of the spring in N⋅m/rad.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if stiffness is negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteSpring_[AutoDiffXd].default_nominal_angle(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteSpring_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the default spring reference angle θ₀ in radians.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteSpring_[AutoDiffXd].default_stiffness(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteSpring_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the default stiffness constant k in N⋅m/rad.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteSpring_[AutoDiffXd].GetNominalAngle(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteSpring_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd</span></span></dt>
<dd><p>Returns the Context dependent nominal angle θ₀ stored as a parameter
in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> spring belongs.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">returns</span></code>:</dt><dd><p>the nominal angle θ₀ in radians.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteSpring_[AutoDiffXd].GetStiffness(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteSpring_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd</span></span></dt>
<dd><p>Returns the Context dependent stiffness coefficient k stored as a
parameter in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> spring belongs.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">returns</span></code>:</dt><dd><p>the stiffness k in N⋅m/rad stored within the context.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteSpring_[AutoDiffXd].joint(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteSpring_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteSpring_[AutoDiffXd].nominal_angle(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteSpring_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>(Deprecated.)</p>
<dl class="simple">
<dt>Deprecated:</dt><dd><p>Use the ‘default_nominal_angle()’ method instead. This will be
removed from Drake on or after 2025-09-01.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteSpring_[AutoDiffXd].SetNominalAngle(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteSpring_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">nominal_angle:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the value of the nominal angle θ₀ for this force element, stored
as a parameter in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> spring belongs.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">nominal_angle</span></code>:</dt><dd><p>The nominal angle θ₀ in radians stored within the context.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteSpring_[AutoDiffXd].SetStiffness(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteSpring_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">stiffness:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the value of the linear stiffness coefficient k for this force
element, stored as a parameter in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> spring belongs.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">stiffness</span></code>:</dt><dd><p>The stiffness value k with units N⋅m/rad.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if stiffness is negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteSpring_[AutoDiffXd].stiffness(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteSpring_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>(Deprecated.)</p>
<dl class="simple">
<dt>Deprecated:</dt><dd><p>Use the ‘default_stiffness()’ method instead. This will be removed
from Drake on or after 2025-09-01.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteSpring_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ForceElement_[Expression]</span></code></p>
<p>This ForceElement models a torsional spring attached to a
RevoluteJoint and applies a torque to that joint</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">τ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">k</span><span class="err">⋅</span><span class="p">(</span><span class="n">θ</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">θ₀</span><span class="p">)</span>
</pre></div>
</div>
</details><p>where θ₀ is the nominal joint position. Note that joint damping exists
within the RevoluteJoint itself, and so is not included here.</p>
<p>The k (stiffness) and θ₀ (nominal angle) specified in the constructor
are kept as default values. These parameters are stored within the
context and can be accessed and set by context dependent
getters/setters.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteSpring_[Expression].__init__(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteSpring_[Expression],</span> <span class="pre">joint:</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[Expression],</span> <span class="pre">nominal_angle:</span> <span class="pre">float,</span> <span class="pre">stiffness:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructor for a spring attached to the given joint</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">nominal_angle</span></code>:</dt><dd><p>The nominal angle of the spring θ₀, in radians, at which the
spring applies no moment.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">stiffness</span></code>:</dt><dd><p>The stiffness k of the spring in N⋅m/rad.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if stiffness is negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteSpring_[Expression].default_nominal_angle(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteSpring_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the default spring reference angle θ₀ in radians.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteSpring_[Expression].default_stiffness(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteSpring_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the default stiffness constant k in N⋅m/rad.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteSpring_[Expression].GetNominalAngle(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteSpring_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd><p>Returns the Context dependent nominal angle θ₀ stored as a parameter
in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> spring belongs.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">returns</span></code>:</dt><dd><p>the nominal angle θ₀ in radians.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteSpring_[Expression].GetStiffness(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteSpring_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd><p>Returns the Context dependent stiffness coefficient k stored as a
parameter in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> spring belongs.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">returns</span></code>:</dt><dd><p>the stiffness k in N⋅m/rad stored within the context.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteSpring_[Expression].joint(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteSpring_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RevoluteJoint_[Expression]</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteSpring_[Expression].nominal_angle(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteSpring_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>(Deprecated.)</p>
<dl class="simple">
<dt>Deprecated:</dt><dd><p>Use the ‘default_nominal_angle()’ method instead. This will be
removed from Drake on or after 2025-09-01.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteSpring_[Expression].SetNominalAngle(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteSpring_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">nominal_angle:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the value of the nominal angle θ₀ for this force element, stored
as a parameter in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> spring belongs.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">nominal_angle</span></code>:</dt><dd><p>The nominal angle θ₀ in radians stored within the context.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteSpring_[Expression].SetStiffness(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteSpring_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">stiffness:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the value of the linear stiffness coefficient k for this force
element, stored as a parameter in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> spring belongs.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">stiffness</span></code>:</dt><dd><p>The stiffness value k with units N⋅m/rad.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if stiffness is negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RevoluteSpring_[Expression].stiffness(self:</span> <span class="pre">pydrake.multibody.tree.RevoluteSpring_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>(Deprecated.)</p>
<dl class="simple">
<dt>Deprecated:</dt><dd><p>Use the ‘default_stiffness()’ method instead. This will be removed
from Drake on or after 2025-09-01.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody</span></span></dt>
<dd><p>The term <strong>rigid body</strong> implies that the deformations of the body
under consideration are so small that they have no significant effect
on the overall motions of the body and therefore deformations can be
neglected. If deformations are neglected, the distance between any two
points on the rigid body remains constant at all times. This
invariance of the distance between two arbitrary points is often taken
as the definition of a rigid body in classical treatments of multibody
mechanics [Goldstein 2001]. It can be demonstrated that the
unconstrained three-dimensional motions of a rigid body can be
described by six coordinates and thus it is often said that a free
body in space has six <strong>degrees of freedom</strong>. These degrees of freedom
obey the Newton-Euler equations of motion. However, within a
MultibodyTree, a RigidBody is <em>not</em> free in space; instead, it is
assigned a limited number of degrees of freedom (0-6) with respect to
its parent body in the multibody tree by its Mobilizer (also called a
“tree joint” or “inboard joint”). Additional constraints on
permissible motion can be added using Constraint objects to remove
more degrees of freedom.</p>
<ul class="simple">
<li><dl class="simple">
<dt>[Goldstein 2001] H Goldstein, CP Poole, JL Safko, Classical Mechanics</dt><dd><p>(3rd Edition), Addison-Wesley, 2001.</p>
</dd>
</dl>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">RigidBody_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.tree.RigidBody, body_name: str, M_BBo_B: pydrake.multibody.tree.SpatialInertia = SpatialInertia.Zero()) -&gt; None</p></li>
</ol>
<p>Constructs a RigidBody named <code class="docutils literal notranslate"><span class="pre">body_name</span></code> with the given default
SpatialInertia.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_name</span></code>:</dt><dd><p>A name associated with this body.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>Spatial inertia of this body B about the frame’s origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code> and
expressed in the body frame B. When not provided, defaults to
zero.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>See multibody_spatial_inertia for details on the monogram notation
used for spatial inertia quantities.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.tree.RigidBody, body_name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex, M_BBo_B: pydrake.multibody.tree.SpatialInertia = SpatialInertia.Zero()) -&gt; None</p></li>
</ol>
<p>Constructs a RigidBody named <code class="docutils literal notranslate"><span class="pre">body_name</span></code> with the given default
SpatialInertia.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_name</span></code>:</dt><dd><p>A name associated with this body.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>:</dt><dd><p>The model instance associated with this body.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>Spatial inertia of this body B about the frame’s origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code> and
expressed in the body frame B. When not provided, defaults to
zero.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>See multibody_spatial_inertia for details on the monogram notation
used for spatial inertia quantities.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody.AddInForce(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">p_BP_E:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">F_Bp_E:</span> <span class="pre">pydrake.multibody.math.SpatialForce,</span> <span class="pre">frame_E:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">forces:</span> <span class="pre">pydrake.multibody.tree.MultibodyForces)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Adds the SpatialForce on this RigidBody B, applied at point P and
expressed in a frame E into <code class="docutils literal notranslate"><span class="pre">forces</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the current state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BP_E</span></code>:</dt><dd><p>The position of point P in B, expressed in a frame E.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">F_Bp_E</span></code>:</dt><dd><p>The spatial force to be applied on body B at point P, expressed in
frame E.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The expressed-in frame E.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">forces</span></code>:</dt><dd><p>A multibody forces objects that on output will have <code class="docutils literal notranslate"><span class="pre">F_Bp_E</span></code>
added.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if forces is nullptr</strong><strong> or </strong><strong>if it is not consistent</strong> – </p></li>
<li><p><strong>with the model to which this body belongs.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody.AddInForceInWorld(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">F_Bo_W:</span> <span class="pre">pydrake.multibody.math.SpatialForce,</span> <span class="pre">forces:</span> <span class="pre">pydrake.multibody.tree.MultibodyForces)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Adds the SpatialForce on this RigidBody B, applied at body B’s origin
Bo and expressed in the world frame W into <code class="docutils literal notranslate"><span class="pre">forces</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody.body_frame(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RigidBodyFrame</span></span></dt>
<dd><p>Returns a const reference to the associated BodyFrame.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody.CalcCenterOfMassInBodyFrame(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Gets this body’s center of mass position from the given context.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>p_BoBcm_B position vector from Bo (this rigid body B’s origin) to
Bcm (B’s center of mass), expressed in B.</p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>the context makes sense for use by this RigidBody.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody.CalcCenterOfMassTranslationalAccelerationInWorld(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Calculates Bcm’s translational acceleration in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context contains the state of the model.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">a_WBcm_W</span></code>:</dt><dd><p>The translational acceleration of Bcm (this rigid body’s center of
mass) in the world frame W, expressed in W.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When cached values are out of sync with the state stored in
context, this method performs an expensive forward dynamics
computation, whereas once evaluated, successive calls to this
method are inexpensive.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody.CalcCenterOfMassTranslationalVelocityInWorld(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Calculates Bcm’s translational velocity in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context contains the state of the model.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">v_WBcm_W</span></code>:</dt><dd><p>The translational velocity of Bcm (this rigid body’s center of
mass) in the world frame W, expressed in W.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody.CalcSpatialInertiaInBodyFrame(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia</span></span></dt>
<dd><p>Gets this body’s spatial inertia about its origin from the given
context.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>M_BBo_B spatial inertia of this rigid body B about Bo (B’s
origin), expressed in B. M_BBo_B contains properties related to
B’s mass, the position vector from Bo to Bcm (B’s center of mass),
and G_BBo_B (B’s unit inertia about Bo expressed in B).</p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>the context makes sense for use by this RigidBody.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody.default_com(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the default value of this RigidBody’s center of mass as
measured and expressed in its body frame. This value is initially
supplied at construction when specifying this body’s SpatialInertia.</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_BoBcm_B</span></code>:</dt><dd><p>The position of this rigid body B’s center of mass <code class="docutils literal notranslate"><span class="pre">Bcm</span></code>
measured from Bo (B’s frame origin) and expressed in B (body B’s
frame).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody.default_mass(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>default_mass(self: pydrake.multibody.tree.RigidBody) -&gt; float</p></li>
</ol>
<p>Returns this RigidBody’s default mass, which is initially supplied at
construction when specifying this body’s SpatialInertia.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In general, a rigid body’s mass can be a constant property stored
in this rigid body’s SpatialInertia or a parameter that is stored
in a Context. The default constant mass value is used to
initialize the mass parameter in the Context.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>default_mass(self: pydrake.multibody.tree.RigidBody) -&gt; float</p></li>
</ol>
<p>Returns this RigidBody’s default mass, which is initially supplied at
construction when specifying this body’s SpatialInertia.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In general, a rigid body’s mass can be a constant property stored
in this rigid body’s SpatialInertia or a parameter that is stored
in a Context. The default constant mass value is used to
initialize the mass parameter in the Context.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody.default_rotational_inertia(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RotationalInertia</span></span></dt>
<dd><p>Gets the default value of this body B’s rotational inertia about Bo
(B’s origin), expressed in B (this body’s body frame). This value is
calculated from the SpatialInertia supplied at construction of this
body.</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">I_BBo_B</span></code>:</dt><dd><p>body B’s rotational inertia about Bo, expressed in B.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody.default_spatial_inertia(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia</span></span></dt>
<dd><p>Gets the default value of this body B’s SpatialInertia about Bo (B’s
origin) and expressed in B (this body’s frame).</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>body B’s spatial inertia about Bo, expressed in B.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody.default_unit_inertia(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia</span></span></dt>
<dd><p>Returns the default value of this body B’s unit inertia about Bo (body
B’s origin), expressed in B (this body’s body frame). This value is
initially supplied at construction when specifying this body’s
SpatialInertia.</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_BBo_B</span></code>:</dt><dd><p>rigid body B’s unit inertia about Bo, expressed in B.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody.EvalPoseInWorld(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RigidTransform</span></span></dt>
<dd><p>Returns the pose <code class="docutils literal notranslate"><span class="pre">X_WB</span></code> of this RigidBody B in the world frame W as
a function of the state of the model stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody.EvalSpatialAccelerationInWorld(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.math.SpatialAcceleration</span></span></dt>
<dd><p>Evaluates A_WB, this body B’s SpatialAcceleration in the world frame
W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the model.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">A_WB_W</span></code>:</dt><dd><p>this body B’s spatial acceleration in the world frame W, expressed
in W (for point Bo, the body’s origin).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When cached values are out of sync with the state stored in
context, this method performs an expensive forward dynamics
computation, whereas once evaluated, successive calls to this
method are inexpensive.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody.EvalSpatialVelocityInWorld(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.math.SpatialVelocity</span></span></dt>
<dd><p>Evaluates V_WB, this body B’s SpatialVelocity in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the model.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">V_WB_W</span></code>:</dt><dd><p>this body B’s spatial velocity in the world frame W, expressed in
W (for point Bo, the body frame’s origin).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody.floating_position_suffix(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody,</span> <span class="pre">arg0:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a string suffix (e.g. to be appended to the name()) to
identify the <code class="docutils literal notranslate"><span class="pre">k`th</span> <span class="pre">position</span> <span class="pre">in</span> <span class="pre">the</span> <span class="pre">floating</span> <span class="pre">base.</span>
<span class="pre">`position_index_in_body</span></code> must be in [0, 7) if
<code class="docutils literal notranslate"><span class="pre">has_quaternion_dofs()</span></code> is true, otherwise in [0, 6).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>this is a floating base body</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>is_floating(), has_quaternion_dofs(), MultibodyPlant::Finalize()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody.floating_positions_start(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>(Advanced) For floating base bodies (see is_floating()) this method
returns the index of this RigidBody’s first generalized position in
the vector q of generalized position coordinates for a MultibodyPlant
model. Positions q for this RigidBody are then contiguous starting at
this index. When a floating RigidBody is modeled with quaternion
coordinates (see has_quaternion_dofs()), the four consecutive entries
in the state starting at this index correspond to the quaternion that
parametrizes this RigidBody’s orientation.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>this is a floating base body</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>is_floating(), has_quaternion_dofs(), MultibodyPlant::Finalize()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody.floating_velocities_start_in_v(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>(Advanced) For floating base bodies (see is_floating()) this method
returns the index of this RigidBody’s first generalized velocity in
the vector v of generalized velocities for a MultibodyPlant model.
Velocities v for this RigidBody are then contiguous starting at this
index.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>this is a floating base body</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>is_floating(), MultibodyPlant::Finalize()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody.floating_velocity_suffix(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody,</span> <span class="pre">arg0:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a string suffix (e.g. to be appended to the name()) to
identify the <code class="docutils literal notranslate"><span class="pre">k`th</span> <span class="pre">velocity</span> <span class="pre">in</span> <span class="pre">the</span> <span class="pre">floating</span> <span class="pre">base.</span>
<span class="pre">`velocity_index_in_body</span></code> must be in [0,6).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>this is a floating base body</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>is_floating(), MultibodyPlant::Finalize()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody.get_mass(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Gets this body’s mass from the given context.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
<dt>Precondition:</dt><dd><p>the context makes sense for use by this RigidBody.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody.GetForceInWorld(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">forces:</span> <span class="pre">pydrake.multibody.tree.MultibodyForces)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.math.SpatialForce</span></span></dt>
<dd><p>Gets the SpatialForce on this RigidBody B from <code class="docutils literal notranslate"><span class="pre">forces</span></code> as F_BBo_W:
applied at body B’s origin Bo and expressed in world frame W.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody.GetParentPlant(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody)</span> <span class="pre">-&gt;</span> <span class="pre">drake::multibody::MultibodyPlant&lt;double&gt;</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody.has_quaternion_dofs(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>(Advanced) If <code class="docutils literal notranslate"><span class="pre">True</span></code>, this body’s generalized position coordinates q
include a quaternion, which occupies the first four elements of q.
Note that this does not imply that the body is floating base body
since it may have fewer than 6 dofs or its inboard body could be
something other than World.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>is_floating(), MultibodyPlant::Finalize()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody.index(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.BodyIndex</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody.is_ephemeral(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody.is_floating(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>(Advanced) Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if this body is granted 6-dofs by a
Mobilizer and the parent body of this body’s associated 6-dof joint is
<code class="docutils literal notranslate"><span class="pre">world</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A floating base body is not necessarily modeled with a quaternion
mobilizer, see has_quaternion_dofs(). Alternative options include
a roll-pitch-yaw (rpy) parametrization of rotations, see
RpyFloatingMobilizer.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize</strong><strong>,</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MultibodyPlant::Finalize()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody.is_locked(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Determines whether this RigidBody is currently locked to its inboard
(parent) RigidBody. This is not limited to floating base bodies but
generally Joint::is_locked() is preferable otherwise.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>true if the body is locked, false otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody.Lock(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>For a floating base RigidBody, lock its inboard joint. Its generalized
velocities will be 0 until it is unlocked.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if this body is not a floating base body.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody.model_instance(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody.name(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Gets the <code class="docutils literal notranslate"><span class="pre">name</span></code> associated with this rigid body. The name will never
be empty.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody.scoped_name(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.ScopedName</span></span></dt>
<dd><p>Returns scoped name of this body. Neither of the two pieces of the
name will be empty (the scope name and the element name).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody.SetCenterOfMassInBodyFrame(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">com:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>(Advanced) Sets this body’s center of mass position while preserving
its inertia about its body origin.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">out</span></code>:</dt><dd><p>] context contains the state of the multibody system. It is
modified to store the updated com (center of mass position).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">com</span></code>:</dt><dd><p>position vector from Bo (this body B’s origin) to Bcm (B’s center
of mass), expressed in B.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function changes B’s center of mass position <strong>without</strong>
modifying G_BBo_B (B’s unit inertia about Bo, expressed in B).
Since this use case is very unlikely, consider using
SetSpatialInertiaInBodyFrame() or
SetCenterOfMassInBodyFrameAndPreserveCentralInertia().</p>
</div>
<dl class="simple">
<dt>Precondition:</dt><dd><p>the context makes sense for use by this RigidBody.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if context is null.</strong> – </p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Do not use this function unless it is needed (think twice).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody.SetMass(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">mass:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>For this RigidBody B, sets its mass stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> to <code class="docutils literal notranslate"><span class="pre">mass</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>mass of this rigid body B.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function changes this body B’s mass and appropriately scales
I_BBo_B (B’s rotational inertia about Bo, expressed in B).</p>
</div>
<dl class="simple">
<dt>Precondition:</dt><dd><p>the context makes sense for use by this RigidBody.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if context is null.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody.SetSpatialInertiaInBodyFrame(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">M_Bo_B:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>For this RigidBody B, sets its SpatialInertia that is stored in
<code class="docutils literal notranslate"><span class="pre">context</span></code> to <code class="docutils literal notranslate"><span class="pre">M_Bo_B</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M_Bo_B</span></code>:</dt><dd><p>spatial inertia of this rigid body B about Bo (B’s origin),
expressed in B. M_Bo_B contains properties related to B’s mass,
the position vector from Bo to Bcm (B’s center of mass), and
G_Bo_B (B’s unit inertia about Bo expressed in B).</p>
</dd>
<dt>Precondition:</dt><dd><p>the context makes sense for use by this RigidBody.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if context is null.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody.Unlock(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>For a floating base RigidBody, unlock its inboard joint.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if this body is not a floating base body.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">RigidBody_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">RigidBody_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">RigidBody_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[AutoDiffXd]</span></span></dt>
<dd><p>The term <strong>rigid body</strong> implies that the deformations of the body
under consideration are so small that they have no significant effect
on the overall motions of the body and therefore deformations can be
neglected. If deformations are neglected, the distance between any two
points on the rigid body remains constant at all times. This
invariance of the distance between two arbitrary points is often taken
as the definition of a rigid body in classical treatments of multibody
mechanics [Goldstein 2001]. It can be demonstrated that the
unconstrained three-dimensional motions of a rigid body can be
described by six coordinates and thus it is often said that a free
body in space has six <strong>degrees of freedom</strong>. These degrees of freedom
obey the Newton-Euler equations of motion. However, within a
MultibodyTree, a RigidBody is <em>not</em> free in space; instead, it is
assigned a limited number of degrees of freedom (0-6) with respect to
its parent body in the multibody tree by its Mobilizer (also called a
“tree joint” or “inboard joint”). Additional constraints on
permissible motion can be added using Constraint objects to remove
more degrees of freedom.</p>
<ul class="simple">
<li><dl class="simple">
<dt>[Goldstein 2001] H Goldstein, CP Poole, JL Safko, Classical Mechanics</dt><dd><p>(3rd Edition), Addison-Wesley, 2001.</p>
</dd>
</dl>
</li>
</ul>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.tree.RigidBody_[AutoDiffXd], body_name: str, M_BBo_B: pydrake.multibody.tree.SpatialInertia = SpatialInertia.Zero()) -&gt; None</p></li>
</ol>
<p>Constructs a RigidBody named <code class="docutils literal notranslate"><span class="pre">body_name</span></code> with the given default
SpatialInertia.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_name</span></code>:</dt><dd><p>A name associated with this body.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>Spatial inertia of this body B about the frame’s origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code> and
expressed in the body frame B. When not provided, defaults to
zero.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>See multibody_spatial_inertia for details on the monogram notation
used for spatial inertia quantities.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.tree.RigidBody_[AutoDiffXd], body_name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex, M_BBo_B: pydrake.multibody.tree.SpatialInertia = SpatialInertia.Zero()) -&gt; None</p></li>
</ol>
<p>Constructs a RigidBody named <code class="docutils literal notranslate"><span class="pre">body_name</span></code> with the given default
SpatialInertia.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_name</span></code>:</dt><dd><p>A name associated with this body.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>:</dt><dd><p>The model instance associated with this body.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>Spatial inertia of this body B about the frame’s origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code> and
expressed in the body frame B. When not provided, defaults to
zero.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>See multibody_spatial_inertia for details on the monogram notation
used for spatial inertia quantities.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[AutoDiffXd].AddInForce(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">p_BP_E:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]],</span> <span class="pre">F_Bp_E:</span> <span class="pre">pydrake.multibody.math.SpatialForce_[AutoDiffXd],</span> <span class="pre">frame_E:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">forces:</span> <span class="pre">pydrake.multibody.tree.MultibodyForces_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Adds the SpatialForce on this RigidBody B, applied at point P and
expressed in a frame E into <code class="docutils literal notranslate"><span class="pre">forces</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the current state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BP_E</span></code>:</dt><dd><p>The position of point P in B, expressed in a frame E.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">F_Bp_E</span></code>:</dt><dd><p>The spatial force to be applied on body B at point P, expressed in
frame E.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The expressed-in frame E.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">forces</span></code>:</dt><dd><p>A multibody forces objects that on output will have <code class="docutils literal notranslate"><span class="pre">F_Bp_E</span></code>
added.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if forces is nullptr</strong><strong> or </strong><strong>if it is not consistent</strong> – </p></li>
<li><p><strong>with the model to which this body belongs.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[AutoDiffXd].AddInForceInWorld(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">F_Bo_W:</span> <span class="pre">pydrake.multibody.math.SpatialForce_[AutoDiffXd],</span> <span class="pre">forces:</span> <span class="pre">pydrake.multibody.tree.MultibodyForces_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Adds the SpatialForce on this RigidBody B, applied at body B’s origin
Bo and expressed in the world frame W into <code class="docutils literal notranslate"><span class="pre">forces</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[AutoDiffXd].body_frame(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RigidBodyFrame_[AutoDiffXd]</span></span></dt>
<dd><p>Returns a const reference to the associated BodyFrame.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[AutoDiffXd].CalcCenterOfMassInBodyFrame(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Gets this body’s center of mass position from the given context.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>p_BoBcm_B position vector from Bo (this rigid body B’s origin) to
Bcm (B’s center of mass), expressed in B.</p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>the context makes sense for use by this RigidBody.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[AutoDiffXd].CalcCenterOfMassTranslationalAccelerationInWorld(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Calculates Bcm’s translational acceleration in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context contains the state of the model.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">a_WBcm_W</span></code>:</dt><dd><p>The translational acceleration of Bcm (this rigid body’s center of
mass) in the world frame W, expressed in W.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When cached values are out of sync with the state stored in
context, this method performs an expensive forward dynamics
computation, whereas once evaluated, successive calls to this
method are inexpensive.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[AutoDiffXd].CalcCenterOfMassTranslationalVelocityInWorld(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Calculates Bcm’s translational velocity in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context contains the state of the model.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">v_WBcm_W</span></code>:</dt><dd><p>The translational velocity of Bcm (this rigid body’s center of
mass) in the world frame W, expressed in W.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[AutoDiffXd].CalcSpatialInertiaInBodyFrame(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Gets this body’s spatial inertia about its origin from the given
context.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>M_BBo_B spatial inertia of this rigid body B about Bo (B’s
origin), expressed in B. M_BBo_B contains properties related to
B’s mass, the position vector from Bo to Bcm (B’s center of mass),
and G_BBo_B (B’s unit inertia about Bo expressed in B).</p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>the context makes sense for use by this RigidBody.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[AutoDiffXd].default_com(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the default value of this RigidBody’s center of mass as
measured and expressed in its body frame. This value is initially
supplied at construction when specifying this body’s SpatialInertia.</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_BoBcm_B</span></code>:</dt><dd><p>The position of this rigid body B’s center of mass <code class="docutils literal notranslate"><span class="pre">Bcm</span></code>
measured from Bo (B’s frame origin) and expressed in B (body B’s
frame).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[AutoDiffXd].default_mass(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>default_mass(self: pydrake.multibody.tree.RigidBody_[AutoDiffXd]) -&gt; float</p></li>
</ol>
<p>Returns this RigidBody’s default mass, which is initially supplied at
construction when specifying this body’s SpatialInertia.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In general, a rigid body’s mass can be a constant property stored
in this rigid body’s SpatialInertia or a parameter that is stored
in a Context. The default constant mass value is used to
initialize the mass parameter in the Context.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>default_mass(self: pydrake.multibody.tree.RigidBody_[AutoDiffXd]) -&gt; float</p></li>
</ol>
<p>Returns this RigidBody’s default mass, which is initially supplied at
construction when specifying this body’s SpatialInertia.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In general, a rigid body’s mass can be a constant property stored
in this rigid body’s SpatialInertia or a parameter that is stored
in a Context. The default constant mass value is used to
initialize the mass parameter in the Context.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[AutoDiffXd].default_rotational_inertia(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RotationalInertia</span></span></dt>
<dd><p>Gets the default value of this body B’s rotational inertia about Bo
(B’s origin), expressed in B (this body’s body frame). This value is
calculated from the SpatialInertia supplied at construction of this
body.</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">I_BBo_B</span></code>:</dt><dd><p>body B’s rotational inertia about Bo, expressed in B.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[AutoDiffXd].default_spatial_inertia(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia</span></span></dt>
<dd><p>Gets the default value of this body B’s SpatialInertia about Bo (B’s
origin) and expressed in B (this body’s frame).</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>body B’s spatial inertia about Bo, expressed in B.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[AutoDiffXd].default_unit_inertia(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia</span></span></dt>
<dd><p>Returns the default value of this body B’s unit inertia about Bo (body
B’s origin), expressed in B (this body’s body frame). This value is
initially supplied at construction when specifying this body’s
SpatialInertia.</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_BBo_B</span></code>:</dt><dd><p>rigid body B’s unit inertia about Bo, expressed in B.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[AutoDiffXd].EvalPoseInWorld(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RigidTransform_[AutoDiffXd]</span></span></dt>
<dd><p>Returns the pose <code class="docutils literal notranslate"><span class="pre">X_WB</span></code> of this RigidBody B in the world frame W as
a function of the state of the model stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[AutoDiffXd].EvalSpatialAccelerationInWorld(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]</span></span></dt>
<dd><p>Evaluates A_WB, this body B’s SpatialAcceleration in the world frame
W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the model.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">A_WB_W</span></code>:</dt><dd><p>this body B’s spatial acceleration in the world frame W, expressed
in W (for point Bo, the body’s origin).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When cached values are out of sync with the state stored in
context, this method performs an expensive forward dynamics
computation, whereas once evaluated, successive calls to this
method are inexpensive.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[AutoDiffXd].EvalSpatialVelocityInWorld(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]</span></span></dt>
<dd><p>Evaluates V_WB, this body B’s SpatialVelocity in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the model.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">V_WB_W</span></code>:</dt><dd><p>this body B’s spatial velocity in the world frame W, expressed in
W (for point Bo, the body frame’s origin).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[AutoDiffXd].floating_position_suffix(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[AutoDiffXd],</span> <span class="pre">arg0:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a string suffix (e.g. to be appended to the name()) to
identify the <code class="docutils literal notranslate"><span class="pre">k`th</span> <span class="pre">position</span> <span class="pre">in</span> <span class="pre">the</span> <span class="pre">floating</span> <span class="pre">base.</span>
<span class="pre">`position_index_in_body</span></code> must be in [0, 7) if
<code class="docutils literal notranslate"><span class="pre">has_quaternion_dofs()</span></code> is true, otherwise in [0, 6).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>this is a floating base body</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>is_floating(), has_quaternion_dofs(), MultibodyPlant::Finalize()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[AutoDiffXd].floating_positions_start(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>(Advanced) For floating base bodies (see is_floating()) this method
returns the index of this RigidBody’s first generalized position in
the vector q of generalized position coordinates for a MultibodyPlant
model. Positions q for this RigidBody are then contiguous starting at
this index. When a floating RigidBody is modeled with quaternion
coordinates (see has_quaternion_dofs()), the four consecutive entries
in the state starting at this index correspond to the quaternion that
parametrizes this RigidBody’s orientation.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>this is a floating base body</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>is_floating(), has_quaternion_dofs(), MultibodyPlant::Finalize()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[AutoDiffXd].floating_velocities_start_in_v(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>(Advanced) For floating base bodies (see is_floating()) this method
returns the index of this RigidBody’s first generalized velocity in
the vector v of generalized velocities for a MultibodyPlant model.
Velocities v for this RigidBody are then contiguous starting at this
index.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>this is a floating base body</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>is_floating(), MultibodyPlant::Finalize()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[AutoDiffXd].floating_velocity_suffix(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[AutoDiffXd],</span> <span class="pre">arg0:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a string suffix (e.g. to be appended to the name()) to
identify the <code class="docutils literal notranslate"><span class="pre">k`th</span> <span class="pre">velocity</span> <span class="pre">in</span> <span class="pre">the</span> <span class="pre">floating</span> <span class="pre">base.</span>
<span class="pre">`velocity_index_in_body</span></code> must be in [0,6).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>this is a floating base body</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>is_floating(), MultibodyPlant::Finalize()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[AutoDiffXd].get_mass(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd</span></span></dt>
<dd><p>Gets this body’s mass from the given context.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
<dt>Precondition:</dt><dd><p>the context makes sense for use by this RigidBody.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[AutoDiffXd].GetForceInWorld(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">forces:</span> <span class="pre">pydrake.multibody.tree.MultibodyForces_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.math.SpatialForce_[AutoDiffXd]</span></span></dt>
<dd><p>Gets the SpatialForce on this RigidBody B from <code class="docutils literal notranslate"><span class="pre">forces</span></code> as F_BBo_W:
applied at body B’s origin Bo and expressed in world frame W.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[AutoDiffXd].GetParentPlant(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">drake::multibody::MultibodyPlant&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double,</span> <span class="pre">-1,</span> <span class="pre">1,</span> <span class="pre">0,</span> <span class="pre">-1,</span> <span class="pre">1&gt;</span> <span class="pre">&gt;</span> <span class="pre">&gt;</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[AutoDiffXd].has_quaternion_dofs(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>(Advanced) If <code class="docutils literal notranslate"><span class="pre">True</span></code>, this body’s generalized position coordinates q
include a quaternion, which occupies the first four elements of q.
Note that this does not imply that the body is floating base body
since it may have fewer than 6 dofs or its inboard body could be
something other than World.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>is_floating(), MultibodyPlant::Finalize()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[AutoDiffXd].index(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.BodyIndex</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[AutoDiffXd].is_ephemeral(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[AutoDiffXd].is_floating(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>(Advanced) Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if this body is granted 6-dofs by a
Mobilizer and the parent body of this body’s associated 6-dof joint is
<code class="docutils literal notranslate"><span class="pre">world</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A floating base body is not necessarily modeled with a quaternion
mobilizer, see has_quaternion_dofs(). Alternative options include
a roll-pitch-yaw (rpy) parametrization of rotations, see
RpyFloatingMobilizer.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize</strong><strong>,</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MultibodyPlant::Finalize()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[AutoDiffXd].is_locked(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Determines whether this RigidBody is currently locked to its inboard
(parent) RigidBody. This is not limited to floating base bodies but
generally Joint::is_locked() is preferable otherwise.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>true if the body is locked, false otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[AutoDiffXd].Lock(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>For a floating base RigidBody, lock its inboard joint. Its generalized
velocities will be 0 until it is unlocked.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if this body is not a floating base body.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[AutoDiffXd].model_instance(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[AutoDiffXd].name(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Gets the <code class="docutils literal notranslate"><span class="pre">name</span></code> associated with this rigid body. The name will never
be empty.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[AutoDiffXd].scoped_name(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.ScopedName</span></span></dt>
<dd><p>Returns scoped name of this body. Neither of the two pieces of the
name will be empty (the scope name and the element name).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[AutoDiffXd].SetCenterOfMassInBodyFrame(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">com:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>(Advanced) Sets this body’s center of mass position while preserving
its inertia about its body origin.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">out</span></code>:</dt><dd><p>] context contains the state of the multibody system. It is
modified to store the updated com (center of mass position).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">com</span></code>:</dt><dd><p>position vector from Bo (this body B’s origin) to Bcm (B’s center
of mass), expressed in B.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function changes B’s center of mass position <strong>without</strong>
modifying G_BBo_B (B’s unit inertia about Bo, expressed in B).
Since this use case is very unlikely, consider using
SetSpatialInertiaInBodyFrame() or
SetCenterOfMassInBodyFrameAndPreserveCentralInertia().</p>
</div>
<dl class="simple">
<dt>Precondition:</dt><dd><p>the context makes sense for use by this RigidBody.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if context is null.</strong> – </p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Do not use this function unless it is needed (think twice).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[AutoDiffXd].SetMass(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">mass:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>For this RigidBody B, sets its mass stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> to <code class="docutils literal notranslate"><span class="pre">mass</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>mass of this rigid body B.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function changes this body B’s mass and appropriately scales
I_BBo_B (B’s rotational inertia about Bo, expressed in B).</p>
</div>
<dl class="simple">
<dt>Precondition:</dt><dd><p>the context makes sense for use by this RigidBody.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if context is null.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[AutoDiffXd].SetSpatialInertiaInBodyFrame(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">M_Bo_B:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>For this RigidBody B, sets its SpatialInertia that is stored in
<code class="docutils literal notranslate"><span class="pre">context</span></code> to <code class="docutils literal notranslate"><span class="pre">M_Bo_B</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M_Bo_B</span></code>:</dt><dd><p>spatial inertia of this rigid body B about Bo (B’s origin),
expressed in B. M_Bo_B contains properties related to B’s mass,
the position vector from Bo to Bcm (B’s center of mass), and
G_Bo_B (B’s unit inertia about Bo expressed in B).</p>
</dd>
<dt>Precondition:</dt><dd><p>the context makes sense for use by this RigidBody.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if context is null.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[AutoDiffXd].Unlock(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>For a floating base RigidBody, unlock its inboard joint.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if this body is not a floating base body.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[Expression]</span></span></dt>
<dd><p>The term <strong>rigid body</strong> implies that the deformations of the body
under consideration are so small that they have no significant effect
on the overall motions of the body and therefore deformations can be
neglected. If deformations are neglected, the distance between any two
points on the rigid body remains constant at all times. This
invariance of the distance between two arbitrary points is often taken
as the definition of a rigid body in classical treatments of multibody
mechanics [Goldstein 2001]. It can be demonstrated that the
unconstrained three-dimensional motions of a rigid body can be
described by six coordinates and thus it is often said that a free
body in space has six <strong>degrees of freedom</strong>. These degrees of freedom
obey the Newton-Euler equations of motion. However, within a
MultibodyTree, a RigidBody is <em>not</em> free in space; instead, it is
assigned a limited number of degrees of freedom (0-6) with respect to
its parent body in the multibody tree by its Mobilizer (also called a
“tree joint” or “inboard joint”). Additional constraints on
permissible motion can be added using Constraint objects to remove
more degrees of freedom.</p>
<ul class="simple">
<li><dl class="simple">
<dt>[Goldstein 2001] H Goldstein, CP Poole, JL Safko, Classical Mechanics</dt><dd><p>(3rd Edition), Addison-Wesley, 2001.</p>
</dd>
</dl>
</li>
</ul>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.tree.RigidBody_[Expression], body_name: str, M_BBo_B: pydrake.multibody.tree.SpatialInertia = SpatialInertia.Zero()) -&gt; None</p></li>
</ol>
<p>Constructs a RigidBody named <code class="docutils literal notranslate"><span class="pre">body_name</span></code> with the given default
SpatialInertia.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_name</span></code>:</dt><dd><p>A name associated with this body.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>Spatial inertia of this body B about the frame’s origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code> and
expressed in the body frame B. When not provided, defaults to
zero.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>See multibody_spatial_inertia for details on the monogram notation
used for spatial inertia quantities.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.tree.RigidBody_[Expression], body_name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex, M_BBo_B: pydrake.multibody.tree.SpatialInertia = SpatialInertia.Zero()) -&gt; None</p></li>
</ol>
<p>Constructs a RigidBody named <code class="docutils literal notranslate"><span class="pre">body_name</span></code> with the given default
SpatialInertia.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_name</span></code>:</dt><dd><p>A name associated with this body.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>:</dt><dd><p>The model instance associated with this body.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>Spatial inertia of this body B about the frame’s origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code> and
expressed in the body frame B. When not provided, defaults to
zero.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>See multibody_spatial_inertia for details on the monogram notation
used for spatial inertia quantities.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[Expression].AddInForce(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">p_BP_E:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]],</span> <span class="pre">F_Bp_E:</span> <span class="pre">pydrake.multibody.math.SpatialForce_[Expression],</span> <span class="pre">frame_E:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">forces:</span> <span class="pre">pydrake.multibody.tree.MultibodyForces_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Adds the SpatialForce on this RigidBody B, applied at point P and
expressed in a frame E into <code class="docutils literal notranslate"><span class="pre">forces</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context containing the current state of the model.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BP_E</span></code>:</dt><dd><p>The position of point P in B, expressed in a frame E.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">F_Bp_E</span></code>:</dt><dd><p>The spatial force to be applied on body B at point P, expressed in
frame E.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt><dd><p>The expressed-in frame E.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">forces</span></code>:</dt><dd><p>A multibody forces objects that on output will have <code class="docutils literal notranslate"><span class="pre">F_Bp_E</span></code>
added.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if forces is nullptr</strong><strong> or </strong><strong>if it is not consistent</strong> – </p></li>
<li><p><strong>with the model to which this body belongs.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[Expression].AddInForceInWorld(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">F_Bo_W:</span> <span class="pre">pydrake.multibody.math.SpatialForce_[Expression],</span> <span class="pre">forces:</span> <span class="pre">pydrake.multibody.tree.MultibodyForces_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Adds the SpatialForce on this RigidBody B, applied at body B’s origin
Bo and expressed in the world frame W into <code class="docutils literal notranslate"><span class="pre">forces</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[Expression].body_frame(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RigidBodyFrame_[Expression]</span></span></dt>
<dd><p>Returns a const reference to the associated BodyFrame.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[Expression].CalcCenterOfMassInBodyFrame(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Gets this body’s center of mass position from the given context.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>p_BoBcm_B position vector from Bo (this rigid body B’s origin) to
Bcm (B’s center of mass), expressed in B.</p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>the context makes sense for use by this RigidBody.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[Expression].CalcCenterOfMassTranslationalAccelerationInWorld(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Calculates Bcm’s translational acceleration in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context contains the state of the model.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">a_WBcm_W</span></code>:</dt><dd><p>The translational acceleration of Bcm (this rigid body’s center of
mass) in the world frame W, expressed in W.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When cached values are out of sync with the state stored in
context, this method performs an expensive forward dynamics
computation, whereas once evaluated, successive calls to this
method are inexpensive.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[Expression].CalcCenterOfMassTranslationalVelocityInWorld(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Calculates Bcm’s translational velocity in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context contains the state of the model.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">v_WBcm_W</span></code>:</dt><dd><p>The translational velocity of Bcm (this rigid body’s center of
mass) in the world frame W, expressed in W.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[Expression].CalcSpatialInertiaInBodyFrame(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[Expression]</span></span></dt>
<dd><p>Gets this body’s spatial inertia about its origin from the given
context.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>M_BBo_B spatial inertia of this rigid body B about Bo (B’s
origin), expressed in B. M_BBo_B contains properties related to
B’s mass, the position vector from Bo to Bcm (B’s center of mass),
and G_BBo_B (B’s unit inertia about Bo expressed in B).</p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>the context makes sense for use by this RigidBody.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[Expression].default_com(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the default value of this RigidBody’s center of mass as
measured and expressed in its body frame. This value is initially
supplied at construction when specifying this body’s SpatialInertia.</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_BoBcm_B</span></code>:</dt><dd><p>The position of this rigid body B’s center of mass <code class="docutils literal notranslate"><span class="pre">Bcm</span></code>
measured from Bo (B’s frame origin) and expressed in B (body B’s
frame).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[Expression].default_mass(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>default_mass(self: pydrake.multibody.tree.RigidBody_[Expression]) -&gt; float</p></li>
</ol>
<p>Returns this RigidBody’s default mass, which is initially supplied at
construction when specifying this body’s SpatialInertia.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In general, a rigid body’s mass can be a constant property stored
in this rigid body’s SpatialInertia or a parameter that is stored
in a Context. The default constant mass value is used to
initialize the mass parameter in the Context.</p>
</div>
<ol class="arabic simple" start="2">
<li><p>default_mass(self: pydrake.multibody.tree.RigidBody_[Expression]) -&gt; float</p></li>
</ol>
<p>Returns this RigidBody’s default mass, which is initially supplied at
construction when specifying this body’s SpatialInertia.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In general, a rigid body’s mass can be a constant property stored
in this rigid body’s SpatialInertia or a parameter that is stored
in a Context. The default constant mass value is used to
initialize the mass parameter in the Context.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[Expression].default_rotational_inertia(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RotationalInertia</span></span></dt>
<dd><p>Gets the default value of this body B’s rotational inertia about Bo
(B’s origin), expressed in B (this body’s body frame). This value is
calculated from the SpatialInertia supplied at construction of this
body.</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">I_BBo_B</span></code>:</dt><dd><p>body B’s rotational inertia about Bo, expressed in B.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[Expression].default_spatial_inertia(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia</span></span></dt>
<dd><p>Gets the default value of this body B’s SpatialInertia about Bo (B’s
origin) and expressed in B (this body’s frame).</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>body B’s spatial inertia about Bo, expressed in B.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[Expression].default_unit_inertia(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia</span></span></dt>
<dd><p>Returns the default value of this body B’s unit inertia about Bo (body
B’s origin), expressed in B (this body’s body frame). This value is
initially supplied at construction when specifying this body’s
SpatialInertia.</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_BBo_B</span></code>:</dt><dd><p>rigid body B’s unit inertia about Bo, expressed in B.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[Expression].EvalPoseInWorld(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RigidTransform_[Expression]</span></span></dt>
<dd><p>Returns the pose <code class="docutils literal notranslate"><span class="pre">X_WB</span></code> of this RigidBody B in the world frame W as
a function of the state of the model stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[Expression].EvalSpatialAccelerationInWorld(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.math.SpatialAcceleration_[Expression]</span></span></dt>
<dd><p>Evaluates A_WB, this body B’s SpatialAcceleration in the world frame
W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the model.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">A_WB_W</span></code>:</dt><dd><p>this body B’s spatial acceleration in the world frame W, expressed
in W (for point Bo, the body’s origin).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When cached values are out of sync with the state stored in
context, this method performs an expensive forward dynamics
computation, whereas once evaluated, successive calls to this
method are inexpensive.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[Expression].EvalSpatialVelocityInWorld(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.math.SpatialVelocity_[Expression]</span></span></dt>
<dd><p>Evaluates V_WB, this body B’s SpatialVelocity in the world frame W.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>Contains the state of the model.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">V_WB_W</span></code>:</dt><dd><p>this body B’s spatial velocity in the world frame W, expressed in
W (for point Bo, the body frame’s origin).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[Expression].floating_position_suffix(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[Expression],</span> <span class="pre">arg0:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a string suffix (e.g. to be appended to the name()) to
identify the <code class="docutils literal notranslate"><span class="pre">k`th</span> <span class="pre">position</span> <span class="pre">in</span> <span class="pre">the</span> <span class="pre">floating</span> <span class="pre">base.</span>
<span class="pre">`position_index_in_body</span></code> must be in [0, 7) if
<code class="docutils literal notranslate"><span class="pre">has_quaternion_dofs()</span></code> is true, otherwise in [0, 6).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>this is a floating base body</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>is_floating(), has_quaternion_dofs(), MultibodyPlant::Finalize()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[Expression].floating_positions_start(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>(Advanced) For floating base bodies (see is_floating()) this method
returns the index of this RigidBody’s first generalized position in
the vector q of generalized position coordinates for a MultibodyPlant
model. Positions q for this RigidBody are then contiguous starting at
this index. When a floating RigidBody is modeled with quaternion
coordinates (see has_quaternion_dofs()), the four consecutive entries
in the state starting at this index correspond to the quaternion that
parametrizes this RigidBody’s orientation.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>this is a floating base body</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>is_floating(), has_quaternion_dofs(), MultibodyPlant::Finalize()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[Expression].floating_velocities_start_in_v(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>(Advanced) For floating base bodies (see is_floating()) this method
returns the index of this RigidBody’s first generalized velocity in
the vector v of generalized velocities for a MultibodyPlant model.
Velocities v for this RigidBody are then contiguous starting at this
index.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>this is a floating base body</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>is_floating(), MultibodyPlant::Finalize()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[Expression].floating_velocity_suffix(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[Expression],</span> <span class="pre">arg0:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns a string suffix (e.g. to be appended to the name()) to
identify the <code class="docutils literal notranslate"><span class="pre">k`th</span> <span class="pre">velocity</span> <span class="pre">in</span> <span class="pre">the</span> <span class="pre">floating</span> <span class="pre">base.</span>
<span class="pre">`velocity_index_in_body</span></code> must be in [0,6).</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize</strong> – </p>
</dd>
</dl>
<dl class="simple">
<dt>Precondition:</dt><dd><p>this is a floating base body</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>is_floating(), MultibodyPlant::Finalize()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[Expression].get_mass(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd><p>Gets this body’s mass from the given context.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
<dt>Precondition:</dt><dd><p>the context makes sense for use by this RigidBody.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[Expression].GetForceInWorld(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">forces:</span> <span class="pre">pydrake.multibody.tree.MultibodyForces_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.math.SpatialForce_[Expression]</span></span></dt>
<dd><p>Gets the SpatialForce on this RigidBody B from <code class="docutils literal notranslate"><span class="pre">forces</span></code> as F_BBo_W:
applied at body B’s origin Bo and expressed in world frame W.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[Expression].GetParentPlant(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">drake::multibody::MultibodyPlant&lt;drake::symbolic::Expression&gt;</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[Expression].has_quaternion_dofs(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>(Advanced) If <code class="docutils literal notranslate"><span class="pre">True</span></code>, this body’s generalized position coordinates q
include a quaternion, which occupies the first four elements of q.
Note that this does not imply that the body is floating base body
since it may have fewer than 6 dofs or its inboard body could be
something other than World.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>is_floating(), MultibodyPlant::Finalize()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[Expression].index(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.BodyIndex</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[Expression].is_ephemeral(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[Expression].is_floating(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>(Advanced) Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if this body is granted 6-dofs by a
Mobilizer and the parent body of this body’s associated 6-dof joint is
<code class="docutils literal notranslate"><span class="pre">world</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A floating base body is not necessarily modeled with a quaternion
mobilizer, see has_quaternion_dofs(). Alternative options include
a roll-pitch-yaw (rpy) parametrization of rotations, see
RpyFloatingMobilizer.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if called pre-finalize</strong><strong>,</strong> – </p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MultibodyPlant::Finalize()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[Expression].is_locked(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Determines whether this RigidBody is currently locked to its inboard
(parent) RigidBody. This is not limited to floating base bodies but
generally Joint::is_locked() is preferable otherwise.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>true if the body is locked, false otherwise.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[Expression].Lock(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>For a floating base RigidBody, lock its inboard joint. Its generalized
velocities will be 0 until it is unlocked.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if this body is not a floating base body.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[Expression].model_instance(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[Expression].name(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Gets the <code class="docutils literal notranslate"><span class="pre">name</span></code> associated with this rigid body. The name will never
be empty.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[Expression].scoped_name(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.ScopedName</span></span></dt>
<dd><p>Returns scoped name of this body. Neither of the two pieces of the
name will be empty (the scope name and the element name).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[Expression].SetCenterOfMassInBodyFrame(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">com:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>(Advanced) Sets this body’s center of mass position while preserving
its inertia about its body origin.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">out</span></code>:</dt><dd><p>] context contains the state of the multibody system. It is
modified to store the updated com (center of mass position).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">com</span></code>:</dt><dd><p>position vector from Bo (this body B’s origin) to Bcm (B’s center
of mass), expressed in B.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function changes B’s center of mass position <strong>without</strong>
modifying G_BBo_B (B’s unit inertia about Bo, expressed in B).
Since this use case is very unlikely, consider using
SetSpatialInertiaInBodyFrame() or
SetCenterOfMassInBodyFrameAndPreserveCentralInertia().</p>
</div>
<dl class="simple">
<dt>Precondition:</dt><dd><p>the context makes sense for use by this RigidBody.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if context is null.</strong> – </p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Do not use this function unless it is needed (think twice).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[Expression].SetMass(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">mass:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>For this RigidBody B, sets its mass stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> to <code class="docutils literal notranslate"><span class="pre">mass</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>mass of this rigid body B.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This function changes this body B’s mass and appropriately scales
I_BBo_B (B’s rotational inertia about Bo, expressed in B).</p>
</div>
<dl class="simple">
<dt>Precondition:</dt><dd><p>the context makes sense for use by this RigidBody.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if context is null.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[Expression].SetSpatialInertiaInBodyFrame(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">M_Bo_B:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>For this RigidBody B, sets its SpatialInertia that is stored in
<code class="docutils literal notranslate"><span class="pre">context</span></code> to <code class="docutils literal notranslate"><span class="pre">M_Bo_B</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>contains the state of the multibody system.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M_Bo_B</span></code>:</dt><dd><p>spatial inertia of this rigid body B about Bo (B’s origin),
expressed in B. M_Bo_B contains properties related to B’s mass,
the position vector from Bo to Bcm (B’s center of mass), and
G_Bo_B (B’s unit inertia about Bo expressed in B).</p>
</dd>
<dt>Precondition:</dt><dd><p>the context makes sense for use by this RigidBody.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if context is null.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBody_[Expression].Unlock(self:</span> <span class="pre">pydrake.multibody.tree.RigidBody_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>For a floating base RigidBody, unlock its inboard joint.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if this body is not a floating base body.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBodyFrame</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Frame</span></code></p>
<p>A RigidBodyFrame is a material Frame that serves as the unique
reference frame for a RigidBody.</p>
<p>Each RigidBody B has a unique body frame for which we use the same
symbol B (with meaning clear from context). We represent a body frame
by a RigidBodyFrame object that is created whenever a RigidBody is
constructed and is owned by the RigidBody. All properties of a
RigidBody are defined with respect to its RigidBodyFrame, including
its mass properties and attachment locations for joints, constraints,
actuators, geometry and so on. Run time motion of the body is defined
with respect to the motion of its body frame.</p>
<p>Note that the body frame associated with a rigid body does not
necessarily need to be located at its center of mass nor does it need
to be aligned with the body’s principal axes, although, in practice,
it frequently is.</p>
<p>A RigidBodyFrame and RigidBody are tightly coupled concepts; neither
makes sense without the other. Therefore, a RigidBodyFrame instance is
constructed in conjunction with its RigidBody and cannot be
constructed anywhere else. However, you can still access the frame
associated with a body, see RigidBody::body_frame(). This access is
more than a convenience; you can use the RigidBodyFrame to define
other frames on the body and to attach other multibody elements to it.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">RigidBodyFrame_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBodyFrame.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBodyFrame_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">RigidBodyFrame_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">RigidBodyFrame_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">RigidBodyFrame_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBodyFrame_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd]</span></code></p>
<p>A RigidBodyFrame is a material Frame that serves as the unique
reference frame for a RigidBody.</p>
<p>Each RigidBody B has a unique body frame for which we use the same
symbol B (with meaning clear from context). We represent a body frame
by a RigidBodyFrame object that is created whenever a RigidBody is
constructed and is owned by the RigidBody. All properties of a
RigidBody are defined with respect to its RigidBodyFrame, including
its mass properties and attachment locations for joints, constraints,
actuators, geometry and so on. Run time motion of the body is defined
with respect to the motion of its body frame.</p>
<p>Note that the body frame associated with a rigid body does not
necessarily need to be located at its center of mass nor does it need
to be aligned with the body’s principal axes, although, in practice,
it frequently is.</p>
<p>A RigidBodyFrame and RigidBody are tightly coupled concepts; neither
makes sense without the other. Therefore, a RigidBodyFrame instance is
constructed in conjunction with its RigidBody and cannot be
constructed anywhere else. However, you can still access the frame
associated with a body, see RigidBody::body_frame(). This access is
more than a convenience; you can use the RigidBodyFrame to define
other frames on the body and to attach other multibody elements to it.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBodyFrame_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBodyFrame_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Frame_[Expression]</span></code></p>
<p>A RigidBodyFrame is a material Frame that serves as the unique
reference frame for a RigidBody.</p>
<p>Each RigidBody B has a unique body frame for which we use the same
symbol B (with meaning clear from context). We represent a body frame
by a RigidBodyFrame object that is created whenever a RigidBody is
constructed and is owned by the RigidBody. All properties of a
RigidBody are defined with respect to its RigidBodyFrame, including
its mass properties and attachment locations for joints, constraints,
actuators, geometry and so on. Run time motion of the body is defined
with respect to the motion of its body frame.</p>
<p>Note that the body frame associated with a rigid body does not
necessarily need to be located at its center of mass nor does it need
to be aligned with the body’s principal axes, although, in practice,
it frequently is.</p>
<p>A RigidBodyFrame and RigidBody are tightly coupled concepts; neither
makes sense without the other. Therefore, a RigidBodyFrame instance is
constructed in conjunction with its RigidBody and cannot be
constructed anywhere else. However, you can still access the frame
associated with a body, see RigidBody::body_frame(). This access is
more than a convenience; you can use the RigidBodyFrame to define
other frames on the body and to attach other multibody elements to it.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RigidBodyFrame_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia</span></span></dt>
<dd><p>This class describes the mass distribution (inertia properties) of a
body or composite body about a particular point. Herein, “composite
body” means one body or a collection of bodies that are welded
together. In this documentation, “body” and “composite body” are used
interchangeably.</p>
<p>A <strong>rigid</strong> body’s mass distribution is described by three quantities:
the body’s mass; the body’s center of mass; and the body’s rotational
inertia about a particular point. The term <strong>rotational inertia</strong> is
used here and by [Jain 2010] to distinguish from a body’s <strong>spatial
inertia</strong>. In this class, a 3x3 <strong>inertia matrix</strong> I represents a
body’s rotational inertia about a point and expressed in a frame. More
specifically, <code class="docutils literal notranslate"><span class="pre">I_BP_E</span></code> is the inertia matrix of a body B about-point
P and expressed-in frame E (herein frame E’s orthogonal unit vectors
Ex, Ey, Ez are denoted 𝐱̂, 𝐲̂, 𝐳̂).</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="o">|</span><span class="w"> </span><span class="n">Ixx</span><span class="w"> </span><span class="n">Ixy</span><span class="w"> </span><span class="n">Ixz</span><span class="w"> </span><span class="o">|</span>
<span class="n">I</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Ixy</span><span class="w"> </span><span class="n">Iyy</span><span class="w"> </span><span class="n">Iyz</span><span class="w"> </span><span class="o">|</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">Ixz</span><span class="w"> </span><span class="n">Iyz</span><span class="w"> </span><span class="n">Izz</span><span class="w"> </span><span class="o">|</span>
</pre></div>
</div>
</details><p>The moments of inertia Ixx, Iyy, Izz and products of inertia Ixy, Ixz,
Iyz are defined in terms of the mass dm of a differential volume of
the body. The position of dm from about-point P is xx̂ + yŷ + zẑ =
[x, y, z]_E.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Ixx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">∫</span><span class="w"> </span><span class="p">(</span><span class="n">y²</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">z²</span><span class="p">)</span><span class="w"> </span><span class="n">dm</span>
<span class="n">Iyy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">∫</span><span class="w"> </span><span class="p">(</span><span class="n">x²</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">z²</span><span class="p">)</span><span class="w"> </span><span class="n">dm</span>
<span class="n">Izz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">∫</span><span class="w"> </span><span class="p">(</span><span class="n">x²</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y²</span><span class="p">)</span><span class="w"> </span><span class="n">dm</span>
<span class="n">Ixy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="err">∫</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">dm</span>
<span class="n">Ixz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="err">∫</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="n">dm</span>
<span class="n">Iyz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="err">∫</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="n">dm</span>
</pre></div>
</div>
</details><p>We use the negated convention for products of inertia, so that I
serves to relate angular velocity ω and angular momentum h via <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">=</span> <span class="pre">I</span>
<span class="pre">⋅</span> <span class="pre">ω</span></code>. Ensure your products of inertia follow this negative sign
convention.</p>
<p>The 3x3 inertia matrix is symmetric and its diagonal elements (moments
of inertia) and off-diagonal elements (products of inertia) are
associated with a body (or composite body) S, an about-point P, and an
expressed-in frame E (𝐱̂, 𝐲̂, 𝐳̂̂). A rotational inertia is
ill-defined unless there is a body S, about-point P, and expressed-in
frame E. The user of this class is responsible for tracking the body
S, about-point P and expressed-in frame E (none of these are stored in
this class).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class does not store the about-point nor the expressed-in
frame, nor does this class help enforce consistency of the
about-point or expressed-in frame. To help users of this class
track the about-point and expressed-in frame, we strongly
recommend the following notation.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In typeset material, use the symbol <span class="math notranslate nohighlight">\([I^{S/P}]_E\)</span> to
represent the rotational inertia (inertia matrix) of a body (or
composite body) S about-point P, expressed in frame E. In code and
comments, use the monogram notation <code class="docutils literal notranslate"><span class="pre">I_SP_E</span></code> (e.g., as described
in multibody_spatial_inertia). If the about-point P is fixed to a
body B, the point is named <span class="math notranslate nohighlight">\(B_P\)</span> and this appears in
code/comments as <code class="docutils literal notranslate"><span class="pre">Bp</span></code>. Examples: <code class="docutils literal notranslate"><span class="pre">I_BBp_E</span></code> is rigid body B’s
rotational inertia about-point Bp expressed-in frame E; I_BBo_E is
B’s rotational inertia about-point <code class="docutils literal notranslate"><span class="pre">Bo</span></code> (body B’s origin)
expressed-in frame E; and I_BBcm_E is B’s inertia matrix
about-point <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> (B’s center of mass) expressed-in frame E.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The rotational inertia (inertia matrix) can be re-expressed in
terms of a special frame whose orthogonal unit vectors are
parallel to <strong>principal axes of inertia</strong> so that the inertia
matrix is diagonalized with elements called <strong>principal moments of
inertia</strong>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The formal definition of the inertia matrix <span class="math notranslate nohighlight">\(I^{S/P}\)</span> of a
system S about a point P follows the definition of the inertia
dyadic 𝐈 of S about P, which begins by modeling S with n particles
S₁ … Sₙ (e.g., 12 grams of carbon can be modeled with n = 6.02 *
10²³ molecules/particles). The inertia dyadic 𝐈₁ of one particle
S₁ about point P is defined [Kane, 1985] in terms of m₁ (mass of
S₁), ᴾ𝐩ˢ¹ (position vector from P to S₁), and the unit dyadic 𝐔
which is defined by the property 𝐔 ⋅ 𝐯 = 𝐯 where 𝐯 is is any
vector (this definition of 𝐔 is analogous to defining the identity
matrix by the property 𝑰𝒅𝒆𝒏𝒕𝒊𝒕𝒚𝑴𝒂𝒕𝒓𝒊𝒙 * 𝒂𝒏𝒚𝑴𝒂𝒕𝒓𝒊𝒙 = 𝒂𝒏𝒚𝑴𝒂𝒕𝒓𝒊𝒙).</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">𝐈₁</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m₁</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">[</span><span class="n">𝐔</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">ᴾ𝐩ˢ¹</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">ᴾ𝐩ˢ¹</span><span class="p">)</span><span class="w">  </span><span class="o">-</span><span class="w">  </span><span class="n">ᴾ𝐩ˢ¹</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">ᴾ𝐩ˢ¹</span><span class="p">]</span>
</pre></div>
</div>
</details><p>Note: The vector dot-product (⋅) above produces a scalar whereas the
vector multiply (*) produces a dyadic which is a 2nd-order tensor
(ᴾ𝐩ˢ¹ * ᴾ𝐩ˢ¹ is similar to the matrix outer-product of a 3x1 matrix
multiplied by a 1x3 matrix). An example inertia dyadic for a single
particle is shown further below. The inertia dyadic 𝐈 of the entire
system S is defined by summing the inertia dyadic of each particle Sᵢ
about P (i = 1, … n), i.e.,</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">𝐈</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">𝐈₁</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">𝐈₂</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">𝐈ₙ</span>
</pre></div>
</div>
</details><p>The elements of the inertia matrix <span class="math notranslate nohighlight">\([I^{S/P}]_E\)</span> expressed in
frame E (in terms of orthogonal unit vectors 𝐱̂, 𝐲̂, 𝐳̂̂) are found by
pre-dot multiplying and post-dot multiplying 𝐈 with appropriate unit
vectors.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Ixx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">𝐱</span><span class="err">̂</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐈</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐱</span><span class="err">̂</span><span class="w">     </span><span class="n">Ixy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">𝐱</span><span class="err">̂</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐈</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐲</span><span class="err">̂</span><span class="w">      </span><span class="n">Ixz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">𝐱</span><span class="err">̂</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐈</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐳</span><span class="err">̂̂</span>
<span class="w">   </span><span class="n">Iyx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">𝐲</span><span class="err">̂</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐈</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐱</span><span class="err">̂</span><span class="w">     </span><span class="n">Iyy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">𝐲</span><span class="err">̂</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐈</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐲</span><span class="err">̂</span><span class="w">      </span><span class="n">Iyz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">𝐲</span><span class="err">̂</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐈</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐳</span><span class="err">̂̂</span>
<span class="w">   </span><span class="n">Izx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">𝐳</span><span class="err">̂̂</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐈</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐱</span><span class="err">̂</span><span class="w">     </span><span class="n">Izy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">𝐳</span><span class="err">̂̂</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐈</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐲</span><span class="err">̂</span><span class="w">      </span><span class="n">Izz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">𝐳</span><span class="err">̂̂</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐈</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐳</span><span class="err">̂̂</span>
</pre></div>
</div>
</details><p>The inertia dyadic 𝐈ᴮ of a rigid body B about Bcm (B’s center of mass)
is related to various dynamic quantities. For example, B’s angular
momentum 𝐇 about Bcm in a frame N and B’s kinetic energy KE in N
relate to 𝐈ᴮ by</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">𝐇</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">𝐈ᴮ</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝛚</span>
<span class="w">   </span><span class="n">KE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="w"> </span><span class="n">𝛚</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐈ᴮ</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝛚</span><span class="w">  </span><span class="o">+</span><span class="w">  </span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="w"> </span><span class="n">mᴮ</span><span class="w"> </span><span class="n">𝐯</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐯</span>
</pre></div>
</div>
</details><p>where 𝛚 is B’s angular velocity in N, 𝐯 is Bcm’s translational
velocity in N, and mᴮ is B’s mass. When frame N happens to be a
Newtonian frame (also called an inertial frame or
non-rotating/non-accelerating frame), the moment 𝐓 of all forces on B
about Bcm relates to 𝐈ᴮ and 𝛂 (B’s angular acceleration in N) by
Euler’s rigid body equation as</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">𝐓</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">𝐈ᴮ</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝛂</span><span class="w">  </span><span class="o">+</span><span class="w">  </span><span class="n">𝛚</span><span class="w"> </span><span class="err">×</span><span class="w"> </span><span class="n">𝐈ᴮ</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝛚</span>
</pre></div>
</div>
</details><p>Example: For a particle Q of mass m whose position vector from a point
O is written in terms of right-handed orthogonal unit vectors 𝐱̂, 𝐲̂,
𝐳̂ (below), the inertia dyadic 𝐈 of particle Q about point O is
defined and calculated</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">𝐩</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">𝐱</span><span class="err">̂</span><span class="w">  </span><span class="o">+</span><span class="w">  </span><span class="n">y</span><span class="w"> </span><span class="n">𝐲</span><span class="err">̂</span><span class="w">                               </span><span class="p">(</span><span class="n">given</span><span class="p">)</span>
<span class="w">    </span><span class="n">𝐈</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">[</span><span class="n">𝐔</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">𝐩</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐩</span><span class="p">)</span><span class="w">  </span><span class="o">-</span><span class="w">  </span><span class="n">𝐩</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">𝐩</span><span class="p">]</span><span class="w">              </span><span class="p">(</span><span class="n">definition</span><span class="p">)</span>
<span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">[</span><span class="n">𝐔</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">x²</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y²</span><span class="p">)</span><span class="w">  </span><span class="o">-</span><span class="w">  </span><span class="p">(</span><span class="n">x𝐱</span><span class="err">̂</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y𝐲</span><span class="err">̂̂</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">x𝐱</span><span class="err">̂</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y𝐲</span><span class="err">̂</span><span class="p">)</span>
<span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">[(</span><span class="n">𝐱</span><span class="err">̂</span><span class="n">𝐱</span><span class="err">̂</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">𝐲</span><span class="err">̂</span><span class="n">𝐲</span><span class="err">̂</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">𝐳</span><span class="err">̂</span><span class="n">𝐳</span><span class="err">̂</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">x²</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y²</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">x²𝐱</span><span class="err">̂</span><span class="n">𝐱</span><span class="err">̂</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">xy𝐱</span><span class="err">̂</span><span class="n">𝐲</span><span class="err">̂̂</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">xy𝐲</span><span class="err">̂̂</span><span class="n">𝐱</span><span class="err">̂</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y²𝐲</span><span class="err">̂̂</span><span class="n">𝐲</span><span class="err">̂̂</span><span class="p">)]</span>
<span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">[</span><span class="n">y²𝐱</span><span class="err">̂</span><span class="n">𝐱</span><span class="err">̂</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x²𝐲</span><span class="err">̂</span><span class="n">𝐲</span><span class="err">̂</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">x²</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y²</span><span class="p">)</span><span class="n">𝐳</span><span class="err">̂</span><span class="n">𝐳</span><span class="err">̂</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">xy𝐱</span><span class="err">̂</span><span class="n">𝐲</span><span class="err">̂̂</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">xy𝐲</span><span class="err">̂̂</span><span class="n">𝐱</span><span class="err">̂</span><span class="p">]</span>
</pre></div>
</div>
</details><p>which means the inertia matrix for particle Q about point O for 𝐱̂,
𝐲̂, 𝐳̂ is</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="o">|</span><span class="w">  </span><span class="n">m</span><span class="w"> </span><span class="n">y²</span><span class="w">     </span><span class="o">-</span><span class="n">m</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w">         </span><span class="mi">0</span><span class="w">     </span><span class="o">|</span>
<span class="n">I</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">-</span><span class="n">m</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w">     </span><span class="n">m</span><span class="w"> </span><span class="n">x²</span><span class="w">          </span><span class="mi">0</span><span class="w">     </span><span class="o">|</span>
<span class="w">    </span><span class="o">|</span><span class="w">    </span><span class="mi">0</span><span class="w">         </span><span class="mi">0</span><span class="w">     </span><span class="n">m</span><span class="w"> </span><span class="p">(</span><span class="n">x²</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y²</span><span class="p">)</span><span class="w"> </span><span class="o">|</span>
</pre></div>
</div>
</details><p>[Kane, 1985] pg. 68. “Dynamics: Theory and Applications,” McGraw-Hill
Co., New York, 1985 (with D. A. Levinson). Available for free .pdf
download: <a class="reference external" href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Several methods in this class throw a RuntimeError for invalid
rotational inertia operations in debug releases only. This
provides speed in a release build while facilitating debugging in
debug builds. In addition, these validity tests are only performed
for scalar types for which drake::scalar_predicate&lt;T&gt;::is_bool is
<code class="docutils literal notranslate"><span class="pre">True</span></code>. For instance, validity checks are not performed when T
is symbolic::Expression.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The methods of this class satisfy the “basic exception guarantee”:
if an exception is thrown, the program will still be in a valid
state. Specifically, no resources are leaked, and all objects’
invariants are intact. Be aware that RotationalInertia objects may
contain invalid inertia data in cases where input checking is
skipped.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://en.cppreference.com/w/cpp/language/exceptions">https://en.cppreference.com/w/cpp/language/exceptions</a></p>
</div>
<p>Various methods in this class require numerical (not symbolic) data
types.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">RotationalInertia_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.tree.RotationalInertia) -&gt; None</p></li>
</ol>
<p>Constructs a rotational inertia that has all its moments/products of
inertia equal to NaN (helps quickly detect uninitialized values).</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.tree.RotationalInertia, Ixx: float, Iyy: float, Izz: float) -&gt; None</p></li>
</ol>
<p>Creates a rotational inertia with moments of inertia <code class="docutils literal notranslate"><span class="pre">Ixx</span></code>, <cite>Iyy</cite>,
<code class="docutils literal notranslate"><span class="pre">Izz</span></code>, and with each product of inertia set to zero.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError for Debug builds if not CouldBePhysicallyValid</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.multibody.tree.RotationalInertia, Ixx: float, Iyy: float, Izz: float, Ixy: float, Ixz: float, Iyz: float) -&gt; None</p></li>
</ol>
<p>Creates a rotational inertia with moments of inertia <code class="docutils literal notranslate"><span class="pre">Ixx</span></code>, <cite>Iyy</cite>,
<code class="docutils literal notranslate"><span class="pre">Izz</span></code>, and with products of inertia <code class="docutils literal notranslate"><span class="pre">Ixy</span></code>, <cite>Ixz</cite>, <code class="docutils literal notranslate"><span class="pre">Iyz</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError for Debug builds if not CouldBePhysicallyValid</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.multibody.tree.RotationalInertia, mass: float, p_PQ_E: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs a rotational inertia for a particle Q of mass <code class="docutils literal notranslate"><span class="pre">mass</span></code>,
whose position vector from about-point P is p_PQ_E (E is expressed-in
frame). This RuntimeError exception only occurs if <code class="docutils literal notranslate"><span class="pre">mass</span></code> &lt; 0.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>The mass of particle Q.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PQ_E</span></code>:</dt><dd><p>Position from about-point P to Q, expressed-in frame E.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">I_QP_E</span></code>:</dt><dd><p>, Q’s rotational inertia about-point P expressed-in frame E.</p>
</dd>
<dt>Remark:</dt><dd><p>Negating the position vector p_PQ_E has no affect on the result.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError for Debug builds if not CouldBePhysicallyValid</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia.CalcMaximumPossibleMomentOfInertia(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the maximum possible moment of inertia for <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational
inertia about-point P for any expressed-in frame E.</p>
<dl class="simple">
<dt>Remark:</dt><dd><p>The maximum moment Imax has range: trace / 3 &lt;= Imax &lt;= trace / 2.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Trace()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia.CalcPrincipalMomentsAndAxesOfInertia(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia)</span> <span class="pre">-&gt;</span> <span class="pre">tuple[numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">pydrake.math.RotationMatrix]</span></span></dt>
<dd><p>Forms the 3 principal moments of inertia and their 3 associated
principal directions for <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>3 principal moments of inertia [Ixx Iyy Izz], sorted in ascending
order (Ixx ≤ Iyy ≤ Izz) and a rotation matrix R_EA whose columns
are the 3 associated principal directions that relate the
expressed-in frame E to a frame A, where frame E is the
expressed-in frame for <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia I_BP_E (body
B’s rotational inertia about-point P) and frame A contains
right-handed orthonormal vectors Ax, Ay, Az. The 1ˢᵗ column of
R_EA is Ax_E (Ax expressed in frame E) which is parallel to the
principal axis associated with Ixx (the smallest principal moment
of inertia). Similarly, the 2ⁿᵈ and 3ʳᵈ columns of R_EA are Ay_E
and Az_E, which are parallel to principal axes associated with Iyy
and Izz (the intermediate and largest principal moments of
inertia). If all principal moments of inertia are equal (i.e., Ixx
= Iyy = Izz), R_EA is the identity matrix.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if the elements</strong><strong> of </strong><strong>this rotational inertia cannot</strong> – </p></li>
<li><p><strong>be converted to a real finite double. For example</strong><strong>, </strong><strong>an exception is</strong> – </p></li>
<li><p><strong>thrown if this contains an erroneous NaN</strong><strong> or </strong><strong>if scalar type T</strong> – </p></li>
<li><p><strong>is symbolic.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcPrincipalMomentsOfInertia() to calculate the principal moments
of inertia [Ixx Iyy Izz], without calculating the principal
directions.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia.CalcPrincipalMomentsOfInertia(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Forms the 3 principal moments of inertia for <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational
inertia.</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">The</span></code>:</dt><dd><p>3 principal moments of inertia [Imin Imed Imax], sorted in
ascending order (Imin ≤ Imed ≤ Imax).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the elements</strong><strong> of </strong><strong>this rotational inertia cannot</strong> – </p></li>
<li><p><strong>be converted to a real finite double. For example</strong><strong>, </strong><strong>an exception is</strong> – </p></li>
<li><p><strong>thrown if this contains an erroneous NaN</strong><strong> or </strong><strong>if scalar type T</strong> – </p></li>
<li><p><strong>is symbolic.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcPrincipalMomentsAndAxesOfInertia() to also calculate principal
moment of inertia directions associated with <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational
inertia.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia.cols(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>For consistency with Eigen’s API, the cols() method returns 3.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia.CopyToFullMatrix3(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">3]]</span></span></dt>
<dd><p>Gets a full 3x3 matrix copy of this rotational inertia. The returned
copy is symmetric and includes both lower and upper parts of the
matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia.CouldBePhysicallyValid(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Performs several checks to verify whether <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia
<em>could</em> be physically valid, including:</p>
<ul class="simple">
<li><p>No NaN moments or products of inertia.</p></li>
<li><p>Ixx, Iyy, Izz and principal moments are all non-negative.</p></li>
<li><p>Ixx, Iyy  Izz and principal moments satisfy the triangle inequality:
- <code class="docutils literal notranslate"><span class="pre">Ixx</span> <span class="pre">+</span> <span class="pre">Iyy</span> <span class="pre">≥</span> <span class="pre">Izz</span></code>
- <cite>Ixx + Izz ≥ Iyy</cite>
- <code class="docutils literal notranslate"><span class="pre">Iyy</span> <span class="pre">+</span> <span class="pre">Izz</span> <span class="pre">≥</span> <span class="pre">Ixx</span></code></p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>These checks are necessary (but NOT sufficient) conditions for a
rotational inertia to be physically valid. The sufficient
condition requires a rotational inertia to satisfy the above
checks <em>after</em> <code class="docutils literal notranslate"><span class="pre">this</span></code> is shifted to the center of mass, i.e.,
the sufficient condition requires calling CouldBePhysicallyValid()
when the about-point is Bcm (the body’s center of mass). Note:
this class does not know its about-point or its center of mass
location.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> for a plausible rotational inertia passing the above
necessary but insufficient checks and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if principal moments</strong><strong> of </strong><strong>inertia cannot be calculated</strong> – </p></li>
<li><p><strong>(</strong><strong>eigenvalue solver</strong><strong>) or </strong><strong>if scalar type T cannot be converted to a</strong> – </p></li>
<li><p><strong>double.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia.get_moments(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns 3-element vector with moments of inertia [Ixx, Iyy, Izz].</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia.get_products(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns 3-element vector with products of inertia [Ixy, Ixz, Iyz].</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia.IsNaN(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if any moment/product in <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia
is NaN. Otherwise returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia.IsNearlyEqualTo(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia,</span> <span class="pre">other:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia,</span> <span class="pre">precision:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Compares <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia to <code class="docutils literal notranslate"><span class="pre">other</span></code> rotational inertia
within the specified <code class="docutils literal notranslate"><span class="pre">precision</span></code> (which is a dimensionless number
specifying the relative precision to which the comparison is
performed). Denoting <code class="docutils literal notranslate"><span class="pre">I_maxA</span></code> as the largest element value that can
appear in a valid <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia (independent of the
expressed-in frame E) and denoting <code class="docutils literal notranslate"><span class="pre">I_maxB</span></code> as the largest element
value that can appear in a valid <code class="docutils literal notranslate"><span class="pre">other</span></code> rotational inertia
(independent of the expressed-in frame E), <code class="docutils literal notranslate"><span class="pre">this</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code> are
considered nearly equal to each other, if: ‖this - other‖∞ &lt; precision
* min(I_maxA, I_maxB)</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other</span></code>:</dt><dd><p>Rotational inertia to compare with <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">precision</span></code>:</dt><dd><p>is a dimensionless real positive number that is usually based on
two factors, namely expected accuracy of moments/products of
inertia (e.g., from end-user or CAD) and/or machine-precision.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if the absolute value of each moment/product of inertia
in <code class="docutils literal notranslate"><span class="pre">this</span></code> is within <code class="docutils literal notranslate"><span class="pre">epsilon</span></code> of the corresponding moment/
product absolute value in <code class="docutils literal notranslate"><span class="pre">other</span></code>. Otherwise returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>: This method only works if all moments of inertia with scalar
type T in <code class="docutils literal notranslate"><span class="pre">this</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code> can be converted to a double
(discarding supplemental scalar data such as derivatives of an
AutoDiffXd). It fails at runtime if type T cannot be converted to
<code class="docutils literal notranslate"><span class="pre">double</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia.IsZero(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if all moments and products of inertia are exactly
zero.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia.ReExpress(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia,</span> <span class="pre">R_AE:</span> <span class="pre">pydrake.math.RotationMatrix)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RotationalInertia</span></span></dt>
<dd><p>Re-expresses <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia <code class="docutils literal notranslate"><span class="pre">I_BP_E</span></code> to <code class="docutils literal notranslate"><span class="pre">I_BP_A</span></code>
i.e., re-expresses body B’s rotational inertia from frame E to frame
A.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_AE</span></code>:</dt><dd><p>RotationMatrix relating frames A and E.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">I_BP_A</span></code>:</dt><dd><p>Rotational inertia of B about-point P expressed-in frame A.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError for Debug builds if the rotational inertia that is</strong> – </p></li>
<li><p><strong>re-expressed-in frame A violates CouldBePhysicallyValid</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ReExpressInPlace()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia.rows(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>For consistency with Eigen’s API, the rows() method returns 3.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia.SetToNaN(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia so all its elements are equal to NaN.
This helps quickly detect uninitialized moments/products of inertia.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia.SetZero(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia so all its moments/products of
inertia are zero, e.g., for convenient initialization before a
computation or for inertia calculations involving a particle
(point-mass). Note: Real 3D massive physical objects have non-zero
moments of inertia.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia.ShiftFromCenterOfMass(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia,</span> <span class="pre">mass:</span> <span class="pre">float,</span> <span class="pre">p_BcmQ_E:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RotationalInertia</span></span></dt>
<dd><p>Calculates the rotational inertia that results from shifting <code class="docutils literal notranslate"><span class="pre">this</span></code>
rotational inertia for a body (or composite body) B from about-point
Bcm (B’s center of mass) to about-point Q. I.e., shifts <code class="docutils literal notranslate"><span class="pre">I_BBcm_E</span></code>
to <code class="docutils literal notranslate"><span class="pre">I_BQ_E</span></code> (both are expressed-in frame E).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>The mass of body (or composite body) B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BcmQ_E</span></code>:</dt><dd><p>Position vector from Bcm to Q, expressed-in frame E.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">I_BQ_E</span></code>:</dt><dd><p>B’s rotational inertia about-point Q expressed-in frame E.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError for Debug builds if the rotational inertia that is</strong> – </p></li>
<li><p><strong>shifted to about-point Q violates CouldBePhysicallyValid</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Remark:</dt><dd><p>Negating the position vector p_BcmQ_E has no affect on the result.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia.ShiftToCenterOfMass(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia,</span> <span class="pre">mass:</span> <span class="pre">float,</span> <span class="pre">p_QBcm_E:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RotationalInertia</span></span></dt>
<dd><p>Calculates the rotational inertia that results from shifting <code class="docutils literal notranslate"><span class="pre">this</span></code>
rotational inertia for a body (or composite body) B from about-point Q
to about-point <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> (B’s center of mass). I.e., shifts <code class="docutils literal notranslate"><span class="pre">I_BQ_E</span></code>
to <code class="docutils literal notranslate"><span class="pre">I_BBcm_E</span></code> (both are expressed-in frame E).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>The mass of body (or composite body) B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_QBcm_E</span></code>:</dt><dd><p>Position vector from Q to <code class="docutils literal notranslate"><span class="pre">Bcm</span></code>, expressed-in frame E.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">I_BBcm_E</span></code>:</dt><dd><p>B’s rotational inertia about-point <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> expressed-in frame E.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError for Debug builds if the rotational inertia that is</strong> – </p></li>
<li><p><strong>shifted to about-point Bcm violates CouldBePhysicallyValid</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Remark:</dt><dd><p>Negating the position vector <code class="docutils literal notranslate"><span class="pre">p_QBcm_E</span></code> has no affect on the
result.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia.ShiftToThenAwayFromCenterOfMass(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia,</span> <span class="pre">mass:</span> <span class="pre">float,</span> <span class="pre">p_PBcm_E:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">p_QBcm_E:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RotationalInertia</span></span></dt>
<dd><p>Calculates the rotational inertia that results from shifting <code class="docutils literal notranslate"><span class="pre">this</span></code>
rotational inertia for a body (or composite body) B from about-point P
to about-point Q via Bcm (B’s center of mass). I.e., shifts <code class="docutils literal notranslate"><span class="pre">I_BP_E</span></code>
to <code class="docutils literal notranslate"><span class="pre">I_BQ_E</span></code> (both are expressed-in frame E).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>The mass of body (or composite body) B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PBcm_E</span></code>:</dt><dd><p>Position vector from P to Bcm, expressed-in frame E.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_QBcm_E</span></code>:</dt><dd><p>Position vector from Q to Bcm, expressed-in frame E.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">I_BQ_E</span></code>:</dt><dd><p>, B’s rotational inertia about-point Q expressed-in frame E.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError for Debug builds if the rotational inertia that is</strong> – </p></li>
<li><p><strong>shifted to about-point Q violates CouldBePhysicallyValid</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Remark:</dt><dd><p>Negating either (or both) position vectors p_PBcm_E and p_QBcm_E
has no affect on the result.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia.Trace(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns a rotational inertia’s trace (i.e., Ixx + Iyy + Izz, the sum
of the diagonal elements of the inertia matrix). The trace happens to
be invariant to its expressed-in frame (i.e., the trace does not
depend on the frame in which it is expressed). The trace is useful
because the largest moment of inertia Imax has range: trace / 3 &lt;=
Imax &lt;= trace / 2, and the largest possible product of inertia must be
&lt;= Imax / 2. Hence, trace / 3 and trace / 2 give a lower and upper
bound on the largest possible element that can be in a valid
rotational inertia.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia.TriaxiallySymmetric(I_triaxial:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RotationalInertia</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">RotationalInertia_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">RotationalInertia_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">RotationalInertia_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[AutoDiffXd]</span></span></dt>
<dd><p>This class describes the mass distribution (inertia properties) of a
body or composite body about a particular point. Herein, “composite
body” means one body or a collection of bodies that are welded
together. In this documentation, “body” and “composite body” are used
interchangeably.</p>
<p>A <strong>rigid</strong> body’s mass distribution is described by three quantities:
the body’s mass; the body’s center of mass; and the body’s rotational
inertia about a particular point. The term <strong>rotational inertia</strong> is
used here and by [Jain 2010] to distinguish from a body’s <strong>spatial
inertia</strong>. In this class, a 3x3 <strong>inertia matrix</strong> I represents a
body’s rotational inertia about a point and expressed in a frame. More
specifically, <code class="docutils literal notranslate"><span class="pre">I_BP_E</span></code> is the inertia matrix of a body B about-point
P and expressed-in frame E (herein frame E’s orthogonal unit vectors
Ex, Ey, Ez are denoted 𝐱̂, 𝐲̂, 𝐳̂).</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="o">|</span><span class="w"> </span><span class="n">Ixx</span><span class="w"> </span><span class="n">Ixy</span><span class="w"> </span><span class="n">Ixz</span><span class="w"> </span><span class="o">|</span>
<span class="n">I</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Ixy</span><span class="w"> </span><span class="n">Iyy</span><span class="w"> </span><span class="n">Iyz</span><span class="w"> </span><span class="o">|</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">Ixz</span><span class="w"> </span><span class="n">Iyz</span><span class="w"> </span><span class="n">Izz</span><span class="w"> </span><span class="o">|</span>
</pre></div>
</div>
</details><p>The moments of inertia Ixx, Iyy, Izz and products of inertia Ixy, Ixz,
Iyz are defined in terms of the mass dm of a differential volume of
the body. The position of dm from about-point P is xx̂ + yŷ + zẑ =
[x, y, z]_E.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Ixx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">∫</span><span class="w"> </span><span class="p">(</span><span class="n">y²</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">z²</span><span class="p">)</span><span class="w"> </span><span class="n">dm</span>
<span class="n">Iyy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">∫</span><span class="w"> </span><span class="p">(</span><span class="n">x²</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">z²</span><span class="p">)</span><span class="w"> </span><span class="n">dm</span>
<span class="n">Izz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">∫</span><span class="w"> </span><span class="p">(</span><span class="n">x²</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y²</span><span class="p">)</span><span class="w"> </span><span class="n">dm</span>
<span class="n">Ixy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="err">∫</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">dm</span>
<span class="n">Ixz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="err">∫</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="n">dm</span>
<span class="n">Iyz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="err">∫</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="n">dm</span>
</pre></div>
</div>
</details><p>We use the negated convention for products of inertia, so that I
serves to relate angular velocity ω and angular momentum h via <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">=</span> <span class="pre">I</span>
<span class="pre">⋅</span> <span class="pre">ω</span></code>. Ensure your products of inertia follow this negative sign
convention.</p>
<p>The 3x3 inertia matrix is symmetric and its diagonal elements (moments
of inertia) and off-diagonal elements (products of inertia) are
associated with a body (or composite body) S, an about-point P, and an
expressed-in frame E (𝐱̂, 𝐲̂, 𝐳̂̂). A rotational inertia is
ill-defined unless there is a body S, about-point P, and expressed-in
frame E. The user of this class is responsible for tracking the body
S, about-point P and expressed-in frame E (none of these are stored in
this class).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class does not store the about-point nor the expressed-in
frame, nor does this class help enforce consistency of the
about-point or expressed-in frame. To help users of this class
track the about-point and expressed-in frame, we strongly
recommend the following notation.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In typeset material, use the symbol <span class="math notranslate nohighlight">\([I^{S/P}]_E\)</span> to
represent the rotational inertia (inertia matrix) of a body (or
composite body) S about-point P, expressed in frame E. In code and
comments, use the monogram notation <code class="docutils literal notranslate"><span class="pre">I_SP_E</span></code> (e.g., as described
in multibody_spatial_inertia). If the about-point P is fixed to a
body B, the point is named <span class="math notranslate nohighlight">\(B_P\)</span> and this appears in
code/comments as <code class="docutils literal notranslate"><span class="pre">Bp</span></code>. Examples: <code class="docutils literal notranslate"><span class="pre">I_BBp_E</span></code> is rigid body B’s
rotational inertia about-point Bp expressed-in frame E; I_BBo_E is
B’s rotational inertia about-point <code class="docutils literal notranslate"><span class="pre">Bo</span></code> (body B’s origin)
expressed-in frame E; and I_BBcm_E is B’s inertia matrix
about-point <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> (B’s center of mass) expressed-in frame E.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The rotational inertia (inertia matrix) can be re-expressed in
terms of a special frame whose orthogonal unit vectors are
parallel to <strong>principal axes of inertia</strong> so that the inertia
matrix is diagonalized with elements called <strong>principal moments of
inertia</strong>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The formal definition of the inertia matrix <span class="math notranslate nohighlight">\(I^{S/P}\)</span> of a
system S about a point P follows the definition of the inertia
dyadic 𝐈 of S about P, which begins by modeling S with n particles
S₁ … Sₙ (e.g., 12 grams of carbon can be modeled with n = 6.02 *
10²³ molecules/particles). The inertia dyadic 𝐈₁ of one particle
S₁ about point P is defined [Kane, 1985] in terms of m₁ (mass of
S₁), ᴾ𝐩ˢ¹ (position vector from P to S₁), and the unit dyadic 𝐔
which is defined by the property 𝐔 ⋅ 𝐯 = 𝐯 where 𝐯 is is any
vector (this definition of 𝐔 is analogous to defining the identity
matrix by the property 𝑰𝒅𝒆𝒏𝒕𝒊𝒕𝒚𝑴𝒂𝒕𝒓𝒊𝒙 * 𝒂𝒏𝒚𝑴𝒂𝒕𝒓𝒊𝒙 = 𝒂𝒏𝒚𝑴𝒂𝒕𝒓𝒊𝒙).</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">𝐈₁</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m₁</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">[</span><span class="n">𝐔</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">ᴾ𝐩ˢ¹</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">ᴾ𝐩ˢ¹</span><span class="p">)</span><span class="w">  </span><span class="o">-</span><span class="w">  </span><span class="n">ᴾ𝐩ˢ¹</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">ᴾ𝐩ˢ¹</span><span class="p">]</span>
</pre></div>
</div>
</details><p>Note: The vector dot-product (⋅) above produces a scalar whereas the
vector multiply (*) produces a dyadic which is a 2nd-order tensor
(ᴾ𝐩ˢ¹ * ᴾ𝐩ˢ¹ is similar to the matrix outer-product of a 3x1 matrix
multiplied by a 1x3 matrix). An example inertia dyadic for a single
particle is shown further below. The inertia dyadic 𝐈 of the entire
system S is defined by summing the inertia dyadic of each particle Sᵢ
about P (i = 1, … n), i.e.,</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">𝐈</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">𝐈₁</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">𝐈₂</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">𝐈ₙ</span>
</pre></div>
</div>
</details><p>The elements of the inertia matrix <span class="math notranslate nohighlight">\([I^{S/P}]_E\)</span> expressed in
frame E (in terms of orthogonal unit vectors 𝐱̂, 𝐲̂, 𝐳̂̂) are found by
pre-dot multiplying and post-dot multiplying 𝐈 with appropriate unit
vectors.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Ixx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">𝐱</span><span class="err">̂</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐈</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐱</span><span class="err">̂</span><span class="w">     </span><span class="n">Ixy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">𝐱</span><span class="err">̂</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐈</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐲</span><span class="err">̂</span><span class="w">      </span><span class="n">Ixz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">𝐱</span><span class="err">̂</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐈</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐳</span><span class="err">̂̂</span>
<span class="w">   </span><span class="n">Iyx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">𝐲</span><span class="err">̂</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐈</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐱</span><span class="err">̂</span><span class="w">     </span><span class="n">Iyy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">𝐲</span><span class="err">̂</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐈</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐲</span><span class="err">̂</span><span class="w">      </span><span class="n">Iyz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">𝐲</span><span class="err">̂</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐈</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐳</span><span class="err">̂̂</span>
<span class="w">   </span><span class="n">Izx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">𝐳</span><span class="err">̂̂</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐈</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐱</span><span class="err">̂</span><span class="w">     </span><span class="n">Izy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">𝐳</span><span class="err">̂̂</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐈</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐲</span><span class="err">̂</span><span class="w">      </span><span class="n">Izz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">𝐳</span><span class="err">̂̂</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐈</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐳</span><span class="err">̂̂</span>
</pre></div>
</div>
</details><p>The inertia dyadic 𝐈ᴮ of a rigid body B about Bcm (B’s center of mass)
is related to various dynamic quantities. For example, B’s angular
momentum 𝐇 about Bcm in a frame N and B’s kinetic energy KE in N
relate to 𝐈ᴮ by</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">𝐇</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">𝐈ᴮ</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝛚</span>
<span class="w">   </span><span class="n">KE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="w"> </span><span class="n">𝛚</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐈ᴮ</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝛚</span><span class="w">  </span><span class="o">+</span><span class="w">  </span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="w"> </span><span class="n">mᴮ</span><span class="w"> </span><span class="n">𝐯</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐯</span>
</pre></div>
</div>
</details><p>where 𝛚 is B’s angular velocity in N, 𝐯 is Bcm’s translational
velocity in N, and mᴮ is B’s mass. When frame N happens to be a
Newtonian frame (also called an inertial frame or
non-rotating/non-accelerating frame), the moment 𝐓 of all forces on B
about Bcm relates to 𝐈ᴮ and 𝛂 (B’s angular acceleration in N) by
Euler’s rigid body equation as</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">𝐓</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">𝐈ᴮ</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝛂</span><span class="w">  </span><span class="o">+</span><span class="w">  </span><span class="n">𝛚</span><span class="w"> </span><span class="err">×</span><span class="w"> </span><span class="n">𝐈ᴮ</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝛚</span>
</pre></div>
</div>
</details><p>Example: For a particle Q of mass m whose position vector from a point
O is written in terms of right-handed orthogonal unit vectors 𝐱̂, 𝐲̂,
𝐳̂ (below), the inertia dyadic 𝐈 of particle Q about point O is
defined and calculated</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">𝐩</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">𝐱</span><span class="err">̂</span><span class="w">  </span><span class="o">+</span><span class="w">  </span><span class="n">y</span><span class="w"> </span><span class="n">𝐲</span><span class="err">̂</span><span class="w">                               </span><span class="p">(</span><span class="n">given</span><span class="p">)</span>
<span class="w">    </span><span class="n">𝐈</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">[</span><span class="n">𝐔</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">𝐩</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐩</span><span class="p">)</span><span class="w">  </span><span class="o">-</span><span class="w">  </span><span class="n">𝐩</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">𝐩</span><span class="p">]</span><span class="w">              </span><span class="p">(</span><span class="n">definition</span><span class="p">)</span>
<span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">[</span><span class="n">𝐔</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">x²</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y²</span><span class="p">)</span><span class="w">  </span><span class="o">-</span><span class="w">  </span><span class="p">(</span><span class="n">x𝐱</span><span class="err">̂</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y𝐲</span><span class="err">̂̂</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">x𝐱</span><span class="err">̂</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y𝐲</span><span class="err">̂</span><span class="p">)</span>
<span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">[(</span><span class="n">𝐱</span><span class="err">̂</span><span class="n">𝐱</span><span class="err">̂</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">𝐲</span><span class="err">̂</span><span class="n">𝐲</span><span class="err">̂</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">𝐳</span><span class="err">̂</span><span class="n">𝐳</span><span class="err">̂</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">x²</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y²</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">x²𝐱</span><span class="err">̂</span><span class="n">𝐱</span><span class="err">̂</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">xy𝐱</span><span class="err">̂</span><span class="n">𝐲</span><span class="err">̂̂</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">xy𝐲</span><span class="err">̂̂</span><span class="n">𝐱</span><span class="err">̂</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y²𝐲</span><span class="err">̂̂</span><span class="n">𝐲</span><span class="err">̂̂</span><span class="p">)]</span>
<span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">[</span><span class="n">y²𝐱</span><span class="err">̂</span><span class="n">𝐱</span><span class="err">̂</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x²𝐲</span><span class="err">̂</span><span class="n">𝐲</span><span class="err">̂</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">x²</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y²</span><span class="p">)</span><span class="n">𝐳</span><span class="err">̂</span><span class="n">𝐳</span><span class="err">̂</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">xy𝐱</span><span class="err">̂</span><span class="n">𝐲</span><span class="err">̂̂</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">xy𝐲</span><span class="err">̂̂</span><span class="n">𝐱</span><span class="err">̂</span><span class="p">]</span>
</pre></div>
</div>
</details><p>which means the inertia matrix for particle Q about point O for 𝐱̂,
𝐲̂, 𝐳̂ is</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="o">|</span><span class="w">  </span><span class="n">m</span><span class="w"> </span><span class="n">y²</span><span class="w">     </span><span class="o">-</span><span class="n">m</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w">         </span><span class="mi">0</span><span class="w">     </span><span class="o">|</span>
<span class="n">I</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">-</span><span class="n">m</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w">     </span><span class="n">m</span><span class="w"> </span><span class="n">x²</span><span class="w">          </span><span class="mi">0</span><span class="w">     </span><span class="o">|</span>
<span class="w">    </span><span class="o">|</span><span class="w">    </span><span class="mi">0</span><span class="w">         </span><span class="mi">0</span><span class="w">     </span><span class="n">m</span><span class="w"> </span><span class="p">(</span><span class="n">x²</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y²</span><span class="p">)</span><span class="w"> </span><span class="o">|</span>
</pre></div>
</div>
</details><p>[Kane, 1985] pg. 68. “Dynamics: Theory and Applications,” McGraw-Hill
Co., New York, 1985 (with D. A. Levinson). Available for free .pdf
download: <a class="reference external" href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Several methods in this class throw a RuntimeError for invalid
rotational inertia operations in debug releases only. This
provides speed in a release build while facilitating debugging in
debug builds. In addition, these validity tests are only performed
for scalar types for which drake::scalar_predicate&lt;T&gt;::is_bool is
<code class="docutils literal notranslate"><span class="pre">True</span></code>. For instance, validity checks are not performed when T
is symbolic::Expression.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The methods of this class satisfy the “basic exception guarantee”:
if an exception is thrown, the program will still be in a valid
state. Specifically, no resources are leaked, and all objects’
invariants are intact. Be aware that RotationalInertia objects may
contain invalid inertia data in cases where input checking is
skipped.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://en.cppreference.com/w/cpp/language/exceptions">https://en.cppreference.com/w/cpp/language/exceptions</a></p>
</div>
<p>Various methods in this class require numerical (not symbolic) data
types.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Constructs a rotational inertia that has all its moments/products of
inertia equal to NaN (helps quickly detect uninitialized values).</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.tree.RotationalInertia_[AutoDiffXd], Ixx: pydrake.autodiffutils.AutoDiffXd, Iyy: pydrake.autodiffutils.AutoDiffXd, Izz: pydrake.autodiffutils.AutoDiffXd) -&gt; None</p></li>
</ol>
<p>Creates a rotational inertia with moments of inertia <code class="docutils literal notranslate"><span class="pre">Ixx</span></code>, <cite>Iyy</cite>,
<code class="docutils literal notranslate"><span class="pre">Izz</span></code>, and with each product of inertia set to zero.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError for Debug builds if not CouldBePhysicallyValid</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.multibody.tree.RotationalInertia_[AutoDiffXd], Ixx: pydrake.autodiffutils.AutoDiffXd, Iyy: pydrake.autodiffutils.AutoDiffXd, Izz: pydrake.autodiffutils.AutoDiffXd, Ixy: pydrake.autodiffutils.AutoDiffXd, Ixz: pydrake.autodiffutils.AutoDiffXd, Iyz: pydrake.autodiffutils.AutoDiffXd) -&gt; None</p></li>
</ol>
<p>Creates a rotational inertia with moments of inertia <code class="docutils literal notranslate"><span class="pre">Ixx</span></code>, <cite>Iyy</cite>,
<code class="docutils literal notranslate"><span class="pre">Izz</span></code>, and with products of inertia <code class="docutils literal notranslate"><span class="pre">Ixy</span></code>, <cite>Ixz</cite>, <code class="docutils literal notranslate"><span class="pre">Iyz</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError for Debug builds if not CouldBePhysicallyValid</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.multibody.tree.RotationalInertia_[AutoDiffXd], mass: pydrake.autodiffutils.AutoDiffXd, p_PQ_E: numpy.ndarray[object[3, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs a rotational inertia for a particle Q of mass <code class="docutils literal notranslate"><span class="pre">mass</span></code>,
whose position vector from about-point P is p_PQ_E (E is expressed-in
frame). This RuntimeError exception only occurs if <code class="docutils literal notranslate"><span class="pre">mass</span></code> &lt; 0.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>The mass of particle Q.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PQ_E</span></code>:</dt><dd><p>Position from about-point P to Q, expressed-in frame E.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">I_QP_E</span></code>:</dt><dd><p>, Q’s rotational inertia about-point P expressed-in frame E.</p>
</dd>
<dt>Remark:</dt><dd><p>Negating the position vector p_PQ_E has no affect on the result.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError for Debug builds if not CouldBePhysicallyValid</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[AutoDiffXd].CalcMaximumPossibleMomentOfInertia(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd</span></span></dt>
<dd><p>Returns the maximum possible moment of inertia for <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational
inertia about-point P for any expressed-in frame E.</p>
<dl class="simple">
<dt>Remark:</dt><dd><p>The maximum moment Imax has range: trace / 3 &lt;= Imax &lt;= trace / 2.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Trace()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[AutoDiffXd].CalcPrincipalMomentsAndAxesOfInertia(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">tuple[numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">pydrake.math.RotationMatrix]</span></span></dt>
<dd><p>Forms the 3 principal moments of inertia and their 3 associated
principal directions for <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>3 principal moments of inertia [Ixx Iyy Izz], sorted in ascending
order (Ixx ≤ Iyy ≤ Izz) and a rotation matrix R_EA whose columns
are the 3 associated principal directions that relate the
expressed-in frame E to a frame A, where frame E is the
expressed-in frame for <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia I_BP_E (body
B’s rotational inertia about-point P) and frame A contains
right-handed orthonormal vectors Ax, Ay, Az. The 1ˢᵗ column of
R_EA is Ax_E (Ax expressed in frame E) which is parallel to the
principal axis associated with Ixx (the smallest principal moment
of inertia). Similarly, the 2ⁿᵈ and 3ʳᵈ columns of R_EA are Ay_E
and Az_E, which are parallel to principal axes associated with Iyy
and Izz (the intermediate and largest principal moments of
inertia). If all principal moments of inertia are equal (i.e., Ixx
= Iyy = Izz), R_EA is the identity matrix.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if the elements</strong><strong> of </strong><strong>this rotational inertia cannot</strong> – </p></li>
<li><p><strong>be converted to a real finite double. For example</strong><strong>, </strong><strong>an exception is</strong> – </p></li>
<li><p><strong>thrown if this contains an erroneous NaN</strong><strong> or </strong><strong>if scalar type T</strong> – </p></li>
<li><p><strong>is symbolic.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcPrincipalMomentsOfInertia() to calculate the principal moments
of inertia [Ixx Iyy Izz], without calculating the principal
directions.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[AutoDiffXd].CalcPrincipalMomentsOfInertia(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Forms the 3 principal moments of inertia for <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational
inertia.</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">The</span></code>:</dt><dd><p>3 principal moments of inertia [Imin Imed Imax], sorted in
ascending order (Imin ≤ Imed ≤ Imax).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the elements</strong><strong> of </strong><strong>this rotational inertia cannot</strong> – </p></li>
<li><p><strong>be converted to a real finite double. For example</strong><strong>, </strong><strong>an exception is</strong> – </p></li>
<li><p><strong>thrown if this contains an erroneous NaN</strong><strong> or </strong><strong>if scalar type T</strong> – </p></li>
<li><p><strong>is symbolic.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcPrincipalMomentsAndAxesOfInertia() to also calculate principal
moment of inertia directions associated with <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational
inertia.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[AutoDiffXd].cols(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>For consistency with Eigen’s API, the cols() method returns 3.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[AutoDiffXd].CopyToFullMatrix3(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">3]]</span></span></dt>
<dd><p>Gets a full 3x3 matrix copy of this rotational inertia. The returned
copy is symmetric and includes both lower and upper parts of the
matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[AutoDiffXd].CouldBePhysicallyValid(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Performs several checks to verify whether <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia
<em>could</em> be physically valid, including:</p>
<ul class="simple">
<li><p>No NaN moments or products of inertia.</p></li>
<li><p>Ixx, Iyy, Izz and principal moments are all non-negative.</p></li>
<li><p>Ixx, Iyy  Izz and principal moments satisfy the triangle inequality:
- <code class="docutils literal notranslate"><span class="pre">Ixx</span> <span class="pre">+</span> <span class="pre">Iyy</span> <span class="pre">≥</span> <span class="pre">Izz</span></code>
- <cite>Ixx + Izz ≥ Iyy</cite>
- <code class="docutils literal notranslate"><span class="pre">Iyy</span> <span class="pre">+</span> <span class="pre">Izz</span> <span class="pre">≥</span> <span class="pre">Ixx</span></code></p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>These checks are necessary (but NOT sufficient) conditions for a
rotational inertia to be physically valid. The sufficient
condition requires a rotational inertia to satisfy the above
checks <em>after</em> <code class="docutils literal notranslate"><span class="pre">this</span></code> is shifted to the center of mass, i.e.,
the sufficient condition requires calling CouldBePhysicallyValid()
when the about-point is Bcm (the body’s center of mass). Note:
this class does not know its about-point or its center of mass
location.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> for a plausible rotational inertia passing the above
necessary but insufficient checks and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if principal moments</strong><strong> of </strong><strong>inertia cannot be calculated</strong> – </p></li>
<li><p><strong>(</strong><strong>eigenvalue solver</strong><strong>) or </strong><strong>if scalar type T cannot be converted to a</strong> – </p></li>
<li><p><strong>double.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[AutoDiffXd].get_moments(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns 3-element vector with moments of inertia [Ixx, Iyy, Izz].</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[AutoDiffXd].get_products(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns 3-element vector with products of inertia [Ixy, Ixz, Iyz].</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[AutoDiffXd].IsNaN(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if any moment/product in <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia
is NaN. Otherwise returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[AutoDiffXd].IsNearlyEqualTo(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[AutoDiffXd],</span> <span class="pre">other:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[AutoDiffXd],</span> <span class="pre">precision:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Compares <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia to <code class="docutils literal notranslate"><span class="pre">other</span></code> rotational inertia
within the specified <code class="docutils literal notranslate"><span class="pre">precision</span></code> (which is a dimensionless number
specifying the relative precision to which the comparison is
performed). Denoting <code class="docutils literal notranslate"><span class="pre">I_maxA</span></code> as the largest element value that can
appear in a valid <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia (independent of the
expressed-in frame E) and denoting <code class="docutils literal notranslate"><span class="pre">I_maxB</span></code> as the largest element
value that can appear in a valid <code class="docutils literal notranslate"><span class="pre">other</span></code> rotational inertia
(independent of the expressed-in frame E), <code class="docutils literal notranslate"><span class="pre">this</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code> are
considered nearly equal to each other, if: ‖this - other‖∞ &lt; precision
* min(I_maxA, I_maxB)</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other</span></code>:</dt><dd><p>Rotational inertia to compare with <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">precision</span></code>:</dt><dd><p>is a dimensionless real positive number that is usually based on
two factors, namely expected accuracy of moments/products of
inertia (e.g., from end-user or CAD) and/or machine-precision.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if the absolute value of each moment/product of inertia
in <code class="docutils literal notranslate"><span class="pre">this</span></code> is within <code class="docutils literal notranslate"><span class="pre">epsilon</span></code> of the corresponding moment/
product absolute value in <code class="docutils literal notranslate"><span class="pre">other</span></code>. Otherwise returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>: This method only works if all moments of inertia with scalar
type T in <code class="docutils literal notranslate"><span class="pre">this</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code> can be converted to a double
(discarding supplemental scalar data such as derivatives of an
AutoDiffXd). It fails at runtime if type T cannot be converted to
<code class="docutils literal notranslate"><span class="pre">double</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[AutoDiffXd].IsZero(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if all moments and products of inertia are exactly
zero.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[AutoDiffXd].ReExpress(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[AutoDiffXd],</span> <span class="pre">R_AE:</span> <span class="pre">pydrake.math.RotationMatrix_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Re-expresses <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia <code class="docutils literal notranslate"><span class="pre">I_BP_E</span></code> to <code class="docutils literal notranslate"><span class="pre">I_BP_A</span></code>
i.e., re-expresses body B’s rotational inertia from frame E to frame
A.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_AE</span></code>:</dt><dd><p>RotationMatrix relating frames A and E.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">I_BP_A</span></code>:</dt><dd><p>Rotational inertia of B about-point P expressed-in frame A.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError for Debug builds if the rotational inertia that is</strong> – </p></li>
<li><p><strong>re-expressed-in frame A violates CouldBePhysicallyValid</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ReExpressInPlace()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[AutoDiffXd].rows(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>For consistency with Eigen’s API, the rows() method returns 3.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[AutoDiffXd].SetToNaN(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia so all its elements are equal to NaN.
This helps quickly detect uninitialized moments/products of inertia.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[AutoDiffXd].SetZero(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia so all its moments/products of
inertia are zero, e.g., for convenient initialization before a
computation or for inertia calculations involving a particle
(point-mass). Note: Real 3D massive physical objects have non-zero
moments of inertia.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[AutoDiffXd].ShiftFromCenterOfMass(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[AutoDiffXd],</span> <span class="pre">mass:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">p_BcmQ_E:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Calculates the rotational inertia that results from shifting <code class="docutils literal notranslate"><span class="pre">this</span></code>
rotational inertia for a body (or composite body) B from about-point
Bcm (B’s center of mass) to about-point Q. I.e., shifts <code class="docutils literal notranslate"><span class="pre">I_BBcm_E</span></code>
to <code class="docutils literal notranslate"><span class="pre">I_BQ_E</span></code> (both are expressed-in frame E).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>The mass of body (or composite body) B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BcmQ_E</span></code>:</dt><dd><p>Position vector from Bcm to Q, expressed-in frame E.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">I_BQ_E</span></code>:</dt><dd><p>B’s rotational inertia about-point Q expressed-in frame E.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError for Debug builds if the rotational inertia that is</strong> – </p></li>
<li><p><strong>shifted to about-point Q violates CouldBePhysicallyValid</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Remark:</dt><dd><p>Negating the position vector p_BcmQ_E has no affect on the result.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[AutoDiffXd].ShiftToCenterOfMass(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[AutoDiffXd],</span> <span class="pre">mass:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">p_QBcm_E:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Calculates the rotational inertia that results from shifting <code class="docutils literal notranslate"><span class="pre">this</span></code>
rotational inertia for a body (or composite body) B from about-point Q
to about-point <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> (B’s center of mass). I.e., shifts <code class="docutils literal notranslate"><span class="pre">I_BQ_E</span></code>
to <code class="docutils literal notranslate"><span class="pre">I_BBcm_E</span></code> (both are expressed-in frame E).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>The mass of body (or composite body) B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_QBcm_E</span></code>:</dt><dd><p>Position vector from Q to <code class="docutils literal notranslate"><span class="pre">Bcm</span></code>, expressed-in frame E.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">I_BBcm_E</span></code>:</dt><dd><p>B’s rotational inertia about-point <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> expressed-in frame E.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError for Debug builds if the rotational inertia that is</strong> – </p></li>
<li><p><strong>shifted to about-point Bcm violates CouldBePhysicallyValid</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Remark:</dt><dd><p>Negating the position vector <code class="docutils literal notranslate"><span class="pre">p_QBcm_E</span></code> has no affect on the
result.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[AutoDiffXd].ShiftToThenAwayFromCenterOfMass(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[AutoDiffXd],</span> <span class="pre">mass:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">p_PBcm_E:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]],</span> <span class="pre">p_QBcm_E:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Calculates the rotational inertia that results from shifting <code class="docutils literal notranslate"><span class="pre">this</span></code>
rotational inertia for a body (or composite body) B from about-point P
to about-point Q via Bcm (B’s center of mass). I.e., shifts <code class="docutils literal notranslate"><span class="pre">I_BP_E</span></code>
to <code class="docutils literal notranslate"><span class="pre">I_BQ_E</span></code> (both are expressed-in frame E).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>The mass of body (or composite body) B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PBcm_E</span></code>:</dt><dd><p>Position vector from P to Bcm, expressed-in frame E.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_QBcm_E</span></code>:</dt><dd><p>Position vector from Q to Bcm, expressed-in frame E.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">I_BQ_E</span></code>:</dt><dd><p>, B’s rotational inertia about-point Q expressed-in frame E.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError for Debug builds if the rotational inertia that is</strong> – </p></li>
<li><p><strong>shifted to about-point Q violates CouldBePhysicallyValid</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Remark:</dt><dd><p>Negating either (or both) position vectors p_PBcm_E and p_QBcm_E
has no affect on the result.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[AutoDiffXd].Trace(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd</span></span></dt>
<dd><p>Returns a rotational inertia’s trace (i.e., Ixx + Iyy + Izz, the sum
of the diagonal elements of the inertia matrix). The trace happens to
be invariant to its expressed-in frame (i.e., the trace does not
depend on the frame in which it is expressed). The trace is useful
because the largest moment of inertia Imax has range: trace / 3 &lt;=
Imax &lt;= trace / 2, and the largest possible product of inertia must be
&lt;= Imax / 2. Hence, trace / 3 and trace / 2 give a lower and upper
bound on the largest possible element that can be in a valid
rotational inertia.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[AutoDiffXd].TriaxiallySymmetric(I_triaxial:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[Expression]</span></span></dt>
<dd><p>This class describes the mass distribution (inertia properties) of a
body or composite body about a particular point. Herein, “composite
body” means one body or a collection of bodies that are welded
together. In this documentation, “body” and “composite body” are used
interchangeably.</p>
<p>A <strong>rigid</strong> body’s mass distribution is described by three quantities:
the body’s mass; the body’s center of mass; and the body’s rotational
inertia about a particular point. The term <strong>rotational inertia</strong> is
used here and by [Jain 2010] to distinguish from a body’s <strong>spatial
inertia</strong>. In this class, a 3x3 <strong>inertia matrix</strong> I represents a
body’s rotational inertia about a point and expressed in a frame. More
specifically, <code class="docutils literal notranslate"><span class="pre">I_BP_E</span></code> is the inertia matrix of a body B about-point
P and expressed-in frame E (herein frame E’s orthogonal unit vectors
Ex, Ey, Ez are denoted 𝐱̂, 𝐲̂, 𝐳̂).</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="o">|</span><span class="w"> </span><span class="n">Ixx</span><span class="w"> </span><span class="n">Ixy</span><span class="w"> </span><span class="n">Ixz</span><span class="w"> </span><span class="o">|</span>
<span class="n">I</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Ixy</span><span class="w"> </span><span class="n">Iyy</span><span class="w"> </span><span class="n">Iyz</span><span class="w"> </span><span class="o">|</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">Ixz</span><span class="w"> </span><span class="n">Iyz</span><span class="w"> </span><span class="n">Izz</span><span class="w"> </span><span class="o">|</span>
</pre></div>
</div>
</details><p>The moments of inertia Ixx, Iyy, Izz and products of inertia Ixy, Ixz,
Iyz are defined in terms of the mass dm of a differential volume of
the body. The position of dm from about-point P is xx̂ + yŷ + zẑ =
[x, y, z]_E.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Ixx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">∫</span><span class="w"> </span><span class="p">(</span><span class="n">y²</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">z²</span><span class="p">)</span><span class="w"> </span><span class="n">dm</span>
<span class="n">Iyy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">∫</span><span class="w"> </span><span class="p">(</span><span class="n">x²</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">z²</span><span class="p">)</span><span class="w"> </span><span class="n">dm</span>
<span class="n">Izz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">∫</span><span class="w"> </span><span class="p">(</span><span class="n">x²</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y²</span><span class="p">)</span><span class="w"> </span><span class="n">dm</span>
<span class="n">Ixy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="err">∫</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">dm</span>
<span class="n">Ixz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="err">∫</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="n">dm</span>
<span class="n">Iyz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="err">∫</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="n">dm</span>
</pre></div>
</div>
</details><p>We use the negated convention for products of inertia, so that I
serves to relate angular velocity ω and angular momentum h via <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">=</span> <span class="pre">I</span>
<span class="pre">⋅</span> <span class="pre">ω</span></code>. Ensure your products of inertia follow this negative sign
convention.</p>
<p>The 3x3 inertia matrix is symmetric and its diagonal elements (moments
of inertia) and off-diagonal elements (products of inertia) are
associated with a body (or composite body) S, an about-point P, and an
expressed-in frame E (𝐱̂, 𝐲̂, 𝐳̂̂). A rotational inertia is
ill-defined unless there is a body S, about-point P, and expressed-in
frame E. The user of this class is responsible for tracking the body
S, about-point P and expressed-in frame E (none of these are stored in
this class).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class does not store the about-point nor the expressed-in
frame, nor does this class help enforce consistency of the
about-point or expressed-in frame. To help users of this class
track the about-point and expressed-in frame, we strongly
recommend the following notation.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In typeset material, use the symbol <span class="math notranslate nohighlight">\([I^{S/P}]_E\)</span> to
represent the rotational inertia (inertia matrix) of a body (or
composite body) S about-point P, expressed in frame E. In code and
comments, use the monogram notation <code class="docutils literal notranslate"><span class="pre">I_SP_E</span></code> (e.g., as described
in multibody_spatial_inertia). If the about-point P is fixed to a
body B, the point is named <span class="math notranslate nohighlight">\(B_P\)</span> and this appears in
code/comments as <code class="docutils literal notranslate"><span class="pre">Bp</span></code>. Examples: <code class="docutils literal notranslate"><span class="pre">I_BBp_E</span></code> is rigid body B’s
rotational inertia about-point Bp expressed-in frame E; I_BBo_E is
B’s rotational inertia about-point <code class="docutils literal notranslate"><span class="pre">Bo</span></code> (body B’s origin)
expressed-in frame E; and I_BBcm_E is B’s inertia matrix
about-point <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> (B’s center of mass) expressed-in frame E.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The rotational inertia (inertia matrix) can be re-expressed in
terms of a special frame whose orthogonal unit vectors are
parallel to <strong>principal axes of inertia</strong> so that the inertia
matrix is diagonalized with elements called <strong>principal moments of
inertia</strong>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The formal definition of the inertia matrix <span class="math notranslate nohighlight">\(I^{S/P}\)</span> of a
system S about a point P follows the definition of the inertia
dyadic 𝐈 of S about P, which begins by modeling S with n particles
S₁ … Sₙ (e.g., 12 grams of carbon can be modeled with n = 6.02 *
10²³ molecules/particles). The inertia dyadic 𝐈₁ of one particle
S₁ about point P is defined [Kane, 1985] in terms of m₁ (mass of
S₁), ᴾ𝐩ˢ¹ (position vector from P to S₁), and the unit dyadic 𝐔
which is defined by the property 𝐔 ⋅ 𝐯 = 𝐯 where 𝐯 is is any
vector (this definition of 𝐔 is analogous to defining the identity
matrix by the property 𝑰𝒅𝒆𝒏𝒕𝒊𝒕𝒚𝑴𝒂𝒕𝒓𝒊𝒙 * 𝒂𝒏𝒚𝑴𝒂𝒕𝒓𝒊𝒙 = 𝒂𝒏𝒚𝑴𝒂𝒕𝒓𝒊𝒙).</p>
</div>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">𝐈₁</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m₁</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">[</span><span class="n">𝐔</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">ᴾ𝐩ˢ¹</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">ᴾ𝐩ˢ¹</span><span class="p">)</span><span class="w">  </span><span class="o">-</span><span class="w">  </span><span class="n">ᴾ𝐩ˢ¹</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">ᴾ𝐩ˢ¹</span><span class="p">]</span>
</pre></div>
</div>
</details><p>Note: The vector dot-product (⋅) above produces a scalar whereas the
vector multiply (*) produces a dyadic which is a 2nd-order tensor
(ᴾ𝐩ˢ¹ * ᴾ𝐩ˢ¹ is similar to the matrix outer-product of a 3x1 matrix
multiplied by a 1x3 matrix). An example inertia dyadic for a single
particle is shown further below. The inertia dyadic 𝐈 of the entire
system S is defined by summing the inertia dyadic of each particle Sᵢ
about P (i = 1, … n), i.e.,</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">𝐈</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">𝐈₁</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">𝐈₂</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="n">𝐈ₙ</span>
</pre></div>
</div>
</details><p>The elements of the inertia matrix <span class="math notranslate nohighlight">\([I^{S/P}]_E\)</span> expressed in
frame E (in terms of orthogonal unit vectors 𝐱̂, 𝐲̂, 𝐳̂̂) are found by
pre-dot multiplying and post-dot multiplying 𝐈 with appropriate unit
vectors.</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Ixx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">𝐱</span><span class="err">̂</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐈</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐱</span><span class="err">̂</span><span class="w">     </span><span class="n">Ixy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">𝐱</span><span class="err">̂</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐈</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐲</span><span class="err">̂</span><span class="w">      </span><span class="n">Ixz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">𝐱</span><span class="err">̂</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐈</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐳</span><span class="err">̂̂</span>
<span class="w">   </span><span class="n">Iyx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">𝐲</span><span class="err">̂</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐈</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐱</span><span class="err">̂</span><span class="w">     </span><span class="n">Iyy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">𝐲</span><span class="err">̂</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐈</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐲</span><span class="err">̂</span><span class="w">      </span><span class="n">Iyz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">𝐲</span><span class="err">̂</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐈</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐳</span><span class="err">̂̂</span>
<span class="w">   </span><span class="n">Izx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">𝐳</span><span class="err">̂̂</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐈</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐱</span><span class="err">̂</span><span class="w">     </span><span class="n">Izy</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">𝐳</span><span class="err">̂̂</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐈</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐲</span><span class="err">̂</span><span class="w">      </span><span class="n">Izz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">𝐳</span><span class="err">̂̂</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐈</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐳</span><span class="err">̂̂</span>
</pre></div>
</div>
</details><p>The inertia dyadic 𝐈ᴮ of a rigid body B about Bcm (B’s center of mass)
is related to various dynamic quantities. For example, B’s angular
momentum 𝐇 about Bcm in a frame N and B’s kinetic energy KE in N
relate to 𝐈ᴮ by</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">𝐇</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">𝐈ᴮ</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝛚</span>
<span class="w">   </span><span class="n">KE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="w"> </span><span class="n">𝛚</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐈ᴮ</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝛚</span><span class="w">  </span><span class="o">+</span><span class="w">  </span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="w"> </span><span class="n">mᴮ</span><span class="w"> </span><span class="n">𝐯</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐯</span>
</pre></div>
</div>
</details><p>where 𝛚 is B’s angular velocity in N, 𝐯 is Bcm’s translational
velocity in N, and mᴮ is B’s mass. When frame N happens to be a
Newtonian frame (also called an inertial frame or
non-rotating/non-accelerating frame), the moment 𝐓 of all forces on B
about Bcm relates to 𝐈ᴮ and 𝛂 (B’s angular acceleration in N) by
Euler’s rigid body equation as</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">𝐓</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">𝐈ᴮ</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝛂</span><span class="w">  </span><span class="o">+</span><span class="w">  </span><span class="n">𝛚</span><span class="w"> </span><span class="err">×</span><span class="w"> </span><span class="n">𝐈ᴮ</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝛚</span>
</pre></div>
</div>
</details><p>Example: For a particle Q of mass m whose position vector from a point
O is written in terms of right-handed orthogonal unit vectors 𝐱̂, 𝐲̂,
𝐳̂ (below), the inertia dyadic 𝐈 of particle Q about point O is
defined and calculated</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">𝐩</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">𝐱</span><span class="err">̂</span><span class="w">  </span><span class="o">+</span><span class="w">  </span><span class="n">y</span><span class="w"> </span><span class="n">𝐲</span><span class="err">̂</span><span class="w">                               </span><span class="p">(</span><span class="n">given</span><span class="p">)</span>
<span class="w">    </span><span class="n">𝐈</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">[</span><span class="n">𝐔</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">𝐩</span><span class="w"> </span><span class="err">⋅</span><span class="w"> </span><span class="n">𝐩</span><span class="p">)</span><span class="w">  </span><span class="o">-</span><span class="w">  </span><span class="n">𝐩</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">𝐩</span><span class="p">]</span><span class="w">              </span><span class="p">(</span><span class="n">definition</span><span class="p">)</span>
<span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">[</span><span class="n">𝐔</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">x²</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y²</span><span class="p">)</span><span class="w">  </span><span class="o">-</span><span class="w">  </span><span class="p">(</span><span class="n">x𝐱</span><span class="err">̂</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y𝐲</span><span class="err">̂̂</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">x𝐱</span><span class="err">̂</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y𝐲</span><span class="err">̂</span><span class="p">)</span>
<span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">[(</span><span class="n">𝐱</span><span class="err">̂</span><span class="n">𝐱</span><span class="err">̂</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">𝐲</span><span class="err">̂</span><span class="n">𝐲</span><span class="err">̂</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">𝐳</span><span class="err">̂</span><span class="n">𝐳</span><span class="err">̂</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">x²</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y²</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">x²𝐱</span><span class="err">̂</span><span class="n">𝐱</span><span class="err">̂</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">xy𝐱</span><span class="err">̂</span><span class="n">𝐲</span><span class="err">̂̂</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">xy𝐲</span><span class="err">̂̂</span><span class="n">𝐱</span><span class="err">̂</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y²𝐲</span><span class="err">̂̂</span><span class="n">𝐲</span><span class="err">̂̂</span><span class="p">)]</span>
<span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">[</span><span class="n">y²𝐱</span><span class="err">̂</span><span class="n">𝐱</span><span class="err">̂</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x²𝐲</span><span class="err">̂</span><span class="n">𝐲</span><span class="err">̂</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">x²</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y²</span><span class="p">)</span><span class="n">𝐳</span><span class="err">̂</span><span class="n">𝐳</span><span class="err">̂</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">xy𝐱</span><span class="err">̂</span><span class="n">𝐲</span><span class="err">̂̂</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">xy𝐲</span><span class="err">̂̂</span><span class="n">𝐱</span><span class="err">̂</span><span class="p">]</span>
</pre></div>
</div>
</details><p>which means the inertia matrix for particle Q about point O for 𝐱̂,
𝐲̂, 𝐳̂ is</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="o">|</span><span class="w">  </span><span class="n">m</span><span class="w"> </span><span class="n">y²</span><span class="w">     </span><span class="o">-</span><span class="n">m</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w">         </span><span class="mi">0</span><span class="w">     </span><span class="o">|</span>
<span class="n">I</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">-</span><span class="n">m</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">y</span><span class="w">     </span><span class="n">m</span><span class="w"> </span><span class="n">x²</span><span class="w">          </span><span class="mi">0</span><span class="w">     </span><span class="o">|</span>
<span class="w">    </span><span class="o">|</span><span class="w">    </span><span class="mi">0</span><span class="w">         </span><span class="mi">0</span><span class="w">     </span><span class="n">m</span><span class="w"> </span><span class="p">(</span><span class="n">x²</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y²</span><span class="p">)</span><span class="w"> </span><span class="o">|</span>
</pre></div>
</div>
</details><p>[Kane, 1985] pg. 68. “Dynamics: Theory and Applications,” McGraw-Hill
Co., New York, 1985 (with D. A. Levinson). Available for free .pdf
download: <a class="reference external" href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Several methods in this class throw a RuntimeError for invalid
rotational inertia operations in debug releases only. This
provides speed in a release build while facilitating debugging in
debug builds. In addition, these validity tests are only performed
for scalar types for which drake::scalar_predicate&lt;T&gt;::is_bool is
<code class="docutils literal notranslate"><span class="pre">True</span></code>. For instance, validity checks are not performed when T
is symbolic::Expression.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The methods of this class satisfy the “basic exception guarantee”:
if an exception is thrown, the program will still be in a valid
state. Specifically, no resources are leaked, and all objects’
invariants are intact. Be aware that RotationalInertia objects may
contain invalid inertia data in cases where input checking is
skipped.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://en.cppreference.com/w/cpp/language/exceptions">https://en.cppreference.com/w/cpp/language/exceptions</a></p>
</div>
<p>Various methods in this class require numerical (not symbolic) data
types.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.tree.RotationalInertia_[Expression]) -&gt; None</p></li>
</ol>
<p>Constructs a rotational inertia that has all its moments/products of
inertia equal to NaN (helps quickly detect uninitialized values).</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.tree.RotationalInertia_[Expression], Ixx: pydrake.symbolic.Expression, Iyy: pydrake.symbolic.Expression, Izz: pydrake.symbolic.Expression) -&gt; None</p></li>
</ol>
<p>Creates a rotational inertia with moments of inertia <code class="docutils literal notranslate"><span class="pre">Ixx</span></code>, <cite>Iyy</cite>,
<code class="docutils literal notranslate"><span class="pre">Izz</span></code>, and with each product of inertia set to zero.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError for Debug builds if not CouldBePhysicallyValid</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.multibody.tree.RotationalInertia_[Expression], Ixx: pydrake.symbolic.Expression, Iyy: pydrake.symbolic.Expression, Izz: pydrake.symbolic.Expression, Ixy: pydrake.symbolic.Expression, Ixz: pydrake.symbolic.Expression, Iyz: pydrake.symbolic.Expression) -&gt; None</p></li>
</ol>
<p>Creates a rotational inertia with moments of inertia <code class="docutils literal notranslate"><span class="pre">Ixx</span></code>, <cite>Iyy</cite>,
<code class="docutils literal notranslate"><span class="pre">Izz</span></code>, and with products of inertia <code class="docutils literal notranslate"><span class="pre">Ixy</span></code>, <cite>Ixz</cite>, <code class="docutils literal notranslate"><span class="pre">Iyz</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError for Debug builds if not CouldBePhysicallyValid</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.multibody.tree.RotationalInertia_[Expression], mass: pydrake.symbolic.Expression, p_PQ_E: numpy.ndarray[object[3, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs a rotational inertia for a particle Q of mass <code class="docutils literal notranslate"><span class="pre">mass</span></code>,
whose position vector from about-point P is p_PQ_E (E is expressed-in
frame). This RuntimeError exception only occurs if <code class="docutils literal notranslate"><span class="pre">mass</span></code> &lt; 0.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>The mass of particle Q.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PQ_E</span></code>:</dt><dd><p>Position from about-point P to Q, expressed-in frame E.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">I_QP_E</span></code>:</dt><dd><p>, Q’s rotational inertia about-point P expressed-in frame E.</p>
</dd>
<dt>Remark:</dt><dd><p>Negating the position vector p_PQ_E has no affect on the result.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError for Debug builds if not CouldBePhysicallyValid</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[Expression].CalcMaximumPossibleMomentOfInertia(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd><p>Returns the maximum possible moment of inertia for <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational
inertia about-point P for any expressed-in frame E.</p>
<dl class="simple">
<dt>Remark:</dt><dd><p>The maximum moment Imax has range: trace / 3 &lt;= Imax &lt;= trace / 2.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>Trace()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[Expression].CalcPrincipalMomentsAndAxesOfInertia(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">tuple[numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">pydrake.math.RotationMatrix]</span></span></dt>
<dd><p>Forms the 3 principal moments of inertia and their 3 associated
principal directions for <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>3 principal moments of inertia [Ixx Iyy Izz], sorted in ascending
order (Ixx ≤ Iyy ≤ Izz) and a rotation matrix R_EA whose columns
are the 3 associated principal directions that relate the
expressed-in frame E to a frame A, where frame E is the
expressed-in frame for <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia I_BP_E (body
B’s rotational inertia about-point P) and frame A contains
right-handed orthonormal vectors Ax, Ay, Az. The 1ˢᵗ column of
R_EA is Ax_E (Ax expressed in frame E) which is parallel to the
principal axis associated with Ixx (the smallest principal moment
of inertia). Similarly, the 2ⁿᵈ and 3ʳᵈ columns of R_EA are Ay_E
and Az_E, which are parallel to principal axes associated with Iyy
and Izz (the intermediate and largest principal moments of
inertia). If all principal moments of inertia are equal (i.e., Ixx
= Iyy = Izz), R_EA is the identity matrix.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if the elements</strong><strong> of </strong><strong>this rotational inertia cannot</strong> – </p></li>
<li><p><strong>be converted to a real finite double. For example</strong><strong>, </strong><strong>an exception is</strong> – </p></li>
<li><p><strong>thrown if this contains an erroneous NaN</strong><strong> or </strong><strong>if scalar type T</strong> – </p></li>
<li><p><strong>is symbolic.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcPrincipalMomentsOfInertia() to calculate the principal moments
of inertia [Ixx Iyy Izz], without calculating the principal
directions.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[Expression].CalcPrincipalMomentsOfInertia(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Forms the 3 principal moments of inertia for <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational
inertia.</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">The</span></code>:</dt><dd><p>3 principal moments of inertia [Imin Imed Imax], sorted in
ascending order (Imin ≤ Imed ≤ Imax).</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the elements</strong><strong> of </strong><strong>this rotational inertia cannot</strong> – </p></li>
<li><p><strong>be converted to a real finite double. For example</strong><strong>, </strong><strong>an exception is</strong> – </p></li>
<li><p><strong>thrown if this contains an erroneous NaN</strong><strong> or </strong><strong>if scalar type T</strong> – </p></li>
<li><p><strong>is symbolic.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>CalcPrincipalMomentsAndAxesOfInertia() to also calculate principal
moment of inertia directions associated with <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational
inertia.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[Expression].cols(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>For consistency with Eigen’s API, the cols() method returns 3.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[Expression].CopyToFullMatrix3(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">3]]</span></span></dt>
<dd><p>Gets a full 3x3 matrix copy of this rotational inertia. The returned
copy is symmetric and includes both lower and upper parts of the
matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[Expression].CouldBePhysicallyValid(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Formula</span></span></dt>
<dd><p>Performs several checks to verify whether <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia
<em>could</em> be physically valid, including:</p>
<ul class="simple">
<li><p>No NaN moments or products of inertia.</p></li>
<li><p>Ixx, Iyy, Izz and principal moments are all non-negative.</p></li>
<li><p>Ixx, Iyy  Izz and principal moments satisfy the triangle inequality:
- <code class="docutils literal notranslate"><span class="pre">Ixx</span> <span class="pre">+</span> <span class="pre">Iyy</span> <span class="pre">≥</span> <span class="pre">Izz</span></code>
- <cite>Ixx + Izz ≥ Iyy</cite>
- <code class="docutils literal notranslate"><span class="pre">Iyy</span> <span class="pre">+</span> <span class="pre">Izz</span> <span class="pre">≥</span> <span class="pre">Ixx</span></code></p></li>
</ul>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>These checks are necessary (but NOT sufficient) conditions for a
rotational inertia to be physically valid. The sufficient
condition requires a rotational inertia to satisfy the above
checks <em>after</em> <code class="docutils literal notranslate"><span class="pre">this</span></code> is shifted to the center of mass, i.e.,
the sufficient condition requires calling CouldBePhysicallyValid()
when the about-point is Bcm (the body’s center of mass). Note:
this class does not know its about-point or its center of mass
location.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> for a plausible rotational inertia passing the above
necessary but insufficient checks and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>RuntimeError if principal moments</strong><strong> of </strong><strong>inertia cannot be calculated</strong> – </p></li>
<li><p><strong>(</strong><strong>eigenvalue solver</strong><strong>) or </strong><strong>if scalar type T cannot be converted to a</strong> – </p></li>
<li><p><strong>double.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[Expression].get_moments(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns 3-element vector with moments of inertia [Ixx, Iyy, Izz].</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[Expression].get_products(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns 3-element vector with products of inertia [Ixy, Ixz, Iyz].</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[Expression].IsNaN(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Formula</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if any moment/product in <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia
is NaN. Otherwise returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[Expression].IsNearlyEqualTo(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[Expression],</span> <span class="pre">other:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[Expression],</span> <span class="pre">precision:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Formula</span></span></dt>
<dd><p>Compares <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia to <code class="docutils literal notranslate"><span class="pre">other</span></code> rotational inertia
within the specified <code class="docutils literal notranslate"><span class="pre">precision</span></code> (which is a dimensionless number
specifying the relative precision to which the comparison is
performed). Denoting <code class="docutils literal notranslate"><span class="pre">I_maxA</span></code> as the largest element value that can
appear in a valid <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia (independent of the
expressed-in frame E) and denoting <code class="docutils literal notranslate"><span class="pre">I_maxB</span></code> as the largest element
value that can appear in a valid <code class="docutils literal notranslate"><span class="pre">other</span></code> rotational inertia
(independent of the expressed-in frame E), <code class="docutils literal notranslate"><span class="pre">this</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code> are
considered nearly equal to each other, if: ‖this - other‖∞ &lt; precision
* min(I_maxA, I_maxB)</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other</span></code>:</dt><dd><p>Rotational inertia to compare with <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">precision</span></code>:</dt><dd><p>is a dimensionless real positive number that is usually based on
two factors, namely expected accuracy of moments/products of
inertia (e.g., from end-user or CAD) and/or machine-precision.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if the absolute value of each moment/product of inertia
in <code class="docutils literal notranslate"><span class="pre">this</span></code> is within <code class="docutils literal notranslate"><span class="pre">epsilon</span></code> of the corresponding moment/
product absolute value in <code class="docutils literal notranslate"><span class="pre">other</span></code>. Otherwise returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>: This method only works if all moments of inertia with scalar
type T in <code class="docutils literal notranslate"><span class="pre">this</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code> can be converted to a double
(discarding supplemental scalar data such as derivatives of an
AutoDiffXd). It fails at runtime if type T cannot be converted to
<code class="docutils literal notranslate"><span class="pre">double</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[Expression].IsZero(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Formula</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if all moments and products of inertia are exactly
zero.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[Expression].ReExpress(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[Expression],</span> <span class="pre">R_AE:</span> <span class="pre">pydrake.math.RotationMatrix_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[Expression]</span></span></dt>
<dd><p>Re-expresses <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia <code class="docutils literal notranslate"><span class="pre">I_BP_E</span></code> to <code class="docutils literal notranslate"><span class="pre">I_BP_A</span></code>
i.e., re-expresses body B’s rotational inertia from frame E to frame
A.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_AE</span></code>:</dt><dd><p>RotationMatrix relating frames A and E.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">I_BP_A</span></code>:</dt><dd><p>Rotational inertia of B about-point P expressed-in frame A.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError for Debug builds if the rotational inertia that is</strong> – </p></li>
<li><p><strong>re-expressed-in frame A violates CouldBePhysicallyValid</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ReExpressInPlace()</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[Expression].rows(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">int</span></span></dt>
<dd><p>For consistency with Eigen’s API, the rows() method returns 3.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[Expression].SetToNaN(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia so all its elements are equal to NaN.
This helps quickly detect uninitialized moments/products of inertia.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[Expression].SetZero(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia so all its moments/products of
inertia are zero, e.g., for convenient initialization before a
computation or for inertia calculations involving a particle
(point-mass). Note: Real 3D massive physical objects have non-zero
moments of inertia.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[Expression].ShiftFromCenterOfMass(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[Expression],</span> <span class="pre">mass:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">p_BcmQ_E:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[Expression]</span></span></dt>
<dd><p>Calculates the rotational inertia that results from shifting <code class="docutils literal notranslate"><span class="pre">this</span></code>
rotational inertia for a body (or composite body) B from about-point
Bcm (B’s center of mass) to about-point Q. I.e., shifts <code class="docutils literal notranslate"><span class="pre">I_BBcm_E</span></code>
to <code class="docutils literal notranslate"><span class="pre">I_BQ_E</span></code> (both are expressed-in frame E).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>The mass of body (or composite body) B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BcmQ_E</span></code>:</dt><dd><p>Position vector from Bcm to Q, expressed-in frame E.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">I_BQ_E</span></code>:</dt><dd><p>B’s rotational inertia about-point Q expressed-in frame E.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError for Debug builds if the rotational inertia that is</strong> – </p></li>
<li><p><strong>shifted to about-point Q violates CouldBePhysicallyValid</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Remark:</dt><dd><p>Negating the position vector p_BcmQ_E has no affect on the result.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[Expression].ShiftToCenterOfMass(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[Expression],</span> <span class="pre">mass:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">p_QBcm_E:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[Expression]</span></span></dt>
<dd><p>Calculates the rotational inertia that results from shifting <code class="docutils literal notranslate"><span class="pre">this</span></code>
rotational inertia for a body (or composite body) B from about-point Q
to about-point <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> (B’s center of mass). I.e., shifts <code class="docutils literal notranslate"><span class="pre">I_BQ_E</span></code>
to <code class="docutils literal notranslate"><span class="pre">I_BBcm_E</span></code> (both are expressed-in frame E).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>The mass of body (or composite body) B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_QBcm_E</span></code>:</dt><dd><p>Position vector from Q to <code class="docutils literal notranslate"><span class="pre">Bcm</span></code>, expressed-in frame E.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">I_BBcm_E</span></code>:</dt><dd><p>B’s rotational inertia about-point <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> expressed-in frame E.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError for Debug builds if the rotational inertia that is</strong> – </p></li>
<li><p><strong>shifted to about-point Bcm violates CouldBePhysicallyValid</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Remark:</dt><dd><p>Negating the position vector <code class="docutils literal notranslate"><span class="pre">p_QBcm_E</span></code> has no affect on the
result.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[Expression].ShiftToThenAwayFromCenterOfMass(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[Expression],</span> <span class="pre">mass:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">p_PBcm_E:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]],</span> <span class="pre">p_QBcm_E:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[Expression]</span></span></dt>
<dd><p>Calculates the rotational inertia that results from shifting <code class="docutils literal notranslate"><span class="pre">this</span></code>
rotational inertia for a body (or composite body) B from about-point P
to about-point Q via Bcm (B’s center of mass). I.e., shifts <code class="docutils literal notranslate"><span class="pre">I_BP_E</span></code>
to <code class="docutils literal notranslate"><span class="pre">I_BQ_E</span></code> (both are expressed-in frame E).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>The mass of body (or composite body) B.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PBcm_E</span></code>:</dt><dd><p>Position vector from P to Bcm, expressed-in frame E.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_QBcm_E</span></code>:</dt><dd><p>Position vector from Q to Bcm, expressed-in frame E.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">I_BQ_E</span></code>:</dt><dd><p>, B’s rotational inertia about-point Q expressed-in frame E.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError for Debug builds if the rotational inertia that is</strong> – </p></li>
<li><p><strong>shifted to about-point Q violates CouldBePhysicallyValid</strong><strong>(</strong><strong>)</strong><strong>.</strong> – </p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Remark:</dt><dd><p>Negating either (or both) position vectors p_PBcm_E and p_QBcm_E
has no affect on the result.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[Expression].Trace(self:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd><p>Returns a rotational inertia’s trace (i.e., Ixx + Iyy + Izz, the sum
of the diagonal elements of the inertia matrix). The trace happens to
be invariant to its expressed-in frame (i.e., the trace does not
depend on the frame in which it is expressed). The trace is useful
because the largest moment of inertia Imax has range: trace / 3 &lt;=
Imax &lt;= trace / 2, and the largest possible product of inertia must be
&lt;= Imax / 2. Hence, trace / 3 and trace / 2 give a lower and upper
bound on the largest possible element that can be in a valid
rotational inertia.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RotationalInertia_[Expression].TriaxiallySymmetric(I_triaxial:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[Expression]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint</span></code></p>
<p>This Joint allows a rigid body to move freely with respect to its
parent rigid body. This is most commonly used to allow a body to move
freely with respect to the World, but can be used with any parent.
More precisely, given a frame F attached to the parent body P and a
frame M attached to the child body B (see the Joint class’s
documentation), this joint allows frame M to translate and rotate
freely with respect to F, introducing six degrees of freedom. However,
unlike the QuaternionFloatingJoint, the orientation of M relative to F
is parameterized with roll-pitch-yaw angles (see warning below). The
generalized coordinates q for this joint are the three orientation
angles followed by three generalized positions to describe the
translation of frame M’s origin Mo in F with a position vector
<code class="docutils literal notranslate"><span class="pre">p_FM</span></code>. As generalized velocities, we use the angular velocity
<code class="docutils literal notranslate"><span class="pre">w_FM</span></code> of frame M in F (<em>not</em> the orientation angle time derivatives
q̇) and the linear velocity <code class="docutils literal notranslate"><span class="pre">v_FM</span></code> of frame M’s origin Mo in frame
F.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Any three-parameter representation of orientation necessarily has
a singularity somewhere. In this case, the singularity occurs when
the pitch angle (second generalized coordinate q) is at π/2 + kπ
(for any integer k), and numerical issues may occur when near one
of those configurations. If you can’t be sure your simulation will
avoid the singularities, consider using the singularity-free
QuaternionFloatingJoint instead.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">RpyFloatingJoint_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint.__init__(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint,</span> <span class="pre">name:</span> <span class="pre">str,</span> <span class="pre">frame_on_parent:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">frame_on_child:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">angular_damping:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">translational_damping:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructor to create an rpy floating joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B move freely relative to one another. See this class’s
documentation for further details on the definition of these frames
and the generalized positions q and generalized velocities v for this
joint. This constructor signature creates a joint with no joint
limits, i.e. the joint position, velocity and acceleration limits are
the pair <code class="docutils literal notranslate"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. These can be set using the Joint methods
set_position_limits(), set_velocity_limits() and
set_acceleration_limits().</p>
<p>The first three arguments to this constructor are those of the Joint
class constructor. See the Joint class’s documentation for details.
The additional parameters are:</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angular_damping</span></code>:</dt><dd><p>Viscous damping coefficient in N⋅m⋅s for the angular component of
this joint’s velocity, used to model losses within the joint. See
documentation of default_angular_damping() for details on modeling
of the damping force.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">translational_damping</span></code>:</dt><dd><p>Viscous damping coefficient in N⋅s/m for the translational
component of this joint’s velocity, used to model losses within
the joint. See documentation of default_translational_damping()
for details on modeling of the damping force.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if angular_damping is negative.</strong> – </p></li>
<li><p><strong>RuntimeError if translational_damping is negative.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint.default_angular_damping(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns this joint’s default angular damping constant in N⋅m⋅s. The
damping torque (in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span> <span class="pre">-damping⋅ω</span></code>, i.e.
opposing motion, with ω the angular velocity of frame M in F (see
get_angular_velocity()) and τ the torque on child body B (to which M
is rigidly attached).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint.default_translational_damping(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns this joint’s default translational damping constant in N⋅s/m.
The damping force (in N) is modeled as <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">-damping⋅v</span></code> i.e.
opposing motion, with v the translational velocity of frame M in F
(see get_translational_velocity()) and f the force on child body B at
Mo.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint.get_angles(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Gets the roll-pitch-yaw rotation angles of this joint from
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<p>The orientation <code class="docutils literal notranslate"><span class="pre">R_FM</span></code> of the child frame M in parent frame F is
parameterized with roll-pitch-yaw angles (also known as space-fixed
x-y-z Euler angles and extrinsic angles). That is, the angles θr, θp,
θy, correspond to a sequence of rotations about the Fx, Fy, and Fz
axes of parent frame F, respectively. Mathematically, rotation
<code class="docutils literal notranslate"><span class="pre">R_FM</span></code> is given in terms of angles θr, θp, θy by:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">R_FM</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rz</span><span class="p">(</span><span class="n">θy</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Ry</span><span class="p">(</span><span class="n">θp</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Rx</span><span class="p">(</span><span class="n">θr</span><span class="p">)</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">Rx(θ)</span></code>, <cite>Ry(θ)</cite> and <code class="docutils literal notranslate"><span class="pre">Rz(θ)</span></code> correspond to the elemental
rotations in amount of θ about the Fx, Fy and Fz axes respectively.
Zero θr, θp, θy angles corresponds to frames F and M having the same
orientation (their origins may still be separated). Angles θr, θp, θy
are defined to be positive according to the right-hand-rule with the
thumb aligned in the direction of their respective axes.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Space <code class="docutils literal notranslate"><span class="pre">x-y-z</span></code> angles (extrinsic) are equivalent to Body
<code class="docutils literal notranslate"><span class="pre">z-y-x</span></code> angles (intrinsic).</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">angles</span></code>:</dt><dd><p>The angle coordinates of this joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code>
ordered as θr, θp, θy.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint.get_angular_velocity(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Retrieves from <code class="docutils literal notranslate"><span class="pre">context</span></code> the angular velocity <code class="docutils literal notranslate"><span class="pre">w_FM</span></code> of the child
frame M in the parent frame F, expressed in F.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">w_FM</span></code>:</dt><dd><p>A vector in ℝ³ with the angular velocity of the child frame M in
the parent frame F, expressed in F. Refer to this class’s
documentation for further details and definitions of these frames.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint.get_default_angles(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Gets the default angles for this joint.</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">angles</span></code>:</dt><dd><p>The default roll-pitch-yaw angles as a Vector3.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint.get_default_translation(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Gets the default translation (position vector) <code class="docutils literal notranslate"><span class="pre">p_FM</span></code> for this
joint.</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_FM</span></code>:</dt><dd><p>The default translation of this joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint.get_translation(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the translation (position vector) <code class="docutils literal notranslate"><span class="pre">p_FM</span></code> of the child frame
M’s origin Mo as measured and expressed in the parent frame F. Refer
to the class documentation for details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_FM</span></code>:</dt><dd><p>The position vector of frame M’s origin in frame F.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint.get_translational_velocity(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Retrieves from <code class="docutils literal notranslate"><span class="pre">context</span></code> the translational velocity <code class="docutils literal notranslate"><span class="pre">v_FM</span></code> of the
child frame M’s origin as measured and expressed in the parent frame
F.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">v_FM</span></code>:</dt><dd><p>A vector in ℝ³ with the translational velocity of the origin of
child frame M in the parent frame F, expressed in F. Refer to this
class’s documentation for further details and definitions of these
frames.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint.GetPose(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RigidTransform</span></span></dt>
<dd><p>Returns the pose <code class="docutils literal notranslate"><span class="pre">X_FM</span></code> of the outboard frame M as measured and
expressed in the inboard frame F. Refer to the documentation for this
class for details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">X_FM</span></code>:</dt><dd><p>The pose of frame M in frame F.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint.kTypeName</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint.set_angles(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">angles:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint</span></span></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the generalized coordinates corresponding
to the roll-pitch-yaw rotation angles of this joint equals <code class="docutils literal notranslate"><span class="pre">angles</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angles</span></code>:</dt><dd><p>Angles in radians to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> ordered as θr, θp,
θy.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>See class documentation for discussion of singular configurations.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to this joint.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>get_angles() for details</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint.set_angular_velocity(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">w_FM:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint</span></span></dt>
<dd><p>Sets in <code class="docutils literal notranslate"><span class="pre">context</span></code> the state for this joint so that the angular
velocity of the child frame M in the parent frame F is <code class="docutils literal notranslate"><span class="pre">w_FM</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">w_FM</span></code>:</dt><dd><p>A vector in ℝ³ with the angular velocity of the child frame M in
the parent frame F, expressed in F. Refer to this class’s
documentation for further details and definitions of these frames.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to this joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint.set_default_angles(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint,</span> <span class="pre">angles:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default roll-pitch-yaw angles of this joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angles</span></code>:</dt><dd><p>the desired default angles of the joint</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>See class documentation for discussion of singular configurations.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint.set_default_translation(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint,</span> <span class="pre">p_FM:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default translation (position vector) <code class="docutils literal notranslate"><span class="pre">p_FM</span></code> of this joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_FM</span></code>:</dt><dd><p>The desired default translation of the joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint.set_random_angles_distribution(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint,</span> <span class="pre">angles:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the random distribution from which the roll-pitch-yaw orientation
angles of this joint will be randomly sampled. See the
RpyFloatingJoint class documentation for details on the orientation
representation. If a translation distribution has already been set
with stochastic variables, it will remain so. Otherwise translation
will be set to this joint’s zero configuration.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Watch for random pitch angles near the singular configuration for
this joint (see class documentation).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint.set_random_translation_distribution(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint,</span> <span class="pre">p_FM:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the random distribution that the translation vector of this joint
will be randomly sampled from. See the RpyFloatingJoint class
documentation for details on the translation representation. If an
angles distribution has has already been set with stochastic
variables, it will remain so. Otherwise angles will be set to this
joint’s zero configuration.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint.set_translational_velocity(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">v_FM:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint</span></span></dt>
<dd><p>Sets in <code class="docutils literal notranslate"><span class="pre">context</span></code> the state for this joint so that the translational
velocity of the child frame M’s origin in the parent frame F is
<code class="docutils literal notranslate"><span class="pre">v_FM</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v_FM</span></code>:</dt><dd><p>A vector in ℝ³ with the translational velocity of the child frame
M’s origin in the parent frame F, expressed in F. Refer to this
class’s documentation for further details and definitions of these
frames.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to this joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint.SetOrientation(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">R_FM:</span> <span class="pre">pydrake.math.RotationMatrix)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint</span></span></dt>
<dd><p>Sets the roll-pitch-yaw angles in <code class="docutils literal notranslate"><span class="pre">context</span></code> so this Joint’s
orientation is consistent with the given <code class="docutils literal notranslate"><span class="pre">R_FM</span></code> rotation matrix.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_FM</span></code>:</dt><dd><p>The rotation matrix giving the orientation of frame M in frame F.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>See class documentation for discussion of singular configurations.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to this joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint.SetPose(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">X_FM:</span> <span class="pre">pydrake.math.RigidTransform)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint</span></span></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">context</span></code> to store <code class="docutils literal notranslate"><span class="pre">X_FM</span></code> the pose of frame M measured and
expressed in frame F.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_FM</span></code>:</dt><dd><p>The desired pose of frame M in frame F to be stored in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>See class documentation for discussion of singular configurations.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint.SetTranslation(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">p_FM:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint</span></span></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">context</span></code> to store the translation (position vector) <code class="docutils literal notranslate"><span class="pre">p_FM</span></code>
of frame M’s origin Mo measured and expressed in frame F.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_FM</span></code>:</dt><dd><p>The desired position of frame M’s origin in frame F, to be stored
in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to this joint.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">RpyFloatingJoint_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">RpyFloatingJoint_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">RpyFloatingJoint_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd]</span></code></p>
<p>This Joint allows a rigid body to move freely with respect to its
parent rigid body. This is most commonly used to allow a body to move
freely with respect to the World, but can be used with any parent.
More precisely, given a frame F attached to the parent body P and a
frame M attached to the child body B (see the Joint class’s
documentation), this joint allows frame M to translate and rotate
freely with respect to F, introducing six degrees of freedom. However,
unlike the QuaternionFloatingJoint, the orientation of M relative to F
is parameterized with roll-pitch-yaw angles (see warning below). The
generalized coordinates q for this joint are the three orientation
angles followed by three generalized positions to describe the
translation of frame M’s origin Mo in F with a position vector
<code class="docutils literal notranslate"><span class="pre">p_FM</span></code>. As generalized velocities, we use the angular velocity
<code class="docutils literal notranslate"><span class="pre">w_FM</span></code> of frame M in F (<em>not</em> the orientation angle time derivatives
q̇) and the linear velocity <code class="docutils literal notranslate"><span class="pre">v_FM</span></code> of frame M’s origin Mo in frame
F.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Any three-parameter representation of orientation necessarily has
a singularity somewhere. In this case, the singularity occurs when
the pitch angle (second generalized coordinate q) is at π/2 + kπ
(for any integer k), and numerical issues may occur when near one
of those configurations. If you can’t be sure your simulation will
avoid the singularities, consider using the singularity-free
QuaternionFloatingJoint instead.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[AutoDiffXd],</span> <span class="pre">name:</span> <span class="pre">str,</span> <span class="pre">frame_on_parent:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">frame_on_child:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">angular_damping:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">translational_damping:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructor to create an rpy floating joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B move freely relative to one another. See this class’s
documentation for further details on the definition of these frames
and the generalized positions q and generalized velocities v for this
joint. This constructor signature creates a joint with no joint
limits, i.e. the joint position, velocity and acceleration limits are
the pair <code class="docutils literal notranslate"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. These can be set using the Joint methods
set_position_limits(), set_velocity_limits() and
set_acceleration_limits().</p>
<p>The first three arguments to this constructor are those of the Joint
class constructor. See the Joint class’s documentation for details.
The additional parameters are:</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angular_damping</span></code>:</dt><dd><p>Viscous damping coefficient in N⋅m⋅s for the angular component of
this joint’s velocity, used to model losses within the joint. See
documentation of default_angular_damping() for details on modeling
of the damping force.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">translational_damping</span></code>:</dt><dd><p>Viscous damping coefficient in N⋅s/m for the translational
component of this joint’s velocity, used to model losses within
the joint. See documentation of default_translational_damping()
for details on modeling of the damping force.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if angular_damping is negative.</strong> – </p></li>
<li><p><strong>RuntimeError if translational_damping is negative.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[AutoDiffXd].default_angular_damping(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns this joint’s default angular damping constant in N⋅m⋅s. The
damping torque (in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span> <span class="pre">-damping⋅ω</span></code>, i.e.
opposing motion, with ω the angular velocity of frame M in F (see
get_angular_velocity()) and τ the torque on child body B (to which M
is rigidly attached).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[AutoDiffXd].default_translational_damping(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns this joint’s default translational damping constant in N⋅s/m.
The damping force (in N) is modeled as <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">-damping⋅v</span></code> i.e.
opposing motion, with v the translational velocity of frame M in F
(see get_translational_velocity()) and f the force on child body B at
Mo.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[AutoDiffXd].get_angles(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Gets the roll-pitch-yaw rotation angles of this joint from
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<p>The orientation <code class="docutils literal notranslate"><span class="pre">R_FM</span></code> of the child frame M in parent frame F is
parameterized with roll-pitch-yaw angles (also known as space-fixed
x-y-z Euler angles and extrinsic angles). That is, the angles θr, θp,
θy, correspond to a sequence of rotations about the Fx, Fy, and Fz
axes of parent frame F, respectively. Mathematically, rotation
<code class="docutils literal notranslate"><span class="pre">R_FM</span></code> is given in terms of angles θr, θp, θy by:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">R_FM</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rz</span><span class="p">(</span><span class="n">θy</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Ry</span><span class="p">(</span><span class="n">θp</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Rx</span><span class="p">(</span><span class="n">θr</span><span class="p">)</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">Rx(θ)</span></code>, <cite>Ry(θ)</cite> and <code class="docutils literal notranslate"><span class="pre">Rz(θ)</span></code> correspond to the elemental
rotations in amount of θ about the Fx, Fy and Fz axes respectively.
Zero θr, θp, θy angles corresponds to frames F and M having the same
orientation (their origins may still be separated). Angles θr, θp, θy
are defined to be positive according to the right-hand-rule with the
thumb aligned in the direction of their respective axes.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Space <code class="docutils literal notranslate"><span class="pre">x-y-z</span></code> angles (extrinsic) are equivalent to Body
<code class="docutils literal notranslate"><span class="pre">z-y-x</span></code> angles (intrinsic).</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">angles</span></code>:</dt><dd><p>The angle coordinates of this joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code>
ordered as θr, θp, θy.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[AutoDiffXd].get_angular_velocity(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Retrieves from <code class="docutils literal notranslate"><span class="pre">context</span></code> the angular velocity <code class="docutils literal notranslate"><span class="pre">w_FM</span></code> of the child
frame M in the parent frame F, expressed in F.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">w_FM</span></code>:</dt><dd><p>A vector in ℝ³ with the angular velocity of the child frame M in
the parent frame F, expressed in F. Refer to this class’s
documentation for further details and definitions of these frames.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[AutoDiffXd].get_default_angles(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Gets the default angles for this joint.</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">angles</span></code>:</dt><dd><p>The default roll-pitch-yaw angles as a Vector3.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[AutoDiffXd].get_default_translation(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Gets the default translation (position vector) <code class="docutils literal notranslate"><span class="pre">p_FM</span></code> for this
joint.</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_FM</span></code>:</dt><dd><p>The default translation of this joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[AutoDiffXd].get_translation(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the translation (position vector) <code class="docutils literal notranslate"><span class="pre">p_FM</span></code> of the child frame
M’s origin Mo as measured and expressed in the parent frame F. Refer
to the class documentation for details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_FM</span></code>:</dt><dd><p>The position vector of frame M’s origin in frame F.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[AutoDiffXd].get_translational_velocity(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Retrieves from <code class="docutils literal notranslate"><span class="pre">context</span></code> the translational velocity <code class="docutils literal notranslate"><span class="pre">v_FM</span></code> of the
child frame M’s origin as measured and expressed in the parent frame
F.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">v_FM</span></code>:</dt><dd><p>A vector in ℝ³ with the translational velocity of the origin of
child frame M in the parent frame F, expressed in F. Refer to this
class’s documentation for further details and definitions of these
frames.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[AutoDiffXd].GetPose(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RigidTransform_[AutoDiffXd]</span></span></dt>
<dd><p>Returns the pose <code class="docutils literal notranslate"><span class="pre">X_FM</span></code> of the outboard frame M as measured and
expressed in the inboard frame F. Refer to the documentation for this
class for details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">X_FM</span></code>:</dt><dd><p>The pose of frame M in frame F.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[AutoDiffXd].kTypeName</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[AutoDiffXd].set_angles(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">angles:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[AutoDiffXd]</span></span></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the generalized coordinates corresponding
to the roll-pitch-yaw rotation angles of this joint equals <code class="docutils literal notranslate"><span class="pre">angles</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angles</span></code>:</dt><dd><p>Angles in radians to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> ordered as θr, θp,
θy.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>See class documentation for discussion of singular configurations.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to this joint.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>get_angles() for details</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[AutoDiffXd].set_angular_velocity(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">w_FM:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[AutoDiffXd]</span></span></dt>
<dd><p>Sets in <code class="docutils literal notranslate"><span class="pre">context</span></code> the state for this joint so that the angular
velocity of the child frame M in the parent frame F is <code class="docutils literal notranslate"><span class="pre">w_FM</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">w_FM</span></code>:</dt><dd><p>A vector in ℝ³ with the angular velocity of the child frame M in
the parent frame F, expressed in F. Refer to this class’s
documentation for further details and definitions of these frames.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to this joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[AutoDiffXd].set_default_angles(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[AutoDiffXd],</span> <span class="pre">angles:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default roll-pitch-yaw angles of this joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angles</span></code>:</dt><dd><p>the desired default angles of the joint</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>See class documentation for discussion of singular configurations.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[AutoDiffXd].set_default_translation(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[AutoDiffXd],</span> <span class="pre">p_FM:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default translation (position vector) <code class="docutils literal notranslate"><span class="pre">p_FM</span></code> of this joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_FM</span></code>:</dt><dd><p>The desired default translation of the joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[AutoDiffXd].set_random_angles_distribution(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[AutoDiffXd],</span> <span class="pre">angles:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the random distribution from which the roll-pitch-yaw orientation
angles of this joint will be randomly sampled. See the
RpyFloatingJoint class documentation for details on the orientation
representation. If a translation distribution has already been set
with stochastic variables, it will remain so. Otherwise translation
will be set to this joint’s zero configuration.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Watch for random pitch angles near the singular configuration for
this joint (see class documentation).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[AutoDiffXd].set_random_translation_distribution(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[AutoDiffXd],</span> <span class="pre">p_FM:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the random distribution that the translation vector of this joint
will be randomly sampled from. See the RpyFloatingJoint class
documentation for details on the translation representation. If an
angles distribution has has already been set with stochastic
variables, it will remain so. Otherwise angles will be set to this
joint’s zero configuration.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[AutoDiffXd].set_translational_velocity(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">v_FM:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[AutoDiffXd]</span></span></dt>
<dd><p>Sets in <code class="docutils literal notranslate"><span class="pre">context</span></code> the state for this joint so that the translational
velocity of the child frame M’s origin in the parent frame F is
<code class="docutils literal notranslate"><span class="pre">v_FM</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v_FM</span></code>:</dt><dd><p>A vector in ℝ³ with the translational velocity of the child frame
M’s origin in the parent frame F, expressed in F. Refer to this
class’s documentation for further details and definitions of these
frames.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to this joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[AutoDiffXd].SetOrientation(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">R_FM:</span> <span class="pre">pydrake.math.RotationMatrix_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[AutoDiffXd]</span></span></dt>
<dd><p>Sets the roll-pitch-yaw angles in <code class="docutils literal notranslate"><span class="pre">context</span></code> so this Joint’s
orientation is consistent with the given <code class="docutils literal notranslate"><span class="pre">R_FM</span></code> rotation matrix.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_FM</span></code>:</dt><dd><p>The rotation matrix giving the orientation of frame M in frame F.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>See class documentation for discussion of singular configurations.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to this joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[AutoDiffXd].SetPose(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">X_FM:</span> <span class="pre">pydrake.math.RigidTransform_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[AutoDiffXd]</span></span></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">context</span></code> to store <code class="docutils literal notranslate"><span class="pre">X_FM</span></code> the pose of frame M measured and
expressed in frame F.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_FM</span></code>:</dt><dd><p>The desired pose of frame M in frame F to be stored in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>See class documentation for discussion of singular configurations.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[AutoDiffXd].SetTranslation(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">p_FM:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[AutoDiffXd]</span></span></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">context</span></code> to store the translation (position vector) <code class="docutils literal notranslate"><span class="pre">p_FM</span></code>
of frame M’s origin Mo measured and expressed in frame F.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_FM</span></code>:</dt><dd><p>The desired position of frame M’s origin in frame F, to be stored
in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to this joint.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[Expression]</span></code></p>
<p>This Joint allows a rigid body to move freely with respect to its
parent rigid body. This is most commonly used to allow a body to move
freely with respect to the World, but can be used with any parent.
More precisely, given a frame F attached to the parent body P and a
frame M attached to the child body B (see the Joint class’s
documentation), this joint allows frame M to translate and rotate
freely with respect to F, introducing six degrees of freedom. However,
unlike the QuaternionFloatingJoint, the orientation of M relative to F
is parameterized with roll-pitch-yaw angles (see warning below). The
generalized coordinates q for this joint are the three orientation
angles followed by three generalized positions to describe the
translation of frame M’s origin Mo in F with a position vector
<code class="docutils literal notranslate"><span class="pre">p_FM</span></code>. As generalized velocities, we use the angular velocity
<code class="docutils literal notranslate"><span class="pre">w_FM</span></code> of frame M in F (<em>not</em> the orientation angle time derivatives
q̇) and the linear velocity <code class="docutils literal notranslate"><span class="pre">v_FM</span></code> of frame M’s origin Mo in frame
F.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Any three-parameter representation of orientation necessarily has
a singularity somewhere. In this case, the singularity occurs when
the pitch angle (second generalized coordinate q) is at π/2 + kπ
(for any integer k), and numerical issues may occur when near one
of those configurations. If you can’t be sure your simulation will
avoid the singularities, consider using the singularity-free
QuaternionFloatingJoint instead.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[Expression].__init__(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[Expression],</span> <span class="pre">name:</span> <span class="pre">str,</span> <span class="pre">frame_on_parent:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">frame_on_child:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">angular_damping:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0,</span> <span class="pre">translational_damping:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructor to create an rpy floating joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B move freely relative to one another. See this class’s
documentation for further details on the definition of these frames
and the generalized positions q and generalized velocities v for this
joint. This constructor signature creates a joint with no joint
limits, i.e. the joint position, velocity and acceleration limits are
the pair <code class="docutils literal notranslate"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. These can be set using the Joint methods
set_position_limits(), set_velocity_limits() and
set_acceleration_limits().</p>
<p>The first three arguments to this constructor are those of the Joint
class constructor. See the Joint class’s documentation for details.
The additional parameters are:</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angular_damping</span></code>:</dt><dd><p>Viscous damping coefficient in N⋅m⋅s for the angular component of
this joint’s velocity, used to model losses within the joint. See
documentation of default_angular_damping() for details on modeling
of the damping force.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">translational_damping</span></code>:</dt><dd><p>Viscous damping coefficient in N⋅s/m for the translational
component of this joint’s velocity, used to model losses within
the joint. See documentation of default_translational_damping()
for details on modeling of the damping force.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if angular_damping is negative.</strong> – </p></li>
<li><p><strong>RuntimeError if translational_damping is negative.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[Expression].default_angular_damping(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns this joint’s default angular damping constant in N⋅m⋅s. The
damping torque (in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span> <span class="pre">-damping⋅ω</span></code>, i.e.
opposing motion, with ω the angular velocity of frame M in F (see
get_angular_velocity()) and τ the torque on child body B (to which M
is rigidly attached).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[Expression].default_translational_damping(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns this joint’s default translational damping constant in N⋅s/m.
The damping force (in N) is modeled as <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">=</span> <span class="pre">-damping⋅v</span></code> i.e.
opposing motion, with v the translational velocity of frame M in F
(see get_translational_velocity()) and f the force on child body B at
Mo.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[Expression].get_angles(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Gets the roll-pitch-yaw rotation angles of this joint from
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<p>The orientation <code class="docutils literal notranslate"><span class="pre">R_FM</span></code> of the child frame M in parent frame F is
parameterized with roll-pitch-yaw angles (also known as space-fixed
x-y-z Euler angles and extrinsic angles). That is, the angles θr, θp,
θy, correspond to a sequence of rotations about the Fx, Fy, and Fz
axes of parent frame F, respectively. Mathematically, rotation
<code class="docutils literal notranslate"><span class="pre">R_FM</span></code> is given in terms of angles θr, θp, θy by:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">R_FM</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rz</span><span class="p">(</span><span class="n">θy</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Ry</span><span class="p">(</span><span class="n">θp</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Rx</span><span class="p">(</span><span class="n">θr</span><span class="p">)</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">Rx(θ)</span></code>, <cite>Ry(θ)</cite> and <code class="docutils literal notranslate"><span class="pre">Rz(θ)</span></code> correspond to the elemental
rotations in amount of θ about the Fx, Fy and Fz axes respectively.
Zero θr, θp, θy angles corresponds to frames F and M having the same
orientation (their origins may still be separated). Angles θr, θp, θy
are defined to be positive according to the right-hand-rule with the
thumb aligned in the direction of their respective axes.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Space <code class="docutils literal notranslate"><span class="pre">x-y-z</span></code> angles (extrinsic) are equivalent to Body
<code class="docutils literal notranslate"><span class="pre">z-y-x</span></code> angles (intrinsic).</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">angles</span></code>:</dt><dd><p>The angle coordinates of this joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code>
ordered as θr, θp, θy.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[Expression].get_angular_velocity(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Retrieves from <code class="docutils literal notranslate"><span class="pre">context</span></code> the angular velocity <code class="docutils literal notranslate"><span class="pre">w_FM</span></code> of the child
frame M in the parent frame F, expressed in F.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">w_FM</span></code>:</dt><dd><p>A vector in ℝ³ with the angular velocity of the child frame M in
the parent frame F, expressed in F. Refer to this class’s
documentation for further details and definitions of these frames.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[Expression].get_default_angles(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Gets the default angles for this joint.</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">angles</span></code>:</dt><dd><p>The default roll-pitch-yaw angles as a Vector3.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[Expression].get_default_translation(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Gets the default translation (position vector) <code class="docutils literal notranslate"><span class="pre">p_FM</span></code> for this
joint.</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_FM</span></code>:</dt><dd><p>The default translation of this joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[Expression].get_translation(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the translation (position vector) <code class="docutils literal notranslate"><span class="pre">p_FM</span></code> of the child frame
M’s origin Mo as measured and expressed in the parent frame F. Refer
to the class documentation for details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_FM</span></code>:</dt><dd><p>The position vector of frame M’s origin in frame F.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[Expression].get_translational_velocity(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Retrieves from <code class="docutils literal notranslate"><span class="pre">context</span></code> the translational velocity <code class="docutils literal notranslate"><span class="pre">v_FM</span></code> of the
child frame M’s origin as measured and expressed in the parent frame
F.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">v_FM</span></code>:</dt><dd><p>A vector in ℝ³ with the translational velocity of the origin of
child frame M in the parent frame F, expressed in F. Refer to this
class’s documentation for further details and definitions of these
frames.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[Expression].GetPose(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RigidTransform_[Expression]</span></span></dt>
<dd><p>Returns the pose <code class="docutils literal notranslate"><span class="pre">X_FM</span></code> of the outboard frame M as measured and
expressed in the inboard frame F. Refer to the documentation for this
class for details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">X_FM</span></code>:</dt><dd><p>The pose of frame M in frame F.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[Expression].kTypeName</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[Expression].set_angles(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">angles:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[Expression]</span></span></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the generalized coordinates corresponding
to the roll-pitch-yaw rotation angles of this joint equals <code class="docutils literal notranslate"><span class="pre">angles</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angles</span></code>:</dt><dd><p>Angles in radians to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> ordered as θr, θp,
θy.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>See class documentation for discussion of singular configurations.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to this joint.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>get_angles() for details</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[Expression].set_angular_velocity(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">w_FM:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[Expression]</span></span></dt>
<dd><p>Sets in <code class="docutils literal notranslate"><span class="pre">context</span></code> the state for this joint so that the angular
velocity of the child frame M in the parent frame F is <code class="docutils literal notranslate"><span class="pre">w_FM</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">w_FM</span></code>:</dt><dd><p>A vector in ℝ³ with the angular velocity of the child frame M in
the parent frame F, expressed in F. Refer to this class’s
documentation for further details and definitions of these frames.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to this joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[Expression].set_default_angles(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[Expression],</span> <span class="pre">angles:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default roll-pitch-yaw angles of this joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angles</span></code>:</dt><dd><p>the desired default angles of the joint</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>See class documentation for discussion of singular configurations.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[Expression].set_default_translation(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[Expression],</span> <span class="pre">p_FM:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default translation (position vector) <code class="docutils literal notranslate"><span class="pre">p_FM</span></code> of this joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_FM</span></code>:</dt><dd><p>The desired default translation of the joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[Expression].set_random_angles_distribution(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[Expression],</span> <span class="pre">angles:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the random distribution from which the roll-pitch-yaw orientation
angles of this joint will be randomly sampled. See the
RpyFloatingJoint class documentation for details on the orientation
representation. If a translation distribution has already been set
with stochastic variables, it will remain so. Otherwise translation
will be set to this joint’s zero configuration.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Watch for random pitch angles near the singular configuration for
this joint (see class documentation).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[Expression].set_random_translation_distribution(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[Expression],</span> <span class="pre">p_FM:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the random distribution that the translation vector of this joint
will be randomly sampled from. See the RpyFloatingJoint class
documentation for details on the translation representation. If an
angles distribution has has already been set with stochastic
variables, it will remain so. Otherwise angles will be set to this
joint’s zero configuration.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[Expression].set_translational_velocity(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">v_FM:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[Expression]</span></span></dt>
<dd><p>Sets in <code class="docutils literal notranslate"><span class="pre">context</span></code> the state for this joint so that the translational
velocity of the child frame M’s origin in the parent frame F is
<code class="docutils literal notranslate"><span class="pre">v_FM</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v_FM</span></code>:</dt><dd><p>A vector in ℝ³ with the translational velocity of the child frame
M’s origin in the parent frame F, expressed in F. Refer to this
class’s documentation for further details and definitions of these
frames.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to this joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[Expression].SetOrientation(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">R_FM:</span> <span class="pre">pydrake.math.RotationMatrix_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[Expression]</span></span></dt>
<dd><p>Sets the roll-pitch-yaw angles in <code class="docutils literal notranslate"><span class="pre">context</span></code> so this Joint’s
orientation is consistent with the given <code class="docutils literal notranslate"><span class="pre">R_FM</span></code> rotation matrix.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_FM</span></code>:</dt><dd><p>The rotation matrix giving the orientation of frame M in frame F.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>See class documentation for discussion of singular configurations.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to this joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[Expression].SetPose(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">X_FM:</span> <span class="pre">pydrake.math.RigidTransform_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[Expression]</span></span></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">context</span></code> to store <code class="docutils literal notranslate"><span class="pre">X_FM</span></code> the pose of frame M measured and
expressed in frame F.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_FM</span></code>:</dt><dd><p>The desired pose of frame M in frame F to be stored in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>See class documentation for discussion of singular configurations.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">RpyFloatingJoint_[Expression].SetTranslation(self:</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">p_FM:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RpyFloatingJoint_[Expression]</span></span></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">context</span></code> to store the translation (position vector) <code class="docutils literal notranslate"><span class="pre">p_FM</span></code>
of frame M’s origin Mo measured and expressed in frame F.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>A Context for the MultibodyPlant this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_FM</span></code>:</dt><dd><p>The desired position of frame M’s origin in frame F, to be stored
in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to this joint.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScopedName</span></span></dt>
<dd><p>A delimited string name for a multibody element, e.g.,
“robot1::torso”.</p>
<p>The name is composed of two semantically separate pieces – the
<code class="docutils literal notranslate"><span class="pre">element</span></code> name is the local name for the element (e.g., a joint,
body, frame, etc.) and the <code class="docutils literal notranslate"><span class="pre">namespace</span></code> name is the location of that
element within the tree. For “robot1::torso” the namespace name is
“robot1” and the element name is “torso”.</p>
<p>The namespace name typically refers to the model instance name that
contains the element. Some temporary scoped names do not use a
namespace (e.g., temporary values created during input file parsing),
in which case the namespace name can be empty. The namespace name will
never start or end with “::”.</p>
<p>The element name is never empty, unless the ScopedName was
default-constructed or moved-from. The element name will never contain
the delimiter string “::”.</p>
<p>When there is no namespace, the scoped name does not contain a leading
“::”, e.g., for the element name “box” without any namespace, the
scoped name is “box” not “::box”.</p>
<p>The namespace name may contain the “::” delimiter in the middle of the
name (possibly multiple times), e.g., for
“robot1::left::arm::end_frame” the namespace name is
“robot1::left::arm” and the element is name “end_frame”.</p>
<p>This class does not treat a single colon (“:”) specially. Those can
appear in either namespace names or element names.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScopedName.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.tree.ScopedName) -&gt; None</p></li>
</ol>
<p>Creates an empty name.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.tree.ScopedName, namespace_name: str, element_name: str) -&gt; None</p></li>
</ol>
<p>Creates a ScopedName for the given <code class="docutils literal notranslate"><span class="pre">namespace_name</span></code> and
<code class="docutils literal notranslate"><span class="pre">element_name</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if namespace_name starts</strong><strong> or </strong><strong>ends with &quot;::&quot;.</strong> – </p></li>
<li><p><strong>RuntimeError if element_name contains &quot;::&quot;</strong><strong> or </strong><strong>is empty.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ScopedName::Make() to use a null return value instead of
exceptions.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ScopedName::Join() for automatic cleanup of “::” tokens.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScopedName.get_element(self:</span> <span class="pre">pydrake.multibody.tree.ScopedName)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns the element portion of this scoped name, e.g., “torso”. This
is the local name of the joint, body, etc. within the model instance.
It is never empty unless this ScopedName was default-constructed or
moved-from.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScopedName.get_full(self:</span> <span class="pre">pydrake.multibody.tree.ScopedName)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns the full ScopedName as a string, e.g., “robot1::torso”. It is
never empty unless this ScopedName was default-constructed or
moved-from.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScopedName.get_namespace(self:</span> <span class="pre">pydrake.multibody.tree.ScopedName)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns the namespace portion of this scoped name, e.g., “robot1”.
This is typically the model instance name. This is typically the model
instance name but can be empty (see class overview for details).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScopedName.Join(name1:</span> <span class="pre">str,</span> <span class="pre">name2:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.ScopedName</span></span></dt>
<dd><p>Creates a ScopedName for the given <code class="docutils literal notranslate"><span class="pre">name1::name2</span></code>. Unlike the
constructor or ScopedName::Make(), this function allows “::” in either
name. Any leading or trailing “::” on the names are removed before
joining. After joining, the final word after all “::”s is the element
name, and everything prior is the namespace name.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScopedName.Make(namespace_name:</span> <span class="pre">str,</span> <span class="pre">element_name:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">Optional[pydrake.multibody.tree.ScopedName]</span></span></dt>
<dd><p>Creates a ScopedName for the given <code class="docutils literal notranslate"><span class="pre">namespace_name</span></code> and
<code class="docutils literal notranslate"><span class="pre">element_name</span></code>. Returns nullopt if <code class="docutils literal notranslate"><span class="pre">namespace_name</span></code> starts or ends
with “::”, or if <code class="docutils literal notranslate"><span class="pre">element_name</span></code> contains “::” or is empty.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ScopedName::Join() for automatic coalescing of “::” tokens.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScopedName.Parse(scoped_name:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.ScopedName</span></span></dt>
<dd><p>Parses the given <code class="docutils literal notranslate"><span class="pre">scoped_name</span></code> string. Any leading or trailing “::”s
on the name are removed (even multiple copies like “::::” are
removed).</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScopedName.set_element(self:</span> <span class="pre">pydrake.multibody.tree.ScopedName,</span> <span class="pre">element_name:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Replaces the element name of this object, leaving the namespace name
unchanged.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if element_name contains &quot;::&quot;</strong><strong> or </strong><strong>is empty.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScopedName.set_namespace(self:</span> <span class="pre">pydrake.multibody.tree.ScopedName,</span> <span class="pre">namespace_name:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Replaces the namespace name of this object, leaving the element name
unchanged. The namespace name is allowed to be empty.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if namespace_name starts</strong><strong> or </strong><strong>ends with &quot;::&quot;.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScopedName.to_string(self:</span> <span class="pre">pydrake.multibody.tree.ScopedName)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></span></dt>
<dd><p>Returns get_full() as a string value instead of a string_view.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint</span></code></p>
<p>This joint models a screw joint allowing two bodies to rotate about
one axis while translating along that same axis with one degree of
freedom. That is, given a frame F attached to the parent body P and a
frame M attached to the child body B (see the Joint class’s
documentation), this joint allows frame M to translate (while
rotating) along an axis â. Axis â is constant and has the same
measures in both frames F and M, that is, <code class="docutils literal notranslate"><span class="pre">â_F</span> <span class="pre">=</span> <span class="pre">â_M</span></code>. The
rotation about the <code class="docutils literal notranslate"><span class="pre">â_F</span></code> axis and its rate specify the state of the
joint. Zero (θ) corresponds to frames F and M being coincident and
aligned. The translation distance is defined positive when child body
B translates along the direction of â, and the rotation θ is defined
to be positive according to the right-hand-rule with the thumb aligned
in the direction of the <code class="docutils literal notranslate"><span class="pre">â_F</span></code> axis.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">ScrewJoint_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.tree.ScrewJoint, name: str, frame_on_parent: pydrake.multibody.tree.Frame, frame_on_child: pydrake.multibody.tree.Frame, screw_pitch: float, damping: float) -&gt; None</p></li>
</ol>
<p>Constructor to create a screw joint between two bodies so that frame F
attached to the parent body P and frame M attached to the child body B
translate and rotate as described in the class’s documentation. This
constructor signature creates a joint with the axis â set to the
z-axis and no joint limits, i.e. the joint angular position, angular
velocity and angular acceleration limits are the pair <code class="docutils literal notranslate"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>.
These can be set using the Joint methods set_position_limits(),
set_velocity_limits() and set_acceleration_limits() in radians,
radians/s, radians/s² units. The first three arguments to this
constructor are those of the Joint class constructor. See the Joint
class’s documentation for details. The additional parameters are:</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">screw_pitch</span></code>:</dt><dd><p>Amount of translation in meters occurring over a one full screw
revolution. It’s domain is (-∞, ∞). When the screw pitch is
negative, positive rotation will result in translating towards the
negative direction of z-axis. When the screw pitch is zero, this
joint will behave like a revolute joint.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>Viscous damping coefficient, N⋅m⋅s/rad for rotation, used to model
losses within the joint. See documentation of default_damping()
for details on modelling of the damping torque.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if damping is negative.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.tree.ScrewJoint, name: str, frame_on_parent: pydrake.multibody.tree.Frame, frame_on_child: pydrake.multibody.tree.Frame, axis: numpy.ndarray[numpy.float64[3, 1]], screw_pitch: float, damping: float) -&gt; None</p></li>
</ol>
<p>Constructor to create a screw joint between two bodies so that frame F
attached to the parent body P and frame M attached to the child body B
translate and rotate as described in the class’s documentation. This
constructor signature creates a joint with no joint limits, i.e. the
joint angular position, angular velocity and angular acceleration
limits are the pair <code class="docutils literal notranslate"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. These can be set using the Joint
methods set_position_limits(), set_velocity_limits() and
set_acceleration_limits() in radians, radians/s, radians/s² units. The
first three arguments to this constructor are those of the Joint class
constructor. See the Joint class’s documentation for details. The
additional parameters are:</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">axis</span></code>:</dt><dd><p>A vector in ℝ³ specifying the axis of motion for this joint. The
coordinates of <code class="docutils literal notranslate"><span class="pre">axis</span></code> expressed in frames F and M are the same
at all times, that is, <code class="docutils literal notranslate"><span class="pre">axis_F</span> <span class="pre">=</span> <span class="pre">axis_M</span></code>. In other words,
<code class="docutils literal notranslate"><span class="pre">axis_F</span></code> (or <code class="docutils literal notranslate"><span class="pre">axis_M</span></code>) is the eigenvector of <code class="docutils literal notranslate"><span class="pre">R_FM</span></code> with
eigenvalue equal to one. This vector can have any length, only the
direction is used.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">screw_pitch</span></code>:</dt><dd><p>Amount of translation in meters occurring over a one full screw
revolution. It’s domain is (-∞, ∞). When the screw pitch is
negative, positive rotation will result in translating towards the
negative direction of â-axis. When the screw pitch is zero, this
joint will behave like a revolute joint.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>Viscous damping coefficient, N⋅m⋅s/rad for rotation, used to model
losses within the joint. See documentation of default_damping()
for details on modelling of the damping torque.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the L2 norm</strong><strong> of </strong><strong>axis is less than the square</strong> – </p></li>
<li><p><strong>root</strong><strong> of </strong><strong>machine epsilon.</strong> – </p></li>
<li><p><strong>RuntimeError if damping is negative.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint.default_damping(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s default damping constant N⋅m⋅s for the
rotational degree. The damping torque (in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span>
<span class="pre">-damping⋅ω</span></code> i.e. opposing motion, with ω the angular rate for
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see get_angular_velocity()) and τ the torque on child
body B expressed in frame F as t_B_F = τ⋅Fâ_F.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint.get_angular_velocity(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Gets the rate of change, in radians per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
angle θ from <code class="docutils literal notranslate"><span class="pre">context</span></code>. See class documentation for the definition
of this angle.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>:</dt><dd><p>The rate of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s angle θ as stored in the
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint.get_default_rotation(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Gets the default angle for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt><dd><p>The default angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint.get_default_translation(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Gets the default position for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">z</span></code>:</dt><dd><p>The default position of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint.get_rotation(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Gets the angle θ of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt><dd><p>The angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code>. See class
documentation for details.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint.get_translation(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Gets the translation of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">z</span></code>:</dt><dd><p>The translation of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code> as
(z). See class documentation for details.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint.get_translational_velocity(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Gets the translational velocity vz, in meters per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code>
joint’s Mo measured and expressed in frame F from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">vz</span></code>:</dt><dd><p>The translational velocity of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint as stored in the
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint.GetDamping(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns the Context dependent damping coefficient stored as a
parameter in <code class="docutils literal notranslate"><span class="pre">context</span></code>. Refer to default_damping() for details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> joint belongs.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint.kTypeName</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint.screw_pitch(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s amount of translation in meters occurring
over a one full revolution.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint.set_angular_velocity(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">theta_dot:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.ScrewJoint</span></span></dt>
<dd><p>Sets the rate of change, in radians per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
angle θ (see class documentation) to <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>. The new rate of
change gets stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>:</dt><dd><p>The desired rates of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s angle in radians
per second.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint.set_default_rotation(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint,</span> <span class="pre">theta:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default angle of this joint. This will change the
<code class="docutils literal notranslate"><span class="pre">default_translation</span></code> too, because they are not independent in this
joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt><dd><p>The desired default angle of the joint</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint.set_default_translation(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint,</span> <span class="pre">z:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default translation of this joint. This will change the
<code class="docutils literal notranslate"><span class="pre">default_rotation</span></code> too, which are not independent in this joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">z</span></code>:</dt><dd><p>The desired default translation of the joint</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if pitch is very near zero.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint.set_random_pose_distribution(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint,</span> <span class="pre">theta:</span> <span class="pre">numpy.ndarray[object[1,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the random distribution that the angle of this joint will be
randomly sampled from. See class documentation for details on the
definition of the position and angle.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint.set_translation(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">translation:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.ScrewJoint</span></span></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the translation of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals
to (z).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">z</span></code>:</dt><dd><p>The desired translation in meters to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> as
(z). See class documentation for details.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint.set_translational_velocity(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">translation_dot:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.ScrewJoint</span></span></dt>
<dd><p>Sets the translational velocity, in meters per second, of this
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s Mo along frame F’s â-axis to <code class="docutils literal notranslate"><span class="pre">vz</span></code>. The new
translational velocity gets stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">vz</span></code>:</dt><dd><p>The desired translational velocity of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters per
second along F frame’s â-axis.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint.SetDamping(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">damping:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the value of the viscous damping coefficient for this joint,
stored as a parameter in <code class="docutils literal notranslate"><span class="pre">context</span></code>. Refer to default_damping() for
details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> joint belongs.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>The damping value.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if damping is negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">ScrewJoint_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ScrewJoint_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">ScrewJoint_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd]</span></code></p>
<p>This joint models a screw joint allowing two bodies to rotate about
one axis while translating along that same axis with one degree of
freedom. That is, given a frame F attached to the parent body P and a
frame M attached to the child body B (see the Joint class’s
documentation), this joint allows frame M to translate (while
rotating) along an axis â. Axis â is constant and has the same
measures in both frames F and M, that is, <code class="docutils literal notranslate"><span class="pre">â_F</span> <span class="pre">=</span> <span class="pre">â_M</span></code>. The
rotation about the <code class="docutils literal notranslate"><span class="pre">â_F</span></code> axis and its rate specify the state of the
joint. Zero (θ) corresponds to frames F and M being coincident and
aligned. The translation distance is defined positive when child body
B translates along the direction of â, and the rotation θ is defined
to be positive according to the right-hand-rule with the thumb aligned
in the direction of the <code class="docutils literal notranslate"><span class="pre">â_F</span></code> axis.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.tree.ScrewJoint_[AutoDiffXd], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_on_child: pydrake.multibody.tree.Frame_[AutoDiffXd], screw_pitch: float, damping: float) -&gt; None</p></li>
</ol>
<p>Constructor to create a screw joint between two bodies so that frame F
attached to the parent body P and frame M attached to the child body B
translate and rotate as described in the class’s documentation. This
constructor signature creates a joint with the axis â set to the
z-axis and no joint limits, i.e. the joint angular position, angular
velocity and angular acceleration limits are the pair <code class="docutils literal notranslate"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>.
These can be set using the Joint methods set_position_limits(),
set_velocity_limits() and set_acceleration_limits() in radians,
radians/s, radians/s² units. The first three arguments to this
constructor are those of the Joint class constructor. See the Joint
class’s documentation for details. The additional parameters are:</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">screw_pitch</span></code>:</dt><dd><p>Amount of translation in meters occurring over a one full screw
revolution. It’s domain is (-∞, ∞). When the screw pitch is
negative, positive rotation will result in translating towards the
negative direction of z-axis. When the screw pitch is zero, this
joint will behave like a revolute joint.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>Viscous damping coefficient, N⋅m⋅s/rad for rotation, used to model
losses within the joint. See documentation of default_damping()
for details on modelling of the damping torque.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if damping is negative.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.tree.ScrewJoint_[AutoDiffXd], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_on_child: pydrake.multibody.tree.Frame_[AutoDiffXd], axis: numpy.ndarray[numpy.float64[3, 1]], screw_pitch: float, damping: float) -&gt; None</p></li>
</ol>
<p>Constructor to create a screw joint between two bodies so that frame F
attached to the parent body P and frame M attached to the child body B
translate and rotate as described in the class’s documentation. This
constructor signature creates a joint with no joint limits, i.e. the
joint angular position, angular velocity and angular acceleration
limits are the pair <code class="docutils literal notranslate"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. These can be set using the Joint
methods set_position_limits(), set_velocity_limits() and
set_acceleration_limits() in radians, radians/s, radians/s² units. The
first three arguments to this constructor are those of the Joint class
constructor. See the Joint class’s documentation for details. The
additional parameters are:</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">axis</span></code>:</dt><dd><p>A vector in ℝ³ specifying the axis of motion for this joint. The
coordinates of <code class="docutils literal notranslate"><span class="pre">axis</span></code> expressed in frames F and M are the same
at all times, that is, <code class="docutils literal notranslate"><span class="pre">axis_F</span> <span class="pre">=</span> <span class="pre">axis_M</span></code>. In other words,
<code class="docutils literal notranslate"><span class="pre">axis_F</span></code> (or <code class="docutils literal notranslate"><span class="pre">axis_M</span></code>) is the eigenvector of <code class="docutils literal notranslate"><span class="pre">R_FM</span></code> with
eigenvalue equal to one. This vector can have any length, only the
direction is used.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">screw_pitch</span></code>:</dt><dd><p>Amount of translation in meters occurring over a one full screw
revolution. It’s domain is (-∞, ∞). When the screw pitch is
negative, positive rotation will result in translating towards the
negative direction of â-axis. When the screw pitch is zero, this
joint will behave like a revolute joint.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>Viscous damping coefficient, N⋅m⋅s/rad for rotation, used to model
losses within the joint. See documentation of default_damping()
for details on modelling of the damping torque.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the L2 norm</strong><strong> of </strong><strong>axis is less than the square</strong> – </p></li>
<li><p><strong>root</strong><strong> of </strong><strong>machine epsilon.</strong> – </p></li>
<li><p><strong>RuntimeError if damping is negative.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint_[AutoDiffXd].default_damping(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s default damping constant N⋅m⋅s for the
rotational degree. The damping torque (in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span>
<span class="pre">-damping⋅ω</span></code> i.e. opposing motion, with ω the angular rate for
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see get_angular_velocity()) and τ the torque on child
body B expressed in frame F as t_B_F = τ⋅Fâ_F.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint_[AutoDiffXd].get_angular_velocity(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd</span></span></dt>
<dd><p>Gets the rate of change, in radians per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
angle θ from <code class="docutils literal notranslate"><span class="pre">context</span></code>. See class documentation for the definition
of this angle.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>:</dt><dd><p>The rate of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s angle θ as stored in the
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint_[AutoDiffXd].get_default_rotation(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Gets the default angle for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt><dd><p>The default angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint_[AutoDiffXd].get_default_translation(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Gets the default position for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">z</span></code>:</dt><dd><p>The default position of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint_[AutoDiffXd].get_rotation(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd</span></span></dt>
<dd><p>Gets the angle θ of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt><dd><p>The angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code>. See class
documentation for details.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint_[AutoDiffXd].get_translation(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd</span></span></dt>
<dd><p>Gets the translation of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">z</span></code>:</dt><dd><p>The translation of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code> as
(z). See class documentation for details.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint_[AutoDiffXd].get_translational_velocity(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd</span></span></dt>
<dd><p>Gets the translational velocity vz, in meters per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code>
joint’s Mo measured and expressed in frame F from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">vz</span></code>:</dt><dd><p>The translational velocity of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint as stored in the
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint_[AutoDiffXd].GetDamping(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd</span></span></dt>
<dd><p>Returns the Context dependent damping coefficient stored as a
parameter in <code class="docutils literal notranslate"><span class="pre">context</span></code>. Refer to default_damping() for details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> joint belongs.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint_[AutoDiffXd].kTypeName</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint_[AutoDiffXd].screw_pitch(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s amount of translation in meters occurring
over a one full revolution.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint_[AutoDiffXd].set_angular_velocity(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">theta_dot:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.ScrewJoint_[AutoDiffXd]</span></span></dt>
<dd><p>Sets the rate of change, in radians per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
angle θ (see class documentation) to <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>. The new rate of
change gets stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>:</dt><dd><p>The desired rates of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s angle in radians
per second.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint_[AutoDiffXd].set_default_rotation(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint_[AutoDiffXd],</span> <span class="pre">theta:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default angle of this joint. This will change the
<code class="docutils literal notranslate"><span class="pre">default_translation</span></code> too, because they are not independent in this
joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt><dd><p>The desired default angle of the joint</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint_[AutoDiffXd].set_default_translation(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint_[AutoDiffXd],</span> <span class="pre">z:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default translation of this joint. This will change the
<code class="docutils literal notranslate"><span class="pre">default_rotation</span></code> too, which are not independent in this joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">z</span></code>:</dt><dd><p>The desired default translation of the joint</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if pitch is very near zero.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint_[AutoDiffXd].set_random_pose_distribution(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint_[AutoDiffXd],</span> <span class="pre">theta:</span> <span class="pre">numpy.ndarray[object[1,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the random distribution that the angle of this joint will be
randomly sampled from. See class documentation for details on the
definition of the position and angle.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint_[AutoDiffXd].set_translation(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">translation:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.ScrewJoint_[AutoDiffXd]</span></span></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the translation of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals
to (z).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">z</span></code>:</dt><dd><p>The desired translation in meters to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> as
(z). See class documentation for details.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint_[AutoDiffXd].set_translational_velocity(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">translation_dot:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.ScrewJoint_[AutoDiffXd]</span></span></dt>
<dd><p>Sets the translational velocity, in meters per second, of this
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s Mo along frame F’s â-axis to <code class="docutils literal notranslate"><span class="pre">vz</span></code>. The new
translational velocity gets stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">vz</span></code>:</dt><dd><p>The desired translational velocity of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters per
second along F frame’s â-axis.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint_[AutoDiffXd].SetDamping(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">damping:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the value of the viscous damping coefficient for this joint,
stored as a parameter in <code class="docutils literal notranslate"><span class="pre">context</span></code>. Refer to default_damping() for
details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> joint belongs.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>The damping value.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if damping is negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[Expression]</span></code></p>
<p>This joint models a screw joint allowing two bodies to rotate about
one axis while translating along that same axis with one degree of
freedom. That is, given a frame F attached to the parent body P and a
frame M attached to the child body B (see the Joint class’s
documentation), this joint allows frame M to translate (while
rotating) along an axis â. Axis â is constant and has the same
measures in both frames F and M, that is, <code class="docutils literal notranslate"><span class="pre">â_F</span> <span class="pre">=</span> <span class="pre">â_M</span></code>. The
rotation about the <code class="docutils literal notranslate"><span class="pre">â_F</span></code> axis and its rate specify the state of the
joint. Zero (θ) corresponds to frames F and M being coincident and
aligned. The translation distance is defined positive when child body
B translates along the direction of â, and the rotation θ is defined
to be positive according to the right-hand-rule with the thumb aligned
in the direction of the <code class="docutils literal notranslate"><span class="pre">â_F</span></code> axis.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.tree.ScrewJoint_[Expression], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[Expression], frame_on_child: pydrake.multibody.tree.Frame_[Expression], screw_pitch: float, damping: float) -&gt; None</p></li>
</ol>
<p>Constructor to create a screw joint between two bodies so that frame F
attached to the parent body P and frame M attached to the child body B
translate and rotate as described in the class’s documentation. This
constructor signature creates a joint with the axis â set to the
z-axis and no joint limits, i.e. the joint angular position, angular
velocity and angular acceleration limits are the pair <code class="docutils literal notranslate"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>.
These can be set using the Joint methods set_position_limits(),
set_velocity_limits() and set_acceleration_limits() in radians,
radians/s, radians/s² units. The first three arguments to this
constructor are those of the Joint class constructor. See the Joint
class’s documentation for details. The additional parameters are:</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">screw_pitch</span></code>:</dt><dd><p>Amount of translation in meters occurring over a one full screw
revolution. It’s domain is (-∞, ∞). When the screw pitch is
negative, positive rotation will result in translating towards the
negative direction of z-axis. When the screw pitch is zero, this
joint will behave like a revolute joint.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>Viscous damping coefficient, N⋅m⋅s/rad for rotation, used to model
losses within the joint. See documentation of default_damping()
for details on modelling of the damping torque.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if damping is negative.</strong> – </p>
</dd>
</dl>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.tree.ScrewJoint_[Expression], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[Expression], frame_on_child: pydrake.multibody.tree.Frame_[Expression], axis: numpy.ndarray[numpy.float64[3, 1]], screw_pitch: float, damping: float) -&gt; None</p></li>
</ol>
<p>Constructor to create a screw joint between two bodies so that frame F
attached to the parent body P and frame M attached to the child body B
translate and rotate as described in the class’s documentation. This
constructor signature creates a joint with no joint limits, i.e. the
joint angular position, angular velocity and angular acceleration
limits are the pair <code class="docutils literal notranslate"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. These can be set using the Joint
methods set_position_limits(), set_velocity_limits() and
set_acceleration_limits() in radians, radians/s, radians/s² units. The
first three arguments to this constructor are those of the Joint class
constructor. See the Joint class’s documentation for details. The
additional parameters are:</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">axis</span></code>:</dt><dd><p>A vector in ℝ³ specifying the axis of motion for this joint. The
coordinates of <code class="docutils literal notranslate"><span class="pre">axis</span></code> expressed in frames F and M are the same
at all times, that is, <code class="docutils literal notranslate"><span class="pre">axis_F</span> <span class="pre">=</span> <span class="pre">axis_M</span></code>. In other words,
<code class="docutils literal notranslate"><span class="pre">axis_F</span></code> (or <code class="docutils literal notranslate"><span class="pre">axis_M</span></code>) is the eigenvector of <code class="docutils literal notranslate"><span class="pre">R_FM</span></code> with
eigenvalue equal to one. This vector can have any length, only the
direction is used.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">screw_pitch</span></code>:</dt><dd><p>Amount of translation in meters occurring over a one full screw
revolution. It’s domain is (-∞, ∞). When the screw pitch is
negative, positive rotation will result in translating towards the
negative direction of â-axis. When the screw pitch is zero, this
joint will behave like a revolute joint.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>Viscous damping coefficient, N⋅m⋅s/rad for rotation, used to model
losses within the joint. See documentation of default_damping()
for details on modelling of the damping torque.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the L2 norm</strong><strong> of </strong><strong>axis is less than the square</strong> – </p></li>
<li><p><strong>root</strong><strong> of </strong><strong>machine epsilon.</strong> – </p></li>
<li><p><strong>RuntimeError if damping is negative.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint_[Expression].default_damping(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s default damping constant N⋅m⋅s for the
rotational degree. The damping torque (in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span>
<span class="pre">-damping⋅ω</span></code> i.e. opposing motion, with ω the angular rate for
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see get_angular_velocity()) and τ the torque on child
body B expressed in frame F as t_B_F = τ⋅Fâ_F.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint_[Expression].get_angular_velocity(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd><p>Gets the rate of change, in radians per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
angle θ from <code class="docutils literal notranslate"><span class="pre">context</span></code>. See class documentation for the definition
of this angle.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>:</dt><dd><p>The rate of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s angle θ as stored in the
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint_[Expression].get_default_rotation(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Gets the default angle for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt><dd><p>The default angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint_[Expression].get_default_translation(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Gets the default position for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
<dl class="simple">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">z</span></code>:</dt><dd><p>The default position of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint_[Expression].get_rotation(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd><p>Gets the angle θ of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt><dd><p>The angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code>. See class
documentation for details.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint_[Expression].get_translation(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd><p>Gets the translation of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">z</span></code>:</dt><dd><p>The translation of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code> as
(z). See class documentation for details.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint_[Expression].get_translational_velocity(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd><p>Gets the translational velocity vz, in meters per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code>
joint’s Mo measured and expressed in frame F from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">vz</span></code>:</dt><dd><p>The translational velocity of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint as stored in the
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint_[Expression].GetDamping(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd><p>Returns the Context dependent damping coefficient stored as a
parameter in <code class="docutils literal notranslate"><span class="pre">context</span></code>. Refer to default_damping() for details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> joint belongs.</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint_[Expression].kTypeName</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint_[Expression].screw_pitch(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s amount of translation in meters occurring
over a one full revolution.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint_[Expression].set_angular_velocity(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">theta_dot:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.ScrewJoint_[Expression]</span></span></dt>
<dd><p>Sets the rate of change, in radians per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
angle θ (see class documentation) to <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>. The new rate of
change gets stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>:</dt><dd><p>The desired rates of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s angle in radians
per second.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint_[Expression].set_default_rotation(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint_[Expression],</span> <span class="pre">theta:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default angle of this joint. This will change the
<code class="docutils literal notranslate"><span class="pre">default_translation</span></code> too, because they are not independent in this
joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt><dd><p>The desired default angle of the joint</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint_[Expression].set_default_translation(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint_[Expression],</span> <span class="pre">z:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default translation of this joint. This will change the
<code class="docutils literal notranslate"><span class="pre">default_rotation</span></code> too, which are not independent in this joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">z</span></code>:</dt><dd><p>The desired default translation of the joint</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if pitch is very near zero.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint_[Expression].set_random_pose_distribution(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint_[Expression],</span> <span class="pre">theta:</span> <span class="pre">numpy.ndarray[object[1,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the random distribution that the angle of this joint will be
randomly sampled from. See class documentation for details on the
definition of the position and angle.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint_[Expression].set_translation(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">translation:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.ScrewJoint_[Expression]</span></span></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the translation of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals
to (z).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">z</span></code>:</dt><dd><p>The desired translation in meters to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> as
(z). See class documentation for details.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint_[Expression].set_translational_velocity(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">translation_dot:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.ScrewJoint_[Expression]</span></span></dt>
<dd><p>Sets the translational velocity, in meters per second, of this
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s Mo along frame F’s â-axis to <code class="docutils literal notranslate"><span class="pre">vz</span></code>. The new
translational velocity gets stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">vz</span></code>:</dt><dd><p>The desired translational velocity of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters per
second along F frame’s â-axis.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">ScrewJoint_[Expression].SetDamping(self:</span> <span class="pre">pydrake.multibody.tree.ScrewJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">damping:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the value of the viscous damping coefficient for this joint,
stored as a parameter in <code class="docutils literal notranslate"><span class="pre">context</span></code>. Refer to default_damping() for
details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> joint belongs.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>The damping value.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if damping is negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia</span></span></dt>
<dd><p>This class represents the physical concept of a <em>Spatial Inertia</em>. A
spatial inertia (or spatial mass matrix) encapsulates the mass, center
of mass, and rotational inertia of the mass distribution of a body or
composite body S, where with “composite body” we mean a collection of
bodies welded together containing at least one body (throughout this
documentation “body” is many times used instead of “composite body”
but the same concepts apply to a collection of bodies as well.) A
spatial inertia is an element of ℝ⁶ˣ⁶ that is symmetric, and positive
semi-definite. It logically consists of <code class="docutils literal notranslate"><span class="pre">3x3</span></code> sub-matrices arranged
like so, [Jain 2010]:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Spatial</span><span class="w"> </span><span class="n">mass</span><span class="w"> </span><span class="n">matrix</span>
<span class="w">          </span><span class="o">------------</span><span class="w"> </span><span class="o">------------</span>
<span class="w">       </span><span class="mi">0</span><span class="w"> </span><span class="o">|</span><span class="w">            </span><span class="o">|</span><span class="w">            </span><span class="o">|</span>
<span class="w">       </span><span class="mi">1</span><span class="w"> </span><span class="o">|</span><span class="w">    </span><span class="n">I_SP</span><span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">p_PScm</span><span class="err">×</span><span class="w">  </span><span class="o">|</span>
<span class="w">       </span><span class="mi">2</span><span class="w"> </span><span class="o">|</span><span class="w">            </span><span class="o">|</span><span class="w">            </span><span class="o">|</span>
<span class="w">          </span><span class="o">------------</span><span class="w"> </span><span class="o">------------</span>
<span class="w">       </span><span class="mi">3</span><span class="w"> </span><span class="o">|</span><span class="w">            </span><span class="o">|</span><span class="w">            </span><span class="o">|</span>
<span class="w">       </span><span class="mi">4</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">-</span><span class="n">m</span><span class="w"> </span><span class="n">p_PScm</span><span class="err">×</span><span class="w"> </span><span class="o">|</span><span class="w">     </span><span class="n">m</span><span class="w"> </span><span class="n">Id</span><span class="w">   </span><span class="o">|</span>
<span class="w">       </span><span class="mi">5</span><span class="w"> </span><span class="o">|</span><span class="w">            </span><span class="o">|</span><span class="w">            </span><span class="o">|</span>
<span class="w">          </span><span class="o">------------</span><span class="w"> </span><span class="o">------------</span>
<span class="w">               </span><span class="nl">Symbol</span><span class="p">:</span><span class="w"> </span><span class="n">M</span>
</pre></div>
</div>
</details><p>where, with the monogram notation described in
multibody_spatial_inertia, <code class="docutils literal notranslate"><span class="pre">I_SP</span></code> is the rotational inertia of body
or composite body S computed about a point P, m is the mass of this
composite body, <code class="docutils literal notranslate"><span class="pre">p_PScm</span></code> is the position vector from point P to the
center of mass <code class="docutils literal notranslate"><span class="pre">Scm</span></code> of the composite body S with <code class="docutils literal notranslate"><span class="pre">p_PScm×</span></code>
denoting its skew-symmetric cross product matrix (defined such that
<code class="docutils literal notranslate"><span class="pre">a×</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">a.cross(b)</span></code>), and <code class="docutils literal notranslate"><span class="pre">Id</span></code> is the identity matrix in ℝ³ˣ³. See
Section 2.1, p. 17 of [Jain 2010]. The logical arrangement as shown
above is chosen to be consistent with our logical arrangement for
spatial vectors as documented in multibody_spatial_algebra for which
the rotational component comes first followed by the translational
component.</p>
<p>In typeset material we use the symbol <span class="math notranslate nohighlight">\([M^{S/P}]_E\)</span> to represent
the spatial inertia of a body or composite body S about point P,
expressed in frame E. For this inertia, the monogram notation reads
<code class="docutils literal notranslate"><span class="pre">M_SP_E</span></code>. If the point P is fixed to a body B, we write that point
as <span class="math notranslate nohighlight">\(B_P\)</span> which appears in code and comments as <code class="docutils literal notranslate"><span class="pre">Bp</span></code>. So if the
body or composite body is B and the about point is <code class="docutils literal notranslate"><span class="pre">Bp</span></code>, the
monogram notation reads <code class="docutils literal notranslate"><span class="pre">M_BBp_E</span></code>, which can be abbreviated to
<code class="docutils literal notranslate"><span class="pre">M_Bp_E</span></code> since the about point <code class="docutils literal notranslate"><span class="pre">Bp</span></code> also identifies the body.
Common cases are that the about point is the origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code> of the
body, or it’s the center of mass <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> for which the rotational
inertia in monogram notation would read as <code class="docutils literal notranslate"><span class="pre">I_Bo_E</span></code> and <code class="docutils literal notranslate"><span class="pre">I_Bcm_E</span></code>,
respectively. Given <code class="docutils literal notranslate"><span class="pre">M_BP_E</span></code> (<span class="math notranslate nohighlight">\([M^{B/P}]_E\)</span>), the rotational
inertia of this spatial inertia is <code class="docutils literal notranslate"><span class="pre">I_BP_E</span></code> (<span class="math notranslate nohighlight">\([I^{B/P}]_E\)</span>)
and the position vector of the center of mass measured from point P
and expressed in E is <code class="docutils literal notranslate"><span class="pre">p_PBcm_E</span></code> (<span class="math notranslate nohighlight">\([^Pp^{B_{cm}}]_E\)</span>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class does not implement any mechanism to track the frame E
in which a spatial inertia is expressed or about what point is
computed. Methods and operators on this class have no means to
determine frame consistency through operations. It is therefore
the responsibility of users of this class to keep track of frames
in which operations are performed. We suggest doing that using
disciplined notation, as described above.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Several methods in this class throw a RuntimeError for invalid
rotational inertia operations in debug releases only. This
provides speed in a release build while facilitating debugging in
debug builds. In addition, these validity tests are only performed
for scalar types for which drake::scalar_predicate&lt;T&gt;::is_bool is
<code class="docutils literal notranslate"><span class="pre">True</span></code>. For instance, validity checks are not performed when T
is symbolic::Expression.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The methods of this class satisfy the “basic exception guarantee”:
if an exception is thrown, the program will still be in a valid
state. Specifically, no resources are leaked, and all objects’
invariants are intact. Be aware that SpatialInertia objects may
contain invalid inertia data in cases where input checking is
skipped.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://en.cppreference.com/w/cpp/language/exceptions">https://en.cppreference.com/w/cpp/language/exceptions</a></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>To create a spatial inertia of a mesh, see
CalcSpatialInertia(const geometry::TriangleSurfaceMesh&lt;double&gt;&amp;
mesh, double density).</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>To create spatial inertia from most of geometry::Shape, see
CalcSpatialInertia(const geometry::Shape&amp; shape, double density).</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>To create spatial inertia for a set of bodies, see
MultibodyPlant::CalcSpatialInertia().</p>
</div>
<ul class="simple">
<li><dl class="simple">
<dt>[Jain 2010]  Jain, A., 2010. Robot and multibody dynamics: analysis and</dt><dd><p>algorithms. Springer Science &amp; Business Media.</p>
</dd>
</dl>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialInertia_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia.__init__(self:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia,</span> <span class="pre">mass:</span> <span class="pre">float,</span> <span class="pre">p_PScm_E:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">G_SP_E:</span> <span class="pre">pydrake.multibody.tree.UnitInertia,</span> <span class="pre">skip_validity_check:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">False)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a spatial inertia for a physical body or composite body S
about a point P from a given mass, center of mass and rotational
inertia. The center of mass is specified by the position vector
<code class="docutils literal notranslate"><span class="pre">p_PScm_E</span></code> from point P to the center of mass point <code class="docutils literal notranslate"><span class="pre">Scm</span></code>,
expressed in a frame E. The rotational inertia is provided as the
UnitInertia <code class="docutils literal notranslate"><span class="pre">G_SP_E</span></code> of the body or composite body S computed about
point P and expressed in frame E.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The third argument of this constructor is unusual in that it is an
UnitInertia (not a traditional RotationalInertia) and its inertia
is about the arbitrary point P (not Scm – S’s center of mass).</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MakeFromCentralInertia a factory method with traditional utility.</p>
</div>
<p>This constructor checks for the physical validity of the resulting
SpatialInertia with IsPhysicallyValid() and throws a RuntimeError
exception in the event the provided input parameters lead to
non-physically viable spatial inertia. Since this check has
non-negligable runtime costs, it can be disabled by setting the
optional argument <code class="docutils literal notranslate"><span class="pre">skip_validity_check</span></code> to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>The mass of the body or composite body S.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PScm_E</span></code>:</dt><dd><p>The position vector from point P to the center of mass of body or
composite body S expressed in frame E.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">G_SP_E</span></code>:</dt><dd><p>UnitInertia of the body or composite body S computed about origin
point P and expressed in frame E.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">skip_validity_check</span></code>:</dt><dd><p>If true, skips the validity check described above. Defaults to
false.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia.CalcComMoment(self:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Computes the center of mass moment vector <code class="docutils literal notranslate"><span class="pre">mass</span> <span class="pre">*</span> <span class="pre">p_PScm_E</span></code> given
the position vector <code class="docutils literal notranslate"><span class="pre">p_PScm_E</span></code> from the <em>about point</em> P to the
center of mass <code class="docutils literal notranslate"><span class="pre">Scm</span></code> of the body or composite body S, expressed in
frame E. See the documentation of this class for details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia.CalcPrincipalSemiDiametersAndPoseForSolidEllipsoid(self:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia)</span> <span class="pre">-&gt;</span> <span class="pre">tuple[numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">pydrake.math.RigidTransform]</span></span></dt>
<dd><p>Returns 3 principal semi-diameters [lmax lmed lmin] sorted in
descending order (lmax ≥ lmed ≥ lmin), orientation, and position of a
solid ellipsoid whose spatial inertia is equal to <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial
inertia. See spatial_inertia_equivalent_shapes “Spatial inertia
equivalent shapes” for more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the elements</strong><strong> of </strong><strong>this spatial inertia cannot be</strong> – </p></li>
<li><p><strong>converted to a real finite double. For example</strong><strong>, </strong><strong>an exception is</strong> – </p></li>
<li><p><strong>thrown if this contains an erroneous NaN</strong><strong> or </strong><strong>if scalar type T</strong> – </p></li>
<li><p><strong>is symbolic.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia.CalcRotationalInertia(self:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RotationalInertia</span></span></dt>
<dd><p>Computes the rotational inertia <code class="docutils literal notranslate"><span class="pre">I_SP_E</span> <span class="pre">=</span> <span class="pre">mass</span> <span class="pre">*</span> <span class="pre">G_SP_E</span></code> of this
spatial inertia, computed about point P and expressed in frame E. See
the documentation of this class for details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia.CopyToFullMatrix6(self:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[6,</span> <span class="pre">6]]</span></span></dt>
<dd><p>Copy to a full 6x6 matrix representation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia.get_com(self:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Get a constant reference to the position vector <code class="docutils literal notranslate"><span class="pre">p_PScm_E</span></code> from the
<em>about point</em> P to the center of mass <code class="docutils literal notranslate"><span class="pre">Scm</span></code> of the body or composite
body S, expressed in frame E. See the documentation of this class for
details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia.get_mass(self:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Get a constant reference to the mass of this spatial inertia.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia.get_unit_inertia(self:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia</span></span></dt>
<dd><p>Get a constant reference to the unit inertia <code class="docutils literal notranslate"><span class="pre">G_SP_E</span></code> of this
spatial inertia, computed about point P and expressed in frame E. See
the documentation of this class for details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia.HollowSphereWithDensity(area_density:</span> <span class="pre">float,</span> <span class="pre">radius:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform density thin hollow sphere B
about its geometric center Bo (which is coincident with B’s center of
mass Bcm).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">area_density</span></code>:</dt><dd><p>mass per unit area (kg/m²).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">radius</span></code>:</dt><dd><p>sphere’s radius in meters (the hollow sphere is regarded as an
infinitesimally thin shell of uniform density).</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>B’s spatial inertia about Bo, expressed in B. Since B’s rotational
inertia is triaxially symmetric, M_BBo_B = M_BBo_E, i.e., M_BBo
expressed in frame B is equal to M_BBo expressed in an arbitrary
frame E.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s rotational inertia about Bo is triaxially symmetric, meaning B
has an equal moment of inertia about any line passing through Bo.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if area_density</strong><strong> or </strong><strong>radius is not positive and finite.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia.HollowSphereWithMass(mass:</span> <span class="pre">float,</span> <span class="pre">radius:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform density hollow sphere B about
its geometric center Bo (which is coincident with B’s center of mass
Bcm).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>mass of the hollow sphere (kg).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">radius</span></code>:</dt><dd><p>sphere’s radius in meters (the hollow sphere is regarded as an
infinitesimally thin shell of uniform density).</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo</span></code>:</dt><dd><p>B’s spatial inertia about Bo. Since B’s rotational inertia is
triaxially symmetric, M_BBo_B = M_BBo_E, i.e., M_BBo expressed in
frame B is equal to M_BBo expressed in an arbitrary frame E.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s rotational inertia about Bo is triaxially symmetric, meaning B
has an equal moment of inertia about any line passing through Bo.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if mass</strong><strong> or </strong><strong>radius is not positive and finite.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia.IsNaN(self:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if any of the elements in this spatial inertia is NaN
and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia.IsPhysicallyValid(self:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Performs a number of checks to verify that this is a physically valid
spatial inertia. The checks performed include:</p>
<ul class="simple">
<li><p>No NaN entries.</p></li>
<li><p>Non-negative mass.</p></li>
<li><p>Non-negative principal moments about the center of mass.</p></li>
<li><p>Principal moments about the center of mass must satisfy the triangle
inequality:
- <code class="docutils literal notranslate"><span class="pre">Ixx</span> <span class="pre">+</span> <span class="pre">Iyy</span> <span class="pre">&gt;=</span> <span class="pre">Izz</span></code>
- <cite>Ixx + Izz &gt;= Iyy</cite>
- <code class="docutils literal notranslate"><span class="pre">Iyy</span> <span class="pre">+</span> <span class="pre">Izz</span> <span class="pre">&gt;=</span> <span class="pre">Ixx</span></code></p></li>
</ul>
<p>These are the tests performed by
RotationalInertia::CouldBePhysicallyValid() which become a sufficient
condition when performed on a rotational inertia about a body’s center
of mass.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RotationalInertia::CouldBePhysicallyValid().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia.IsZero(self:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if all of the elements in this spatial inertia are
zero and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia.MakeFromCentralInertia(mass:</span> <span class="pre">float,</span> <span class="pre">p_PScm_E:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">I_SScm_E:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia</span></span></dt>
<dd><p>Creates a spatial inertia for a physical body or composite body S
about a point P from a given mass, center of mass, and central
rotational inertia. For example, this method creates a body’s
SpatialInertia about its body origin Bo from the body’s mass, position
vector from Bo to the body’s center of mass, and rotational inertia
about the body’s center of mass.</p>
<p>This method checks for the physical validity of the resulting
SpatialInertia with IsPhysicallyValid() and throws a RuntimeError
exception in the event the provided input parameters lead to a
non-physically viable spatial inertia.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>The mass of the body or composite body S.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PScm_E</span></code>:</dt><dd><p>The position vector from point P to point <code class="docutils literal notranslate"><span class="pre">Scm</span></code> (S’s center of
mass), expressed in a frame E.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">I_SScm_E</span></code>:</dt><dd><p>S’s RotationalInertia about Scm, expressed in frame E.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_SP_E</span></code>:</dt><dd><p>S’s spatial inertia about point P, expressed in frame E.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia.NaN()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia</span></span></dt>
<dd><p>Initializes mass, center of mass and rotational inertia to invalid
NaN’s for a quick detection of uninitialized values.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia.ReExpress(self:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia,</span> <span class="pre">R_AE:</span> <span class="pre">pydrake.math.RotationMatrix)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia</span></span></dt>
<dd><p>Given <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial inertia <code class="docutils literal notranslate"><span class="pre">M_SP_E</span></code> for some body or composite
body S, taken about a point P and expressed in frame E, this method
computes the same inertia re-expressed in another frame A.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_AE</span></code>:</dt><dd><p>RotationMatrix relating frames A and E.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_SP_A</span></code>:</dt><dd><p>The same spatial inertia of S about P but now re-expressed in
frame A.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ReExpressInPlace() for details.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia.SetNaN(self:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial inertia to have NaN entries. Typically used for
quick detection of uninitialized values.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia.Shift(self:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia,</span> <span class="pre">p_PQ_E:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia</span></span></dt>
<dd><p>Given <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial inertia <code class="docutils literal notranslate"><span class="pre">M_SP_E</span></code> for some body or composite
body S, computed about point P, and expressed in frame E, this method
uses the <em>Parallel Axis Theorem</em> for spatial inertias to compute the
same spatial inertia about a new point Q. The result still is
expressed in frame E.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ShiftInPlace() for more details.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PQ_E</span></code>:</dt><dd><p>Vector from the original about point P to the new about point Q,
expressed in the same frame E <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial inertia is
expressed in.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_SQ_E</span></code>:</dt><dd><p>This same spatial inertia for body or composite body S but
computed about a new point Q.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia.SolidBoxWithDensity(density:</span> <span class="pre">float,</span> <span class="pre">lx:</span> <span class="pre">float,</span> <span class="pre">ly:</span> <span class="pre">float,</span> <span class="pre">lz:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform density solid box B about its
geometric center Bo (which is coincident with B’s center of mass Bcm).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">density</span></code>:</dt><dd><p>mass per volume (kg/m³).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lx</span></code>:</dt><dd><p>length of the box in the Bx direction (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">ly</span></code>:</dt><dd><p>length of the box in the By direction (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lz</span></code>:</dt><dd><p>length of the box in the Bz direction (meters).</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>B’s spatial inertia about Bo, expressed in B.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if density</strong><strong>, </strong><strong>lx</strong><strong>, </strong><strong>ly</strong><strong>, or </strong><strong>lz is not positive and finite.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia.SolidBoxWithMass(mass:</span> <span class="pre">float,</span> <span class="pre">lx:</span> <span class="pre">float,</span> <span class="pre">ly:</span> <span class="pre">float,</span> <span class="pre">lz:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform density solid box B about its
geometric center Bo (which is coincident with B’s center of mass Bcm).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>mass of the solid box (kg).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lx</span></code>:</dt><dd><p>length of the box in the Bx direction (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">ly</span></code>:</dt><dd><p>length of the box in the By direction (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lz</span></code>:</dt><dd><p>length of the box in the Bz direction (meters).</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>B’s spatial inertia about Bo, expressed in B.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if mass</strong><strong>, </strong><strong>lx</strong><strong>, </strong><strong>ly</strong><strong>, or </strong><strong>lz is not positive and finite.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia.SolidCapsuleWithDensity(density:</span> <span class="pre">float,</span> <span class="pre">radius:</span> <span class="pre">float,</span> <span class="pre">length:</span> <span class="pre">float,</span> <span class="pre">unit_vector:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform density solid capsule B about
its geometric center Bo (which is coincident with B’s center of mass
Bcm).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">density</span></code>:</dt><dd><p>mass per volume (kg/m³).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">radius</span></code>:</dt><dd><p>radius of the cylinder/half-sphere parts of the capsule.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">length</span></code>:</dt><dd><p>length of the cylindrical part of the capsule.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">unit_vector</span></code>:</dt><dd><p>unit vector defining the axial direction of the cylindrical part
of the capsule, expressed in B.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>B’s spatial inertia about Bo, expressed in B.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s rotational inertia about Bo is axially symmetric, meaning B
has an equal moment of inertia about any line that both passes
through Bo and is perpendicular to unit_vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if density</strong><strong>, </strong><strong>radius</strong><strong>, or </strong><strong>length is not positive and</strong> – </p></li>
<li><p><strong>finite</strong><strong> or </strong><strong>if ‖unit_vector‖ is not within 1.0E-14</strong><strong> of </strong><strong>1.0.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia.SolidCapsuleWithMass(mass:</span> <span class="pre">float,</span> <span class="pre">radius:</span> <span class="pre">float,</span> <span class="pre">length:</span> <span class="pre">float,</span> <span class="pre">unit_vector:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform density solid capsule B about
its geometric center Bo (which is coincident with B’s center of mass
Bcm).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>mass of the solid capsule (kg).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">radius</span></code>:</dt><dd><p>radius of the cylinder/half-sphere parts of the capsule.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">length</span></code>:</dt><dd><p>length of the cylindrical part of the capsule.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">unit_vector</span></code>:</dt><dd><p>unit vector defining the axial direction of the cylindrical part
of the capsule, expressed in B.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>B’s spatial inertia about Bo, expressed in B.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s rotational inertia about Bo is axially symmetric, meaning B
has an equal moment of inertia about any line that both passes
through Bo and is perpendicular to unit_vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if mass</strong><strong>, </strong><strong>radius</strong><strong>, or </strong><strong>length is not positive and finite</strong> – </p></li>
<li><p><strong>or if ‖unit_vector‖ is not within 1.0E-14</strong><strong> of </strong><strong>1.0.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia.SolidCubeWithDensity(density:</span> <span class="pre">float,</span> <span class="pre">length:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform density solid cube B about its
geometric center Bo (which is coincident with B’s center of mass Bcm).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">density</span></code>:</dt><dd><p>mass per volume (kg/m³).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">length</span></code>:</dt><dd><p>The length of each of the cube’s sides (meters).</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>B’s spatial inertia about Bo, expressed in B. Since B’s rotational
inertia is triaxially symmetric, M_BBo_B = M_BBo_E, i.e., M_BBo
expressed in frame B is equal to M_BBo expressed in an arbitrary
frame E.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s rotational inertia about Bo is triaxially symmetric, meaning B
has an equal moment of inertia about any line passing through Bo.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if density</strong><strong> or </strong><strong>length is not positive and finite.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia.SolidCylinderWithDensity(density:</span> <span class="pre">float,</span> <span class="pre">radius:</span> <span class="pre">float,</span> <span class="pre">length:</span> <span class="pre">float,</span> <span class="pre">unit_vector:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform density solid cylinder B about
its geometric center Bo (which is coincident with B’s center of mass
Bcm).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">density</span></code>:</dt><dd><p>mass per volume (kg/m³).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">radius</span></code>:</dt><dd><p>radius of the cylinder (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">length</span></code>:</dt><dd><p>length of cylinder in unit_vector direction (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">unit_vector</span></code>:</dt><dd><p>unit vector defining the axial direction of the cylinder,
expressed in B.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>B’s spatial inertia about Bo, expressed in B.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s rotational inertia about Bo is axially symmetric, meaning B
has an equal moment of inertia about any line that both passes
through Bo and is perpendicular to unit_vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if density</strong><strong>, </strong><strong>radius</strong><strong>, or </strong><strong>length is not positive and</strong> – </p></li>
<li><p><strong>finite</strong><strong> or </strong><strong>if ‖unit_vector‖ is not within 1.0E-14</strong><strong> of </strong><strong>1.0.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SolidCylinderWithDensityAboutEnd() to calculate M_BBp_B, B’s
spatial inertia about Bp (at the center of one of the cylinder’s
circular ends).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia.SolidCylinderWithDensityAboutEnd(density:</span> <span class="pre">float,</span> <span class="pre">radius:</span> <span class="pre">float,</span> <span class="pre">length:</span> <span class="pre">float,</span> <span class="pre">unit_vector:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform-density solid cylinder B about
an end-point Bp of the cylinder’s axis (see below for more about Bp).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">density</span></code>:</dt><dd><p>mass per volume (kg/m³).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">radius</span></code>:</dt><dd><p>radius of cylinder (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">length</span></code>:</dt><dd><p>length of cylinder in unit_vector direction (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">unit_vector</span></code>:</dt><dd><p>unit vector parallel to the axis of the cylinder and directed from
Bp to Bcm (B’s center of mass), expressed in B.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBp_B</span></code>:</dt><dd><p>B’s spatial inertia about Bp, expressed in B.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The position from Bp to Bcm is p_BpBcm = length / 2 * unit_vector.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s rotational inertia about Bp is axially symmetric, meaning B
has an equal moment of inertia about any line that both passes
through Bp and is perpendicular to unit_vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if density</strong><strong>, </strong><strong>radius</strong><strong>, or </strong><strong>length is not positive and</strong> – </p></li>
<li><p><strong>finite</strong><strong> or </strong><strong>if ‖unit_vector‖ is not within 1.0E-14</strong><strong> of </strong><strong>1.0.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SolidCylinderWithDensity() to calculate M_BBcm_B, B’s spatial
inertia about Bcm (B’s center of mass).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia.SolidCylinderWithMass(mass:</span> <span class="pre">float,</span> <span class="pre">radius:</span> <span class="pre">float,</span> <span class="pre">length:</span> <span class="pre">float,</span> <span class="pre">unit_vector:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform density solid cylinder B about
its geometric center Bo (which is coincident with B’s center of mass
Bcm).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>mass of the solid cylinder (kg).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">radius</span></code>:</dt><dd><p>radius of the cylinder (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">length</span></code>:</dt><dd><p>length of cylinder in unit_vector direction (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">unit_vector</span></code>:</dt><dd><p>unit vector defining the axial direction of the cylinder,
expressed in B.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>B’s spatial inertia about Bo, expressed in B.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s rotational inertia about Bo is axially symmetric, meaning B
has an equal moment of inertia about any line that both passes
through Bo and is perpendicular to unit_vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if mass</strong><strong>, </strong><strong>radius</strong><strong>, or </strong><strong>length is not positive and finite</strong> – </p></li>
<li><p><strong>or if ‖unit_vector‖ is not within 1.0E-14</strong><strong> of </strong><strong>1.0.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SolidCylinderWithMassAboutEnd() to calculate M_BBp_B, B’s spatial
inertia about Bp (at the center of one of the cylinder’s circular
ends).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia.SolidCylinderWithMassAboutEnd(mass:</span> <span class="pre">float,</span> <span class="pre">radius:</span> <span class="pre">float,</span> <span class="pre">length:</span> <span class="pre">float,</span> <span class="pre">unit_vector:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform-density solid cylinder B about
an end-point Bp of the cylinder’s axis (see below for more about Bp).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>mass of the solid cylinder (kg).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">radius</span></code>:</dt><dd><p>radius of cylinder (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">length</span></code>:</dt><dd><p>length of cylinder in unit_vector direction (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">unit_vector</span></code>:</dt><dd><p>unit vector parallel to the axis of the cylinder and directed from
Bp to Bcm (B’s center of mass), expressed in B.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBp_B</span></code>:</dt><dd><p>B’s spatial inertia about Bp, expressed in B.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The position from Bp to Bcm is p_BpBcm = length / 2 * unit_vector.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s rotational inertia about Bp is axially symmetric, meaning B
has an equal moment of inertia about any line that both passes
through Bp and is perpendicular to unit_vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if density</strong><strong>, </strong><strong>radius</strong><strong>, or </strong><strong>length is not positive and</strong> – </p></li>
<li><p><strong>finite</strong><strong> or </strong><strong>if ‖unit_vector‖ is not within 1.0E-14</strong><strong> of </strong><strong>1.0.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SolidCylinderWithMass() to calculate M_BBcm_B, B’s spatial inertia
about Bcm (B’s center of mass).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia.SolidEllipsoidWithDensity(density:</span> <span class="pre">float,</span> <span class="pre">a:</span> <span class="pre">float,</span> <span class="pre">b:</span> <span class="pre">float,</span> <span class="pre">c:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform density solid ellipsoid B
about its geometric center Bo (which is coincident with B’s center of
mass Bcm).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">density</span></code>:</dt><dd><p>mass per volume (kg/m³).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">a</span></code>:</dt><dd><p>length of ellipsoid semi-axis in the ellipsoid Bx direction.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>:</dt><dd><p>length of ellipsoid semi-axis in the ellipsoid By direction.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">c</span></code>:</dt><dd><p>length of ellipsoid semi-axis in the ellipsoid Bz direction.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>B’s spatial inertia about Bo, expressed in B.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if density</strong><strong>, </strong><strong>a</strong><strong>, </strong><strong>b</strong><strong>, or </strong><strong>c is not positive and finite.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia.SolidEllipsoidWithMass(mass:</span> <span class="pre">float,</span> <span class="pre">a:</span> <span class="pre">float,</span> <span class="pre">b:</span> <span class="pre">float,</span> <span class="pre">c:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform density solid ellipsoid B
about its geometric center Bo (which is coincident with B’s center of
mass Bcm).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>mass of the solid ellipsoid (kg).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">a</span></code>:</dt><dd><p>length of ellipsoid semi-axis in the ellipsoid Bx direction.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>:</dt><dd><p>length of ellipsoid semi-axis in the ellipsoid By direction.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">c</span></code>:</dt><dd><p>length of ellipsoid semi-axis in the ellipsoid Bz direction.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>B’s spatial inertia about Bo, expressed in B.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if mass</strong><strong>, </strong><strong>a</strong><strong>, </strong><strong>b</strong><strong>, or </strong><strong>c is not positive and finite.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia.SolidSphereWithDensity(density:</span> <span class="pre">float,</span> <span class="pre">radius:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform density solid sphere B about
its geometric center Bo (which is coincident with B’s center of mass
Bcm).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">density</span></code>:</dt><dd><p>mass per volume (kg/m³).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">radius</span></code>:</dt><dd><p>sphere’s radius (meters).</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo</span></code>:</dt><dd><p>B’s spatial inertia about Bo. Since B’s rotational inertia is
triaxially symmetric, M_BBo_B = M_BBo_E, i.e., M_BBo expressed in
frame B is equal to M_BBo expressed in an arbitrary frame E.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s rotational inertia about Bo is triaxially symmetric, meaning B
has an equal moment of inertia about any line passing through Bo.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if density</strong><strong> or </strong><strong>radius is not positive and finite.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia.SolidSphereWithMass(mass:</span> <span class="pre">float,</span> <span class="pre">radius:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform density solid sphere B about
its geometric center Bo (which is coincident with B’s center of mass
Bcm).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>mass of the solid sphere (kg).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">radius</span></code>:</dt><dd><p>sphere’s radius (meters).</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo</span></code>:</dt><dd><p>B’s spatial inertia about Bo. Since B’s rotational inertia is
triaxially symmetric, M_BBo_B = M_BBo_E, i.e., M_BBo expressed in
frame B is equal to M_BBo expressed in an arbitrary frame E.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s rotational inertia about Bo is triaxially symmetric, meaning B
has an equal moment of inertia about any line passing through Bo.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if mass</strong><strong> or </strong><strong>radius is not positive and finite.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia.ThinRodWithMass(mass:</span> <span class="pre">float,</span> <span class="pre">length:</span> <span class="pre">float,</span> <span class="pre">unit_vector:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform-density thin rod B about its
center of mass Bcm.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>mass of the rod (units of kg).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">length</span></code>:</dt><dd><p>length of the rod (units of meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">unit_vector</span></code>:</dt><dd><p>unit vector defining the rod’s axial direction, expressed in B.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBcm_B</span></code>:</dt><dd><p>B’s spatial inertia about Bcm, expressed in B.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s rotational inertia about Bcm is axially symmetric, meaning B
has an equal moment of inertia about any line that both passes
through Bcm and is perpendicular to unit_vector. B has no (zero)
rotational inertia about the line that passes through Bcm and is
parallel to unit_vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if mass</strong><strong> or </strong><strong>length is not positive and finite</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>‖unit_vector‖ is not within 1.0E-14</strong><strong> of </strong><strong>1.0.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ThinRodWithMassAboutEnd() to calculate M_BBp_B, B’s spatial
inertia about Bp (one of the ends of rod B).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia.ThinRodWithMassAboutEnd(mass:</span> <span class="pre">float,</span> <span class="pre">length:</span> <span class="pre">float,</span> <span class="pre">unit_vector:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform-density thin rod B about one
of its ends.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>mass of the rod (units of kg).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">length</span></code>:</dt><dd><p>length of the rod (units of meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">unit_vector</span></code>:</dt><dd><p>unit vector defining the rod’s axial direction, expressed in B.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBp_B</span></code>:</dt><dd><p>B’s spatial inertia about Bp, expressed in B.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The position from Bp to Bcm is length / 2 * unit_vector.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s rotational inertia about Bp is axially symmetric, meaning B
has an equal moment of inertia about any line that both passes
through Bp and is perpendicular to unit_vector. B has no (zero)
rotational inertia about the line that passes through Bp and is
parallel to unit_vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if mass</strong><strong> or </strong><strong>length is not positive and finite</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>‖unit_vector‖ is not within 1.0E-14</strong><strong> of </strong><strong>1.0.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ThinRodWithMass() to calculate M_BBcm_B, B’s spatial inertia about
Bcm (B’s center of mass).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia.Zero()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia</span></span></dt>
<dd><p>Initializes mass, center of mass and rotational inertia to zero.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialInertia_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialInertia_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialInertia_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[AutoDiffXd]</span></span></dt>
<dd><p>This class represents the physical concept of a <em>Spatial Inertia</em>. A
spatial inertia (or spatial mass matrix) encapsulates the mass, center
of mass, and rotational inertia of the mass distribution of a body or
composite body S, where with “composite body” we mean a collection of
bodies welded together containing at least one body (throughout this
documentation “body” is many times used instead of “composite body”
but the same concepts apply to a collection of bodies as well.) A
spatial inertia is an element of ℝ⁶ˣ⁶ that is symmetric, and positive
semi-definite. It logically consists of <code class="docutils literal notranslate"><span class="pre">3x3</span></code> sub-matrices arranged
like so, [Jain 2010]:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Spatial</span><span class="w"> </span><span class="n">mass</span><span class="w"> </span><span class="n">matrix</span>
<span class="w">          </span><span class="o">------------</span><span class="w"> </span><span class="o">------------</span>
<span class="w">       </span><span class="mi">0</span><span class="w"> </span><span class="o">|</span><span class="w">            </span><span class="o">|</span><span class="w">            </span><span class="o">|</span>
<span class="w">       </span><span class="mi">1</span><span class="w"> </span><span class="o">|</span><span class="w">    </span><span class="n">I_SP</span><span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">p_PScm</span><span class="err">×</span><span class="w">  </span><span class="o">|</span>
<span class="w">       </span><span class="mi">2</span><span class="w"> </span><span class="o">|</span><span class="w">            </span><span class="o">|</span><span class="w">            </span><span class="o">|</span>
<span class="w">          </span><span class="o">------------</span><span class="w"> </span><span class="o">------------</span>
<span class="w">       </span><span class="mi">3</span><span class="w"> </span><span class="o">|</span><span class="w">            </span><span class="o">|</span><span class="w">            </span><span class="o">|</span>
<span class="w">       </span><span class="mi">4</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">-</span><span class="n">m</span><span class="w"> </span><span class="n">p_PScm</span><span class="err">×</span><span class="w"> </span><span class="o">|</span><span class="w">     </span><span class="n">m</span><span class="w"> </span><span class="n">Id</span><span class="w">   </span><span class="o">|</span>
<span class="w">       </span><span class="mi">5</span><span class="w"> </span><span class="o">|</span><span class="w">            </span><span class="o">|</span><span class="w">            </span><span class="o">|</span>
<span class="w">          </span><span class="o">------------</span><span class="w"> </span><span class="o">------------</span>
<span class="w">               </span><span class="nl">Symbol</span><span class="p">:</span><span class="w"> </span><span class="n">M</span>
</pre></div>
</div>
</details><p>where, with the monogram notation described in
multibody_spatial_inertia, <code class="docutils literal notranslate"><span class="pre">I_SP</span></code> is the rotational inertia of body
or composite body S computed about a point P, m is the mass of this
composite body, <code class="docutils literal notranslate"><span class="pre">p_PScm</span></code> is the position vector from point P to the
center of mass <code class="docutils literal notranslate"><span class="pre">Scm</span></code> of the composite body S with <code class="docutils literal notranslate"><span class="pre">p_PScm×</span></code>
denoting its skew-symmetric cross product matrix (defined such that
<code class="docutils literal notranslate"><span class="pre">a×</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">a.cross(b)</span></code>), and <code class="docutils literal notranslate"><span class="pre">Id</span></code> is the identity matrix in ℝ³ˣ³. See
Section 2.1, p. 17 of [Jain 2010]. The logical arrangement as shown
above is chosen to be consistent with our logical arrangement for
spatial vectors as documented in multibody_spatial_algebra for which
the rotational component comes first followed by the translational
component.</p>
<p>In typeset material we use the symbol <span class="math notranslate nohighlight">\([M^{S/P}]_E\)</span> to represent
the spatial inertia of a body or composite body S about point P,
expressed in frame E. For this inertia, the monogram notation reads
<code class="docutils literal notranslate"><span class="pre">M_SP_E</span></code>. If the point P is fixed to a body B, we write that point
as <span class="math notranslate nohighlight">\(B_P\)</span> which appears in code and comments as <code class="docutils literal notranslate"><span class="pre">Bp</span></code>. So if the
body or composite body is B and the about point is <code class="docutils literal notranslate"><span class="pre">Bp</span></code>, the
monogram notation reads <code class="docutils literal notranslate"><span class="pre">M_BBp_E</span></code>, which can be abbreviated to
<code class="docutils literal notranslate"><span class="pre">M_Bp_E</span></code> since the about point <code class="docutils literal notranslate"><span class="pre">Bp</span></code> also identifies the body.
Common cases are that the about point is the origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code> of the
body, or it’s the center of mass <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> for which the rotational
inertia in monogram notation would read as <code class="docutils literal notranslate"><span class="pre">I_Bo_E</span></code> and <code class="docutils literal notranslate"><span class="pre">I_Bcm_E</span></code>,
respectively. Given <code class="docutils literal notranslate"><span class="pre">M_BP_E</span></code> (<span class="math notranslate nohighlight">\([M^{B/P}]_E\)</span>), the rotational
inertia of this spatial inertia is <code class="docutils literal notranslate"><span class="pre">I_BP_E</span></code> (<span class="math notranslate nohighlight">\([I^{B/P}]_E\)</span>)
and the position vector of the center of mass measured from point P
and expressed in E is <code class="docutils literal notranslate"><span class="pre">p_PBcm_E</span></code> (<span class="math notranslate nohighlight">\([^Pp^{B_{cm}}]_E\)</span>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class does not implement any mechanism to track the frame E
in which a spatial inertia is expressed or about what point is
computed. Methods and operators on this class have no means to
determine frame consistency through operations. It is therefore
the responsibility of users of this class to keep track of frames
in which operations are performed. We suggest doing that using
disciplined notation, as described above.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Several methods in this class throw a RuntimeError for invalid
rotational inertia operations in debug releases only. This
provides speed in a release build while facilitating debugging in
debug builds. In addition, these validity tests are only performed
for scalar types for which drake::scalar_predicate&lt;T&gt;::is_bool is
<code class="docutils literal notranslate"><span class="pre">True</span></code>. For instance, validity checks are not performed when T
is symbolic::Expression.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The methods of this class satisfy the “basic exception guarantee”:
if an exception is thrown, the program will still be in a valid
state. Specifically, no resources are leaked, and all objects’
invariants are intact. Be aware that SpatialInertia objects may
contain invalid inertia data in cases where input checking is
skipped.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://en.cppreference.com/w/cpp/language/exceptions">https://en.cppreference.com/w/cpp/language/exceptions</a></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>To create a spatial inertia of a mesh, see
CalcSpatialInertia(const geometry::TriangleSurfaceMesh&lt;double&gt;&amp;
mesh, double density).</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>To create spatial inertia from most of geometry::Shape, see
CalcSpatialInertia(const geometry::Shape&amp; shape, double density).</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>To create spatial inertia for a set of bodies, see
MultibodyPlant::CalcSpatialInertia().</p>
</div>
<ul class="simple">
<li><dl class="simple">
<dt>[Jain 2010]  Jain, A., 2010. Robot and multibody dynamics: analysis and</dt><dd><p>algorithms. Springer Science &amp; Business Media.</p>
</dd>
</dl>
</li>
</ul>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[AutoDiffXd],</span> <span class="pre">mass:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">p_PScm_E:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]],</span> <span class="pre">G_SP_E:</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[AutoDiffXd],</span> <span class="pre">skip_validity_check:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">False)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a spatial inertia for a physical body or composite body S
about a point P from a given mass, center of mass and rotational
inertia. The center of mass is specified by the position vector
<code class="docutils literal notranslate"><span class="pre">p_PScm_E</span></code> from point P to the center of mass point <code class="docutils literal notranslate"><span class="pre">Scm</span></code>,
expressed in a frame E. The rotational inertia is provided as the
UnitInertia <code class="docutils literal notranslate"><span class="pre">G_SP_E</span></code> of the body or composite body S computed about
point P and expressed in frame E.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The third argument of this constructor is unusual in that it is an
UnitInertia (not a traditional RotationalInertia) and its inertia
is about the arbitrary point P (not Scm – S’s center of mass).</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MakeFromCentralInertia a factory method with traditional utility.</p>
</div>
<p>This constructor checks for the physical validity of the resulting
SpatialInertia with IsPhysicallyValid() and throws a RuntimeError
exception in the event the provided input parameters lead to
non-physically viable spatial inertia. Since this check has
non-negligable runtime costs, it can be disabled by setting the
optional argument <code class="docutils literal notranslate"><span class="pre">skip_validity_check</span></code> to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>The mass of the body or composite body S.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PScm_E</span></code>:</dt><dd><p>The position vector from point P to the center of mass of body or
composite body S expressed in frame E.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">G_SP_E</span></code>:</dt><dd><p>UnitInertia of the body or composite body S computed about origin
point P and expressed in frame E.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">skip_validity_check</span></code>:</dt><dd><p>If true, skips the validity check described above. Defaults to
false.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[AutoDiffXd].CalcComMoment(self:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Computes the center of mass moment vector <code class="docutils literal notranslate"><span class="pre">mass</span> <span class="pre">*</span> <span class="pre">p_PScm_E</span></code> given
the position vector <code class="docutils literal notranslate"><span class="pre">p_PScm_E</span></code> from the <em>about point</em> P to the
center of mass <code class="docutils literal notranslate"><span class="pre">Scm</span></code> of the body or composite body S, expressed in
frame E. See the documentation of this class for details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[AutoDiffXd].CalcPrincipalSemiDiametersAndPoseForSolidEllipsoid(self:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">tuple[numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">pydrake.math.RigidTransform]</span></span></dt>
<dd><p>Returns 3 principal semi-diameters [lmax lmed lmin] sorted in
descending order (lmax ≥ lmed ≥ lmin), orientation, and position of a
solid ellipsoid whose spatial inertia is equal to <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial
inertia. See spatial_inertia_equivalent_shapes “Spatial inertia
equivalent shapes” for more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the elements</strong><strong> of </strong><strong>this spatial inertia cannot be</strong> – </p></li>
<li><p><strong>converted to a real finite double. For example</strong><strong>, </strong><strong>an exception is</strong> – </p></li>
<li><p><strong>thrown if this contains an erroneous NaN</strong><strong> or </strong><strong>if scalar type T</strong> – </p></li>
<li><p><strong>is symbolic.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[AutoDiffXd].CalcRotationalInertia(self:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Computes the rotational inertia <code class="docutils literal notranslate"><span class="pre">I_SP_E</span> <span class="pre">=</span> <span class="pre">mass</span> <span class="pre">*</span> <span class="pre">G_SP_E</span></code> of this
spatial inertia, computed about point P and expressed in frame E. See
the documentation of this class for details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[AutoDiffXd].CopyToFullMatrix6(self:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[6,</span> <span class="pre">6]]</span></span></dt>
<dd><p>Copy to a full 6x6 matrix representation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[AutoDiffXd].get_com(self:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Get a constant reference to the position vector <code class="docutils literal notranslate"><span class="pre">p_PScm_E</span></code> from the
<em>about point</em> P to the center of mass <code class="docutils literal notranslate"><span class="pre">Scm</span></code> of the body or composite
body S, expressed in frame E. See the documentation of this class for
details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[AutoDiffXd].get_mass(self:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd</span></span></dt>
<dd><p>Get a constant reference to the mass of this spatial inertia.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[AutoDiffXd].get_unit_inertia(self:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Get a constant reference to the unit inertia <code class="docutils literal notranslate"><span class="pre">G_SP_E</span></code> of this
spatial inertia, computed about point P and expressed in frame E. See
the documentation of this class for details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[AutoDiffXd].HollowSphereWithDensity(area_density:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">radius:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform density thin hollow sphere B
about its geometric center Bo (which is coincident with B’s center of
mass Bcm).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">area_density</span></code>:</dt><dd><p>mass per unit area (kg/m²).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">radius</span></code>:</dt><dd><p>sphere’s radius in meters (the hollow sphere is regarded as an
infinitesimally thin shell of uniform density).</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>B’s spatial inertia about Bo, expressed in B. Since B’s rotational
inertia is triaxially symmetric, M_BBo_B = M_BBo_E, i.e., M_BBo
expressed in frame B is equal to M_BBo expressed in an arbitrary
frame E.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s rotational inertia about Bo is triaxially symmetric, meaning B
has an equal moment of inertia about any line passing through Bo.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if area_density</strong><strong> or </strong><strong>radius is not positive and finite.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[AutoDiffXd].HollowSphereWithMass(mass:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">radius:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform density hollow sphere B about
its geometric center Bo (which is coincident with B’s center of mass
Bcm).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>mass of the hollow sphere (kg).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">radius</span></code>:</dt><dd><p>sphere’s radius in meters (the hollow sphere is regarded as an
infinitesimally thin shell of uniform density).</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo</span></code>:</dt><dd><p>B’s spatial inertia about Bo. Since B’s rotational inertia is
triaxially symmetric, M_BBo_B = M_BBo_E, i.e., M_BBo expressed in
frame B is equal to M_BBo expressed in an arbitrary frame E.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s rotational inertia about Bo is triaxially symmetric, meaning B
has an equal moment of inertia about any line passing through Bo.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if mass</strong><strong> or </strong><strong>radius is not positive and finite.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[AutoDiffXd].IsNaN(self:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if any of the elements in this spatial inertia is NaN
and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[AutoDiffXd].IsPhysicallyValid(self:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Performs a number of checks to verify that this is a physically valid
spatial inertia. The checks performed include:</p>
<ul class="simple">
<li><p>No NaN entries.</p></li>
<li><p>Non-negative mass.</p></li>
<li><p>Non-negative principal moments about the center of mass.</p></li>
<li><p>Principal moments about the center of mass must satisfy the triangle
inequality:
- <code class="docutils literal notranslate"><span class="pre">Ixx</span> <span class="pre">+</span> <span class="pre">Iyy</span> <span class="pre">&gt;=</span> <span class="pre">Izz</span></code>
- <cite>Ixx + Izz &gt;= Iyy</cite>
- <code class="docutils literal notranslate"><span class="pre">Iyy</span> <span class="pre">+</span> <span class="pre">Izz</span> <span class="pre">&gt;=</span> <span class="pre">Ixx</span></code></p></li>
</ul>
<p>These are the tests performed by
RotationalInertia::CouldBePhysicallyValid() which become a sufficient
condition when performed on a rotational inertia about a body’s center
of mass.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RotationalInertia::CouldBePhysicallyValid().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[AutoDiffXd].IsZero(self:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if all of the elements in this spatial inertia are
zero and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[AutoDiffXd].MakeFromCentralInertia(mass:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">p_PScm_E:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]],</span> <span class="pre">I_SScm_E:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Creates a spatial inertia for a physical body or composite body S
about a point P from a given mass, center of mass, and central
rotational inertia. For example, this method creates a body’s
SpatialInertia about its body origin Bo from the body’s mass, position
vector from Bo to the body’s center of mass, and rotational inertia
about the body’s center of mass.</p>
<p>This method checks for the physical validity of the resulting
SpatialInertia with IsPhysicallyValid() and throws a RuntimeError
exception in the event the provided input parameters lead to a
non-physically viable spatial inertia.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>The mass of the body or composite body S.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PScm_E</span></code>:</dt><dd><p>The position vector from point P to point <code class="docutils literal notranslate"><span class="pre">Scm</span></code> (S’s center of
mass), expressed in a frame E.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">I_SScm_E</span></code>:</dt><dd><p>S’s RotationalInertia about Scm, expressed in frame E.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_SP_E</span></code>:</dt><dd><p>S’s spatial inertia about point P, expressed in frame E.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[AutoDiffXd].NaN()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Initializes mass, center of mass and rotational inertia to invalid
NaN’s for a quick detection of uninitialized values.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[AutoDiffXd].ReExpress(self:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[AutoDiffXd],</span> <span class="pre">R_AE:</span> <span class="pre">pydrake.math.RotationMatrix_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Given <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial inertia <code class="docutils literal notranslate"><span class="pre">M_SP_E</span></code> for some body or composite
body S, taken about a point P and expressed in frame E, this method
computes the same inertia re-expressed in another frame A.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_AE</span></code>:</dt><dd><p>RotationMatrix relating frames A and E.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_SP_A</span></code>:</dt><dd><p>The same spatial inertia of S about P but now re-expressed in
frame A.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ReExpressInPlace() for details.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[AutoDiffXd].SetNaN(self:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial inertia to have NaN entries. Typically used for
quick detection of uninitialized values.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[AutoDiffXd].Shift(self:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[AutoDiffXd],</span> <span class="pre">p_PQ_E:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Given <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial inertia <code class="docutils literal notranslate"><span class="pre">M_SP_E</span></code> for some body or composite
body S, computed about point P, and expressed in frame E, this method
uses the <em>Parallel Axis Theorem</em> for spatial inertias to compute the
same spatial inertia about a new point Q. The result still is
expressed in frame E.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ShiftInPlace() for more details.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PQ_E</span></code>:</dt><dd><p>Vector from the original about point P to the new about point Q,
expressed in the same frame E <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial inertia is
expressed in.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_SQ_E</span></code>:</dt><dd><p>This same spatial inertia for body or composite body S but
computed about a new point Q.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[AutoDiffXd].SolidBoxWithDensity(density:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">lx:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">ly:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">lz:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform density solid box B about its
geometric center Bo (which is coincident with B’s center of mass Bcm).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">density</span></code>:</dt><dd><p>mass per volume (kg/m³).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lx</span></code>:</dt><dd><p>length of the box in the Bx direction (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">ly</span></code>:</dt><dd><p>length of the box in the By direction (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lz</span></code>:</dt><dd><p>length of the box in the Bz direction (meters).</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>B’s spatial inertia about Bo, expressed in B.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if density</strong><strong>, </strong><strong>lx</strong><strong>, </strong><strong>ly</strong><strong>, or </strong><strong>lz is not positive and finite.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[AutoDiffXd].SolidBoxWithMass(mass:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">lx:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">ly:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">lz:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform density solid box B about its
geometric center Bo (which is coincident with B’s center of mass Bcm).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>mass of the solid box (kg).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lx</span></code>:</dt><dd><p>length of the box in the Bx direction (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">ly</span></code>:</dt><dd><p>length of the box in the By direction (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lz</span></code>:</dt><dd><p>length of the box in the Bz direction (meters).</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>B’s spatial inertia about Bo, expressed in B.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if mass</strong><strong>, </strong><strong>lx</strong><strong>, </strong><strong>ly</strong><strong>, or </strong><strong>lz is not positive and finite.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[AutoDiffXd].SolidCapsuleWithDensity(density:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">radius:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">length:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">unit_vector:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform density solid capsule B about
its geometric center Bo (which is coincident with B’s center of mass
Bcm).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">density</span></code>:</dt><dd><p>mass per volume (kg/m³).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">radius</span></code>:</dt><dd><p>radius of the cylinder/half-sphere parts of the capsule.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">length</span></code>:</dt><dd><p>length of the cylindrical part of the capsule.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">unit_vector</span></code>:</dt><dd><p>unit vector defining the axial direction of the cylindrical part
of the capsule, expressed in B.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>B’s spatial inertia about Bo, expressed in B.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s rotational inertia about Bo is axially symmetric, meaning B
has an equal moment of inertia about any line that both passes
through Bo and is perpendicular to unit_vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if density</strong><strong>, </strong><strong>radius</strong><strong>, or </strong><strong>length is not positive and</strong> – </p></li>
<li><p><strong>finite</strong><strong> or </strong><strong>if ‖unit_vector‖ is not within 1.0E-14</strong><strong> of </strong><strong>1.0.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[AutoDiffXd].SolidCapsuleWithMass(mass:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">radius:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">length:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">unit_vector:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform density solid capsule B about
its geometric center Bo (which is coincident with B’s center of mass
Bcm).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>mass of the solid capsule (kg).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">radius</span></code>:</dt><dd><p>radius of the cylinder/half-sphere parts of the capsule.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">length</span></code>:</dt><dd><p>length of the cylindrical part of the capsule.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">unit_vector</span></code>:</dt><dd><p>unit vector defining the axial direction of the cylindrical part
of the capsule, expressed in B.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>B’s spatial inertia about Bo, expressed in B.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s rotational inertia about Bo is axially symmetric, meaning B
has an equal moment of inertia about any line that both passes
through Bo and is perpendicular to unit_vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if mass</strong><strong>, </strong><strong>radius</strong><strong>, or </strong><strong>length is not positive and finite</strong> – </p></li>
<li><p><strong>or if ‖unit_vector‖ is not within 1.0E-14</strong><strong> of </strong><strong>1.0.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[AutoDiffXd].SolidCubeWithDensity(density:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">length:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform density solid cube B about its
geometric center Bo (which is coincident with B’s center of mass Bcm).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">density</span></code>:</dt><dd><p>mass per volume (kg/m³).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">length</span></code>:</dt><dd><p>The length of each of the cube’s sides (meters).</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>B’s spatial inertia about Bo, expressed in B. Since B’s rotational
inertia is triaxially symmetric, M_BBo_B = M_BBo_E, i.e., M_BBo
expressed in frame B is equal to M_BBo expressed in an arbitrary
frame E.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s rotational inertia about Bo is triaxially symmetric, meaning B
has an equal moment of inertia about any line passing through Bo.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if density</strong><strong> or </strong><strong>length is not positive and finite.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[AutoDiffXd].SolidCylinderWithDensity(density:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">radius:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">length:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">unit_vector:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform density solid cylinder B about
its geometric center Bo (which is coincident with B’s center of mass
Bcm).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">density</span></code>:</dt><dd><p>mass per volume (kg/m³).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">radius</span></code>:</dt><dd><p>radius of the cylinder (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">length</span></code>:</dt><dd><p>length of cylinder in unit_vector direction (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">unit_vector</span></code>:</dt><dd><p>unit vector defining the axial direction of the cylinder,
expressed in B.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>B’s spatial inertia about Bo, expressed in B.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s rotational inertia about Bo is axially symmetric, meaning B
has an equal moment of inertia about any line that both passes
through Bo and is perpendicular to unit_vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if density</strong><strong>, </strong><strong>radius</strong><strong>, or </strong><strong>length is not positive and</strong> – </p></li>
<li><p><strong>finite</strong><strong> or </strong><strong>if ‖unit_vector‖ is not within 1.0E-14</strong><strong> of </strong><strong>1.0.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SolidCylinderWithDensityAboutEnd() to calculate M_BBp_B, B’s
spatial inertia about Bp (at the center of one of the cylinder’s
circular ends).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[AutoDiffXd].SolidCylinderWithDensityAboutEnd(density:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">radius:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">length:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">unit_vector:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform-density solid cylinder B about
an end-point Bp of the cylinder’s axis (see below for more about Bp).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">density</span></code>:</dt><dd><p>mass per volume (kg/m³).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">radius</span></code>:</dt><dd><p>radius of cylinder (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">length</span></code>:</dt><dd><p>length of cylinder in unit_vector direction (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">unit_vector</span></code>:</dt><dd><p>unit vector parallel to the axis of the cylinder and directed from
Bp to Bcm (B’s center of mass), expressed in B.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBp_B</span></code>:</dt><dd><p>B’s spatial inertia about Bp, expressed in B.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The position from Bp to Bcm is p_BpBcm = length / 2 * unit_vector.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s rotational inertia about Bp is axially symmetric, meaning B
has an equal moment of inertia about any line that both passes
through Bp and is perpendicular to unit_vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if density</strong><strong>, </strong><strong>radius</strong><strong>, or </strong><strong>length is not positive and</strong> – </p></li>
<li><p><strong>finite</strong><strong> or </strong><strong>if ‖unit_vector‖ is not within 1.0E-14</strong><strong> of </strong><strong>1.0.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SolidCylinderWithDensity() to calculate M_BBcm_B, B’s spatial
inertia about Bcm (B’s center of mass).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[AutoDiffXd].SolidCylinderWithMass(mass:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">radius:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">length:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">unit_vector:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform density solid cylinder B about
its geometric center Bo (which is coincident with B’s center of mass
Bcm).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>mass of the solid cylinder (kg).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">radius</span></code>:</dt><dd><p>radius of the cylinder (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">length</span></code>:</dt><dd><p>length of cylinder in unit_vector direction (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">unit_vector</span></code>:</dt><dd><p>unit vector defining the axial direction of the cylinder,
expressed in B.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>B’s spatial inertia about Bo, expressed in B.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s rotational inertia about Bo is axially symmetric, meaning B
has an equal moment of inertia about any line that both passes
through Bo and is perpendicular to unit_vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if mass</strong><strong>, </strong><strong>radius</strong><strong>, or </strong><strong>length is not positive and finite</strong> – </p></li>
<li><p><strong>or if ‖unit_vector‖ is not within 1.0E-14</strong><strong> of </strong><strong>1.0.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SolidCylinderWithMassAboutEnd() to calculate M_BBp_B, B’s spatial
inertia about Bp (at the center of one of the cylinder’s circular
ends).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[AutoDiffXd].SolidCylinderWithMassAboutEnd(mass:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">radius:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">length:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">unit_vector:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform-density solid cylinder B about
an end-point Bp of the cylinder’s axis (see below for more about Bp).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>mass of the solid cylinder (kg).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">radius</span></code>:</dt><dd><p>radius of cylinder (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">length</span></code>:</dt><dd><p>length of cylinder in unit_vector direction (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">unit_vector</span></code>:</dt><dd><p>unit vector parallel to the axis of the cylinder and directed from
Bp to Bcm (B’s center of mass), expressed in B.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBp_B</span></code>:</dt><dd><p>B’s spatial inertia about Bp, expressed in B.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The position from Bp to Bcm is p_BpBcm = length / 2 * unit_vector.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s rotational inertia about Bp is axially symmetric, meaning B
has an equal moment of inertia about any line that both passes
through Bp and is perpendicular to unit_vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if density</strong><strong>, </strong><strong>radius</strong><strong>, or </strong><strong>length is not positive and</strong> – </p></li>
<li><p><strong>finite</strong><strong> or </strong><strong>if ‖unit_vector‖ is not within 1.0E-14</strong><strong> of </strong><strong>1.0.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SolidCylinderWithMass() to calculate M_BBcm_B, B’s spatial inertia
about Bcm (B’s center of mass).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[AutoDiffXd].SolidEllipsoidWithDensity(density:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">a:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">b:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">c:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform density solid ellipsoid B
about its geometric center Bo (which is coincident with B’s center of
mass Bcm).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">density</span></code>:</dt><dd><p>mass per volume (kg/m³).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">a</span></code>:</dt><dd><p>length of ellipsoid semi-axis in the ellipsoid Bx direction.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>:</dt><dd><p>length of ellipsoid semi-axis in the ellipsoid By direction.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">c</span></code>:</dt><dd><p>length of ellipsoid semi-axis in the ellipsoid Bz direction.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>B’s spatial inertia about Bo, expressed in B.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if density</strong><strong>, </strong><strong>a</strong><strong>, </strong><strong>b</strong><strong>, or </strong><strong>c is not positive and finite.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[AutoDiffXd].SolidEllipsoidWithMass(mass:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">a:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">b:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">c:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform density solid ellipsoid B
about its geometric center Bo (which is coincident with B’s center of
mass Bcm).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>mass of the solid ellipsoid (kg).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">a</span></code>:</dt><dd><p>length of ellipsoid semi-axis in the ellipsoid Bx direction.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>:</dt><dd><p>length of ellipsoid semi-axis in the ellipsoid By direction.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">c</span></code>:</dt><dd><p>length of ellipsoid semi-axis in the ellipsoid Bz direction.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>B’s spatial inertia about Bo, expressed in B.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if mass</strong><strong>, </strong><strong>a</strong><strong>, </strong><strong>b</strong><strong>, or </strong><strong>c is not positive and finite.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[AutoDiffXd].SolidSphereWithDensity(density:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">radius:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform density solid sphere B about
its geometric center Bo (which is coincident with B’s center of mass
Bcm).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">density</span></code>:</dt><dd><p>mass per volume (kg/m³).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">radius</span></code>:</dt><dd><p>sphere’s radius (meters).</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo</span></code>:</dt><dd><p>B’s spatial inertia about Bo. Since B’s rotational inertia is
triaxially symmetric, M_BBo_B = M_BBo_E, i.e., M_BBo expressed in
frame B is equal to M_BBo expressed in an arbitrary frame E.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s rotational inertia about Bo is triaxially symmetric, meaning B
has an equal moment of inertia about any line passing through Bo.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if density</strong><strong> or </strong><strong>radius is not positive and finite.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[AutoDiffXd].SolidSphereWithMass(mass:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">radius:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform density solid sphere B about
its geometric center Bo (which is coincident with B’s center of mass
Bcm).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>mass of the solid sphere (kg).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">radius</span></code>:</dt><dd><p>sphere’s radius (meters).</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo</span></code>:</dt><dd><p>B’s spatial inertia about Bo. Since B’s rotational inertia is
triaxially symmetric, M_BBo_B = M_BBo_E, i.e., M_BBo expressed in
frame B is equal to M_BBo expressed in an arbitrary frame E.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s rotational inertia about Bo is triaxially symmetric, meaning B
has an equal moment of inertia about any line passing through Bo.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if mass</strong><strong> or </strong><strong>radius is not positive and finite.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[AutoDiffXd].ThinRodWithMass(mass:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">length:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">unit_vector:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform-density thin rod B about its
center of mass Bcm.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>mass of the rod (units of kg).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">length</span></code>:</dt><dd><p>length of the rod (units of meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">unit_vector</span></code>:</dt><dd><p>unit vector defining the rod’s axial direction, expressed in B.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBcm_B</span></code>:</dt><dd><p>B’s spatial inertia about Bcm, expressed in B.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s rotational inertia about Bcm is axially symmetric, meaning B
has an equal moment of inertia about any line that both passes
through Bcm and is perpendicular to unit_vector. B has no (zero)
rotational inertia about the line that passes through Bcm and is
parallel to unit_vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if mass</strong><strong> or </strong><strong>length is not positive and finite</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>‖unit_vector‖ is not within 1.0E-14</strong><strong> of </strong><strong>1.0.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ThinRodWithMassAboutEnd() to calculate M_BBp_B, B’s spatial
inertia about Bp (one of the ends of rod B).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[AutoDiffXd].ThinRodWithMassAboutEnd(mass:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">length:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">unit_vector:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform-density thin rod B about one
of its ends.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>mass of the rod (units of kg).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">length</span></code>:</dt><dd><p>length of the rod (units of meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">unit_vector</span></code>:</dt><dd><p>unit vector defining the rod’s axial direction, expressed in B.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBp_B</span></code>:</dt><dd><p>B’s spatial inertia about Bp, expressed in B.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The position from Bp to Bcm is length / 2 * unit_vector.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s rotational inertia about Bp is axially symmetric, meaning B
has an equal moment of inertia about any line that both passes
through Bp and is perpendicular to unit_vector. B has no (zero)
rotational inertia about the line that passes through Bp and is
parallel to unit_vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if mass</strong><strong> or </strong><strong>length is not positive and finite</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>‖unit_vector‖ is not within 1.0E-14</strong><strong> of </strong><strong>1.0.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ThinRodWithMass() to calculate M_BBcm_B, B’s spatial inertia about
Bcm (B’s center of mass).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[AutoDiffXd].Zero()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Initializes mass, center of mass and rotational inertia to zero.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[Expression]</span></span></dt>
<dd><p>This class represents the physical concept of a <em>Spatial Inertia</em>. A
spatial inertia (or spatial mass matrix) encapsulates the mass, center
of mass, and rotational inertia of the mass distribution of a body or
composite body S, where with “composite body” we mean a collection of
bodies welded together containing at least one body (throughout this
documentation “body” is many times used instead of “composite body”
but the same concepts apply to a collection of bodies as well.) A
spatial inertia is an element of ℝ⁶ˣ⁶ that is symmetric, and positive
semi-definite. It logically consists of <code class="docutils literal notranslate"><span class="pre">3x3</span></code> sub-matrices arranged
like so, [Jain 2010]:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Spatial</span><span class="w"> </span><span class="n">mass</span><span class="w"> </span><span class="n">matrix</span>
<span class="w">          </span><span class="o">------------</span><span class="w"> </span><span class="o">------------</span>
<span class="w">       </span><span class="mi">0</span><span class="w"> </span><span class="o">|</span><span class="w">            </span><span class="o">|</span><span class="w">            </span><span class="o">|</span>
<span class="w">       </span><span class="mi">1</span><span class="w"> </span><span class="o">|</span><span class="w">    </span><span class="n">I_SP</span><span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">p_PScm</span><span class="err">×</span><span class="w">  </span><span class="o">|</span>
<span class="w">       </span><span class="mi">2</span><span class="w"> </span><span class="o">|</span><span class="w">            </span><span class="o">|</span><span class="w">            </span><span class="o">|</span>
<span class="w">          </span><span class="o">------------</span><span class="w"> </span><span class="o">------------</span>
<span class="w">       </span><span class="mi">3</span><span class="w"> </span><span class="o">|</span><span class="w">            </span><span class="o">|</span><span class="w">            </span><span class="o">|</span>
<span class="w">       </span><span class="mi">4</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">-</span><span class="n">m</span><span class="w"> </span><span class="n">p_PScm</span><span class="err">×</span><span class="w"> </span><span class="o">|</span><span class="w">     </span><span class="n">m</span><span class="w"> </span><span class="n">Id</span><span class="w">   </span><span class="o">|</span>
<span class="w">       </span><span class="mi">5</span><span class="w"> </span><span class="o">|</span><span class="w">            </span><span class="o">|</span><span class="w">            </span><span class="o">|</span>
<span class="w">          </span><span class="o">------------</span><span class="w"> </span><span class="o">------------</span>
<span class="w">               </span><span class="nl">Symbol</span><span class="p">:</span><span class="w"> </span><span class="n">M</span>
</pre></div>
</div>
</details><p>where, with the monogram notation described in
multibody_spatial_inertia, <code class="docutils literal notranslate"><span class="pre">I_SP</span></code> is the rotational inertia of body
or composite body S computed about a point P, m is the mass of this
composite body, <code class="docutils literal notranslate"><span class="pre">p_PScm</span></code> is the position vector from point P to the
center of mass <code class="docutils literal notranslate"><span class="pre">Scm</span></code> of the composite body S with <code class="docutils literal notranslate"><span class="pre">p_PScm×</span></code>
denoting its skew-symmetric cross product matrix (defined such that
<code class="docutils literal notranslate"><span class="pre">a×</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">a.cross(b)</span></code>), and <code class="docutils literal notranslate"><span class="pre">Id</span></code> is the identity matrix in ℝ³ˣ³. See
Section 2.1, p. 17 of [Jain 2010]. The logical arrangement as shown
above is chosen to be consistent with our logical arrangement for
spatial vectors as documented in multibody_spatial_algebra for which
the rotational component comes first followed by the translational
component.</p>
<p>In typeset material we use the symbol <span class="math notranslate nohighlight">\([M^{S/P}]_E\)</span> to represent
the spatial inertia of a body or composite body S about point P,
expressed in frame E. For this inertia, the monogram notation reads
<code class="docutils literal notranslate"><span class="pre">M_SP_E</span></code>. If the point P is fixed to a body B, we write that point
as <span class="math notranslate nohighlight">\(B_P\)</span> which appears in code and comments as <code class="docutils literal notranslate"><span class="pre">Bp</span></code>. So if the
body or composite body is B and the about point is <code class="docutils literal notranslate"><span class="pre">Bp</span></code>, the
monogram notation reads <code class="docutils literal notranslate"><span class="pre">M_BBp_E</span></code>, which can be abbreviated to
<code class="docutils literal notranslate"><span class="pre">M_Bp_E</span></code> since the about point <code class="docutils literal notranslate"><span class="pre">Bp</span></code> also identifies the body.
Common cases are that the about point is the origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code> of the
body, or it’s the center of mass <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> for which the rotational
inertia in monogram notation would read as <code class="docutils literal notranslate"><span class="pre">I_Bo_E</span></code> and <code class="docutils literal notranslate"><span class="pre">I_Bcm_E</span></code>,
respectively. Given <code class="docutils literal notranslate"><span class="pre">M_BP_E</span></code> (<span class="math notranslate nohighlight">\([M^{B/P}]_E\)</span>), the rotational
inertia of this spatial inertia is <code class="docutils literal notranslate"><span class="pre">I_BP_E</span></code> (<span class="math notranslate nohighlight">\([I^{B/P}]_E\)</span>)
and the position vector of the center of mass measured from point P
and expressed in E is <code class="docutils literal notranslate"><span class="pre">p_PBcm_E</span></code> (<span class="math notranslate nohighlight">\([^Pp^{B_{cm}}]_E\)</span>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class does not implement any mechanism to track the frame E
in which a spatial inertia is expressed or about what point is
computed. Methods and operators on this class have no means to
determine frame consistency through operations. It is therefore
the responsibility of users of this class to keep track of frames
in which operations are performed. We suggest doing that using
disciplined notation, as described above.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Several methods in this class throw a RuntimeError for invalid
rotational inertia operations in debug releases only. This
provides speed in a release build while facilitating debugging in
debug builds. In addition, these validity tests are only performed
for scalar types for which drake::scalar_predicate&lt;T&gt;::is_bool is
<code class="docutils literal notranslate"><span class="pre">True</span></code>. For instance, validity checks are not performed when T
is symbolic::Expression.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The methods of this class satisfy the “basic exception guarantee”:
if an exception is thrown, the program will still be in a valid
state. Specifically, no resources are leaked, and all objects’
invariants are intact. Be aware that SpatialInertia objects may
contain invalid inertia data in cases where input checking is
skipped.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://en.cppreference.com/w/cpp/language/exceptions">https://en.cppreference.com/w/cpp/language/exceptions</a></p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>To create a spatial inertia of a mesh, see
CalcSpatialInertia(const geometry::TriangleSurfaceMesh&lt;double&gt;&amp;
mesh, double density).</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>To create spatial inertia from most of geometry::Shape, see
CalcSpatialInertia(const geometry::Shape&amp; shape, double density).</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>To create spatial inertia for a set of bodies, see
MultibodyPlant::CalcSpatialInertia().</p>
</div>
<ul class="simple">
<li><dl class="simple">
<dt>[Jain 2010]  Jain, A., 2010. Robot and multibody dynamics: analysis and</dt><dd><p>algorithms. Springer Science &amp; Business Media.</p>
</dd>
</dl>
</li>
</ul>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[Expression].__init__(self:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[Expression],</span> <span class="pre">mass:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">p_PScm_E:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]],</span> <span class="pre">G_SP_E:</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[Expression],</span> <span class="pre">skip_validity_check:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">False)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructs a spatial inertia for a physical body or composite body S
about a point P from a given mass, center of mass and rotational
inertia. The center of mass is specified by the position vector
<code class="docutils literal notranslate"><span class="pre">p_PScm_E</span></code> from point P to the center of mass point <code class="docutils literal notranslate"><span class="pre">Scm</span></code>,
expressed in a frame E. The rotational inertia is provided as the
UnitInertia <code class="docutils literal notranslate"><span class="pre">G_SP_E</span></code> of the body or composite body S computed about
point P and expressed in frame E.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The third argument of this constructor is unusual in that it is an
UnitInertia (not a traditional RotationalInertia) and its inertia
is about the arbitrary point P (not Scm – S’s center of mass).</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>MakeFromCentralInertia a factory method with traditional utility.</p>
</div>
<p>This constructor checks for the physical validity of the resulting
SpatialInertia with IsPhysicallyValid() and throws a RuntimeError
exception in the event the provided input parameters lead to
non-physically viable spatial inertia. Since this check has
non-negligable runtime costs, it can be disabled by setting the
optional argument <code class="docutils literal notranslate"><span class="pre">skip_validity_check</span></code> to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>The mass of the body or composite body S.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PScm_E</span></code>:</dt><dd><p>The position vector from point P to the center of mass of body or
composite body S expressed in frame E.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">G_SP_E</span></code>:</dt><dd><p>UnitInertia of the body or composite body S computed about origin
point P and expressed in frame E.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">skip_validity_check</span></code>:</dt><dd><p>If true, skips the validity check described above. Defaults to
false.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[Expression].CalcComMoment(self:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Computes the center of mass moment vector <code class="docutils literal notranslate"><span class="pre">mass</span> <span class="pre">*</span> <span class="pre">p_PScm_E</span></code> given
the position vector <code class="docutils literal notranslate"><span class="pre">p_PScm_E</span></code> from the <em>about point</em> P to the
center of mass <code class="docutils literal notranslate"><span class="pre">Scm</span></code> of the body or composite body S, expressed in
frame E. See the documentation of this class for details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[Expression].CalcPrincipalSemiDiametersAndPoseForSolidEllipsoid(self:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">tuple[numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]],</span> <span class="pre">pydrake.math.RigidTransform]</span></span></dt>
<dd><p>Returns 3 principal semi-diameters [lmax lmed lmin] sorted in
descending order (lmax ≥ lmed ≥ lmin), orientation, and position of a
solid ellipsoid whose spatial inertia is equal to <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial
inertia. See spatial_inertia_equivalent_shapes “Spatial inertia
equivalent shapes” for more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if the elements</strong><strong> of </strong><strong>this spatial inertia cannot be</strong> – </p></li>
<li><p><strong>converted to a real finite double. For example</strong><strong>, </strong><strong>an exception is</strong> – </p></li>
<li><p><strong>thrown if this contains an erroneous NaN</strong><strong> or </strong><strong>if scalar type T</strong> – </p></li>
<li><p><strong>is symbolic.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[Expression].CalcRotationalInertia(self:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[Expression]</span></span></dt>
<dd><p>Computes the rotational inertia <code class="docutils literal notranslate"><span class="pre">I_SP_E</span> <span class="pre">=</span> <span class="pre">mass</span> <span class="pre">*</span> <span class="pre">G_SP_E</span></code> of this
spatial inertia, computed about point P and expressed in frame E. See
the documentation of this class for details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[Expression].CopyToFullMatrix6(self:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[6,</span> <span class="pre">6]]</span></span></dt>
<dd><p>Copy to a full 6x6 matrix representation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[Expression].get_com(self:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Get a constant reference to the position vector <code class="docutils literal notranslate"><span class="pre">p_PScm_E</span></code> from the
<em>about point</em> P to the center of mass <code class="docutils literal notranslate"><span class="pre">Scm</span></code> of the body or composite
body S, expressed in frame E. See the documentation of this class for
details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[Expression].get_mass(self:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Expression</span></span></dt>
<dd><p>Get a constant reference to the mass of this spatial inertia.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[Expression].get_unit_inertia(self:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[Expression]</span></span></dt>
<dd><p>Get a constant reference to the unit inertia <code class="docutils literal notranslate"><span class="pre">G_SP_E</span></code> of this
spatial inertia, computed about point P and expressed in frame E. See
the documentation of this class for details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[Expression].HollowSphereWithDensity(area_density:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">radius:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[Expression]</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform density thin hollow sphere B
about its geometric center Bo (which is coincident with B’s center of
mass Bcm).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">area_density</span></code>:</dt><dd><p>mass per unit area (kg/m²).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">radius</span></code>:</dt><dd><p>sphere’s radius in meters (the hollow sphere is regarded as an
infinitesimally thin shell of uniform density).</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>B’s spatial inertia about Bo, expressed in B. Since B’s rotational
inertia is triaxially symmetric, M_BBo_B = M_BBo_E, i.e., M_BBo
expressed in frame B is equal to M_BBo expressed in an arbitrary
frame E.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s rotational inertia about Bo is triaxially symmetric, meaning B
has an equal moment of inertia about any line passing through Bo.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if area_density</strong><strong> or </strong><strong>radius is not positive and finite.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[Expression].HollowSphereWithMass(mass:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">radius:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[Expression]</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform density hollow sphere B about
its geometric center Bo (which is coincident with B’s center of mass
Bcm).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>mass of the hollow sphere (kg).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">radius</span></code>:</dt><dd><p>sphere’s radius in meters (the hollow sphere is regarded as an
infinitesimally thin shell of uniform density).</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo</span></code>:</dt><dd><p>B’s spatial inertia about Bo. Since B’s rotational inertia is
triaxially symmetric, M_BBo_B = M_BBo_E, i.e., M_BBo expressed in
frame B is equal to M_BBo expressed in an arbitrary frame E.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s rotational inertia about Bo is triaxially symmetric, meaning B
has an equal moment of inertia about any line passing through Bo.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if mass</strong><strong> or </strong><strong>radius is not positive and finite.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[Expression].IsNaN(self:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Formula</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if any of the elements in this spatial inertia is NaN
and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[Expression].IsPhysicallyValid(self:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Formula</span></span></dt>
<dd><p>Performs a number of checks to verify that this is a physically valid
spatial inertia. The checks performed include:</p>
<ul class="simple">
<li><p>No NaN entries.</p></li>
<li><p>Non-negative mass.</p></li>
<li><p>Non-negative principal moments about the center of mass.</p></li>
<li><p>Principal moments about the center of mass must satisfy the triangle
inequality:
- <code class="docutils literal notranslate"><span class="pre">Ixx</span> <span class="pre">+</span> <span class="pre">Iyy</span> <span class="pre">&gt;=</span> <span class="pre">Izz</span></code>
- <cite>Ixx + Izz &gt;= Iyy</cite>
- <code class="docutils literal notranslate"><span class="pre">Iyy</span> <span class="pre">+</span> <span class="pre">Izz</span> <span class="pre">&gt;=</span> <span class="pre">Ixx</span></code></p></li>
</ul>
<p>These are the tests performed by
RotationalInertia::CouldBePhysicallyValid() which become a sufficient
condition when performed on a rotational inertia about a body’s center
of mass.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>RotationalInertia::CouldBePhysicallyValid().</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[Expression].IsZero(self:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.symbolic.Formula</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if all of the elements in this spatial inertia are
zero and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[Expression].MakeFromCentralInertia(mass:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">p_PScm_E:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]],</span> <span class="pre">I_SScm_E:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[Expression]</span></span></dt>
<dd><p>Creates a spatial inertia for a physical body or composite body S
about a point P from a given mass, center of mass, and central
rotational inertia. For example, this method creates a body’s
SpatialInertia about its body origin Bo from the body’s mass, position
vector from Bo to the body’s center of mass, and rotational inertia
about the body’s center of mass.</p>
<p>This method checks for the physical validity of the resulting
SpatialInertia with IsPhysicallyValid() and throws a RuntimeError
exception in the event the provided input parameters lead to a
non-physically viable spatial inertia.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>The mass of the body or composite body S.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PScm_E</span></code>:</dt><dd><p>The position vector from point P to point <code class="docutils literal notranslate"><span class="pre">Scm</span></code> (S’s center of
mass), expressed in a frame E.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">I_SScm_E</span></code>:</dt><dd><p>S’s RotationalInertia about Scm, expressed in frame E.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_SP_E</span></code>:</dt><dd><p>S’s spatial inertia about point P, expressed in frame E.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[Expression].NaN()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[Expression]</span></span></dt>
<dd><p>Initializes mass, center of mass and rotational inertia to invalid
NaN’s for a quick detection of uninitialized values.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[Expression].ReExpress(self:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[Expression],</span> <span class="pre">R_AE:</span> <span class="pre">pydrake.math.RotationMatrix_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[Expression]</span></span></dt>
<dd><p>Given <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial inertia <code class="docutils literal notranslate"><span class="pre">M_SP_E</span></code> for some body or composite
body S, taken about a point P and expressed in frame E, this method
computes the same inertia re-expressed in another frame A.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_AE</span></code>:</dt><dd><p>RotationMatrix relating frames A and E.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_SP_A</span></code>:</dt><dd><p>The same spatial inertia of S about P but now re-expressed in
frame A.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ReExpressInPlace() for details.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[Expression].SetNaN(self:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial inertia to have NaN entries. Typically used for
quick detection of uninitialized values.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[Expression].Shift(self:</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[Expression],</span> <span class="pre">p_PQ_E:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[Expression]</span></span></dt>
<dd><p>Given <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial inertia <code class="docutils literal notranslate"><span class="pre">M_SP_E</span></code> for some body or composite
body S, computed about point P, and expressed in frame E, this method
uses the <em>Parallel Axis Theorem</em> for spatial inertias to compute the
same spatial inertia about a new point Q. The result still is
expressed in frame E.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ShiftInPlace() for more details.</p>
</div>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PQ_E</span></code>:</dt><dd><p>Vector from the original about point P to the new about point Q,
expressed in the same frame E <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial inertia is
expressed in.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_SQ_E</span></code>:</dt><dd><p>This same spatial inertia for body or composite body S but
computed about a new point Q.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[Expression].SolidBoxWithDensity(density:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">lx:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">ly:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">lz:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[Expression]</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform density solid box B about its
geometric center Bo (which is coincident with B’s center of mass Bcm).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">density</span></code>:</dt><dd><p>mass per volume (kg/m³).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lx</span></code>:</dt><dd><p>length of the box in the Bx direction (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">ly</span></code>:</dt><dd><p>length of the box in the By direction (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lz</span></code>:</dt><dd><p>length of the box in the Bz direction (meters).</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>B’s spatial inertia about Bo, expressed in B.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if density</strong><strong>, </strong><strong>lx</strong><strong>, </strong><strong>ly</strong><strong>, or </strong><strong>lz is not positive and finite.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[Expression].SolidBoxWithMass(mass:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">lx:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">ly:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">lz:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[Expression]</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform density solid box B about its
geometric center Bo (which is coincident with B’s center of mass Bcm).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>mass of the solid box (kg).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lx</span></code>:</dt><dd><p>length of the box in the Bx direction (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">ly</span></code>:</dt><dd><p>length of the box in the By direction (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">lz</span></code>:</dt><dd><p>length of the box in the Bz direction (meters).</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>B’s spatial inertia about Bo, expressed in B.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if mass</strong><strong>, </strong><strong>lx</strong><strong>, </strong><strong>ly</strong><strong>, or </strong><strong>lz is not positive and finite.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[Expression].SolidCapsuleWithDensity(density:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">radius:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">length:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">unit_vector:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[Expression]</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform density solid capsule B about
its geometric center Bo (which is coincident with B’s center of mass
Bcm).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">density</span></code>:</dt><dd><p>mass per volume (kg/m³).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">radius</span></code>:</dt><dd><p>radius of the cylinder/half-sphere parts of the capsule.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">length</span></code>:</dt><dd><p>length of the cylindrical part of the capsule.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">unit_vector</span></code>:</dt><dd><p>unit vector defining the axial direction of the cylindrical part
of the capsule, expressed in B.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>B’s spatial inertia about Bo, expressed in B.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s rotational inertia about Bo is axially symmetric, meaning B
has an equal moment of inertia about any line that both passes
through Bo and is perpendicular to unit_vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if density</strong><strong>, </strong><strong>radius</strong><strong>, or </strong><strong>length is not positive and</strong> – </p></li>
<li><p><strong>finite</strong><strong> or </strong><strong>if ‖unit_vector‖ is not within 1.0E-14</strong><strong> of </strong><strong>1.0.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[Expression].SolidCapsuleWithMass(mass:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">radius:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">length:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">unit_vector:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[Expression]</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform density solid capsule B about
its geometric center Bo (which is coincident with B’s center of mass
Bcm).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>mass of the solid capsule (kg).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">radius</span></code>:</dt><dd><p>radius of the cylinder/half-sphere parts of the capsule.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">length</span></code>:</dt><dd><p>length of the cylindrical part of the capsule.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">unit_vector</span></code>:</dt><dd><p>unit vector defining the axial direction of the cylindrical part
of the capsule, expressed in B.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>B’s spatial inertia about Bo, expressed in B.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s rotational inertia about Bo is axially symmetric, meaning B
has an equal moment of inertia about any line that both passes
through Bo and is perpendicular to unit_vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if mass</strong><strong>, </strong><strong>radius</strong><strong>, or </strong><strong>length is not positive and finite</strong> – </p></li>
<li><p><strong>or if ‖unit_vector‖ is not within 1.0E-14</strong><strong> of </strong><strong>1.0.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[Expression].SolidCubeWithDensity(density:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">length:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[Expression]</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform density solid cube B about its
geometric center Bo (which is coincident with B’s center of mass Bcm).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">density</span></code>:</dt><dd><p>mass per volume (kg/m³).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">length</span></code>:</dt><dd><p>The length of each of the cube’s sides (meters).</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>B’s spatial inertia about Bo, expressed in B. Since B’s rotational
inertia is triaxially symmetric, M_BBo_B = M_BBo_E, i.e., M_BBo
expressed in frame B is equal to M_BBo expressed in an arbitrary
frame E.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s rotational inertia about Bo is triaxially symmetric, meaning B
has an equal moment of inertia about any line passing through Bo.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if density</strong><strong> or </strong><strong>length is not positive and finite.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[Expression].SolidCylinderWithDensity(density:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">radius:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">length:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">unit_vector:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[Expression]</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform density solid cylinder B about
its geometric center Bo (which is coincident with B’s center of mass
Bcm).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">density</span></code>:</dt><dd><p>mass per volume (kg/m³).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">radius</span></code>:</dt><dd><p>radius of the cylinder (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">length</span></code>:</dt><dd><p>length of cylinder in unit_vector direction (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">unit_vector</span></code>:</dt><dd><p>unit vector defining the axial direction of the cylinder,
expressed in B.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>B’s spatial inertia about Bo, expressed in B.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s rotational inertia about Bo is axially symmetric, meaning B
has an equal moment of inertia about any line that both passes
through Bo and is perpendicular to unit_vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if density</strong><strong>, </strong><strong>radius</strong><strong>, or </strong><strong>length is not positive and</strong> – </p></li>
<li><p><strong>finite</strong><strong> or </strong><strong>if ‖unit_vector‖ is not within 1.0E-14</strong><strong> of </strong><strong>1.0.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SolidCylinderWithDensityAboutEnd() to calculate M_BBp_B, B’s
spatial inertia about Bp (at the center of one of the cylinder’s
circular ends).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[Expression].SolidCylinderWithDensityAboutEnd(density:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">radius:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">length:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">unit_vector:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[Expression]</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform-density solid cylinder B about
an end-point Bp of the cylinder’s axis (see below for more about Bp).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">density</span></code>:</dt><dd><p>mass per volume (kg/m³).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">radius</span></code>:</dt><dd><p>radius of cylinder (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">length</span></code>:</dt><dd><p>length of cylinder in unit_vector direction (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">unit_vector</span></code>:</dt><dd><p>unit vector parallel to the axis of the cylinder and directed from
Bp to Bcm (B’s center of mass), expressed in B.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBp_B</span></code>:</dt><dd><p>B’s spatial inertia about Bp, expressed in B.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The position from Bp to Bcm is p_BpBcm = length / 2 * unit_vector.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s rotational inertia about Bp is axially symmetric, meaning B
has an equal moment of inertia about any line that both passes
through Bp and is perpendicular to unit_vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if density</strong><strong>, </strong><strong>radius</strong><strong>, or </strong><strong>length is not positive and</strong> – </p></li>
<li><p><strong>finite</strong><strong> or </strong><strong>if ‖unit_vector‖ is not within 1.0E-14</strong><strong> of </strong><strong>1.0.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SolidCylinderWithDensity() to calculate M_BBcm_B, B’s spatial
inertia about Bcm (B’s center of mass).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[Expression].SolidCylinderWithMass(mass:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">radius:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">length:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">unit_vector:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[Expression]</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform density solid cylinder B about
its geometric center Bo (which is coincident with B’s center of mass
Bcm).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>mass of the solid cylinder (kg).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">radius</span></code>:</dt><dd><p>radius of the cylinder (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">length</span></code>:</dt><dd><p>length of cylinder in unit_vector direction (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">unit_vector</span></code>:</dt><dd><p>unit vector defining the axial direction of the cylinder,
expressed in B.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>B’s spatial inertia about Bo, expressed in B.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s rotational inertia about Bo is axially symmetric, meaning B
has an equal moment of inertia about any line that both passes
through Bo and is perpendicular to unit_vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if mass</strong><strong>, </strong><strong>radius</strong><strong>, or </strong><strong>length is not positive and finite</strong> – </p></li>
<li><p><strong>or if ‖unit_vector‖ is not within 1.0E-14</strong><strong> of </strong><strong>1.0.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SolidCylinderWithMassAboutEnd() to calculate M_BBp_B, B’s spatial
inertia about Bp (at the center of one of the cylinder’s circular
ends).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[Expression].SolidCylinderWithMassAboutEnd(mass:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">radius:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">length:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">unit_vector:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[Expression]</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform-density solid cylinder B about
an end-point Bp of the cylinder’s axis (see below for more about Bp).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>mass of the solid cylinder (kg).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">radius</span></code>:</dt><dd><p>radius of cylinder (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">length</span></code>:</dt><dd><p>length of cylinder in unit_vector direction (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">unit_vector</span></code>:</dt><dd><p>unit vector parallel to the axis of the cylinder and directed from
Bp to Bcm (B’s center of mass), expressed in B.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBp_B</span></code>:</dt><dd><p>B’s spatial inertia about Bp, expressed in B.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The position from Bp to Bcm is p_BpBcm = length / 2 * unit_vector.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s rotational inertia about Bp is axially symmetric, meaning B
has an equal moment of inertia about any line that both passes
through Bp and is perpendicular to unit_vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if density</strong><strong>, </strong><strong>radius</strong><strong>, or </strong><strong>length is not positive and</strong> – </p></li>
<li><p><strong>finite</strong><strong> or </strong><strong>if ‖unit_vector‖ is not within 1.0E-14</strong><strong> of </strong><strong>1.0.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SolidCylinderWithMass() to calculate M_BBcm_B, B’s spatial inertia
about Bcm (B’s center of mass).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[Expression].SolidEllipsoidWithDensity(density:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">a:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">b:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">c:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[Expression]</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform density solid ellipsoid B
about its geometric center Bo (which is coincident with B’s center of
mass Bcm).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">density</span></code>:</dt><dd><p>mass per volume (kg/m³).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">a</span></code>:</dt><dd><p>length of ellipsoid semi-axis in the ellipsoid Bx direction.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>:</dt><dd><p>length of ellipsoid semi-axis in the ellipsoid By direction.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">c</span></code>:</dt><dd><p>length of ellipsoid semi-axis in the ellipsoid Bz direction.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>B’s spatial inertia about Bo, expressed in B.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if density</strong><strong>, </strong><strong>a</strong><strong>, </strong><strong>b</strong><strong>, or </strong><strong>c is not positive and finite.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[Expression].SolidEllipsoidWithMass(mass:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">a:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">b:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">c:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[Expression]</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform density solid ellipsoid B
about its geometric center Bo (which is coincident with B’s center of
mass Bcm).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>mass of the solid ellipsoid (kg).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">a</span></code>:</dt><dd><p>length of ellipsoid semi-axis in the ellipsoid Bx direction.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b</span></code>:</dt><dd><p>length of ellipsoid semi-axis in the ellipsoid By direction.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">c</span></code>:</dt><dd><p>length of ellipsoid semi-axis in the ellipsoid Bz direction.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt><dd><p>B’s spatial inertia about Bo, expressed in B.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if mass</strong><strong>, </strong><strong>a</strong><strong>, </strong><strong>b</strong><strong>, or </strong><strong>c is not positive and finite.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[Expression].SolidSphereWithDensity(density:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">radius:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[Expression]</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform density solid sphere B about
its geometric center Bo (which is coincident with B’s center of mass
Bcm).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">density</span></code>:</dt><dd><p>mass per volume (kg/m³).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">radius</span></code>:</dt><dd><p>sphere’s radius (meters).</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo</span></code>:</dt><dd><p>B’s spatial inertia about Bo. Since B’s rotational inertia is
triaxially symmetric, M_BBo_B = M_BBo_E, i.e., M_BBo expressed in
frame B is equal to M_BBo expressed in an arbitrary frame E.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s rotational inertia about Bo is triaxially symmetric, meaning B
has an equal moment of inertia about any line passing through Bo.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if density</strong><strong> or </strong><strong>radius is not positive and finite.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[Expression].SolidSphereWithMass(mass:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">radius:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[Expression]</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform density solid sphere B about
its geometric center Bo (which is coincident with B’s center of mass
Bcm).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>mass of the solid sphere (kg).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">radius</span></code>:</dt><dd><p>sphere’s radius (meters).</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo</span></code>:</dt><dd><p>B’s spatial inertia about Bo. Since B’s rotational inertia is
triaxially symmetric, M_BBo_B = M_BBo_E, i.e., M_BBo expressed in
frame B is equal to M_BBo expressed in an arbitrary frame E.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s rotational inertia about Bo is triaxially symmetric, meaning B
has an equal moment of inertia about any line passing through Bo.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if mass</strong><strong> or </strong><strong>radius is not positive and finite.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[Expression].ThinRodWithMass(mass:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">length:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">unit_vector:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[Expression]</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform-density thin rod B about its
center of mass Bcm.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>mass of the rod (units of kg).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">length</span></code>:</dt><dd><p>length of the rod (units of meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">unit_vector</span></code>:</dt><dd><p>unit vector defining the rod’s axial direction, expressed in B.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBcm_B</span></code>:</dt><dd><p>B’s spatial inertia about Bcm, expressed in B.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s rotational inertia about Bcm is axially symmetric, meaning B
has an equal moment of inertia about any line that both passes
through Bcm and is perpendicular to unit_vector. B has no (zero)
rotational inertia about the line that passes through Bcm and is
parallel to unit_vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if mass</strong><strong> or </strong><strong>length is not positive and finite</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>‖unit_vector‖ is not within 1.0E-14</strong><strong> of </strong><strong>1.0.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ThinRodWithMassAboutEnd() to calculate M_BBp_B, B’s spatial
inertia about Bp (one of the ends of rod B).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[Expression].ThinRodWithMassAboutEnd(mass:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">length:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">unit_vector:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[Expression]</span></span></dt>
<dd><p>Creates a spatial inertia for a uniform-density thin rod B about one
of its ends.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt><dd><p>mass of the rod (units of kg).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">length</span></code>:</dt><dd><p>length of the rod (units of meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">unit_vector</span></code>:</dt><dd><p>unit vector defining the rod’s axial direction, expressed in B.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBp_B</span></code>:</dt><dd><p>B’s spatial inertia about Bp, expressed in B.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The position from Bp to Bcm is length / 2 * unit_vector.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s rotational inertia about Bp is axially symmetric, meaning B
has an equal moment of inertia about any line that both passes
through Bp and is perpendicular to unit_vector. B has no (zero)
rotational inertia about the line that passes through Bp and is
parallel to unit_vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if mass</strong><strong> or </strong><strong>length is not positive and finite</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>‖unit_vector‖ is not within 1.0E-14</strong><strong> of </strong><strong>1.0.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ThinRodWithMass() to calculate M_BBcm_B, B’s spatial inertia about
Bcm (B’s center of mass).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">SpatialInertia_[Expression].Zero()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.SpatialInertia_[Expression]</span></span></dt>
<dd><p>Initializes mass, center of mass and rotational inertia to zero.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniformGravityFieldElement</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ForceElement</span></code></p>
<p>This ForceElement allows modeling the effect of a uniform gravity
field as felt by bodies on the surface of the Earth. This gravity
field acts on all bodies in the MultibodyTree model.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">UniformGravityFieldElement_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniformGravityFieldElement.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.tree.UniformGravityFieldElement) -&gt; None</p></li>
</ol>
<p>Constructs a uniform gravity field element with a default strength (on
the earth’s surface) and direction (-z).</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.tree.UniformGravityFieldElement, g_W: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs a uniform gravity field element with a strength given by
the acceleration of gravity vector <code class="docutils literal notranslate"><span class="pre">g_W</span></code>, expressed in the world
frame W.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniformGravityFieldElement.CalcGravityGeneralizedForces(self:</span> <span class="pre">pydrake.multibody.tree.UniformGravityFieldElement,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Computes the generalized forces <code class="docutils literal notranslate"><span class="pre">tau_g(q)</span></code> due to <code class="docutils literal notranslate"><span class="pre">this</span></code> gravity
field element as a function of the generalized positions <code class="docutils literal notranslate"><span class="pre">q</span></code> stored
in the input <code class="docutils literal notranslate"><span class="pre">context</span></code>, for the multibody model to which <code class="docutils literal notranslate"><span class="pre">this</span></code>
element belongs. <code class="docutils literal notranslate"><span class="pre">tau_g(q)</span></code> is defined such that it appears on the
right hand side of the equations of motion together with any other
generalized forces, like so:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Mv</span><span class="err">̇</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">C</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tau_g</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tau_app</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">tau_app</span></code> includes any other generalized forces applied on the
system.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state of the multibody model to which this
element belongs.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>tau_g A vector containing the generalized forces due to this
gravity field force element. The generalized forces are consistent
with the vector of generalized velocities <code class="docutils literal notranslate"><span class="pre">v</span></code> for the parent
MultibodyTree model so that the inner product <code class="docutils literal notranslate"><span class="pre">v⋅tau_g</span></code>
corresponds to the power applied by the gravity forces on the
mechanical system. That is, <code class="docutils literal notranslate"><span class="pre">v⋅tau_g</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> corresponds to
potential energy going into the system, as either mechanical
kinetic energy, some other potential energy, or heat, and
therefore to a decrease of potential energy.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniformGravityFieldElement.gravity_vector(self:</span> <span class="pre">pydrake.multibody.tree.UniformGravityFieldElement)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the acceleration of the gravity vector in m/s², expressed in
the world frame W.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniformGravityFieldElement.is_enabled(self:</span> <span class="pre">pydrake.multibody.tree.UniformGravityFieldElement,</span> <span class="pre">model_instance:</span> <span class="pre">pydrake.multibody.tree.ModelInstanceIndex)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> iff gravity is enabled for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>enable(), disable().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the model instance is invalid.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniformGravityFieldElement.kDefaultStrength</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniformGravityFieldElement.set_enabled(self:</span> <span class="pre">pydrake.multibody.tree.UniformGravityFieldElement,</span> <span class="pre">model_instance:</span> <span class="pre">pydrake.multibody.tree.ModelInstanceIndex,</span> <span class="pre">is_enabled:</span> <span class="pre">bool)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets is_enabled() for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> to <code class="docutils literal notranslate"><span class="pre">is_enabled</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>if the parent model is finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if the model instance is invalid.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniformGravityFieldElement.set_gravity_vector(self:</span> <span class="pre">pydrake.multibody.tree.UniformGravityFieldElement,</span> <span class="pre">arg0:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the acceleration of gravity vector, expressed in the world frame
W in m/s².</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniformGravityFieldElement_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">UniformGravityFieldElement_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">UniformGravityFieldElement_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">UniformGravityFieldElement_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniformGravityFieldElement_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ForceElement_[AutoDiffXd]</span></code></p>
<p>This ForceElement allows modeling the effect of a uniform gravity
field as felt by bodies on the surface of the Earth. This gravity
field acts on all bodies in the MultibodyTree model.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniformGravityFieldElement_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Constructs a uniform gravity field element with a default strength (on
the earth’s surface) and direction (-z).</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd], g_W: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs a uniform gravity field element with a strength given by
the acceleration of gravity vector <code class="docutils literal notranslate"><span class="pre">g_W</span></code>, expressed in the world
frame W.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniformGravityFieldElement_[AutoDiffXd].CalcGravityGeneralizedForces(self:</span> <span class="pre">pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Computes the generalized forces <code class="docutils literal notranslate"><span class="pre">tau_g(q)</span></code> due to <code class="docutils literal notranslate"><span class="pre">this</span></code> gravity
field element as a function of the generalized positions <code class="docutils literal notranslate"><span class="pre">q</span></code> stored
in the input <code class="docutils literal notranslate"><span class="pre">context</span></code>, for the multibody model to which <code class="docutils literal notranslate"><span class="pre">this</span></code>
element belongs. <code class="docutils literal notranslate"><span class="pre">tau_g(q)</span></code> is defined such that it appears on the
right hand side of the equations of motion together with any other
generalized forces, like so:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Mv</span><span class="err">̇</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">C</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tau_g</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tau_app</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">tau_app</span></code> includes any other generalized forces applied on the
system.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state of the multibody model to which this
element belongs.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>tau_g A vector containing the generalized forces due to this
gravity field force element. The generalized forces are consistent
with the vector of generalized velocities <code class="docutils literal notranslate"><span class="pre">v</span></code> for the parent
MultibodyTree model so that the inner product <code class="docutils literal notranslate"><span class="pre">v⋅tau_g</span></code>
corresponds to the power applied by the gravity forces on the
mechanical system. That is, <code class="docutils literal notranslate"><span class="pre">v⋅tau_g</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> corresponds to
potential energy going into the system, as either mechanical
kinetic energy, some other potential energy, or heat, and
therefore to a decrease of potential energy.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniformGravityFieldElement_[AutoDiffXd].gravity_vector(self:</span> <span class="pre">pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the acceleration of the gravity vector in m/s², expressed in
the world frame W.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniformGravityFieldElement_[AutoDiffXd].is_enabled(self:</span> <span class="pre">pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd],</span> <span class="pre">model_instance:</span> <span class="pre">pydrake.multibody.tree.ModelInstanceIndex)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> iff gravity is enabled for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>enable(), disable().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the model instance is invalid.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniformGravityFieldElement_[AutoDiffXd].kDefaultStrength</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniformGravityFieldElement_[AutoDiffXd].set_enabled(self:</span> <span class="pre">pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd],</span> <span class="pre">model_instance:</span> <span class="pre">pydrake.multibody.tree.ModelInstanceIndex,</span> <span class="pre">is_enabled:</span> <span class="pre">bool)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets is_enabled() for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> to <code class="docutils literal notranslate"><span class="pre">is_enabled</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>if the parent model is finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if the model instance is invalid.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniformGravityFieldElement_[AutoDiffXd].set_gravity_vector(self:</span> <span class="pre">pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd],</span> <span class="pre">arg0:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the acceleration of gravity vector, expressed in the world frame
W in m/s².</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniformGravityFieldElement_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ForceElement_[Expression]</span></code></p>
<p>This ForceElement allows modeling the effect of a uniform gravity
field as felt by bodies on the surface of the Earth. This gravity
field acts on all bodies in the MultibodyTree model.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniformGravityFieldElement_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.tree.UniformGravityFieldElement_[Expression]) -&gt; None</p></li>
</ol>
<p>Constructs a uniform gravity field element with a default strength (on
the earth’s surface) and direction (-z).</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.tree.UniformGravityFieldElement_[Expression], g_W: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</p></li>
</ol>
<p>Constructs a uniform gravity field element with a strength given by
the acceleration of gravity vector <code class="docutils literal notranslate"><span class="pre">g_W</span></code>, expressed in the world
frame W.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniformGravityFieldElement_[Expression].CalcGravityGeneralizedForces(self:</span> <span class="pre">pydrake.multibody.tree.UniformGravityFieldElement_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[m,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Computes the generalized forces <code class="docutils literal notranslate"><span class="pre">tau_g(q)</span></code> due to <code class="docutils literal notranslate"><span class="pre">this</span></code> gravity
field element as a function of the generalized positions <code class="docutils literal notranslate"><span class="pre">q</span></code> stored
in the input <code class="docutils literal notranslate"><span class="pre">context</span></code>, for the multibody model to which <code class="docutils literal notranslate"><span class="pre">this</span></code>
element belongs. <code class="docutils literal notranslate"><span class="pre">tau_g(q)</span></code> is defined such that it appears on the
right hand side of the equations of motion together with any other
generalized forces, like so:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">Mv</span><span class="err">̇</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">C</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tau_g</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">tau_app</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">tau_app</span></code> includes any other generalized forces applied on the
system.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context storing the state of the multibody model to which this
element belongs.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>tau_g A vector containing the generalized forces due to this
gravity field force element. The generalized forces are consistent
with the vector of generalized velocities <code class="docutils literal notranslate"><span class="pre">v</span></code> for the parent
MultibodyTree model so that the inner product <code class="docutils literal notranslate"><span class="pre">v⋅tau_g</span></code>
corresponds to the power applied by the gravity forces on the
mechanical system. That is, <code class="docutils literal notranslate"><span class="pre">v⋅tau_g</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> corresponds to
potential energy going into the system, as either mechanical
kinetic energy, some other potential energy, or heat, and
therefore to a decrease of potential energy.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniformGravityFieldElement_[Expression].gravity_vector(self:</span> <span class="pre">pydrake.multibody.tree.UniformGravityFieldElement_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Returns the acceleration of the gravity vector in m/s², expressed in
the world frame W.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniformGravityFieldElement_[Expression].is_enabled(self:</span> <span class="pre">pydrake.multibody.tree.UniformGravityFieldElement_[Expression],</span> <span class="pre">model_instance:</span> <span class="pre">pydrake.multibody.tree.ModelInstanceIndex)</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">True</span></code> iff gravity is enabled for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>enable(), disable().</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the model instance is invalid.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniformGravityFieldElement_[Expression].kDefaultStrength</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniformGravityFieldElement_[Expression].set_enabled(self:</span> <span class="pre">pydrake.multibody.tree.UniformGravityFieldElement_[Expression],</span> <span class="pre">model_instance:</span> <span class="pre">pydrake.multibody.tree.ModelInstanceIndex,</span> <span class="pre">is_enabled:</span> <span class="pre">bool)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets is_enabled() for <code class="docutils literal notranslate"><span class="pre">model_instance</span></code> to <code class="docutils literal notranslate"><span class="pre">is_enabled</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>if the parent model is finalized.</strong> – </p></li>
<li><p><strong>RuntimeError if the model instance is invalid.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniformGravityFieldElement_[Expression].set_gravity_vector(self:</span> <span class="pre">pydrake.multibody.tree.UniformGravityFieldElement_[Expression],</span> <span class="pre">arg0:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the acceleration of gravity vector, expressed in the world frame
W in m/s².</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.RotationalInertia</span></code></p>
<p>This class is used to represent rotational inertias for unit mass
bodies. Therefore, unlike RotationalInertia whose units are kg⋅m², the
units of a UnitInertia are those of length squared. A unit inertia is
a useful concept to represent the geometric distribution of mass in a
body regardless of the actual value of the body mass. The rotational
inertia of a body can therefore be obtained by multiplying its unit
inertia by its mass. Unit inertia matrices can also be called
<strong>gyration</strong> matrices and therefore we choose to represent them in
source code notation with the capital letter G. In contrast, the
capital letter I is used to represent non-unit mass rotational
inertias. This class restricts the set of allowed operations on a unit
inertia to ensure the unit-mass invariant. For instance,
multiplication by a scalar can only return a general RotationalInertia
but not a UnitInertia.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class has no means to check at construction from user
provided parameters whether it actually represents the unit
inertia or gyration matrix of a unit-mass body. However, as
previously noted, once a unit inertia is created, a number of
operations are disallowed to ensure the unit-mass invariant. Also
notice that once a unit inertia is created, it <em>is</em> the unit
inertia of <em>some</em> body, perhaps with scaled geometry from the
user’s intention.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The methods of this class satisfy the “basic exception guarantee”:
if an exception is thrown, the program will still be in a valid
state. Specifically, no resources are leaked, and all objects’
invariants are intact. Be aware that UnitInertia objects may
contain invalid inertia data in cases where input checking is
skipped.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://en.cppreference.com/w/cpp/language/exceptions">https://en.cppreference.com/w/cpp/language/exceptions</a></p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">UnitInertia_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia.__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.tree.UnitInertia) -&gt; None</p></li>
</ol>
<p>Default UnitInertia constructor sets all entries to NaN for quick
detection of uninitialized values.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.tree.UnitInertia, Ixx: float, Iyy: float, Izz: float) -&gt; None</p></li>
</ol>
<p>Creates a unit inertia with moments of inertia <code class="docutils literal notranslate"><span class="pre">Ixx</span></code>, <cite>Iyy</cite>,
<code class="docutils literal notranslate"><span class="pre">Izz</span></code>, and with each product of inertia set to zero. In debug
builds, throws RuntimeError if unit inertia constructed from these
arguments violates RotationalInertia::CouldBePhysicallyValid().</p>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.multibody.tree.UnitInertia, Ixx: float, Iyy: float, Izz: float, Ixy: float, Ixz: float, Iyz: float) -&gt; None</p></li>
</ol>
<p>Creates a unit inertia with moments of inertia <code class="docutils literal notranslate"><span class="pre">Ixx</span></code>, <cite>Iyy</cite>,
<code class="docutils literal notranslate"><span class="pre">Izz</span></code>, and with products of inertia <code class="docutils literal notranslate"><span class="pre">Ixy</span></code>, <cite>Ixz</cite>, <code class="docutils literal notranslate"><span class="pre">Iyz</span></code>. In
debug builds, throws RuntimeError if unit inertia constructed from
these arguments violates RotationalInertia::CouldBePhysicallyValid().</p>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.multibody.tree.UnitInertia, I: pydrake.multibody.tree.RotationalInertia) -&gt; None</p></li>
</ol>
<p>Constructs a UnitInertia from a RotationalInertia. This constructor
has no way to verify that the input rotational inertia actually is a
unit inertia. But the construction will nevertheless succeed, and the
values of the input rotational inertia will henceforth be considered a
valid unit inertia.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>The user is responsible for passing a valid rotational inertia.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia.AxiallySymmetric(moment_parallel:</span> <span class="pre">float,</span> <span class="pre">moment_perpendicular:</span> <span class="pre">float,</span> <span class="pre">unit_vector:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia</span></span></dt>
<dd><p>Returns the unit inertia for a body B for which there exists an axis L
passing through the body’s center of mass Bcm having the property that
B’s moment of inertia about all lines perpendicular to L are equal.
Bodies with this “axially symmetric inertia” property include
axisymmetric cylinders or cones and propellers with 3⁺ evenly spaced
blades. For a body B with axially symmetric inertia, B’s unit inertia
about a point Bp on axis L can be written in terms of a unit_vector
parallel to L; the parallel moment of inertia J about L; and the
perpendicular moment of inertia K about any line perpendicular to axis
L; as:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">G</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">K</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Identity</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">J</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">K</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">unit_vector</span><span class="w"> </span><span class="err">⊗</span><span class="w"> </span><span class="n">unit_vector</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">Identity</span></code> is the identity matrix and ⊗ denotes the tensor
product operator. See Mitiguy, P., 2016. Advanced Dynamics &amp; Motion
Simulation.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">moment_parallel</span></code>:</dt><dd><ol class="upperalpha simple" start="10">
<li><p>B’s unit moment of inertia about axis L.</p></li>
</ol>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">moment_perpendicular</span></code>:</dt><dd><p>(K) B’s unit moment of inertia about Bp for any line perpendicular
to unit_vector.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">unit_vector</span></code>:</dt><dd><p>unit vector parallel to axis L, expressed in a frame E.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_BBp_E</span></code>:</dt><dd><p>B’s unit inertia about point Bp on B’s symmetry axis, expressed in
the same frame E as the unit_vector is expressed.</p>
</dd>
<dt>Precondition:</dt><dd><p>Points Bp and Bcm are both on B’s symmetry axis. The actual
location of these points is not known by this function. However,
the value of moment_perpendicular (K) is associated with point Bp.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s unit inertia about Bp is axially symmetric, meaning B has an
equal moment of inertia about any line that both passes through Bp
and is perpendicular to unit_vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if moment_parallel</strong><strong> (</strong><strong>J</strong><strong>) or </strong><strong>moment_perpendicular</strong><strong> (</strong><strong>K</strong><strong>) </strong><strong>is</strong> – </p></li>
<li><p><strong>negative</strong><strong> or </strong><strong>if J &gt; 2 K</strong><strong> (</strong><strong>violates the triangle inequality</strong><strong>, </strong><strong>see</strong> – </p></li>
<li><p><strong>CouldBePhysicallyValid</strong><strong>(</strong><strong>)</strong><strong>) or </strong><strong>‖unit_vector‖ is not within 1.0E-14</strong> – </p></li>
<li><p><strong>of 1.0.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia.HollowSphere(r:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia</span></span></dt>
<dd><p>Computes the unit inertia for a unit-mass hollow sphere of radius
<code class="docutils literal notranslate"><span class="pre">r</span></code> consisting of an infinitesimally thin shell of uniform density.
The unit inertia is taken about the center of the sphere.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia.PointMass(p_FQ:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia</span></span></dt>
<dd><p>Construct a unit inertia for a point mass of unit mass located at
point Q, whose location in a frame F is given by the position vector
<code class="docutils literal notranslate"><span class="pre">p_FQ</span></code> (that is, p_FoQ_F). The unit inertia <code class="docutils literal notranslate"><span class="pre">G_QFo_F</span></code> of point
mass Q about the origin <code class="docutils literal notranslate"><span class="pre">Fo</span></code> of frame F and expressed in F for this
unit mass point equals the square of the cross product matrix of
<code class="docutils literal notranslate"><span class="pre">p_FQ</span></code>. In coordinate-free form:</p>
<div class="math notranslate nohighlight">
\[G^{Q/F_o} = (^Fp^Q_\times)^2 = (^Fp^Q_\times)^T \, ^Fp^Q_\times =
-^Fp^Q_\times \, ^Fp^Q_\times\]</div>
<p>where <span class="math notranslate nohighlight">\(^Fp^Q_\times\)</span> is the cross product matrix of vector
<span class="math notranslate nohighlight">\(^Fp^Q\)</span>. In source code the above expression is written as:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">G_QFo_F</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">px_FQ²</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">px_FQᵀ</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">px_FQ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">px_FQ</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">px_FQ</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">px_FQ</span></code> denotes the cross product matrix of the position
vector <code class="docutils literal notranslate"><span class="pre">p_FQ</span></code> (expressed in F) such that the cross product with
another vector <code class="docutils literal notranslate"><span class="pre">a</span></code> can be obtained as <code class="docutils literal notranslate"><span class="pre">px.cross(a)</span> <span class="pre">=</span> <span class="pre">px</span> <span class="pre">*</span> <span class="pre">a</span></code>. The
cross product matrix <code class="docutils literal notranslate"><span class="pre">px</span></code> is skew-symmetric. The square of the cross
product matrix is a symmetric matrix with non-negative diagonals and
obeys the triangle inequality. Matrix <code class="docutils literal notranslate"><span class="pre">px²</span></code> can be used to compute
the triple vector product as <code class="docutils literal notranslate"><span class="pre">-p</span> <span class="pre">x</span> <span class="pre">(p</span> <span class="pre">x</span> <span class="pre">a)</span> <span class="pre">=</span> <span class="pre">-p.cross(p.cross(a))</span> <span class="pre">=</span>
<span class="pre">px²</span> <span class="pre">*</span> <span class="pre">a</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia.ReExpress(self:</span> <span class="pre">pydrake.multibody.tree.UnitInertia,</span> <span class="pre">R_AE:</span> <span class="pre">pydrake.math.RotationMatrix)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia</span></span></dt>
<dd><p>Given <code class="docutils literal notranslate"><span class="pre">this</span></code> unit inertia <code class="docutils literal notranslate"><span class="pre">G_BP_E</span></code> of a body B about a point P and
expressed in frame E, this method computes the same unit inertia
re-expressed in another frame A as <code class="docutils literal notranslate"><span class="pre">G_BP_A</span> <span class="pre">=</span> <span class="pre">R_AE</span> <span class="pre">*</span> <span class="pre">G_BP_E</span> <span class="pre">*</span>
<span class="pre">(R_AE)ᵀ</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_AE</span></code>:</dt><dd><p>RotationMatrix relating frames A and E.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_BP_A</span></code>:</dt><dd><p>The same unit inertia for body B about point P but now
re-expressed in frame A.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia.SetFromRotationalInertia(self:</span> <span class="pre">pydrake.multibody.tree.UnitInertia,</span> <span class="pre">I:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia,</span> <span class="pre">mass:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia</span></span></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> unit inertia from a generally non-unit inertia I
corresponding to a body with a given <code class="docutils literal notranslate"><span class="pre">mass</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the provided mass is not strictly positive.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia.ShiftFromCenterOfMass(self:</span> <span class="pre">pydrake.multibody.tree.UnitInertia,</span> <span class="pre">p_BcmQ_E:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia</span></span></dt>
<dd><p>Shifts this central unit inertia to a different point, and returns the
result. See ShiftFromCenterOfMassInPlace() for details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BcmQ_E</span></code>:</dt><dd><p>A vector from the body’s centroid <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> to point Q expressed in
the same frame E in which <code class="docutils literal notranslate"><span class="pre">this</span></code> inertia is expressed.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_BQ_E</span></code>:</dt><dd><p>This same unit inertia taken about a point Q instead of the
centroid <code class="docutils literal notranslate"><span class="pre">Bcm</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia.ShiftToCenterOfMass(self:</span> <span class="pre">pydrake.multibody.tree.UnitInertia,</span> <span class="pre">p_QBcm_E:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia</span></span></dt>
<dd><p>For the unit inertia <code class="docutils literal notranslate"><span class="pre">G_BQ_E</span></code> of a body or composite body B computed
about a point Q and expressed in a frame E, this method shifts this
inertia using the parallel axis theorem to be computed about the
center of mass <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> of B. See ShiftToCenterOfMassInPlace() for
details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_QBcm_E</span></code>:</dt><dd><p>A position vector from the about point Q to the body’s centroid
<code class="docutils literal notranslate"><span class="pre">Bcm</span></code> expressed in the same frame E in which <code class="docutils literal notranslate"><span class="pre">this</span></code> inertia is
expressed.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_Bcm_E</span></code>:</dt><dd><p>This same unit which has now been taken about point <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> so
that it can be written as <code class="docutils literal notranslate"><span class="pre">G_BBcm_E</span></code>, or <code class="docutils literal notranslate"><span class="pre">G_Bcm_E</span></code>.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This operation could result in a non-physical rotational inertia.
Use with care. See ShiftToCenterOfMassInPlace() for details.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia.SolidBox(Lx:</span> <span class="pre">float,</span> <span class="pre">Ly:</span> <span class="pre">float,</span> <span class="pre">Lz:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia</span></span></dt>
<dd><p>Computes the unit inertia for a unit-mass solid box of uniform density
taken about its geometric center. If one length is zero the inertia
corresponds to that of a thin rectangular sheet. If two lengths are
zero the inertia corresponds to that of a thin rod in the remaining
direction.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Lx</span></code>:</dt><dd><p>The length of the box edge in the principal x-axis.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Ly</span></code>:</dt><dd><p>The length of the box edge in the principal y-axis.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Lz</span></code>:</dt><dd><p>The length of the box edge in the principal z-axis.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if any</strong><strong> of </strong><strong>Lx</strong><strong>, </strong><strong>Ly</strong><strong>, </strong><strong>Lz are negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia.SolidCapsule(radius:</span> <span class="pre">float,</span> <span class="pre">length:</span> <span class="pre">float,</span> <span class="pre">unit_vector:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia</span></span></dt>
<dd><p>Creates a unit inertia for a uniform density solid capsule B about its
center of mass Bcm (which is coincident with B’s geometric center Bo).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">radius</span></code>:</dt><dd><p>radius of the cylinder/half-sphere parts of the capsule.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">length</span></code>:</dt><dd><p>length of cylindrical part of the capsule.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">unit_vector</span></code>:</dt><dd><p>unit vector defining the axial direction of the cylindrical part
of the capsule, expressed in a frame E.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_BBcm_E</span></code>:</dt><dd><p>B’s unit inertia about Bcm expressed in the same frame E as the
unit_vector is expressed.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s unit inertia about Bcm is axially symmetric, meaning B has an
equal moment of inertia about any line that both passes through
Bcm and is perpendicular to unit_vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if radius</strong><strong> or </strong><strong>length is negative</strong><strong> or </strong><strong>if ‖unit_vector‖</strong> – </p></li>
<li><p><strong>is not within 1.0E-14</strong><strong> of </strong><strong>1.0.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia.SolidCube(L:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia</span></span></dt>
<dd><p>Computes the unit inertia for a unit-mass solid cube (a box with
equal-sized sides) of uniform density taken about its geometric
center.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">L</span></code>:</dt><dd><p>The length of each of the cube’s sides.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia.SolidCylinder(radius:</span> <span class="pre">float,</span> <span class="pre">length:</span> <span class="pre">float,</span> <span class="pre">unit_vector:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia</span></span></dt>
<dd><p>Creates a unit inertia for a uniform density solid cylinder B about
its center of mass Bcm (which is coincident with B’s geometric center
Bo).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">radius</span></code>:</dt><dd><p>radius of the cylinder (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">length</span></code>:</dt><dd><p>length of cylinder in unit_vector direction (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">unit_vector</span></code>:</dt><dd><p>unit vector defining the axial direction of the cylinder,
expressed in a frame E.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_BBcm_E</span></code>:</dt><dd><p>B’s unit inertia about Bcm expressed in the same frame E as the
unit_vector is expressed.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s unit inertia about Bcm is axially symmetric, meaning B has an
equal moment of inertia about any line that both passes through
Bcm and is perpendicular to unit_vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if radius</strong><strong> or </strong><strong>length is negative</strong><strong> or </strong><strong>if ‖unit_vector‖</strong> – </p></li>
<li><p><strong>is not within 1.0E-14</strong><strong> of </strong><strong>1.0.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SolidCylinderAboutEnd() to calculate G_BBp_E, B’s unit inertia
about point Bp (Bp is at the center of one of the cylinder’s
circular ends).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia.SolidCylinderAboutEnd(radius:</span> <span class="pre">float,</span> <span class="pre">length:</span> <span class="pre">float,</span> <span class="pre">unit_vector:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia</span></span></dt>
<dd><p>Creates a unit inertia for a uniform-density solid cylinder B about an
end-point Bp of the cylinder’s axis (see below for more about Bp).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">radius</span></code>:</dt><dd><p>radius of cylinder (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">length</span></code>:</dt><dd><p>length of cylinder in unit_vector direction (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">unit_vector</span></code>:</dt><dd><p>unit vector parallel to the axis of the cylinder and directed from
Bp to Bcm (B’s center of mass), expressed in a frame E.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_BBp_E</span></code>:</dt><dd><p>B’s unit inertia about Bp expressed in the same frame E as the
unit_vector is expressed.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The position from Bp to Bcm is p_BpBcm = length / 2 * unit_vector.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s unit inertia about Bp is axially symmetric, meaning B has an
equal moment of inertia about any line that both passes through Bp
and is perpendicular to unit_vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if radius</strong><strong> or </strong><strong>length is negative</strong><strong> or </strong><strong>if ‖unit_vector‖</strong> – </p></li>
<li><p><strong>is not within 1.0E-14</strong><strong> of </strong><strong>1.0.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia.SolidEllipsoid(a:</span> <span class="pre">float,</span> <span class="pre">b:</span> <span class="pre">float,</span> <span class="pre">c:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia</span></span></dt>
<dd><p>Computes the unit inertia for a unit-mass solid ellipsoid of uniform
density taken about its center. The lengths of the semi-axes of the
ellipsoid in the principal x,y,z-axes are <code class="docutils literal notranslate"><span class="pre">a</span></code>, <cite>b</cite>, and <code class="docutils literal notranslate"><span class="pre">c</span></code>
respectively.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia.SolidSphere(r:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia</span></span></dt>
<dd><p>Computes the unit inertia for a unit-mass solid sphere of uniform
density and radius <code class="docutils literal notranslate"><span class="pre">r</span></code> taken about its center.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia.StraightLine(moment_perpendicular:</span> <span class="pre">float,</span> <span class="pre">unit_vector:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia</span></span></dt>
<dd><p>Creates a unit inertia for a straight line segment B about a point Bp
on the line segment.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">moment_perpendicular</span></code>:</dt><dd><p>Unit moment of inertia about any axis that passes through Bp and
is perpendicular to the line segment.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">unit_vector</span></code>:</dt><dd><p>unit vector defining the line segment’s direction, expressed in a
frame E.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_BBp_E</span></code>:</dt><dd><p>B’s unit inertia about Bp, expressed in the same frame E that the
unit_vector is expressed.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s unit inertia about Bp is axially symmetric, meaning B has an
equal moment of inertia about any line that both passes through Bp
and is perpendicular to unit_vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if moment_perpendicular is not positive</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>‖unit_vector‖ is not within 1.0E-14</strong><strong> of </strong><strong>1.0.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s axial moment of inertia (along the line segment) is zero.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ThinRod() is an example of an object that is axially symmetric and
that has a zero moment of inertia about Bp in the unit_vector
direction.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia.ThinRod(length:</span> <span class="pre">float,</span> <span class="pre">unit_vector:</span> <span class="pre">numpy.ndarray[numpy.float64[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia</span></span></dt>
<dd><p>Creates a unit inertia for a uniform density thin rod B about its
center of mass Bcm (which is coincident with B’s geometric center Bo).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">length</span></code>:</dt><dd><p>length of rod in unit_vector direction (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">unit_vector</span></code>:</dt><dd><p>unit vector defining the rod’s axial direction, expressed in a
frame E.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_BBcm_E</span></code>:</dt><dd><p>B’s unit inertia about Bcm expressed in the same frame E that the
unit_vector is expressed.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s unit inertia about Bcm is axially symmetric, meaning B has an
equal moment of inertia about any line that both passes through
Bcm and is perpendicular to unit_vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if length is not positive</strong><strong> or </strong><strong>if ‖unit_vector‖ is not</strong> – </p></li>
<li><p><strong>within 1.0E-14</strong><strong> of </strong><strong>1.0.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s axial moment of inertia (along the rod) is zero..</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia.TriaxiallySymmetric(I_triaxial:</span> <span class="pre">float)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">UnitInertia_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">UnitInertia_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">UnitInertia_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]</span></code></p>
<p>This class is used to represent rotational inertias for unit mass
bodies. Therefore, unlike RotationalInertia whose units are kg⋅m², the
units of a UnitInertia are those of length squared. A unit inertia is
a useful concept to represent the geometric distribution of mass in a
body regardless of the actual value of the body mass. The rotational
inertia of a body can therefore be obtained by multiplying its unit
inertia by its mass. Unit inertia matrices can also be called
<strong>gyration</strong> matrices and therefore we choose to represent them in
source code notation with the capital letter G. In contrast, the
capital letter I is used to represent non-unit mass rotational
inertias. This class restricts the set of allowed operations on a unit
inertia to ensure the unit-mass invariant. For instance,
multiplication by a scalar can only return a general RotationalInertia
but not a UnitInertia.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class has no means to check at construction from user
provided parameters whether it actually represents the unit
inertia or gyration matrix of a unit-mass body. However, as
previously noted, once a unit inertia is created, a number of
operations are disallowed to ensure the unit-mass invariant. Also
notice that once a unit inertia is created, it <em>is</em> the unit
inertia of <em>some</em> body, perhaps with scaled geometry from the
user’s intention.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The methods of this class satisfy the “basic exception guarantee”:
if an exception is thrown, the program will still be in a valid
state. Specifically, no resources are leaked, and all objects’
invariants are intact. Be aware that UnitInertia objects may
contain invalid inertia data in cases where input checking is
skipped.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://en.cppreference.com/w/cpp/language/exceptions">https://en.cppreference.com/w/cpp/language/exceptions</a></p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia_[AutoDiffXd].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.tree.UnitInertia_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Default UnitInertia constructor sets all entries to NaN for quick
detection of uninitialized values.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.tree.UnitInertia_[AutoDiffXd], Ixx: pydrake.autodiffutils.AutoDiffXd, Iyy: pydrake.autodiffutils.AutoDiffXd, Izz: pydrake.autodiffutils.AutoDiffXd) -&gt; None</p></li>
</ol>
<p>Creates a unit inertia with moments of inertia <code class="docutils literal notranslate"><span class="pre">Ixx</span></code>, <cite>Iyy</cite>,
<code class="docutils literal notranslate"><span class="pre">Izz</span></code>, and with each product of inertia set to zero. In debug
builds, throws RuntimeError if unit inertia constructed from these
arguments violates RotationalInertia::CouldBePhysicallyValid().</p>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.multibody.tree.UnitInertia_[AutoDiffXd], Ixx: pydrake.autodiffutils.AutoDiffXd, Iyy: pydrake.autodiffutils.AutoDiffXd, Izz: pydrake.autodiffutils.AutoDiffXd, Ixy: pydrake.autodiffutils.AutoDiffXd, Ixz: pydrake.autodiffutils.AutoDiffXd, Iyz: pydrake.autodiffutils.AutoDiffXd) -&gt; None</p></li>
</ol>
<p>Creates a unit inertia with moments of inertia <code class="docutils literal notranslate"><span class="pre">Ixx</span></code>, <cite>Iyy</cite>,
<code class="docutils literal notranslate"><span class="pre">Izz</span></code>, and with products of inertia <code class="docutils literal notranslate"><span class="pre">Ixy</span></code>, <cite>Ixz</cite>, <code class="docutils literal notranslate"><span class="pre">Iyz</span></code>. In
debug builds, throws RuntimeError if unit inertia constructed from
these arguments violates RotationalInertia::CouldBePhysicallyValid().</p>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.multibody.tree.UnitInertia_[AutoDiffXd], I: pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]) -&gt; None</p></li>
</ol>
<p>Constructs a UnitInertia from a RotationalInertia. This constructor
has no way to verify that the input rotational inertia actually is a
unit inertia. But the construction will nevertheless succeed, and the
values of the input rotational inertia will henceforth be considered a
valid unit inertia.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>The user is responsible for passing a valid rotational inertia.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia_[AutoDiffXd].AxiallySymmetric(moment_parallel:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">moment_perpendicular:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">unit_vector:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Returns the unit inertia for a body B for which there exists an axis L
passing through the body’s center of mass Bcm having the property that
B’s moment of inertia about all lines perpendicular to L are equal.
Bodies with this “axially symmetric inertia” property include
axisymmetric cylinders or cones and propellers with 3⁺ evenly spaced
blades. For a body B with axially symmetric inertia, B’s unit inertia
about a point Bp on axis L can be written in terms of a unit_vector
parallel to L; the parallel moment of inertia J about L; and the
perpendicular moment of inertia K about any line perpendicular to axis
L; as:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">G</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">K</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Identity</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">J</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">K</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">unit_vector</span><span class="w"> </span><span class="err">⊗</span><span class="w"> </span><span class="n">unit_vector</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">Identity</span></code> is the identity matrix and ⊗ denotes the tensor
product operator. See Mitiguy, P., 2016. Advanced Dynamics &amp; Motion
Simulation.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">moment_parallel</span></code>:</dt><dd><ol class="upperalpha simple" start="10">
<li><p>B’s unit moment of inertia about axis L.</p></li>
</ol>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">moment_perpendicular</span></code>:</dt><dd><p>(K) B’s unit moment of inertia about Bp for any line perpendicular
to unit_vector.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">unit_vector</span></code>:</dt><dd><p>unit vector parallel to axis L, expressed in a frame E.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_BBp_E</span></code>:</dt><dd><p>B’s unit inertia about point Bp on B’s symmetry axis, expressed in
the same frame E as the unit_vector is expressed.</p>
</dd>
<dt>Precondition:</dt><dd><p>Points Bp and Bcm are both on B’s symmetry axis. The actual
location of these points is not known by this function. However,
the value of moment_perpendicular (K) is associated with point Bp.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s unit inertia about Bp is axially symmetric, meaning B has an
equal moment of inertia about any line that both passes through Bp
and is perpendicular to unit_vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if moment_parallel</strong><strong> (</strong><strong>J</strong><strong>) or </strong><strong>moment_perpendicular</strong><strong> (</strong><strong>K</strong><strong>) </strong><strong>is</strong> – </p></li>
<li><p><strong>negative</strong><strong> or </strong><strong>if J &gt; 2 K</strong><strong> (</strong><strong>violates the triangle inequality</strong><strong>, </strong><strong>see</strong> – </p></li>
<li><p><strong>CouldBePhysicallyValid</strong><strong>(</strong><strong>)</strong><strong>) or </strong><strong>‖unit_vector‖ is not within 1.0E-14</strong> – </p></li>
<li><p><strong>of 1.0.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia_[AutoDiffXd].HollowSphere(r:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Computes the unit inertia for a unit-mass hollow sphere of radius
<code class="docutils literal notranslate"><span class="pre">r</span></code> consisting of an infinitesimally thin shell of uniform density.
The unit inertia is taken about the center of the sphere.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia_[AutoDiffXd].PointMass(p_FQ:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Construct a unit inertia for a point mass of unit mass located at
point Q, whose location in a frame F is given by the position vector
<code class="docutils literal notranslate"><span class="pre">p_FQ</span></code> (that is, p_FoQ_F). The unit inertia <code class="docutils literal notranslate"><span class="pre">G_QFo_F</span></code> of point
mass Q about the origin <code class="docutils literal notranslate"><span class="pre">Fo</span></code> of frame F and expressed in F for this
unit mass point equals the square of the cross product matrix of
<code class="docutils literal notranslate"><span class="pre">p_FQ</span></code>. In coordinate-free form:</p>
<div class="math notranslate nohighlight">
\[G^{Q/F_o} = (^Fp^Q_\times)^2 = (^Fp^Q_\times)^T \, ^Fp^Q_\times =
-^Fp^Q_\times \, ^Fp^Q_\times\]</div>
<p>where <span class="math notranslate nohighlight">\(^Fp^Q_\times\)</span> is the cross product matrix of vector
<span class="math notranslate nohighlight">\(^Fp^Q\)</span>. In source code the above expression is written as:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">G_QFo_F</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">px_FQ²</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">px_FQᵀ</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">px_FQ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">px_FQ</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">px_FQ</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">px_FQ</span></code> denotes the cross product matrix of the position
vector <code class="docutils literal notranslate"><span class="pre">p_FQ</span></code> (expressed in F) such that the cross product with
another vector <code class="docutils literal notranslate"><span class="pre">a</span></code> can be obtained as <code class="docutils literal notranslate"><span class="pre">px.cross(a)</span> <span class="pre">=</span> <span class="pre">px</span> <span class="pre">*</span> <span class="pre">a</span></code>. The
cross product matrix <code class="docutils literal notranslate"><span class="pre">px</span></code> is skew-symmetric. The square of the cross
product matrix is a symmetric matrix with non-negative diagonals and
obeys the triangle inequality. Matrix <code class="docutils literal notranslate"><span class="pre">px²</span></code> can be used to compute
the triple vector product as <code class="docutils literal notranslate"><span class="pre">-p</span> <span class="pre">x</span> <span class="pre">(p</span> <span class="pre">x</span> <span class="pre">a)</span> <span class="pre">=</span> <span class="pre">-p.cross(p.cross(a))</span> <span class="pre">=</span>
<span class="pre">px²</span> <span class="pre">*</span> <span class="pre">a</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia_[AutoDiffXd].ReExpress(self:</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[AutoDiffXd],</span> <span class="pre">R_AE:</span> <span class="pre">pydrake.math.RotationMatrix_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Given <code class="docutils literal notranslate"><span class="pre">this</span></code> unit inertia <code class="docutils literal notranslate"><span class="pre">G_BP_E</span></code> of a body B about a point P and
expressed in frame E, this method computes the same unit inertia
re-expressed in another frame A as <code class="docutils literal notranslate"><span class="pre">G_BP_A</span> <span class="pre">=</span> <span class="pre">R_AE</span> <span class="pre">*</span> <span class="pre">G_BP_E</span> <span class="pre">*</span>
<span class="pre">(R_AE)ᵀ</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_AE</span></code>:</dt><dd><p>RotationMatrix relating frames A and E.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_BP_A</span></code>:</dt><dd><p>The same unit inertia for body B about point P but now
re-expressed in frame A.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia_[AutoDiffXd].SetFromRotationalInertia(self:</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[AutoDiffXd],</span> <span class="pre">I:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[AutoDiffXd],</span> <span class="pre">mass:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> unit inertia from a generally non-unit inertia I
corresponding to a body with a given <code class="docutils literal notranslate"><span class="pre">mass</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the provided mass is not strictly positive.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia_[AutoDiffXd].ShiftFromCenterOfMass(self:</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[AutoDiffXd],</span> <span class="pre">p_BcmQ_E:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Shifts this central unit inertia to a different point, and returns the
result. See ShiftFromCenterOfMassInPlace() for details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BcmQ_E</span></code>:</dt><dd><p>A vector from the body’s centroid <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> to point Q expressed in
the same frame E in which <code class="docutils literal notranslate"><span class="pre">this</span></code> inertia is expressed.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_BQ_E</span></code>:</dt><dd><p>This same unit inertia taken about a point Q instead of the
centroid <code class="docutils literal notranslate"><span class="pre">Bcm</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia_[AutoDiffXd].ShiftToCenterOfMass(self:</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[AutoDiffXd],</span> <span class="pre">p_QBcm_E:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[AutoDiffXd]</span></span></dt>
<dd><p>For the unit inertia <code class="docutils literal notranslate"><span class="pre">G_BQ_E</span></code> of a body or composite body B computed
about a point Q and expressed in a frame E, this method shifts this
inertia using the parallel axis theorem to be computed about the
center of mass <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> of B. See ShiftToCenterOfMassInPlace() for
details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_QBcm_E</span></code>:</dt><dd><p>A position vector from the about point Q to the body’s centroid
<code class="docutils literal notranslate"><span class="pre">Bcm</span></code> expressed in the same frame E in which <code class="docutils literal notranslate"><span class="pre">this</span></code> inertia is
expressed.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_Bcm_E</span></code>:</dt><dd><p>This same unit which has now been taken about point <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> so
that it can be written as <code class="docutils literal notranslate"><span class="pre">G_BBcm_E</span></code>, or <code class="docutils literal notranslate"><span class="pre">G_Bcm_E</span></code>.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This operation could result in a non-physical rotational inertia.
Use with care. See ShiftToCenterOfMassInPlace() for details.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia_[AutoDiffXd].SolidBox(Lx:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">Ly:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">Lz:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Computes the unit inertia for a unit-mass solid box of uniform density
taken about its geometric center. If one length is zero the inertia
corresponds to that of a thin rectangular sheet. If two lengths are
zero the inertia corresponds to that of a thin rod in the remaining
direction.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Lx</span></code>:</dt><dd><p>The length of the box edge in the principal x-axis.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Ly</span></code>:</dt><dd><p>The length of the box edge in the principal y-axis.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Lz</span></code>:</dt><dd><p>The length of the box edge in the principal z-axis.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if any</strong><strong> of </strong><strong>Lx</strong><strong>, </strong><strong>Ly</strong><strong>, </strong><strong>Lz are negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia_[AutoDiffXd].SolidCapsule(radius:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">length:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">unit_vector:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Creates a unit inertia for a uniform density solid capsule B about its
center of mass Bcm (which is coincident with B’s geometric center Bo).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">radius</span></code>:</dt><dd><p>radius of the cylinder/half-sphere parts of the capsule.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">length</span></code>:</dt><dd><p>length of cylindrical part of the capsule.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">unit_vector</span></code>:</dt><dd><p>unit vector defining the axial direction of the cylindrical part
of the capsule, expressed in a frame E.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_BBcm_E</span></code>:</dt><dd><p>B’s unit inertia about Bcm expressed in the same frame E as the
unit_vector is expressed.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s unit inertia about Bcm is axially symmetric, meaning B has an
equal moment of inertia about any line that both passes through
Bcm and is perpendicular to unit_vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if radius</strong><strong> or </strong><strong>length is negative</strong><strong> or </strong><strong>if ‖unit_vector‖</strong> – </p></li>
<li><p><strong>is not within 1.0E-14</strong><strong> of </strong><strong>1.0.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia_[AutoDiffXd].SolidCube(L:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Computes the unit inertia for a unit-mass solid cube (a box with
equal-sized sides) of uniform density taken about its geometric
center.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">L</span></code>:</dt><dd><p>The length of each of the cube’s sides.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia_[AutoDiffXd].SolidCylinder(radius:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">length:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">unit_vector:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Creates a unit inertia for a uniform density solid cylinder B about
its center of mass Bcm (which is coincident with B’s geometric center
Bo).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">radius</span></code>:</dt><dd><p>radius of the cylinder (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">length</span></code>:</dt><dd><p>length of cylinder in unit_vector direction (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">unit_vector</span></code>:</dt><dd><p>unit vector defining the axial direction of the cylinder,
expressed in a frame E.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_BBcm_E</span></code>:</dt><dd><p>B’s unit inertia about Bcm expressed in the same frame E as the
unit_vector is expressed.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s unit inertia about Bcm is axially symmetric, meaning B has an
equal moment of inertia about any line that both passes through
Bcm and is perpendicular to unit_vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if radius</strong><strong> or </strong><strong>length is negative</strong><strong> or </strong><strong>if ‖unit_vector‖</strong> – </p></li>
<li><p><strong>is not within 1.0E-14</strong><strong> of </strong><strong>1.0.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SolidCylinderAboutEnd() to calculate G_BBp_E, B’s unit inertia
about point Bp (Bp is at the center of one of the cylinder’s
circular ends).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia_[AutoDiffXd].SolidCylinderAboutEnd(radius:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">length:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">unit_vector:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Creates a unit inertia for a uniform-density solid cylinder B about an
end-point Bp of the cylinder’s axis (see below for more about Bp).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">radius</span></code>:</dt><dd><p>radius of cylinder (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">length</span></code>:</dt><dd><p>length of cylinder in unit_vector direction (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">unit_vector</span></code>:</dt><dd><p>unit vector parallel to the axis of the cylinder and directed from
Bp to Bcm (B’s center of mass), expressed in a frame E.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_BBp_E</span></code>:</dt><dd><p>B’s unit inertia about Bp expressed in the same frame E as the
unit_vector is expressed.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The position from Bp to Bcm is p_BpBcm = length / 2 * unit_vector.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s unit inertia about Bp is axially symmetric, meaning B has an
equal moment of inertia about any line that both passes through Bp
and is perpendicular to unit_vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if radius</strong><strong> or </strong><strong>length is negative</strong><strong> or </strong><strong>if ‖unit_vector‖</strong> – </p></li>
<li><p><strong>is not within 1.0E-14</strong><strong> of </strong><strong>1.0.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia_[AutoDiffXd].SolidEllipsoid(a:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">b:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">c:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Computes the unit inertia for a unit-mass solid ellipsoid of uniform
density taken about its center. The lengths of the semi-axes of the
ellipsoid in the principal x,y,z-axes are <code class="docutils literal notranslate"><span class="pre">a</span></code>, <cite>b</cite>, and <code class="docutils literal notranslate"><span class="pre">c</span></code>
respectively.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia_[AutoDiffXd].SolidSphere(r:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Computes the unit inertia for a unit-mass solid sphere of uniform
density and radius <code class="docutils literal notranslate"><span class="pre">r</span></code> taken about its center.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia_[AutoDiffXd].StraightLine(moment_perpendicular:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">unit_vector:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Creates a unit inertia for a straight line segment B about a point Bp
on the line segment.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">moment_perpendicular</span></code>:</dt><dd><p>Unit moment of inertia about any axis that passes through Bp and
is perpendicular to the line segment.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">unit_vector</span></code>:</dt><dd><p>unit vector defining the line segment’s direction, expressed in a
frame E.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_BBp_E</span></code>:</dt><dd><p>B’s unit inertia about Bp, expressed in the same frame E that the
unit_vector is expressed.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s unit inertia about Bp is axially symmetric, meaning B has an
equal moment of inertia about any line that both passes through Bp
and is perpendicular to unit_vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if moment_perpendicular is not positive</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>‖unit_vector‖ is not within 1.0E-14</strong><strong> of </strong><strong>1.0.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s axial moment of inertia (along the line segment) is zero.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ThinRod() is an example of an object that is axially symmetric and
that has a zero moment of inertia about Bp in the unit_vector
direction.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia_[AutoDiffXd].ThinRod(length:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd,</span> <span class="pre">unit_vector:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[AutoDiffXd]</span></span></dt>
<dd><p>Creates a unit inertia for a uniform density thin rod B about its
center of mass Bcm (which is coincident with B’s geometric center Bo).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">length</span></code>:</dt><dd><p>length of rod in unit_vector direction (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">unit_vector</span></code>:</dt><dd><p>unit vector defining the rod’s axial direction, expressed in a
frame E.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_BBcm_E</span></code>:</dt><dd><p>B’s unit inertia about Bcm expressed in the same frame E that the
unit_vector is expressed.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s unit inertia about Bcm is axially symmetric, meaning B has an
equal moment of inertia about any line that both passes through
Bcm and is perpendicular to unit_vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if length is not positive</strong><strong> or </strong><strong>if ‖unit_vector‖ is not</strong> – </p></li>
<li><p><strong>within 1.0E-14</strong><strong> of </strong><strong>1.0.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s axial moment of inertia (along the rod) is zero..</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia_[AutoDiffXd].TriaxiallySymmetric(I_triaxial:</span> <span class="pre">pydrake.autodiffutils.AutoDiffXd)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[AutoDiffXd]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.RotationalInertia_[Expression]</span></code></p>
<p>This class is used to represent rotational inertias for unit mass
bodies. Therefore, unlike RotationalInertia whose units are kg⋅m², the
units of a UnitInertia are those of length squared. A unit inertia is
a useful concept to represent the geometric distribution of mass in a
body regardless of the actual value of the body mass. The rotational
inertia of a body can therefore be obtained by multiplying its unit
inertia by its mass. Unit inertia matrices can also be called
<strong>gyration</strong> matrices and therefore we choose to represent them in
source code notation with the capital letter G. In contrast, the
capital letter I is used to represent non-unit mass rotational
inertias. This class restricts the set of allowed operations on a unit
inertia to ensure the unit-mass invariant. For instance,
multiplication by a scalar can only return a general RotationalInertia
but not a UnitInertia.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class has no means to check at construction from user
provided parameters whether it actually represents the unit
inertia or gyration matrix of a unit-mass body. However, as
previously noted, once a unit inertia is created, a number of
operations are disallowed to ensure the unit-mass invariant. Also
notice that once a unit inertia is created, it <em>is</em> the unit
inertia of <em>some</em> body, perhaps with scaled geometry from the
user’s intention.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The methods of this class satisfy the “basic exception guarantee”:
if an exception is thrown, the program will still be in a valid
state. Specifically, no resources are leaked, and all objects’
invariants are intact. Be aware that UnitInertia objects may
contain invalid inertia data in cases where input checking is
skipped.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference external" href="https://en.cppreference.com/w/cpp/language/exceptions">https://en.cppreference.com/w/cpp/language/exceptions</a></p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia_[Expression].__init__(*args,</span> <span class="pre">**kwargs)</span></span></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li><p>__init__(self: pydrake.multibody.tree.UnitInertia_[Expression]) -&gt; None</p></li>
</ol>
<p>Default UnitInertia constructor sets all entries to NaN for quick
detection of uninitialized values.</p>
<ol class="arabic simple" start="2">
<li><p>__init__(self: pydrake.multibody.tree.UnitInertia_[Expression], Ixx: pydrake.symbolic.Expression, Iyy: pydrake.symbolic.Expression, Izz: pydrake.symbolic.Expression) -&gt; None</p></li>
</ol>
<p>Creates a unit inertia with moments of inertia <code class="docutils literal notranslate"><span class="pre">Ixx</span></code>, <cite>Iyy</cite>,
<code class="docutils literal notranslate"><span class="pre">Izz</span></code>, and with each product of inertia set to zero. In debug
builds, throws RuntimeError if unit inertia constructed from these
arguments violates RotationalInertia::CouldBePhysicallyValid().</p>
<ol class="arabic simple" start="3">
<li><p>__init__(self: pydrake.multibody.tree.UnitInertia_[Expression], Ixx: pydrake.symbolic.Expression, Iyy: pydrake.symbolic.Expression, Izz: pydrake.symbolic.Expression, Ixy: pydrake.symbolic.Expression, Ixz: pydrake.symbolic.Expression, Iyz: pydrake.symbolic.Expression) -&gt; None</p></li>
</ol>
<p>Creates a unit inertia with moments of inertia <code class="docutils literal notranslate"><span class="pre">Ixx</span></code>, <cite>Iyy</cite>,
<code class="docutils literal notranslate"><span class="pre">Izz</span></code>, and with products of inertia <code class="docutils literal notranslate"><span class="pre">Ixy</span></code>, <cite>Ixz</cite>, <code class="docutils literal notranslate"><span class="pre">Iyz</span></code>. In
debug builds, throws RuntimeError if unit inertia constructed from
these arguments violates RotationalInertia::CouldBePhysicallyValid().</p>
<ol class="arabic simple" start="4">
<li><p>__init__(self: pydrake.multibody.tree.UnitInertia_[Expression], I: pydrake.multibody.tree.RotationalInertia_[Expression]) -&gt; None</p></li>
</ol>
<p>Constructs a UnitInertia from a RotationalInertia. This constructor
has no way to verify that the input rotational inertia actually is a
unit inertia. But the construction will nevertheless succeed, and the
values of the input rotational inertia will henceforth be considered a
valid unit inertia.</p>
<dl class="simple">
<dt>Precondition:</dt><dd><p>The user is responsible for passing a valid rotational inertia.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia_[Expression].AxiallySymmetric(moment_parallel:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">moment_perpendicular:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">unit_vector:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[Expression]</span></span></dt>
<dd><p>Returns the unit inertia for a body B for which there exists an axis L
passing through the body’s center of mass Bcm having the property that
B’s moment of inertia about all lines perpendicular to L are equal.
Bodies with this “axially symmetric inertia” property include
axisymmetric cylinders or cones and propellers with 3⁺ evenly spaced
blades. For a body B with axially symmetric inertia, B’s unit inertia
about a point Bp on axis L can be written in terms of a unit_vector
parallel to L; the parallel moment of inertia J about L; and the
perpendicular moment of inertia K about any line perpendicular to axis
L; as:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">G</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">K</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Identity</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">J</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">K</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">unit_vector</span><span class="w"> </span><span class="err">⊗</span><span class="w"> </span><span class="n">unit_vector</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">Identity</span></code> is the identity matrix and ⊗ denotes the tensor
product operator. See Mitiguy, P., 2016. Advanced Dynamics &amp; Motion
Simulation.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">moment_parallel</span></code>:</dt><dd><ol class="upperalpha simple" start="10">
<li><p>B’s unit moment of inertia about axis L.</p></li>
</ol>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">moment_perpendicular</span></code>:</dt><dd><p>(K) B’s unit moment of inertia about Bp for any line perpendicular
to unit_vector.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">unit_vector</span></code>:</dt><dd><p>unit vector parallel to axis L, expressed in a frame E.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_BBp_E</span></code>:</dt><dd><p>B’s unit inertia about point Bp on B’s symmetry axis, expressed in
the same frame E as the unit_vector is expressed.</p>
</dd>
<dt>Precondition:</dt><dd><p>Points Bp and Bcm are both on B’s symmetry axis. The actual
location of these points is not known by this function. However,
the value of moment_perpendicular (K) is associated with point Bp.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s unit inertia about Bp is axially symmetric, meaning B has an
equal moment of inertia about any line that both passes through Bp
and is perpendicular to unit_vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if moment_parallel</strong><strong> (</strong><strong>J</strong><strong>) or </strong><strong>moment_perpendicular</strong><strong> (</strong><strong>K</strong><strong>) </strong><strong>is</strong> – </p></li>
<li><p><strong>negative</strong><strong> or </strong><strong>if J &gt; 2 K</strong><strong> (</strong><strong>violates the triangle inequality</strong><strong>, </strong><strong>see</strong> – </p></li>
<li><p><strong>CouldBePhysicallyValid</strong><strong>(</strong><strong>)</strong><strong>) or </strong><strong>‖unit_vector‖ is not within 1.0E-14</strong> – </p></li>
<li><p><strong>of 1.0.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia_[Expression].HollowSphere(r:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[Expression]</span></span></dt>
<dd><p>Computes the unit inertia for a unit-mass hollow sphere of radius
<code class="docutils literal notranslate"><span class="pre">r</span></code> consisting of an infinitesimally thin shell of uniform density.
The unit inertia is taken about the center of the sphere.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia_[Expression].PointMass(p_FQ:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[Expression]</span></span></dt>
<dd><p>Construct a unit inertia for a point mass of unit mass located at
point Q, whose location in a frame F is given by the position vector
<code class="docutils literal notranslate"><span class="pre">p_FQ</span></code> (that is, p_FoQ_F). The unit inertia <code class="docutils literal notranslate"><span class="pre">G_QFo_F</span></code> of point
mass Q about the origin <code class="docutils literal notranslate"><span class="pre">Fo</span></code> of frame F and expressed in F for this
unit mass point equals the square of the cross product matrix of
<code class="docutils literal notranslate"><span class="pre">p_FQ</span></code>. In coordinate-free form:</p>
<div class="math notranslate nohighlight">
\[G^{Q/F_o} = (^Fp^Q_\times)^2 = (^Fp^Q_\times)^T \, ^Fp^Q_\times =
-^Fp^Q_\times \, ^Fp^Q_\times\]</div>
<p>where <span class="math notranslate nohighlight">\(^Fp^Q_\times\)</span> is the cross product matrix of vector
<span class="math notranslate nohighlight">\(^Fp^Q\)</span>. In source code the above expression is written as:</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">G_QFo_F</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">px_FQ²</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">px_FQᵀ</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">px_FQ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">px_FQ</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">px_FQ</span>
</pre></div>
</div>
</details><p>where <code class="docutils literal notranslate"><span class="pre">px_FQ</span></code> denotes the cross product matrix of the position
vector <code class="docutils literal notranslate"><span class="pre">p_FQ</span></code> (expressed in F) such that the cross product with
another vector <code class="docutils literal notranslate"><span class="pre">a</span></code> can be obtained as <code class="docutils literal notranslate"><span class="pre">px.cross(a)</span> <span class="pre">=</span> <span class="pre">px</span> <span class="pre">*</span> <span class="pre">a</span></code>. The
cross product matrix <code class="docutils literal notranslate"><span class="pre">px</span></code> is skew-symmetric. The square of the cross
product matrix is a symmetric matrix with non-negative diagonals and
obeys the triangle inequality. Matrix <code class="docutils literal notranslate"><span class="pre">px²</span></code> can be used to compute
the triple vector product as <code class="docutils literal notranslate"><span class="pre">-p</span> <span class="pre">x</span> <span class="pre">(p</span> <span class="pre">x</span> <span class="pre">a)</span> <span class="pre">=</span> <span class="pre">-p.cross(p.cross(a))</span> <span class="pre">=</span>
<span class="pre">px²</span> <span class="pre">*</span> <span class="pre">a</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia_[Expression].ReExpress(self:</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[Expression],</span> <span class="pre">R_AE:</span> <span class="pre">pydrake.math.RotationMatrix_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[Expression]</span></span></dt>
<dd><p>Given <code class="docutils literal notranslate"><span class="pre">this</span></code> unit inertia <code class="docutils literal notranslate"><span class="pre">G_BP_E</span></code> of a body B about a point P and
expressed in frame E, this method computes the same unit inertia
re-expressed in another frame A as <code class="docutils literal notranslate"><span class="pre">G_BP_A</span> <span class="pre">=</span> <span class="pre">R_AE</span> <span class="pre">*</span> <span class="pre">G_BP_E</span> <span class="pre">*</span>
<span class="pre">(R_AE)ᵀ</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_AE</span></code>:</dt><dd><p>RotationMatrix relating frames A and E.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_BP_A</span></code>:</dt><dd><p>The same unit inertia for body B about point P but now
re-expressed in frame A.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia_[Expression].SetFromRotationalInertia(self:</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[Expression],</span> <span class="pre">I:</span> <span class="pre">pydrake.multibody.tree.RotationalInertia_[Expression],</span> <span class="pre">mass:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[Expression]</span></span></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> unit inertia from a generally non-unit inertia I
corresponding to a body with a given <code class="docutils literal notranslate"><span class="pre">mass</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if the provided mass is not strictly positive.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia_[Expression].ShiftFromCenterOfMass(self:</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[Expression],</span> <span class="pre">p_BcmQ_E:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[Expression]</span></span></dt>
<dd><p>Shifts this central unit inertia to a different point, and returns the
result. See ShiftFromCenterOfMassInPlace() for details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BcmQ_E</span></code>:</dt><dd><p>A vector from the body’s centroid <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> to point Q expressed in
the same frame E in which <code class="docutils literal notranslate"><span class="pre">this</span></code> inertia is expressed.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_BQ_E</span></code>:</dt><dd><p>This same unit inertia taken about a point Q instead of the
centroid <code class="docutils literal notranslate"><span class="pre">Bcm</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia_[Expression].ShiftToCenterOfMass(self:</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[Expression],</span> <span class="pre">p_QBcm_E:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[Expression]</span></span></dt>
<dd><p>For the unit inertia <code class="docutils literal notranslate"><span class="pre">G_BQ_E</span></code> of a body or composite body B computed
about a point Q and expressed in a frame E, this method shifts this
inertia using the parallel axis theorem to be computed about the
center of mass <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> of B. See ShiftToCenterOfMassInPlace() for
details.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_QBcm_E</span></code>:</dt><dd><p>A position vector from the about point Q to the body’s centroid
<code class="docutils literal notranslate"><span class="pre">Bcm</span></code> expressed in the same frame E in which <code class="docutils literal notranslate"><span class="pre">this</span></code> inertia is
expressed.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_Bcm_E</span></code>:</dt><dd><p>This same unit which has now been taken about point <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> so
that it can be written as <code class="docutils literal notranslate"><span class="pre">G_BBcm_E</span></code>, or <code class="docutils literal notranslate"><span class="pre">G_Bcm_E</span></code>.</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This operation could result in a non-physical rotational inertia.
Use with care. See ShiftToCenterOfMassInPlace() for details.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia_[Expression].SolidBox(Lx:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">Ly:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">Lz:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[Expression]</span></span></dt>
<dd><p>Computes the unit inertia for a unit-mass solid box of uniform density
taken about its geometric center. If one length is zero the inertia
corresponds to that of a thin rectangular sheet. If two lengths are
zero the inertia corresponds to that of a thin rod in the remaining
direction.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Lx</span></code>:</dt><dd><p>The length of the box edge in the principal x-axis.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Ly</span></code>:</dt><dd><p>The length of the box edge in the principal y-axis.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Lz</span></code>:</dt><dd><p>The length of the box edge in the principal z-axis.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if any</strong><strong> of </strong><strong>Lx</strong><strong>, </strong><strong>Ly</strong><strong>, </strong><strong>Lz are negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia_[Expression].SolidCapsule(radius:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">length:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">unit_vector:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[Expression]</span></span></dt>
<dd><p>Creates a unit inertia for a uniform density solid capsule B about its
center of mass Bcm (which is coincident with B’s geometric center Bo).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">radius</span></code>:</dt><dd><p>radius of the cylinder/half-sphere parts of the capsule.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">length</span></code>:</dt><dd><p>length of cylindrical part of the capsule.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">unit_vector</span></code>:</dt><dd><p>unit vector defining the axial direction of the cylindrical part
of the capsule, expressed in a frame E.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_BBcm_E</span></code>:</dt><dd><p>B’s unit inertia about Bcm expressed in the same frame E as the
unit_vector is expressed.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s unit inertia about Bcm is axially symmetric, meaning B has an
equal moment of inertia about any line that both passes through
Bcm and is perpendicular to unit_vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if radius</strong><strong> or </strong><strong>length is negative</strong><strong> or </strong><strong>if ‖unit_vector‖</strong> – </p></li>
<li><p><strong>is not within 1.0E-14</strong><strong> of </strong><strong>1.0.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia_[Expression].SolidCube(L:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[Expression]</span></span></dt>
<dd><p>Computes the unit inertia for a unit-mass solid cube (a box with
equal-sized sides) of uniform density taken about its geometric
center.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">L</span></code>:</dt><dd><p>The length of each of the cube’s sides.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia_[Expression].SolidCylinder(radius:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">length:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">unit_vector:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[Expression]</span></span></dt>
<dd><p>Creates a unit inertia for a uniform density solid cylinder B about
its center of mass Bcm (which is coincident with B’s geometric center
Bo).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">radius</span></code>:</dt><dd><p>radius of the cylinder (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">length</span></code>:</dt><dd><p>length of cylinder in unit_vector direction (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">unit_vector</span></code>:</dt><dd><p>unit vector defining the axial direction of the cylinder,
expressed in a frame E.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_BBcm_E</span></code>:</dt><dd><p>B’s unit inertia about Bcm expressed in the same frame E as the
unit_vector is expressed.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s unit inertia about Bcm is axially symmetric, meaning B has an
equal moment of inertia about any line that both passes through
Bcm and is perpendicular to unit_vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if radius</strong><strong> or </strong><strong>length is negative</strong><strong> or </strong><strong>if ‖unit_vector‖</strong> – </p></li>
<li><p><strong>is not within 1.0E-14</strong><strong> of </strong><strong>1.0.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>SolidCylinderAboutEnd() to calculate G_BBp_E, B’s unit inertia
about point Bp (Bp is at the center of one of the cylinder’s
circular ends).</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia_[Expression].SolidCylinderAboutEnd(radius:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">length:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">unit_vector:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[Expression]</span></span></dt>
<dd><p>Creates a unit inertia for a uniform-density solid cylinder B about an
end-point Bp of the cylinder’s axis (see below for more about Bp).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">radius</span></code>:</dt><dd><p>radius of cylinder (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">length</span></code>:</dt><dd><p>length of cylinder in unit_vector direction (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">unit_vector</span></code>:</dt><dd><p>unit vector parallel to the axis of the cylinder and directed from
Bp to Bcm (B’s center of mass), expressed in a frame E.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_BBp_E</span></code>:</dt><dd><p>B’s unit inertia about Bp expressed in the same frame E as the
unit_vector is expressed.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The position from Bp to Bcm is p_BpBcm = length / 2 * unit_vector.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s unit inertia about Bp is axially symmetric, meaning B has an
equal moment of inertia about any line that both passes through Bp
and is perpendicular to unit_vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if radius</strong><strong> or </strong><strong>length is negative</strong><strong> or </strong><strong>if ‖unit_vector‖</strong> – </p></li>
<li><p><strong>is not within 1.0E-14</strong><strong> of </strong><strong>1.0.</strong> – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia_[Expression].SolidEllipsoid(a:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">b:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">c:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[Expression]</span></span></dt>
<dd><p>Computes the unit inertia for a unit-mass solid ellipsoid of uniform
density taken about its center. The lengths of the semi-axes of the
ellipsoid in the principal x,y,z-axes are <code class="docutils literal notranslate"><span class="pre">a</span></code>, <cite>b</cite>, and <code class="docutils literal notranslate"><span class="pre">c</span></code>
respectively.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia_[Expression].SolidSphere(r:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[Expression]</span></span></dt>
<dd><p>Computes the unit inertia for a unit-mass solid sphere of uniform
density and radius <code class="docutils literal notranslate"><span class="pre">r</span></code> taken about its center.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia_[Expression].StraightLine(moment_perpendicular:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">unit_vector:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[Expression]</span></span></dt>
<dd><p>Creates a unit inertia for a straight line segment B about a point Bp
on the line segment.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">moment_perpendicular</span></code>:</dt><dd><p>Unit moment of inertia about any axis that passes through Bp and
is perpendicular to the line segment.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">unit_vector</span></code>:</dt><dd><p>unit vector defining the line segment’s direction, expressed in a
frame E.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_BBp_E</span></code>:</dt><dd><p>B’s unit inertia about Bp, expressed in the same frame E that the
unit_vector is expressed.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s unit inertia about Bp is axially symmetric, meaning B has an
equal moment of inertia about any line that both passes through Bp
and is perpendicular to unit_vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if moment_perpendicular is not positive</strong><strong> or </strong><strong>if</strong> – </p></li>
<li><p><strong>‖unit_vector‖ is not within 1.0E-14</strong><strong> of </strong><strong>1.0.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s axial moment of inertia (along the line segment) is zero.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>ThinRod() is an example of an object that is axially symmetric and
that has a zero moment of inertia about Bp in the unit_vector
direction.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia_[Expression].ThinRod(length:</span> <span class="pre">pydrake.symbolic.Expression,</span> <span class="pre">unit_vector:</span> <span class="pre">numpy.ndarray[object[3,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[Expression]</span></span></dt>
<dd><p>Creates a unit inertia for a uniform density thin rod B about its
center of mass Bcm (which is coincident with B’s geometric center Bo).</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">length</span></code>:</dt><dd><p>length of rod in unit_vector direction (meters).</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">unit_vector</span></code>:</dt><dd><p>unit vector defining the rod’s axial direction, expressed in a
frame E.</p>
</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_BBcm_E</span></code>:</dt><dd><p>B’s unit inertia about Bcm expressed in the same frame E that the
unit_vector is expressed.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s unit inertia about Bcm is axially symmetric, meaning B has an
equal moment of inertia about any line that both passes through
Bcm and is perpendicular to unit_vector.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>RuntimeError if length is not positive</strong><strong> or </strong><strong>if ‖unit_vector‖ is not</strong> – </p></li>
<li><p><strong>within 1.0E-14</strong><strong> of </strong><strong>1.0.</strong> – </p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>B’s axial moment of inertia (along the rod) is zero..</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UnitInertia_[Expression].TriaxiallySymmetric(I_triaxial:</span> <span class="pre">pydrake.symbolic.Expression)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UnitInertia_[Expression]</span></span></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniversalJoint</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint</span></code></p>
<p>This joint models a universal joint allowing two bodies to rotate
relative to one another with two degrees of freedom. A universal joint
can be thought of as a mechanism consisting of three bodies; the
parent body P, an intermediate cross-shaped body I, and the child body
B. In a physical universal joint, body I has a significantly smaller
mass than P or B. This universal joint model corresponds to the
mathematical limit of having a body I of negligible mass. Given a
frame F attached to the parent body P and a frame M attached to the
child body B (see the Joint class’s documentation), the orientation of
M in F can then naturally be defined as follows using a body fixed
rotation sequence. A first rotation of θ₁ about Fx defines the
orientation R_FI of the intermediate frame I attached to body I
(notice that by definition Ix = Fx at all times). A second rotation of
θ₂ about Iy defines the orientation R_IM of frame M (notice that by
definition My = Iy at all times). Mathematically, the orientation of
frame M in F is given by</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">R_FM</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">R_FI</span><span class="p">(</span><span class="n">θ₁</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">R_IM</span><span class="p">(</span><span class="n">θ₂</span><span class="p">)</span>
</pre></div>
</div>
</details><p>No translational motion of M in F is allowed and the origins, <code class="docutils literal notranslate"><span class="pre">Mo</span></code>
and <code class="docutils literal notranslate"><span class="pre">Fo</span></code>, of frames M and F respectively remain coincident. The
angles of rotation about F’s x-axis and M’s y-axis, along with their
rates, specify the state of the joint. Zero θ₁, θ₂ angles corresponds
to frames F, I, and M being coincident. Angles (θ₁, θ₂) are defined to
be positive according to the right-hand-rule with the thumb aligned in
the direction of their respective axes.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">UniversalJoint_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniversalJoint.__init__(self:</span> <span class="pre">pydrake.multibody.tree.UniversalJoint,</span> <span class="pre">name:</span> <span class="pre">str,</span> <span class="pre">frame_on_parent:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">frame_on_child:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">damping:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructor to create a universal joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B rotate as described in the class’s documentation. See
class documentation for details on the angles defining orientation.
This constructor signature creates a joint with no joint limits, i.e.
the joint position, velocity and acceleration limits are the pair
<code class="docutils literal notranslate"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. These can be set using the Joint methods
set_position_limits(), set_velocity_limits() and
set_acceleration_limits(). The first three arguments to this
constructor are those of the Joint class constructor. See the Joint
class’s documentation for details. The additional parameters are:</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>Viscous damping coefficient, in N⋅m⋅s, used to model losses within
the joint. See documentation of default_damping() for details on
modelling of the damping torque.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if damping is negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniversalJoint.default_damping(self:</span> <span class="pre">pydrake.multibody.tree.UniversalJoint)</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s default damping constant in N⋅m⋅s. The
damping torque (in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τᵢ</span> <span class="pre">=</span> <span class="pre">-damping⋅ωᵢ,</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">2</span></code>
i.e. opposing motion, with ωᵢ the angular rates about the i-th axis
for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see get_angular_rates())and τᵢ the torque on child
body B about the same i-th axis.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniversalJoint.get_angles(self:</span> <span class="pre">pydrake.multibody.tree.UniversalJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[2,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Gets the rotation angles of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint from <code class="docutils literal notranslate"><span class="pre">context</span></code>. See class
documentation for the definition of these angles.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The angle coordinates of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code>
ordered as (θ₁, θ₂).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniversalJoint.get_angular_rates(self:</span> <span class="pre">pydrake.multibody.tree.UniversalJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[2,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Gets the rates of change, in radians per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
angles (see class documentation) from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The rates of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s angles as stored in the
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniversalJoint.get_default_angles(self:</span> <span class="pre">pydrake.multibody.tree.UniversalJoint)</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[2,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Gets the default angles for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint. Wrapper for the more
general <code class="docutils literal notranslate"><span class="pre">Joint::default_positions()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The default angles of <code class="docutils literal notranslate"><span class="pre">this</span></code> stored in <code class="docutils literal notranslate"><span class="pre">default_positions_</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniversalJoint.kTypeName</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniversalJoint.set_angles(self:</span> <span class="pre">pydrake.multibody.tree.UniversalJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">angles:</span> <span class="pre">numpy.ndarray[numpy.float64[2,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UniversalJoint</span></span></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the generalized coordinates corresponding
to the rotation angles of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals <code class="docutils literal notranslate"><span class="pre">angles</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angles</span></code>:</dt><dd><p>The desired angles in radians to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> ordered
as (θ₁, θ₂). See class documentation for details.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniversalJoint.set_angular_rates(self:</span> <span class="pre">pydrake.multibody.tree.UniversalJoint,</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context,</span> <span class="pre">theta_dot:</span> <span class="pre">numpy.ndarray[numpy.float64[2,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UniversalJoint</span></span></dt>
<dd><p>Sets the rates of change, in radians per second, of this <code class="docutils literal notranslate"><span class="pre">this</span></code>
joint’s angles (see class documentation) to <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>. The new
rates of change get stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>:</dt><dd><p>The desired rates of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joints’s angles in radians
per second.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniversalJoint.set_default_angles(self:</span> <span class="pre">pydrake.multibody.tree.UniversalJoint,</span> <span class="pre">angles:</span> <span class="pre">numpy.ndarray[numpy.float64[2,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default angles of this joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angles</span></code>:</dt><dd><p>The desired default angles of the joint</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniversalJoint.set_random_angles_distribution(self:</span> <span class="pre">pydrake.multibody.tree.UniversalJoint,</span> <span class="pre">angles:</span> <span class="pre">numpy.ndarray[object[2,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the random distribution that angles of this joint will be
randomly sampled from. See class documentation for details on the
definition of the angles.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniversalJoint_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">UniversalJoint_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">UniversalJoint_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">UniversalJoint_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniversalJoint_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd]</span></code></p>
<p>This joint models a universal joint allowing two bodies to rotate
relative to one another with two degrees of freedom. A universal joint
can be thought of as a mechanism consisting of three bodies; the
parent body P, an intermediate cross-shaped body I, and the child body
B. In a physical universal joint, body I has a significantly smaller
mass than P or B. This universal joint model corresponds to the
mathematical limit of having a body I of negligible mass. Given a
frame F attached to the parent body P and a frame M attached to the
child body B (see the Joint class’s documentation), the orientation of
M in F can then naturally be defined as follows using a body fixed
rotation sequence. A first rotation of θ₁ about Fx defines the
orientation R_FI of the intermediate frame I attached to body I
(notice that by definition Ix = Fx at all times). A second rotation of
θ₂ about Iy defines the orientation R_IM of frame M (notice that by
definition My = Iy at all times). Mathematically, the orientation of
frame M in F is given by</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">R_FM</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">R_FI</span><span class="p">(</span><span class="n">θ₁</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">R_IM</span><span class="p">(</span><span class="n">θ₂</span><span class="p">)</span>
</pre></div>
</div>
</details><p>No translational motion of M in F is allowed and the origins, <code class="docutils literal notranslate"><span class="pre">Mo</span></code>
and <code class="docutils literal notranslate"><span class="pre">Fo</span></code>, of frames M and F respectively remain coincident. The
angles of rotation about F’s x-axis and M’s y-axis, along with their
rates, specify the state of the joint. Zero θ₁, θ₂ angles corresponds
to frames F, I, and M being coincident. Angles (θ₁, θ₂) are defined to
be positive according to the right-hand-rule with the thumb aligned in
the direction of their respective axes.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniversalJoint_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.multibody.tree.UniversalJoint_[AutoDiffXd],</span> <span class="pre">name:</span> <span class="pre">str,</span> <span class="pre">frame_on_parent:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">frame_on_child:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">damping:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructor to create a universal joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B rotate as described in the class’s documentation. See
class documentation for details on the angles defining orientation.
This constructor signature creates a joint with no joint limits, i.e.
the joint position, velocity and acceleration limits are the pair
<code class="docutils literal notranslate"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. These can be set using the Joint methods
set_position_limits(), set_velocity_limits() and
set_acceleration_limits(). The first three arguments to this
constructor are those of the Joint class constructor. See the Joint
class’s documentation for details. The additional parameters are:</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>Viscous damping coefficient, in N⋅m⋅s, used to model losses within
the joint. See documentation of default_damping() for details on
modelling of the damping torque.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if damping is negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniversalJoint_[AutoDiffXd].default_damping(self:</span> <span class="pre">pydrake.multibody.tree.UniversalJoint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s default damping constant in N⋅m⋅s. The
damping torque (in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τᵢ</span> <span class="pre">=</span> <span class="pre">-damping⋅ωᵢ,</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">2</span></code>
i.e. opposing motion, with ωᵢ the angular rates about the i-th axis
for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see get_angular_rates())and τᵢ the torque on child
body B about the same i-th axis.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniversalJoint_[AutoDiffXd].get_angles(self:</span> <span class="pre">pydrake.multibody.tree.UniversalJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[2,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Gets the rotation angles of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint from <code class="docutils literal notranslate"><span class="pre">context</span></code>. See class
documentation for the definition of these angles.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The angle coordinates of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code>
ordered as (θ₁, θ₂).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniversalJoint_[AutoDiffXd].get_angular_rates(self:</span> <span class="pre">pydrake.multibody.tree.UniversalJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[2,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Gets the rates of change, in radians per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
angles (see class documentation) from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The rates of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s angles as stored in the
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniversalJoint_[AutoDiffXd].get_default_angles(self:</span> <span class="pre">pydrake.multibody.tree.UniversalJoint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[2,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Gets the default angles for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint. Wrapper for the more
general <code class="docutils literal notranslate"><span class="pre">Joint::default_positions()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The default angles of <code class="docutils literal notranslate"><span class="pre">this</span></code> stored in <code class="docutils literal notranslate"><span class="pre">default_positions_</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniversalJoint_[AutoDiffXd].kTypeName</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniversalJoint_[AutoDiffXd].set_angles(self:</span> <span class="pre">pydrake.multibody.tree.UniversalJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">angles:</span> <span class="pre">numpy.ndarray[object[2,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UniversalJoint_[AutoDiffXd]</span></span></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the generalized coordinates corresponding
to the rotation angles of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals <code class="docutils literal notranslate"><span class="pre">angles</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angles</span></code>:</dt><dd><p>The desired angles in radians to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> ordered
as (θ₁, θ₂). See class documentation for details.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniversalJoint_[AutoDiffXd].set_angular_rates(self:</span> <span class="pre">pydrake.multibody.tree.UniversalJoint_[AutoDiffXd],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[AutoDiffXd],</span> <span class="pre">theta_dot:</span> <span class="pre">numpy.ndarray[object[2,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UniversalJoint_[AutoDiffXd]</span></span></dt>
<dd><p>Sets the rates of change, in radians per second, of this <code class="docutils literal notranslate"><span class="pre">this</span></code>
joint’s angles (see class documentation) to <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>. The new
rates of change get stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>:</dt><dd><p>The desired rates of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joints’s angles in radians
per second.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniversalJoint_[AutoDiffXd].set_default_angles(self:</span> <span class="pre">pydrake.multibody.tree.UniversalJoint_[AutoDiffXd],</span> <span class="pre">angles:</span> <span class="pre">numpy.ndarray[numpy.float64[2,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default angles of this joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angles</span></code>:</dt><dd><p>The desired default angles of the joint</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniversalJoint_[AutoDiffXd].set_random_angles_distribution(self:</span> <span class="pre">pydrake.multibody.tree.UniversalJoint_[AutoDiffXd],</span> <span class="pre">angles:</span> <span class="pre">numpy.ndarray[object[2,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the random distribution that angles of this joint will be
randomly sampled from. See class documentation for details on the
definition of the angles.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniversalJoint_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[Expression]</span></code></p>
<p>This joint models a universal joint allowing two bodies to rotate
relative to one another with two degrees of freedom. A universal joint
can be thought of as a mechanism consisting of three bodies; the
parent body P, an intermediate cross-shaped body I, and the child body
B. In a physical universal joint, body I has a significantly smaller
mass than P or B. This universal joint model corresponds to the
mathematical limit of having a body I of negligible mass. Given a
frame F attached to the parent body P and a frame M attached to the
child body B (see the Joint class’s documentation), the orientation of
M in F can then naturally be defined as follows using a body fixed
rotation sequence. A first rotation of θ₁ about Fx defines the
orientation R_FI of the intermediate frame I attached to body I
(notice that by definition Ix = Fx at all times). A second rotation of
θ₂ about Iy defines the orientation R_IM of frame M (notice that by
definition My = Iy at all times). Mathematically, the orientation of
frame M in F is given by</p>
<details><summary>Click to expand C++ code...</summary><div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">R_FM</span><span class="p">(</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">R_FI</span><span class="p">(</span><span class="n">θ₁</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">R_IM</span><span class="p">(</span><span class="n">θ₂</span><span class="p">)</span>
</pre></div>
</div>
</details><p>No translational motion of M in F is allowed and the origins, <code class="docutils literal notranslate"><span class="pre">Mo</span></code>
and <code class="docutils literal notranslate"><span class="pre">Fo</span></code>, of frames M and F respectively remain coincident. The
angles of rotation about F’s x-axis and M’s y-axis, along with their
rates, specify the state of the joint. Zero θ₁, θ₂ angles corresponds
to frames F, I, and M being coincident. Angles (θ₁, θ₂) are defined to
be positive according to the right-hand-rule with the thumb aligned in
the direction of their respective axes.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniversalJoint_[Expression].__init__(self:</span> <span class="pre">pydrake.multibody.tree.UniversalJoint_[Expression],</span> <span class="pre">name:</span> <span class="pre">str,</span> <span class="pre">frame_on_parent:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">frame_on_child:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">damping:</span> <span class="pre">float</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructor to create a universal joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B rotate as described in the class’s documentation. See
class documentation for details on the angles defining orientation.
This constructor signature creates a joint with no joint limits, i.e.
the joint position, velocity and acceleration limits are the pair
<code class="docutils literal notranslate"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. These can be set using the Joint methods
set_position_limits(), set_velocity_limits() and
set_acceleration_limits(). The first three arguments to this
constructor are those of the Joint class constructor. See the Joint
class’s documentation for details. The additional parameters are:</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt><dd><p>Viscous damping coefficient, in N⋅m⋅s, used to model losses within
the joint. See documentation of default_damping() for details on
modelling of the damping torque.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>RuntimeError if damping is negative.</strong> – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniversalJoint_[Expression].default_damping(self:</span> <span class="pre">pydrake.multibody.tree.UniversalJoint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">float</span></span></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s default damping constant in N⋅m⋅s. The
damping torque (in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τᵢ</span> <span class="pre">=</span> <span class="pre">-damping⋅ωᵢ,</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">2</span></code>
i.e. opposing motion, with ωᵢ the angular rates about the i-th axis
for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see get_angular_rates())and τᵢ the torque on child
body B about the same i-th axis.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniversalJoint_[Expression].get_angles(self:</span> <span class="pre">pydrake.multibody.tree.UniversalJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[2,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Gets the rotation angles of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint from <code class="docutils literal notranslate"><span class="pre">context</span></code>. See class
documentation for the definition of these angles.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The angle coordinates of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code>
ordered as (θ₁, θ₂).</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniversalJoint_[Expression].get_angular_rates(self:</span> <span class="pre">pydrake.multibody.tree.UniversalJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[object[2,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Gets the rates of change, in radians per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
angles (see class documentation) from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The rates of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s angles as stored in the
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniversalJoint_[Expression].get_default_angles(self:</span> <span class="pre">pydrake.multibody.tree.UniversalJoint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">numpy.ndarray[numpy.float64[2,</span> <span class="pre">1]]</span></span></dt>
<dd><p>Gets the default angles for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint. Wrapper for the more
general <code class="docutils literal notranslate"><span class="pre">Joint::default_positions()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The default angles of <code class="docutils literal notranslate"><span class="pre">this</span></code> stored in <code class="docutils literal notranslate"><span class="pre">default_positions_</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniversalJoint_[Expression].kTypeName</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniversalJoint_[Expression].set_angles(self:</span> <span class="pre">pydrake.multibody.tree.UniversalJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">angles:</span> <span class="pre">numpy.ndarray[object[2,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UniversalJoint_[Expression]</span></span></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the generalized coordinates corresponding
to the rotation angles of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals <code class="docutils literal notranslate"><span class="pre">angles</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angles</span></code>:</dt><dd><p>The desired angles in radians to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> ordered
as (θ₁, θ₂). See class documentation for details.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniversalJoint_[Expression].set_angular_rates(self:</span> <span class="pre">pydrake.multibody.tree.UniversalJoint_[Expression],</span> <span class="pre">context:</span> <span class="pre">pydrake.systems.framework.Context_[Expression],</span> <span class="pre">theta_dot:</span> <span class="pre">numpy.ndarray[object[2,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.UniversalJoint_[Expression]</span></span></dt>
<dd><p>Sets the rates of change, in radians per second, of this <code class="docutils literal notranslate"><span class="pre">this</span></code>
joint’s angles (see class documentation) to <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>. The new
rates of change get stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt><dd><p>The context of the model this joint belongs to.</p>
</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>:</dt><dd><p>The desired rates of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joints’s angles in radians
per second.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniversalJoint_[Expression].set_default_angles(self:</span> <span class="pre">pydrake.multibody.tree.UniversalJoint_[Expression],</span> <span class="pre">angles:</span> <span class="pre">numpy.ndarray[numpy.float64[2,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the default angles of this joint.</p>
<dl class="simple">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angles</span></code>:</dt><dd><p>The desired default angles of the joint</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">UniversalJoint_[Expression].set_random_angles_distribution(self:</span> <span class="pre">pydrake.multibody.tree.UniversalJoint_[Expression],</span> <span class="pre">angles:</span> <span class="pre">numpy.ndarray[object[2,</span> <span class="pre">1]])</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Sets the random distribution that angles of this joint will be
randomly sampled from. See class documentation for details on the
definition of the angles.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">WeldJoint</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint</span></code></p>
<p>This Joint fixes the relative pose between two frames as if “welding”
them together.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is templated; see <code class="xref py py-class docutils literal notranslate"><span class="pre">WeldJoint_</span></code>
for the list of instantiations.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">WeldJoint.__init__(self:</span> <span class="pre">pydrake.multibody.tree.WeldJoint,</span> <span class="pre">name:</span> <span class="pre">str,</span> <span class="pre">frame_on_parent_F:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">frame_on_child_M:</span> <span class="pre">pydrake.multibody.tree.Frame,</span> <span class="pre">X_FM:</span> <span class="pre">pydrake.math.RigidTransform)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructor for a WeldJoint between a <code class="docutils literal notranslate"><span class="pre">frame_on_parent_F</span></code> and a
<code class="docutils literal notranslate"><span class="pre">frame_on_child_M</span></code> so that their relative pose <code class="docutils literal notranslate"><span class="pre">X_FM</span></code> is fixed as
if they were “welded” together.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">WeldJoint.kTypeName</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">WeldJoint.X_FM(self:</span> <span class="pre">pydrake.multibody.tree.WeldJoint)</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RigidTransform</span></span></dt>
<dd><p>Returns the pose X_FM of frame M in F.</p>
</dd></dl>

</dd></dl>

<dl class="py template">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">WeldJoint_</span></span></dt>
<dd><p>Instantiations: <code class="xref py py-class docutils literal notranslate"><span class="pre">WeldJoint_[float]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">WeldJoint_[AutoDiffXd]</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">WeldJoint_[Expression]</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">WeldJoint_[AutoDiffXd]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd]</span></code></p>
<p>This Joint fixes the relative pose between two frames as if “welding”
them together.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">WeldJoint_[AutoDiffXd].__init__(self:</span> <span class="pre">pydrake.multibody.tree.WeldJoint_[AutoDiffXd],</span> <span class="pre">name:</span> <span class="pre">str,</span> <span class="pre">frame_on_parent_F:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">frame_on_child_M:</span> <span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd],</span> <span class="pre">X_FM:</span> <span class="pre">pydrake.math.RigidTransform)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructor for a WeldJoint between a <code class="docutils literal notranslate"><span class="pre">frame_on_parent_F</span></code> and a
<code class="docutils literal notranslate"><span class="pre">frame_on_child_M</span></code> so that their relative pose <code class="docutils literal notranslate"><span class="pre">X_FM</span></code> is fixed as
if they were “welded” together.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">WeldJoint_[AutoDiffXd].kTypeName</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">WeldJoint_[AutoDiffXd].X_FM(self:</span> <span class="pre">pydrake.multibody.tree.WeldJoint_[AutoDiffXd])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RigidTransform</span></span></dt>
<dd><p>Returns the pose X_FM of frame M in F.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">WeldJoint_[Expression]</span></span></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[Expression]</span></code></p>
<p>This Joint fixes the relative pose between two frames as if “welding”
them together.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">WeldJoint_[Expression].__init__(self:</span> <span class="pre">pydrake.multibody.tree.WeldJoint_[Expression],</span> <span class="pre">name:</span> <span class="pre">str,</span> <span class="pre">frame_on_parent_F:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">frame_on_child_M:</span> <span class="pre">pydrake.multibody.tree.Frame_[Expression],</span> <span class="pre">X_FM:</span> <span class="pre">pydrake.math.RigidTransform)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></span></dt>
<dd><p>Constructor for a WeldJoint between a <code class="docutils literal notranslate"><span class="pre">frame_on_parent_F</span></code> and a
<code class="docutils literal notranslate"><span class="pre">frame_on_child_M</span></code> so that their relative pose <code class="docutils literal notranslate"><span class="pre">X_FM</span></code> is fixed as
if they were “welded” together.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">WeldJoint_[Expression].kTypeName</span></span></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">WeldJoint_[Expression].X_FM(self:</span> <span class="pre">pydrake.multibody.tree.WeldJoint_[Expression])</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.math.RigidTransform</span></span></dt>
<dd><p>Returns the pose X_FM of frame M in F.</p>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">world_frame_index()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.FrameIndex</span></span></dt>
<dd><p>For every MultibodyPlant the <strong>world</strong> frame <em>always</em> has this unique
index and it is always zero.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">world_index()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.BodyIndex</span></span></dt>
<dd><p>For every MultibodyPlant the <strong>world</strong> body <em>always</em> has this unique
index and it is always zero.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">world_model_instance()</span> <span class="pre">-&gt;</span> <span class="pre">pydrake.multibody.tree.ModelInstanceIndex</span></span></dt>
<dd><p>Returns the model instance containing the <em>world</em> body. For every
MultibodyPlant the <strong>world</strong> body <em>always</em> has this unique model
instance and it is always zero (as described in #3088).</p>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="pydrake.multibody.rational.html" class="btn btn-neutral float-left" title="pydrake.multibody.rational" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="pydrake.perception.html" class="btn btn-neutral float-right" title="pydrake.perception" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p></p>
  </div>

  
</footer>
<script>
  /* Enables clicking for the mobile "hamburger" (three-line) menu item. */
  const siteHeader = document.querySelector('.site-header')
  const mobileButton = document.querySelector('.menu-mobile-toggle')
  const body = document.querySelector('body')

  mobileButton.addEventListener('click', function(event) {
    siteHeader.classList.toggle('open');
    body.classList.toggle('overflow-hidden');
  })
</script>
<footer class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg">
    </a>
    <div class="footer-menu">
      <ul>
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"></a>
        </li>
      </ul>
    </div>
  </div>


</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>