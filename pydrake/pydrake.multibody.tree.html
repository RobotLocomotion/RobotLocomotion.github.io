

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pydrake.multibody.tree &mdash; pydrake  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="pydrake.perception" href="pydrake.perception.html" />
    <link rel="prev" title="pydrake.multibody.plant" href="pydrake.multibody.plant.html" /> 
</head>

<body class="wy-body-for-nav">

  
<header class="site-header">
  <div class="site-header-inner contain">
    <a class="drake-logo" href="/"><img src="/images/drake-logo-white.svg"></a>
    <div class="menu-mobile-toggle">
      <span></span>
    </div>
    <nav class="site-menu">
      <ul>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/">Home</a>
        </li>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/installation.html">Installation</a>
        </li>
        <li class="site-menu-item site-menu-item-main">
          <a class="site-menu-item" href="/gallery.html">Gallery</a>
        </li>
        <li class="site-menu-item site-menu-item-main">API Documentation
          <div class="sub">
            <a class="site-menu-item" href="https://drake.mit.edu/doxygen_cxx/index.html">C++</a> <a class="site-menu-item" href="https://drake.mit.edu/pydrake/index.html">Python</a>
          </div>
        </li>
        <li class="site-menu-item site-menu-item-main">Resources
          <div class="sub">
            <a class="site-menu-item" href="/getting_help.html">Getting Help</a> <a class="site-menu-item" href="https://deepnote.com/workspace/Drake-0b3b2c53-a7ad-441b-80f8-bf8350752305/project/Tutorials-2b4fc509-aef2-417d-a40d-6071dfed9199/%2Findex.ipynb">Tutorials</a> <a class="site-menu-item" href="/python_bindings.html">Python Bindings</a> <a class="site-menu-item" href="/developers.html">For Developers</a> <a class="site-menu-item" href="/credits.html">Credits</a>
          </div>
        </li>
        <li class="github-link">
          <a class="site-menu-item" href="https://github.com/RobotLocomotion/drake">GitHub <img src="/third_party/images/GitHub-Mark-Light-64px.png"></a>
        </li>
      </ul>
    </nav>
  </div>
</header>

  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> pydrake
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search pydrake only…" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
  <form id="ddg-search-form" class="wy_form" action="https://duckduckgo.com/" method="get">
    <input type="text" name="q" placeholder="Search all of Drake…" />
    <input type="hidden" name="sites" value="drake.mit.edu" />
  </form>
</div>


          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="pydrake.all.html">pydrake.all</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.autodiffutils.html">pydrake.autodiffutils</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.common.html">pydrake.common</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.examples.html">pydrake.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.forwarddiff.html">pydrake.forwarddiff</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.geometry.html">pydrake.geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.lcm.html">pydrake.lcm</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.manipulation.html">pydrake.manipulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.math.html">pydrake.math</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="pydrake.multibody.html">pydrake.multibody</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.all.html">pydrake.multibody.all</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.benchmarks.html">pydrake.multibody.benchmarks</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.inverse_kinematics.html">pydrake.multibody.inverse_kinematics</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.math.html">pydrake.multibody.math</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.meshcat.html">pydrake.multibody.meshcat</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.optimization.html">pydrake.multibody.optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.parsing.html">pydrake.multibody.parsing</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.plant.html">pydrake.multibody.plant</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">pydrake.multibody.tree</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.perception.html">pydrake.perception</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.polynomial.html">pydrake.polynomial</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.html">pydrake.solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.symbolic.html">pydrake.symbolic</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.systems.html">pydrake.systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.trajectories.html">pydrake.trajectories</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.tutorials.html">pydrake.tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.visualization.html">pydrake.visualization</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pydrake</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="pydrake.multibody.html">pydrake.multibody</a> &raquo;</li>
        
      <li>pydrake.multibody.tree</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-pydrake.multibody.tree">
<span id="pydrake-multibody-tree"></span><h1>pydrake.multibody.tree<a class="headerlink" href="#module-pydrake.multibody.tree" title="Permalink to this headline">¶</a></h1>
<p>Bindings for MultibodyTree and related components.</p>
<dl class="attribute">
<dt id="pydrake.multibody.tree.BallRpyJoint">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">BallRpyJoint</code><a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.BallRpyJoint_[float]" title="pydrake.multibody.tree.BallRpyJoint_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.BallRpyJoint_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.BallRpyJoint_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">BallRpyJoint_</code><a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.BallRpyJoint_[float]" title="pydrake.multibody.tree.BallRpyJoint_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">BallRpyJoint_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd]" title="pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">BallRpyJoint_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.BallRpyJoint_[Expression]" title="pydrake.multibody.tree.BallRpyJoint_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">BallRpyJoint_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.BallRpyJoint_.BallRpyJoint_[float]">
<em class="property">class </em><code class="descname">BallRpyJoint_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_.BallRpyJoint_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[float]" title="pydrake.multibody.tree.Joint_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[float]</span></code></a></p>
<p>This Joint allows two bodies to rotate freely relative to one another.
That is, given a frame F attached to the parent body P and a frame M
attached to the child body B (see the Joint class’s documentation),
this Joint allows frame M to rotate freely with respect to F, while
the origins, Mo and Fo, of frames M and F respectively remain
coincident. The orientation of M relative to F is parameterized with
space <code class="docutils literal notranslate"><span class="pre">x-y-z</span></code> Euler angles.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_.BallRpyJoint_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[float], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[float], frame_on_child: pydrake.multibody.tree.Frame_[float], damping: float = 0</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_.BallRpyJoint_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor to create a ball rpy joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B rotate freely relative to one another. See this class’s
documentation for further details on the definition of these frames,
get_angles() for an explanation of the angles defining orientation,
and get_angular_velocity() for an explanation of the generalized
velocities. This constructor signature creates a joint with no joint
limits, i.e. the joint position, velocity and acceleration limits are
the pair <code class="docutils literal notranslate"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. These can be set using the Joint methods
set_position_limits(), set_velocity_limits() and
set_acceleration_limits(). The first three arguments to this
constructor are those of the Joint class constructor. See the Joint
class’s documentation for details. The additional parameters are:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, in N⋅m⋅s, used to model losses within
the joint. See documentation of damping() for details on modelling
of the damping torque.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if damping is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_.BallRpyJoint_[float].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_.BallRpyJoint_[float].damping" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s damping constant in N⋅m⋅s. The damping torque
(in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span> <span class="pre">-damping⋅ω</span></code>, i.e. opposing motion, with
ω the angular velocity of frame M in F (see get_angular_velocity())
and τ the torque on child body B (to which M is rigidly attached).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_.BallRpyJoint_[float].get_angles">
<code class="descname">get_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_.BallRpyJoint_[float].get_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rotation angles of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<p>The orientation <code class="docutils literal notranslate"><span class="pre">R_FM</span></code> of the child frame M in parent frame F is
parameterized with space <code class="docutils literal notranslate"><span class="pre">x-y-z</span></code> Euler angles (also known as
extrinsic angles). That is, the angles θr, θp, θy, correspond to a
sequence of rotations about the x̂, ŷ, ẑ axes of parent frame F,
respectively. Mathematically, rotation <code class="docutils literal notranslate"><span class="pre">R_FM</span></code> is given in terms of
angles θr, θp, θy by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">R_FM</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">=</span> <span class="n">Rz</span><span class="p">(</span><span class="n">θy</span><span class="p">)</span> <span class="o">*</span> <span class="n">Ry</span><span class="p">(</span><span class="n">θp</span><span class="p">)</span> <span class="o">*</span> <span class="n">Rx</span><span class="p">(</span><span class="n">θr</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">Rx(θ)</span></code>, <cite>Ry(θ)</cite> and <code class="docutils literal notranslate"><span class="pre">Rz(θ)</span></code> correspond to the elemental
rotations in amount of θ about the x, y and z axes respectively. Zero
θr, θp, θy angles corresponds to frames F and M being coincident.
Angles θr, θp, θy are defined to be positive according to the
right-hand-rule with the thumb aligned in the direction of their
respective axes.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Space <code class="docutils literal notranslate"><span class="pre">x-y-z</span></code> angles (extrinsic) are equivalent to Body
<code class="docutils literal notranslate"><span class="pre">z-y-x</span></code> angles (intrinsic).</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This particular choice of angles θr, θp, θy for this joint are
many times referred to as the roll, pitch and yaw angles by many
dynamicists. They are also known as the Tait-Bryan angles or
Cardan angles.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The angle coordinates of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code>
ordered as θr, θp, θy.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_.BallRpyJoint_[float].get_angular_velocity">
<code class="descname">get_angular_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_.BallRpyJoint_[float].get_angular_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves from <code class="docutils literal notranslate"><span class="pre">context</span></code> the angular velocity <code class="docutils literal notranslate"><span class="pre">w_FM</span></code> of the child
frame M in the parent frame F, expressed in F.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">w_FM</span></code>:</dt>
<dd>A vector in ℝ³ with the angular velocity of the child frame M in
the parent frame F, expressed in F. Refer to this class’s
documentation for further details and definitions of these frames.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_.BallRpyJoint_[float].get_default_angles">
<code class="descname">get_default_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_.BallRpyJoint_[float].get_default_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default angles for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint. Wrapper for the more
general <code class="docutils literal notranslate"><span class="pre">Joint::default_positions()</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The default angles of <code class="docutils literal notranslate"><span class="pre">this</span></code> stored in <code class="docutils literal notranslate"><span class="pre">default_positions_</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_.BallRpyJoint_[float].set_angles">
<code class="descname">set_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[float], context: pydrake.systems.framework.Context_[float], angles: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BallRpyJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_.BallRpyJoint_[float].set_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the generalized coordinates corresponding
to the rotation angles of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals <code class="docutils literal notranslate"><span class="pre">angles</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angles</span></code>:</dt>
<dd>The desired angles in radians to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> ordered
as θr, θp, θy. See get_angles() for details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_.BallRpyJoint_[float].set_angular_velocity">
<code class="descname">set_angular_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[float], context: pydrake.systems.framework.Context_[float], w_FM: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BallRpyJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_.BallRpyJoint_[float].set_angular_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets in <code class="docutils literal notranslate"><span class="pre">context</span></code> the state for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint so that the angular
velocity of the child frame M in the parent frame F is <code class="docutils literal notranslate"><span class="pre">w_FM</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">w_FM</span></code>:</dt>
<dd>A vector in ℝ³ with the angular velocity of the child frame M in
the parent frame F, expressed in F. Refer to this class’s
documentation for further details and definitions of these frames.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_.BallRpyJoint_[float].set_default_angles">
<code class="descname">set_default_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[float], angles: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_.BallRpyJoint_[float].set_default_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default angles of this joint.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angles</span></code>:</dt>
<dd>The desired default angles of the joint</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_.BallRpyJoint_[float].set_random_angles_distribution">
<code class="descname">set_random_angles_distribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[float], angles: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_.BallRpyJoint_[float].set_random_angles_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the random distribution that angles of this joint will be
randomly sampled from. See get_angles() for details on the angle
representation.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">BallRpyJoint_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[AutoDiffXd]" title="pydrake.multibody.tree.Joint_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd]</span></code></a></p>
<p>This Joint allows two bodies to rotate freely relative to one another.
That is, given a frame F attached to the parent body P and a frame M
attached to the child body B (see the Joint class’s documentation),
this Joint allows frame M to rotate freely with respect to F, while
the origins, Mo and Fo, of frames M and F respectively remain
coincident. The orientation of M relative to F is parameterized with
space <code class="docutils literal notranslate"><span class="pre">x-y-z</span></code> Euler angles.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_on_child: pydrake.multibody.tree.Frame_[AutoDiffXd], damping: float = 0</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor to create a ball rpy joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B rotate freely relative to one another. See this class’s
documentation for further details on the definition of these frames,
get_angles() for an explanation of the angles defining orientation,
and get_angular_velocity() for an explanation of the generalized
velocities. This constructor signature creates a joint with no joint
limits, i.e. the joint position, velocity and acceleration limits are
the pair <code class="docutils literal notranslate"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. These can be set using the Joint methods
set_position_limits(), set_velocity_limits() and
set_acceleration_limits(). The first three arguments to this
constructor are those of the Joint class constructor. See the Joint
class’s documentation for details. The additional parameters are:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, in N⋅m⋅s, used to model losses within
the joint. See documentation of damping() for details on modelling
of the damping torque.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if damping is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd].damping" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s damping constant in N⋅m⋅s. The damping torque
(in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span> <span class="pre">-damping⋅ω</span></code>, i.e. opposing motion, with
ω the angular velocity of frame M in F (see get_angular_velocity())
and τ the torque on child body B (to which M is rigidly attached).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd].get_angles">
<code class="descname">get_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd].get_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rotation angles of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<p>The orientation <code class="docutils literal notranslate"><span class="pre">R_FM</span></code> of the child frame M in parent frame F is
parameterized with space <code class="docutils literal notranslate"><span class="pre">x-y-z</span></code> Euler angles (also known as
extrinsic angles). That is, the angles θr, θp, θy, correspond to a
sequence of rotations about the x̂, ŷ, ẑ axes of parent frame F,
respectively. Mathematically, rotation <code class="docutils literal notranslate"><span class="pre">R_FM</span></code> is given in terms of
angles θr, θp, θy by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">R_FM</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">=</span> <span class="n">Rz</span><span class="p">(</span><span class="n">θy</span><span class="p">)</span> <span class="o">*</span> <span class="n">Ry</span><span class="p">(</span><span class="n">θp</span><span class="p">)</span> <span class="o">*</span> <span class="n">Rx</span><span class="p">(</span><span class="n">θr</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">Rx(θ)</span></code>, <cite>Ry(θ)</cite> and <code class="docutils literal notranslate"><span class="pre">Rz(θ)</span></code> correspond to the elemental
rotations in amount of θ about the x, y and z axes respectively. Zero
θr, θp, θy angles corresponds to frames F and M being coincident.
Angles θr, θp, θy are defined to be positive according to the
right-hand-rule with the thumb aligned in the direction of their
respective axes.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Space <code class="docutils literal notranslate"><span class="pre">x-y-z</span></code> angles (extrinsic) are equivalent to Body
<code class="docutils literal notranslate"><span class="pre">z-y-x</span></code> angles (intrinsic).</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This particular choice of angles θr, θp, θy for this joint are
many times referred to as the roll, pitch and yaw angles by many
dynamicists. They are also known as the Tait-Bryan angles or
Cardan angles.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The angle coordinates of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code>
ordered as θr, θp, θy.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd].get_angular_velocity">
<code class="descname">get_angular_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd].get_angular_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves from <code class="docutils literal notranslate"><span class="pre">context</span></code> the angular velocity <code class="docutils literal notranslate"><span class="pre">w_FM</span></code> of the child
frame M in the parent frame F, expressed in F.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">w_FM</span></code>:</dt>
<dd>A vector in ℝ³ with the angular velocity of the child frame M in
the parent frame F, expressed in F. Refer to this class’s
documentation for further details and definitions of these frames.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd].get_default_angles">
<code class="descname">get_default_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd].get_default_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default angles for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint. Wrapper for the more
general <code class="docutils literal notranslate"><span class="pre">Joint::default_positions()</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The default angles of <code class="docutils literal notranslate"><span class="pre">this</span></code> stored in <code class="docutils literal notranslate"><span class="pre">default_positions_</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd].set_angles">
<code class="descname">set_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], angles: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd].set_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the generalized coordinates corresponding
to the rotation angles of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals <code class="docutils literal notranslate"><span class="pre">angles</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angles</span></code>:</dt>
<dd>The desired angles in radians to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> ordered
as θr, θp, θy. See get_angles() for details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd].set_angular_velocity">
<code class="descname">set_angular_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], w_FM: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd].set_angular_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets in <code class="docutils literal notranslate"><span class="pre">context</span></code> the state for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint so that the angular
velocity of the child frame M in the parent frame F is <code class="docutils literal notranslate"><span class="pre">w_FM</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">w_FM</span></code>:</dt>
<dd>A vector in ℝ³ with the angular velocity of the child frame M in
the parent frame F, expressed in F. Refer to this class’s
documentation for further details and definitions of these frames.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd].set_default_angles">
<code class="descname">set_default_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd], angles: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd].set_default_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default angles of this joint.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angles</span></code>:</dt>
<dd>The desired default angles of the joint</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd].set_random_angles_distribution">
<code class="descname">set_random_angles_distribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd], angles: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[AutoDiffXd].set_random_angles_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the random distribution that angles of this joint will be
randomly sampled from. See get_angles() for details on the angle
representation.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.BallRpyJoint_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">BallRpyJoint_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[Expression]" title="pydrake.multibody.tree.Joint_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[Expression]</span></code></a></p>
<p>This Joint allows two bodies to rotate freely relative to one another.
That is, given a frame F attached to the parent body P and a frame M
attached to the child body B (see the Joint class’s documentation),
this Joint allows frame M to rotate freely with respect to F, while
the origins, Mo and Fo, of frames M and F respectively remain
coincident. The orientation of M relative to F is parameterized with
space <code class="docutils literal notranslate"><span class="pre">x-y-z</span></code> Euler angles.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[Expression], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[Expression], frame_on_child: pydrake.multibody.tree.Frame_[Expression], damping: float = 0</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor to create a ball rpy joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B rotate freely relative to one another. See this class’s
documentation for further details on the definition of these frames,
get_angles() for an explanation of the angles defining orientation,
and get_angular_velocity() for an explanation of the generalized
velocities. This constructor signature creates a joint with no joint
limits, i.e. the joint position, velocity and acceleration limits are
the pair <code class="docutils literal notranslate"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. These can be set using the Joint methods
set_position_limits(), set_velocity_limits() and
set_acceleration_limits(). The first three arguments to this
constructor are those of the Joint class constructor. See the Joint
class’s documentation for details. The additional parameters are:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, in N⋅m⋅s, used to model losses within
the joint. See documentation of damping() for details on modelling
of the damping torque.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if damping is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[Expression].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[Expression].damping" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s damping constant in N⋅m⋅s. The damping torque
(in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span> <span class="pre">-damping⋅ω</span></code>, i.e. opposing motion, with
ω the angular velocity of frame M in F (see get_angular_velocity())
and τ the torque on child body B (to which M is rigidly attached).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[Expression].get_angles">
<code class="descname">get_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[Expression].get_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rotation angles of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<p>The orientation <code class="docutils literal notranslate"><span class="pre">R_FM</span></code> of the child frame M in parent frame F is
parameterized with space <code class="docutils literal notranslate"><span class="pre">x-y-z</span></code> Euler angles (also known as
extrinsic angles). That is, the angles θr, θp, θy, correspond to a
sequence of rotations about the x̂, ŷ, ẑ axes of parent frame F,
respectively. Mathematically, rotation <code class="docutils literal notranslate"><span class="pre">R_FM</span></code> is given in terms of
angles θr, θp, θy by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">R_FM</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">=</span> <span class="n">Rz</span><span class="p">(</span><span class="n">θy</span><span class="p">)</span> <span class="o">*</span> <span class="n">Ry</span><span class="p">(</span><span class="n">θp</span><span class="p">)</span> <span class="o">*</span> <span class="n">Rx</span><span class="p">(</span><span class="n">θr</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">Rx(θ)</span></code>, <cite>Ry(θ)</cite> and <code class="docutils literal notranslate"><span class="pre">Rz(θ)</span></code> correspond to the elemental
rotations in amount of θ about the x, y and z axes respectively. Zero
θr, θp, θy angles corresponds to frames F and M being coincident.
Angles θr, θp, θy are defined to be positive according to the
right-hand-rule with the thumb aligned in the direction of their
respective axes.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Space <code class="docutils literal notranslate"><span class="pre">x-y-z</span></code> angles (extrinsic) are equivalent to Body
<code class="docutils literal notranslate"><span class="pre">z-y-x</span></code> angles (intrinsic).</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This particular choice of angles θr, θp, θy for this joint are
many times referred to as the roll, pitch and yaw angles by many
dynamicists. They are also known as the Tait-Bryan angles or
Cardan angles.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The angle coordinates of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code>
ordered as θr, θp, θy.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[Expression].get_angular_velocity">
<code class="descname">get_angular_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[Expression].get_angular_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves from <code class="docutils literal notranslate"><span class="pre">context</span></code> the angular velocity <code class="docutils literal notranslate"><span class="pre">w_FM</span></code> of the child
frame M in the parent frame F, expressed in F.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">w_FM</span></code>:</dt>
<dd>A vector in ℝ³ with the angular velocity of the child frame M in
the parent frame F, expressed in F. Refer to this class’s
documentation for further details and definitions of these frames.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[Expression].get_default_angles">
<code class="descname">get_default_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[Expression].get_default_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default angles for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint. Wrapper for the more
general <code class="docutils literal notranslate"><span class="pre">Joint::default_positions()</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The default angles of <code class="docutils literal notranslate"><span class="pre">this</span></code> stored in <code class="docutils literal notranslate"><span class="pre">default_positions_</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[Expression].set_angles">
<code class="descname">set_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[Expression], context: pydrake.systems.framework.Context_[Expression], angles: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BallRpyJoint_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[Expression].set_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the generalized coordinates corresponding
to the rotation angles of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals <code class="docutils literal notranslate"><span class="pre">angles</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angles</span></code>:</dt>
<dd>The desired angles in radians to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> ordered
as θr, θp, θy. See get_angles() for details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[Expression].set_angular_velocity">
<code class="descname">set_angular_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[Expression], context: pydrake.systems.framework.Context_[Expression], w_FM: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BallRpyJoint_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[Expression].set_angular_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets in <code class="docutils literal notranslate"><span class="pre">context</span></code> the state for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint so that the angular
velocity of the child frame M in the parent frame F is <code class="docutils literal notranslate"><span class="pre">w_FM</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">w_FM</span></code>:</dt>
<dd>A vector in ℝ³ with the angular velocity of the child frame M in
the parent frame F, expressed in F. Refer to this class’s
documentation for further details and definitions of these frames.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[Expression].set_default_angles">
<code class="descname">set_default_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[Expression], angles: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[Expression].set_default_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default angles of this joint.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angles</span></code>:</dt>
<dd>The desired default angles of the joint</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[Expression].set_random_angles_distribution">
<code class="descname">set_random_angles_distribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[Expression], angles: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[Expression].set_random_angles_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the random distribution that angles of this joint will be
randomly sampled from. See get_angles() for details on the angle
representation.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.BallRpyJoint_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">BallRpyJoint_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[float]" title="pydrake.multibody.tree.Joint_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[float]</span></code></a></p>
<p>This Joint allows two bodies to rotate freely relative to one another.
That is, given a frame F attached to the parent body P and a frame M
attached to the child body B (see the Joint class’s documentation),
this Joint allows frame M to rotate freely with respect to F, while
the origins, Mo and Fo, of frames M and F respectively remain
coincident. The orientation of M relative to F is parameterized with
space <code class="docutils literal notranslate"><span class="pre">x-y-z</span></code> Euler angles.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[float], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[float], frame_on_child: pydrake.multibody.tree.Frame_[float], damping: float = 0</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor to create a ball rpy joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B rotate freely relative to one another. See this class’s
documentation for further details on the definition of these frames,
get_angles() for an explanation of the angles defining orientation,
and get_angular_velocity() for an explanation of the generalized
velocities. This constructor signature creates a joint with no joint
limits, i.e. the joint position, velocity and acceleration limits are
the pair <code class="docutils literal notranslate"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. These can be set using the Joint methods
set_position_limits(), set_velocity_limits() and
set_acceleration_limits(). The first three arguments to this
constructor are those of the Joint class constructor. See the Joint
class’s documentation for details. The additional parameters are:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, in N⋅m⋅s, used to model losses within
the joint. See documentation of damping() for details on modelling
of the damping torque.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if damping is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[float].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[float].damping" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s damping constant in N⋅m⋅s. The damping torque
(in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span> <span class="pre">-damping⋅ω</span></code>, i.e. opposing motion, with
ω the angular velocity of frame M in F (see get_angular_velocity())
and τ the torque on child body B (to which M is rigidly attached).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[float].get_angles">
<code class="descname">get_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[float].get_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rotation angles of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<p>The orientation <code class="docutils literal notranslate"><span class="pre">R_FM</span></code> of the child frame M in parent frame F is
parameterized with space <code class="docutils literal notranslate"><span class="pre">x-y-z</span></code> Euler angles (also known as
extrinsic angles). That is, the angles θr, θp, θy, correspond to a
sequence of rotations about the x̂, ŷ, ẑ axes of parent frame F,
respectively. Mathematically, rotation <code class="docutils literal notranslate"><span class="pre">R_FM</span></code> is given in terms of
angles θr, θp, θy by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">R_FM</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">=</span> <span class="n">Rz</span><span class="p">(</span><span class="n">θy</span><span class="p">)</span> <span class="o">*</span> <span class="n">Ry</span><span class="p">(</span><span class="n">θp</span><span class="p">)</span> <span class="o">*</span> <span class="n">Rx</span><span class="p">(</span><span class="n">θr</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">Rx(θ)</span></code>, <cite>Ry(θ)</cite> and <code class="docutils literal notranslate"><span class="pre">Rz(θ)</span></code> correspond to the elemental
rotations in amount of θ about the x, y and z axes respectively. Zero
θr, θp, θy angles corresponds to frames F and M being coincident.
Angles θr, θp, θy are defined to be positive according to the
right-hand-rule with the thumb aligned in the direction of their
respective axes.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Space <code class="docutils literal notranslate"><span class="pre">x-y-z</span></code> angles (extrinsic) are equivalent to Body
<code class="docutils literal notranslate"><span class="pre">z-y-x</span></code> angles (intrinsic).</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This particular choice of angles θr, θp, θy for this joint are
many times referred to as the roll, pitch and yaw angles by many
dynamicists. They are also known as the Tait-Bryan angles or
Cardan angles.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The angle coordinates of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code>
ordered as θr, θp, θy.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[float].get_angular_velocity">
<code class="descname">get_angular_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[float].get_angular_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves from <code class="docutils literal notranslate"><span class="pre">context</span></code> the angular velocity <code class="docutils literal notranslate"><span class="pre">w_FM</span></code> of the child
frame M in the parent frame F, expressed in F.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">w_FM</span></code>:</dt>
<dd>A vector in ℝ³ with the angular velocity of the child frame M in
the parent frame F, expressed in F. Refer to this class’s
documentation for further details and definitions of these frames.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[float].get_default_angles">
<code class="descname">get_default_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[float].get_default_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default angles for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint. Wrapper for the more
general <code class="docutils literal notranslate"><span class="pre">Joint::default_positions()</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The default angles of <code class="docutils literal notranslate"><span class="pre">this</span></code> stored in <code class="docutils literal notranslate"><span class="pre">default_positions_</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[float].set_angles">
<code class="descname">set_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[float], context: pydrake.systems.framework.Context_[float], angles: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BallRpyJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[float].set_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the generalized coordinates corresponding
to the rotation angles of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals <code class="docutils literal notranslate"><span class="pre">angles</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angles</span></code>:</dt>
<dd>The desired angles in radians to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> ordered
as θr, θp, θy. See get_angles() for details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[float].set_angular_velocity">
<code class="descname">set_angular_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[float], context: pydrake.systems.framework.Context_[float], w_FM: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BallRpyJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[float].set_angular_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets in <code class="docutils literal notranslate"><span class="pre">context</span></code> the state for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint so that the angular
velocity of the child frame M in the parent frame F is <code class="docutils literal notranslate"><span class="pre">w_FM</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">w_FM</span></code>:</dt>
<dd>A vector in ℝ³ with the angular velocity of the child frame M in
the parent frame F, expressed in F. Refer to this class’s
documentation for further details and definitions of these frames.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[float].set_default_angles">
<code class="descname">set_default_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[float], angles: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[float].set_default_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default angles of this joint.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angles</span></code>:</dt>
<dd>The desired default angles of the joint</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BallRpyJoint_[float].set_random_angles_distribution">
<code class="descname">set_random_angles_distribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BallRpyJoint_[float], angles: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.BallRpyJoint_[float].set_random_angles_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the random distribution that angles of this joint will be
randomly sampled from. See get_angles() for details on the angle
representation.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.Body">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">Body</code><a class="headerlink" href="#pydrake.multibody.tree.Body" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.Body_[float]" title="pydrake.multibody.tree.Body_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Body_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.Body_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">Body_</code><a class="headerlink" href="#pydrake.multibody.tree.Body_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.Body_[float]" title="pydrake.multibody.tree.Body_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Body_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.Body_[AutoDiffXd]" title="pydrake.multibody.tree.Body_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Body_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.Body_[Expression]" title="pydrake.multibody.tree.Body_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Body_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.Body_.Body_[float]">
<em class="property">class </em><code class="descname">Body_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.Body_.Body_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>%Body provides the general abstraction of a body with an API that
makes no assumption about whether a body is rigid or deformable and
neither does it make any assumptions about the underlying physical
model or approximation. As an element or component of a MultibodyTree,
a body is a MultibodyElement, and therefore it has a unique index of
type BodyIndex within the multibody tree it belongs to.</p>
<p>A Body contains a unique BodyFrame; see BodyFrame class documentation
for more information.</p>
<dl class="attribute">
<dt id="pydrake.multibody.tree.Body_.Body_[float].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.Body_.Body_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_.Body_[float].AddInForce">
<code class="descname">AddInForce</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float], context: pydrake.systems.framework.Context_[float], p_BP_E: numpy.ndarray[numpy.float64[3, 1]], F_Bp_E: pydrake.multibody.math.SpatialForce_[float], frame_E: pydrake.multibody.tree.Frame_[float], forces: drake::multibody::MultibodyForces&lt;double&gt;</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Body_.Body_[float].AddInForce" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the spatial force on <code class="docutils literal notranslate"><span class="pre">this</span></code> body B, applied at point P and
expressed in a frame E into <code class="docutils literal notranslate"><span class="pre">forces</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context containing the current state of the model.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BP_E</span></code>:</dt>
<dd>The position of point P in B, expressed in a frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">F_Bp_E</span></code>:</dt>
<dd>The spatial force to be applied on body B at point P, expressed in
frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt>
<dd>The expressed-in frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">forces</span></code>:</dt>
<dd>A multibody forces objects that on output will have <code class="docutils literal notranslate"><span class="pre">F_Bp_E</span></code>
added.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal notranslate"><span class="pre">forces</span></code> is nullptr or if it is not consistent</li>
<li>with the model to which <code class="docutils literal notranslate"><span class="pre">this</span></code> body belongs.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_.Body_[float].AddInForceInWorld">
<code class="descname">AddInForceInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float], context: pydrake.systems.framework.Context_[float], F_Bo_W: pydrake.multibody.math.SpatialForce_[float], forces: drake::multibody::MultibodyForces&lt;double&gt;</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Body_.Body_[float].AddInForceInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the spatial force on <code class="docutils literal notranslate"><span class="pre">this</span></code> body B, applied at body B’s origin
Bo and expressed in the world frame W into <code class="docutils literal notranslate"><span class="pre">forces</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_.Body_[float].body_frame">
<code class="descname">body_frame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BodyFrame_[float]<a class="headerlink" href="#pydrake.multibody.tree.Body_.Body_[float].body_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the associated BodyFrame.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_.Body_[float].CalcCenterOfMassInBodyFrame">
<code class="descname">CalcCenterOfMassInBodyFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Body_.Body_[float].CalcCenterOfMassInBodyFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Computes the center of mass <code class="docutils literal notranslate"><span class="pre">p_BoBcm_B</span></code> (or <code class="docutils literal notranslate"><span class="pre">p_Bcm</span></code> for
short) of this body measured from this body’s frame origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code> and
expressed in the body frame B.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_.Body_[float].CalcSpatialInertiaInBodyFrame">
<code class="descname">CalcSpatialInertiaInBodyFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; drake::multibody::SpatialInertia&lt;double&gt;<a class="headerlink" href="#pydrake.multibody.tree.Body_.Body_[float].CalcSpatialInertiaInBodyFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Computes the SpatialInertia <code class="docutils literal notranslate"><span class="pre">I_BBo_B</span></code> of <code class="docutils literal notranslate"><span class="pre">this</span></code> body
about its frame origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code> (not necessarily its center of mass) and
expressed in its body frame <code class="docutils literal notranslate"><span class="pre">B</span></code>. In general, the spatial inertia of
a body is a function of state. Consider for instance the case of a
flexible body for which its spatial inertia in the body frame depends
on the generalized coordinates describing its state of deformation. As
a particular case, the spatial inertia of a RigidBody in its body
frame is constant.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_.Body_[float].default_mass">
<code class="descname">default_mass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.Body_.Body_[float].default_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default mass (not Context dependent) for <code class="docutils literal notranslate"><span class="pre">this</span></code> body. In
general, a body’s mass can be a Context-dependent parameter that is
returned by the method get_mass(). When a body’s mass is a parameter,
the value returned by default_mass() is used to initialize the mass
parameter in the Context.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_.Body_[float].EvalPoseInWorld">
<code class="descname">EvalPoseInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.multibody.tree.Body_.Body_[float].EvalPoseInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pose <code class="docutils literal notranslate"><span class="pre">X_WB</span></code> of this body B in the world frame W as a
function of the state of the model stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_.Body_[float].EvalSpatialAccelerationInWorld">
<code class="descname">EvalSpatialAccelerationInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[float]<a class="headerlink" href="#pydrake.multibody.tree.Body_.Body_[float].EvalSpatialAccelerationInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates A_WB, <code class="docutils literal notranslate"><span class="pre">this</span></code> body B’s spatial acceleration in the world
frame W.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>Contains the state of the model.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">A_WB_W</span></code>:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">this</span></code> body B’s spatial acceleration in the world frame W,
expressed in W (for point Bo, the body’s origin).</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When cached values are out of sync with the state stored in
context, this method performs an expensive forward dynamics
computation, whereas once evaluated, successive calls to this
method are inexpensive.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_.Body_[float].EvalSpatialVelocityInWorld">
<code class="descname">EvalSpatialVelocityInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[float]<a class="headerlink" href="#pydrake.multibody.tree.Body_.Body_[float].EvalSpatialVelocityInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates V_WB, <code class="docutils literal notranslate"><span class="pre">this</span></code> body B’s spatial velocity in the world frame
W.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>Contains the state of the model.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">V_WB_W</span></code>:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">this</span></code> body B’s spatial velocity in the world frame W, expressed
in W (for point Bo, the body frame’s origin).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_.Body_[float].floating_position_suffix">
<code class="descname">floating_position_suffix</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float], arg0: int</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Body_.Body_[float].floating_position_suffix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string suffix (e.g. to be appended to the name()) to
identify the <code class="docutils literal notranslate"><span class="pre">k`th</span> <span class="pre">position</span> <span class="pre">in</span> <span class="pre">the</span> <span class="pre">floating</span> <span class="pre">base.</span>
<span class="pre">``position_index_in_body</span></code> must be in [0, 7) if
<cite>has_quaternion_dofs()`</cite> is true, otherwise in [0, 6).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first">RuntimeError if is_floating() is false.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called pre-finalize, see</li>
<li>MultibodyPlant::Finalize().</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_.Body_[float].floating_positions_start">
<code class="descname">floating_positions_start</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Body_.Body_[float].floating_positions_start" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) For floating bodies (see is_floating()) this method returns
the index of the first generalized position in the state vector for a
MultibodyPlant model. Positions for this body are then contiguous
starting at this index. When a floating body is modeled with a
quaternion mobilizer (see has_quaternion_dofs()), the four consecutive
entries in the state starting at this index correspond to the
quaternion that parametrizes this body’s orientation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called pre-finalize, see</li>
<li>MultibodyPlant::Finalize().</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_.Body_[float].floating_velocities_start">
<code class="descname">floating_velocities_start</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Body_.Body_[float].floating_velocities_start" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) For floating bodies (see is_floating()) this method returns
the index of the first generalized velocity in the state vector for a
MultibodyPlant model. Velocities for this body are then contiguous
starting at this index.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called pre-finalize, see</li>
<li>MultibodyPlant::Finalize().</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_.Body_[float].floating_velocity_suffix">
<code class="descname">floating_velocity_suffix</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float], arg0: int</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Body_.Body_[float].floating_velocity_suffix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string suffix (e.g. to be appended to the name()) to
identify the <cite>k`th velocity in the floating base.
``velocity_index_in_body`</cite> must be in [0,6).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first">RuntimeError if is_floating() is false.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called pre-finalize, see</li>
<li>MultibodyPlant::Finalize().</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_.Body_[float].get_mass">
<code class="descname">get_mass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.Body_.Body_[float].get_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Returns the mass of this body stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_.Body_[float].get_num_flexible_positions">
<code class="descname">get_num_flexible_positions</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Body_.Body_[float].get_num_flexible_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of generalized positions q describing flexible
deformations for this body. A rigid body will therefore return zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_.Body_[float].get_num_flexible_velocities">
<code class="descname">get_num_flexible_velocities</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Body_.Body_[float].get_num_flexible_velocities" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of generalized velocities v describing flexible
deformations for this body. A rigid body will therefore return zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_.Body_[float].GetForceInWorld">
<code class="descname">GetForceInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float], context: pydrake.systems.framework.Context_[float], forces: drake::multibody::MultibodyForces&lt;double&gt;</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[float]<a class="headerlink" href="#pydrake.multibody.tree.Body_.Body_[float].GetForceInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the sptatial force on <code class="docutils literal notranslate"><span class="pre">this</span></code> body B from <code class="docutils literal notranslate"><span class="pre">forces</span></code> as F_BBo_W:
applied at body B’s origin Bo and expressed in world frame W.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_.Body_[float].GetParentPlant">
<code class="descname">GetParentPlant</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float]</em><span class="sig-paren">)</span> &#x2192; drake::multibody::MultibodyPlant&lt;double&gt;<a class="headerlink" href="#pydrake.multibody.tree.Body_.Body_[float].GetParentPlant" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_.Body_[float].has_quaternion_dofs">
<code class="descname">has_quaternion_dofs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.Body_.Body_[float].has_quaternion_dofs" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) If <code class="docutils literal notranslate"><span class="pre">True</span></code>, this body is a floating body modeled with a
quaternion floating mobilizer. By implication, is_floating() is also
<code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">floating_positions_start(), floating_velocities_start().</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called pre-finalize, see</li>
<li>MultibodyPlant::Finalize().</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_.Body_[float].index">
<code class="descname">index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BodyIndex<a class="headerlink" href="#pydrake.multibody.tree.Body_.Body_[float].index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_.Body_[float].is_floating">
<code class="descname">is_floating</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.Body_.Body_[float].is_floating" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">this</span></code> body is granted 6-dofs by a
Mobilizer.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A floating body is not necessarily modeled with a quaternion
mobilizer, see has_quaternion_dofs(). Alternative options include
a space XYZ parametrization of rotations, see SpaceXYZMobilizer.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called pre-finalize, see</li>
<li>MultibodyPlant::Finalize().</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_.Body_[float].is_locked">
<code class="descname">is_locked</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.Body_.Body_[float].is_locked" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">true if the body is locked, false otherwise.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_.Body_[float].Lock">
<code class="descname">Lock</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Body_.Body_[float].Lock" title="Permalink to this definition">¶</a></dt>
<dd><p>For a floating body, lock its implicit inboard joint. Its generalized
velocities will be 0 until it is unlocked. Locking is not yet
supported for continuous-mode systems.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if this body is not a floating body, or if the parent</li>
<li>model uses continuous state.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_.Body_[float].model_instance">
<code class="descname">model_instance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.Body_.Body_[float].model_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_.Body_[float].name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Body_.Body_[float].name" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the <code class="docutils literal notranslate"><span class="pre">name</span></code> associated with <code class="docutils literal notranslate"><span class="pre">this</span></code> body. The name will never
be empty.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_.Body_[float].Unlock">
<code class="descname">Unlock</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Body_.Body_[float].Unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>For a floating body, unlock its implicit inboard joint. Unlocking is
not yet supported for continuous-mode systems.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if this body is not a floating body, or if the parent</li>
<li>model uses continuous state.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.Body_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">Body_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.Body_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>%Body provides the general abstraction of a body with an API that
makes no assumption about whether a body is rigid or deformable and
neither does it make any assumptions about the underlying physical
model or approximation. As an element or component of a MultibodyTree,
a body is a MultibodyElement, and therefore it has a unique index of
type BodyIndex within the multibody tree it belongs to.</p>
<p>A Body contains a unique BodyFrame; see BodyFrame class documentation
for more information.</p>
<dl class="attribute">
<dt id="pydrake.multibody.tree.Body_[AutoDiffXd].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.Body_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[AutoDiffXd].AddInForce">
<code class="descname">AddInForce</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], p_BP_E: numpy.ndarray[object[3, 1]], F_Bp_E: pydrake.multibody.math.SpatialForce_[AutoDiffXd], frame_E: pydrake.multibody.tree.Frame_[AutoDiffXd], forces: drake::multibody::MultibodyForces&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Body_[AutoDiffXd].AddInForce" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the spatial force on <code class="docutils literal notranslate"><span class="pre">this</span></code> body B, applied at point P and
expressed in a frame E into <code class="docutils literal notranslate"><span class="pre">forces</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context containing the current state of the model.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BP_E</span></code>:</dt>
<dd>The position of point P in B, expressed in a frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">F_Bp_E</span></code>:</dt>
<dd>The spatial force to be applied on body B at point P, expressed in
frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt>
<dd>The expressed-in frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">forces</span></code>:</dt>
<dd>A multibody forces objects that on output will have <code class="docutils literal notranslate"><span class="pre">F_Bp_E</span></code>
added.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal notranslate"><span class="pre">forces</span></code> is nullptr or if it is not consistent</li>
<li>with the model to which <code class="docutils literal notranslate"><span class="pre">this</span></code> body belongs.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[AutoDiffXd].AddInForceInWorld">
<code class="descname">AddInForceInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], F_Bo_W: pydrake.multibody.math.SpatialForce_[AutoDiffXd], forces: drake::multibody::MultibodyForces&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Body_[AutoDiffXd].AddInForceInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the spatial force on <code class="docutils literal notranslate"><span class="pre">this</span></code> body B, applied at body B’s origin
Bo and expressed in the world frame W into <code class="docutils literal notranslate"><span class="pre">forces</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[AutoDiffXd].body_frame">
<code class="descname">body_frame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BodyFrame_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.Body_[AutoDiffXd].body_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the associated BodyFrame.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[AutoDiffXd].CalcCenterOfMassInBodyFrame">
<code class="descname">CalcCenterOfMassInBodyFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Body_[AutoDiffXd].CalcCenterOfMassInBodyFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Computes the center of mass <code class="docutils literal notranslate"><span class="pre">p_BoBcm_B</span></code> (or <code class="docutils literal notranslate"><span class="pre">p_Bcm</span></code> for
short) of this body measured from this body’s frame origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code> and
expressed in the body frame B.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[AutoDiffXd].CalcSpatialInertiaInBodyFrame">
<code class="descname">CalcSpatialInertiaInBodyFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; drake::multibody::SpatialInertia&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;<a class="headerlink" href="#pydrake.multibody.tree.Body_[AutoDiffXd].CalcSpatialInertiaInBodyFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Computes the SpatialInertia <code class="docutils literal notranslate"><span class="pre">I_BBo_B</span></code> of <code class="docutils literal notranslate"><span class="pre">this</span></code> body
about its frame origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code> (not necessarily its center of mass) and
expressed in its body frame <code class="docutils literal notranslate"><span class="pre">B</span></code>. In general, the spatial inertia of
a body is a function of state. Consider for instance the case of a
flexible body for which its spatial inertia in the body frame depends
on the generalized coordinates describing its state of deformation. As
a particular case, the spatial inertia of a RigidBody in its body
frame is constant.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[AutoDiffXd].default_mass">
<code class="descname">default_mass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.Body_[AutoDiffXd].default_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default mass (not Context dependent) for <code class="docutils literal notranslate"><span class="pre">this</span></code> body. In
general, a body’s mass can be a Context-dependent parameter that is
returned by the method get_mass(). When a body’s mass is a parameter,
the value returned by default_mass() is used to initialize the mass
parameter in the Context.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[AutoDiffXd].EvalPoseInWorld">
<code class="descname">EvalPoseInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.Body_[AutoDiffXd].EvalPoseInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pose <code class="docutils literal notranslate"><span class="pre">X_WB</span></code> of this body B in the world frame W as a
function of the state of the model stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[AutoDiffXd].EvalSpatialAccelerationInWorld">
<code class="descname">EvalSpatialAccelerationInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.Body_[AutoDiffXd].EvalSpatialAccelerationInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates A_WB, <code class="docutils literal notranslate"><span class="pre">this</span></code> body B’s spatial acceleration in the world
frame W.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>Contains the state of the model.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">A_WB_W</span></code>:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">this</span></code> body B’s spatial acceleration in the world frame W,
expressed in W (for point Bo, the body’s origin).</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When cached values are out of sync with the state stored in
context, this method performs an expensive forward dynamics
computation, whereas once evaluated, successive calls to this
method are inexpensive.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[AutoDiffXd].EvalSpatialVelocityInWorld">
<code class="descname">EvalSpatialVelocityInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.Body_[AutoDiffXd].EvalSpatialVelocityInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates V_WB, <code class="docutils literal notranslate"><span class="pre">this</span></code> body B’s spatial velocity in the world frame
W.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>Contains the state of the model.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">V_WB_W</span></code>:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">this</span></code> body B’s spatial velocity in the world frame W, expressed
in W (for point Bo, the body frame’s origin).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[AutoDiffXd].floating_position_suffix">
<code class="descname">floating_position_suffix</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[AutoDiffXd], arg0: int</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Body_[AutoDiffXd].floating_position_suffix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string suffix (e.g. to be appended to the name()) to
identify the <code class="docutils literal notranslate"><span class="pre">k`th</span> <span class="pre">position</span> <span class="pre">in</span> <span class="pre">the</span> <span class="pre">floating</span> <span class="pre">base.</span>
<span class="pre">``position_index_in_body</span></code> must be in [0, 7) if
<cite>has_quaternion_dofs()`</cite> is true, otherwise in [0, 6).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first">RuntimeError if is_floating() is false.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called pre-finalize, see</li>
<li>MultibodyPlant::Finalize().</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[AutoDiffXd].floating_positions_start">
<code class="descname">floating_positions_start</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Body_[AutoDiffXd].floating_positions_start" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) For floating bodies (see is_floating()) this method returns
the index of the first generalized position in the state vector for a
MultibodyPlant model. Positions for this body are then contiguous
starting at this index. When a floating body is modeled with a
quaternion mobilizer (see has_quaternion_dofs()), the four consecutive
entries in the state starting at this index correspond to the
quaternion that parametrizes this body’s orientation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called pre-finalize, see</li>
<li>MultibodyPlant::Finalize().</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[AutoDiffXd].floating_velocities_start">
<code class="descname">floating_velocities_start</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Body_[AutoDiffXd].floating_velocities_start" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) For floating bodies (see is_floating()) this method returns
the index of the first generalized velocity in the state vector for a
MultibodyPlant model. Velocities for this body are then contiguous
starting at this index.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called pre-finalize, see</li>
<li>MultibodyPlant::Finalize().</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[AutoDiffXd].floating_velocity_suffix">
<code class="descname">floating_velocity_suffix</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[AutoDiffXd], arg0: int</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Body_[AutoDiffXd].floating_velocity_suffix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string suffix (e.g. to be appended to the name()) to
identify the <cite>k`th velocity in the floating base.
``velocity_index_in_body`</cite> must be in [0,6).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first">RuntimeError if is_floating() is false.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called pre-finalize, see</li>
<li>MultibodyPlant::Finalize().</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[AutoDiffXd].get_mass">
<code class="descname">get_mass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.autodiffutils.AutoDiffXd<a class="headerlink" href="#pydrake.multibody.tree.Body_[AutoDiffXd].get_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Returns the mass of this body stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[AutoDiffXd].get_num_flexible_positions">
<code class="descname">get_num_flexible_positions</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Body_[AutoDiffXd].get_num_flexible_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of generalized positions q describing flexible
deformations for this body. A rigid body will therefore return zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[AutoDiffXd].get_num_flexible_velocities">
<code class="descname">get_num_flexible_velocities</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Body_[AutoDiffXd].get_num_flexible_velocities" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of generalized velocities v describing flexible
deformations for this body. A rigid body will therefore return zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[AutoDiffXd].GetForceInWorld">
<code class="descname">GetForceInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], forces: drake::multibody::MultibodyForces&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.Body_[AutoDiffXd].GetForceInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the sptatial force on <code class="docutils literal notranslate"><span class="pre">this</span></code> body B from <code class="docutils literal notranslate"><span class="pre">forces</span></code> as F_BBo_W:
applied at body B’s origin Bo and expressed in world frame W.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[AutoDiffXd].GetParentPlant">
<code class="descname">GetParentPlant</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; drake::multibody::MultibodyPlant&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;<a class="headerlink" href="#pydrake.multibody.tree.Body_[AutoDiffXd].GetParentPlant" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[AutoDiffXd].has_quaternion_dofs">
<code class="descname">has_quaternion_dofs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.Body_[AutoDiffXd].has_quaternion_dofs" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) If <code class="docutils literal notranslate"><span class="pre">True</span></code>, this body is a floating body modeled with a
quaternion floating mobilizer. By implication, is_floating() is also
<code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">floating_positions_start(), floating_velocities_start().</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called pre-finalize, see</li>
<li>MultibodyPlant::Finalize().</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[AutoDiffXd].index">
<code class="descname">index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BodyIndex<a class="headerlink" href="#pydrake.multibody.tree.Body_[AutoDiffXd].index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[AutoDiffXd].is_floating">
<code class="descname">is_floating</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.Body_[AutoDiffXd].is_floating" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">this</span></code> body is granted 6-dofs by a
Mobilizer.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A floating body is not necessarily modeled with a quaternion
mobilizer, see has_quaternion_dofs(). Alternative options include
a space XYZ parametrization of rotations, see SpaceXYZMobilizer.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called pre-finalize, see</li>
<li>MultibodyPlant::Finalize().</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[AutoDiffXd].is_locked">
<code class="descname">is_locked</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.Body_[AutoDiffXd].is_locked" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">true if the body is locked, false otherwise.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[AutoDiffXd].Lock">
<code class="descname">Lock</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Body_[AutoDiffXd].Lock" title="Permalink to this definition">¶</a></dt>
<dd><p>For a floating body, lock its implicit inboard joint. Its generalized
velocities will be 0 until it is unlocked. Locking is not yet
supported for continuous-mode systems.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if this body is not a floating body, or if the parent</li>
<li>model uses continuous state.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[AutoDiffXd].model_instance">
<code class="descname">model_instance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.Body_[AutoDiffXd].model_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[AutoDiffXd].name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Body_[AutoDiffXd].name" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the <code class="docutils literal notranslate"><span class="pre">name</span></code> associated with <code class="docutils literal notranslate"><span class="pre">this</span></code> body. The name will never
be empty.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[AutoDiffXd].Unlock">
<code class="descname">Unlock</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Body_[AutoDiffXd].Unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>For a floating body, unlock its implicit inboard joint. Unlocking is
not yet supported for continuous-mode systems.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if this body is not a floating body, or if the parent</li>
<li>model uses continuous state.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.Body_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">Body_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.Body_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>%Body provides the general abstraction of a body with an API that
makes no assumption about whether a body is rigid or deformable and
neither does it make any assumptions about the underlying physical
model or approximation. As an element or component of a MultibodyTree,
a body is a MultibodyElement, and therefore it has a unique index of
type BodyIndex within the multibody tree it belongs to.</p>
<p>A Body contains a unique BodyFrame; see BodyFrame class documentation
for more information.</p>
<dl class="attribute">
<dt id="pydrake.multibody.tree.Body_[Expression].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.Body_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[Expression].AddInForce">
<code class="descname">AddInForce</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[Expression], context: pydrake.systems.framework.Context_[Expression], p_BP_E: numpy.ndarray[object[3, 1]], F_Bp_E: pydrake.multibody.math.SpatialForce_[Expression], frame_E: pydrake.multibody.tree.Frame_[Expression], forces: drake::multibody::MultibodyForces&lt;drake::symbolic::Expression&gt;</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Body_[Expression].AddInForce" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the spatial force on <code class="docutils literal notranslate"><span class="pre">this</span></code> body B, applied at point P and
expressed in a frame E into <code class="docutils literal notranslate"><span class="pre">forces</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context containing the current state of the model.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BP_E</span></code>:</dt>
<dd>The position of point P in B, expressed in a frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">F_Bp_E</span></code>:</dt>
<dd>The spatial force to be applied on body B at point P, expressed in
frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt>
<dd>The expressed-in frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">forces</span></code>:</dt>
<dd>A multibody forces objects that on output will have <code class="docutils literal notranslate"><span class="pre">F_Bp_E</span></code>
added.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal notranslate"><span class="pre">forces</span></code> is nullptr or if it is not consistent</li>
<li>with the model to which <code class="docutils literal notranslate"><span class="pre">this</span></code> body belongs.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[Expression].AddInForceInWorld">
<code class="descname">AddInForceInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[Expression], context: pydrake.systems.framework.Context_[Expression], F_Bo_W: pydrake.multibody.math.SpatialForce_[Expression], forces: drake::multibody::MultibodyForces&lt;drake::symbolic::Expression&gt;</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Body_[Expression].AddInForceInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the spatial force on <code class="docutils literal notranslate"><span class="pre">this</span></code> body B, applied at body B’s origin
Bo and expressed in the world frame W into <code class="docutils literal notranslate"><span class="pre">forces</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[Expression].body_frame">
<code class="descname">body_frame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BodyFrame_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.Body_[Expression].body_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the associated BodyFrame.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[Expression].CalcCenterOfMassInBodyFrame">
<code class="descname">CalcCenterOfMassInBodyFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Body_[Expression].CalcCenterOfMassInBodyFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Computes the center of mass <code class="docutils literal notranslate"><span class="pre">p_BoBcm_B</span></code> (or <code class="docutils literal notranslate"><span class="pre">p_Bcm</span></code> for
short) of this body measured from this body’s frame origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code> and
expressed in the body frame B.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[Expression].CalcSpatialInertiaInBodyFrame">
<code class="descname">CalcSpatialInertiaInBodyFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; drake::multibody::SpatialInertia&lt;drake::symbolic::Expression&gt;<a class="headerlink" href="#pydrake.multibody.tree.Body_[Expression].CalcSpatialInertiaInBodyFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Computes the SpatialInertia <code class="docutils literal notranslate"><span class="pre">I_BBo_B</span></code> of <code class="docutils literal notranslate"><span class="pre">this</span></code> body
about its frame origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code> (not necessarily its center of mass) and
expressed in its body frame <code class="docutils literal notranslate"><span class="pre">B</span></code>. In general, the spatial inertia of
a body is a function of state. Consider for instance the case of a
flexible body for which its spatial inertia in the body frame depends
on the generalized coordinates describing its state of deformation. As
a particular case, the spatial inertia of a RigidBody in its body
frame is constant.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[Expression].default_mass">
<code class="descname">default_mass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.Body_[Expression].default_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default mass (not Context dependent) for <code class="docutils literal notranslate"><span class="pre">this</span></code> body. In
general, a body’s mass can be a Context-dependent parameter that is
returned by the method get_mass(). When a body’s mass is a parameter,
the value returned by default_mass() is used to initialize the mass
parameter in the Context.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[Expression].EvalPoseInWorld">
<code class="descname">EvalPoseInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.Body_[Expression].EvalPoseInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pose <code class="docutils literal notranslate"><span class="pre">X_WB</span></code> of this body B in the world frame W as a
function of the state of the model stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[Expression].EvalSpatialAccelerationInWorld">
<code class="descname">EvalSpatialAccelerationInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.Body_[Expression].EvalSpatialAccelerationInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates A_WB, <code class="docutils literal notranslate"><span class="pre">this</span></code> body B’s spatial acceleration in the world
frame W.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>Contains the state of the model.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">A_WB_W</span></code>:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">this</span></code> body B’s spatial acceleration in the world frame W,
expressed in W (for point Bo, the body’s origin).</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When cached values are out of sync with the state stored in
context, this method performs an expensive forward dynamics
computation, whereas once evaluated, successive calls to this
method are inexpensive.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[Expression].EvalSpatialVelocityInWorld">
<code class="descname">EvalSpatialVelocityInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.Body_[Expression].EvalSpatialVelocityInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates V_WB, <code class="docutils literal notranslate"><span class="pre">this</span></code> body B’s spatial velocity in the world frame
W.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>Contains the state of the model.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">V_WB_W</span></code>:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">this</span></code> body B’s spatial velocity in the world frame W, expressed
in W (for point Bo, the body frame’s origin).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[Expression].floating_position_suffix">
<code class="descname">floating_position_suffix</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[Expression], arg0: int</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Body_[Expression].floating_position_suffix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string suffix (e.g. to be appended to the name()) to
identify the <code class="docutils literal notranslate"><span class="pre">k`th</span> <span class="pre">position</span> <span class="pre">in</span> <span class="pre">the</span> <span class="pre">floating</span> <span class="pre">base.</span>
<span class="pre">``position_index_in_body</span></code> must be in [0, 7) if
<cite>has_quaternion_dofs()`</cite> is true, otherwise in [0, 6).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first">RuntimeError if is_floating() is false.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called pre-finalize, see</li>
<li>MultibodyPlant::Finalize().</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[Expression].floating_positions_start">
<code class="descname">floating_positions_start</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[Expression]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Body_[Expression].floating_positions_start" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) For floating bodies (see is_floating()) this method returns
the index of the first generalized position in the state vector for a
MultibodyPlant model. Positions for this body are then contiguous
starting at this index. When a floating body is modeled with a
quaternion mobilizer (see has_quaternion_dofs()), the four consecutive
entries in the state starting at this index correspond to the
quaternion that parametrizes this body’s orientation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called pre-finalize, see</li>
<li>MultibodyPlant::Finalize().</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[Expression].floating_velocities_start">
<code class="descname">floating_velocities_start</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[Expression]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Body_[Expression].floating_velocities_start" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) For floating bodies (see is_floating()) this method returns
the index of the first generalized velocity in the state vector for a
MultibodyPlant model. Velocities for this body are then contiguous
starting at this index.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called pre-finalize, see</li>
<li>MultibodyPlant::Finalize().</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[Expression].floating_velocity_suffix">
<code class="descname">floating_velocity_suffix</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[Expression], arg0: int</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Body_[Expression].floating_velocity_suffix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string suffix (e.g. to be appended to the name()) to
identify the <cite>k`th velocity in the floating base.
``velocity_index_in_body`</cite> must be in [0,6).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first">RuntimeError if is_floating() is false.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called pre-finalize, see</li>
<li>MultibodyPlant::Finalize().</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[Expression].get_mass">
<code class="descname">get_mass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.multibody.tree.Body_[Expression].get_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Returns the mass of this body stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[Expression].get_num_flexible_positions">
<code class="descname">get_num_flexible_positions</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[Expression]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Body_[Expression].get_num_flexible_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of generalized positions q describing flexible
deformations for this body. A rigid body will therefore return zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[Expression].get_num_flexible_velocities">
<code class="descname">get_num_flexible_velocities</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[Expression]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Body_[Expression].get_num_flexible_velocities" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of generalized velocities v describing flexible
deformations for this body. A rigid body will therefore return zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[Expression].GetForceInWorld">
<code class="descname">GetForceInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[Expression], context: pydrake.systems.framework.Context_[Expression], forces: drake::multibody::MultibodyForces&lt;drake::symbolic::Expression&gt;</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.Body_[Expression].GetForceInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the sptatial force on <code class="docutils literal notranslate"><span class="pre">this</span></code> body B from <code class="docutils literal notranslate"><span class="pre">forces</span></code> as F_BBo_W:
applied at body B’s origin Bo and expressed in world frame W.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[Expression].GetParentPlant">
<code class="descname">GetParentPlant</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[Expression]</em><span class="sig-paren">)</span> &#x2192; drake::multibody::MultibodyPlant&lt;drake::symbolic::Expression&gt;<a class="headerlink" href="#pydrake.multibody.tree.Body_[Expression].GetParentPlant" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[Expression].has_quaternion_dofs">
<code class="descname">has_quaternion_dofs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[Expression]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.Body_[Expression].has_quaternion_dofs" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) If <code class="docutils literal notranslate"><span class="pre">True</span></code>, this body is a floating body modeled with a
quaternion floating mobilizer. By implication, is_floating() is also
<code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">floating_positions_start(), floating_velocities_start().</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called pre-finalize, see</li>
<li>MultibodyPlant::Finalize().</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[Expression].index">
<code class="descname">index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BodyIndex<a class="headerlink" href="#pydrake.multibody.tree.Body_[Expression].index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[Expression].is_floating">
<code class="descname">is_floating</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[Expression]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.Body_[Expression].is_floating" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">this</span></code> body is granted 6-dofs by a
Mobilizer.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A floating body is not necessarily modeled with a quaternion
mobilizer, see has_quaternion_dofs(). Alternative options include
a space XYZ parametrization of rotations, see SpaceXYZMobilizer.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called pre-finalize, see</li>
<li>MultibodyPlant::Finalize().</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[Expression].is_locked">
<code class="descname">is_locked</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.Body_[Expression].is_locked" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">true if the body is locked, false otherwise.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[Expression].Lock">
<code class="descname">Lock</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Body_[Expression].Lock" title="Permalink to this definition">¶</a></dt>
<dd><p>For a floating body, lock its implicit inboard joint. Its generalized
velocities will be 0 until it is unlocked. Locking is not yet
supported for continuous-mode systems.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if this body is not a floating body, or if the parent</li>
<li>model uses continuous state.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[Expression].model_instance">
<code class="descname">model_instance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.Body_[Expression].model_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[Expression].name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[Expression]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Body_[Expression].name" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the <code class="docutils literal notranslate"><span class="pre">name</span></code> associated with <code class="docutils literal notranslate"><span class="pre">this</span></code> body. The name will never
be empty.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[Expression].Unlock">
<code class="descname">Unlock</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Body_[Expression].Unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>For a floating body, unlock its implicit inboard joint. Unlocking is
not yet supported for continuous-mode systems.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if this body is not a floating body, or if the parent</li>
<li>model uses continuous state.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.Body_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">Body_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.Body_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>%Body provides the general abstraction of a body with an API that
makes no assumption about whether a body is rigid or deformable and
neither does it make any assumptions about the underlying physical
model or approximation. As an element or component of a MultibodyTree,
a body is a MultibodyElement, and therefore it has a unique index of
type BodyIndex within the multibody tree it belongs to.</p>
<p>A Body contains a unique BodyFrame; see BodyFrame class documentation
for more information.</p>
<dl class="attribute">
<dt id="pydrake.multibody.tree.Body_[float].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.Body_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[float].AddInForce">
<code class="descname">AddInForce</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float], context: pydrake.systems.framework.Context_[float], p_BP_E: numpy.ndarray[numpy.float64[3, 1]], F_Bp_E: pydrake.multibody.math.SpatialForce_[float], frame_E: pydrake.multibody.tree.Frame_[float], forces: drake::multibody::MultibodyForces&lt;double&gt;</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Body_[float].AddInForce" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the spatial force on <code class="docutils literal notranslate"><span class="pre">this</span></code> body B, applied at point P and
expressed in a frame E into <code class="docutils literal notranslate"><span class="pre">forces</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context containing the current state of the model.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BP_E</span></code>:</dt>
<dd>The position of point P in B, expressed in a frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">F_Bp_E</span></code>:</dt>
<dd>The spatial force to be applied on body B at point P, expressed in
frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt>
<dd>The expressed-in frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">forces</span></code>:</dt>
<dd>A multibody forces objects that on output will have <code class="docutils literal notranslate"><span class="pre">F_Bp_E</span></code>
added.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal notranslate"><span class="pre">forces</span></code> is nullptr or if it is not consistent</li>
<li>with the model to which <code class="docutils literal notranslate"><span class="pre">this</span></code> body belongs.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[float].AddInForceInWorld">
<code class="descname">AddInForceInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float], context: pydrake.systems.framework.Context_[float], F_Bo_W: pydrake.multibody.math.SpatialForce_[float], forces: drake::multibody::MultibodyForces&lt;double&gt;</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Body_[float].AddInForceInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the spatial force on <code class="docutils literal notranslate"><span class="pre">this</span></code> body B, applied at body B’s origin
Bo and expressed in the world frame W into <code class="docutils literal notranslate"><span class="pre">forces</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[float].body_frame">
<code class="descname">body_frame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BodyFrame_[float]<a class="headerlink" href="#pydrake.multibody.tree.Body_[float].body_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the associated BodyFrame.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[float].CalcCenterOfMassInBodyFrame">
<code class="descname">CalcCenterOfMassInBodyFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Body_[float].CalcCenterOfMassInBodyFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Computes the center of mass <code class="docutils literal notranslate"><span class="pre">p_BoBcm_B</span></code> (or <code class="docutils literal notranslate"><span class="pre">p_Bcm</span></code> for
short) of this body measured from this body’s frame origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code> and
expressed in the body frame B.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[float].CalcSpatialInertiaInBodyFrame">
<code class="descname">CalcSpatialInertiaInBodyFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; drake::multibody::SpatialInertia&lt;double&gt;<a class="headerlink" href="#pydrake.multibody.tree.Body_[float].CalcSpatialInertiaInBodyFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Computes the SpatialInertia <code class="docutils literal notranslate"><span class="pre">I_BBo_B</span></code> of <code class="docutils literal notranslate"><span class="pre">this</span></code> body
about its frame origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code> (not necessarily its center of mass) and
expressed in its body frame <code class="docutils literal notranslate"><span class="pre">B</span></code>. In general, the spatial inertia of
a body is a function of state. Consider for instance the case of a
flexible body for which its spatial inertia in the body frame depends
on the generalized coordinates describing its state of deformation. As
a particular case, the spatial inertia of a RigidBody in its body
frame is constant.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[float].default_mass">
<code class="descname">default_mass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.Body_[float].default_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default mass (not Context dependent) for <code class="docutils literal notranslate"><span class="pre">this</span></code> body. In
general, a body’s mass can be a Context-dependent parameter that is
returned by the method get_mass(). When a body’s mass is a parameter,
the value returned by default_mass() is used to initialize the mass
parameter in the Context.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[float].EvalPoseInWorld">
<code class="descname">EvalPoseInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.multibody.tree.Body_[float].EvalPoseInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pose <code class="docutils literal notranslate"><span class="pre">X_WB</span></code> of this body B in the world frame W as a
function of the state of the model stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[float].EvalSpatialAccelerationInWorld">
<code class="descname">EvalSpatialAccelerationInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[float]<a class="headerlink" href="#pydrake.multibody.tree.Body_[float].EvalSpatialAccelerationInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates A_WB, <code class="docutils literal notranslate"><span class="pre">this</span></code> body B’s spatial acceleration in the world
frame W.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>Contains the state of the model.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">A_WB_W</span></code>:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">this</span></code> body B’s spatial acceleration in the world frame W,
expressed in W (for point Bo, the body’s origin).</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When cached values are out of sync with the state stored in
context, this method performs an expensive forward dynamics
computation, whereas once evaluated, successive calls to this
method are inexpensive.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[float].EvalSpatialVelocityInWorld">
<code class="descname">EvalSpatialVelocityInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[float]<a class="headerlink" href="#pydrake.multibody.tree.Body_[float].EvalSpatialVelocityInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates V_WB, <code class="docutils literal notranslate"><span class="pre">this</span></code> body B’s spatial velocity in the world frame
W.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>Contains the state of the model.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">V_WB_W</span></code>:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">this</span></code> body B’s spatial velocity in the world frame W, expressed
in W (for point Bo, the body frame’s origin).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[float].floating_position_suffix">
<code class="descname">floating_position_suffix</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float], arg0: int</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Body_[float].floating_position_suffix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string suffix (e.g. to be appended to the name()) to
identify the <code class="docutils literal notranslate"><span class="pre">k`th</span> <span class="pre">position</span> <span class="pre">in</span> <span class="pre">the</span> <span class="pre">floating</span> <span class="pre">base.</span>
<span class="pre">``position_index_in_body</span></code> must be in [0, 7) if
<cite>has_quaternion_dofs()`</cite> is true, otherwise in [0, 6).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first">RuntimeError if is_floating() is false.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called pre-finalize, see</li>
<li>MultibodyPlant::Finalize().</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[float].floating_positions_start">
<code class="descname">floating_positions_start</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Body_[float].floating_positions_start" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) For floating bodies (see is_floating()) this method returns
the index of the first generalized position in the state vector for a
MultibodyPlant model. Positions for this body are then contiguous
starting at this index. When a floating body is modeled with a
quaternion mobilizer (see has_quaternion_dofs()), the four consecutive
entries in the state starting at this index correspond to the
quaternion that parametrizes this body’s orientation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called pre-finalize, see</li>
<li>MultibodyPlant::Finalize().</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[float].floating_velocities_start">
<code class="descname">floating_velocities_start</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Body_[float].floating_velocities_start" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) For floating bodies (see is_floating()) this method returns
the index of the first generalized velocity in the state vector for a
MultibodyPlant model. Velocities for this body are then contiguous
starting at this index.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called pre-finalize, see</li>
<li>MultibodyPlant::Finalize().</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[float].floating_velocity_suffix">
<code class="descname">floating_velocity_suffix</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float], arg0: int</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Body_[float].floating_velocity_suffix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string suffix (e.g. to be appended to the name()) to
identify the <cite>k`th velocity in the floating base.
``velocity_index_in_body`</cite> must be in [0,6).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first">RuntimeError if is_floating() is false.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called pre-finalize, see</li>
<li>MultibodyPlant::Finalize().</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[float].get_mass">
<code class="descname">get_mass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.Body_[float].get_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Returns the mass of this body stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[float].get_num_flexible_positions">
<code class="descname">get_num_flexible_positions</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Body_[float].get_num_flexible_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of generalized positions q describing flexible
deformations for this body. A rigid body will therefore return zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[float].get_num_flexible_velocities">
<code class="descname">get_num_flexible_velocities</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Body_[float].get_num_flexible_velocities" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of generalized velocities v describing flexible
deformations for this body. A rigid body will therefore return zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[float].GetForceInWorld">
<code class="descname">GetForceInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float], context: pydrake.systems.framework.Context_[float], forces: drake::multibody::MultibodyForces&lt;double&gt;</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[float]<a class="headerlink" href="#pydrake.multibody.tree.Body_[float].GetForceInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the sptatial force on <code class="docutils literal notranslate"><span class="pre">this</span></code> body B from <code class="docutils literal notranslate"><span class="pre">forces</span></code> as F_BBo_W:
applied at body B’s origin Bo and expressed in world frame W.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[float].GetParentPlant">
<code class="descname">GetParentPlant</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float]</em><span class="sig-paren">)</span> &#x2192; drake::multibody::MultibodyPlant&lt;double&gt;<a class="headerlink" href="#pydrake.multibody.tree.Body_[float].GetParentPlant" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[float].has_quaternion_dofs">
<code class="descname">has_quaternion_dofs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.Body_[float].has_quaternion_dofs" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) If <code class="docutils literal notranslate"><span class="pre">True</span></code>, this body is a floating body modeled with a
quaternion floating mobilizer. By implication, is_floating() is also
<code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">floating_positions_start(), floating_velocities_start().</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called pre-finalize, see</li>
<li>MultibodyPlant::Finalize().</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[float].index">
<code class="descname">index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BodyIndex<a class="headerlink" href="#pydrake.multibody.tree.Body_[float].index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[float].is_floating">
<code class="descname">is_floating</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.Body_[float].is_floating" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if <code class="docutils literal notranslate"><span class="pre">this</span></code> body is granted 6-dofs by a
Mobilizer.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A floating body is not necessarily modeled with a quaternion
mobilizer, see has_quaternion_dofs(). Alternative options include
a space XYZ parametrization of rotations, see SpaceXYZMobilizer.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called pre-finalize, see</li>
<li>MultibodyPlant::Finalize().</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[float].is_locked">
<code class="descname">is_locked</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.Body_[float].is_locked" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">true if the body is locked, false otherwise.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[float].Lock">
<code class="descname">Lock</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Body_[float].Lock" title="Permalink to this definition">¶</a></dt>
<dd><p>For a floating body, lock its implicit inboard joint. Its generalized
velocities will be 0 until it is unlocked. Locking is not yet
supported for continuous-mode systems.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if this body is not a floating body, or if the parent</li>
<li>model uses continuous state.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[float].model_instance">
<code class="descname">model_instance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.Body_[float].model_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[float].name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Body_[float].name" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the <code class="docutils literal notranslate"><span class="pre">name</span></code> associated with <code class="docutils literal notranslate"><span class="pre">this</span></code> body. The name will never
be empty.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Body_[float].Unlock">
<code class="descname">Unlock</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Body_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Body_[float].Unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>For a floating body, unlock its implicit inboard joint. Unlocking is
not yet supported for continuous-mode systems.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if this body is not a floating body, or if the parent</li>
<li>model uses continuous state.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.BodyFrame">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">BodyFrame</code><a class="headerlink" href="#pydrake.multibody.tree.BodyFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.BodyFrame_[float]" title="pydrake.multibody.tree.BodyFrame_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.BodyFrame_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.BodyFrame_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">BodyFrame_</code><a class="headerlink" href="#pydrake.multibody.tree.BodyFrame_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.BodyFrame_[float]" title="pydrake.multibody.tree.BodyFrame_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">BodyFrame_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.BodyFrame_[AutoDiffXd]" title="pydrake.multibody.tree.BodyFrame_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">BodyFrame_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.BodyFrame_[Expression]" title="pydrake.multibody.tree.BodyFrame_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">BodyFrame_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.BodyFrame_.BodyFrame_[float]">
<em class="property">class </em><code class="descname">BodyFrame_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.BodyFrame_.BodyFrame_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Frame_[float]" title="pydrake.multibody.tree.Frame_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Frame_[float]</span></code></a></p>
<p>A BodyFrame is a material Frame that serves as the unique reference
frame for a Body.</p>
<p>Each Body B, regardless of whether it represents a rigid body or a
flexible body, has a unique body frame for which we use the same
symbol B (with meaning clear from context). The body frame is also
referred to as a <em>reference frame</em> in the literature for flexible body
mechanics modeling using the Finite Element Method. All properties of
a body are defined with respect to its body frame, including its mass
properties and attachment locations for joints, constraints,
actuators, geometry and so on. Run time motion of the body is defined
with respect to the motion of its body frame. We represent a body
frame by a BodyFrame object that is created whenever a Body is
constructed and is owned by the Body.</p>
<p>Note that the BodyFrame associated with a body does not necessarily
need to be located at its center of mass nor does it need to be
aligned with the body’s principal axes, although, in practice, it
frequently is. For flexible bodies, BodyFrame provides a
representation for the body’s reference frame. The flexible degrees of
freedom associated with a flexible body describe the body’s
deformation in this frame. Therefore, the motion of a flexible body is
defined by the motion of its BodyFrame, or reference frame, plus the
motion of the material points on the body with respect to its
BodyFrame.</p>
<p>A BodyFrame and Body are tightly coupled concepts; neither makes sense
without the other. Therefore, a BodyFrame instance is constructed in
conjunction with its Body and cannot be constructed anywhere else.
However, you can still access the frame associated with a body, see
Body::body_frame(). This access is more than a convenience; you can
use the BodyFrame to define other frames on the body and to attach
other multibody elements to it.</p>
<dl class="attribute">
<dt id="pydrake.multibody.tree.BodyFrame_.BodyFrame_[float].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.BodyFrame_.BodyFrame_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.BodyFrame_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">BodyFrame_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.BodyFrame_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Frame_[AutoDiffXd]" title="pydrake.multibody.tree.Frame_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd]</span></code></a></p>
<p>A BodyFrame is a material Frame that serves as the unique reference
frame for a Body.</p>
<p>Each Body B, regardless of whether it represents a rigid body or a
flexible body, has a unique body frame for which we use the same
symbol B (with meaning clear from context). The body frame is also
referred to as a <em>reference frame</em> in the literature for flexible body
mechanics modeling using the Finite Element Method. All properties of
a body are defined with respect to its body frame, including its mass
properties and attachment locations for joints, constraints,
actuators, geometry and so on. Run time motion of the body is defined
with respect to the motion of its body frame. We represent a body
frame by a BodyFrame object that is created whenever a Body is
constructed and is owned by the Body.</p>
<p>Note that the BodyFrame associated with a body does not necessarily
need to be located at its center of mass nor does it need to be
aligned with the body’s principal axes, although, in practice, it
frequently is. For flexible bodies, BodyFrame provides a
representation for the body’s reference frame. The flexible degrees of
freedom associated with a flexible body describe the body’s
deformation in this frame. Therefore, the motion of a flexible body is
defined by the motion of its BodyFrame, or reference frame, plus the
motion of the material points on the body with respect to its
BodyFrame.</p>
<p>A BodyFrame and Body are tightly coupled concepts; neither makes sense
without the other. Therefore, a BodyFrame instance is constructed in
conjunction with its Body and cannot be constructed anywhere else.
However, you can still access the frame associated with a body, see
Body::body_frame(). This access is more than a convenience; you can
use the BodyFrame to define other frames on the body and to attach
other multibody elements to it.</p>
<dl class="attribute">
<dt id="pydrake.multibody.tree.BodyFrame_[AutoDiffXd].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.BodyFrame_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.BodyFrame_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">BodyFrame_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.BodyFrame_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Frame_[Expression]" title="pydrake.multibody.tree.Frame_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Frame_[Expression]</span></code></a></p>
<p>A BodyFrame is a material Frame that serves as the unique reference
frame for a Body.</p>
<p>Each Body B, regardless of whether it represents a rigid body or a
flexible body, has a unique body frame for which we use the same
symbol B (with meaning clear from context). The body frame is also
referred to as a <em>reference frame</em> in the literature for flexible body
mechanics modeling using the Finite Element Method. All properties of
a body are defined with respect to its body frame, including its mass
properties and attachment locations for joints, constraints,
actuators, geometry and so on. Run time motion of the body is defined
with respect to the motion of its body frame. We represent a body
frame by a BodyFrame object that is created whenever a Body is
constructed and is owned by the Body.</p>
<p>Note that the BodyFrame associated with a body does not necessarily
need to be located at its center of mass nor does it need to be
aligned with the body’s principal axes, although, in practice, it
frequently is. For flexible bodies, BodyFrame provides a
representation for the body’s reference frame. The flexible degrees of
freedom associated with a flexible body describe the body’s
deformation in this frame. Therefore, the motion of a flexible body is
defined by the motion of its BodyFrame, or reference frame, plus the
motion of the material points on the body with respect to its
BodyFrame.</p>
<p>A BodyFrame and Body are tightly coupled concepts; neither makes sense
without the other. Therefore, a BodyFrame instance is constructed in
conjunction with its Body and cannot be constructed anywhere else.
However, you can still access the frame associated with a body, see
Body::body_frame(). This access is more than a convenience; you can
use the BodyFrame to define other frames on the body and to attach
other multibody elements to it.</p>
<dl class="attribute">
<dt id="pydrake.multibody.tree.BodyFrame_[Expression].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.BodyFrame_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.BodyFrame_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">BodyFrame_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.BodyFrame_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Frame_[float]" title="pydrake.multibody.tree.Frame_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Frame_[float]</span></code></a></p>
<p>A BodyFrame is a material Frame that serves as the unique reference
frame for a Body.</p>
<p>Each Body B, regardless of whether it represents a rigid body or a
flexible body, has a unique body frame for which we use the same
symbol B (with meaning clear from context). The body frame is also
referred to as a <em>reference frame</em> in the literature for flexible body
mechanics modeling using the Finite Element Method. All properties of
a body are defined with respect to its body frame, including its mass
properties and attachment locations for joints, constraints,
actuators, geometry and so on. Run time motion of the body is defined
with respect to the motion of its body frame. We represent a body
frame by a BodyFrame object that is created whenever a Body is
constructed and is owned by the Body.</p>
<p>Note that the BodyFrame associated with a body does not necessarily
need to be located at its center of mass nor does it need to be
aligned with the body’s principal axes, although, in practice, it
frequently is. For flexible bodies, BodyFrame provides a
representation for the body’s reference frame. The flexible degrees of
freedom associated with a flexible body describe the body’s
deformation in this frame. Therefore, the motion of a flexible body is
defined by the motion of its BodyFrame, or reference frame, plus the
motion of the material points on the body with respect to its
BodyFrame.</p>
<p>A BodyFrame and Body are tightly coupled concepts; neither makes sense
without the other. Therefore, a BodyFrame instance is constructed in
conjunction with its Body and cannot be constructed anywhere else.
However, you can still access the frame associated with a body, see
Body::body_frame(). This access is more than a convenience; you can
use the BodyFrame to define other frames on the body and to attach
other multibody elements to it.</p>
<dl class="attribute">
<dt id="pydrake.multibody.tree.BodyFrame_[float].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.BodyFrame_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.BodyIndex">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">BodyIndex</code><a class="headerlink" href="#pydrake.multibody.tree.BodyIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Type used to identify bodies by index in a multibody tree system.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.BodyIndex.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.BodyIndex.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.BodyIndex) -&gt; None</li>
</ol>
<p>Default constructor; the result is an <em>invalid</em> index. This only
exists to serve applications which require a default constructor.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.BodyIndex, arg0: int) -&gt; None</li>
</ol>
<p>Construction from a non-negative <code class="docutils literal notranslate"><span class="pre">int</span></code> value. The value must lie in
the range of [0, 2³¹). Constructor only promises to test validity in
Debug build.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.BodyIndex.is_valid">
<code class="descname">is_valid</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.BodyIndex</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.BodyIndex.is_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports if the index is valid–the only operation on an invalid index
that doesn’t throw an exception in Debug builds.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.ConstraintIndex">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">ConstraintIndex</code><a class="headerlink" href="#pydrake.multibody.tree.ConstraintIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Type used to identify constraints by index within a multibody system.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.ConstraintIndex.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.ConstraintIndex.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.ConstraintIndex) -&gt; None</li>
</ol>
<p>Default constructor; the result is an <em>invalid</em> index. This only
exists to serve applications which require a default constructor.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.ConstraintIndex, arg0: int) -&gt; None</li>
</ol>
<p>Construction from a non-negative <code class="docutils literal notranslate"><span class="pre">int</span></code> value. The value must lie in
the range of [0, 2³¹). Constructor only promises to test validity in
Debug build.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ConstraintIndex.is_valid">
<code class="descname">is_valid</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ConstraintIndex</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.ConstraintIndex.is_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports if the index is valid–the only operation on an invalid index
that doesn’t throw an exception in Debug builds.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pydrake.multibody.tree.default_model_instance">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">default_model_instance</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.default_model_instance" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the model instance which contains all tree elements with no
explicit model instance specified.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.DoorHinge">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">DoorHinge</code><a class="headerlink" href="#pydrake.multibody.tree.DoorHinge" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.DoorHinge_[float]" title="pydrake.multibody.tree.DoorHinge_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.DoorHinge_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.DoorHinge_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">DoorHinge_</code><a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.DoorHinge_[float]" title="pydrake.multibody.tree.DoorHinge_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">DoorHinge_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.DoorHinge_[AutoDiffXd]" title="pydrake.multibody.tree.DoorHinge_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">DoorHinge_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.DoorHinge_[Expression]" title="pydrake.multibody.tree.DoorHinge_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">DoorHinge_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.DoorHinge_.DoorHinge_[float]">
<em class="property">class </em><code class="descname">DoorHinge_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_.DoorHinge_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[float]" title="pydrake.multibody.tree.ForceElement_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ForceElement_[float]</span></code></a></p>
<p>This ForceElement models a revolute DoorHinge joint that could exhibit
different force/torque characteristics at different states due to the
existence of different type of torques on the joint. This class
implements a “christmas tree” accumulation of these different torques
in an empirical and unprincipled way. Specifically, different curves
are assigned to different torques to mimic their evolution based on
the joint state and some prespecified parameters.</p>
<p>Torques considered in this implementation include: * torsional spring
torque (τ_ts) – position dependent * catch torque (τ_c) – position
dependent * dynamic friction torque (τ_df) – velocity dependent *
static friction torque (τ_sf) – velocity dependent * viscous friction
torque (τ_vf) – velocity dependent</p>
<p>We then implement two curves to approximate the progression of
different torques. A curve <code class="docutils literal notranslate"><span class="pre">s(t,</span> <span class="pre">x)</span> <span class="pre">=</span> <span class="pre">tanh(x/t)</span></code> uses the <code class="docutils literal notranslate"><span class="pre">tanh</span></code>
function to approximate a step curve ({<cite>x&lt;0</cite>: -1 ; <code class="docutils literal notranslate"><span class="pre">x&gt;0</span></code>: 1})
outside of <code class="docutils literal notranslate"><span class="pre">-t</span> <span class="pre">&lt;</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">t</span></code>. The curve <code class="docutils literal notranslate"><span class="pre">doublet(t,</span> <span class="pre">x)</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">s</span> <span class="pre">*</span> <span class="pre">(1</span> <span class="pre">−</span>
<span class="pre">s²)</span></code> is the second derivative of <code class="docutils literal notranslate"><span class="pre">s</span></code> scaled by <code class="docutils literal notranslate"><span class="pre">-t²</span></code>, which
yields a lump at negative <code class="docutils literal notranslate"><span class="pre">x</span></code> that integrates to -1 and a lump at
positive <code class="docutils literal notranslate"><span class="pre">x</span></code> that integrates to 1. Finally, the total external
torque on the hinge joint would be:</p>
<p><code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span> <span class="pre">τ_ts</span> <span class="pre">+</span> <span class="pre">τ_c</span> <span class="pre">+</span> <span class="pre">τ_df</span> <span class="pre">+</span> <span class="pre">τ_sf</span> <span class="pre">+</span> <span class="pre">τ_vf</span></code>.</p>
<p>where <code class="docutils literal notranslate"><span class="pre">τ_ts</span> <span class="pre">=</span> <span class="pre">-k_ts</span> <span class="pre">*</span> <span class="pre">(q</span> <span class="pre">−</span> <span class="pre">qs₀)</span></code>, <cite>τ_c = k_c * doublet(qc₀/2, q −
qc₀/2)`</cite>, <cite>τ_df = -k_df * s(k_q̇₀, q̇)`</cite>, <cite>τ_sf = -k_sf *
doublet(k_q̇₀, q̇)</cite> and <code class="docutils literal notranslate"><span class="pre">τ_vf</span> <span class="pre">=</span> <span class="pre">-k_vf</span> <span class="pre">*</span> <span class="pre">q̇</span></code>. The door is assumed to
be closed at <code class="docutils literal notranslate"><span class="pre">q=0</span></code>, opening in the positive-q direction. Note that,
the sign of the torques depends on two elements: one is the sign of
the torque related constants and another one is the sign of the
assigned curves. For example, as defined above, the static friction
torque <code class="docutils literal notranslate"><span class="pre">τ_sf</span></code> should be opposite to the direction of the velocity
q̇. The catch torque <code class="docutils literal notranslate"><span class="pre">τ_c</span></code> should be negative when <code class="docutils literal notranslate"><span class="pre">q</span> <span class="pre">&lt;</span> <span class="pre">qc₀/2</span></code> and
positive otherwise. This class applies all hinge-originating forces,
so it can be used instead of the SDF viscous damping. The users could
change the values of these different elements to obtain different
characteristics for the DoorHinge joint that the users want to model.
A jupyter notebook tool is also provided to help the users visualize
the curves and design parameters. Run <code class="docutils literal notranslate"><span class="pre">bazel</span> <span class="pre">run</span>
<span class="pre">//bindings/pydrake/multibody:examples/door_hinge_inspector</span></code> to bring
up the notebook.</p>
<p><strong>To give an example</strong>, a common dishwasher door has a frictional
torque sufficient for it to rest motionless at any angle, a catch at
the top to hold it in place, a dashpot (viscous friction source) to
prevent it from swinging too fast, and a spring to counteract some of
its mass. Two figures are provided to illustrate the dishwasher
DoorHinge torque with the given default parameters. Figure 1 shows the
static characteristic of the dishwasher door. At q = 0, there exists a
negative catch torque to prevent the door from moving. After that, the
torsional spring torque will dominate to compensate part of the door
gravity. Figure 2 shows the dynamic feature of the dishwasher door at
q = 30 deg. It shows the door can be closed easily since the torque is
small when the velocity is negative. However, whenever the door
intends to open further, there will be a counter torque to prevent
that movement, which therefore keeps the door at rest. Note that, due
to the gravity, the dishwasher door will be fully open eventually.
This process can be really slow because of the default
<code class="docutils literal notranslate"><span class="pre">motion_threshold</span></code> is set to be very small. You can change the
<code class="docutils literal notranslate"><span class="pre">motion_threshold</span></code> parameter to adjust the time. &#64;image html
drake/multibody/tree/images/torque_vs_angle.svg “Figure 1” &#64;image html
drake/multibody/tree/images/torque_vs_velocity.svg “Figure 2”</p>
<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_.DoorHinge_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[float], joint: pydrake.multibody.tree.RevoluteJoint_[float], config: pydrake.multibody.tree.DoorHingeConfig</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_.DoorHinge_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a hinge force element with parameters <code class="docutils literal notranslate"><span class="pre">config</span></code> applied to
the specified <code class="docutils literal notranslate"><span class="pre">joint</span></code>. It will throw an exception if the
DoorHingeConfig is invalid.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_.DoorHinge_[float].CalcHingeFrictionalTorque">
<code class="descname">CalcHingeFrictionalTorque</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[float], angular_rate: float</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_.DoorHinge_[float].CalcHingeFrictionalTorque" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the total frictional torque with the given <code class="docutils literal notranslate"><span class="pre">angular_rate</span></code>
and the internal DoorHingeConfig.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_.DoorHinge_[float].CalcHingeSpringTorque">
<code class="descname">CalcHingeSpringTorque</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[float], angle: float</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_.DoorHinge_[float].CalcHingeSpringTorque" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the total spring related torque with the given <code class="docutils literal notranslate"><span class="pre">angle</span></code> and
the internal DoorHingeConfig.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_.DoorHinge_[float].CalcHingeTorque">
<code class="descname">CalcHingeTorque</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[float], angle: float, angular_rate: float</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_.DoorHinge_[float].CalcHingeTorque" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the total torque with the given <code class="docutils literal notranslate"><span class="pre">angle</span></code> and
<code class="docutils literal notranslate"><span class="pre">angular_rate</span></code> and the internal DoorHingeConfig.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_.DoorHinge_[float].config">
<code class="descname">config</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.DoorHingeConfig<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_.DoorHinge_[float].config" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_.DoorHinge_[float].joint">
<code class="descname">joint</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RevoluteJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_.DoorHinge_[float].joint" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.DoorHinge_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">DoorHinge_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[AutoDiffXd]" title="pydrake.multibody.tree.ForceElement_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ForceElement_[AutoDiffXd]</span></code></a></p>
<p>This ForceElement models a revolute DoorHinge joint that could exhibit
different force/torque characteristics at different states due to the
existence of different type of torques on the joint. This class
implements a “christmas tree” accumulation of these different torques
in an empirical and unprincipled way. Specifically, different curves
are assigned to different torques to mimic their evolution based on
the joint state and some prespecified parameters.</p>
<p>Torques considered in this implementation include: * torsional spring
torque (τ_ts) – position dependent * catch torque (τ_c) – position
dependent * dynamic friction torque (τ_df) – velocity dependent *
static friction torque (τ_sf) – velocity dependent * viscous friction
torque (τ_vf) – velocity dependent</p>
<p>We then implement two curves to approximate the progression of
different torques. A curve <code class="docutils literal notranslate"><span class="pre">s(t,</span> <span class="pre">x)</span> <span class="pre">=</span> <span class="pre">tanh(x/t)</span></code> uses the <code class="docutils literal notranslate"><span class="pre">tanh</span></code>
function to approximate a step curve ({<cite>x&lt;0</cite>: -1 ; <code class="docutils literal notranslate"><span class="pre">x&gt;0</span></code>: 1})
outside of <code class="docutils literal notranslate"><span class="pre">-t</span> <span class="pre">&lt;</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">t</span></code>. The curve <code class="docutils literal notranslate"><span class="pre">doublet(t,</span> <span class="pre">x)</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">s</span> <span class="pre">*</span> <span class="pre">(1</span> <span class="pre">−</span>
<span class="pre">s²)</span></code> is the second derivative of <code class="docutils literal notranslate"><span class="pre">s</span></code> scaled by <code class="docutils literal notranslate"><span class="pre">-t²</span></code>, which
yields a lump at negative <code class="docutils literal notranslate"><span class="pre">x</span></code> that integrates to -1 and a lump at
positive <code class="docutils literal notranslate"><span class="pre">x</span></code> that integrates to 1. Finally, the total external
torque on the hinge joint would be:</p>
<p><code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span> <span class="pre">τ_ts</span> <span class="pre">+</span> <span class="pre">τ_c</span> <span class="pre">+</span> <span class="pre">τ_df</span> <span class="pre">+</span> <span class="pre">τ_sf</span> <span class="pre">+</span> <span class="pre">τ_vf</span></code>.</p>
<p>where <code class="docutils literal notranslate"><span class="pre">τ_ts</span> <span class="pre">=</span> <span class="pre">-k_ts</span> <span class="pre">*</span> <span class="pre">(q</span> <span class="pre">−</span> <span class="pre">qs₀)</span></code>, <cite>τ_c = k_c * doublet(qc₀/2, q −
qc₀/2)`</cite>, <cite>τ_df = -k_df * s(k_q̇₀, q̇)`</cite>, <cite>τ_sf = -k_sf *
doublet(k_q̇₀, q̇)</cite> and <code class="docutils literal notranslate"><span class="pre">τ_vf</span> <span class="pre">=</span> <span class="pre">-k_vf</span> <span class="pre">*</span> <span class="pre">q̇</span></code>. The door is assumed to
be closed at <code class="docutils literal notranslate"><span class="pre">q=0</span></code>, opening in the positive-q direction. Note that,
the sign of the torques depends on two elements: one is the sign of
the torque related constants and another one is the sign of the
assigned curves. For example, as defined above, the static friction
torque <code class="docutils literal notranslate"><span class="pre">τ_sf</span></code> should be opposite to the direction of the velocity
q̇. The catch torque <code class="docutils literal notranslate"><span class="pre">τ_c</span></code> should be negative when <code class="docutils literal notranslate"><span class="pre">q</span> <span class="pre">&lt;</span> <span class="pre">qc₀/2</span></code> and
positive otherwise. This class applies all hinge-originating forces,
so it can be used instead of the SDF viscous damping. The users could
change the values of these different elements to obtain different
characteristics for the DoorHinge joint that the users want to model.
A jupyter notebook tool is also provided to help the users visualize
the curves and design parameters. Run <code class="docutils literal notranslate"><span class="pre">bazel</span> <span class="pre">run</span>
<span class="pre">//bindings/pydrake/multibody:examples/door_hinge_inspector</span></code> to bring
up the notebook.</p>
<p><strong>To give an example</strong>, a common dishwasher door has a frictional
torque sufficient for it to rest motionless at any angle, a catch at
the top to hold it in place, a dashpot (viscous friction source) to
prevent it from swinging too fast, and a spring to counteract some of
its mass. Two figures are provided to illustrate the dishwasher
DoorHinge torque with the given default parameters. Figure 1 shows the
static characteristic of the dishwasher door. At q = 0, there exists a
negative catch torque to prevent the door from moving. After that, the
torsional spring torque will dominate to compensate part of the door
gravity. Figure 2 shows the dynamic feature of the dishwasher door at
q = 30 deg. It shows the door can be closed easily since the torque is
small when the velocity is negative. However, whenever the door
intends to open further, there will be a counter torque to prevent
that movement, which therefore keeps the door at rest. Note that, due
to the gravity, the dishwasher door will be fully open eventually.
This process can be really slow because of the default
<code class="docutils literal notranslate"><span class="pre">motion_threshold</span></code> is set to be very small. You can change the
<code class="docutils literal notranslate"><span class="pre">motion_threshold</span></code> parameter to adjust the time. &#64;image html
drake/multibody/tree/images/torque_vs_angle.svg “Figure 1” &#64;image html
drake/multibody/tree/images/torque_vs_velocity.svg “Figure 2”</p>
<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[AutoDiffXd], joint: pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd], config: pydrake.multibody.tree.DoorHingeConfig</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a hinge force element with parameters <code class="docutils literal notranslate"><span class="pre">config</span></code> applied to
the specified <code class="docutils literal notranslate"><span class="pre">joint</span></code>. It will throw an exception if the
DoorHingeConfig is invalid.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_[AutoDiffXd].CalcHingeFrictionalTorque">
<code class="descname">CalcHingeFrictionalTorque</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[AutoDiffXd], angular_rate: pydrake.autodiffutils.AutoDiffXd</em><span class="sig-paren">)</span> &#x2192; pydrake.autodiffutils.AutoDiffXd<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_[AutoDiffXd].CalcHingeFrictionalTorque" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the total frictional torque with the given <code class="docutils literal notranslate"><span class="pre">angular_rate</span></code>
and the internal DoorHingeConfig.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_[AutoDiffXd].CalcHingeSpringTorque">
<code class="descname">CalcHingeSpringTorque</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[AutoDiffXd], angle: pydrake.autodiffutils.AutoDiffXd</em><span class="sig-paren">)</span> &#x2192; pydrake.autodiffutils.AutoDiffXd<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_[AutoDiffXd].CalcHingeSpringTorque" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the total spring related torque with the given <code class="docutils literal notranslate"><span class="pre">angle</span></code> and
the internal DoorHingeConfig.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_[AutoDiffXd].CalcHingeTorque">
<code class="descname">CalcHingeTorque</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[AutoDiffXd], angle: pydrake.autodiffutils.AutoDiffXd, angular_rate: pydrake.autodiffutils.AutoDiffXd</em><span class="sig-paren">)</span> &#x2192; pydrake.autodiffutils.AutoDiffXd<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_[AutoDiffXd].CalcHingeTorque" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the total torque with the given <code class="docutils literal notranslate"><span class="pre">angle</span></code> and
<code class="docutils literal notranslate"><span class="pre">angular_rate</span></code> and the internal DoorHingeConfig.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_[AutoDiffXd].config">
<code class="descname">config</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.DoorHingeConfig<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_[AutoDiffXd].config" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_[AutoDiffXd].joint">
<code class="descname">joint</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_[AutoDiffXd].joint" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.DoorHinge_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">DoorHinge_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[Expression]" title="pydrake.multibody.tree.ForceElement_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ForceElement_[Expression]</span></code></a></p>
<p>This ForceElement models a revolute DoorHinge joint that could exhibit
different force/torque characteristics at different states due to the
existence of different type of torques on the joint. This class
implements a “christmas tree” accumulation of these different torques
in an empirical and unprincipled way. Specifically, different curves
are assigned to different torques to mimic their evolution based on
the joint state and some prespecified parameters.</p>
<p>Torques considered in this implementation include: * torsional spring
torque (τ_ts) – position dependent * catch torque (τ_c) – position
dependent * dynamic friction torque (τ_df) – velocity dependent *
static friction torque (τ_sf) – velocity dependent * viscous friction
torque (τ_vf) – velocity dependent</p>
<p>We then implement two curves to approximate the progression of
different torques. A curve <code class="docutils literal notranslate"><span class="pre">s(t,</span> <span class="pre">x)</span> <span class="pre">=</span> <span class="pre">tanh(x/t)</span></code> uses the <code class="docutils literal notranslate"><span class="pre">tanh</span></code>
function to approximate a step curve ({<cite>x&lt;0</cite>: -1 ; <code class="docutils literal notranslate"><span class="pre">x&gt;0</span></code>: 1})
outside of <code class="docutils literal notranslate"><span class="pre">-t</span> <span class="pre">&lt;</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">t</span></code>. The curve <code class="docutils literal notranslate"><span class="pre">doublet(t,</span> <span class="pre">x)</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">s</span> <span class="pre">*</span> <span class="pre">(1</span> <span class="pre">−</span>
<span class="pre">s²)</span></code> is the second derivative of <code class="docutils literal notranslate"><span class="pre">s</span></code> scaled by <code class="docutils literal notranslate"><span class="pre">-t²</span></code>, which
yields a lump at negative <code class="docutils literal notranslate"><span class="pre">x</span></code> that integrates to -1 and a lump at
positive <code class="docutils literal notranslate"><span class="pre">x</span></code> that integrates to 1. Finally, the total external
torque on the hinge joint would be:</p>
<p><code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span> <span class="pre">τ_ts</span> <span class="pre">+</span> <span class="pre">τ_c</span> <span class="pre">+</span> <span class="pre">τ_df</span> <span class="pre">+</span> <span class="pre">τ_sf</span> <span class="pre">+</span> <span class="pre">τ_vf</span></code>.</p>
<p>where <code class="docutils literal notranslate"><span class="pre">τ_ts</span> <span class="pre">=</span> <span class="pre">-k_ts</span> <span class="pre">*</span> <span class="pre">(q</span> <span class="pre">−</span> <span class="pre">qs₀)</span></code>, <cite>τ_c = k_c * doublet(qc₀/2, q −
qc₀/2)`</cite>, <cite>τ_df = -k_df * s(k_q̇₀, q̇)`</cite>, <cite>τ_sf = -k_sf *
doublet(k_q̇₀, q̇)</cite> and <code class="docutils literal notranslate"><span class="pre">τ_vf</span> <span class="pre">=</span> <span class="pre">-k_vf</span> <span class="pre">*</span> <span class="pre">q̇</span></code>. The door is assumed to
be closed at <code class="docutils literal notranslate"><span class="pre">q=0</span></code>, opening in the positive-q direction. Note that,
the sign of the torques depends on two elements: one is the sign of
the torque related constants and another one is the sign of the
assigned curves. For example, as defined above, the static friction
torque <code class="docutils literal notranslate"><span class="pre">τ_sf</span></code> should be opposite to the direction of the velocity
q̇. The catch torque <code class="docutils literal notranslate"><span class="pre">τ_c</span></code> should be negative when <code class="docutils literal notranslate"><span class="pre">q</span> <span class="pre">&lt;</span> <span class="pre">qc₀/2</span></code> and
positive otherwise. This class applies all hinge-originating forces,
so it can be used instead of the SDF viscous damping. The users could
change the values of these different elements to obtain different
characteristics for the DoorHinge joint that the users want to model.
A jupyter notebook tool is also provided to help the users visualize
the curves and design parameters. Run <code class="docutils literal notranslate"><span class="pre">bazel</span> <span class="pre">run</span>
<span class="pre">//bindings/pydrake/multibody:examples/door_hinge_inspector</span></code> to bring
up the notebook.</p>
<p><strong>To give an example</strong>, a common dishwasher door has a frictional
torque sufficient for it to rest motionless at any angle, a catch at
the top to hold it in place, a dashpot (viscous friction source) to
prevent it from swinging too fast, and a spring to counteract some of
its mass. Two figures are provided to illustrate the dishwasher
DoorHinge torque with the given default parameters. Figure 1 shows the
static characteristic of the dishwasher door. At q = 0, there exists a
negative catch torque to prevent the door from moving. After that, the
torsional spring torque will dominate to compensate part of the door
gravity. Figure 2 shows the dynamic feature of the dishwasher door at
q = 30 deg. It shows the door can be closed easily since the torque is
small when the velocity is negative. However, whenever the door
intends to open further, there will be a counter torque to prevent
that movement, which therefore keeps the door at rest. Note that, due
to the gravity, the dishwasher door will be fully open eventually.
This process can be really slow because of the default
<code class="docutils literal notranslate"><span class="pre">motion_threshold</span></code> is set to be very small. You can change the
<code class="docutils literal notranslate"><span class="pre">motion_threshold</span></code> parameter to adjust the time. &#64;image html
drake/multibody/tree/images/torque_vs_angle.svg “Figure 1” &#64;image html
drake/multibody/tree/images/torque_vs_velocity.svg “Figure 2”</p>
<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[Expression], joint: pydrake.multibody.tree.RevoluteJoint_[Expression], config: pydrake.multibody.tree.DoorHingeConfig</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a hinge force element with parameters <code class="docutils literal notranslate"><span class="pre">config</span></code> applied to
the specified <code class="docutils literal notranslate"><span class="pre">joint</span></code>. It will throw an exception if the
DoorHingeConfig is invalid.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_[Expression].CalcHingeFrictionalTorque">
<code class="descname">CalcHingeFrictionalTorque</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[Expression], angular_rate: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_[Expression].CalcHingeFrictionalTorque" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the total frictional torque with the given <code class="docutils literal notranslate"><span class="pre">angular_rate</span></code>
and the internal DoorHingeConfig.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_[Expression].CalcHingeSpringTorque">
<code class="descname">CalcHingeSpringTorque</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[Expression], angle: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_[Expression].CalcHingeSpringTorque" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the total spring related torque with the given <code class="docutils literal notranslate"><span class="pre">angle</span></code> and
the internal DoorHingeConfig.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_[Expression].CalcHingeTorque">
<code class="descname">CalcHingeTorque</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[Expression], angle: pydrake.symbolic.Expression, angular_rate: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_[Expression].CalcHingeTorque" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the total torque with the given <code class="docutils literal notranslate"><span class="pre">angle</span></code> and
<code class="docutils literal notranslate"><span class="pre">angular_rate</span></code> and the internal DoorHingeConfig.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_[Expression].config">
<code class="descname">config</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.DoorHingeConfig<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_[Expression].config" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_[Expression].joint">
<code class="descname">joint</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RevoluteJoint_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_[Expression].joint" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.DoorHinge_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">DoorHinge_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[float]" title="pydrake.multibody.tree.ForceElement_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ForceElement_[float]</span></code></a></p>
<p>This ForceElement models a revolute DoorHinge joint that could exhibit
different force/torque characteristics at different states due to the
existence of different type of torques on the joint. This class
implements a “christmas tree” accumulation of these different torques
in an empirical and unprincipled way. Specifically, different curves
are assigned to different torques to mimic their evolution based on
the joint state and some prespecified parameters.</p>
<p>Torques considered in this implementation include: * torsional spring
torque (τ_ts) – position dependent * catch torque (τ_c) – position
dependent * dynamic friction torque (τ_df) – velocity dependent *
static friction torque (τ_sf) – velocity dependent * viscous friction
torque (τ_vf) – velocity dependent</p>
<p>We then implement two curves to approximate the progression of
different torques. A curve <code class="docutils literal notranslate"><span class="pre">s(t,</span> <span class="pre">x)</span> <span class="pre">=</span> <span class="pre">tanh(x/t)</span></code> uses the <code class="docutils literal notranslate"><span class="pre">tanh</span></code>
function to approximate a step curve ({<cite>x&lt;0</cite>: -1 ; <code class="docutils literal notranslate"><span class="pre">x&gt;0</span></code>: 1})
outside of <code class="docutils literal notranslate"><span class="pre">-t</span> <span class="pre">&lt;</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">t</span></code>. The curve <code class="docutils literal notranslate"><span class="pre">doublet(t,</span> <span class="pre">x)</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">s</span> <span class="pre">*</span> <span class="pre">(1</span> <span class="pre">−</span>
<span class="pre">s²)</span></code> is the second derivative of <code class="docutils literal notranslate"><span class="pre">s</span></code> scaled by <code class="docutils literal notranslate"><span class="pre">-t²</span></code>, which
yields a lump at negative <code class="docutils literal notranslate"><span class="pre">x</span></code> that integrates to -1 and a lump at
positive <code class="docutils literal notranslate"><span class="pre">x</span></code> that integrates to 1. Finally, the total external
torque on the hinge joint would be:</p>
<p><code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span> <span class="pre">τ_ts</span> <span class="pre">+</span> <span class="pre">τ_c</span> <span class="pre">+</span> <span class="pre">τ_df</span> <span class="pre">+</span> <span class="pre">τ_sf</span> <span class="pre">+</span> <span class="pre">τ_vf</span></code>.</p>
<p>where <code class="docutils literal notranslate"><span class="pre">τ_ts</span> <span class="pre">=</span> <span class="pre">-k_ts</span> <span class="pre">*</span> <span class="pre">(q</span> <span class="pre">−</span> <span class="pre">qs₀)</span></code>, <cite>τ_c = k_c * doublet(qc₀/2, q −
qc₀/2)`</cite>, <cite>τ_df = -k_df * s(k_q̇₀, q̇)`</cite>, <cite>τ_sf = -k_sf *
doublet(k_q̇₀, q̇)</cite> and <code class="docutils literal notranslate"><span class="pre">τ_vf</span> <span class="pre">=</span> <span class="pre">-k_vf</span> <span class="pre">*</span> <span class="pre">q̇</span></code>. The door is assumed to
be closed at <code class="docutils literal notranslate"><span class="pre">q=0</span></code>, opening in the positive-q direction. Note that,
the sign of the torques depends on two elements: one is the sign of
the torque related constants and another one is the sign of the
assigned curves. For example, as defined above, the static friction
torque <code class="docutils literal notranslate"><span class="pre">τ_sf</span></code> should be opposite to the direction of the velocity
q̇. The catch torque <code class="docutils literal notranslate"><span class="pre">τ_c</span></code> should be negative when <code class="docutils literal notranslate"><span class="pre">q</span> <span class="pre">&lt;</span> <span class="pre">qc₀/2</span></code> and
positive otherwise. This class applies all hinge-originating forces,
so it can be used instead of the SDF viscous damping. The users could
change the values of these different elements to obtain different
characteristics for the DoorHinge joint that the users want to model.
A jupyter notebook tool is also provided to help the users visualize
the curves and design parameters. Run <code class="docutils literal notranslate"><span class="pre">bazel</span> <span class="pre">run</span>
<span class="pre">//bindings/pydrake/multibody:examples/door_hinge_inspector</span></code> to bring
up the notebook.</p>
<p><strong>To give an example</strong>, a common dishwasher door has a frictional
torque sufficient for it to rest motionless at any angle, a catch at
the top to hold it in place, a dashpot (viscous friction source) to
prevent it from swinging too fast, and a spring to counteract some of
its mass. Two figures are provided to illustrate the dishwasher
DoorHinge torque with the given default parameters. Figure 1 shows the
static characteristic of the dishwasher door. At q = 0, there exists a
negative catch torque to prevent the door from moving. After that, the
torsional spring torque will dominate to compensate part of the door
gravity. Figure 2 shows the dynamic feature of the dishwasher door at
q = 30 deg. It shows the door can be closed easily since the torque is
small when the velocity is negative. However, whenever the door
intends to open further, there will be a counter torque to prevent
that movement, which therefore keeps the door at rest. Note that, due
to the gravity, the dishwasher door will be fully open eventually.
This process can be really slow because of the default
<code class="docutils literal notranslate"><span class="pre">motion_threshold</span></code> is set to be very small. You can change the
<code class="docutils literal notranslate"><span class="pre">motion_threshold</span></code> parameter to adjust the time. &#64;image html
drake/multibody/tree/images/torque_vs_angle.svg “Figure 1” &#64;image html
drake/multibody/tree/images/torque_vs_velocity.svg “Figure 2”</p>
<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[float], joint: pydrake.multibody.tree.RevoluteJoint_[float], config: pydrake.multibody.tree.DoorHingeConfig</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a hinge force element with parameters <code class="docutils literal notranslate"><span class="pre">config</span></code> applied to
the specified <code class="docutils literal notranslate"><span class="pre">joint</span></code>. It will throw an exception if the
DoorHingeConfig is invalid.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_[float].CalcHingeFrictionalTorque">
<code class="descname">CalcHingeFrictionalTorque</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[float], angular_rate: float</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_[float].CalcHingeFrictionalTorque" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the total frictional torque with the given <code class="docutils literal notranslate"><span class="pre">angular_rate</span></code>
and the internal DoorHingeConfig.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_[float].CalcHingeSpringTorque">
<code class="descname">CalcHingeSpringTorque</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[float], angle: float</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_[float].CalcHingeSpringTorque" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the total spring related torque with the given <code class="docutils literal notranslate"><span class="pre">angle</span></code> and
the internal DoorHingeConfig.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_[float].CalcHingeTorque">
<code class="descname">CalcHingeTorque</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[float], angle: float, angular_rate: float</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_[float].CalcHingeTorque" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the total torque with the given <code class="docutils literal notranslate"><span class="pre">angle</span></code> and
<code class="docutils literal notranslate"><span class="pre">angular_rate</span></code> and the internal DoorHingeConfig.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_[float].config">
<code class="descname">config</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.DoorHingeConfig<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_[float].config" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.DoorHinge_[float].joint">
<code class="descname">joint</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHinge_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RevoluteJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.DoorHinge_[float].joint" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.DoorHingeConfig">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">DoorHingeConfig</code><a class="headerlink" href="#pydrake.multibody.tree.DoorHingeConfig" title="Permalink to this definition">¶</a></dt>
<dd><p>Configuration structure for the DoorHinge.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.DoorHingeConfig.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.DoorHingeConfig</em>, <em>**kwargs</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.DoorHingeConfig.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize to empirically reasonable values measured approximately by
banging on the door of a dishwasher with a force gauge.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.DoorHingeConfig.catch_torque">
<code class="descname">catch_torque</code><a class="headerlink" href="#pydrake.multibody.tree.DoorHingeConfig.catch_torque" title="Permalink to this definition">¶</a></dt>
<dd><p>k_c maximum catch torque applied over <code class="docutils literal notranslate"><span class="pre">catch_width</span></code> [Nm]. It should
be non-negative.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.DoorHingeConfig.catch_width">
<code class="descname">catch_width</code><a class="headerlink" href="#pydrake.multibody.tree.DoorHingeConfig.catch_width" title="Permalink to this definition">¶</a></dt>
<dd><p>qc₀ measured from closed (q=0) position [radian]. It should be
non-negative.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.DoorHingeConfig.dynamic_friction_torque">
<code class="descname">dynamic_friction_torque</code><a class="headerlink" href="#pydrake.multibody.tree.DoorHingeConfig.dynamic_friction_torque" title="Permalink to this definition">¶</a></dt>
<dd><p>k_df maximum dynamic friction torque measured opposite direction of
motion [Nm]. It should be non-negative.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.DoorHingeConfig.motion_threshold">
<code class="descname">motion_threshold</code><a class="headerlink" href="#pydrake.multibody.tree.DoorHingeConfig.motion_threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>k_q̇₀ motion threshold to start to apply friction torques [rad/s]. It
should be non-negative. Realistic frictional force is very stiff,
reversing entirely over zero change in position or velocity, which
kills integrators. We approximate it with a continuous function. This
constant [rad/s] is the scaling factor on that function – very
approximately the rad/s at which half of the full frictional force is
applied. This number is nonphysical; make it small but not so small
that the simulation vibrates or explodes.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.DoorHingeConfig.spring_constant">
<code class="descname">spring_constant</code><a class="headerlink" href="#pydrake.multibody.tree.DoorHingeConfig.spring_constant" title="Permalink to this definition">¶</a></dt>
<dd><p>k_ts torsional spring constant measured toward the spring zero angle
[Nm/rad]. It should be non-negative.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.DoorHingeConfig.spring_zero_angle_rad">
<code class="descname">spring_zero_angle_rad</code><a class="headerlink" href="#pydrake.multibody.tree.DoorHingeConfig.spring_zero_angle_rad" title="Permalink to this definition">¶</a></dt>
<dd><p>qs₀ measured outward from the closed position [radian].</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.DoorHingeConfig.static_friction_torque">
<code class="descname">static_friction_torque</code><a class="headerlink" href="#pydrake.multibody.tree.DoorHingeConfig.static_friction_torque" title="Permalink to this definition">¶</a></dt>
<dd><p>k_sf maximum static friction measured opposite direction of motion
[Nm]. It should be non-negative.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.DoorHingeConfig.viscous_friction">
<code class="descname">viscous_friction</code><a class="headerlink" href="#pydrake.multibody.tree.DoorHingeConfig.viscous_friction" title="Permalink to this definition">¶</a></dt>
<dd><p>k_vf viscous friction measured opposite direction of motion [Nm]. It
should be non-negative.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.FixedOffsetFrame">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">FixedOffsetFrame</code><a class="headerlink" href="#pydrake.multibody.tree.FixedOffsetFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.FixedOffsetFrame_[float]" title="pydrake.multibody.tree.FixedOffsetFrame_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.FixedOffsetFrame_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.FixedOffsetFrame_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">FixedOffsetFrame_</code><a class="headerlink" href="#pydrake.multibody.tree.FixedOffsetFrame_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.FixedOffsetFrame_[float]" title="pydrake.multibody.tree.FixedOffsetFrame_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">FixedOffsetFrame_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.FixedOffsetFrame_[AutoDiffXd]" title="pydrake.multibody.tree.FixedOffsetFrame_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">FixedOffsetFrame_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.FixedOffsetFrame_[Expression]" title="pydrake.multibody.tree.FixedOffsetFrame_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">FixedOffsetFrame_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.FixedOffsetFrame_.FixedOffsetFrame_[float]">
<em class="property">class </em><code class="descname">FixedOffsetFrame_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.FixedOffsetFrame_.FixedOffsetFrame_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Frame_[float]" title="pydrake.multibody.tree.Frame_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Frame_[float]</span></code></a></p>
<p>%FixedOffsetFrame represents a material frame F whose pose is fixed
with respect to a <em>parent</em> material frame P. The pose offset is given
by a spatial transform <code class="docutils literal notranslate"><span class="pre">X_PF</span></code>, which is constant after construction.
For instance, we could rigidly attach a frame F to move with a rigid
body B at a fixed pose <code class="docutils literal notranslate"><span class="pre">X_BF</span></code>, where B is the BodyFrame associated
with body B. Thus, the World frame pose <code class="docutils literal notranslate"><span class="pre">X_WF</span></code> of a FixedOffsetFrame
F depends only on the World frame pose <code class="docutils literal notranslate"><span class="pre">X_WP</span></code> of its parent P, and
the constant pose <code class="docutils literal notranslate"><span class="pre">X_PF</span></code>, with <code class="docutils literal notranslate"><span class="pre">X_WF=X_WP*X_PF</span></code>.</p>
<p>For more information about spatial transforms, see
multibody_spatial_pose.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.FixedOffsetFrame_.FixedOffsetFrame_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.FixedOffsetFrame_.FixedOffsetFrame_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.FixedOffsetFrame_[float], name: str, P: pydrake.multibody.tree.Frame_[float], X_PF: pydrake.math.RigidTransform_[float], model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = None) -&gt; None</li>
</ol>
<p>Creates a material Frame F whose pose is fixed with respect to its
parent material Frame P. The pose is given by a spatial transform
<code class="docutils literal notranslate"><span class="pre">X_PF</span></code>; see class documentation for more information.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt>
<dd>The name of this frame. Cannot be empty.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">P</span></code>:</dt>
<dd>The frame to which this frame is attached with a fixed pose.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_PF</span></code>:</dt>
<dd>The <em>default</em> transform giving the pose of F in P, therefore only
the value (as a RigidTransform&lt;double&gt;) is provided.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>:</dt>
<dd>The model instance to which this frame belongs to. If unspecified,
will use P.body().model_instance().</dd>
</dl>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.FixedOffsetFrame_[float], P: pydrake.multibody.tree.Frame_[float], X_PF: pydrake.math.RigidTransform_[float]) -&gt; None</li>
</ol>
<p>(Deprecated.)</p>
<dl class="docutils">
<dt>Deprecated:</dt>
<dd>The name parameter to the FixedOffsetFrame constructor is now
required. This will be removed from Drake on or after 2022-12-01.</dd>
</dl>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.tree.FixedOffsetFrame_[float], name: str, bodyB: drake::multibody::Body&lt;double&gt;, X_BF: pydrake.math.RigidTransform_[float]) -&gt; None</li>
</ol>
<p>Creates a material Frame F whose pose is fixed with respect to the
BodyFrame B of the given Body, which serves as F’s parent frame. The
pose is given by a spatial transform <code class="docutils literal notranslate"><span class="pre">X_BF</span></code>; see class documentation
for more information.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt>
<dd>The name of this frame. Cannot be empty.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">bodyB</span></code>:</dt>
<dd>The body whose BodyFrame B is to be F’s parent frame.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_BF</span></code>:</dt>
<dd>The transform giving the pose of F in B.</dd>
</dl>
<ol class="arabic simple" start="4">
<li>__init__(self: pydrake.multibody.tree.FixedOffsetFrame_[float], bodyB: drake::multibody::Body&lt;double&gt;, X_BF: pydrake.math.RigidTransform_[float]) -&gt; None</li>
</ol>
<p>(Deprecated.)</p>
<dl class="docutils">
<dt>Deprecated:</dt>
<dd>FixedOffsetFrame must always have name This will be removed from
Drake on or after 2022-12-01.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.FixedOffsetFrame_.FixedOffsetFrame_[float].GetPoseInParentFrame">
<code class="descname">GetPoseInParentFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.FixedOffsetFrame_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.multibody.tree.FixedOffsetFrame_.FixedOffsetFrame_[float].GetPoseInParentFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the rigid transform X_PF that characterizes <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s
pose in its parent frame P.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody plant.</dd>
<dt>Precondition:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">this</span></code> frame has been registered in the given <code class="docutils literal notranslate"><span class="pre">context</span></code>.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.FixedOffsetFrame_.FixedOffsetFrame_[float].SetPoseInBodyFrame">
<code class="descname">SetPoseInBodyFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.FixedOffsetFrame_[float], context: pydrake.systems.framework.Context_[float], X_PF: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.FixedOffsetFrame_.FixedOffsetFrame_[float].SetPoseInBodyFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>(Deprecated.)</p>
<dl class="docutils">
<dt>Deprecated:</dt>
<dd>SetPoseInBodyFrame() was incorrectly named so it has been replaced
by SetPoseInParentFrame(). This will be removed from Drake on or
after 2023-03-01.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.FixedOffsetFrame_.FixedOffsetFrame_[float].SetPoseInParentFrame">
<code class="descname">SetPoseInParentFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.FixedOffsetFrame_[float], context: pydrake.systems.framework.Context_[float], X_PF: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.FixedOffsetFrame_.FixedOffsetFrame_[float].SetPoseInParentFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the pose of <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F in its parent frame P.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody plant.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_PF</span></code>:</dt>
<dd>Rigid transform that characterizes <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s pose
(orientation and position) in its parent frame P.</dd>
<dt>Precondition:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">this</span></code> frame has been registered in the given <code class="docutils literal notranslate"><span class="pre">context</span></code>.</dd>
</dl>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.FixedOffsetFrame_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">FixedOffsetFrame_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.FixedOffsetFrame_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Frame_[AutoDiffXd]" title="pydrake.multibody.tree.Frame_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Frame_[AutoDiffXd]</span></code></a></p>
<p>%FixedOffsetFrame represents a material frame F whose pose is fixed
with respect to a <em>parent</em> material frame P. The pose offset is given
by a spatial transform <code class="docutils literal notranslate"><span class="pre">X_PF</span></code>, which is constant after construction.
For instance, we could rigidly attach a frame F to move with a rigid
body B at a fixed pose <code class="docutils literal notranslate"><span class="pre">X_BF</span></code>, where B is the BodyFrame associated
with body B. Thus, the World frame pose <code class="docutils literal notranslate"><span class="pre">X_WF</span></code> of a FixedOffsetFrame
F depends only on the World frame pose <code class="docutils literal notranslate"><span class="pre">X_WP</span></code> of its parent P, and
the constant pose <code class="docutils literal notranslate"><span class="pre">X_PF</span></code>, with <code class="docutils literal notranslate"><span class="pre">X_WF=X_WP*X_PF</span></code>.</p>
<p>For more information about spatial transforms, see
multibody_spatial_pose.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.FixedOffsetFrame_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.FixedOffsetFrame_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.FixedOffsetFrame_[AutoDiffXd], name: str, P: pydrake.multibody.tree.Frame_[AutoDiffXd], X_PF: pydrake.math.RigidTransform_[float], model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = None) -&gt; None</li>
</ol>
<p>Creates a material Frame F whose pose is fixed with respect to its
parent material Frame P. The pose is given by a spatial transform
<code class="docutils literal notranslate"><span class="pre">X_PF</span></code>; see class documentation for more information.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt>
<dd>The name of this frame. Cannot be empty.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">P</span></code>:</dt>
<dd>The frame to which this frame is attached with a fixed pose.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_PF</span></code>:</dt>
<dd>The <em>default</em> transform giving the pose of F in P, therefore only
the value (as a RigidTransform&lt;double&gt;) is provided.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>:</dt>
<dd>The model instance to which this frame belongs to. If unspecified,
will use P.body().model_instance().</dd>
</dl>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.FixedOffsetFrame_[AutoDiffXd], P: pydrake.multibody.tree.Frame_[AutoDiffXd], X_PF: pydrake.math.RigidTransform_[float]) -&gt; None</li>
</ol>
<p>(Deprecated.)</p>
<dl class="docutils">
<dt>Deprecated:</dt>
<dd>The name parameter to the FixedOffsetFrame constructor is now
required. This will be removed from Drake on or after 2022-12-01.</dd>
</dl>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.tree.FixedOffsetFrame_[AutoDiffXd], name: str, bodyB: drake::multibody::Body&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;, X_BF: pydrake.math.RigidTransform_[float]) -&gt; None</li>
</ol>
<p>Creates a material Frame F whose pose is fixed with respect to the
BodyFrame B of the given Body, which serves as F’s parent frame. The
pose is given by a spatial transform <code class="docutils literal notranslate"><span class="pre">X_BF</span></code>; see class documentation
for more information.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt>
<dd>The name of this frame. Cannot be empty.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">bodyB</span></code>:</dt>
<dd>The body whose BodyFrame B is to be F’s parent frame.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_BF</span></code>:</dt>
<dd>The transform giving the pose of F in B.</dd>
</dl>
<ol class="arabic simple" start="4">
<li>__init__(self: pydrake.multibody.tree.FixedOffsetFrame_[AutoDiffXd], bodyB: drake::multibody::Body&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;, X_BF: pydrake.math.RigidTransform_[float]) -&gt; None</li>
</ol>
<p>(Deprecated.)</p>
<dl class="docutils">
<dt>Deprecated:</dt>
<dd>FixedOffsetFrame must always have name This will be removed from
Drake on or after 2022-12-01.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.FixedOffsetFrame_[AutoDiffXd].GetPoseInParentFrame">
<code class="descname">GetPoseInParentFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.FixedOffsetFrame_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.FixedOffsetFrame_[AutoDiffXd].GetPoseInParentFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the rigid transform X_PF that characterizes <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s
pose in its parent frame P.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody plant.</dd>
<dt>Precondition:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">this</span></code> frame has been registered in the given <code class="docutils literal notranslate"><span class="pre">context</span></code>.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.FixedOffsetFrame_[AutoDiffXd].SetPoseInBodyFrame">
<code class="descname">SetPoseInBodyFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.FixedOffsetFrame_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], X_PF: pydrake.math.RigidTransform_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.FixedOffsetFrame_[AutoDiffXd].SetPoseInBodyFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>(Deprecated.)</p>
<dl class="docutils">
<dt>Deprecated:</dt>
<dd>SetPoseInBodyFrame() was incorrectly named so it has been replaced
by SetPoseInParentFrame(). This will be removed from Drake on or
after 2023-03-01.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.FixedOffsetFrame_[AutoDiffXd].SetPoseInParentFrame">
<code class="descname">SetPoseInParentFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.FixedOffsetFrame_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], X_PF: pydrake.math.RigidTransform_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.FixedOffsetFrame_[AutoDiffXd].SetPoseInParentFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the pose of <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F in its parent frame P.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody plant.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_PF</span></code>:</dt>
<dd>Rigid transform that characterizes <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s pose
(orientation and position) in its parent frame P.</dd>
<dt>Precondition:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">this</span></code> frame has been registered in the given <code class="docutils literal notranslate"><span class="pre">context</span></code>.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.FixedOffsetFrame_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">FixedOffsetFrame_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.FixedOffsetFrame_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Frame_[Expression]" title="pydrake.multibody.tree.Frame_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Frame_[Expression]</span></code></a></p>
<p>%FixedOffsetFrame represents a material frame F whose pose is fixed
with respect to a <em>parent</em> material frame P. The pose offset is given
by a spatial transform <code class="docutils literal notranslate"><span class="pre">X_PF</span></code>, which is constant after construction.
For instance, we could rigidly attach a frame F to move with a rigid
body B at a fixed pose <code class="docutils literal notranslate"><span class="pre">X_BF</span></code>, where B is the BodyFrame associated
with body B. Thus, the World frame pose <code class="docutils literal notranslate"><span class="pre">X_WF</span></code> of a FixedOffsetFrame
F depends only on the World frame pose <code class="docutils literal notranslate"><span class="pre">X_WP</span></code> of its parent P, and
the constant pose <code class="docutils literal notranslate"><span class="pre">X_PF</span></code>, with <code class="docutils literal notranslate"><span class="pre">X_WF=X_WP*X_PF</span></code>.</p>
<p>For more information about spatial transforms, see
multibody_spatial_pose.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.FixedOffsetFrame_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.FixedOffsetFrame_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.FixedOffsetFrame_[Expression], name: str, P: pydrake.multibody.tree.Frame_[Expression], X_PF: pydrake.math.RigidTransform_[float], model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = None) -&gt; None</li>
</ol>
<p>Creates a material Frame F whose pose is fixed with respect to its
parent material Frame P. The pose is given by a spatial transform
<code class="docutils literal notranslate"><span class="pre">X_PF</span></code>; see class documentation for more information.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt>
<dd>The name of this frame. Cannot be empty.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">P</span></code>:</dt>
<dd>The frame to which this frame is attached with a fixed pose.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_PF</span></code>:</dt>
<dd>The <em>default</em> transform giving the pose of F in P, therefore only
the value (as a RigidTransform&lt;double&gt;) is provided.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>:</dt>
<dd>The model instance to which this frame belongs to. If unspecified,
will use P.body().model_instance().</dd>
</dl>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.FixedOffsetFrame_[Expression], P: pydrake.multibody.tree.Frame_[Expression], X_PF: pydrake.math.RigidTransform_[float]) -&gt; None</li>
</ol>
<p>(Deprecated.)</p>
<dl class="docutils">
<dt>Deprecated:</dt>
<dd>The name parameter to the FixedOffsetFrame constructor is now
required. This will be removed from Drake on or after 2022-12-01.</dd>
</dl>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.tree.FixedOffsetFrame_[Expression], name: str, bodyB: drake::multibody::Body&lt;drake::symbolic::Expression&gt;, X_BF: pydrake.math.RigidTransform_[float]) -&gt; None</li>
</ol>
<p>Creates a material Frame F whose pose is fixed with respect to the
BodyFrame B of the given Body, which serves as F’s parent frame. The
pose is given by a spatial transform <code class="docutils literal notranslate"><span class="pre">X_BF</span></code>; see class documentation
for more information.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt>
<dd>The name of this frame. Cannot be empty.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">bodyB</span></code>:</dt>
<dd>The body whose BodyFrame B is to be F’s parent frame.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_BF</span></code>:</dt>
<dd>The transform giving the pose of F in B.</dd>
</dl>
<ol class="arabic simple" start="4">
<li>__init__(self: pydrake.multibody.tree.FixedOffsetFrame_[Expression], bodyB: drake::multibody::Body&lt;drake::symbolic::Expression&gt;, X_BF: pydrake.math.RigidTransform_[float]) -&gt; None</li>
</ol>
<p>(Deprecated.)</p>
<dl class="docutils">
<dt>Deprecated:</dt>
<dd>FixedOffsetFrame must always have name This will be removed from
Drake on or after 2022-12-01.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.FixedOffsetFrame_[Expression].GetPoseInParentFrame">
<code class="descname">GetPoseInParentFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.FixedOffsetFrame_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.FixedOffsetFrame_[Expression].GetPoseInParentFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the rigid transform X_PF that characterizes <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s
pose in its parent frame P.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody plant.</dd>
<dt>Precondition:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">this</span></code> frame has been registered in the given <code class="docutils literal notranslate"><span class="pre">context</span></code>.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.FixedOffsetFrame_[Expression].SetPoseInBodyFrame">
<code class="descname">SetPoseInBodyFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.FixedOffsetFrame_[Expression], context: pydrake.systems.framework.Context_[Expression], X_PF: pydrake.math.RigidTransform_[Expression]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.FixedOffsetFrame_[Expression].SetPoseInBodyFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>(Deprecated.)</p>
<dl class="docutils">
<dt>Deprecated:</dt>
<dd>SetPoseInBodyFrame() was incorrectly named so it has been replaced
by SetPoseInParentFrame(). This will be removed from Drake on or
after 2023-03-01.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.FixedOffsetFrame_[Expression].SetPoseInParentFrame">
<code class="descname">SetPoseInParentFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.FixedOffsetFrame_[Expression], context: pydrake.systems.framework.Context_[Expression], X_PF: pydrake.math.RigidTransform_[Expression]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.FixedOffsetFrame_[Expression].SetPoseInParentFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the pose of <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F in its parent frame P.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody plant.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_PF</span></code>:</dt>
<dd>Rigid transform that characterizes <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s pose
(orientation and position) in its parent frame P.</dd>
<dt>Precondition:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">this</span></code> frame has been registered in the given <code class="docutils literal notranslate"><span class="pre">context</span></code>.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.FixedOffsetFrame_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">FixedOffsetFrame_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.FixedOffsetFrame_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Frame_[float]" title="pydrake.multibody.tree.Frame_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Frame_[float]</span></code></a></p>
<p>%FixedOffsetFrame represents a material frame F whose pose is fixed
with respect to a <em>parent</em> material frame P. The pose offset is given
by a spatial transform <code class="docutils literal notranslate"><span class="pre">X_PF</span></code>, which is constant after construction.
For instance, we could rigidly attach a frame F to move with a rigid
body B at a fixed pose <code class="docutils literal notranslate"><span class="pre">X_BF</span></code>, where B is the BodyFrame associated
with body B. Thus, the World frame pose <code class="docutils literal notranslate"><span class="pre">X_WF</span></code> of a FixedOffsetFrame
F depends only on the World frame pose <code class="docutils literal notranslate"><span class="pre">X_WP</span></code> of its parent P, and
the constant pose <code class="docutils literal notranslate"><span class="pre">X_PF</span></code>, with <code class="docutils literal notranslate"><span class="pre">X_WF=X_WP*X_PF</span></code>.</p>
<p>For more information about spatial transforms, see
multibody_spatial_pose.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.FixedOffsetFrame_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.FixedOffsetFrame_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.FixedOffsetFrame_[float], name: str, P: pydrake.multibody.tree.Frame_[float], X_PF: pydrake.math.RigidTransform_[float], model_instance: Optional[pydrake.multibody.tree.ModelInstanceIndex] = None) -&gt; None</li>
</ol>
<p>Creates a material Frame F whose pose is fixed with respect to its
parent material Frame P. The pose is given by a spatial transform
<code class="docutils literal notranslate"><span class="pre">X_PF</span></code>; see class documentation for more information.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt>
<dd>The name of this frame. Cannot be empty.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">P</span></code>:</dt>
<dd>The frame to which this frame is attached with a fixed pose.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_PF</span></code>:</dt>
<dd>The <em>default</em> transform giving the pose of F in P, therefore only
the value (as a RigidTransform&lt;double&gt;) is provided.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>:</dt>
<dd>The model instance to which this frame belongs to. If unspecified,
will use P.body().model_instance().</dd>
</dl>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.FixedOffsetFrame_[float], P: pydrake.multibody.tree.Frame_[float], X_PF: pydrake.math.RigidTransform_[float]) -&gt; None</li>
</ol>
<p>(Deprecated.)</p>
<dl class="docutils">
<dt>Deprecated:</dt>
<dd>The name parameter to the FixedOffsetFrame constructor is now
required. This will be removed from Drake on or after 2022-12-01.</dd>
</dl>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.tree.FixedOffsetFrame_[float], name: str, bodyB: drake::multibody::Body&lt;double&gt;, X_BF: pydrake.math.RigidTransform_[float]) -&gt; None</li>
</ol>
<p>Creates a material Frame F whose pose is fixed with respect to the
BodyFrame B of the given Body, which serves as F’s parent frame. The
pose is given by a spatial transform <code class="docutils literal notranslate"><span class="pre">X_BF</span></code>; see class documentation
for more information.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">name</span></code>:</dt>
<dd>The name of this frame. Cannot be empty.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">bodyB</span></code>:</dt>
<dd>The body whose BodyFrame B is to be F’s parent frame.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_BF</span></code>:</dt>
<dd>The transform giving the pose of F in B.</dd>
</dl>
<ol class="arabic simple" start="4">
<li>__init__(self: pydrake.multibody.tree.FixedOffsetFrame_[float], bodyB: drake::multibody::Body&lt;double&gt;, X_BF: pydrake.math.RigidTransform_[float]) -&gt; None</li>
</ol>
<p>(Deprecated.)</p>
<dl class="docutils">
<dt>Deprecated:</dt>
<dd>FixedOffsetFrame must always have name This will be removed from
Drake on or after 2022-12-01.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.FixedOffsetFrame_[float].GetPoseInParentFrame">
<code class="descname">GetPoseInParentFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.FixedOffsetFrame_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.multibody.tree.FixedOffsetFrame_[float].GetPoseInParentFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the rigid transform X_PF that characterizes <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s
pose in its parent frame P.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody plant.</dd>
<dt>Precondition:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">this</span></code> frame has been registered in the given <code class="docutils literal notranslate"><span class="pre">context</span></code>.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.FixedOffsetFrame_[float].SetPoseInBodyFrame">
<code class="descname">SetPoseInBodyFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.FixedOffsetFrame_[float], context: pydrake.systems.framework.Context_[float], X_PF: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.FixedOffsetFrame_[float].SetPoseInBodyFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>(Deprecated.)</p>
<dl class="docutils">
<dt>Deprecated:</dt>
<dd>SetPoseInBodyFrame() was incorrectly named so it has been replaced
by SetPoseInParentFrame(). This will be removed from Drake on or
after 2023-03-01.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.FixedOffsetFrame_[float].SetPoseInParentFrame">
<code class="descname">SetPoseInParentFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.FixedOffsetFrame_[float], context: pydrake.systems.framework.Context_[float], X_PF: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.FixedOffsetFrame_[float].SetPoseInParentFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the pose of <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F in its parent frame P.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody plant.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">X_PF</span></code>:</dt>
<dd>Rigid transform that characterizes <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s pose
(orientation and position) in its parent frame P.</dd>
<dt>Precondition:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">this</span></code> frame has been registered in the given <code class="docutils literal notranslate"><span class="pre">context</span></code>.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.ForceElement">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">ForceElement</code><a class="headerlink" href="#pydrake.multibody.tree.ForceElement" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[float]" title="pydrake.multibody.tree.ForceElement_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ForceElement_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.ForceElement_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">ForceElement_</code><a class="headerlink" href="#pydrake.multibody.tree.ForceElement_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[float]" title="pydrake.multibody.tree.ForceElement_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForceElement_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[AutoDiffXd]" title="pydrake.multibody.tree.ForceElement_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForceElement_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[Expression]" title="pydrake.multibody.tree.ForceElement_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">ForceElement_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.ForceElement_.ForceElement_[float]">
<em class="property">class </em><code class="descname">ForceElement_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.ForceElement_.ForceElement_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>A ForceElement allows modeling state and time dependent forces in a
MultibodyTree model. Examples of such forces are springs, dampers,
drag and gravity. Forces that depend on accelerations such as virtual
mass cannot be modeled with a ForceElement. This abstract class
provides an API that all force elements subclasses must implement in
order to be fully defined. These are:</p>
<ul class="simple">
<li>CalcAndAddForceContribution(): computes the force contribution of a force
element in a MultibodyTree model.</li>
<li>CalcPotentialEnergy(): computes a force element potential energy
contribution.</li>
<li>CalcConservativePower(): computes the power generated by conservative
forces.</li>
<li>CalcNonConservativePower(): computes the power dissipated by
non-conservative forces.</li>
</ul>
<dl class="attribute">
<dt id="pydrake.multibody.tree.ForceElement_.ForceElement_[float].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.ForceElement_.ForceElement_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ForceElement_.ForceElement_[float].GetParentPlant">
<code class="descname">GetParentPlant</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ForceElement_[float]</em><span class="sig-paren">)</span> &#x2192; drake::multibody::MultibodyPlant&lt;double&gt;<a class="headerlink" href="#pydrake.multibody.tree.ForceElement_.ForceElement_[float].GetParentPlant" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ForceElement_.ForceElement_[float].index">
<code class="descname">index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ForceElement_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ForceElementIndex<a class="headerlink" href="#pydrake.multibody.tree.ForceElement_.ForceElement_[float].index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ForceElement_.ForceElement_[float].model_instance">
<code class="descname">model_instance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ForceElement_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.ForceElement_.ForceElement_[float].model_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.ForceElement_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">ForceElement_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.ForceElement_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>A ForceElement allows modeling state and time dependent forces in a
MultibodyTree model. Examples of such forces are springs, dampers,
drag and gravity. Forces that depend on accelerations such as virtual
mass cannot be modeled with a ForceElement. This abstract class
provides an API that all force elements subclasses must implement in
order to be fully defined. These are:</p>
<ul class="simple">
<li>CalcAndAddForceContribution(): computes the force contribution of a force
element in a MultibodyTree model.</li>
<li>CalcPotentialEnergy(): computes a force element potential energy
contribution.</li>
<li>CalcConservativePower(): computes the power generated by conservative
forces.</li>
<li>CalcNonConservativePower(): computes the power dissipated by
non-conservative forces.</li>
</ul>
<dl class="attribute">
<dt id="pydrake.multibody.tree.ForceElement_[AutoDiffXd].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.ForceElement_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ForceElement_[AutoDiffXd].GetParentPlant">
<code class="descname">GetParentPlant</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ForceElement_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; drake::multibody::MultibodyPlant&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;<a class="headerlink" href="#pydrake.multibody.tree.ForceElement_[AutoDiffXd].GetParentPlant" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ForceElement_[AutoDiffXd].index">
<code class="descname">index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ForceElement_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ForceElementIndex<a class="headerlink" href="#pydrake.multibody.tree.ForceElement_[AutoDiffXd].index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ForceElement_[AutoDiffXd].model_instance">
<code class="descname">model_instance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ForceElement_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.ForceElement_[AutoDiffXd].model_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.ForceElement_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">ForceElement_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.ForceElement_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>A ForceElement allows modeling state and time dependent forces in a
MultibodyTree model. Examples of such forces are springs, dampers,
drag and gravity. Forces that depend on accelerations such as virtual
mass cannot be modeled with a ForceElement. This abstract class
provides an API that all force elements subclasses must implement in
order to be fully defined. These are:</p>
<ul class="simple">
<li>CalcAndAddForceContribution(): computes the force contribution of a force
element in a MultibodyTree model.</li>
<li>CalcPotentialEnergy(): computes a force element potential energy
contribution.</li>
<li>CalcConservativePower(): computes the power generated by conservative
forces.</li>
<li>CalcNonConservativePower(): computes the power dissipated by
non-conservative forces.</li>
</ul>
<dl class="attribute">
<dt id="pydrake.multibody.tree.ForceElement_[Expression].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.ForceElement_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ForceElement_[Expression].GetParentPlant">
<code class="descname">GetParentPlant</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ForceElement_[Expression]</em><span class="sig-paren">)</span> &#x2192; drake::multibody::MultibodyPlant&lt;drake::symbolic::Expression&gt;<a class="headerlink" href="#pydrake.multibody.tree.ForceElement_[Expression].GetParentPlant" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ForceElement_[Expression].index">
<code class="descname">index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ForceElement_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ForceElementIndex<a class="headerlink" href="#pydrake.multibody.tree.ForceElement_[Expression].index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ForceElement_[Expression].model_instance">
<code class="descname">model_instance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ForceElement_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.ForceElement_[Expression].model_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.ForceElement_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">ForceElement_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.ForceElement_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>A ForceElement allows modeling state and time dependent forces in a
MultibodyTree model. Examples of such forces are springs, dampers,
drag and gravity. Forces that depend on accelerations such as virtual
mass cannot be modeled with a ForceElement. This abstract class
provides an API that all force elements subclasses must implement in
order to be fully defined. These are:</p>
<ul class="simple">
<li>CalcAndAddForceContribution(): computes the force contribution of a force
element in a MultibodyTree model.</li>
<li>CalcPotentialEnergy(): computes a force element potential energy
contribution.</li>
<li>CalcConservativePower(): computes the power generated by conservative
forces.</li>
<li>CalcNonConservativePower(): computes the power dissipated by
non-conservative forces.</li>
</ul>
<dl class="attribute">
<dt id="pydrake.multibody.tree.ForceElement_[float].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.ForceElement_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ForceElement_[float].GetParentPlant">
<code class="descname">GetParentPlant</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ForceElement_[float]</em><span class="sig-paren">)</span> &#x2192; drake::multibody::MultibodyPlant&lt;double&gt;<a class="headerlink" href="#pydrake.multibody.tree.ForceElement_[float].GetParentPlant" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ForceElement_[float].index">
<code class="descname">index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ForceElement_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ForceElementIndex<a class="headerlink" href="#pydrake.multibody.tree.ForceElement_[float].index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ForceElement_[float].model_instance">
<code class="descname">model_instance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ForceElement_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.ForceElement_[float].model_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.ForceElementIndex">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">ForceElementIndex</code><a class="headerlink" href="#pydrake.multibody.tree.ForceElementIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Type used to identify force elements by index within a multibody tree
system.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.ForceElementIndex.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.ForceElementIndex.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.ForceElementIndex) -&gt; None</li>
</ol>
<p>Default constructor; the result is an <em>invalid</em> index. This only
exists to serve applications which require a default constructor.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.ForceElementIndex, arg0: int) -&gt; None</li>
</ol>
<p>Construction from a non-negative <code class="docutils literal notranslate"><span class="pre">int</span></code> value. The value must lie in
the range of [0, 2³¹). Constructor only promises to test validity in
Debug build.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ForceElementIndex.is_valid">
<code class="descname">is_valid</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ForceElementIndex</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.ForceElementIndex.is_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports if the index is valid–the only operation on an invalid index
that doesn’t throw an exception in Debug builds.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.Frame">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">Frame</code><a class="headerlink" href="#pydrake.multibody.tree.Frame" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.Frame_[float]" title="pydrake.multibody.tree.Frame_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Frame_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.Frame_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">Frame_</code><a class="headerlink" href="#pydrake.multibody.tree.Frame_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.Frame_[float]" title="pydrake.multibody.tree.Frame_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Frame_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.Frame_[AutoDiffXd]" title="pydrake.multibody.tree.Frame_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Frame_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.Frame_[Expression]" title="pydrake.multibody.tree.Frame_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Frame_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.Frame_.Frame_[float]">
<em class="property">class </em><code class="descname">Frame_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.Frame_.Frame_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>%Frame is an abstract class representing a <em>material frame</em> (also
called a <em>physical frame</em>), meaning that the Frame’s origin is a
material point of a Body.</p>
<p>An important characteristic of a Frame is that forces or torques
applied to a Frame are applied to the Frame’s underlying Body.
Force-producing elements like joints, actuators, and constraints
usually employ two Frames, with one Frame connected to one body and
the other connected to a different Body. Every Frame object can report
the Body to which it is attached. Despite its name, Frame is not the
most general frame in Drake (see FrameBase for more information).</p>
<p>A Frame’s pose in World (or relative to other frames) is always
calculated starting with its pose relative to its underlying Body’s
BodyFrame. Subclasses derived from Frame differ in how kinematic
calculations are performed. For example, the angular velocity of a
FixedOffsetFrame or BodyFrame is identical to the angular velocity of
its underlying body, whereas the translational velocity of a
FixedOffsetFrame differs from that of a BodyFrame. If a Frame is
associated with a soft body, kinematic calculations can depend on the
soft body’s deformation state variables.</p>
<p>A Frame object does <em>not</em> store a Context (where Context means state
that contains the Frame’s current orientation, position, motion,
etc.). Instead, Frame provides methods for calculating these
Frame-properties from a Context passed to Frame methods.</p>
<dl class="attribute">
<dt id="pydrake.multibody.tree.Frame_.Frame_[float].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.Frame_.Frame_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_.Frame_[float].body">
<code class="descname">body</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; drake::multibody::Body&lt;double&gt;<a class="headerlink" href="#pydrake.multibody.tree.Frame_.Frame_[float].body" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the body associated to this Frame.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_.Frame_[float].CalcAngularVelocity">
<code class="descname">CalcAngularVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float], context: pydrake.systems.framework.Context_[float], measured_in_frame: pydrake.multibody.tree.Frame_[float], expressed_in_frame: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Frame_.Frame_[float].CalcAngularVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s angular velocity measured in a frame M,
expressed in a frame E.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">measured_in_frame</span></code>:</dt>
<dd>which is frame M (the frame in which <code class="docutils literal notranslate"><span class="pre">this</span></code> angular velocity is
to be measured).</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">expressed_in_frame</span></code>:</dt>
<dd>which is frame E (the frame in which the returned angular velocity
is to be expressed).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">ω_MF_E, <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s angular velocity ω measured in frame M,
expressed in frame E.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">EvalAngularVelocityInWorld() to evaluate ω_WF_W (<code class="docutils literal notranslate"><span class="pre">this</span></code> frame
F’s angular velocity ω measured and expressed in the world frame
W).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_.Frame_[float].CalcOffsetPoseInBody">
<code class="descname">CalcOffsetPoseInBody</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float], context: pydrake.systems.framework.Context_[float], X_FQ: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.multibody.tree.Frame_.Frame_[float].CalcOffsetPoseInBody" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the offset pose <code class="docutils literal notranslate"><span class="pre">X_FQ</span></code> of a frame Q in <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F, this
method computes the pose <code class="docutils literal notranslate"><span class="pre">X_BQ</span></code> of frame Q in the body frame B to
which this frame is attached. In other words, if the pose of <code class="docutils literal notranslate"><span class="pre">this</span></code>
frame F in the body frame B is <code class="docutils literal notranslate"><span class="pre">X_BF</span></code>, this method computes the pose
<code class="docutils literal notranslate"><span class="pre">X_BQ</span></code> of frame Q in the body frame B as <code class="docutils literal notranslate"><span class="pre">X_BQ</span> <span class="pre">=</span> <span class="pre">X_BF</span> <span class="pre">*</span> <span class="pre">X_FQ</span></code>. In
particular, if <code class="docutils literal notranslate"><span class="pre">this</span></code> <a href="#id1"><span class="problematic" id="id2">**</span></a>is**` the body frame B, i.e. <code class="docutils literal notranslate"><span class="pre">X_BF</span></code> is the
identity transformation, this method directly returns <code class="docutils literal notranslate"><span class="pre">X_FQ</span></code>.
Specific frame subclasses can override this method to provide faster
implementations if needed.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_.Frame_[float].CalcOffsetRotationMatrixInBody">
<code class="descname">CalcOffsetRotationMatrixInBody</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float], context: pydrake.systems.framework.Context_[float], R_FQ: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[float]<a class="headerlink" href="#pydrake.multibody.tree.Frame_.Frame_[float].CalcOffsetRotationMatrixInBody" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates and returns the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_BQ</span></code> that relates body
frame B to frame Q via <code class="docutils literal notranslate"><span class="pre">this</span></code> intermediate frame F, i.e., <code class="docutils literal notranslate"><span class="pre">R_BQ</span> <span class="pre">=</span>
<span class="pre">R_BF</span> <span class="pre">*</span> <span class="pre">R_FQ</span></code> (B is the body frame to which <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F is
attached).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_FQ</span></code>:</dt>
<dd>rotation matrix that relates frame F to frame Q.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_.Frame_[float].CalcPose">
<code class="descname">CalcPose</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float], context: pydrake.systems.framework.Context_[float], frame_M: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.multibody.tree.Frame_.Frame_[float].CalcPose" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes and returns the pose <code class="docutils literal notranslate"><span class="pre">X_MF</span></code> of <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F in measured
in <code class="docutils literal notranslate"><span class="pre">frame_M</span></code> as a function of the state of the model stored in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcPoseInWorld().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_.Frame_[float].CalcPoseInBodyFrame">
<code class="descname">CalcPoseInBodyFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.multibody.tree.Frame_.Frame_[float].CalcPoseInBodyFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pose <code class="docutils literal notranslate"><span class="pre">X_BF</span></code> of <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F in the body frame B
associated with this frame. In particular, if <code class="docutils literal notranslate"><span class="pre">this</span></code> <strong>is</strong> the body
frame B, this method directly returns the identity transformation.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_.Frame_[float].CalcPoseInWorld">
<code class="descname">CalcPoseInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.multibody.tree.Frame_.Frame_[float].CalcPoseInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes and returns the pose <code class="docutils literal notranslate"><span class="pre">X_WF</span></code> of <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F in the
world frame W as a function of the state of the model stored in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Body::EvalPoseInWorld() provides a more efficient way to obtain
the pose for a body frame.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_.Frame_[float].CalcRelativeSpatialAcceleration">
<code class="descname">CalcRelativeSpatialAcceleration</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float], context: pydrake.systems.framework.Context_[float], other_frame: pydrake.multibody.tree.Frame_[float], measured_in_frame: pydrake.multibody.tree.Frame_[float], expressed_in_frame: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[float]<a class="headerlink" href="#pydrake.multibody.tree.Frame_.Frame_[float].CalcRelativeSpatialAcceleration" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame C’s spatial acceleration relative to another
frame B, measured in a frame M, expressed in a frame E.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other_frame</span></code>:</dt>
<dd>which is frame B.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">measured_in_frame</span></code>:</dt>
<dd>which is frame M.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">expressed_in_frame</span></code>:</dt>
<dd>which is frame E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A_M_BC_E = A_MC_E - A_MB_E, frame C’s spatial acceleration
relative to frame B, measured in frame M, expressed in frame E.</td>
</tr>
</tbody>
</table>
<p>In general, A_M_BC = DtW(V_M_BC), the time-derivative in frame M of
frame C’s spatial velocity relative to frame B. The rotational part of
the returned quantity is α_MC_E - α_MB_E = DtM(ω_BC)_E. Note: For 3D
analysis, DtM(ω_BC) ≠ α_BC. The translational part of the returned
quantity is a_M_BoCo_E (Co’s translational acceleration relative to
Bo, measured in frame M, expressed in frame E).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>α_MC_E - α_MB_E = DtM(ω_MC)_E - DtM(ω_MB)_E = DtM(ω_BC)_E
 a_M_BoCo_E = a_MCo_E - a_MBo_E = DtM(v_MCo) - DtM(v_MBo) = Dt²M(p_BoCo)_E
</pre></div>
</div>
<p>where Dt²M(p_BoCo)_E is the 2ⁿᵈ time-derivative in frame M of p_BoCo
(the position vector from Bo to Co), and this result is expressed in
frame E.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The calculation of the 2ⁿᵈ time-derivative of the distance between
Bo and Co can be done with relative translational acceleration,
but this calculation does not depend on the measured-in-frame,
hence in this case, consider
CalcRelativeSpatialAccelerationInWorld() since it is faster.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcSpatialAccelerationInWorld(), CalcSpatialAcceleration(), and
CalcRelativeSpatialAccelerationInWorld().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_.Frame_[float].CalcRelativeSpatialAccelerationInWorld">
<code class="descname">CalcRelativeSpatialAccelerationInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float], context: pydrake.systems.framework.Context_[float], other_frame: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[float]<a class="headerlink" href="#pydrake.multibody.tree.Frame_.Frame_[float].CalcRelativeSpatialAccelerationInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame C’s spatial acceleration relative to another
frame B, measured and expressed in the world frame W.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other_frame</span></code>:</dt>
<dd>which is frame B.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A_W_BC_W = A_WC_W - A_WB_W, frame C’s spatial acceleration
relative to frame B, measured and expressed in the world frame W.</td>
</tr>
</tbody>
</table>
<p>In general, A_W_BC = DtW(V_W_BC), the time-derivative in the world
frame W of frame C’s spatial velocity relative to frame B. The
rotational part of the returned quantity is α_WC_W - α_WB_W =
DtW(ω_BC)_W. For 3D analysis, DtW(ω_BC) ≠ α_BC. The translational part
of the returned quantity is a_W_BoCo_W (Co’s translational
acceleration relative to Bo, measured and expressed in world frame W).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>α_WC_W - α_WB_W = DtW(ω_WC)_W - DtW(ω_WB)_W = DtW(ω_BC)_W
 a_W_BoCo_W = a_WCo_W - a_WBo_W = DtW(v_WCo) - DtW(v_WBo) = Dt²W(p_BoCo)_W
</pre></div>
</div>
<p>where Dt²W(p_BoCo)_W is the 2ⁿᵈ time-derivative in frame W of p_BoCo
(the position vector from Bo to Co), and this result is expressed in
frame W.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The method CalcSpatialAccelerationInWorld() is more efficient and
coherent if any of <code class="docutils literal notranslate"><span class="pre">this</span></code>, other_frame, or the world frame W are
the same.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcSpatialAccelerationInWorld(),
CalcRelativeSpatialAcceleration().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_.Frame_[float].CalcRelativeSpatialVelocity">
<code class="descname">CalcRelativeSpatialVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float], context: pydrake.systems.framework.Context_[float], other_frame: pydrake.multibody.tree.Frame_[float], measured_in_frame: pydrake.multibody.tree.Frame_[float], expressed_in_frame: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[float]<a class="headerlink" href="#pydrake.multibody.tree.Frame_.Frame_[float].CalcRelativeSpatialVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame C’s spatial velocity relative to another
frame B, measured in a frame M, expressed in a frame E.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other_frame</span></code>:</dt>
<dd>which is frame B.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">measured_in_frame</span></code>:</dt>
<dd>which is frame M.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">expressed_in_frame</span></code>:</dt>
<dd>which is frame E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">V_M_BC_E = V_MC_E - V_MB_E, frame C’s spatial velocity relative to
frame B, measured in frame M, expressed in frame E. The rotational
part of the returned quantity is ω_BC_E (C’s angular velocity
measured in B and expressed in E). The translational part is
v_M_BoCo_E (Co’s translational velocity relative to Bo, measured
in M, and expressed in E).</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ω_BC_E</span> <span class="o">=</span> <span class="n">ω_MC_E</span> <span class="o">-</span> <span class="n">ω_MB_E</span>
 <span class="n">v_M_BoCo_E</span> <span class="o">=</span> <span class="n">v_MCo_E</span> <span class="o">-</span> <span class="n">v_MBo_E</span> <span class="o">=</span> <span class="n">DtM</span><span class="p">(</span><span class="n">p_BoCo</span><span class="p">)</span>
</pre></div>
</div>
<p>where DtM(p_BoCo) is the time-derivative in frame M of p_BoCo
(position vector from Bo to Co), and this vector is expressed in frame
E.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The method CalcSpatialVelocity() is more efficient and coherent if
any of <code class="docutils literal notranslate"><span class="pre">this</span></code>, other_frame, or measured_in_frame are the same.
Also, the value of V_M_BoCo does not depend on the
measured_in_frame if Bo and Co are coincident (i.e., p_BoCo = 0),
in which case consider the more efficient method
CalcRelativeSpatialVelocityInWorld(). Lastly, the calculation of
elongation between Bo and Co can be done with relative
translational velocity, but elongation does not depend on the
measured-in-frame (hence consider
CalcRelativeSpatialVelocityInWorld()).</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcSpatialVelocityInWorld(), CalcSpatialVelocity(), and
CalcRelativeSpatialVelocityInWorld().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_.Frame_[float].CalcRelativeSpatialVelocityInWorld">
<code class="descname">CalcRelativeSpatialVelocityInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float], context: pydrake.systems.framework.Context_[float], other_frame: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[float]<a class="headerlink" href="#pydrake.multibody.tree.Frame_.Frame_[float].CalcRelativeSpatialVelocityInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame C’s spatial velocity relative to another
frame B, measured and expressed in the world frame W.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other_frame</span></code>:</dt>
<dd>which is frame B.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">V_W_BC_W = V_WC_W - V_WB_W, frame C’s spatial velocity relative to
frame B, measured and expressed in the world frame W. The
rotational part of the returned quantity is ω_BC_W (C’s angular
velocity measured in B and expressed in W). The translational part
is v_W_BoCo_W (Co’s translational velocity relative to Bo,
measured and expressed in world frame W).</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ω_BC_W</span>  <span class="o">=</span> <span class="n">ω_WC_W</span> <span class="o">-</span> <span class="n">ω_WB_W</span>
 <span class="n">v_W_BoCo_W</span> <span class="o">=</span> <span class="n">v_WCo_W</span> <span class="o">-</span> <span class="n">v_WBo_W</span> <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">p_BoCo</span><span class="p">)</span>
</pre></div>
</div>
<p>where DtW(p_BoCo) is the time-derivative in frame W of p_BoCo
(position vector from Bo to Co), and this vector is expressed in frame
W.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The method CalcSpatialVelocityInWorld() is more efficient and
coherent if any of <code class="docutils literal notranslate"><span class="pre">this</span></code>, other_frame, or the world frame W are
the same.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcSpatialVelocityInWorld() and CalcRelativeSpatialVelocity().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_.Frame_[float].CalcRotationMatrix">
<code class="descname">CalcRotationMatrix</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float], context: pydrake.systems.framework.Context_[float], frame_M: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[float]<a class="headerlink" href="#pydrake.multibody.tree.Frame_.Frame_[float].CalcRotationMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates and returns the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_MF</span></code> that relates
<code class="docutils literal notranslate"><span class="pre">frame_M</span></code> and <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F as a function of the state stored in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_.Frame_[float].CalcRotationMatrixInBodyFrame">
<code class="descname">CalcRotationMatrixInBodyFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[float]<a class="headerlink" href="#pydrake.multibody.tree.Frame_.Frame_[float].CalcRotationMatrixInBodyFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_BF</span></code> that relates body frame B to
<code class="docutils literal notranslate"><span class="pre">this</span></code> frame F (B is the body frame to which <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F is
attached).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If <code class="docutils literal notranslate"><span class="pre">this</span></code> is B, this method returns the identity RotationMatrix.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_.Frame_[float].CalcRotationMatrixInWorld">
<code class="descname">CalcRotationMatrixInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[float]<a class="headerlink" href="#pydrake.multibody.tree.Frame_.Frame_[float].CalcRotationMatrixInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates and returns the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_WF</span></code> that relates the
world frame W and <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F as a function of the state stored
in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_.Frame_[float].CalcSpatialAcceleration">
<code class="descname">CalcSpatialAcceleration</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float], context: pydrake.systems.framework.Context_[float], measured_in_frame: pydrake.multibody.tree.Frame_[float], expressed_in_frame: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[float]<a class="headerlink" href="#pydrake.multibody.tree.Frame_.Frame_[float].CalcSpatialAcceleration" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial acceleration measured in a frame
M, expressed in a frame E.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">measured_in_frame</span></code>:</dt>
<dd>which is frame M.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">expressed_in_frame</span></code>:</dt>
<dd>which is frame E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A_MF_E, <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial acceleration measured in frame
M, expressed in frame E. The rotational part of the returned
quantity is α_MF_E (frame F’s angular acceleration α measured in
frame M, expressed in frame E). The translational part is a_MFo_E
(translational acceleration of frame F’s origin point Fo, measured
in frame M, expressed in frame E). Although α_MF is defined below
in terms of DtM(ω_MF), the time-derivative in frame M of ω_MF, the
actual calculation of α_MF avoids differentiation. Similarly for
the definition vs. calculation for a_MFo.</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">α_MF</span> <span class="o">=</span> <span class="n">DtM</span><span class="p">(</span><span class="n">ω_MF</span><span class="p">)</span>           <span class="n">ω_MF</span> <span class="ow">is</span> <span class="n">frame</span> <span class="n">F</span><span class="s1">&#39;s angular velocity in frame M.</span>
 <span class="n">a_MFo</span> <span class="o">=</span> <span class="n">DtM</span><span class="p">(</span><span class="n">v_MFo</span><span class="p">)</span>    <span class="n">v_MF</span> <span class="ow">is</span> <span class="n">Fo</span><span class="s1">&#39;s translational acceleration in frame M.</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcSpatialAccelerationInWorld() and CalcSpatialVelocity().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_.Frame_[float].CalcSpatialAccelerationInWorld">
<code class="descname">CalcSpatialAccelerationInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[float]<a class="headerlink" href="#pydrake.multibody.tree.Frame_.Frame_[float].CalcSpatialAccelerationInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial acceleration measured and
expressed in the world frame W.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody system.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A_WF_W, <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial acceleration measured and
expressed in the world frame W. The rotational part of the
returned quantity is α_WF_E (frame F’s angular acceleration α
measured and expressed in the world frame W). The translational
part is a_WFo_W (translational acceleration of frame F’s origin
point Fo, measured and expressed in the world frame W).</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Body::EvalSpatialAccelerationInWorld() provides a more efficient
way to obtain a body frame’s spatial acceleration measured in the
world frame.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When cached values are out of sync with the state stored in
context, this method performs an expensive forward dynamics
computation, whereas once evaluated, successive calls to this
method are inexpensive.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcSpatialAcceleration() and CalcSpatialVelocityInWorld().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_.Frame_[float].CalcSpatialVelocity">
<code class="descname">CalcSpatialVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float], context: pydrake.systems.framework.Context_[float], frame_M: pydrake.multibody.tree.Frame_[float], frame_E: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[float]<a class="headerlink" href="#pydrake.multibody.tree.Frame_.Frame_[float].CalcSpatialVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial velocity measured in a frame M,
expressed in a frame E.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_M</span></code>:</dt>
<dd>which is the measured_in_frame.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt>
<dd>which is the expressed_in_frame.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">V_MF_E, <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial velocity measured in frame M,
expressed in frame E. The rotational part of the returned quantity
is ω_MF_E (frame F’s angular velocity ω measured in frame M,
expressed in frame E). The translational part is v_MFo_E
(translational velocity v of frame F’s origin point Fo, measured
in frame M, expressed in frame E).</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcSpatialVelocityInWorld(), CalcRelativeSpatialVelocity(), and
CalcSpatialAcceleration().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_.Frame_[float].CalcSpatialVelocityInWorld">
<code class="descname">CalcSpatialVelocityInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[float]<a class="headerlink" href="#pydrake.multibody.tree.Frame_.Frame_[float].CalcSpatialVelocityInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial velocity measured and expressed
in the world frame W.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody system.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">V_WF_W, <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial velocity measured and expressed
in the world frame W. The rotational part of the returned quantity
is ω_WF_W (frame F’s angular velocity ω measured and expressed in
the world frame W). The translational part is v_WFo_W
(translational velocity v of frame F’s origin point Fo, measured
and expressed in the world frame W).</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Body::EvalSpatialVelocityInWorld() provides a more efficient way
to obtain a body frame’s spatial velocity measured in the world
frame.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcSpatialVelocity(), CalcRelativeSpatialVelocityInWorld(), and
CalcSpatialAccelerationInWorld().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_.Frame_[float].EvalAngularVelocityInWorld">
<code class="descname">EvalAngularVelocityInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Frame_.Frame_[float].EvalAngularVelocityInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s angular velocity measured and expressed
in the world frame W.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody system.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">ω_WF_W (frame F’s angular velocity ω measured and expressed in the
world frame W).</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcAngularVelocity() to calculate ω_MF_E (<code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s
angular velocity ω measured in a frame M and expressed in a frame
E).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_.Frame_[float].GetFixedOffsetPoseInBody">
<code class="descname">GetFixedOffsetPoseInBody</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float], X_FQ: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.multibody.tree.Frame_.Frame_[float].GetFixedOffsetPoseInBody" title="Permalink to this definition">¶</a></dt>
<dd><p>Variant of CalcOffsetPoseInBody() that given the offset pose <code class="docutils literal notranslate"><span class="pre">X_FQ</span></code>
of a frame Q in <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F, returns the pose <code class="docutils literal notranslate"><span class="pre">X_BQ</span></code> of frame Q
in the body frame B to which this frame is attached.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called on a Frame that does not have a fixed</li>
<li>offset in the body frame.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_.Frame_[float].GetFixedPoseInBodyFrame">
<code class="descname">GetFixedPoseInBodyFrame</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.Frame_.Frame_[float].GetFixedPoseInBodyFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>GetFixedPoseInBodyFrame(self: pydrake.multibody.tree.Frame_[float]) -&gt; pydrake.math.RigidTransform_[float]</li>
</ol>
<p>Variant of CalcPoseInBodyFrame() that returns the fixed pose <code class="docutils literal notranslate"><span class="pre">X_BF</span></code>
of <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F in the body frame B associated with this frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called on a Frame that does not have a fixed</li>
<li>offset in the body frame.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>GetFixedPoseInBodyFrame(self: pydrake.multibody.tree.Frame_[float]) -&gt; pydrake.math.RigidTransform_[float]</li>
</ol>
<p>Variant of CalcPoseInBodyFrame() that returns the fixed pose <code class="docutils literal notranslate"><span class="pre">X_BF</span></code>
of <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F in the body frame B associated with this frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called on a Frame that does not have a fixed</li>
<li>offset in the body frame.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_.Frame_[float].GetFixedRotationMatrixInBody">
<code class="descname">GetFixedRotationMatrixInBody</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float], R_FQ: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[float]<a class="headerlink" href="#pydrake.multibody.tree.Frame_.Frame_[float].GetFixedRotationMatrixInBody" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates and returns the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_BQ</span></code> that relates body
frame B to frame Q via <code class="docutils literal notranslate"><span class="pre">this</span></code> intermediate frame F, i.e., <code class="docutils literal notranslate"><span class="pre">R_BQ</span> <span class="pre">=</span>
<span class="pre">R_BF</span> <span class="pre">*</span> <span class="pre">R_FQ</span></code> (B is the body frame to which <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F is
attached).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_FQ</span></code>:</dt>
<dd>rotation matrix that relates frame F to frame Q.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F is a Frame that does not have a</li>
<li>fixed offset in the body frame B (i.e., <code class="docutils literal notranslate"><span class="pre">R_BF</span></code> is not constant).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_.Frame_[float].GetFixedRotationMatrixInBodyFrame">
<code class="descname">GetFixedRotationMatrixInBodyFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[float]<a class="headerlink" href="#pydrake.multibody.tree.Frame_.Frame_[float].GetFixedRotationMatrixInBodyFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_BF</span></code> that relates body frame B to
<code class="docutils literal notranslate"><span class="pre">this</span></code> frame F (B is the body frame to which <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F is
attached).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F is a Frame that does not have a</li>
<li>fixed offset in the body frame B (i.e., <code class="docutils literal notranslate"><span class="pre">R_BF</span></code> is not constant).</li>
<li>Frame sub-classes that have a constant <code class="docutils literal notranslate"><span class="pre">R_BF</span></code> must override this</li>
<li>method. An example of a frame sub-class not implementing this</li>
<li>method would be that of a frame on a soft body, for which its pose</li>
<li>in the body frame depends on the state of deformation of the body.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_.Frame_[float].GetParentPlant">
<code class="descname">GetParentPlant</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; drake::multibody::MultibodyPlant&lt;double&gt;<a class="headerlink" href="#pydrake.multibody.tree.Frame_.Frame_[float].GetParentPlant" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_.Frame_[float].index">
<code class="descname">index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.FrameIndex<a class="headerlink" href="#pydrake.multibody.tree.Frame_.Frame_[float].index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_.Frame_[float].is_body_frame">
<code class="descname">is_body_frame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.Frame_.Frame_[float].is_body_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if <code class="docutils literal notranslate"><span class="pre">this</span></code> is the body frame.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_.Frame_[float].is_world_frame">
<code class="descname">is_world_frame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.Frame_.Frame_[float].is_world_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if <code class="docutils literal notranslate"><span class="pre">this</span></code> is the world frame.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_.Frame_[float].model_instance">
<code class="descname">model_instance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.Frame_.Frame_[float].model_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_.Frame_[float].name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Frame_.Frame_[float].name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name of this frame. The name will never be empty.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.Frame_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">Frame_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.Frame_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>%Frame is an abstract class representing a <em>material frame</em> (also
called a <em>physical frame</em>), meaning that the Frame’s origin is a
material point of a Body.</p>
<p>An important characteristic of a Frame is that forces or torques
applied to a Frame are applied to the Frame’s underlying Body.
Force-producing elements like joints, actuators, and constraints
usually employ two Frames, with one Frame connected to one body and
the other connected to a different Body. Every Frame object can report
the Body to which it is attached. Despite its name, Frame is not the
most general frame in Drake (see FrameBase for more information).</p>
<p>A Frame’s pose in World (or relative to other frames) is always
calculated starting with its pose relative to its underlying Body’s
BodyFrame. Subclasses derived from Frame differ in how kinematic
calculations are performed. For example, the angular velocity of a
FixedOffsetFrame or BodyFrame is identical to the angular velocity of
its underlying body, whereas the translational velocity of a
FixedOffsetFrame differs from that of a BodyFrame. If a Frame is
associated with a soft body, kinematic calculations can depend on the
soft body’s deformation state variables.</p>
<p>A Frame object does <em>not</em> store a Context (where Context means state
that contains the Frame’s current orientation, position, motion,
etc.). Instead, Frame provides methods for calculating these
Frame-properties from a Context passed to Frame methods.</p>
<dl class="attribute">
<dt id="pydrake.multibody.tree.Frame_[AutoDiffXd].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.Frame_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[AutoDiffXd].body">
<code class="descname">body</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; drake::multibody::Body&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;<a class="headerlink" href="#pydrake.multibody.tree.Frame_[AutoDiffXd].body" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the body associated to this Frame.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[AutoDiffXd].CalcAngularVelocity">
<code class="descname">CalcAngularVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], measured_in_frame: pydrake.multibody.tree.Frame_[AutoDiffXd], expressed_in_frame: pydrake.multibody.tree.Frame_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[AutoDiffXd].CalcAngularVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s angular velocity measured in a frame M,
expressed in a frame E.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">measured_in_frame</span></code>:</dt>
<dd>which is frame M (the frame in which <code class="docutils literal notranslate"><span class="pre">this</span></code> angular velocity is
to be measured).</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">expressed_in_frame</span></code>:</dt>
<dd>which is frame E (the frame in which the returned angular velocity
is to be expressed).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">ω_MF_E, <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s angular velocity ω measured in frame M,
expressed in frame E.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">EvalAngularVelocityInWorld() to evaluate ω_WF_W (<code class="docutils literal notranslate"><span class="pre">this</span></code> frame
F’s angular velocity ω measured and expressed in the world frame
W).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[AutoDiffXd].CalcOffsetPoseInBody">
<code class="descname">CalcOffsetPoseInBody</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], X_FQ: pydrake.math.RigidTransform_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[AutoDiffXd].CalcOffsetPoseInBody" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the offset pose <code class="docutils literal notranslate"><span class="pre">X_FQ</span></code> of a frame Q in <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F, this
method computes the pose <code class="docutils literal notranslate"><span class="pre">X_BQ</span></code> of frame Q in the body frame B to
which this frame is attached. In other words, if the pose of <code class="docutils literal notranslate"><span class="pre">this</span></code>
frame F in the body frame B is <code class="docutils literal notranslate"><span class="pre">X_BF</span></code>, this method computes the pose
<code class="docutils literal notranslate"><span class="pre">X_BQ</span></code> of frame Q in the body frame B as <code class="docutils literal notranslate"><span class="pre">X_BQ</span> <span class="pre">=</span> <span class="pre">X_BF</span> <span class="pre">*</span> <span class="pre">X_FQ</span></code>. In
particular, if <code class="docutils literal notranslate"><span class="pre">this</span></code> <a href="#id3"><span class="problematic" id="id4">**</span></a>is**` the body frame B, i.e. <code class="docutils literal notranslate"><span class="pre">X_BF</span></code> is the
identity transformation, this method directly returns <code class="docutils literal notranslate"><span class="pre">X_FQ</span></code>.
Specific frame subclasses can override this method to provide faster
implementations if needed.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[AutoDiffXd].CalcOffsetRotationMatrixInBody">
<code class="descname">CalcOffsetRotationMatrixInBody</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], R_FQ: pydrake.math.RotationMatrix_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[AutoDiffXd].CalcOffsetRotationMatrixInBody" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates and returns the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_BQ</span></code> that relates body
frame B to frame Q via <code class="docutils literal notranslate"><span class="pre">this</span></code> intermediate frame F, i.e., <code class="docutils literal notranslate"><span class="pre">R_BQ</span> <span class="pre">=</span>
<span class="pre">R_BF</span> <span class="pre">*</span> <span class="pre">R_FQ</span></code> (B is the body frame to which <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F is
attached).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_FQ</span></code>:</dt>
<dd>rotation matrix that relates frame F to frame Q.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[AutoDiffXd].CalcPose">
<code class="descname">CalcPose</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], frame_M: pydrake.multibody.tree.Frame_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[AutoDiffXd].CalcPose" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes and returns the pose <code class="docutils literal notranslate"><span class="pre">X_MF</span></code> of <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F in measured
in <code class="docutils literal notranslate"><span class="pre">frame_M</span></code> as a function of the state of the model stored in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcPoseInWorld().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[AutoDiffXd].CalcPoseInBodyFrame">
<code class="descname">CalcPoseInBodyFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[AutoDiffXd].CalcPoseInBodyFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pose <code class="docutils literal notranslate"><span class="pre">X_BF</span></code> of <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F in the body frame B
associated with this frame. In particular, if <code class="docutils literal notranslate"><span class="pre">this</span></code> <strong>is</strong> the body
frame B, this method directly returns the identity transformation.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[AutoDiffXd].CalcPoseInWorld">
<code class="descname">CalcPoseInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[AutoDiffXd].CalcPoseInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes and returns the pose <code class="docutils literal notranslate"><span class="pre">X_WF</span></code> of <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F in the
world frame W as a function of the state of the model stored in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Body::EvalPoseInWorld() provides a more efficient way to obtain
the pose for a body frame.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[AutoDiffXd].CalcRelativeSpatialAcceleration">
<code class="descname">CalcRelativeSpatialAcceleration</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], other_frame: pydrake.multibody.tree.Frame_[AutoDiffXd], measured_in_frame: pydrake.multibody.tree.Frame_[AutoDiffXd], expressed_in_frame: pydrake.multibody.tree.Frame_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[AutoDiffXd].CalcRelativeSpatialAcceleration" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame C’s spatial acceleration relative to another
frame B, measured in a frame M, expressed in a frame E.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other_frame</span></code>:</dt>
<dd>which is frame B.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">measured_in_frame</span></code>:</dt>
<dd>which is frame M.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">expressed_in_frame</span></code>:</dt>
<dd>which is frame E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A_M_BC_E = A_MC_E - A_MB_E, frame C’s spatial acceleration
relative to frame B, measured in frame M, expressed in frame E.</td>
</tr>
</tbody>
</table>
<p>In general, A_M_BC = DtW(V_M_BC), the time-derivative in frame M of
frame C’s spatial velocity relative to frame B. The rotational part of
the returned quantity is α_MC_E - α_MB_E = DtM(ω_BC)_E. Note: For 3D
analysis, DtM(ω_BC) ≠ α_BC. The translational part of the returned
quantity is a_M_BoCo_E (Co’s translational acceleration relative to
Bo, measured in frame M, expressed in frame E).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>α_MC_E - α_MB_E = DtM(ω_MC)_E - DtM(ω_MB)_E = DtM(ω_BC)_E
 a_M_BoCo_E = a_MCo_E - a_MBo_E = DtM(v_MCo) - DtM(v_MBo) = Dt²M(p_BoCo)_E
</pre></div>
</div>
<p>where Dt²M(p_BoCo)_E is the 2ⁿᵈ time-derivative in frame M of p_BoCo
(the position vector from Bo to Co), and this result is expressed in
frame E.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The calculation of the 2ⁿᵈ time-derivative of the distance between
Bo and Co can be done with relative translational acceleration,
but this calculation does not depend on the measured-in-frame,
hence in this case, consider
CalcRelativeSpatialAccelerationInWorld() since it is faster.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcSpatialAccelerationInWorld(), CalcSpatialAcceleration(), and
CalcRelativeSpatialAccelerationInWorld().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[AutoDiffXd].CalcRelativeSpatialAccelerationInWorld">
<code class="descname">CalcRelativeSpatialAccelerationInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], other_frame: pydrake.multibody.tree.Frame_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[AutoDiffXd].CalcRelativeSpatialAccelerationInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame C’s spatial acceleration relative to another
frame B, measured and expressed in the world frame W.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other_frame</span></code>:</dt>
<dd>which is frame B.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A_W_BC_W = A_WC_W - A_WB_W, frame C’s spatial acceleration
relative to frame B, measured and expressed in the world frame W.</td>
</tr>
</tbody>
</table>
<p>In general, A_W_BC = DtW(V_W_BC), the time-derivative in the world
frame W of frame C’s spatial velocity relative to frame B. The
rotational part of the returned quantity is α_WC_W - α_WB_W =
DtW(ω_BC)_W. For 3D analysis, DtW(ω_BC) ≠ α_BC. The translational part
of the returned quantity is a_W_BoCo_W (Co’s translational
acceleration relative to Bo, measured and expressed in world frame W).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>α_WC_W - α_WB_W = DtW(ω_WC)_W - DtW(ω_WB)_W = DtW(ω_BC)_W
 a_W_BoCo_W = a_WCo_W - a_WBo_W = DtW(v_WCo) - DtW(v_WBo) = Dt²W(p_BoCo)_W
</pre></div>
</div>
<p>where Dt²W(p_BoCo)_W is the 2ⁿᵈ time-derivative in frame W of p_BoCo
(the position vector from Bo to Co), and this result is expressed in
frame W.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The method CalcSpatialAccelerationInWorld() is more efficient and
coherent if any of <code class="docutils literal notranslate"><span class="pre">this</span></code>, other_frame, or the world frame W are
the same.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcSpatialAccelerationInWorld(),
CalcRelativeSpatialAcceleration().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[AutoDiffXd].CalcRelativeSpatialVelocity">
<code class="descname">CalcRelativeSpatialVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], other_frame: pydrake.multibody.tree.Frame_[AutoDiffXd], measured_in_frame: pydrake.multibody.tree.Frame_[AutoDiffXd], expressed_in_frame: pydrake.multibody.tree.Frame_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[AutoDiffXd].CalcRelativeSpatialVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame C’s spatial velocity relative to another
frame B, measured in a frame M, expressed in a frame E.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other_frame</span></code>:</dt>
<dd>which is frame B.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">measured_in_frame</span></code>:</dt>
<dd>which is frame M.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">expressed_in_frame</span></code>:</dt>
<dd>which is frame E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">V_M_BC_E = V_MC_E - V_MB_E, frame C’s spatial velocity relative to
frame B, measured in frame M, expressed in frame E. The rotational
part of the returned quantity is ω_BC_E (C’s angular velocity
measured in B and expressed in E). The translational part is
v_M_BoCo_E (Co’s translational velocity relative to Bo, measured
in M, and expressed in E).</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ω_BC_E</span> <span class="o">=</span> <span class="n">ω_MC_E</span> <span class="o">-</span> <span class="n">ω_MB_E</span>
 <span class="n">v_M_BoCo_E</span> <span class="o">=</span> <span class="n">v_MCo_E</span> <span class="o">-</span> <span class="n">v_MBo_E</span> <span class="o">=</span> <span class="n">DtM</span><span class="p">(</span><span class="n">p_BoCo</span><span class="p">)</span>
</pre></div>
</div>
<p>where DtM(p_BoCo) is the time-derivative in frame M of p_BoCo
(position vector from Bo to Co), and this vector is expressed in frame
E.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The method CalcSpatialVelocity() is more efficient and coherent if
any of <code class="docutils literal notranslate"><span class="pre">this</span></code>, other_frame, or measured_in_frame are the same.
Also, the value of V_M_BoCo does not depend on the
measured_in_frame if Bo and Co are coincident (i.e., p_BoCo = 0),
in which case consider the more efficient method
CalcRelativeSpatialVelocityInWorld(). Lastly, the calculation of
elongation between Bo and Co can be done with relative
translational velocity, but elongation does not depend on the
measured-in-frame (hence consider
CalcRelativeSpatialVelocityInWorld()).</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcSpatialVelocityInWorld(), CalcSpatialVelocity(), and
CalcRelativeSpatialVelocityInWorld().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[AutoDiffXd].CalcRelativeSpatialVelocityInWorld">
<code class="descname">CalcRelativeSpatialVelocityInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], other_frame: pydrake.multibody.tree.Frame_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[AutoDiffXd].CalcRelativeSpatialVelocityInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame C’s spatial velocity relative to another
frame B, measured and expressed in the world frame W.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other_frame</span></code>:</dt>
<dd>which is frame B.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">V_W_BC_W = V_WC_W - V_WB_W, frame C’s spatial velocity relative to
frame B, measured and expressed in the world frame W. The
rotational part of the returned quantity is ω_BC_W (C’s angular
velocity measured in B and expressed in W). The translational part
is v_W_BoCo_W (Co’s translational velocity relative to Bo,
measured and expressed in world frame W).</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ω_BC_W</span>  <span class="o">=</span> <span class="n">ω_WC_W</span> <span class="o">-</span> <span class="n">ω_WB_W</span>
 <span class="n">v_W_BoCo_W</span> <span class="o">=</span> <span class="n">v_WCo_W</span> <span class="o">-</span> <span class="n">v_WBo_W</span> <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">p_BoCo</span><span class="p">)</span>
</pre></div>
</div>
<p>where DtW(p_BoCo) is the time-derivative in frame W of p_BoCo
(position vector from Bo to Co), and this vector is expressed in frame
W.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The method CalcSpatialVelocityInWorld() is more efficient and
coherent if any of <code class="docutils literal notranslate"><span class="pre">this</span></code>, other_frame, or the world frame W are
the same.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcSpatialVelocityInWorld() and CalcRelativeSpatialVelocity().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[AutoDiffXd].CalcRotationMatrix">
<code class="descname">CalcRotationMatrix</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], frame_M: pydrake.multibody.tree.Frame_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[AutoDiffXd].CalcRotationMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates and returns the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_MF</span></code> that relates
<code class="docutils literal notranslate"><span class="pre">frame_M</span></code> and <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F as a function of the state stored in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[AutoDiffXd].CalcRotationMatrixInBodyFrame">
<code class="descname">CalcRotationMatrixInBodyFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[AutoDiffXd].CalcRotationMatrixInBodyFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_BF</span></code> that relates body frame B to
<code class="docutils literal notranslate"><span class="pre">this</span></code> frame F (B is the body frame to which <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F is
attached).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If <code class="docutils literal notranslate"><span class="pre">this</span></code> is B, this method returns the identity RotationMatrix.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[AutoDiffXd].CalcRotationMatrixInWorld">
<code class="descname">CalcRotationMatrixInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[AutoDiffXd].CalcRotationMatrixInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates and returns the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_WF</span></code> that relates the
world frame W and <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F as a function of the state stored
in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[AutoDiffXd].CalcSpatialAcceleration">
<code class="descname">CalcSpatialAcceleration</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], measured_in_frame: pydrake.multibody.tree.Frame_[AutoDiffXd], expressed_in_frame: pydrake.multibody.tree.Frame_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[AutoDiffXd].CalcSpatialAcceleration" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial acceleration measured in a frame
M, expressed in a frame E.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">measured_in_frame</span></code>:</dt>
<dd>which is frame M.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">expressed_in_frame</span></code>:</dt>
<dd>which is frame E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A_MF_E, <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial acceleration measured in frame
M, expressed in frame E. The rotational part of the returned
quantity is α_MF_E (frame F’s angular acceleration α measured in
frame M, expressed in frame E). The translational part is a_MFo_E
(translational acceleration of frame F’s origin point Fo, measured
in frame M, expressed in frame E). Although α_MF is defined below
in terms of DtM(ω_MF), the time-derivative in frame M of ω_MF, the
actual calculation of α_MF avoids differentiation. Similarly for
the definition vs. calculation for a_MFo.</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">α_MF</span> <span class="o">=</span> <span class="n">DtM</span><span class="p">(</span><span class="n">ω_MF</span><span class="p">)</span>           <span class="n">ω_MF</span> <span class="ow">is</span> <span class="n">frame</span> <span class="n">F</span><span class="s1">&#39;s angular velocity in frame M.</span>
 <span class="n">a_MFo</span> <span class="o">=</span> <span class="n">DtM</span><span class="p">(</span><span class="n">v_MFo</span><span class="p">)</span>    <span class="n">v_MF</span> <span class="ow">is</span> <span class="n">Fo</span><span class="s1">&#39;s translational acceleration in frame M.</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcSpatialAccelerationInWorld() and CalcSpatialVelocity().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[AutoDiffXd].CalcSpatialAccelerationInWorld">
<code class="descname">CalcSpatialAccelerationInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[AutoDiffXd].CalcSpatialAccelerationInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial acceleration measured and
expressed in the world frame W.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody system.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A_WF_W, <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial acceleration measured and
expressed in the world frame W. The rotational part of the
returned quantity is α_WF_E (frame F’s angular acceleration α
measured and expressed in the world frame W). The translational
part is a_WFo_W (translational acceleration of frame F’s origin
point Fo, measured and expressed in the world frame W).</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Body::EvalSpatialAccelerationInWorld() provides a more efficient
way to obtain a body frame’s spatial acceleration measured in the
world frame.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When cached values are out of sync with the state stored in
context, this method performs an expensive forward dynamics
computation, whereas once evaluated, successive calls to this
method are inexpensive.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcSpatialAcceleration() and CalcSpatialVelocityInWorld().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[AutoDiffXd].CalcSpatialVelocity">
<code class="descname">CalcSpatialVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], frame_M: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_E: pydrake.multibody.tree.Frame_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[AutoDiffXd].CalcSpatialVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial velocity measured in a frame M,
expressed in a frame E.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_M</span></code>:</dt>
<dd>which is the measured_in_frame.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt>
<dd>which is the expressed_in_frame.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">V_MF_E, <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial velocity measured in frame M,
expressed in frame E. The rotational part of the returned quantity
is ω_MF_E (frame F’s angular velocity ω measured in frame M,
expressed in frame E). The translational part is v_MFo_E
(translational velocity v of frame F’s origin point Fo, measured
in frame M, expressed in frame E).</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcSpatialVelocityInWorld(), CalcRelativeSpatialVelocity(), and
CalcSpatialAcceleration().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[AutoDiffXd].CalcSpatialVelocityInWorld">
<code class="descname">CalcSpatialVelocityInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[AutoDiffXd].CalcSpatialVelocityInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial velocity measured and expressed
in the world frame W.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody system.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">V_WF_W, <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial velocity measured and expressed
in the world frame W. The rotational part of the returned quantity
is ω_WF_W (frame F’s angular velocity ω measured and expressed in
the world frame W). The translational part is v_WFo_W
(translational velocity v of frame F’s origin point Fo, measured
and expressed in the world frame W).</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Body::EvalSpatialVelocityInWorld() provides a more efficient way
to obtain a body frame’s spatial velocity measured in the world
frame.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcSpatialVelocity(), CalcRelativeSpatialVelocityInWorld(), and
CalcSpatialAccelerationInWorld().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[AutoDiffXd].EvalAngularVelocityInWorld">
<code class="descname">EvalAngularVelocityInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[AutoDiffXd].EvalAngularVelocityInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s angular velocity measured and expressed
in the world frame W.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody system.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">ω_WF_W (frame F’s angular velocity ω measured and expressed in the
world frame W).</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcAngularVelocity() to calculate ω_MF_E (<code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s
angular velocity ω measured in a frame M and expressed in a frame
E).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[AutoDiffXd].GetFixedOffsetPoseInBody">
<code class="descname">GetFixedOffsetPoseInBody</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[AutoDiffXd], X_FQ: pydrake.math.RigidTransform_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[AutoDiffXd].GetFixedOffsetPoseInBody" title="Permalink to this definition">¶</a></dt>
<dd><p>Variant of CalcOffsetPoseInBody() that given the offset pose <code class="docutils literal notranslate"><span class="pre">X_FQ</span></code>
of a frame Q in <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F, returns the pose <code class="docutils literal notranslate"><span class="pre">X_BQ</span></code> of frame Q
in the body frame B to which this frame is attached.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called on a Frame that does not have a fixed</li>
<li>offset in the body frame.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[AutoDiffXd].GetFixedPoseInBodyFrame">
<code class="descname">GetFixedPoseInBodyFrame</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.Frame_[AutoDiffXd].GetFixedPoseInBodyFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>GetFixedPoseInBodyFrame(self: pydrake.multibody.tree.Frame_[AutoDiffXd]) -&gt; pydrake.math.RigidTransform_[AutoDiffXd]</li>
</ol>
<p>Variant of CalcPoseInBodyFrame() that returns the fixed pose <code class="docutils literal notranslate"><span class="pre">X_BF</span></code>
of <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F in the body frame B associated with this frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called on a Frame that does not have a fixed</li>
<li>offset in the body frame.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>GetFixedPoseInBodyFrame(self: pydrake.multibody.tree.Frame_[AutoDiffXd]) -&gt; pydrake.math.RigidTransform_[AutoDiffXd]</li>
</ol>
<p>Variant of CalcPoseInBodyFrame() that returns the fixed pose <code class="docutils literal notranslate"><span class="pre">X_BF</span></code>
of <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F in the body frame B associated with this frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called on a Frame that does not have a fixed</li>
<li>offset in the body frame.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[AutoDiffXd].GetFixedRotationMatrixInBody">
<code class="descname">GetFixedRotationMatrixInBody</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[AutoDiffXd], R_FQ: pydrake.math.RotationMatrix_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[AutoDiffXd].GetFixedRotationMatrixInBody" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates and returns the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_BQ</span></code> that relates body
frame B to frame Q via <code class="docutils literal notranslate"><span class="pre">this</span></code> intermediate frame F, i.e., <code class="docutils literal notranslate"><span class="pre">R_BQ</span> <span class="pre">=</span>
<span class="pre">R_BF</span> <span class="pre">*</span> <span class="pre">R_FQ</span></code> (B is the body frame to which <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F is
attached).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_FQ</span></code>:</dt>
<dd>rotation matrix that relates frame F to frame Q.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F is a Frame that does not have a</li>
<li>fixed offset in the body frame B (i.e., <code class="docutils literal notranslate"><span class="pre">R_BF</span></code> is not constant).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[AutoDiffXd].GetFixedRotationMatrixInBodyFrame">
<code class="descname">GetFixedRotationMatrixInBodyFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[AutoDiffXd].GetFixedRotationMatrixInBodyFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_BF</span></code> that relates body frame B to
<code class="docutils literal notranslate"><span class="pre">this</span></code> frame F (B is the body frame to which <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F is
attached).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F is a Frame that does not have a</li>
<li>fixed offset in the body frame B (i.e., <code class="docutils literal notranslate"><span class="pre">R_BF</span></code> is not constant).</li>
<li>Frame sub-classes that have a constant <code class="docutils literal notranslate"><span class="pre">R_BF</span></code> must override this</li>
<li>method. An example of a frame sub-class not implementing this</li>
<li>method would be that of a frame on a soft body, for which its pose</li>
<li>in the body frame depends on the state of deformation of the body.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[AutoDiffXd].GetParentPlant">
<code class="descname">GetParentPlant</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; drake::multibody::MultibodyPlant&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;<a class="headerlink" href="#pydrake.multibody.tree.Frame_[AutoDiffXd].GetParentPlant" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[AutoDiffXd].index">
<code class="descname">index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.FrameIndex<a class="headerlink" href="#pydrake.multibody.tree.Frame_[AutoDiffXd].index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[AutoDiffXd].is_body_frame">
<code class="descname">is_body_frame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.Frame_[AutoDiffXd].is_body_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if <code class="docutils literal notranslate"><span class="pre">this</span></code> is the body frame.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[AutoDiffXd].is_world_frame">
<code class="descname">is_world_frame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.Frame_[AutoDiffXd].is_world_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if <code class="docutils literal notranslate"><span class="pre">this</span></code> is the world frame.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[AutoDiffXd].model_instance">
<code class="descname">model_instance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.Frame_[AutoDiffXd].model_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[AutoDiffXd].name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Frame_[AutoDiffXd].name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name of this frame. The name will never be empty.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.Frame_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">Frame_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.Frame_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>%Frame is an abstract class representing a <em>material frame</em> (also
called a <em>physical frame</em>), meaning that the Frame’s origin is a
material point of a Body.</p>
<p>An important characteristic of a Frame is that forces or torques
applied to a Frame are applied to the Frame’s underlying Body.
Force-producing elements like joints, actuators, and constraints
usually employ two Frames, with one Frame connected to one body and
the other connected to a different Body. Every Frame object can report
the Body to which it is attached. Despite its name, Frame is not the
most general frame in Drake (see FrameBase for more information).</p>
<p>A Frame’s pose in World (or relative to other frames) is always
calculated starting with its pose relative to its underlying Body’s
BodyFrame. Subclasses derived from Frame differ in how kinematic
calculations are performed. For example, the angular velocity of a
FixedOffsetFrame or BodyFrame is identical to the angular velocity of
its underlying body, whereas the translational velocity of a
FixedOffsetFrame differs from that of a BodyFrame. If a Frame is
associated with a soft body, kinematic calculations can depend on the
soft body’s deformation state variables.</p>
<p>A Frame object does <em>not</em> store a Context (where Context means state
that contains the Frame’s current orientation, position, motion,
etc.). Instead, Frame provides methods for calculating these
Frame-properties from a Context passed to Frame methods.</p>
<dl class="attribute">
<dt id="pydrake.multibody.tree.Frame_[Expression].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.Frame_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[Expression].body">
<code class="descname">body</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[Expression]</em><span class="sig-paren">)</span> &#x2192; drake::multibody::Body&lt;drake::symbolic::Expression&gt;<a class="headerlink" href="#pydrake.multibody.tree.Frame_[Expression].body" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the body associated to this Frame.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[Expression].CalcAngularVelocity">
<code class="descname">CalcAngularVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[Expression], context: pydrake.systems.framework.Context_[Expression], measured_in_frame: pydrake.multibody.tree.Frame_[Expression], expressed_in_frame: pydrake.multibody.tree.Frame_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[Expression].CalcAngularVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s angular velocity measured in a frame M,
expressed in a frame E.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">measured_in_frame</span></code>:</dt>
<dd>which is frame M (the frame in which <code class="docutils literal notranslate"><span class="pre">this</span></code> angular velocity is
to be measured).</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">expressed_in_frame</span></code>:</dt>
<dd>which is frame E (the frame in which the returned angular velocity
is to be expressed).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">ω_MF_E, <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s angular velocity ω measured in frame M,
expressed in frame E.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">EvalAngularVelocityInWorld() to evaluate ω_WF_W (<code class="docutils literal notranslate"><span class="pre">this</span></code> frame
F’s angular velocity ω measured and expressed in the world frame
W).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[Expression].CalcOffsetPoseInBody">
<code class="descname">CalcOffsetPoseInBody</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[Expression], context: pydrake.systems.framework.Context_[Expression], X_FQ: pydrake.math.RigidTransform_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[Expression].CalcOffsetPoseInBody" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the offset pose <code class="docutils literal notranslate"><span class="pre">X_FQ</span></code> of a frame Q in <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F, this
method computes the pose <code class="docutils literal notranslate"><span class="pre">X_BQ</span></code> of frame Q in the body frame B to
which this frame is attached. In other words, if the pose of <code class="docutils literal notranslate"><span class="pre">this</span></code>
frame F in the body frame B is <code class="docutils literal notranslate"><span class="pre">X_BF</span></code>, this method computes the pose
<code class="docutils literal notranslate"><span class="pre">X_BQ</span></code> of frame Q in the body frame B as <code class="docutils literal notranslate"><span class="pre">X_BQ</span> <span class="pre">=</span> <span class="pre">X_BF</span> <span class="pre">*</span> <span class="pre">X_FQ</span></code>. In
particular, if <code class="docutils literal notranslate"><span class="pre">this</span></code> <a href="#id5"><span class="problematic" id="id6">**</span></a>is**` the body frame B, i.e. <code class="docutils literal notranslate"><span class="pre">X_BF</span></code> is the
identity transformation, this method directly returns <code class="docutils literal notranslate"><span class="pre">X_FQ</span></code>.
Specific frame subclasses can override this method to provide faster
implementations if needed.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[Expression].CalcOffsetRotationMatrixInBody">
<code class="descname">CalcOffsetRotationMatrixInBody</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[Expression], context: pydrake.systems.framework.Context_[Expression], R_FQ: pydrake.math.RotationMatrix_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[Expression].CalcOffsetRotationMatrixInBody" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates and returns the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_BQ</span></code> that relates body
frame B to frame Q via <code class="docutils literal notranslate"><span class="pre">this</span></code> intermediate frame F, i.e., <code class="docutils literal notranslate"><span class="pre">R_BQ</span> <span class="pre">=</span>
<span class="pre">R_BF</span> <span class="pre">*</span> <span class="pre">R_FQ</span></code> (B is the body frame to which <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F is
attached).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_FQ</span></code>:</dt>
<dd>rotation matrix that relates frame F to frame Q.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[Expression].CalcPose">
<code class="descname">CalcPose</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[Expression], context: pydrake.systems.framework.Context_[Expression], frame_M: pydrake.multibody.tree.Frame_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[Expression].CalcPose" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes and returns the pose <code class="docutils literal notranslate"><span class="pre">X_MF</span></code> of <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F in measured
in <code class="docutils literal notranslate"><span class="pre">frame_M</span></code> as a function of the state of the model stored in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcPoseInWorld().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[Expression].CalcPoseInBodyFrame">
<code class="descname">CalcPoseInBodyFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[Expression].CalcPoseInBodyFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pose <code class="docutils literal notranslate"><span class="pre">X_BF</span></code> of <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F in the body frame B
associated with this frame. In particular, if <code class="docutils literal notranslate"><span class="pre">this</span></code> <strong>is</strong> the body
frame B, this method directly returns the identity transformation.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[Expression].CalcPoseInWorld">
<code class="descname">CalcPoseInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[Expression].CalcPoseInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes and returns the pose <code class="docutils literal notranslate"><span class="pre">X_WF</span></code> of <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F in the
world frame W as a function of the state of the model stored in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Body::EvalPoseInWorld() provides a more efficient way to obtain
the pose for a body frame.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[Expression].CalcRelativeSpatialAcceleration">
<code class="descname">CalcRelativeSpatialAcceleration</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[Expression], context: pydrake.systems.framework.Context_[Expression], other_frame: pydrake.multibody.tree.Frame_[Expression], measured_in_frame: pydrake.multibody.tree.Frame_[Expression], expressed_in_frame: pydrake.multibody.tree.Frame_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[Expression].CalcRelativeSpatialAcceleration" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame C’s spatial acceleration relative to another
frame B, measured in a frame M, expressed in a frame E.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other_frame</span></code>:</dt>
<dd>which is frame B.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">measured_in_frame</span></code>:</dt>
<dd>which is frame M.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">expressed_in_frame</span></code>:</dt>
<dd>which is frame E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A_M_BC_E = A_MC_E - A_MB_E, frame C’s spatial acceleration
relative to frame B, measured in frame M, expressed in frame E.</td>
</tr>
</tbody>
</table>
<p>In general, A_M_BC = DtW(V_M_BC), the time-derivative in frame M of
frame C’s spatial velocity relative to frame B. The rotational part of
the returned quantity is α_MC_E - α_MB_E = DtM(ω_BC)_E. Note: For 3D
analysis, DtM(ω_BC) ≠ α_BC. The translational part of the returned
quantity is a_M_BoCo_E (Co’s translational acceleration relative to
Bo, measured in frame M, expressed in frame E).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>α_MC_E - α_MB_E = DtM(ω_MC)_E - DtM(ω_MB)_E = DtM(ω_BC)_E
 a_M_BoCo_E = a_MCo_E - a_MBo_E = DtM(v_MCo) - DtM(v_MBo) = Dt²M(p_BoCo)_E
</pre></div>
</div>
<p>where Dt²M(p_BoCo)_E is the 2ⁿᵈ time-derivative in frame M of p_BoCo
(the position vector from Bo to Co), and this result is expressed in
frame E.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The calculation of the 2ⁿᵈ time-derivative of the distance between
Bo and Co can be done with relative translational acceleration,
but this calculation does not depend on the measured-in-frame,
hence in this case, consider
CalcRelativeSpatialAccelerationInWorld() since it is faster.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcSpatialAccelerationInWorld(), CalcSpatialAcceleration(), and
CalcRelativeSpatialAccelerationInWorld().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[Expression].CalcRelativeSpatialAccelerationInWorld">
<code class="descname">CalcRelativeSpatialAccelerationInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[Expression], context: pydrake.systems.framework.Context_[Expression], other_frame: pydrake.multibody.tree.Frame_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[Expression].CalcRelativeSpatialAccelerationInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame C’s spatial acceleration relative to another
frame B, measured and expressed in the world frame W.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other_frame</span></code>:</dt>
<dd>which is frame B.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A_W_BC_W = A_WC_W - A_WB_W, frame C’s spatial acceleration
relative to frame B, measured and expressed in the world frame W.</td>
</tr>
</tbody>
</table>
<p>In general, A_W_BC = DtW(V_W_BC), the time-derivative in the world
frame W of frame C’s spatial velocity relative to frame B. The
rotational part of the returned quantity is α_WC_W - α_WB_W =
DtW(ω_BC)_W. For 3D analysis, DtW(ω_BC) ≠ α_BC. The translational part
of the returned quantity is a_W_BoCo_W (Co’s translational
acceleration relative to Bo, measured and expressed in world frame W).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>α_WC_W - α_WB_W = DtW(ω_WC)_W - DtW(ω_WB)_W = DtW(ω_BC)_W
 a_W_BoCo_W = a_WCo_W - a_WBo_W = DtW(v_WCo) - DtW(v_WBo) = Dt²W(p_BoCo)_W
</pre></div>
</div>
<p>where Dt²W(p_BoCo)_W is the 2ⁿᵈ time-derivative in frame W of p_BoCo
(the position vector from Bo to Co), and this result is expressed in
frame W.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The method CalcSpatialAccelerationInWorld() is more efficient and
coherent if any of <code class="docutils literal notranslate"><span class="pre">this</span></code>, other_frame, or the world frame W are
the same.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcSpatialAccelerationInWorld(),
CalcRelativeSpatialAcceleration().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[Expression].CalcRelativeSpatialVelocity">
<code class="descname">CalcRelativeSpatialVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[Expression], context: pydrake.systems.framework.Context_[Expression], other_frame: pydrake.multibody.tree.Frame_[Expression], measured_in_frame: pydrake.multibody.tree.Frame_[Expression], expressed_in_frame: pydrake.multibody.tree.Frame_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[Expression].CalcRelativeSpatialVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame C’s spatial velocity relative to another
frame B, measured in a frame M, expressed in a frame E.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other_frame</span></code>:</dt>
<dd>which is frame B.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">measured_in_frame</span></code>:</dt>
<dd>which is frame M.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">expressed_in_frame</span></code>:</dt>
<dd>which is frame E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">V_M_BC_E = V_MC_E - V_MB_E, frame C’s spatial velocity relative to
frame B, measured in frame M, expressed in frame E. The rotational
part of the returned quantity is ω_BC_E (C’s angular velocity
measured in B and expressed in E). The translational part is
v_M_BoCo_E (Co’s translational velocity relative to Bo, measured
in M, and expressed in E).</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ω_BC_E</span> <span class="o">=</span> <span class="n">ω_MC_E</span> <span class="o">-</span> <span class="n">ω_MB_E</span>
 <span class="n">v_M_BoCo_E</span> <span class="o">=</span> <span class="n">v_MCo_E</span> <span class="o">-</span> <span class="n">v_MBo_E</span> <span class="o">=</span> <span class="n">DtM</span><span class="p">(</span><span class="n">p_BoCo</span><span class="p">)</span>
</pre></div>
</div>
<p>where DtM(p_BoCo) is the time-derivative in frame M of p_BoCo
(position vector from Bo to Co), and this vector is expressed in frame
E.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The method CalcSpatialVelocity() is more efficient and coherent if
any of <code class="docutils literal notranslate"><span class="pre">this</span></code>, other_frame, or measured_in_frame are the same.
Also, the value of V_M_BoCo does not depend on the
measured_in_frame if Bo and Co are coincident (i.e., p_BoCo = 0),
in which case consider the more efficient method
CalcRelativeSpatialVelocityInWorld(). Lastly, the calculation of
elongation between Bo and Co can be done with relative
translational velocity, but elongation does not depend on the
measured-in-frame (hence consider
CalcRelativeSpatialVelocityInWorld()).</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcSpatialVelocityInWorld(), CalcSpatialVelocity(), and
CalcRelativeSpatialVelocityInWorld().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[Expression].CalcRelativeSpatialVelocityInWorld">
<code class="descname">CalcRelativeSpatialVelocityInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[Expression], context: pydrake.systems.framework.Context_[Expression], other_frame: pydrake.multibody.tree.Frame_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[Expression].CalcRelativeSpatialVelocityInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame C’s spatial velocity relative to another
frame B, measured and expressed in the world frame W.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other_frame</span></code>:</dt>
<dd>which is frame B.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">V_W_BC_W = V_WC_W - V_WB_W, frame C’s spatial velocity relative to
frame B, measured and expressed in the world frame W. The
rotational part of the returned quantity is ω_BC_W (C’s angular
velocity measured in B and expressed in W). The translational part
is v_W_BoCo_W (Co’s translational velocity relative to Bo,
measured and expressed in world frame W).</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ω_BC_W</span>  <span class="o">=</span> <span class="n">ω_WC_W</span> <span class="o">-</span> <span class="n">ω_WB_W</span>
 <span class="n">v_W_BoCo_W</span> <span class="o">=</span> <span class="n">v_WCo_W</span> <span class="o">-</span> <span class="n">v_WBo_W</span> <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">p_BoCo</span><span class="p">)</span>
</pre></div>
</div>
<p>where DtW(p_BoCo) is the time-derivative in frame W of p_BoCo
(position vector from Bo to Co), and this vector is expressed in frame
W.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The method CalcSpatialVelocityInWorld() is more efficient and
coherent if any of <code class="docutils literal notranslate"><span class="pre">this</span></code>, other_frame, or the world frame W are
the same.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcSpatialVelocityInWorld() and CalcRelativeSpatialVelocity().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[Expression].CalcRotationMatrix">
<code class="descname">CalcRotationMatrix</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[Expression], context: pydrake.systems.framework.Context_[Expression], frame_M: pydrake.multibody.tree.Frame_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[Expression].CalcRotationMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates and returns the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_MF</span></code> that relates
<code class="docutils literal notranslate"><span class="pre">frame_M</span></code> and <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F as a function of the state stored in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[Expression].CalcRotationMatrixInBodyFrame">
<code class="descname">CalcRotationMatrixInBodyFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[Expression].CalcRotationMatrixInBodyFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_BF</span></code> that relates body frame B to
<code class="docutils literal notranslate"><span class="pre">this</span></code> frame F (B is the body frame to which <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F is
attached).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If <code class="docutils literal notranslate"><span class="pre">this</span></code> is B, this method returns the identity RotationMatrix.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[Expression].CalcRotationMatrixInWorld">
<code class="descname">CalcRotationMatrixInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[Expression].CalcRotationMatrixInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates and returns the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_WF</span></code> that relates the
world frame W and <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F as a function of the state stored
in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[Expression].CalcSpatialAcceleration">
<code class="descname">CalcSpatialAcceleration</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[Expression], context: pydrake.systems.framework.Context_[Expression], measured_in_frame: pydrake.multibody.tree.Frame_[Expression], expressed_in_frame: pydrake.multibody.tree.Frame_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[Expression].CalcSpatialAcceleration" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial acceleration measured in a frame
M, expressed in a frame E.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">measured_in_frame</span></code>:</dt>
<dd>which is frame M.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">expressed_in_frame</span></code>:</dt>
<dd>which is frame E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A_MF_E, <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial acceleration measured in frame
M, expressed in frame E. The rotational part of the returned
quantity is α_MF_E (frame F’s angular acceleration α measured in
frame M, expressed in frame E). The translational part is a_MFo_E
(translational acceleration of frame F’s origin point Fo, measured
in frame M, expressed in frame E). Although α_MF is defined below
in terms of DtM(ω_MF), the time-derivative in frame M of ω_MF, the
actual calculation of α_MF avoids differentiation. Similarly for
the definition vs. calculation for a_MFo.</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">α_MF</span> <span class="o">=</span> <span class="n">DtM</span><span class="p">(</span><span class="n">ω_MF</span><span class="p">)</span>           <span class="n">ω_MF</span> <span class="ow">is</span> <span class="n">frame</span> <span class="n">F</span><span class="s1">&#39;s angular velocity in frame M.</span>
 <span class="n">a_MFo</span> <span class="o">=</span> <span class="n">DtM</span><span class="p">(</span><span class="n">v_MFo</span><span class="p">)</span>    <span class="n">v_MF</span> <span class="ow">is</span> <span class="n">Fo</span><span class="s1">&#39;s translational acceleration in frame M.</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcSpatialAccelerationInWorld() and CalcSpatialVelocity().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[Expression].CalcSpatialAccelerationInWorld">
<code class="descname">CalcSpatialAccelerationInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[Expression].CalcSpatialAccelerationInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial acceleration measured and
expressed in the world frame W.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody system.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A_WF_W, <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial acceleration measured and
expressed in the world frame W. The rotational part of the
returned quantity is α_WF_E (frame F’s angular acceleration α
measured and expressed in the world frame W). The translational
part is a_WFo_W (translational acceleration of frame F’s origin
point Fo, measured and expressed in the world frame W).</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Body::EvalSpatialAccelerationInWorld() provides a more efficient
way to obtain a body frame’s spatial acceleration measured in the
world frame.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When cached values are out of sync with the state stored in
context, this method performs an expensive forward dynamics
computation, whereas once evaluated, successive calls to this
method are inexpensive.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcSpatialAcceleration() and CalcSpatialVelocityInWorld().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[Expression].CalcSpatialVelocity">
<code class="descname">CalcSpatialVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[Expression], context: pydrake.systems.framework.Context_[Expression], frame_M: pydrake.multibody.tree.Frame_[Expression], frame_E: pydrake.multibody.tree.Frame_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[Expression].CalcSpatialVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial velocity measured in a frame M,
expressed in a frame E.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_M</span></code>:</dt>
<dd>which is the measured_in_frame.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt>
<dd>which is the expressed_in_frame.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">V_MF_E, <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial velocity measured in frame M,
expressed in frame E. The rotational part of the returned quantity
is ω_MF_E (frame F’s angular velocity ω measured in frame M,
expressed in frame E). The translational part is v_MFo_E
(translational velocity v of frame F’s origin point Fo, measured
in frame M, expressed in frame E).</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcSpatialVelocityInWorld(), CalcRelativeSpatialVelocity(), and
CalcSpatialAcceleration().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[Expression].CalcSpatialVelocityInWorld">
<code class="descname">CalcSpatialVelocityInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[Expression].CalcSpatialVelocityInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial velocity measured and expressed
in the world frame W.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody system.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">V_WF_W, <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial velocity measured and expressed
in the world frame W. The rotational part of the returned quantity
is ω_WF_W (frame F’s angular velocity ω measured and expressed in
the world frame W). The translational part is v_WFo_W
(translational velocity v of frame F’s origin point Fo, measured
and expressed in the world frame W).</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Body::EvalSpatialVelocityInWorld() provides a more efficient way
to obtain a body frame’s spatial velocity measured in the world
frame.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcSpatialVelocity(), CalcRelativeSpatialVelocityInWorld(), and
CalcSpatialAccelerationInWorld().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[Expression].EvalAngularVelocityInWorld">
<code class="descname">EvalAngularVelocityInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[Expression].EvalAngularVelocityInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s angular velocity measured and expressed
in the world frame W.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody system.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">ω_WF_W (frame F’s angular velocity ω measured and expressed in the
world frame W).</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcAngularVelocity() to calculate ω_MF_E (<code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s
angular velocity ω measured in a frame M and expressed in a frame
E).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[Expression].GetFixedOffsetPoseInBody">
<code class="descname">GetFixedOffsetPoseInBody</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[Expression], X_FQ: pydrake.math.RigidTransform_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[Expression].GetFixedOffsetPoseInBody" title="Permalink to this definition">¶</a></dt>
<dd><p>Variant of CalcOffsetPoseInBody() that given the offset pose <code class="docutils literal notranslate"><span class="pre">X_FQ</span></code>
of a frame Q in <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F, returns the pose <code class="docutils literal notranslate"><span class="pre">X_BQ</span></code> of frame Q
in the body frame B to which this frame is attached.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called on a Frame that does not have a fixed</li>
<li>offset in the body frame.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[Expression].GetFixedPoseInBodyFrame">
<code class="descname">GetFixedPoseInBodyFrame</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.Frame_[Expression].GetFixedPoseInBodyFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>GetFixedPoseInBodyFrame(self: pydrake.multibody.tree.Frame_[Expression]) -&gt; pydrake.math.RigidTransform_[Expression]</li>
</ol>
<p>Variant of CalcPoseInBodyFrame() that returns the fixed pose <code class="docutils literal notranslate"><span class="pre">X_BF</span></code>
of <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F in the body frame B associated with this frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called on a Frame that does not have a fixed</li>
<li>offset in the body frame.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>GetFixedPoseInBodyFrame(self: pydrake.multibody.tree.Frame_[Expression]) -&gt; pydrake.math.RigidTransform_[Expression]</li>
</ol>
<p>Variant of CalcPoseInBodyFrame() that returns the fixed pose <code class="docutils literal notranslate"><span class="pre">X_BF</span></code>
of <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F in the body frame B associated with this frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called on a Frame that does not have a fixed</li>
<li>offset in the body frame.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[Expression].GetFixedRotationMatrixInBody">
<code class="descname">GetFixedRotationMatrixInBody</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[Expression], R_FQ: pydrake.math.RotationMatrix_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[Expression].GetFixedRotationMatrixInBody" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates and returns the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_BQ</span></code> that relates body
frame B to frame Q via <code class="docutils literal notranslate"><span class="pre">this</span></code> intermediate frame F, i.e., <code class="docutils literal notranslate"><span class="pre">R_BQ</span> <span class="pre">=</span>
<span class="pre">R_BF</span> <span class="pre">*</span> <span class="pre">R_FQ</span></code> (B is the body frame to which <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F is
attached).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_FQ</span></code>:</dt>
<dd>rotation matrix that relates frame F to frame Q.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F is a Frame that does not have a</li>
<li>fixed offset in the body frame B (i.e., <code class="docutils literal notranslate"><span class="pre">R_BF</span></code> is not constant).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[Expression].GetFixedRotationMatrixInBodyFrame">
<code class="descname">GetFixedRotationMatrixInBodyFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[Expression].GetFixedRotationMatrixInBodyFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_BF</span></code> that relates body frame B to
<code class="docutils literal notranslate"><span class="pre">this</span></code> frame F (B is the body frame to which <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F is
attached).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F is a Frame that does not have a</li>
<li>fixed offset in the body frame B (i.e., <code class="docutils literal notranslate"><span class="pre">R_BF</span></code> is not constant).</li>
<li>Frame sub-classes that have a constant <code class="docutils literal notranslate"><span class="pre">R_BF</span></code> must override this</li>
<li>method. An example of a frame sub-class not implementing this</li>
<li>method would be that of a frame on a soft body, for which its pose</li>
<li>in the body frame depends on the state of deformation of the body.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[Expression].GetParentPlant">
<code class="descname">GetParentPlant</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[Expression]</em><span class="sig-paren">)</span> &#x2192; drake::multibody::MultibodyPlant&lt;drake::symbolic::Expression&gt;<a class="headerlink" href="#pydrake.multibody.tree.Frame_[Expression].GetParentPlant" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[Expression].index">
<code class="descname">index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.FrameIndex<a class="headerlink" href="#pydrake.multibody.tree.Frame_[Expression].index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[Expression].is_body_frame">
<code class="descname">is_body_frame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[Expression]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.Frame_[Expression].is_body_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if <code class="docutils literal notranslate"><span class="pre">this</span></code> is the body frame.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[Expression].is_world_frame">
<code class="descname">is_world_frame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[Expression]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.Frame_[Expression].is_world_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if <code class="docutils literal notranslate"><span class="pre">this</span></code> is the world frame.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[Expression].model_instance">
<code class="descname">model_instance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.Frame_[Expression].model_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[Expression].name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[Expression]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Frame_[Expression].name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name of this frame. The name will never be empty.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.Frame_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">Frame_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.Frame_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>%Frame is an abstract class representing a <em>material frame</em> (also
called a <em>physical frame</em>), meaning that the Frame’s origin is a
material point of a Body.</p>
<p>An important characteristic of a Frame is that forces or torques
applied to a Frame are applied to the Frame’s underlying Body.
Force-producing elements like joints, actuators, and constraints
usually employ two Frames, with one Frame connected to one body and
the other connected to a different Body. Every Frame object can report
the Body to which it is attached. Despite its name, Frame is not the
most general frame in Drake (see FrameBase for more information).</p>
<p>A Frame’s pose in World (or relative to other frames) is always
calculated starting with its pose relative to its underlying Body’s
BodyFrame. Subclasses derived from Frame differ in how kinematic
calculations are performed. For example, the angular velocity of a
FixedOffsetFrame or BodyFrame is identical to the angular velocity of
its underlying body, whereas the translational velocity of a
FixedOffsetFrame differs from that of a BodyFrame. If a Frame is
associated with a soft body, kinematic calculations can depend on the
soft body’s deformation state variables.</p>
<p>A Frame object does <em>not</em> store a Context (where Context means state
that contains the Frame’s current orientation, position, motion,
etc.). Instead, Frame provides methods for calculating these
Frame-properties from a Context passed to Frame methods.</p>
<dl class="attribute">
<dt id="pydrake.multibody.tree.Frame_[float].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.Frame_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[float].body">
<code class="descname">body</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; drake::multibody::Body&lt;double&gt;<a class="headerlink" href="#pydrake.multibody.tree.Frame_[float].body" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the body associated to this Frame.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[float].CalcAngularVelocity">
<code class="descname">CalcAngularVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float], context: pydrake.systems.framework.Context_[float], measured_in_frame: pydrake.multibody.tree.Frame_[float], expressed_in_frame: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[float].CalcAngularVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s angular velocity measured in a frame M,
expressed in a frame E.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">measured_in_frame</span></code>:</dt>
<dd>which is frame M (the frame in which <code class="docutils literal notranslate"><span class="pre">this</span></code> angular velocity is
to be measured).</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">expressed_in_frame</span></code>:</dt>
<dd>which is frame E (the frame in which the returned angular velocity
is to be expressed).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">ω_MF_E, <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s angular velocity ω measured in frame M,
expressed in frame E.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">EvalAngularVelocityInWorld() to evaluate ω_WF_W (<code class="docutils literal notranslate"><span class="pre">this</span></code> frame
F’s angular velocity ω measured and expressed in the world frame
W).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[float].CalcOffsetPoseInBody">
<code class="descname">CalcOffsetPoseInBody</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float], context: pydrake.systems.framework.Context_[float], X_FQ: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[float].CalcOffsetPoseInBody" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the offset pose <code class="docutils literal notranslate"><span class="pre">X_FQ</span></code> of a frame Q in <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F, this
method computes the pose <code class="docutils literal notranslate"><span class="pre">X_BQ</span></code> of frame Q in the body frame B to
which this frame is attached. In other words, if the pose of <code class="docutils literal notranslate"><span class="pre">this</span></code>
frame F in the body frame B is <code class="docutils literal notranslate"><span class="pre">X_BF</span></code>, this method computes the pose
<code class="docutils literal notranslate"><span class="pre">X_BQ</span></code> of frame Q in the body frame B as <code class="docutils literal notranslate"><span class="pre">X_BQ</span> <span class="pre">=</span> <span class="pre">X_BF</span> <span class="pre">*</span> <span class="pre">X_FQ</span></code>. In
particular, if <code class="docutils literal notranslate"><span class="pre">this</span></code> <a href="#id7"><span class="problematic" id="id8">**</span></a>is**` the body frame B, i.e. <code class="docutils literal notranslate"><span class="pre">X_BF</span></code> is the
identity transformation, this method directly returns <code class="docutils literal notranslate"><span class="pre">X_FQ</span></code>.
Specific frame subclasses can override this method to provide faster
implementations if needed.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[float].CalcOffsetRotationMatrixInBody">
<code class="descname">CalcOffsetRotationMatrixInBody</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float], context: pydrake.systems.framework.Context_[float], R_FQ: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[float]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[float].CalcOffsetRotationMatrixInBody" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates and returns the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_BQ</span></code> that relates body
frame B to frame Q via <code class="docutils literal notranslate"><span class="pre">this</span></code> intermediate frame F, i.e., <code class="docutils literal notranslate"><span class="pre">R_BQ</span> <span class="pre">=</span>
<span class="pre">R_BF</span> <span class="pre">*</span> <span class="pre">R_FQ</span></code> (B is the body frame to which <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F is
attached).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_FQ</span></code>:</dt>
<dd>rotation matrix that relates frame F to frame Q.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[float].CalcPose">
<code class="descname">CalcPose</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float], context: pydrake.systems.framework.Context_[float], frame_M: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[float].CalcPose" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes and returns the pose <code class="docutils literal notranslate"><span class="pre">X_MF</span></code> of <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F in measured
in <code class="docutils literal notranslate"><span class="pre">frame_M</span></code> as a function of the state of the model stored in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcPoseInWorld().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[float].CalcPoseInBodyFrame">
<code class="descname">CalcPoseInBodyFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[float].CalcPoseInBodyFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pose <code class="docutils literal notranslate"><span class="pre">X_BF</span></code> of <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F in the body frame B
associated with this frame. In particular, if <code class="docutils literal notranslate"><span class="pre">this</span></code> <strong>is</strong> the body
frame B, this method directly returns the identity transformation.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[float].CalcPoseInWorld">
<code class="descname">CalcPoseInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[float].CalcPoseInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes and returns the pose <code class="docutils literal notranslate"><span class="pre">X_WF</span></code> of <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F in the
world frame W as a function of the state of the model stored in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Body::EvalPoseInWorld() provides a more efficient way to obtain
the pose for a body frame.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[float].CalcRelativeSpatialAcceleration">
<code class="descname">CalcRelativeSpatialAcceleration</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float], context: pydrake.systems.framework.Context_[float], other_frame: pydrake.multibody.tree.Frame_[float], measured_in_frame: pydrake.multibody.tree.Frame_[float], expressed_in_frame: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[float]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[float].CalcRelativeSpatialAcceleration" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame C’s spatial acceleration relative to another
frame B, measured in a frame M, expressed in a frame E.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other_frame</span></code>:</dt>
<dd>which is frame B.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">measured_in_frame</span></code>:</dt>
<dd>which is frame M.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">expressed_in_frame</span></code>:</dt>
<dd>which is frame E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A_M_BC_E = A_MC_E - A_MB_E, frame C’s spatial acceleration
relative to frame B, measured in frame M, expressed in frame E.</td>
</tr>
</tbody>
</table>
<p>In general, A_M_BC = DtW(V_M_BC), the time-derivative in frame M of
frame C’s spatial velocity relative to frame B. The rotational part of
the returned quantity is α_MC_E - α_MB_E = DtM(ω_BC)_E. Note: For 3D
analysis, DtM(ω_BC) ≠ α_BC. The translational part of the returned
quantity is a_M_BoCo_E (Co’s translational acceleration relative to
Bo, measured in frame M, expressed in frame E).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>α_MC_E - α_MB_E = DtM(ω_MC)_E - DtM(ω_MB)_E = DtM(ω_BC)_E
 a_M_BoCo_E = a_MCo_E - a_MBo_E = DtM(v_MCo) - DtM(v_MBo) = Dt²M(p_BoCo)_E
</pre></div>
</div>
<p>where Dt²M(p_BoCo)_E is the 2ⁿᵈ time-derivative in frame M of p_BoCo
(the position vector from Bo to Co), and this result is expressed in
frame E.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The calculation of the 2ⁿᵈ time-derivative of the distance between
Bo and Co can be done with relative translational acceleration,
but this calculation does not depend on the measured-in-frame,
hence in this case, consider
CalcRelativeSpatialAccelerationInWorld() since it is faster.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcSpatialAccelerationInWorld(), CalcSpatialAcceleration(), and
CalcRelativeSpatialAccelerationInWorld().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[float].CalcRelativeSpatialAccelerationInWorld">
<code class="descname">CalcRelativeSpatialAccelerationInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float], context: pydrake.systems.framework.Context_[float], other_frame: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[float]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[float].CalcRelativeSpatialAccelerationInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame C’s spatial acceleration relative to another
frame B, measured and expressed in the world frame W.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other_frame</span></code>:</dt>
<dd>which is frame B.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A_W_BC_W = A_WC_W - A_WB_W, frame C’s spatial acceleration
relative to frame B, measured and expressed in the world frame W.</td>
</tr>
</tbody>
</table>
<p>In general, A_W_BC = DtW(V_W_BC), the time-derivative in the world
frame W of frame C’s spatial velocity relative to frame B. The
rotational part of the returned quantity is α_WC_W - α_WB_W =
DtW(ω_BC)_W. For 3D analysis, DtW(ω_BC) ≠ α_BC. The translational part
of the returned quantity is a_W_BoCo_W (Co’s translational
acceleration relative to Bo, measured and expressed in world frame W).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>α_WC_W - α_WB_W = DtW(ω_WC)_W - DtW(ω_WB)_W = DtW(ω_BC)_W
 a_W_BoCo_W = a_WCo_W - a_WBo_W = DtW(v_WCo) - DtW(v_WBo) = Dt²W(p_BoCo)_W
</pre></div>
</div>
<p>where Dt²W(p_BoCo)_W is the 2ⁿᵈ time-derivative in frame W of p_BoCo
(the position vector from Bo to Co), and this result is expressed in
frame W.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The method CalcSpatialAccelerationInWorld() is more efficient and
coherent if any of <code class="docutils literal notranslate"><span class="pre">this</span></code>, other_frame, or the world frame W are
the same.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcSpatialAccelerationInWorld(),
CalcRelativeSpatialAcceleration().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[float].CalcRelativeSpatialVelocity">
<code class="descname">CalcRelativeSpatialVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float], context: pydrake.systems.framework.Context_[float], other_frame: pydrake.multibody.tree.Frame_[float], measured_in_frame: pydrake.multibody.tree.Frame_[float], expressed_in_frame: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[float]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[float].CalcRelativeSpatialVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame C’s spatial velocity relative to another
frame B, measured in a frame M, expressed in a frame E.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other_frame</span></code>:</dt>
<dd>which is frame B.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">measured_in_frame</span></code>:</dt>
<dd>which is frame M.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">expressed_in_frame</span></code>:</dt>
<dd>which is frame E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">V_M_BC_E = V_MC_E - V_MB_E, frame C’s spatial velocity relative to
frame B, measured in frame M, expressed in frame E. The rotational
part of the returned quantity is ω_BC_E (C’s angular velocity
measured in B and expressed in E). The translational part is
v_M_BoCo_E (Co’s translational velocity relative to Bo, measured
in M, and expressed in E).</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ω_BC_E</span> <span class="o">=</span> <span class="n">ω_MC_E</span> <span class="o">-</span> <span class="n">ω_MB_E</span>
 <span class="n">v_M_BoCo_E</span> <span class="o">=</span> <span class="n">v_MCo_E</span> <span class="o">-</span> <span class="n">v_MBo_E</span> <span class="o">=</span> <span class="n">DtM</span><span class="p">(</span><span class="n">p_BoCo</span><span class="p">)</span>
</pre></div>
</div>
<p>where DtM(p_BoCo) is the time-derivative in frame M of p_BoCo
(position vector from Bo to Co), and this vector is expressed in frame
E.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The method CalcSpatialVelocity() is more efficient and coherent if
any of <code class="docutils literal notranslate"><span class="pre">this</span></code>, other_frame, or measured_in_frame are the same.
Also, the value of V_M_BoCo does not depend on the
measured_in_frame if Bo and Co are coincident (i.e., p_BoCo = 0),
in which case consider the more efficient method
CalcRelativeSpatialVelocityInWorld(). Lastly, the calculation of
elongation between Bo and Co can be done with relative
translational velocity, but elongation does not depend on the
measured-in-frame (hence consider
CalcRelativeSpatialVelocityInWorld()).</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcSpatialVelocityInWorld(), CalcSpatialVelocity(), and
CalcRelativeSpatialVelocityInWorld().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[float].CalcRelativeSpatialVelocityInWorld">
<code class="descname">CalcRelativeSpatialVelocityInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float], context: pydrake.systems.framework.Context_[float], other_frame: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[float]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[float].CalcRelativeSpatialVelocityInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame C’s spatial velocity relative to another
frame B, measured and expressed in the world frame W.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other_frame</span></code>:</dt>
<dd>which is frame B.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">V_W_BC_W = V_WC_W - V_WB_W, frame C’s spatial velocity relative to
frame B, measured and expressed in the world frame W. The
rotational part of the returned quantity is ω_BC_W (C’s angular
velocity measured in B and expressed in W). The translational part
is v_W_BoCo_W (Co’s translational velocity relative to Bo,
measured and expressed in world frame W).</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ω_BC_W</span>  <span class="o">=</span> <span class="n">ω_WC_W</span> <span class="o">-</span> <span class="n">ω_WB_W</span>
 <span class="n">v_W_BoCo_W</span> <span class="o">=</span> <span class="n">v_WCo_W</span> <span class="o">-</span> <span class="n">v_WBo_W</span> <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">p_BoCo</span><span class="p">)</span>
</pre></div>
</div>
<p>where DtW(p_BoCo) is the time-derivative in frame W of p_BoCo
(position vector from Bo to Co), and this vector is expressed in frame
W.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The method CalcSpatialVelocityInWorld() is more efficient and
coherent if any of <code class="docutils literal notranslate"><span class="pre">this</span></code>, other_frame, or the world frame W are
the same.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcSpatialVelocityInWorld() and CalcRelativeSpatialVelocity().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[float].CalcRotationMatrix">
<code class="descname">CalcRotationMatrix</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float], context: pydrake.systems.framework.Context_[float], frame_M: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[float]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[float].CalcRotationMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates and returns the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_MF</span></code> that relates
<code class="docutils literal notranslate"><span class="pre">frame_M</span></code> and <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F as a function of the state stored in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[float].CalcRotationMatrixInBodyFrame">
<code class="descname">CalcRotationMatrixInBodyFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[float]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[float].CalcRotationMatrixInBodyFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_BF</span></code> that relates body frame B to
<code class="docutils literal notranslate"><span class="pre">this</span></code> frame F (B is the body frame to which <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F is
attached).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If <code class="docutils literal notranslate"><span class="pre">this</span></code> is B, this method returns the identity RotationMatrix.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[float].CalcRotationMatrixInWorld">
<code class="descname">CalcRotationMatrixInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[float]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[float].CalcRotationMatrixInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates and returns the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_WF</span></code> that relates the
world frame W and <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F as a function of the state stored
in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[float].CalcSpatialAcceleration">
<code class="descname">CalcSpatialAcceleration</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float], context: pydrake.systems.framework.Context_[float], measured_in_frame: pydrake.multibody.tree.Frame_[float], expressed_in_frame: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[float]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[float].CalcSpatialAcceleration" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial acceleration measured in a frame
M, expressed in a frame E.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">measured_in_frame</span></code>:</dt>
<dd>which is frame M.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">expressed_in_frame</span></code>:</dt>
<dd>which is frame E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A_MF_E, <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial acceleration measured in frame
M, expressed in frame E. The rotational part of the returned
quantity is α_MF_E (frame F’s angular acceleration α measured in
frame M, expressed in frame E). The translational part is a_MFo_E
(translational acceleration of frame F’s origin point Fo, measured
in frame M, expressed in frame E). Although α_MF is defined below
in terms of DtM(ω_MF), the time-derivative in frame M of ω_MF, the
actual calculation of α_MF avoids differentiation. Similarly for
the definition vs. calculation for a_MFo.</td>
</tr>
</tbody>
</table>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">α_MF</span> <span class="o">=</span> <span class="n">DtM</span><span class="p">(</span><span class="n">ω_MF</span><span class="p">)</span>           <span class="n">ω_MF</span> <span class="ow">is</span> <span class="n">frame</span> <span class="n">F</span><span class="s1">&#39;s angular velocity in frame M.</span>
 <span class="n">a_MFo</span> <span class="o">=</span> <span class="n">DtM</span><span class="p">(</span><span class="n">v_MFo</span><span class="p">)</span>    <span class="n">v_MF</span> <span class="ow">is</span> <span class="n">Fo</span><span class="s1">&#39;s translational acceleration in frame M.</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcSpatialAccelerationInWorld() and CalcSpatialVelocity().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[float].CalcSpatialAccelerationInWorld">
<code class="descname">CalcSpatialAccelerationInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[float]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[float].CalcSpatialAccelerationInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial acceleration measured and
expressed in the world frame W.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody system.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A_WF_W, <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial acceleration measured and
expressed in the world frame W. The rotational part of the
returned quantity is α_WF_E (frame F’s angular acceleration α
measured and expressed in the world frame W). The translational
part is a_WFo_W (translational acceleration of frame F’s origin
point Fo, measured and expressed in the world frame W).</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Body::EvalSpatialAccelerationInWorld() provides a more efficient
way to obtain a body frame’s spatial acceleration measured in the
world frame.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When cached values are out of sync with the state stored in
context, this method performs an expensive forward dynamics
computation, whereas once evaluated, successive calls to this
method are inexpensive.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcSpatialAcceleration() and CalcSpatialVelocityInWorld().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[float].CalcSpatialVelocity">
<code class="descname">CalcSpatialVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float], context: pydrake.systems.framework.Context_[float], frame_M: pydrake.multibody.tree.Frame_[float], frame_E: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[float]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[float].CalcSpatialVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial velocity measured in a frame M,
expressed in a frame E.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody system.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_M</span></code>:</dt>
<dd>which is the measured_in_frame.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frame_E</span></code>:</dt>
<dd>which is the expressed_in_frame.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">V_MF_E, <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial velocity measured in frame M,
expressed in frame E. The rotational part of the returned quantity
is ω_MF_E (frame F’s angular velocity ω measured in frame M,
expressed in frame E). The translational part is v_MFo_E
(translational velocity v of frame F’s origin point Fo, measured
in frame M, expressed in frame E).</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcSpatialVelocityInWorld(), CalcRelativeSpatialVelocity(), and
CalcSpatialAcceleration().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[float].CalcSpatialVelocityInWorld">
<code class="descname">CalcSpatialVelocityInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[float]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[float].CalcSpatialVelocityInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial velocity measured and expressed
in the world frame W.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody system.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">V_WF_W, <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s spatial velocity measured and expressed
in the world frame W. The rotational part of the returned quantity
is ω_WF_W (frame F’s angular velocity ω measured and expressed in
the world frame W). The translational part is v_WFo_W
(translational velocity v of frame F’s origin point Fo, measured
and expressed in the world frame W).</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Body::EvalSpatialVelocityInWorld() provides a more efficient way
to obtain a body frame’s spatial velocity measured in the world
frame.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcSpatialVelocity(), CalcRelativeSpatialVelocityInWorld(), and
CalcSpatialAccelerationInWorld().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[float].EvalAngularVelocityInWorld">
<code class="descname">EvalAngularVelocityInWorld</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[float].EvalAngularVelocityInWorld" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s angular velocity measured and expressed
in the world frame W.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>contains the state of the multibody system.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">ω_WF_W (frame F’s angular velocity ω measured and expressed in the
world frame W).</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcAngularVelocity() to calculate ω_MF_E (<code class="docutils literal notranslate"><span class="pre">this</span></code> frame F’s
angular velocity ω measured in a frame M and expressed in a frame
E).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[float].GetFixedOffsetPoseInBody">
<code class="descname">GetFixedOffsetPoseInBody</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float], X_FQ: pydrake.math.RigidTransform_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[float].GetFixedOffsetPoseInBody" title="Permalink to this definition">¶</a></dt>
<dd><p>Variant of CalcOffsetPoseInBody() that given the offset pose <code class="docutils literal notranslate"><span class="pre">X_FQ</span></code>
of a frame Q in <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F, returns the pose <code class="docutils literal notranslate"><span class="pre">X_BQ</span></code> of frame Q
in the body frame B to which this frame is attached.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called on a Frame that does not have a fixed</li>
<li>offset in the body frame.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[float].GetFixedPoseInBodyFrame">
<code class="descname">GetFixedPoseInBodyFrame</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.Frame_[float].GetFixedPoseInBodyFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>GetFixedPoseInBodyFrame(self: pydrake.multibody.tree.Frame_[float]) -&gt; pydrake.math.RigidTransform_[float]</li>
</ol>
<p>Variant of CalcPoseInBodyFrame() that returns the fixed pose <code class="docutils literal notranslate"><span class="pre">X_BF</span></code>
of <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F in the body frame B associated with this frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called on a Frame that does not have a fixed</li>
<li>offset in the body frame.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>GetFixedPoseInBodyFrame(self: pydrake.multibody.tree.Frame_[float]) -&gt; pydrake.math.RigidTransform_[float]</li>
</ol>
<p>Variant of CalcPoseInBodyFrame() that returns the fixed pose <code class="docutils literal notranslate"><span class="pre">X_BF</span></code>
of <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F in the body frame B associated with this frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if called on a Frame that does not have a fixed</li>
<li>offset in the body frame.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[float].GetFixedRotationMatrixInBody">
<code class="descname">GetFixedRotationMatrixInBody</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float], R_FQ: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[float]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[float].GetFixedRotationMatrixInBody" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates and returns the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_BQ</span></code> that relates body
frame B to frame Q via <code class="docutils literal notranslate"><span class="pre">this</span></code> intermediate frame F, i.e., <code class="docutils literal notranslate"><span class="pre">R_BQ</span> <span class="pre">=</span>
<span class="pre">R_BF</span> <span class="pre">*</span> <span class="pre">R_FQ</span></code> (B is the body frame to which <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F is
attached).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_FQ</span></code>:</dt>
<dd>rotation matrix that relates frame F to frame Q.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F is a Frame that does not have a</li>
<li>fixed offset in the body frame B (i.e., <code class="docutils literal notranslate"><span class="pre">R_BF</span></code> is not constant).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[float].GetFixedRotationMatrixInBodyFrame">
<code class="descname">GetFixedRotationMatrixInBodyFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RotationMatrix_[float]<a class="headerlink" href="#pydrake.multibody.tree.Frame_[float].GetFixedRotationMatrixInBodyFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the rotation matrix <code class="docutils literal notranslate"><span class="pre">R_BF</span></code> that relates body frame B to
<code class="docutils literal notranslate"><span class="pre">this</span></code> frame F (B is the body frame to which <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F is
attached).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal notranslate"><span class="pre">this</span></code> frame F is a Frame that does not have a</li>
<li>fixed offset in the body frame B (i.e., <code class="docutils literal notranslate"><span class="pre">R_BF</span></code> is not constant).</li>
<li>Frame sub-classes that have a constant <code class="docutils literal notranslate"><span class="pre">R_BF</span></code> must override this</li>
<li>method. An example of a frame sub-class not implementing this</li>
<li>method would be that of a frame on a soft body, for which its pose</li>
<li>in the body frame depends on the state of deformation of the body.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[float].GetParentPlant">
<code class="descname">GetParentPlant</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; drake::multibody::MultibodyPlant&lt;double&gt;<a class="headerlink" href="#pydrake.multibody.tree.Frame_[float].GetParentPlant" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[float].index">
<code class="descname">index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.FrameIndex<a class="headerlink" href="#pydrake.multibody.tree.Frame_[float].index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[float].is_body_frame">
<code class="descname">is_body_frame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.Frame_[float].is_body_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if <code class="docutils literal notranslate"><span class="pre">this</span></code> is the body frame.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[float].is_world_frame">
<code class="descname">is_world_frame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.Frame_[float].is_world_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if <code class="docutils literal notranslate"><span class="pre">this</span></code> is the world frame.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[float].model_instance">
<code class="descname">model_instance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.Frame_[float].model_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Frame_[float].name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Frame_[float]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Frame_[float].name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name of this frame. The name will never be empty.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.FrameIndex">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">FrameIndex</code><a class="headerlink" href="#pydrake.multibody.tree.FrameIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Type used to identify frames by index in a multibody tree system.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.FrameIndex.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.FrameIndex.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.FrameIndex) -&gt; None</li>
</ol>
<p>Default constructor; the result is an <em>invalid</em> index. This only
exists to serve applications which require a default constructor.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.FrameIndex, arg0: int) -&gt; None</li>
</ol>
<p>Construction from a non-negative <code class="docutils literal notranslate"><span class="pre">int</span></code> value. The value must lie in
the range of [0, 2³¹). Constructor only promises to test validity in
Debug build.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.FrameIndex.is_valid">
<code class="descname">is_valid</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.FrameIndex</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.FrameIndex.is_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports if the index is valid–the only operation on an invalid index
that doesn’t throw an exception in Debug builds.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.JacobianWrtVariable">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">JacobianWrtVariable</code><a class="headerlink" href="#pydrake.multibody.tree.JacobianWrtVariable" title="Permalink to this definition">¶</a></dt>
<dd><p>Enumeration that indicates whether the Jacobian is partial
differentiation with respect to q̇ (time-derivatives of generalized
positions) or with respect to v (generalized velocities).</p>
<p>Members:</p>
<blockquote>
<div><p>kQDot : J = ∂V/∂q̇</p>
<p>kV : J = ∂V/∂v</p>
</div></blockquote>
<dl class="method">
<dt id="pydrake.multibody.tree.JacobianWrtVariable.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JacobianWrtVariable</em>, <em>value: int</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.JacobianWrtVariable.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.JacobianWrtVariable.kQDot">
<code class="descname">kQDot</code><em class="property"> = &lt;JacobianWrtVariable.kQDot: 0&gt;</em><a class="headerlink" href="#pydrake.multibody.tree.JacobianWrtVariable.kQDot" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.JacobianWrtVariable.kV">
<code class="descname">kV</code><em class="property"> = &lt;JacobianWrtVariable.kV: 1&gt;</em><a class="headerlink" href="#pydrake.multibody.tree.JacobianWrtVariable.kV" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.JacobianWrtVariable.name">
<code class="descname">name</code><a class="headerlink" href="#pydrake.multibody.tree.JacobianWrtVariable.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.JacobianWrtVariable.value">
<code class="descname">value</code><a class="headerlink" href="#pydrake.multibody.tree.JacobianWrtVariable.value" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.Joint">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">Joint</code><a class="headerlink" href="#pydrake.multibody.tree.Joint" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.Joint_[float]" title="pydrake.multibody.tree.Joint_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.Joint_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">Joint_</code><a class="headerlink" href="#pydrake.multibody.tree.Joint_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[float]" title="pydrake.multibody.tree.Joint_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Joint_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.Joint_[AutoDiffXd]" title="pydrake.multibody.tree.Joint_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Joint_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.Joint_[Expression]" title="pydrake.multibody.tree.Joint_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">Joint_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float]">
<em class="property">class </em><code class="descname">Joint_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>A Joint models the kinematical relationship which characterizes the
possible relative motion between two bodies. The two bodies connected
by this Joint object are referred to as <em>parent</em> and <em>child</em> bodies.
The parent/child ordering defines the sign conventions for the
generalized coordinates and the coordinate ordering for multi-DOF
joints. A Joint is a model of a physical kinematic constraint between
two bodies, a constraint that in the real physical system does not
specify a tree ordering. &#64;image html
drake/multibody/plant/images/BodyParentChildJoint.png width=50%</p>
<p>In Drake we define a frame F rigidly attached to the parent body P
with pose <code class="docutils literal notranslate"><span class="pre">X_PF</span></code> and a frame M rigidly attached to the child body B
with pose <code class="docutils literal notranslate"><span class="pre">X_BM</span></code>. A Joint object specifies a kinematic relation
between frames F and M, which in turn imposes a kinematic relation
between bodies P and B.</p>
<p>Typical joints include the ball joint, to allow unrestricted rotations
about a given point, the revolute joint, that constraints two bodies
to rotate about a given common axis, etc.</p>
<p>Consider the following example to build a simple pendulum system:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">plant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
<span class="o">//</span> <span class="o">...</span> <span class="n">Code</span> <span class="n">here</span> <span class="n">to</span> <span class="n">setup</span> <span class="n">quantities</span> <span class="n">below</span> <span class="k">as</span> <span class="n">mass</span><span class="p">,</span> <span class="n">com</span><span class="p">,</span> <span class="n">etc</span><span class="o">.</span> <span class="o">...</span>
<span class="n">const</span> <span class="n">Body</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&amp;</span> <span class="n">pendulum</span> <span class="o">=</span>
  <span class="n">plant</span><span class="o">.</span><span class="n">AddBody</span><span class="o">&lt;</span><span class="n">RigidBody</span><span class="o">&gt;</span><span class="p">(</span><span class="n">SpatialInertia</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mass</span><span class="p">,</span> <span class="n">com</span><span class="p">,</span> <span class="n">unit_inertia</span><span class="p">));</span>
<span class="o">//</span> <span class="n">We</span> <span class="n">will</span> <span class="n">connect</span> <span class="n">the</span> <span class="n">pendulum</span> <span class="n">body</span> <span class="n">to</span> <span class="n">the</span> <span class="n">world</span> <span class="n">using</span> <span class="n">a</span> <span class="n">RevoluteJoint</span><span class="o">.</span>
<span class="o">//</span> <span class="n">In</span> <span class="n">this</span> <span class="n">simple</span> <span class="n">case</span> <span class="n">the</span> <span class="n">parent</span> <span class="n">body</span> <span class="n">P</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">model</span><span class="s1">&#39;s world body and frame</span>
<span class="o">//</span> <span class="n">F</span> <span class="n">IS</span> <span class="n">the</span> <span class="n">world</span> <span class="n">frame</span><span class="o">.</span>
<span class="o">//</span> <span class="n">Additionally</span><span class="p">,</span> <span class="n">we</span> <span class="n">need</span> <span class="n">to</span> <span class="n">specify</span> <span class="n">the</span> <span class="n">pose</span> <span class="n">of</span> <span class="n">frame</span> <span class="n">M</span> <span class="n">on</span> <span class="n">the</span> <span class="n">pendulum</span><span class="s1">&#39;s</span>
<span class="o">//</span> <span class="n">body</span> <span class="n">frame</span> <span class="n">B</span><span class="o">.</span>
<span class="o">//</span> <span class="n">Say</span> <span class="n">we</span> <span class="n">declared</span> <span class="ow">and</span> <span class="n">initialized</span> <span class="n">X_BM</span><span class="o">...</span>
<span class="n">const</span> <span class="n">RevoluteJoint</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&amp;</span> <span class="n">elbow</span> <span class="o">=</span>
  <span class="n">plant</span><span class="o">.</span><span class="n">AddJoint</span><span class="o">&lt;</span><span class="n">RevoluteJoint</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="s2">&quot;Elbow&quot;</span><span class="p">,</span>                <span class="o">/*</span> <span class="n">joint</span> <span class="n">name</span>
    <span class="n">plant</span><span class="o">.</span><span class="n">world_body</span><span class="p">(),</span>     <span class="o">/*</span> <span class="n">parent</span> <span class="n">body</span>
    <span class="p">{},</span>                     <span class="o">/*</span> <span class="n">frame</span> <span class="n">F</span> <span class="n">IS</span> <span class="n">the</span> <span class="n">world</span> <span class="n">frame</span> <span class="n">W</span>
    <span class="n">pendulum</span><span class="p">,</span>               <span class="o">/*</span> <span class="n">child</span> <span class="n">body</span><span class="p">,</span> <span class="n">the</span> <span class="n">pendulum</span>
    <span class="n">X_BM</span><span class="p">,</span>                   <span class="o">/*</span> <span class="n">pose</span> <span class="n">of</span> <span class="n">frame</span> <span class="n">M</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">body</span> <span class="n">frame</span> <span class="n">B</span>
    <span class="n">Vector3d</span><span class="p">::</span><span class="n">UnitZ</span><span class="p">());</span>     <span class="o">/*</span> <span class="n">revolute</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">case</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Do not ever attempt to instantiate and manipulate Joint objects on
the stack; it will fail. Add joints to your plant using the
provided API MultibodyPlant::AddJoint() as in the example above.</p>
</div>
<dl class="attribute">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].acceleration_lower_limits">
<code class="descname">acceleration_lower_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].acceleration_lower_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the acceleration lower limits.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].acceleration_upper_limits">
<code class="descname">acceleration_upper_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].acceleration_upper_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the acceleration upper limits.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].AddInDamping">
<code class="descname">AddInDamping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float], context: pydrake.systems.framework.Context_[float], forces: drake::multibody::MultibodyForces&lt;double&gt;</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].AddInDamping" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds into <code class="docutils literal notranslate"><span class="pre">forces</span></code> the force due to damping within <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> joint belongs.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">forces</span></code>:</dt>
<dd>On return, this method will add the force due to damping within
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint. This method aborts if <code class="docutils literal notranslate"><span class="pre">forces</span></code> is <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> or
if <code class="docutils literal notranslate"><span class="pre">forces</span></code> does not have the right sizes to accommodate a set
of forces for the model to which this joint belongs.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].AddInOneForce">
<code class="descname">AddInOneForce</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float], context: pydrake.systems.framework.Context_[float], joint_dof: int, joint_tau: float, forces: drake::multibody::MultibodyForces&lt;double&gt;</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].AddInOneForce" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds into <code class="docutils literal notranslate"><span class="pre">forces</span></code> a force along the one of the joint’s degrees of
freedom indicated by index <code class="docutils literal notranslate"><span class="pre">joint_dof</span></code>. The meaning for this degree
of freedom and even its dimensional units depend on the specific joint
sub-class. For a RevoluteJoint for instance, <code class="docutils literal notranslate"><span class="pre">joint_dof</span></code> can only be
0 since revolute joints’s motion subspace only has one degree of
freedom, while the units of <code class="docutils literal notranslate"><span class="pre">joint_tau</span></code> are those of torque (N⋅m in
the MKS system of units). For multi-dof joints please refer to the
documentation provided by specific joint sub-classes regarding the
meaning of <code class="docutils literal notranslate"><span class="pre">joint_dof</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> joint belongs.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">joint_dof</span></code>:</dt>
<dd>Index specifying one of the degrees of freedom for this joint. The
index must be in the range <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">joint_dof</span> <span class="pre">&lt;</span> <span class="pre">num_velocities()</span></code>
or otherwise this method will abort.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">joint_tau</span></code>:</dt>
<dd>Generalized force corresponding to the degree of freedom indicated
by <code class="docutils literal notranslate"><span class="pre">joint_dof</span></code> to be added into <code class="docutils literal notranslate"><span class="pre">forces</span></code>.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">forces</span></code>:</dt>
<dd>On return, this method will add force <code class="docutils literal notranslate"><span class="pre">joint_tau</span></code> for the degree
of freedom <code class="docutils literal notranslate"><span class="pre">joint_dof</span></code> into the output <code class="docutils literal notranslate"><span class="pre">forces</span></code>. This method
aborts if <code class="docutils literal notranslate"><span class="pre">forces</span></code> is <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> or if <code class="docutils literal notranslate"><span class="pre">forces</span></code> doest not
have the right sizes to accommodate a set of forces for the model
to which this joint belongs.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].child_body">
<code class="descname">child_body</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[float]<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].child_body" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the child body B.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].default_positions">
<code class="descname">default_positions</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].default_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default positions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].frame_on_child">
<code class="descname">frame_on_child</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Frame_[float]<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].frame_on_child" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the frame M attached on the child body B.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].frame_on_parent">
<code class="descname">frame_on_parent</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Frame_[float]<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].frame_on_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the frame F attached on the parent body
P.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].GetOnePosition">
<code class="descname">GetOnePosition</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].GetOnePosition" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the position coordinate for joints with a single degree of
freedom.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the joint does not have a single degree of</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">freedom.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].GetOneVelocity">
<code class="descname">GetOneVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].GetOneVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the velocity coordinate for joints with a single degree of
freedom.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the joint does not have a single degree of</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">freedom.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].GetParentPlant">
<code class="descname">GetParentPlant</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; drake::multibody::MultibodyPlant&lt;double&gt;<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].GetParentPlant" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].index">
<code class="descname">index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.JointIndex<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].is_locked">
<code class="descname">is_locked</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].is_locked" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">true if the joint is locked, false otherwise.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].Lock">
<code class="descname">Lock</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].Lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Lock the joint. Its generalized velocities will be 0 until it is
unlocked. Locking is not yet supported for continuous-mode systems.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the parent model uses continuous state.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].model_instance">
<code class="descname">model_instance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].model_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name of this joint.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].num_positions">
<code class="descname">num_positions</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].num_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of generalized positions describing this joint.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].num_velocities">
<code class="descname">num_velocities</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].num_velocities" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of generalized velocities describing this joint.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].parent_body">
<code class="descname">parent_body</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[float]<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].parent_body" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the parent body P.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].position_lower_limits">
<code class="descname">position_lower_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].position_lower_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;name Methods to get and set the limits of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint. For
position limits, the layout is the same as the generalized position’s.
For velocity and acceleration limits, the layout is the same as the
generalized velocity’s. A limit with value +/- ∞ implies no upper or
lower limit. Returns the position lower limits.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].position_start">
<code class="descname">position_start</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].position_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index to the first generalized position for this joint
within the vector q of generalized positions for the full multibody
system.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].position_suffix">
<code class="descname">position_suffix</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float], arg0: int</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].position_suffix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string suffix (e.g. to be appended to the name()) to
identify the <cite>k`th position in this joint. ``position_index_in_joint`</cite>
must be in [0, num_positions()).</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>the MultibodyPlant must be finalized.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].position_upper_limits">
<code class="descname">position_upper_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].position_upper_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the position upper limits.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].set_acceleration_limits">
<code class="descname">set_acceleration_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float], lower_limits: numpy.ndarray[numpy.float64[m, 1]], upper_limits: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].set_acceleration_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the acceleration limits to <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> and <code class="docutils literal notranslate"><span class="pre">upper_limits</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the dimension of <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> or</li>
<li><code class="docutils literal notranslate"><span class="pre">upper_limits</span></code> does not match num_velocities().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if any of <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> is larger than the</li>
<li>corresponding term in <code class="docutils literal notranslate"><span class="pre">upper_limits</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].set_default_positions">
<code class="descname">set_default_positions</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float], default_positions: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].set_default_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default positions to <code class="docutils literal notranslate"><span class="pre">default_positions</span></code>. Joint subclasses
are expected to implement the do_set_default_positions().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the dimension of <code class="docutils literal notranslate"><span class="pre">default_positions</span></code> does not</li>
<li>match num_positions().</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The values in <code class="docutils literal notranslate"><span class="pre">default_positions</span></code> are NOT constrained to be
within <code class="docutils literal notranslate"><span class="pre">position_lower_limits()</span></code> and
<code class="docutils literal notranslate"><span class="pre">position_upper_limits()</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].set_position_limits">
<code class="descname">set_position_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float], lower_limits: numpy.ndarray[numpy.float64[m, 1]], upper_limits: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].set_position_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the position limits to <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> and <code class="docutils literal notranslate"><span class="pre">upper_limits</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the dimension of <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> or</li>
<li><code class="docutils literal notranslate"><span class="pre">upper_limits</span></code> does not match num_positions().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if any of <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> is larger than the</li>
<li>corresponding term in <code class="docutils literal notranslate"><span class="pre">upper_limits</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Setting the position limits does not affect the
<code class="docutils literal notranslate"><span class="pre">default_positions()</span></code>, regardless of whether the current
<code class="docutils literal notranslate"><span class="pre">default_positions()</span></code> satisfy the new position limits.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].set_velocity_limits">
<code class="descname">set_velocity_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float], lower_limits: numpy.ndarray[numpy.float64[m, 1]], upper_limits: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].set_velocity_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the velocity limits to <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> and <code class="docutils literal notranslate"><span class="pre">upper_limits</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the dimension of <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> or</li>
<li><code class="docutils literal notranslate"><span class="pre">upper_limits</span></code> does not match num_velocities().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if any of <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> is larger than the</li>
<li>corresponding term in <code class="docutils literal notranslate"><span class="pre">upper_limits</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].type_name">
<code class="descname">type_name</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string identifying the type of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint, such as
“revolute” or “prismatic”.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].Unlock">
<code class="descname">Unlock</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].Unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Unlock the joint. Unlocking is not yet supported for continuous-mode
systems.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the parent model uses continuous state.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].velocity_lower_limits">
<code class="descname">velocity_lower_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].velocity_lower_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the velocity lower limits.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].velocity_start">
<code class="descname">velocity_start</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].velocity_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index to the first generalized velocity for this joint
within the vector v of generalized velocities for the full multibody
system.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].velocity_suffix">
<code class="descname">velocity_suffix</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float], arg0: int</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].velocity_suffix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string suffix (e.g. to be appended to the name()) to
identify the <cite>k`th velocity in this joint. ``velocity_index_in_joint`</cite>
must be in [0, num_velocities()).</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>the MultibodyPlant must be finalized.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_.Joint_[float].velocity_upper_limits">
<code class="descname">velocity_upper_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_.Joint_[float].velocity_upper_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the velocity upper limits.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">Joint_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>A Joint models the kinematical relationship which characterizes the
possible relative motion between two bodies. The two bodies connected
by this Joint object are referred to as <em>parent</em> and <em>child</em> bodies.
The parent/child ordering defines the sign conventions for the
generalized coordinates and the coordinate ordering for multi-DOF
joints. A Joint is a model of a physical kinematic constraint between
two bodies, a constraint that in the real physical system does not
specify a tree ordering. &#64;image html
drake/multibody/plant/images/BodyParentChildJoint.png width=50%</p>
<p>In Drake we define a frame F rigidly attached to the parent body P
with pose <code class="docutils literal notranslate"><span class="pre">X_PF</span></code> and a frame M rigidly attached to the child body B
with pose <code class="docutils literal notranslate"><span class="pre">X_BM</span></code>. A Joint object specifies a kinematic relation
between frames F and M, which in turn imposes a kinematic relation
between bodies P and B.</p>
<p>Typical joints include the ball joint, to allow unrestricted rotations
about a given point, the revolute joint, that constraints two bodies
to rotate about a given common axis, etc.</p>
<p>Consider the following example to build a simple pendulum system:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">plant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
<span class="o">//</span> <span class="o">...</span> <span class="n">Code</span> <span class="n">here</span> <span class="n">to</span> <span class="n">setup</span> <span class="n">quantities</span> <span class="n">below</span> <span class="k">as</span> <span class="n">mass</span><span class="p">,</span> <span class="n">com</span><span class="p">,</span> <span class="n">etc</span><span class="o">.</span> <span class="o">...</span>
<span class="n">const</span> <span class="n">Body</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&amp;</span> <span class="n">pendulum</span> <span class="o">=</span>
  <span class="n">plant</span><span class="o">.</span><span class="n">AddBody</span><span class="o">&lt;</span><span class="n">RigidBody</span><span class="o">&gt;</span><span class="p">(</span><span class="n">SpatialInertia</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mass</span><span class="p">,</span> <span class="n">com</span><span class="p">,</span> <span class="n">unit_inertia</span><span class="p">));</span>
<span class="o">//</span> <span class="n">We</span> <span class="n">will</span> <span class="n">connect</span> <span class="n">the</span> <span class="n">pendulum</span> <span class="n">body</span> <span class="n">to</span> <span class="n">the</span> <span class="n">world</span> <span class="n">using</span> <span class="n">a</span> <span class="n">RevoluteJoint</span><span class="o">.</span>
<span class="o">//</span> <span class="n">In</span> <span class="n">this</span> <span class="n">simple</span> <span class="n">case</span> <span class="n">the</span> <span class="n">parent</span> <span class="n">body</span> <span class="n">P</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">model</span><span class="s1">&#39;s world body and frame</span>
<span class="o">//</span> <span class="n">F</span> <span class="n">IS</span> <span class="n">the</span> <span class="n">world</span> <span class="n">frame</span><span class="o">.</span>
<span class="o">//</span> <span class="n">Additionally</span><span class="p">,</span> <span class="n">we</span> <span class="n">need</span> <span class="n">to</span> <span class="n">specify</span> <span class="n">the</span> <span class="n">pose</span> <span class="n">of</span> <span class="n">frame</span> <span class="n">M</span> <span class="n">on</span> <span class="n">the</span> <span class="n">pendulum</span><span class="s1">&#39;s</span>
<span class="o">//</span> <span class="n">body</span> <span class="n">frame</span> <span class="n">B</span><span class="o">.</span>
<span class="o">//</span> <span class="n">Say</span> <span class="n">we</span> <span class="n">declared</span> <span class="ow">and</span> <span class="n">initialized</span> <span class="n">X_BM</span><span class="o">...</span>
<span class="n">const</span> <span class="n">RevoluteJoint</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&amp;</span> <span class="n">elbow</span> <span class="o">=</span>
  <span class="n">plant</span><span class="o">.</span><span class="n">AddJoint</span><span class="o">&lt;</span><span class="n">RevoluteJoint</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="s2">&quot;Elbow&quot;</span><span class="p">,</span>                <span class="o">/*</span> <span class="n">joint</span> <span class="n">name</span>
    <span class="n">plant</span><span class="o">.</span><span class="n">world_body</span><span class="p">(),</span>     <span class="o">/*</span> <span class="n">parent</span> <span class="n">body</span>
    <span class="p">{},</span>                     <span class="o">/*</span> <span class="n">frame</span> <span class="n">F</span> <span class="n">IS</span> <span class="n">the</span> <span class="n">world</span> <span class="n">frame</span> <span class="n">W</span>
    <span class="n">pendulum</span><span class="p">,</span>               <span class="o">/*</span> <span class="n">child</span> <span class="n">body</span><span class="p">,</span> <span class="n">the</span> <span class="n">pendulum</span>
    <span class="n">X_BM</span><span class="p">,</span>                   <span class="o">/*</span> <span class="n">pose</span> <span class="n">of</span> <span class="n">frame</span> <span class="n">M</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">body</span> <span class="n">frame</span> <span class="n">B</span>
    <span class="n">Vector3d</span><span class="p">::</span><span class="n">UnitZ</span><span class="p">());</span>     <span class="o">/*</span> <span class="n">revolute</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">case</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Do not ever attempt to instantiate and manipulate Joint objects on
the stack; it will fail. Add joints to your plant using the
provided API MultibodyPlant::AddJoint() as in the example above.</p>
</div>
<dl class="attribute">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].acceleration_lower_limits">
<code class="descname">acceleration_lower_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].acceleration_lower_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the acceleration lower limits.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].acceleration_upper_limits">
<code class="descname">acceleration_upper_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].acceleration_upper_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the acceleration upper limits.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].AddInDamping">
<code class="descname">AddInDamping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], forces: drake::multibody::MultibodyForces&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].AddInDamping" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds into <code class="docutils literal notranslate"><span class="pre">forces</span></code> the force due to damping within <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> joint belongs.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">forces</span></code>:</dt>
<dd>On return, this method will add the force due to damping within
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint. This method aborts if <code class="docutils literal notranslate"><span class="pre">forces</span></code> is <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> or
if <code class="docutils literal notranslate"><span class="pre">forces</span></code> does not have the right sizes to accommodate a set
of forces for the model to which this joint belongs.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].AddInOneForce">
<code class="descname">AddInOneForce</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], joint_dof: int, joint_tau: pydrake.autodiffutils.AutoDiffXd, forces: drake::multibody::MultibodyForces&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].AddInOneForce" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds into <code class="docutils literal notranslate"><span class="pre">forces</span></code> a force along the one of the joint’s degrees of
freedom indicated by index <code class="docutils literal notranslate"><span class="pre">joint_dof</span></code>. The meaning for this degree
of freedom and even its dimensional units depend on the specific joint
sub-class. For a RevoluteJoint for instance, <code class="docutils literal notranslate"><span class="pre">joint_dof</span></code> can only be
0 since revolute joints’s motion subspace only has one degree of
freedom, while the units of <code class="docutils literal notranslate"><span class="pre">joint_tau</span></code> are those of torque (N⋅m in
the MKS system of units). For multi-dof joints please refer to the
documentation provided by specific joint sub-classes regarding the
meaning of <code class="docutils literal notranslate"><span class="pre">joint_dof</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> joint belongs.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">joint_dof</span></code>:</dt>
<dd>Index specifying one of the degrees of freedom for this joint. The
index must be in the range <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">joint_dof</span> <span class="pre">&lt;</span> <span class="pre">num_velocities()</span></code>
or otherwise this method will abort.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">joint_tau</span></code>:</dt>
<dd>Generalized force corresponding to the degree of freedom indicated
by <code class="docutils literal notranslate"><span class="pre">joint_dof</span></code> to be added into <code class="docutils literal notranslate"><span class="pre">forces</span></code>.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">forces</span></code>:</dt>
<dd>On return, this method will add force <code class="docutils literal notranslate"><span class="pre">joint_tau</span></code> for the degree
of freedom <code class="docutils literal notranslate"><span class="pre">joint_dof</span></code> into the output <code class="docutils literal notranslate"><span class="pre">forces</span></code>. This method
aborts if <code class="docutils literal notranslate"><span class="pre">forces</span></code> is <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> or if <code class="docutils literal notranslate"><span class="pre">forces</span></code> doest not
have the right sizes to accommodate a set of forces for the model
to which this joint belongs.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].child_body">
<code class="descname">child_body</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].child_body" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the child body B.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].default_positions">
<code class="descname">default_positions</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].default_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default positions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].frame_on_child">
<code class="descname">frame_on_child</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Frame_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].frame_on_child" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the frame M attached on the child body B.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].frame_on_parent">
<code class="descname">frame_on_parent</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Frame_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].frame_on_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the frame F attached on the parent body
P.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].GetOnePosition">
<code class="descname">GetOnePosition</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.autodiffutils.AutoDiffXd<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].GetOnePosition" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the position coordinate for joints with a single degree of
freedom.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the joint does not have a single degree of</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">freedom.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].GetOneVelocity">
<code class="descname">GetOneVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.autodiffutils.AutoDiffXd<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].GetOneVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the velocity coordinate for joints with a single degree of
freedom.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the joint does not have a single degree of</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">freedom.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].GetParentPlant">
<code class="descname">GetParentPlant</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; drake::multibody::MultibodyPlant&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].GetParentPlant" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].index">
<code class="descname">index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.JointIndex<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].is_locked">
<code class="descname">is_locked</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].is_locked" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">true if the joint is locked, false otherwise.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].Lock">
<code class="descname">Lock</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].Lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Lock the joint. Its generalized velocities will be 0 until it is
unlocked. Locking is not yet supported for continuous-mode systems.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the parent model uses continuous state.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].model_instance">
<code class="descname">model_instance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].model_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name of this joint.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].num_positions">
<code class="descname">num_positions</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].num_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of generalized positions describing this joint.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].num_velocities">
<code class="descname">num_velocities</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].num_velocities" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of generalized velocities describing this joint.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].parent_body">
<code class="descname">parent_body</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].parent_body" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the parent body P.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].position_lower_limits">
<code class="descname">position_lower_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].position_lower_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;name Methods to get and set the limits of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint. For
position limits, the layout is the same as the generalized position’s.
For velocity and acceleration limits, the layout is the same as the
generalized velocity’s. A limit with value +/- ∞ implies no upper or
lower limit. Returns the position lower limits.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].position_start">
<code class="descname">position_start</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].position_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index to the first generalized position for this joint
within the vector q of generalized positions for the full multibody
system.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].position_suffix">
<code class="descname">position_suffix</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd], arg0: int</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].position_suffix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string suffix (e.g. to be appended to the name()) to
identify the <cite>k`th position in this joint. ``position_index_in_joint`</cite>
must be in [0, num_positions()).</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>the MultibodyPlant must be finalized.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].position_upper_limits">
<code class="descname">position_upper_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].position_upper_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the position upper limits.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].set_acceleration_limits">
<code class="descname">set_acceleration_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd], lower_limits: numpy.ndarray[numpy.float64[m, 1]], upper_limits: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].set_acceleration_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the acceleration limits to <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> and <code class="docutils literal notranslate"><span class="pre">upper_limits</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the dimension of <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> or</li>
<li><code class="docutils literal notranslate"><span class="pre">upper_limits</span></code> does not match num_velocities().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if any of <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> is larger than the</li>
<li>corresponding term in <code class="docutils literal notranslate"><span class="pre">upper_limits</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].set_default_positions">
<code class="descname">set_default_positions</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd], default_positions: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].set_default_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default positions to <code class="docutils literal notranslate"><span class="pre">default_positions</span></code>. Joint subclasses
are expected to implement the do_set_default_positions().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the dimension of <code class="docutils literal notranslate"><span class="pre">default_positions</span></code> does not</li>
<li>match num_positions().</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The values in <code class="docutils literal notranslate"><span class="pre">default_positions</span></code> are NOT constrained to be
within <code class="docutils literal notranslate"><span class="pre">position_lower_limits()</span></code> and
<code class="docutils literal notranslate"><span class="pre">position_upper_limits()</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].set_position_limits">
<code class="descname">set_position_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd], lower_limits: numpy.ndarray[numpy.float64[m, 1]], upper_limits: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].set_position_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the position limits to <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> and <code class="docutils literal notranslate"><span class="pre">upper_limits</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the dimension of <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> or</li>
<li><code class="docutils literal notranslate"><span class="pre">upper_limits</span></code> does not match num_positions().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if any of <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> is larger than the</li>
<li>corresponding term in <code class="docutils literal notranslate"><span class="pre">upper_limits</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Setting the position limits does not affect the
<code class="docutils literal notranslate"><span class="pre">default_positions()</span></code>, regardless of whether the current
<code class="docutils literal notranslate"><span class="pre">default_positions()</span></code> satisfy the new position limits.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].set_velocity_limits">
<code class="descname">set_velocity_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd], lower_limits: numpy.ndarray[numpy.float64[m, 1]], upper_limits: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].set_velocity_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the velocity limits to <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> and <code class="docutils literal notranslate"><span class="pre">upper_limits</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the dimension of <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> or</li>
<li><code class="docutils literal notranslate"><span class="pre">upper_limits</span></code> does not match num_velocities().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if any of <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> is larger than the</li>
<li>corresponding term in <code class="docutils literal notranslate"><span class="pre">upper_limits</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].type_name">
<code class="descname">type_name</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string identifying the type of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint, such as
“revolute” or “prismatic”.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].Unlock">
<code class="descname">Unlock</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].Unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Unlock the joint. Unlocking is not yet supported for continuous-mode
systems.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the parent model uses continuous state.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].velocity_lower_limits">
<code class="descname">velocity_lower_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].velocity_lower_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the velocity lower limits.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].velocity_start">
<code class="descname">velocity_start</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].velocity_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index to the first generalized velocity for this joint
within the vector v of generalized velocities for the full multibody
system.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].velocity_suffix">
<code class="descname">velocity_suffix</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd], arg0: int</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].velocity_suffix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string suffix (e.g. to be appended to the name()) to
identify the <cite>k`th velocity in this joint. ``velocity_index_in_joint`</cite>
must be in [0, num_velocities()).</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>the MultibodyPlant must be finalized.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[AutoDiffXd].velocity_upper_limits">
<code class="descname">velocity_upper_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[AutoDiffXd].velocity_upper_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the velocity upper limits.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.Joint_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">Joint_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>A Joint models the kinematical relationship which characterizes the
possible relative motion between two bodies. The two bodies connected
by this Joint object are referred to as <em>parent</em> and <em>child</em> bodies.
The parent/child ordering defines the sign conventions for the
generalized coordinates and the coordinate ordering for multi-DOF
joints. A Joint is a model of a physical kinematic constraint between
two bodies, a constraint that in the real physical system does not
specify a tree ordering. &#64;image html
drake/multibody/plant/images/BodyParentChildJoint.png width=50%</p>
<p>In Drake we define a frame F rigidly attached to the parent body P
with pose <code class="docutils literal notranslate"><span class="pre">X_PF</span></code> and a frame M rigidly attached to the child body B
with pose <code class="docutils literal notranslate"><span class="pre">X_BM</span></code>. A Joint object specifies a kinematic relation
between frames F and M, which in turn imposes a kinematic relation
between bodies P and B.</p>
<p>Typical joints include the ball joint, to allow unrestricted rotations
about a given point, the revolute joint, that constraints two bodies
to rotate about a given common axis, etc.</p>
<p>Consider the following example to build a simple pendulum system:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">plant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
<span class="o">//</span> <span class="o">...</span> <span class="n">Code</span> <span class="n">here</span> <span class="n">to</span> <span class="n">setup</span> <span class="n">quantities</span> <span class="n">below</span> <span class="k">as</span> <span class="n">mass</span><span class="p">,</span> <span class="n">com</span><span class="p">,</span> <span class="n">etc</span><span class="o">.</span> <span class="o">...</span>
<span class="n">const</span> <span class="n">Body</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&amp;</span> <span class="n">pendulum</span> <span class="o">=</span>
  <span class="n">plant</span><span class="o">.</span><span class="n">AddBody</span><span class="o">&lt;</span><span class="n">RigidBody</span><span class="o">&gt;</span><span class="p">(</span><span class="n">SpatialInertia</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mass</span><span class="p">,</span> <span class="n">com</span><span class="p">,</span> <span class="n">unit_inertia</span><span class="p">));</span>
<span class="o">//</span> <span class="n">We</span> <span class="n">will</span> <span class="n">connect</span> <span class="n">the</span> <span class="n">pendulum</span> <span class="n">body</span> <span class="n">to</span> <span class="n">the</span> <span class="n">world</span> <span class="n">using</span> <span class="n">a</span> <span class="n">RevoluteJoint</span><span class="o">.</span>
<span class="o">//</span> <span class="n">In</span> <span class="n">this</span> <span class="n">simple</span> <span class="n">case</span> <span class="n">the</span> <span class="n">parent</span> <span class="n">body</span> <span class="n">P</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">model</span><span class="s1">&#39;s world body and frame</span>
<span class="o">//</span> <span class="n">F</span> <span class="n">IS</span> <span class="n">the</span> <span class="n">world</span> <span class="n">frame</span><span class="o">.</span>
<span class="o">//</span> <span class="n">Additionally</span><span class="p">,</span> <span class="n">we</span> <span class="n">need</span> <span class="n">to</span> <span class="n">specify</span> <span class="n">the</span> <span class="n">pose</span> <span class="n">of</span> <span class="n">frame</span> <span class="n">M</span> <span class="n">on</span> <span class="n">the</span> <span class="n">pendulum</span><span class="s1">&#39;s</span>
<span class="o">//</span> <span class="n">body</span> <span class="n">frame</span> <span class="n">B</span><span class="o">.</span>
<span class="o">//</span> <span class="n">Say</span> <span class="n">we</span> <span class="n">declared</span> <span class="ow">and</span> <span class="n">initialized</span> <span class="n">X_BM</span><span class="o">...</span>
<span class="n">const</span> <span class="n">RevoluteJoint</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&amp;</span> <span class="n">elbow</span> <span class="o">=</span>
  <span class="n">plant</span><span class="o">.</span><span class="n">AddJoint</span><span class="o">&lt;</span><span class="n">RevoluteJoint</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="s2">&quot;Elbow&quot;</span><span class="p">,</span>                <span class="o">/*</span> <span class="n">joint</span> <span class="n">name</span>
    <span class="n">plant</span><span class="o">.</span><span class="n">world_body</span><span class="p">(),</span>     <span class="o">/*</span> <span class="n">parent</span> <span class="n">body</span>
    <span class="p">{},</span>                     <span class="o">/*</span> <span class="n">frame</span> <span class="n">F</span> <span class="n">IS</span> <span class="n">the</span> <span class="n">world</span> <span class="n">frame</span> <span class="n">W</span>
    <span class="n">pendulum</span><span class="p">,</span>               <span class="o">/*</span> <span class="n">child</span> <span class="n">body</span><span class="p">,</span> <span class="n">the</span> <span class="n">pendulum</span>
    <span class="n">X_BM</span><span class="p">,</span>                   <span class="o">/*</span> <span class="n">pose</span> <span class="n">of</span> <span class="n">frame</span> <span class="n">M</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">body</span> <span class="n">frame</span> <span class="n">B</span>
    <span class="n">Vector3d</span><span class="p">::</span><span class="n">UnitZ</span><span class="p">());</span>     <span class="o">/*</span> <span class="n">revolute</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">case</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Do not ever attempt to instantiate and manipulate Joint objects on
the stack; it will fail. Add joints to your plant using the
provided API MultibodyPlant::AddJoint() as in the example above.</p>
</div>
<dl class="attribute">
<dt id="pydrake.multibody.tree.Joint_[Expression].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].acceleration_lower_limits">
<code class="descname">acceleration_lower_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].acceleration_lower_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the acceleration lower limits.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].acceleration_upper_limits">
<code class="descname">acceleration_upper_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].acceleration_upper_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the acceleration upper limits.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].AddInDamping">
<code class="descname">AddInDamping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression], context: pydrake.systems.framework.Context_[Expression], forces: drake::multibody::MultibodyForces&lt;drake::symbolic::Expression&gt;</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].AddInDamping" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds into <code class="docutils literal notranslate"><span class="pre">forces</span></code> the force due to damping within <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> joint belongs.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">forces</span></code>:</dt>
<dd>On return, this method will add the force due to damping within
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint. This method aborts if <code class="docutils literal notranslate"><span class="pre">forces</span></code> is <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> or
if <code class="docutils literal notranslate"><span class="pre">forces</span></code> does not have the right sizes to accommodate a set
of forces for the model to which this joint belongs.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].AddInOneForce">
<code class="descname">AddInOneForce</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression], context: pydrake.systems.framework.Context_[Expression], joint_dof: int, joint_tau: pydrake.symbolic.Expression, forces: drake::multibody::MultibodyForces&lt;drake::symbolic::Expression&gt;</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].AddInOneForce" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds into <code class="docutils literal notranslate"><span class="pre">forces</span></code> a force along the one of the joint’s degrees of
freedom indicated by index <code class="docutils literal notranslate"><span class="pre">joint_dof</span></code>. The meaning for this degree
of freedom and even its dimensional units depend on the specific joint
sub-class. For a RevoluteJoint for instance, <code class="docutils literal notranslate"><span class="pre">joint_dof</span></code> can only be
0 since revolute joints’s motion subspace only has one degree of
freedom, while the units of <code class="docutils literal notranslate"><span class="pre">joint_tau</span></code> are those of torque (N⋅m in
the MKS system of units). For multi-dof joints please refer to the
documentation provided by specific joint sub-classes regarding the
meaning of <code class="docutils literal notranslate"><span class="pre">joint_dof</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> joint belongs.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">joint_dof</span></code>:</dt>
<dd>Index specifying one of the degrees of freedom for this joint. The
index must be in the range <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">joint_dof</span> <span class="pre">&lt;</span> <span class="pre">num_velocities()</span></code>
or otherwise this method will abort.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">joint_tau</span></code>:</dt>
<dd>Generalized force corresponding to the degree of freedom indicated
by <code class="docutils literal notranslate"><span class="pre">joint_dof</span></code> to be added into <code class="docutils literal notranslate"><span class="pre">forces</span></code>.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">forces</span></code>:</dt>
<dd>On return, this method will add force <code class="docutils literal notranslate"><span class="pre">joint_tau</span></code> for the degree
of freedom <code class="docutils literal notranslate"><span class="pre">joint_dof</span></code> into the output <code class="docutils literal notranslate"><span class="pre">forces</span></code>. This method
aborts if <code class="docutils literal notranslate"><span class="pre">forces</span></code> is <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> or if <code class="docutils literal notranslate"><span class="pre">forces</span></code> doest not
have the right sizes to accommodate a set of forces for the model
to which this joint belongs.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].child_body">
<code class="descname">child_body</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].child_body" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the child body B.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].default_positions">
<code class="descname">default_positions</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].default_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default positions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].frame_on_child">
<code class="descname">frame_on_child</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Frame_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].frame_on_child" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the frame M attached on the child body B.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].frame_on_parent">
<code class="descname">frame_on_parent</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Frame_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].frame_on_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the frame F attached on the parent body
P.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].GetOnePosition">
<code class="descname">GetOnePosition</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].GetOnePosition" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the position coordinate for joints with a single degree of
freedom.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the joint does not have a single degree of</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">freedom.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].GetOneVelocity">
<code class="descname">GetOneVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].GetOneVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the velocity coordinate for joints with a single degree of
freedom.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the joint does not have a single degree of</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">freedom.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].GetParentPlant">
<code class="descname">GetParentPlant</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression]</em><span class="sig-paren">)</span> &#x2192; drake::multibody::MultibodyPlant&lt;drake::symbolic::Expression&gt;<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].GetParentPlant" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].index">
<code class="descname">index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.JointIndex<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].is_locked">
<code class="descname">is_locked</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].is_locked" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">true if the joint is locked, false otherwise.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].Lock">
<code class="descname">Lock</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].Lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Lock the joint. Its generalized velocities will be 0 until it is
unlocked. Locking is not yet supported for continuous-mode systems.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the parent model uses continuous state.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].model_instance">
<code class="descname">model_instance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].model_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name of this joint.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].num_positions">
<code class="descname">num_positions</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].num_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of generalized positions describing this joint.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].num_velocities">
<code class="descname">num_velocities</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].num_velocities" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of generalized velocities describing this joint.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].parent_body">
<code class="descname">parent_body</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].parent_body" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the parent body P.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].position_lower_limits">
<code class="descname">position_lower_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].position_lower_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;name Methods to get and set the limits of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint. For
position limits, the layout is the same as the generalized position’s.
For velocity and acceleration limits, the layout is the same as the
generalized velocity’s. A limit with value +/- ∞ implies no upper or
lower limit. Returns the position lower limits.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].position_start">
<code class="descname">position_start</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].position_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index to the first generalized position for this joint
within the vector q of generalized positions for the full multibody
system.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].position_suffix">
<code class="descname">position_suffix</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression], arg0: int</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].position_suffix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string suffix (e.g. to be appended to the name()) to
identify the <cite>k`th position in this joint. ``position_index_in_joint`</cite>
must be in [0, num_positions()).</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>the MultibodyPlant must be finalized.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].position_upper_limits">
<code class="descname">position_upper_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].position_upper_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the position upper limits.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].set_acceleration_limits">
<code class="descname">set_acceleration_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression], lower_limits: numpy.ndarray[numpy.float64[m, 1]], upper_limits: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].set_acceleration_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the acceleration limits to <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> and <code class="docutils literal notranslate"><span class="pre">upper_limits</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the dimension of <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> or</li>
<li><code class="docutils literal notranslate"><span class="pre">upper_limits</span></code> does not match num_velocities().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if any of <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> is larger than the</li>
<li>corresponding term in <code class="docutils literal notranslate"><span class="pre">upper_limits</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].set_default_positions">
<code class="descname">set_default_positions</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression], default_positions: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].set_default_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default positions to <code class="docutils literal notranslate"><span class="pre">default_positions</span></code>. Joint subclasses
are expected to implement the do_set_default_positions().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the dimension of <code class="docutils literal notranslate"><span class="pre">default_positions</span></code> does not</li>
<li>match num_positions().</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The values in <code class="docutils literal notranslate"><span class="pre">default_positions</span></code> are NOT constrained to be
within <code class="docutils literal notranslate"><span class="pre">position_lower_limits()</span></code> and
<code class="docutils literal notranslate"><span class="pre">position_upper_limits()</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].set_position_limits">
<code class="descname">set_position_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression], lower_limits: numpy.ndarray[numpy.float64[m, 1]], upper_limits: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].set_position_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the position limits to <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> and <code class="docutils literal notranslate"><span class="pre">upper_limits</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the dimension of <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> or</li>
<li><code class="docutils literal notranslate"><span class="pre">upper_limits</span></code> does not match num_positions().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if any of <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> is larger than the</li>
<li>corresponding term in <code class="docutils literal notranslate"><span class="pre">upper_limits</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Setting the position limits does not affect the
<code class="docutils literal notranslate"><span class="pre">default_positions()</span></code>, regardless of whether the current
<code class="docutils literal notranslate"><span class="pre">default_positions()</span></code> satisfy the new position limits.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].set_velocity_limits">
<code class="descname">set_velocity_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression], lower_limits: numpy.ndarray[numpy.float64[m, 1]], upper_limits: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].set_velocity_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the velocity limits to <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> and <code class="docutils literal notranslate"><span class="pre">upper_limits</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the dimension of <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> or</li>
<li><code class="docutils literal notranslate"><span class="pre">upper_limits</span></code> does not match num_velocities().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if any of <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> is larger than the</li>
<li>corresponding term in <code class="docutils literal notranslate"><span class="pre">upper_limits</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].type_name">
<code class="descname">type_name</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string identifying the type of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint, such as
“revolute” or “prismatic”.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].Unlock">
<code class="descname">Unlock</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].Unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Unlock the joint. Unlocking is not yet supported for continuous-mode
systems.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the parent model uses continuous state.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].velocity_lower_limits">
<code class="descname">velocity_lower_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].velocity_lower_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the velocity lower limits.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].velocity_start">
<code class="descname">velocity_start</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].velocity_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index to the first generalized velocity for this joint
within the vector v of generalized velocities for the full multibody
system.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].velocity_suffix">
<code class="descname">velocity_suffix</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression], arg0: int</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].velocity_suffix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string suffix (e.g. to be appended to the name()) to
identify the <cite>k`th velocity in this joint. ``velocity_index_in_joint`</cite>
must be in [0, num_velocities()).</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>the MultibodyPlant must be finalized.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[Expression].velocity_upper_limits">
<code class="descname">velocity_upper_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[Expression].velocity_upper_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the velocity upper limits.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.Joint_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">Joint_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.Joint_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>A Joint models the kinematical relationship which characterizes the
possible relative motion between two bodies. The two bodies connected
by this Joint object are referred to as <em>parent</em> and <em>child</em> bodies.
The parent/child ordering defines the sign conventions for the
generalized coordinates and the coordinate ordering for multi-DOF
joints. A Joint is a model of a physical kinematic constraint between
two bodies, a constraint that in the real physical system does not
specify a tree ordering. &#64;image html
drake/multibody/plant/images/BodyParentChildJoint.png width=50%</p>
<p>In Drake we define a frame F rigidly attached to the parent body P
with pose <code class="docutils literal notranslate"><span class="pre">X_PF</span></code> and a frame M rigidly attached to the child body B
with pose <code class="docutils literal notranslate"><span class="pre">X_BM</span></code>. A Joint object specifies a kinematic relation
between frames F and M, which in turn imposes a kinematic relation
between bodies P and B.</p>
<p>Typical joints include the ball joint, to allow unrestricted rotations
about a given point, the revolute joint, that constraints two bodies
to rotate about a given common axis, etc.</p>
<p>Consider the following example to build a simple pendulum system:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">MultibodyPlant</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span> <span class="n">plant</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
<span class="o">//</span> <span class="o">...</span> <span class="n">Code</span> <span class="n">here</span> <span class="n">to</span> <span class="n">setup</span> <span class="n">quantities</span> <span class="n">below</span> <span class="k">as</span> <span class="n">mass</span><span class="p">,</span> <span class="n">com</span><span class="p">,</span> <span class="n">etc</span><span class="o">.</span> <span class="o">...</span>
<span class="n">const</span> <span class="n">Body</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&amp;</span> <span class="n">pendulum</span> <span class="o">=</span>
  <span class="n">plant</span><span class="o">.</span><span class="n">AddBody</span><span class="o">&lt;</span><span class="n">RigidBody</span><span class="o">&gt;</span><span class="p">(</span><span class="n">SpatialInertia</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mass</span><span class="p">,</span> <span class="n">com</span><span class="p">,</span> <span class="n">unit_inertia</span><span class="p">));</span>
<span class="o">//</span> <span class="n">We</span> <span class="n">will</span> <span class="n">connect</span> <span class="n">the</span> <span class="n">pendulum</span> <span class="n">body</span> <span class="n">to</span> <span class="n">the</span> <span class="n">world</span> <span class="n">using</span> <span class="n">a</span> <span class="n">RevoluteJoint</span><span class="o">.</span>
<span class="o">//</span> <span class="n">In</span> <span class="n">this</span> <span class="n">simple</span> <span class="n">case</span> <span class="n">the</span> <span class="n">parent</span> <span class="n">body</span> <span class="n">P</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">model</span><span class="s1">&#39;s world body and frame</span>
<span class="o">//</span> <span class="n">F</span> <span class="n">IS</span> <span class="n">the</span> <span class="n">world</span> <span class="n">frame</span><span class="o">.</span>
<span class="o">//</span> <span class="n">Additionally</span><span class="p">,</span> <span class="n">we</span> <span class="n">need</span> <span class="n">to</span> <span class="n">specify</span> <span class="n">the</span> <span class="n">pose</span> <span class="n">of</span> <span class="n">frame</span> <span class="n">M</span> <span class="n">on</span> <span class="n">the</span> <span class="n">pendulum</span><span class="s1">&#39;s</span>
<span class="o">//</span> <span class="n">body</span> <span class="n">frame</span> <span class="n">B</span><span class="o">.</span>
<span class="o">//</span> <span class="n">Say</span> <span class="n">we</span> <span class="n">declared</span> <span class="ow">and</span> <span class="n">initialized</span> <span class="n">X_BM</span><span class="o">...</span>
<span class="n">const</span> <span class="n">RevoluteJoint</span><span class="o">&lt;</span><span class="n">double</span><span class="o">&gt;&amp;</span> <span class="n">elbow</span> <span class="o">=</span>
  <span class="n">plant</span><span class="o">.</span><span class="n">AddJoint</span><span class="o">&lt;</span><span class="n">RevoluteJoint</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="s2">&quot;Elbow&quot;</span><span class="p">,</span>                <span class="o">/*</span> <span class="n">joint</span> <span class="n">name</span>
    <span class="n">plant</span><span class="o">.</span><span class="n">world_body</span><span class="p">(),</span>     <span class="o">/*</span> <span class="n">parent</span> <span class="n">body</span>
    <span class="p">{},</span>                     <span class="o">/*</span> <span class="n">frame</span> <span class="n">F</span> <span class="n">IS</span> <span class="n">the</span> <span class="n">world</span> <span class="n">frame</span> <span class="n">W</span>
    <span class="n">pendulum</span><span class="p">,</span>               <span class="o">/*</span> <span class="n">child</span> <span class="n">body</span><span class="p">,</span> <span class="n">the</span> <span class="n">pendulum</span>
    <span class="n">X_BM</span><span class="p">,</span>                   <span class="o">/*</span> <span class="n">pose</span> <span class="n">of</span> <span class="n">frame</span> <span class="n">M</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">body</span> <span class="n">frame</span> <span class="n">B</span>
    <span class="n">Vector3d</span><span class="p">::</span><span class="n">UnitZ</span><span class="p">());</span>     <span class="o">/*</span> <span class="n">revolute</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">case</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Do not ever attempt to instantiate and manipulate Joint objects on
the stack; it will fail. Add joints to your plant using the
provided API MultibodyPlant::AddJoint() as in the example above.</p>
</div>
<dl class="attribute">
<dt id="pydrake.multibody.tree.Joint_[float].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].acceleration_lower_limits">
<code class="descname">acceleration_lower_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].acceleration_lower_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the acceleration lower limits.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].acceleration_upper_limits">
<code class="descname">acceleration_upper_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].acceleration_upper_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the acceleration upper limits.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].AddInDamping">
<code class="descname">AddInDamping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float], context: pydrake.systems.framework.Context_[float], forces: drake::multibody::MultibodyForces&lt;double&gt;</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].AddInDamping" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds into <code class="docutils literal notranslate"><span class="pre">forces</span></code> the force due to damping within <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> joint belongs.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">forces</span></code>:</dt>
<dd>On return, this method will add the force due to damping within
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint. This method aborts if <code class="docutils literal notranslate"><span class="pre">forces</span></code> is <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> or
if <code class="docutils literal notranslate"><span class="pre">forces</span></code> does not have the right sizes to accommodate a set
of forces for the model to which this joint belongs.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].AddInOneForce">
<code class="descname">AddInOneForce</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float], context: pydrake.systems.framework.Context_[float], joint_dof: int, joint_tau: float, forces: drake::multibody::MultibodyForces&lt;double&gt;</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].AddInOneForce" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds into <code class="docutils literal notranslate"><span class="pre">forces</span></code> a force along the one of the joint’s degrees of
freedom indicated by index <code class="docutils literal notranslate"><span class="pre">joint_dof</span></code>. The meaning for this degree
of freedom and even its dimensional units depend on the specific joint
sub-class. For a RevoluteJoint for instance, <code class="docutils literal notranslate"><span class="pre">joint_dof</span></code> can only be
0 since revolute joints’s motion subspace only has one degree of
freedom, while the units of <code class="docutils literal notranslate"><span class="pre">joint_tau</span></code> are those of torque (N⋅m in
the MKS system of units). For multi-dof joints please refer to the
documentation provided by specific joint sub-classes regarding the
meaning of <code class="docutils literal notranslate"><span class="pre">joint_dof</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context storing the state and parameters for the model to
which <code class="docutils literal notranslate"><span class="pre">this</span></code> joint belongs.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">joint_dof</span></code>:</dt>
<dd>Index specifying one of the degrees of freedom for this joint. The
index must be in the range <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">joint_dof</span> <span class="pre">&lt;</span> <span class="pre">num_velocities()</span></code>
or otherwise this method will abort.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">joint_tau</span></code>:</dt>
<dd>Generalized force corresponding to the degree of freedom indicated
by <code class="docutils literal notranslate"><span class="pre">joint_dof</span></code> to be added into <code class="docutils literal notranslate"><span class="pre">forces</span></code>.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">forces</span></code>:</dt>
<dd>On return, this method will add force <code class="docutils literal notranslate"><span class="pre">joint_tau</span></code> for the degree
of freedom <code class="docutils literal notranslate"><span class="pre">joint_dof</span></code> into the output <code class="docutils literal notranslate"><span class="pre">forces</span></code>. This method
aborts if <code class="docutils literal notranslate"><span class="pre">forces</span></code> is <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> or if <code class="docutils literal notranslate"><span class="pre">forces</span></code> doest not
have the right sizes to accommodate a set of forces for the model
to which this joint belongs.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].child_body">
<code class="descname">child_body</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[float]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].child_body" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the child body B.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].default_positions">
<code class="descname">default_positions</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].default_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default positions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].frame_on_child">
<code class="descname">frame_on_child</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Frame_[float]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].frame_on_child" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the frame M attached on the child body B.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].frame_on_parent">
<code class="descname">frame_on_parent</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Frame_[float]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].frame_on_parent" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the frame F attached on the parent body
P.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].GetOnePosition">
<code class="descname">GetOnePosition</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].GetOnePosition" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the position coordinate for joints with a single degree of
freedom.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the joint does not have a single degree of</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">freedom.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].GetOneVelocity">
<code class="descname">GetOneVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].GetOneVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the velocity coordinate for joints with a single degree of
freedom.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the joint does not have a single degree of</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">freedom.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].GetParentPlant">
<code class="descname">GetParentPlant</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; drake::multibody::MultibodyPlant&lt;double&gt;<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].GetParentPlant" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].index">
<code class="descname">index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.JointIndex<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].is_locked">
<code class="descname">is_locked</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].is_locked" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">true if the joint is locked, false otherwise.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].Lock">
<code class="descname">Lock</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].Lock" title="Permalink to this definition">¶</a></dt>
<dd><p>Lock the joint. Its generalized velocities will be 0 until it is
unlocked. Locking is not yet supported for continuous-mode systems.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the parent model uses continuous state.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].model_instance">
<code class="descname">model_instance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].model_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name of this joint.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].num_positions">
<code class="descname">num_positions</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].num_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of generalized positions describing this joint.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].num_velocities">
<code class="descname">num_velocities</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].num_velocities" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of generalized velocities describing this joint.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].parent_body">
<code class="descname">parent_body</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[float]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].parent_body" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a const reference to the parent body P.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].position_lower_limits">
<code class="descname">position_lower_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].position_lower_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>&#64;name Methods to get and set the limits of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint. For
position limits, the layout is the same as the generalized position’s.
For velocity and acceleration limits, the layout is the same as the
generalized velocity’s. A limit with value +/- ∞ implies no upper or
lower limit. Returns the position lower limits.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].position_start">
<code class="descname">position_start</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].position_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index to the first generalized position for this joint
within the vector q of generalized positions for the full multibody
system.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].position_suffix">
<code class="descname">position_suffix</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float], arg0: int</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].position_suffix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string suffix (e.g. to be appended to the name()) to
identify the <cite>k`th position in this joint. ``position_index_in_joint`</cite>
must be in [0, num_positions()).</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>the MultibodyPlant must be finalized.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].position_upper_limits">
<code class="descname">position_upper_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].position_upper_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the position upper limits.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].set_acceleration_limits">
<code class="descname">set_acceleration_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float], lower_limits: numpy.ndarray[numpy.float64[m, 1]], upper_limits: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].set_acceleration_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the acceleration limits to <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> and <code class="docutils literal notranslate"><span class="pre">upper_limits</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the dimension of <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> or</li>
<li><code class="docutils literal notranslate"><span class="pre">upper_limits</span></code> does not match num_velocities().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if any of <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> is larger than the</li>
<li>corresponding term in <code class="docutils literal notranslate"><span class="pre">upper_limits</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].set_default_positions">
<code class="descname">set_default_positions</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float], default_positions: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].set_default_positions" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default positions to <code class="docutils literal notranslate"><span class="pre">default_positions</span></code>. Joint subclasses
are expected to implement the do_set_default_positions().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if the dimension of <code class="docutils literal notranslate"><span class="pre">default_positions</span></code> does not</li>
<li>match num_positions().</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The values in <code class="docutils literal notranslate"><span class="pre">default_positions</span></code> are NOT constrained to be
within <code class="docutils literal notranslate"><span class="pre">position_lower_limits()</span></code> and
<code class="docutils literal notranslate"><span class="pre">position_upper_limits()</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].set_position_limits">
<code class="descname">set_position_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float], lower_limits: numpy.ndarray[numpy.float64[m, 1]], upper_limits: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].set_position_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the position limits to <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> and <code class="docutils literal notranslate"><span class="pre">upper_limits</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the dimension of <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> or</li>
<li><code class="docutils literal notranslate"><span class="pre">upper_limits</span></code> does not match num_positions().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if any of <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> is larger than the</li>
<li>corresponding term in <code class="docutils literal notranslate"><span class="pre">upper_limits</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Setting the position limits does not affect the
<code class="docutils literal notranslate"><span class="pre">default_positions()</span></code>, regardless of whether the current
<code class="docutils literal notranslate"><span class="pre">default_positions()</span></code> satisfy the new position limits.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].set_velocity_limits">
<code class="descname">set_velocity_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float], lower_limits: numpy.ndarray[numpy.float64[m, 1]], upper_limits: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].set_velocity_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the velocity limits to <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> and <code class="docutils literal notranslate"><span class="pre">upper_limits</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the dimension of <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> or</li>
<li><code class="docutils literal notranslate"><span class="pre">upper_limits</span></code> does not match num_velocities().</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if any of <code class="docutils literal notranslate"><span class="pre">lower_limits</span></code> is larger than the</li>
<li>corresponding term in <code class="docutils literal notranslate"><span class="pre">upper_limits</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].type_name">
<code class="descname">type_name</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].type_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string identifying the type of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint, such as
“revolute” or “prismatic”.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].Unlock">
<code class="descname">Unlock</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].Unlock" title="Permalink to this definition">¶</a></dt>
<dd><p>Unlock the joint. Unlocking is not yet supported for continuous-mode
systems.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the parent model uses continuous state.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].velocity_lower_limits">
<code class="descname">velocity_lower_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].velocity_lower_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the velocity lower limits.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].velocity_start">
<code class="descname">velocity_start</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].velocity_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index to the first generalized velocity for this joint
within the vector v of generalized velocities for the full multibody
system.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].velocity_suffix">
<code class="descname">velocity_suffix</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float], arg0: int</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].velocity_suffix" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a string suffix (e.g. to be appended to the name()) to
identify the <cite>k`th velocity in this joint. ``velocity_index_in_joint`</cite>
must be in [0, num_velocities()).</p>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>the MultibodyPlant must be finalized.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.Joint_[float].velocity_upper_limits">
<code class="descname">velocity_upper_limits</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.Joint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.Joint_[float].velocity_upper_limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the velocity upper limits.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.JointActuator">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">JointActuator</code><a class="headerlink" href="#pydrake.multibody.tree.JointActuator" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.JointActuator_[float]" title="pydrake.multibody.tree.JointActuator_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.JointActuator_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.JointActuator_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">JointActuator_</code><a class="headerlink" href="#pydrake.multibody.tree.JointActuator_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.JointActuator_[float]" title="pydrake.multibody.tree.JointActuator_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">JointActuator_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.JointActuator_[AutoDiffXd]" title="pydrake.multibody.tree.JointActuator_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">JointActuator_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.JointActuator_[Expression]" title="pydrake.multibody.tree.JointActuator_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">JointActuator_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.JointActuator_.JointActuator_[float]">
<em class="property">class </em><code class="descname">JointActuator_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.JointActuator_.JointActuator_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>The JointActuator class is mostly a simple bookkeeping structure to
represent an actuator acting on a given Joint. It helps to flag
whether a given Joint is actuated or not so that MultibodyTree clients
can apply forces on actuated joints through their actuators, see
AddInOneForce().</p>
<dl class="attribute">
<dt id="pydrake.multibody.tree.JointActuator_.JointActuator_[float].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.JointActuator_.JointActuator_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_.JointActuator_[float].effort_limit">
<code class="descname">effort_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_.JointActuator_[float].effort_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the actuator effort limit.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_.JointActuator_[float].get_actuation_vector">
<code class="descname">get_actuation_vector</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[float], u: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_.JointActuator_[float].get_actuation_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the actuation values for <code class="docutils literal notranslate"><span class="pre">this</span></code> actuator from the actuation
vector u for the entire model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a reference to a nv-dimensional vector, where nv is the number of
velocity variables of joint().</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_.JointActuator_[float].GetParentPlant">
<code class="descname">GetParentPlant</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[float]</em><span class="sig-paren">)</span> &#x2192; drake::multibody::MultibodyPlant&lt;double&gt;<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_.JointActuator_[float].GetParentPlant" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_.JointActuator_[float].index">
<code class="descname">index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.JointActuatorIndex<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_.JointActuator_[float].index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_.JointActuator_[float].input_start">
<code class="descname">input_start</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_.JointActuator_[float].input_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index to the first element for this joint actuator /
within the vector of actuation inputs for the full multibody / system.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the MultibodyTree model is not finalized.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_.JointActuator_[float].joint">
<code class="descname">joint</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Joint_[float]<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_.JointActuator_[float].joint" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a reference to the joint actuated by this JointActuator.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_.JointActuator_[float].model_instance">
<code class="descname">model_instance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_.JointActuator_[float].model_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_.JointActuator_[float].name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[float]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_.JointActuator_[float].name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name of the actuator.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_.JointActuator_[float].num_inputs">
<code class="descname">num_inputs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_.JointActuator_[float].num_inputs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of inputs associated with this actuator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the MultibodyTree model is not finalized.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_.JointActuator_[float].set_actuation_vector">
<code class="descname">set_actuation_vector</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[float], u_instance: numpy.ndarray[numpy.float64[m, 1]], u: Optional[numpy.ndarray[numpy.float64[m, 1], flags.writeable]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_.JointActuator_[float].set_actuation_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the actuation values u_instance for <code class="docutils literal notranslate"><span class="pre">this</span></code> actuator, this
method sets the actuation vector u for the entire MultibodyTree model
to which this actuator belongs to.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">u_instance</span></code>:</dt>
<dd>Actuation values for <code class="docutils literal notranslate"><span class="pre">this</span></code> actuator. It must be of size equal
to the number of degrees of freedom of the actuated Joint, see
Joint::num_velocities(). For units and sign conventions refer to
the specific Joint sub-class documentation.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">u</span></code>:</dt>
<dd>The vector containing the actuation values for the entire
MultibodyTree model to which <code class="docutils literal notranslate"><span class="pre">this</span></code> actuator belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if <a href="#id9"><span class="problematic" id="id10">``</span></a>u_instance.size() !=</li>
<li>this-&gt;joint().num_velocities()``.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first">RuntimeError if u is nullptr.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <a href="#id11"><span class="problematic" id="id12">``</span></a>u.size() !=</li>
<li>this-&gt;get_parent_tree().num_actuated_dofs()``.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.JointActuator_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">JointActuator_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>The JointActuator class is mostly a simple bookkeeping structure to
represent an actuator acting on a given Joint. It helps to flag
whether a given Joint is actuated or not so that MultibodyTree clients
can apply forces on actuated joints through their actuators, see
AddInOneForce().</p>
<dl class="attribute">
<dt id="pydrake.multibody.tree.JointActuator_[AutoDiffXd].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[AutoDiffXd].effort_limit">
<code class="descname">effort_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[AutoDiffXd].effort_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the actuator effort limit.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[AutoDiffXd].get_actuation_vector">
<code class="descname">get_actuation_vector</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[AutoDiffXd], u: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[AutoDiffXd].get_actuation_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the actuation values for <code class="docutils literal notranslate"><span class="pre">this</span></code> actuator from the actuation
vector u for the entire model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a reference to a nv-dimensional vector, where nv is the number of
velocity variables of joint().</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[AutoDiffXd].GetParentPlant">
<code class="descname">GetParentPlant</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; drake::multibody::MultibodyPlant&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[AutoDiffXd].GetParentPlant" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[AutoDiffXd].index">
<code class="descname">index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.JointActuatorIndex<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[AutoDiffXd].index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[AutoDiffXd].input_start">
<code class="descname">input_start</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[AutoDiffXd].input_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index to the first element for this joint actuator /
within the vector of actuation inputs for the full multibody / system.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the MultibodyTree model is not finalized.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[AutoDiffXd].joint">
<code class="descname">joint</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Joint_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[AutoDiffXd].joint" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a reference to the joint actuated by this JointActuator.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[AutoDiffXd].model_instance">
<code class="descname">model_instance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[AutoDiffXd].model_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[AutoDiffXd].name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[AutoDiffXd].name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name of the actuator.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[AutoDiffXd].num_inputs">
<code class="descname">num_inputs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[AutoDiffXd].num_inputs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of inputs associated with this actuator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the MultibodyTree model is not finalized.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[AutoDiffXd].set_actuation_vector">
<code class="descname">set_actuation_vector</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[AutoDiffXd], u_instance: numpy.ndarray[object[m, 1]], u: Optional[numpy.ndarray[object[m, 1], flags.writeable]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[AutoDiffXd].set_actuation_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the actuation values u_instance for <code class="docutils literal notranslate"><span class="pre">this</span></code> actuator, this
method sets the actuation vector u for the entire MultibodyTree model
to which this actuator belongs to.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">u_instance</span></code>:</dt>
<dd>Actuation values for <code class="docutils literal notranslate"><span class="pre">this</span></code> actuator. It must be of size equal
to the number of degrees of freedom of the actuated Joint, see
Joint::num_velocities(). For units and sign conventions refer to
the specific Joint sub-class documentation.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">u</span></code>:</dt>
<dd>The vector containing the actuation values for the entire
MultibodyTree model to which <code class="docutils literal notranslate"><span class="pre">this</span></code> actuator belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if <a href="#id13"><span class="problematic" id="id14">``</span></a>u_instance.size() !=</li>
<li>this-&gt;joint().num_velocities()``.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first">RuntimeError if u is nullptr.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <a href="#id15"><span class="problematic" id="id16">``</span></a>u.size() !=</li>
<li>this-&gt;get_parent_tree().num_actuated_dofs()``.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.JointActuator_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">JointActuator_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>The JointActuator class is mostly a simple bookkeeping structure to
represent an actuator acting on a given Joint. It helps to flag
whether a given Joint is actuated or not so that MultibodyTree clients
can apply forces on actuated joints through their actuators, see
AddInOneForce().</p>
<dl class="attribute">
<dt id="pydrake.multibody.tree.JointActuator_[Expression].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[Expression].effort_limit">
<code class="descname">effort_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[Expression].effort_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the actuator effort limit.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[Expression].get_actuation_vector">
<code class="descname">get_actuation_vector</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[Expression], u: numpy.ndarray[object[m, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[Expression].get_actuation_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the actuation values for <code class="docutils literal notranslate"><span class="pre">this</span></code> actuator from the actuation
vector u for the entire model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a reference to a nv-dimensional vector, where nv is the number of
velocity variables of joint().</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[Expression].GetParentPlant">
<code class="descname">GetParentPlant</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[Expression]</em><span class="sig-paren">)</span> &#x2192; drake::multibody::MultibodyPlant&lt;drake::symbolic::Expression&gt;<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[Expression].GetParentPlant" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[Expression].index">
<code class="descname">index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.JointActuatorIndex<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[Expression].index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[Expression].input_start">
<code class="descname">input_start</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[Expression]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[Expression].input_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index to the first element for this joint actuator /
within the vector of actuation inputs for the full multibody / system.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the MultibodyTree model is not finalized.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[Expression].joint">
<code class="descname">joint</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Joint_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[Expression].joint" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a reference to the joint actuated by this JointActuator.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[Expression].model_instance">
<code class="descname">model_instance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[Expression].model_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[Expression].name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[Expression]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[Expression].name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name of the actuator.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[Expression].num_inputs">
<code class="descname">num_inputs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[Expression]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[Expression].num_inputs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of inputs associated with this actuator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the MultibodyTree model is not finalized.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[Expression].set_actuation_vector">
<code class="descname">set_actuation_vector</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[Expression], u_instance: numpy.ndarray[object[m, 1]], u: Optional[numpy.ndarray[object[m, 1], flags.writeable]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[Expression].set_actuation_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the actuation values u_instance for <code class="docutils literal notranslate"><span class="pre">this</span></code> actuator, this
method sets the actuation vector u for the entire MultibodyTree model
to which this actuator belongs to.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">u_instance</span></code>:</dt>
<dd>Actuation values for <code class="docutils literal notranslate"><span class="pre">this</span></code> actuator. It must be of size equal
to the number of degrees of freedom of the actuated Joint, see
Joint::num_velocities(). For units and sign conventions refer to
the specific Joint sub-class documentation.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">u</span></code>:</dt>
<dd>The vector containing the actuation values for the entire
MultibodyTree model to which <code class="docutils literal notranslate"><span class="pre">this</span></code> actuator belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if <a href="#id17"><span class="problematic" id="id18">``</span></a>u_instance.size() !=</li>
<li>this-&gt;joint().num_velocities()``.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first">RuntimeError if u is nullptr.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <a href="#id19"><span class="problematic" id="id20">``</span></a>u.size() !=</li>
<li>this-&gt;get_parent_tree().num_actuated_dofs()``.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.JointActuator_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">JointActuator_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>The JointActuator class is mostly a simple bookkeeping structure to
represent an actuator acting on a given Joint. It helps to flag
whether a given Joint is actuated or not so that MultibodyTree clients
can apply forces on actuated joints through their actuators, see
AddInOneForce().</p>
<dl class="attribute">
<dt id="pydrake.multibody.tree.JointActuator_[float].__init__">
<code class="descname">__init__</code><a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize self.  See help(type(self)) for accurate signature.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[float].effort_limit">
<code class="descname">effort_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[float].effort_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the actuator effort limit.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[float].get_actuation_vector">
<code class="descname">get_actuation_vector</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[float], u: numpy.ndarray[numpy.float64[m, 1]]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[float].get_actuation_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the actuation values for <code class="docutils literal notranslate"><span class="pre">this</span></code> actuator from the actuation
vector u for the entire model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a reference to a nv-dimensional vector, where nv is the number of
velocity variables of joint().</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[float].GetParentPlant">
<code class="descname">GetParentPlant</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[float]</em><span class="sig-paren">)</span> &#x2192; drake::multibody::MultibodyPlant&lt;double&gt;<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[float].GetParentPlant" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[float].index">
<code class="descname">index</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.JointActuatorIndex<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[float].index" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[float].input_start">
<code class="descname">input_start</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[float].input_start" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index to the first element for this joint actuator /
within the vector of actuation inputs for the full multibody / system.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the MultibodyTree model is not finalized.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[float].joint">
<code class="descname">joint</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Joint_[float]<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[float].joint" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a reference to the joint actuated by this JointActuator.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[float].model_instance">
<code class="descname">model_instance</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[float].model_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[float].name">
<code class="descname">name</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[float]</em><span class="sig-paren">)</span> &#x2192; str<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[float].name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name of the actuator.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[float].num_inputs">
<code class="descname">num_inputs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[float].num_inputs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of inputs associated with this actuator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if the MultibodyTree model is not finalized.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuator_[float].set_actuation_vector">
<code class="descname">set_actuation_vector</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuator_[float], u_instance: numpy.ndarray[numpy.float64[m, 1]], u: Optional[numpy.ndarray[numpy.float64[m, 1], flags.writeable]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.JointActuator_[float].set_actuation_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the actuation values u_instance for <code class="docutils literal notranslate"><span class="pre">this</span></code> actuator, this
method sets the actuation vector u for the entire MultibodyTree model
to which this actuator belongs to.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">u_instance</span></code>:</dt>
<dd>Actuation values for <code class="docutils literal notranslate"><span class="pre">this</span></code> actuator. It must be of size equal
to the number of degrees of freedom of the actuated Joint, see
Joint::num_velocities(). For units and sign conventions refer to
the specific Joint sub-class documentation.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">u</span></code>:</dt>
<dd>The vector containing the actuation values for the entire
MultibodyTree model to which <code class="docutils literal notranslate"><span class="pre">this</span></code> actuator belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if <a href="#id21"><span class="problematic" id="id22">``</span></a>u_instance.size() !=</li>
<li>this-&gt;joint().num_velocities()``.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first">RuntimeError if u is nullptr.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <a href="#id23"><span class="problematic" id="id24">``</span></a>u.size() !=</li>
<li>this-&gt;get_parent_tree().num_actuated_dofs()``.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.JointActuatorIndex">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">JointActuatorIndex</code><a class="headerlink" href="#pydrake.multibody.tree.JointActuatorIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Type used to identify actuators by index within a multibody tree
system.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.JointActuatorIndex.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.JointActuatorIndex.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.JointActuatorIndex) -&gt; None</li>
</ol>
<p>Default constructor; the result is an <em>invalid</em> index. This only
exists to serve applications which require a default constructor.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.JointActuatorIndex, arg0: int) -&gt; None</li>
</ol>
<p>Construction from a non-negative <code class="docutils literal notranslate"><span class="pre">int</span></code> value. The value must lie in
the range of [0, 2³¹). Constructor only promises to test validity in
Debug build.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointActuatorIndex.is_valid">
<code class="descname">is_valid</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointActuatorIndex</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.JointActuatorIndex.is_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports if the index is valid–the only operation on an invalid index
that doesn’t throw an exception in Debug builds.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.JointIndex">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">JointIndex</code><a class="headerlink" href="#pydrake.multibody.tree.JointIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Type used to identify joints by index within a multibody tree system.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.JointIndex.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.JointIndex.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.JointIndex) -&gt; None</li>
</ol>
<p>Default constructor; the result is an <em>invalid</em> index. This only
exists to serve applications which require a default constructor.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.JointIndex, arg0: int) -&gt; None</li>
</ol>
<p>Construction from a non-negative <code class="docutils literal notranslate"><span class="pre">int</span></code> value. The value must lie in
the range of [0, 2³¹). Constructor only promises to test validity in
Debug build.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.JointIndex.is_valid">
<code class="descname">is_valid</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.JointIndex</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.JointIndex.is_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports if the index is valid–the only operation on an invalid index
that doesn’t throw an exception in Debug builds.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">LinearBushingRollPitchYaw</code><a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[float]" title="pydrake.multibody.tree.LinearBushingRollPitchYaw_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.LinearBushingRollPitchYaw_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">LinearBushingRollPitchYaw_</code><a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[float]" title="pydrake.multibody.tree.LinearBushingRollPitchYaw_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">LinearBushingRollPitchYaw_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd]" title="pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">LinearBushingRollPitchYaw_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression]" title="pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">LinearBushingRollPitchYaw_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_.LinearBushingRollPitchYaw_[float]">
<em class="property">class </em><code class="descname">LinearBushingRollPitchYaw_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_.LinearBushingRollPitchYaw_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[float]" title="pydrake.multibody.tree.ForceElement_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ForceElement_[float]</span></code></a></p>
<p>This ForceElement models a massless flexible bushing that connects a
frame A of a link (body) L0 to a frame C of a link (body) L1. The
bushing can apply a torque and force due to stiffness (spring) and
dissipation (damper) properties. Frame B is the bushing frame whose
origin Bo is halfway between Ao (A’s origin) and Co (C’s origin) and
whose unit vectors 𝐁𝐱, 𝐁𝐲, 𝐁𝐳 are “halfway” (in an angle-axis sense)
between the unit vectors of frame A and frame C. Frame B is a
“floating” frame in the sense that it is calculated from the position
and orientation of frames A and C (B is not welded to the bushing).</p>
<p>&#64;image html drake/multibody/tree/images/LinearBushingRollPitchYaw.png
width=80%</p>
<p>The set of forces on frame C from the bushing is equivalent to a
torque 𝐭 on frame C and a force 𝐟 applied to a point Cp of C. The set
of forces on frame A from the bushing is equivalent to a torque −𝐭 on
frame A and a force −𝐟 applied to a point Ap of A. Points Ap and Cp
are coincident with Bo (frame B’s origin).</p>
<p>This “quasi-symmetric” bushing force/torque model was developed at
Toyota Research Institute and has advantages compared to traditional
bushing models because it employs a bushing-centered “symmetric” frame
B and it ensures the moment of −𝐟 on A about Ao is equal to the moment
of 𝐟 on C about Co. Traditional models differ as they lack a
“symmetric” frame B and apply −𝐟 at Ao, which means the moment of −𝐟
on A about Ao is always zero. Note: This bushing model is not fully
symmetric since the orientation between frames A and C is
parameterized with roll-pitch-yaw angles [q₀ q₁ q₂]. Since these
angles have an inherent sequence, they are not mathematically
symmetric.</p>
<p>The torque model depends on spring-damper “gimbal” torques <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">≜</span> <span class="pre">[τ₀</span>
<span class="pre">τ₁</span> <span class="pre">τ₂]</span></code> which themselves depend on roll-pitch-yaw angles <code class="docutils literal notranslate"><span class="pre">q</span> <span class="pre">≜</span> <span class="pre">[q₀</span> <span class="pre">q₁</span>
<span class="pre">q₂]</span></code> and rates <code class="docutils literal notranslate"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">[q̇₀</span> <span class="pre">q̇₁</span> <span class="pre">q̇₂]</span></code> via a diagonal torque-stiffness
matrix K₀₁₂ and a diagonal torque-damping matrix D₀₁₂ as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>⌈ τ₀ ⌉     ⌈k₀    0    0⌉ ⌈ q₀ ⌉     ⌈d₀    0    0⌉ ⌈ q̇₀ ⌉
τ ≜ | τ₁ | = − | 0   k₁    0| | q₁ |  −  | 0   d₁    0| | q̇₁ |
    ⌊ τ₂ ⌋     ⌊ 0    0   k₂⌋ ⌊ q₂ ⌋     ⌊ 0    0   d₂⌋ ⌊ q̇₂ ⌋
</pre></div>
</div>
<p>where k₀, k₁, k₂ and d₀, d₁, d₂ are torque stiffness and damping
constants and must have non-negative values.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">τ does not represent a vector expressed in one frame. Instead it
is regarded as a 3x1 array of torque scalars associated with
roll-pitch yaw.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As discussed in the Advanced section below, τ is not 𝐭 <code class="docutils literal notranslate"><span class="pre">(τ</span> <span class="pre">≠</span>
<span class="pre">𝐭)</span></code>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is a “linear” bushing model as gimbal torque τ varies
linearly with q and q̇ as τ = τᴋ + τᴅ where τᴋ = −K₀₁₂ ⋅ q and τᴅ
= −D₀₁₂ ⋅ q̇.</p>
</div>
<p>The bushing model for the net force 𝐟 on frame C from the bushing
depends on scalars x, y, z which are defined so 𝐫 (the position vector
from Ao to Co) can be expressed in frame B as <code class="docutils literal notranslate"><span class="pre">𝐫</span> <span class="pre">≜</span> <span class="pre">p_AoCo</span> <span class="pre">=</span> <span class="pre">[x</span> <span class="pre">y</span> <span class="pre">z]ʙ</span>
<span class="pre">=</span> <span class="pre">x</span> <span class="pre">𝐁𝐱</span> <span class="pre">+</span> <span class="pre">y</span> <span class="pre">𝐁𝐲</span> <span class="pre">+</span> <span class="pre">z</span> <span class="pre">𝐁𝐳</span></code>. The model for 𝐟 uses a diagonal
force-stiffness matrix Kxyᴢ, a diagonal force-damping matrix Dxyᴢ, and
defines fx, fy, fz so <code class="docutils literal notranslate"><span class="pre">𝐟</span> <span class="pre">=</span> <span class="pre">[fx</span> <span class="pre">fy</span> <span class="pre">fz]ʙ</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>⌈ fx ⌉      ⌈kx    0    0⌉ ⌈ x ⌉     ⌈dx    0    0⌉ ⌈ ẋ ⌉
| fy | =  − | 0   ky    0| | y |  −  | 0   dy    0| | ẏ |
⌊ fz ⌋      ⌊ 0    0   kz⌋ ⌊ z ⌋     ⌊ 0    0   dz⌋ ⌊ ż ⌋
</pre></div>
</div>
<p>where kx, ky, kz and dx, dy, dz are force stiffness and damping
constants and must have non-negative values.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is a “linear” bushing model as the force 𝐟 varies linearly
with 𝐫 and 𝐫̇̇ as 𝐟 = 𝐟ᴋ + 𝐟ᴅ where 𝐟ᴋ = −Kxyz ⋅ 𝐫 and 𝐟ᴅ = −Dxyz
⋅ 𝐫̇̇.</p>
</div>
<p>This bushing’s constructor sets the torque stiffness/damping constants
<code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> and <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">d₂]</span></code> and the force stiffness/damping
constants <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> and <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code>. The examples below
demonstrate how to model various joints that have a flexible (e.g.,
rubber) mount. The damping values below with ? may be set to 0 or a
reasonable positive number.</p>
<p>Bushing type | torque constants | force constants
——————————–<a href="#id65"><span class="problematic" id="id66">|:--------------------|</span></a>:——————
z-axis revolute joint | k₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">0]</span></code> | kxyz = <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> ^
| d₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">?]</span></code> | dxyz = <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code> x-axis prismatic joint
| k₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> | kxyz = <code class="docutils literal notranslate"><span class="pre">[0</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> ^ | d₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span>
<span class="pre">d₂]</span></code> | dxyz = <code class="docutils literal notranslate"><span class="pre">[?</span> <span class="pre">dy</span> <span class="pre">dz]</span></code> Ball and socket joint | k₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[0</span> <span class="pre">0</span>
<span class="pre">0]</span></code> | kxyz = <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> ^ | d₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[?</span> <span class="pre">?</span> <span class="pre">?]</span></code> | dxyz = <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span>
<span class="pre">dz]</span></code> Weld/fixed joint | k₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> | kxyz = <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code>
^ | d₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">d₂]</span></code> | dxyz = <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code></p>
<p>Angles q₀, q₁, q₂ are calculated from frame C’s orientation relative
to frame A, with <code class="docutils literal notranslate"><span class="pre">[−π</span> <span class="pre">&lt;</span> <span class="pre">q₀</span> <span class="pre">≤</span> <span class="pre">π,</span> <span class="pre">−π/2</span> <span class="pre">≤</span> <span class="pre">q₁</span> <span class="pre">≤</span> <span class="pre">π/2,</span> <span class="pre">−π</span> <span class="pre">&lt;</span> <span class="pre">q₂</span> <span class="pre">≤</span> <span class="pre">π]</span></code>,
hence, there is no angle wrapping and torque stiffness has a limited
range. Gimbal torques τ can be discontinuous if one of q₀, q₁, q₂ is
discontinuous and its associated torque spring constant is nonzero.
For example, τ₂ is discontinuous if <code class="docutils literal notranslate"><span class="pre">k₂</span> <span class="pre">≠</span> <span class="pre">0</span></code> and the bushing has a
large rotation so q₂ jumps from <code class="docutils literal notranslate"><span class="pre">≈</span> <span class="pre">−π</span> <span class="pre">to</span> <span class="pre">π</span></code>. τ can also be
discontinuous if one of q̇₀, q̇₁, q̇₂ is discontinuous and its
associated torque damper constant is nonzero. For example, τ₀ is
discontinuous if <code class="docutils literal notranslate"><span class="pre">d₀</span> <span class="pre">≠</span> <span class="pre">0</span></code> and q̇₀ is undefined (which occurs when
<code class="docutils literal notranslate"><span class="pre">pitch</span> <span class="pre">=</span> <span class="pre">q₁</span> <span class="pre">=</span> <span class="pre">π/2</span></code>). Note: Due to the relationship of 𝐭 to τ shown
below, 𝐭 is discontinuous if τ is discontinuous.</p>
<p>As shown below, there are multiple ways to estimate torque and force
stiffness and damping constants. Use a method or combination of
methods appropriate for your application. For example, some methods
are more useful for a real physical bushing whereas other methods
(called “penalty methods”) can be more useful when replacing an ideal
joint (such as a revolute or fixed/weld joint) with a bushing.</p>
<p>Consider a penalty method if you want a bushing to substitute for a
“hard” constraint (e.g., an ideal joint). Since a bushing is
inherently compliant it will violate a hard constraint somewhat. The
stiffer the bushing, the more accurately it enforces the hard
constraint, but at a cost of more computational time. To balance
accuracy versus time, consider your tolerance for constraint errors.
For example, is it OK for your bushing to displace xₘₐₓ = 1 mm for an
estimated Fxₘₐₓ = 100 N? Also, one way to choose a force damping
constant dx is by choosing a “reasonably small” settling time tₛ,
where settling time tₛ is the interval of time for a system to settle
to within 1% (0.01) of an equilibrium solution). Is tₛ = 0.01 s
negligible for a robot arm with a 10 s reach maneuver?</p>
<p><a href="#id25"><span class="problematic" id="id26">**</span></a>** How to choose a torque stiffness constant k₀ or damping constant
d₀. The estimate of stiffness k₀ depends on whether you are modeling a
physical bushing (consider stiffness methods 1 or 2 below) or whether
you are using a bushing to replace an ideal joint such as a revolute
or fixed/weld joint (consider stiffness “penalty methods” 3 or 4
below). 1. Use a static experiment, e.g., apply a known moment load
Mx, measure the associated angular displacement Δq (radians), and
estimate k₀ = Mx / Δq. 2. Use FEA (finite element analysis) software
to estimate k₀. 3. Pick a desired maximum angular displacement qₘₐₓ,
estimate a maximum moment load Mxₘₐₓ, and estimate <code class="docutils literal notranslate"><span class="pre">k₀</span> <span class="pre">=</span> <span class="pre">Mxₘₐₓ</span> <span class="pre">/</span>
<span class="pre">qₘₐₓ</span></code> (units of N*m/rad). 4. Choose a characteristic moment of
inertia I₀ (directionally dependent), choose a desired angular
frequency ωₙ &gt; 0 (in rad/s) and estimate <code class="docutils literal notranslate"><span class="pre">k₀</span> <span class="pre">=</span> <span class="pre">I₀</span> <span class="pre">ωₙ²</span></code> (units of
N*m/rad).</p>
<p>The estimate of damping d₀ depends on whether you are modeling a
physical bushing (consider damping method 1 below) or whether you are
using a bushing to enforce a constraint (consider damping methods 2 or
3 below). 1. Use experiments to estimate a damping ratio ζ and
settling time tₛ. Compute “undamped natural frequency” ωₙ from ζ and
tₛ (as shown below in the Advanced section), then <code class="docutils literal notranslate"><span class="pre">d₀</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">ζ</span> <span class="pre">k₀</span> <span class="pre">/</span> <span class="pre">ωₙ</span></code>
(units of N*m*s/rad). 2. Choose a damping ratio ζ (e.g., ζ = 1,
critical damping) and a desired settling time tₛ, calculate ωₙ (as
shown below in the Advanced section), then <code class="docutils literal notranslate"><span class="pre">d₀</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">ζ</span> <span class="pre">k₀</span> <span class="pre">/</span> <span class="pre">ωₙ</span></code> (units
of N*m*s/rad). 3. Choose a damping ratio ζ (e.g., ζ = 1, critical
damping), estimate a characteristic moment of inertia and calculate
<code class="docutils literal notranslate"><span class="pre">d₀</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">ζ</span> <span class="pre">√(I₀</span> <span class="pre">k₀)</span></code>.</p>
<p>Refer to Advanced_bushing_stiffness_and_damping “Advanced bushing
stiffness and damping” for more details.</p>
<p><a href="#id27"><span class="problematic" id="id28">**</span></a>** How to choose a force stiffness constant kx or damping constant
dx. The estimate of stiffness kx depends on whether you are modeling a
real bushing (consider stiffness methods 1 or 2 below) or whether you
are using a bushing to replace an ideal joint such as a revolute or
fixed/weld joint (consider stiffness “penalty methods” 3 or 4 below).
1. Use a static experiment, e.g., apply a known force load Fx, measure
the associated displacement (stretch) Δx (in meters), and estimate kx
= Fx / Δx. 2. Use FEA (finite element analysis) software to estimate
kx (units of N/m). 3. Pick a desired maximum displacement xₘₐₓ,
estimate a maximum force load Fxₘₐₓ, and estimate <code class="docutils literal notranslate"><span class="pre">kx</span> <span class="pre">=</span> <span class="pre">Fxₘₐₓ</span> <span class="pre">/</span>
<span class="pre">xₘₐₓ</span></code> (units of N/m). 4. Choose a characteristic mass m (which may be
directionally dependent), choose a desired angular frequency ωₙ &gt; 0
(in rad/s) and estimate <code class="docutils literal notranslate"><span class="pre">kx</span> <span class="pre">=</span> <span class="pre">m</span> <span class="pre">ωₙ²</span></code> (units of N/m).</p>
<p>The estimate of damping dx depends on whether you are modeling a
physical bushing (consider damping method 1 below) or whether you are
using a bushing to enforce a constraint (consider damping methods 2 or
3 below). 1. Use experiments to estimate a damping ratio ζ and
settling time tₛ. Compute “undamped natural frequency” ωₙ from ζ and
tₛ (as shown below in the Advanced section), then <code class="docutils literal notranslate"><span class="pre">dx</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">ζ</span> <span class="pre">kx</span> <span class="pre">/</span> <span class="pre">ωₙ</span></code>
(units of N*s/m). 2. Choose a damping ratio ζ (e.g., ζ = 1, critical
damping) and a desired settling time tₛ, calculate ωₙ (as shown below
in the Advanced section), then <code class="docutils literal notranslate"><span class="pre">dx</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">ζ</span> <span class="pre">kx</span> <span class="pre">/</span> <span class="pre">ωₙ</span></code> (units of N*s/m).
3. Choose a damping ratio ζ (e.g., ζ = 1, critical damping), estimate
a characteristic mass m and calculate <code class="docutils literal notranslate"><span class="pre">dx</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">ζ</span> <span class="pre">√(m</span> <span class="pre">kx)</span></code> (units of
N*s/m).</p>
<p>Refer to Advanced_bushing_stiffness_and_damping “Advanced bushing
stiffness and damping” for more details.</p>
<p><a href="#id29"><span class="problematic" id="id30">**</span></a>** Advanced: Relationship of 𝐭 to τ. To understand how “gimbal
torques” τ relate to 𝐭, it helps to remember that the RollPitchYaw
class documentation states that a Space-fixed (extrinsic) X-Y-Z
rotation with roll-pitch-yaw angles [q₀ q₁ q₂] is equivalent to a
Body-fixed (intrinsic) Z-Y-X rotation by yaw-pitch-roll angles [q₂ q₁
q₀]. In the context of “gimbal torques”, the Body-fixed Z-Y-X rotation
sequence with angles [q₂ q₁ q₀] is physical meaningful as it produces
torques associated with successive frames in a gimbal as τ₂ 𝐀𝐳, τ₁ 𝐏𝐲,
τ₀ 𝐂𝐱, where each of 𝐀𝐳, 𝐏𝐲, 𝐂𝐱 are unit vectors associated with a
frame in the yaw-pitch-roll rotation sequence and 𝐏𝐲 is a unit vector
of the “pitch” intermediate frame. As described earlier, torque 𝐭 is
the moment of the bushing forces on frame C about Cp. Scalars tx, ty,
tz are defined so 𝐭 can be expressed <code class="docutils literal notranslate"><span class="pre">𝐭</span> <span class="pre">=</span> <span class="pre">[tx</span> <span class="pre">ty</span> <span class="pre">tz]ᴀ</span> <span class="pre">=</span> <span class="pre">tx</span> <span class="pre">𝐀𝐱</span> <span class="pre">+</span> <span class="pre">ty</span> <span class="pre">𝐀𝐲</span>
<span class="pre">+</span> <span class="pre">tz</span> <span class="pre">𝐀𝐳</span></code>. As shown in code documentation, the relationship of [tx ty
tz] to [τ₀ τ₁ τ₂] was found by equating 𝐭’s power to τ’s power as 𝐭 ⋅
w_AC = τ ⋅ q̇.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>⌈ tx ⌉      ⌈ τ₀ ⌉            ⌈ cos(q₂)/cos(q₁)  sin(q₂)/cos(q₁)   0 ⌉
| ty | = Nᵀ | τ₁ |  where N = |   −sin(q2)            cos(q2)      0 |
⌊ tz ⌋      ⌊ τ₂ ⌋            ⌊ cos(q₂)*tan(q₁)   sin(q₂)*tan(q₁)  1 ⌋
</pre></div>
</div>
<p><a href="#id31"><span class="problematic" id="id32">**</span></a>** Advanced: More on how to choose bushing stiffness and damping
constants. The basics on how to choose bushing stiffness and damping
constants are at: - Basic_bushing_torque_stiffness_and_damping “How to
choose torque stiffness and damping constants” -
Basic_bushing_force_stiffness_and_damping “How to choose force
stiffness and damping constants”</p>
<p>The list below provides more detail on: The performance tradeoff
between high stiffness and long simulation time; loads that affect
estimates of Mxₘₐₓ or Fxₘₐₓ; and how a linear 2ⁿᵈ-order ODE provides
insight on how to experimentally determine stiffness and damping
constants. - Stiffness [k₀ k₁ k₂] and [kx ky kz] affect simulation
time and accuracy. Generally, a stiffer bushing better resembles an
ideal joint (e.g., a revolute joint or fixed/weld joint). However
(depending on integrator), a stiffer bushing usually increases
numerical integration time. - An estimate for a maximum load Mxₘₐₓ or
Fxₘₐₓ accounts for gravity forces, applied forces, inertia forces
(centripetal, Coriolis, gyroscopic), etc. - One way to determine
physical stiffness and damping constants is through the mathematical
intermediaries ωₙ (units of rad/s) and ζ (no units). The constant ωₙ
(called “undamped natural frequency” or “angular frequency”) and
constant ζ (called “damping ratio”) relate to the physical constants
mass m, damping constant dx, and stiffness constant kx via the
following prototypical linear constant-coefficient 2ⁿᵈ-order ODEs.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>m ẍ +     dx ẋ +  kx x = 0   or alternatively as
   ẍ + 2 ζ ωₙ ẋ + ωₙ² x = 0   where ωₙ² = kx/m,  ζ = dx / (2 √(m kx))
</pre></div>
</div>
<p>ωₙ and ζ also appear in the related ODEs for rotational systems,
namely</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>I₀ q̈ +     d₀ q̇ +  k₀ q = 0   or alternatively as
    q̈ + 2 ζ ωₙ q̇ + ωₙ² q = 0   where ωₙ² = k₀/I₀,  ζ = d₀ / (2 √(I₀ k₀))
</pre></div>
</div>
<p>One way to determine ωₙ is from settling time tₛ which approximates
the time for a system to settle to within a specified settling ratio
of an equilibrium solutions. Typical values for settling ratio are 1%
(0.01), 2% (0.02), 5% (0.05), and 10% (0.10). - When ζ &lt; 0.7
(underdamped), a commonly used approximation is ωₙ ≈
-ln(settling_ratio) / (ζ tₛ) which for settling ratios 0.01 and 0.05
give ωₙ ≈ 4.6 / (ζ tₛ) and ωₙ ≈ 3 / (ζ tₛ). Another commonly used
approximation is ωₙ ≈ -ln(settling_ratio √(1- ζ²)) / (ζ tₛ). See
<a class="reference external" href="https://en.wikipedia.org/wiki/Settling_time">https://en.wikipedia.org/wiki/Settling_time</a> or the book Modern Control
Engineering by Katsuhiko Ogata. Although these approximate formulas
for ωₙ are common, they are somewhat inaccurate. Settling time for
underdamped systems is discontinuous and requires solving a nonlinear
algebraic equation (an iterative process). For more information, see
<a class="reference external" href="http://www.scielo.org.co/pdf/rfiua/n66/n66a09.pdf">http://www.scielo.org.co/pdf/rfiua/n66/n66a09.pdf</a> [Ramos-Paja, et. al
2012], “Accurate calculation of settling time in second order systems:
a photovoltaic application”. Another reference is
<a class="reference external" href="https://courses.grainger.illinois.edu/ece486/sp2020/laboratory/docs/lab2/estimates.html">https://courses.grainger.illinois.edu/ece486/sp2020/laboratory/docs/lab2/estimates.html</a>
- When ζ ≈ 1 (critically damped), ωₙ is determined by choosing a
settling ratio and then solving for (ωₙ tₛ) via the nonlinear
algebraic equation (1 + ωₙ tₛ)*exp(-ωₙ tₛ) = settling_ratio. Settling
ratio | ωₙ ————– | ————- 0.01 | 6.64 / tₛ 0.02 | 5.83
/ tₛ 0.05 | 4.74 / tₛ 0.10 | 3.89 / tₛ See
<a class="reference external" href="https://electronics.stackexchange.com/questions/296567/over-and-critically-damped-systems-settling-time">https://electronics.stackexchange.com/questions/296567/over-and-critically-damped-systems-settling-time</a>
- When ζ ≥ 1.01 (overdamped), ωₙ ≈ -ln(2 settling_ratio sz/s₂) / (s₁
tₛ) where sz = √(ζ² - 1), s₁ = ζ - sz, s₂ = ζ + sz. The derivation and
approximation error estimates for this overdamped settling time
formula is ApproximateOverdampedSettlingTime “below”.</p>
<ul class="simple">
<li>For a real physical bushing, an experiment is one way to estimate damping</li>
</ul>
<p>constants.  For example, to estimate a torque damping constant d₀ associated
with underdamped vibrations (damping ratio 0 &lt; ζ &lt; 1), attach the bushing to
a massive rod, initially displace the rod by angle Δq, release the rod and
measure q(t).  From the q(t) measurement, estimate decay ratio (the ratio of
successive peak heights above the final steady-state value) calculate
logarithmic decrement δ = -ln(decay_ratio), calculate damping ratio
ζ = √(δ² / (4π² + δ²)), then calculate d₀ using d₀ = 2 ζ √(I₀ k₀) or
d₀ = 2 ζ k₀ / ωₙ. For more information, see
<a class="reference external" href="https://en.wikipedia.org/wiki/Damping_ratio#Logarithmic_decrement">https://en.wikipedia.org/wiki/Damping_ratio#Logarithmic_decrement</a></p>
<p><a href="#id33"><span class="problematic" id="id34">**</span></a>** Derivation: Approximate formula for overdamped settling time.
Since a literature reference for this formula was not found, the
derivation below was done at TRI (it has not been peer reviewed). This
formula results from the “dominant pole” solution in the prototypical
constant-coefficient linear 2ⁿᵈ-order ODE. For ẋ(0) = 0, mathematics
shows poles p₁ = -ωₙ s₁, p₂ = -ωₙ s₂, where sz = √(ζ² - 1), s₁ = ζ -
sz, s₂ = ζ + sz. and</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>x(t) / x(0) = p₂/(p₂-p₁) exp(p₁ t) - p₁/(p₂-p₁) exp(p₂ t)
             = s₂/(s₂-s₁) exp(p₁ t) - s₁/(s₂-s₁) exp(p₂ t)
             =  k/( k-1 ) exp(p₁ t) -  1/( k-1 ) exp(p₂ t) where k = s₂ / s₁
             ≈  k/( k-1 ) exp(p₁ t)                        since p₁ &gt; p₂
</pre></div>
</div>
<p>Note: k = s₂ / s₁ is real, k &gt; 0, s₂ = k s₁, and p₁ &gt; p₂ (p₁ is less
negative then p₂), so exp(p₁ t) decays to zero slower than exp(p₂ t)
and exp(p₁ t) ≫ exp(p₂ t) for sufficiently large t. Hence we assume
exp(p₂ t) ≈ 0 (which is why p₁ is called the “dominant pole”). Next,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>k/(k - 1) = s₂ / s₁ / (s₂/s₁ -1) = s₂ / (s₂ - s₁) = s₂ / (2 sz),  so
  x(t) / x(0)  ≈  s₂ / (2 sz) exp(-s₁ ωₙ t),                        hence
  settling_ratio ≈ s₂ / (2 sz) exp(-s₁ ωₙ tₛ),                      finally
  ωₙ ≈ -ln(settling_ratio 2 sz / s₂) / (s₁ tₛ)
</pre></div>
</div>
<p>The table below shows that there is little error in this approximate
formula for various settling ratios and ζ, particularly for ζ ≥ 1.1.
For 1.0 ≤ ζ &lt; 1.1, the critical damping estimates of ωₙ work well.
Settling ratio | ζ = 1.01 | ζ = 1.1 | ζ = 1.2 | ζ = 1.3 | ζ = 1.5
————– | ——– | ——- | ——- | ——- | ——–
0.01 | 1.98% | 0.005% | 2.9E-5% | 1.6E-7% | 2.4E-12% 0.02 | 2.91% |
0.016% | 1.8E-4% | 2.1E-6% | 1.6E-10% 0.05 | 5.10% | 0.076% | 2.3E-3%
| 7.0E-5% | 4.4E-8% 0.10 | 8.28% | 0.258% | 1.6E-2% | 1.0E-3% |
3.3E-6% Note: There is a related derivation in the reference below,
however, it needlessly makes the oversimplified approximation k/(k -
1) ≈ 1.
<a class="reference external" href="https://electronics.stackexchange.com/questions/296567/over-and-critically-damped-systems-settling-time">https://electronics.stackexchange.com/questions/296567/over-and-critically-damped-systems-settling-time</a></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The complete theory for this bushing is documented in the source
code. Please look there if you want more information.</p>
</div>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">T</span></code>:</dt>
<dd>The underlying scalar type. Must be a valid Eigen scalar.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">math::RollPitchYaw for definitions of roll, pitch, yaw <code class="docutils literal notranslate"><span class="pre">[q₀</span> <span class="pre">q₁</span>
<span class="pre">q₂]</span></code>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Per issue #12982, do not directly or indirectly call the following
methods as they have not yet been implemented and throw an
exception: CalcPotentialEnergy(), CalcConservativePower(),
CalcNonConservativePower().</p>
</div>
<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_.LinearBushingRollPitchYaw_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[float], frameA: pydrake.multibody.tree.Frame_[float], frameC: pydrake.multibody.tree.Frame_[float], torque_stiffness_constants: numpy.ndarray[numpy.float64[3, 1]], torque_damping_constants: numpy.ndarray[numpy.float64[3, 1]], force_stiffness_constants: numpy.ndarray[numpy.float64[3, 1]], force_damping_constants: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_.LinearBushingRollPitchYaw_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a LinearBushingRollPitchYaw B that connects frames A and C,
where frame A is welded to a link L0 and frame C is welded to a link
L1.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameA</span></code>:</dt>
<dd>frame A of link (body) L0 that connects to bushing B.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameC</span></code>:</dt>
<dd>frame C of link (body) L1 that connects to bushing B.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">torque_stiffness_constants</span></code>:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> multiply the roll-pitch-yaw angles <code class="docutils literal notranslate"><span class="pre">[q₀</span> <span class="pre">q₁</span> <span class="pre">q₂]</span></code>
to produce the spring portion of the “gimbal” torques τ₀, τ₁, τ₂.
The SI units of <code class="docutils literal notranslate"><span class="pre">k₀,</span> <span class="pre">k₁,</span> <span class="pre">k₂</span></code> are N*m/rad.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">torque_damping_constants</span></code>:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">d₂]</span></code> multiply the roll-pitch-yaw rates <code class="docutils literal notranslate"><span class="pre">[q̇₀</span> <span class="pre">q̇₁</span> <span class="pre">q̇₂]</span></code>
to produce the damper portion of the “gimbal” torques τ₀, τ₁, τ₂.
The SI units of <code class="docutils literal notranslate"><span class="pre">d₀,</span> <span class="pre">d₁,</span> <span class="pre">d₂</span></code> are N*m*s/rad.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">force_stiffness_constants</span></code>:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> multiply the bushing displacements <code class="docutils literal notranslate"><span class="pre">[x</span> <span class="pre">y</span> <span class="pre">z]</span></code> to
form 𝐟ᴋ, the spring portion of the force 𝐟 = [fx fy fz]ʙ. The SI
units of <code class="docutils literal notranslate"><span class="pre">kx,</span> <span class="pre">ky,</span> <span class="pre">kz</span></code> are N/m.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">force_damping_constants</span></code>:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code> multiply the bushing displacement rates <code class="docutils literal notranslate"><span class="pre">[ẋ</span> <span class="pre">ẏ</span>
<span class="pre">ż]</span></code> to form 𝐟ᴅ, the damper portion of the force 𝐟 = [fx fy fz]ʙ.
The SI units of <code class="docutils literal notranslate"><span class="pre">dx,</span> <span class="pre">dy,</span> <span class="pre">dz</span></code> are N*s/m.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The LinearBushingRollPitchYaw class documentation describes the
stiffness and damping constants.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The net moment on C about Co is affected by both the gimbal torque
and the moment of 𝐟 about Co. Similarly, for the net moment on A
about Ao.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">math::RollPitchYaw describes the roll pitch yaw angles q₀, q₁, q₂.
The position from Ao to Co is p_AoCo_B = x 𝐁𝐱 + y 𝐁𝐲 + z 𝐁𝐳 = [x y
z]ʙ.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The ModelInstanceIndex assigned to this by the constructor is the
one assigned to frame C, i.e., frameC.model_instance().</p>
</div>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>All the stiffness and damping constants must be non-negative.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_.LinearBushingRollPitchYaw_[float].CalcBushingSpatialForceOnFrameA">
<code class="descname">CalcBushingSpatialForceOnFrameA</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[float]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_.LinearBushingRollPitchYaw_[float].CalcBushingSpatialForceOnFrameA" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate F_A_A, the bushing’s spatial force on frame A expressed in
A. F_A_A contains two vectors: the moment of all bushing forces on A
about Ao (−𝐭 + p_AoAp × −𝐟) and the net bushing force on A (−𝐟
expressed in A).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The state of the multibody system.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcBushingSpatialForceOnFrameC().</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if pitch angle is near gimbal-lock. For more info,</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RollPitchYaw::DoesCosPitchAngleViolateGimbalLockTolerance().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_.LinearBushingRollPitchYaw_[float].CalcBushingSpatialForceOnFrameC">
<code class="descname">CalcBushingSpatialForceOnFrameC</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[float]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_.LinearBushingRollPitchYaw_[float].CalcBushingSpatialForceOnFrameC" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate F_C_C, the bushing’s spatial force on frame C expressed in
C. F_C_C contains two vectors: the moment of all bushing forces on C
about Co (𝐭 + p_CoCp × 𝐟) and the resultant bushing force on C (𝐟
expressed in C).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The state of the multibody system.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcBushingSpatialForceOnFrameA().</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if pitch angle is near gimbal-lock. For more info,</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RollPitchYaw::DoesCosPitchAngleViolateGimbalLockTolerance().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_.LinearBushingRollPitchYaw_[float].force_damping_constants">
<code class="descname">force_damping_constants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_.LinearBushingRollPitchYaw_[float].force_damping_constants" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default force damping constants <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code> (units of
N*s/m). Refer to Basic_bushing_force_stiffness_and_damping “How to
choose force stiffness and damping constants” for more details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_.LinearBushingRollPitchYaw_[float].force_stiffness_constants">
<code class="descname">force_stiffness_constants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_.LinearBushingRollPitchYaw_[float].force_stiffness_constants" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default force stiffness constants <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> (units of
N/m). Refer to Basic_bushing_force_stiffness_and_damping “How to
choose force stiffness and damping constants” for more details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_.LinearBushingRollPitchYaw_[float].frameA">
<code class="descname">frameA</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Frame_[float]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_.LinearBushingRollPitchYaw_[float].frameA" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns frame A, which is the frame that is welded to link (body) L0
and attached to the bushing.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_.LinearBushingRollPitchYaw_[float].frameC">
<code class="descname">frameC</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Frame_[float]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_.LinearBushingRollPitchYaw_[float].frameC" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns frame C, which is the frame that is welded to link (body) L1
and attached to the bushing.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_.LinearBushingRollPitchYaw_[float].GetForceDampingConstants">
<code class="descname">GetForceDampingConstants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_.LinearBushingRollPitchYaw_[float].GetForceDampingConstants" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the force damping constants <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code> (units of N*s/m)
stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_.LinearBushingRollPitchYaw_[float].GetForceStiffnessConstants">
<code class="descname">GetForceStiffnessConstants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_.LinearBushingRollPitchYaw_[float].GetForceStiffnessConstants" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the force stiffness constants <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> (units of N/m)
stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_.LinearBushingRollPitchYaw_[float].GetTorqueDampingConstants">
<code class="descname">GetTorqueDampingConstants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_.LinearBushingRollPitchYaw_[float].GetTorqueDampingConstants" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the torque damping constants <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">d₂]</span></code> (units of
N*m*s/rad) stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_.LinearBushingRollPitchYaw_[float].GetTorqueStiffnessConstants">
<code class="descname">GetTorqueStiffnessConstants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_.LinearBushingRollPitchYaw_[float].GetTorqueStiffnessConstants" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the torque stiffness constants <code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> (units of
N*m/rad) stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_.LinearBushingRollPitchYaw_[float].link0">
<code class="descname">link0</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[float]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_.LinearBushingRollPitchYaw_[float].link0" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns link (body) L0 (frame A is welded to link L0).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_.LinearBushingRollPitchYaw_[float].link1">
<code class="descname">link1</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[float]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_.LinearBushingRollPitchYaw_[float].link1" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns link (body) L1 (frame C is welded to link L1).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_.LinearBushingRollPitchYaw_[float].SetForceDampingConstants">
<code class="descname">SetForceDampingConstants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[float], context: pydrake.systems.framework.Context_[float], force_damping: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_.LinearBushingRollPitchYaw_[float].SetForceDampingConstants" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the force damping constants <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code> (units of N*s/m) in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_.LinearBushingRollPitchYaw_[float].SetForceStiffnessConstants">
<code class="descname">SetForceStiffnessConstants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[float], context: pydrake.systems.framework.Context_[float], force_stiffness: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_.LinearBushingRollPitchYaw_[float].SetForceStiffnessConstants" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the force stiffness constants <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> (units of N/m) in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_.LinearBushingRollPitchYaw_[float].SetTorqueDampingConstants">
<code class="descname">SetTorqueDampingConstants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[float], context: pydrake.systems.framework.Context_[float], torque_damping: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_.LinearBushingRollPitchYaw_[float].SetTorqueDampingConstants" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the torque damping constants <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">d₂]</span></code> (units of N*m*s/rad)
in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_.LinearBushingRollPitchYaw_[float].SetTorqueStiffnessConstants">
<code class="descname">SetTorqueStiffnessConstants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[float], context: pydrake.systems.framework.Context_[float], torque_stiffness: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_.LinearBushingRollPitchYaw_[float].SetTorqueStiffnessConstants" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the torque stiffness constants <code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> (units of N*m/rad)
in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_.LinearBushingRollPitchYaw_[float].torque_damping_constants">
<code class="descname">torque_damping_constants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_.LinearBushingRollPitchYaw_[float].torque_damping_constants" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default torque damping constants <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">d₂]</span></code> (units of
N*m*s/rad). Refer to Basic_bushing_torque_stiffness_and_damping “How
to choose torque stiffness and damping constants” for more details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_.LinearBushingRollPitchYaw_[float].torque_stiffness_constants">
<code class="descname">torque_stiffness_constants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_.LinearBushingRollPitchYaw_[float].torque_stiffness_constants" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default torque stiffness constants <code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> (units
of N*m/rad). Refer to Basic_bushing_torque_stiffness_and_damping “How
to choose torque stiffness and damping constants” for more details.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">LinearBushingRollPitchYaw_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[AutoDiffXd]" title="pydrake.multibody.tree.ForceElement_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ForceElement_[AutoDiffXd]</span></code></a></p>
<p>This ForceElement models a massless flexible bushing that connects a
frame A of a link (body) L0 to a frame C of a link (body) L1. The
bushing can apply a torque and force due to stiffness (spring) and
dissipation (damper) properties. Frame B is the bushing frame whose
origin Bo is halfway between Ao (A’s origin) and Co (C’s origin) and
whose unit vectors 𝐁𝐱, 𝐁𝐲, 𝐁𝐳 are “halfway” (in an angle-axis sense)
between the unit vectors of frame A and frame C. Frame B is a
“floating” frame in the sense that it is calculated from the position
and orientation of frames A and C (B is not welded to the bushing).</p>
<p>&#64;image html drake/multibody/tree/images/LinearBushingRollPitchYaw.png
width=80%</p>
<p>The set of forces on frame C from the bushing is equivalent to a
torque 𝐭 on frame C and a force 𝐟 applied to a point Cp of C. The set
of forces on frame A from the bushing is equivalent to a torque −𝐭 on
frame A and a force −𝐟 applied to a point Ap of A. Points Ap and Cp
are coincident with Bo (frame B’s origin).</p>
<p>This “quasi-symmetric” bushing force/torque model was developed at
Toyota Research Institute and has advantages compared to traditional
bushing models because it employs a bushing-centered “symmetric” frame
B and it ensures the moment of −𝐟 on A about Ao is equal to the moment
of 𝐟 on C about Co. Traditional models differ as they lack a
“symmetric” frame B and apply −𝐟 at Ao, which means the moment of −𝐟
on A about Ao is always zero. Note: This bushing model is not fully
symmetric since the orientation between frames A and C is
parameterized with roll-pitch-yaw angles [q₀ q₁ q₂]. Since these
angles have an inherent sequence, they are not mathematically
symmetric.</p>
<p>The torque model depends on spring-damper “gimbal” torques <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">≜</span> <span class="pre">[τ₀</span>
<span class="pre">τ₁</span> <span class="pre">τ₂]</span></code> which themselves depend on roll-pitch-yaw angles <code class="docutils literal notranslate"><span class="pre">q</span> <span class="pre">≜</span> <span class="pre">[q₀</span> <span class="pre">q₁</span>
<span class="pre">q₂]</span></code> and rates <code class="docutils literal notranslate"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">[q̇₀</span> <span class="pre">q̇₁</span> <span class="pre">q̇₂]</span></code> via a diagonal torque-stiffness
matrix K₀₁₂ and a diagonal torque-damping matrix D₀₁₂ as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>⌈ τ₀ ⌉     ⌈k₀    0    0⌉ ⌈ q₀ ⌉     ⌈d₀    0    0⌉ ⌈ q̇₀ ⌉
τ ≜ | τ₁ | = − | 0   k₁    0| | q₁ |  −  | 0   d₁    0| | q̇₁ |
    ⌊ τ₂ ⌋     ⌊ 0    0   k₂⌋ ⌊ q₂ ⌋     ⌊ 0    0   d₂⌋ ⌊ q̇₂ ⌋
</pre></div>
</div>
<p>where k₀, k₁, k₂ and d₀, d₁, d₂ are torque stiffness and damping
constants and must have non-negative values.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">τ does not represent a vector expressed in one frame. Instead it
is regarded as a 3x1 array of torque scalars associated with
roll-pitch yaw.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As discussed in the Advanced section below, τ is not 𝐭 <code class="docutils literal notranslate"><span class="pre">(τ</span> <span class="pre">≠</span>
<span class="pre">𝐭)</span></code>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is a “linear” bushing model as gimbal torque τ varies
linearly with q and q̇ as τ = τᴋ + τᴅ where τᴋ = −K₀₁₂ ⋅ q and τᴅ
= −D₀₁₂ ⋅ q̇.</p>
</div>
<p>The bushing model for the net force 𝐟 on frame C from the bushing
depends on scalars x, y, z which are defined so 𝐫 (the position vector
from Ao to Co) can be expressed in frame B as <code class="docutils literal notranslate"><span class="pre">𝐫</span> <span class="pre">≜</span> <span class="pre">p_AoCo</span> <span class="pre">=</span> <span class="pre">[x</span> <span class="pre">y</span> <span class="pre">z]ʙ</span>
<span class="pre">=</span> <span class="pre">x</span> <span class="pre">𝐁𝐱</span> <span class="pre">+</span> <span class="pre">y</span> <span class="pre">𝐁𝐲</span> <span class="pre">+</span> <span class="pre">z</span> <span class="pre">𝐁𝐳</span></code>. The model for 𝐟 uses a diagonal
force-stiffness matrix Kxyᴢ, a diagonal force-damping matrix Dxyᴢ, and
defines fx, fy, fz so <code class="docutils literal notranslate"><span class="pre">𝐟</span> <span class="pre">=</span> <span class="pre">[fx</span> <span class="pre">fy</span> <span class="pre">fz]ʙ</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>⌈ fx ⌉      ⌈kx    0    0⌉ ⌈ x ⌉     ⌈dx    0    0⌉ ⌈ ẋ ⌉
| fy | =  − | 0   ky    0| | y |  −  | 0   dy    0| | ẏ |
⌊ fz ⌋      ⌊ 0    0   kz⌋ ⌊ z ⌋     ⌊ 0    0   dz⌋ ⌊ ż ⌋
</pre></div>
</div>
<p>where kx, ky, kz and dx, dy, dz are force stiffness and damping
constants and must have non-negative values.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is a “linear” bushing model as the force 𝐟 varies linearly
with 𝐫 and 𝐫̇̇ as 𝐟 = 𝐟ᴋ + 𝐟ᴅ where 𝐟ᴋ = −Kxyz ⋅ 𝐫 and 𝐟ᴅ = −Dxyz
⋅ 𝐫̇̇.</p>
</div>
<p>This bushing’s constructor sets the torque stiffness/damping constants
<code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> and <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">d₂]</span></code> and the force stiffness/damping
constants <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> and <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code>. The examples below
demonstrate how to model various joints that have a flexible (e.g.,
rubber) mount. The damping values below with ? may be set to 0 or a
reasonable positive number.</p>
<p>Bushing type | torque constants | force constants
——————————–<a href="#id67"><span class="problematic" id="id68">|:--------------------|</span></a>:——————
z-axis revolute joint | k₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">0]</span></code> | kxyz = <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> ^
| d₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">?]</span></code> | dxyz = <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code> x-axis prismatic joint
| k₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> | kxyz = <code class="docutils literal notranslate"><span class="pre">[0</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> ^ | d₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span>
<span class="pre">d₂]</span></code> | dxyz = <code class="docutils literal notranslate"><span class="pre">[?</span> <span class="pre">dy</span> <span class="pre">dz]</span></code> Ball and socket joint | k₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[0</span> <span class="pre">0</span>
<span class="pre">0]</span></code> | kxyz = <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> ^ | d₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[?</span> <span class="pre">?</span> <span class="pre">?]</span></code> | dxyz = <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span>
<span class="pre">dz]</span></code> Weld/fixed joint | k₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> | kxyz = <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code>
^ | d₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">d₂]</span></code> | dxyz = <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code></p>
<p>Angles q₀, q₁, q₂ are calculated from frame C’s orientation relative
to frame A, with <code class="docutils literal notranslate"><span class="pre">[−π</span> <span class="pre">&lt;</span> <span class="pre">q₀</span> <span class="pre">≤</span> <span class="pre">π,</span> <span class="pre">−π/2</span> <span class="pre">≤</span> <span class="pre">q₁</span> <span class="pre">≤</span> <span class="pre">π/2,</span> <span class="pre">−π</span> <span class="pre">&lt;</span> <span class="pre">q₂</span> <span class="pre">≤</span> <span class="pre">π]</span></code>,
hence, there is no angle wrapping and torque stiffness has a limited
range. Gimbal torques τ can be discontinuous if one of q₀, q₁, q₂ is
discontinuous and its associated torque spring constant is nonzero.
For example, τ₂ is discontinuous if <code class="docutils literal notranslate"><span class="pre">k₂</span> <span class="pre">≠</span> <span class="pre">0</span></code> and the bushing has a
large rotation so q₂ jumps from <code class="docutils literal notranslate"><span class="pre">≈</span> <span class="pre">−π</span> <span class="pre">to</span> <span class="pre">π</span></code>. τ can also be
discontinuous if one of q̇₀, q̇₁, q̇₂ is discontinuous and its
associated torque damper constant is nonzero. For example, τ₀ is
discontinuous if <code class="docutils literal notranslate"><span class="pre">d₀</span> <span class="pre">≠</span> <span class="pre">0</span></code> and q̇₀ is undefined (which occurs when
<code class="docutils literal notranslate"><span class="pre">pitch</span> <span class="pre">=</span> <span class="pre">q₁</span> <span class="pre">=</span> <span class="pre">π/2</span></code>). Note: Due to the relationship of 𝐭 to τ shown
below, 𝐭 is discontinuous if τ is discontinuous.</p>
<p>As shown below, there are multiple ways to estimate torque and force
stiffness and damping constants. Use a method or combination of
methods appropriate for your application. For example, some methods
are more useful for a real physical bushing whereas other methods
(called “penalty methods”) can be more useful when replacing an ideal
joint (such as a revolute or fixed/weld joint) with a bushing.</p>
<p>Consider a penalty method if you want a bushing to substitute for a
“hard” constraint (e.g., an ideal joint). Since a bushing is
inherently compliant it will violate a hard constraint somewhat. The
stiffer the bushing, the more accurately it enforces the hard
constraint, but at a cost of more computational time. To balance
accuracy versus time, consider your tolerance for constraint errors.
For example, is it OK for your bushing to displace xₘₐₓ = 1 mm for an
estimated Fxₘₐₓ = 100 N? Also, one way to choose a force damping
constant dx is by choosing a “reasonably small” settling time tₛ,
where settling time tₛ is the interval of time for a system to settle
to within 1% (0.01) of an equilibrium solution). Is tₛ = 0.01 s
negligible for a robot arm with a 10 s reach maneuver?</p>
<p><a href="#id35"><span class="problematic" id="id36">**</span></a>** How to choose a torque stiffness constant k₀ or damping constant
d₀. The estimate of stiffness k₀ depends on whether you are modeling a
physical bushing (consider stiffness methods 1 or 2 below) or whether
you are using a bushing to replace an ideal joint such as a revolute
or fixed/weld joint (consider stiffness “penalty methods” 3 or 4
below). 1. Use a static experiment, e.g., apply a known moment load
Mx, measure the associated angular displacement Δq (radians), and
estimate k₀ = Mx / Δq. 2. Use FEA (finite element analysis) software
to estimate k₀. 3. Pick a desired maximum angular displacement qₘₐₓ,
estimate a maximum moment load Mxₘₐₓ, and estimate <code class="docutils literal notranslate"><span class="pre">k₀</span> <span class="pre">=</span> <span class="pre">Mxₘₐₓ</span> <span class="pre">/</span>
<span class="pre">qₘₐₓ</span></code> (units of N*m/rad). 4. Choose a characteristic moment of
inertia I₀ (directionally dependent), choose a desired angular
frequency ωₙ &gt; 0 (in rad/s) and estimate <code class="docutils literal notranslate"><span class="pre">k₀</span> <span class="pre">=</span> <span class="pre">I₀</span> <span class="pre">ωₙ²</span></code> (units of
N*m/rad).</p>
<p>The estimate of damping d₀ depends on whether you are modeling a
physical bushing (consider damping method 1 below) or whether you are
using a bushing to enforce a constraint (consider damping methods 2 or
3 below). 1. Use experiments to estimate a damping ratio ζ and
settling time tₛ. Compute “undamped natural frequency” ωₙ from ζ and
tₛ (as shown below in the Advanced section), then <code class="docutils literal notranslate"><span class="pre">d₀</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">ζ</span> <span class="pre">k₀</span> <span class="pre">/</span> <span class="pre">ωₙ</span></code>
(units of N*m*s/rad). 2. Choose a damping ratio ζ (e.g., ζ = 1,
critical damping) and a desired settling time tₛ, calculate ωₙ (as
shown below in the Advanced section), then <code class="docutils literal notranslate"><span class="pre">d₀</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">ζ</span> <span class="pre">k₀</span> <span class="pre">/</span> <span class="pre">ωₙ</span></code> (units
of N*m*s/rad). 3. Choose a damping ratio ζ (e.g., ζ = 1, critical
damping), estimate a characteristic moment of inertia and calculate
<code class="docutils literal notranslate"><span class="pre">d₀</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">ζ</span> <span class="pre">√(I₀</span> <span class="pre">k₀)</span></code>.</p>
<p>Refer to Advanced_bushing_stiffness_and_damping “Advanced bushing
stiffness and damping” for more details.</p>
<p><a href="#id37"><span class="problematic" id="id38">**</span></a>** How to choose a force stiffness constant kx or damping constant
dx. The estimate of stiffness kx depends on whether you are modeling a
real bushing (consider stiffness methods 1 or 2 below) or whether you
are using a bushing to replace an ideal joint such as a revolute or
fixed/weld joint (consider stiffness “penalty methods” 3 or 4 below).
1. Use a static experiment, e.g., apply a known force load Fx, measure
the associated displacement (stretch) Δx (in meters), and estimate kx
= Fx / Δx. 2. Use FEA (finite element analysis) software to estimate
kx (units of N/m). 3. Pick a desired maximum displacement xₘₐₓ,
estimate a maximum force load Fxₘₐₓ, and estimate <code class="docutils literal notranslate"><span class="pre">kx</span> <span class="pre">=</span> <span class="pre">Fxₘₐₓ</span> <span class="pre">/</span>
<span class="pre">xₘₐₓ</span></code> (units of N/m). 4. Choose a characteristic mass m (which may be
directionally dependent), choose a desired angular frequency ωₙ &gt; 0
(in rad/s) and estimate <code class="docutils literal notranslate"><span class="pre">kx</span> <span class="pre">=</span> <span class="pre">m</span> <span class="pre">ωₙ²</span></code> (units of N/m).</p>
<p>The estimate of damping dx depends on whether you are modeling a
physical bushing (consider damping method 1 below) or whether you are
using a bushing to enforce a constraint (consider damping methods 2 or
3 below). 1. Use experiments to estimate a damping ratio ζ and
settling time tₛ. Compute “undamped natural frequency” ωₙ from ζ and
tₛ (as shown below in the Advanced section), then <code class="docutils literal notranslate"><span class="pre">dx</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">ζ</span> <span class="pre">kx</span> <span class="pre">/</span> <span class="pre">ωₙ</span></code>
(units of N*s/m). 2. Choose a damping ratio ζ (e.g., ζ = 1, critical
damping) and a desired settling time tₛ, calculate ωₙ (as shown below
in the Advanced section), then <code class="docutils literal notranslate"><span class="pre">dx</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">ζ</span> <span class="pre">kx</span> <span class="pre">/</span> <span class="pre">ωₙ</span></code> (units of N*s/m).
3. Choose a damping ratio ζ (e.g., ζ = 1, critical damping), estimate
a characteristic mass m and calculate <code class="docutils literal notranslate"><span class="pre">dx</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">ζ</span> <span class="pre">√(m</span> <span class="pre">kx)</span></code> (units of
N*s/m).</p>
<p>Refer to Advanced_bushing_stiffness_and_damping “Advanced bushing
stiffness and damping” for more details.</p>
<p><a href="#id39"><span class="problematic" id="id40">**</span></a>** Advanced: Relationship of 𝐭 to τ. To understand how “gimbal
torques” τ relate to 𝐭, it helps to remember that the RollPitchYaw
class documentation states that a Space-fixed (extrinsic) X-Y-Z
rotation with roll-pitch-yaw angles [q₀ q₁ q₂] is equivalent to a
Body-fixed (intrinsic) Z-Y-X rotation by yaw-pitch-roll angles [q₂ q₁
q₀]. In the context of “gimbal torques”, the Body-fixed Z-Y-X rotation
sequence with angles [q₂ q₁ q₀] is physical meaningful as it produces
torques associated with successive frames in a gimbal as τ₂ 𝐀𝐳, τ₁ 𝐏𝐲,
τ₀ 𝐂𝐱, where each of 𝐀𝐳, 𝐏𝐲, 𝐂𝐱 are unit vectors associated with a
frame in the yaw-pitch-roll rotation sequence and 𝐏𝐲 is a unit vector
of the “pitch” intermediate frame. As described earlier, torque 𝐭 is
the moment of the bushing forces on frame C about Cp. Scalars tx, ty,
tz are defined so 𝐭 can be expressed <code class="docutils literal notranslate"><span class="pre">𝐭</span> <span class="pre">=</span> <span class="pre">[tx</span> <span class="pre">ty</span> <span class="pre">tz]ᴀ</span> <span class="pre">=</span> <span class="pre">tx</span> <span class="pre">𝐀𝐱</span> <span class="pre">+</span> <span class="pre">ty</span> <span class="pre">𝐀𝐲</span>
<span class="pre">+</span> <span class="pre">tz</span> <span class="pre">𝐀𝐳</span></code>. As shown in code documentation, the relationship of [tx ty
tz] to [τ₀ τ₁ τ₂] was found by equating 𝐭’s power to τ’s power as 𝐭 ⋅
w_AC = τ ⋅ q̇.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>⌈ tx ⌉      ⌈ τ₀ ⌉            ⌈ cos(q₂)/cos(q₁)  sin(q₂)/cos(q₁)   0 ⌉
| ty | = Nᵀ | τ₁ |  where N = |   −sin(q2)            cos(q2)      0 |
⌊ tz ⌋      ⌊ τ₂ ⌋            ⌊ cos(q₂)*tan(q₁)   sin(q₂)*tan(q₁)  1 ⌋
</pre></div>
</div>
<p><a href="#id41"><span class="problematic" id="id42">**</span></a>** Advanced: More on how to choose bushing stiffness and damping
constants. The basics on how to choose bushing stiffness and damping
constants are at: - Basic_bushing_torque_stiffness_and_damping “How to
choose torque stiffness and damping constants” -
Basic_bushing_force_stiffness_and_damping “How to choose force
stiffness and damping constants”</p>
<p>The list below provides more detail on: The performance tradeoff
between high stiffness and long simulation time; loads that affect
estimates of Mxₘₐₓ or Fxₘₐₓ; and how a linear 2ⁿᵈ-order ODE provides
insight on how to experimentally determine stiffness and damping
constants. - Stiffness [k₀ k₁ k₂] and [kx ky kz] affect simulation
time and accuracy. Generally, a stiffer bushing better resembles an
ideal joint (e.g., a revolute joint or fixed/weld joint). However
(depending on integrator), a stiffer bushing usually increases
numerical integration time. - An estimate for a maximum load Mxₘₐₓ or
Fxₘₐₓ accounts for gravity forces, applied forces, inertia forces
(centripetal, Coriolis, gyroscopic), etc. - One way to determine
physical stiffness and damping constants is through the mathematical
intermediaries ωₙ (units of rad/s) and ζ (no units). The constant ωₙ
(called “undamped natural frequency” or “angular frequency”) and
constant ζ (called “damping ratio”) relate to the physical constants
mass m, damping constant dx, and stiffness constant kx via the
following prototypical linear constant-coefficient 2ⁿᵈ-order ODEs.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>m ẍ +     dx ẋ +  kx x = 0   or alternatively as
   ẍ + 2 ζ ωₙ ẋ + ωₙ² x = 0   where ωₙ² = kx/m,  ζ = dx / (2 √(m kx))
</pre></div>
</div>
<p>ωₙ and ζ also appear in the related ODEs for rotational systems,
namely</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>I₀ q̈ +     d₀ q̇ +  k₀ q = 0   or alternatively as
    q̈ + 2 ζ ωₙ q̇ + ωₙ² q = 0   where ωₙ² = k₀/I₀,  ζ = d₀ / (2 √(I₀ k₀))
</pre></div>
</div>
<p>One way to determine ωₙ is from settling time tₛ which approximates
the time for a system to settle to within a specified settling ratio
of an equilibrium solutions. Typical values for settling ratio are 1%
(0.01), 2% (0.02), 5% (0.05), and 10% (0.10). - When ζ &lt; 0.7
(underdamped), a commonly used approximation is ωₙ ≈
-ln(settling_ratio) / (ζ tₛ) which for settling ratios 0.01 and 0.05
give ωₙ ≈ 4.6 / (ζ tₛ) and ωₙ ≈ 3 / (ζ tₛ). Another commonly used
approximation is ωₙ ≈ -ln(settling_ratio √(1- ζ²)) / (ζ tₛ). See
<a class="reference external" href="https://en.wikipedia.org/wiki/Settling_time">https://en.wikipedia.org/wiki/Settling_time</a> or the book Modern Control
Engineering by Katsuhiko Ogata. Although these approximate formulas
for ωₙ are common, they are somewhat inaccurate. Settling time for
underdamped systems is discontinuous and requires solving a nonlinear
algebraic equation (an iterative process). For more information, see
<a class="reference external" href="http://www.scielo.org.co/pdf/rfiua/n66/n66a09.pdf">http://www.scielo.org.co/pdf/rfiua/n66/n66a09.pdf</a> [Ramos-Paja, et. al
2012], “Accurate calculation of settling time in second order systems:
a photovoltaic application”. Another reference is
<a class="reference external" href="https://courses.grainger.illinois.edu/ece486/sp2020/laboratory/docs/lab2/estimates.html">https://courses.grainger.illinois.edu/ece486/sp2020/laboratory/docs/lab2/estimates.html</a>
- When ζ ≈ 1 (critically damped), ωₙ is determined by choosing a
settling ratio and then solving for (ωₙ tₛ) via the nonlinear
algebraic equation (1 + ωₙ tₛ)*exp(-ωₙ tₛ) = settling_ratio. Settling
ratio | ωₙ ————– | ————- 0.01 | 6.64 / tₛ 0.02 | 5.83
/ tₛ 0.05 | 4.74 / tₛ 0.10 | 3.89 / tₛ See
<a class="reference external" href="https://electronics.stackexchange.com/questions/296567/over-and-critically-damped-systems-settling-time">https://electronics.stackexchange.com/questions/296567/over-and-critically-damped-systems-settling-time</a>
- When ζ ≥ 1.01 (overdamped), ωₙ ≈ -ln(2 settling_ratio sz/s₂) / (s₁
tₛ) where sz = √(ζ² - 1), s₁ = ζ - sz, s₂ = ζ + sz. The derivation and
approximation error estimates for this overdamped settling time
formula is ApproximateOverdampedSettlingTime “below”.</p>
<ul class="simple">
<li>For a real physical bushing, an experiment is one way to estimate damping</li>
</ul>
<p>constants.  For example, to estimate a torque damping constant d₀ associated
with underdamped vibrations (damping ratio 0 &lt; ζ &lt; 1), attach the bushing to
a massive rod, initially displace the rod by angle Δq, release the rod and
measure q(t).  From the q(t) measurement, estimate decay ratio (the ratio of
successive peak heights above the final steady-state value) calculate
logarithmic decrement δ = -ln(decay_ratio), calculate damping ratio
ζ = √(δ² / (4π² + δ²)), then calculate d₀ using d₀ = 2 ζ √(I₀ k₀) or
d₀ = 2 ζ k₀ / ωₙ. For more information, see
<a class="reference external" href="https://en.wikipedia.org/wiki/Damping_ratio#Logarithmic_decrement">https://en.wikipedia.org/wiki/Damping_ratio#Logarithmic_decrement</a></p>
<p><a href="#id43"><span class="problematic" id="id44">**</span></a>** Derivation: Approximate formula for overdamped settling time.
Since a literature reference for this formula was not found, the
derivation below was done at TRI (it has not been peer reviewed). This
formula results from the “dominant pole” solution in the prototypical
constant-coefficient linear 2ⁿᵈ-order ODE. For ẋ(0) = 0, mathematics
shows poles p₁ = -ωₙ s₁, p₂ = -ωₙ s₂, where sz = √(ζ² - 1), s₁ = ζ -
sz, s₂ = ζ + sz. and</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>x(t) / x(0) = p₂/(p₂-p₁) exp(p₁ t) - p₁/(p₂-p₁) exp(p₂ t)
             = s₂/(s₂-s₁) exp(p₁ t) - s₁/(s₂-s₁) exp(p₂ t)
             =  k/( k-1 ) exp(p₁ t) -  1/( k-1 ) exp(p₂ t) where k = s₂ / s₁
             ≈  k/( k-1 ) exp(p₁ t)                        since p₁ &gt; p₂
</pre></div>
</div>
<p>Note: k = s₂ / s₁ is real, k &gt; 0, s₂ = k s₁, and p₁ &gt; p₂ (p₁ is less
negative then p₂), so exp(p₁ t) decays to zero slower than exp(p₂ t)
and exp(p₁ t) ≫ exp(p₂ t) for sufficiently large t. Hence we assume
exp(p₂ t) ≈ 0 (which is why p₁ is called the “dominant pole”). Next,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>k/(k - 1) = s₂ / s₁ / (s₂/s₁ -1) = s₂ / (s₂ - s₁) = s₂ / (2 sz),  so
  x(t) / x(0)  ≈  s₂ / (2 sz) exp(-s₁ ωₙ t),                        hence
  settling_ratio ≈ s₂ / (2 sz) exp(-s₁ ωₙ tₛ),                      finally
  ωₙ ≈ -ln(settling_ratio 2 sz / s₂) / (s₁ tₛ)
</pre></div>
</div>
<p>The table below shows that there is little error in this approximate
formula for various settling ratios and ζ, particularly for ζ ≥ 1.1.
For 1.0 ≤ ζ &lt; 1.1, the critical damping estimates of ωₙ work well.
Settling ratio | ζ = 1.01 | ζ = 1.1 | ζ = 1.2 | ζ = 1.3 | ζ = 1.5
————– | ——– | ——- | ——- | ——- | ——–
0.01 | 1.98% | 0.005% | 2.9E-5% | 1.6E-7% | 2.4E-12% 0.02 | 2.91% |
0.016% | 1.8E-4% | 2.1E-6% | 1.6E-10% 0.05 | 5.10% | 0.076% | 2.3E-3%
| 7.0E-5% | 4.4E-8% 0.10 | 8.28% | 0.258% | 1.6E-2% | 1.0E-3% |
3.3E-6% Note: There is a related derivation in the reference below,
however, it needlessly makes the oversimplified approximation k/(k -
1) ≈ 1.
<a class="reference external" href="https://electronics.stackexchange.com/questions/296567/over-and-critically-damped-systems-settling-time">https://electronics.stackexchange.com/questions/296567/over-and-critically-damped-systems-settling-time</a></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The complete theory for this bushing is documented in the source
code. Please look there if you want more information.</p>
</div>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">T</span></code>:</dt>
<dd>The underlying scalar type. Must be a valid Eigen scalar.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">math::RollPitchYaw for definitions of roll, pitch, yaw <code class="docutils literal notranslate"><span class="pre">[q₀</span> <span class="pre">q₁</span>
<span class="pre">q₂]</span></code>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Per issue #12982, do not directly or indirectly call the following
methods as they have not yet been implemented and throw an
exception: CalcPotentialEnergy(), CalcConservativePower(),
CalcNonConservativePower().</p>
</div>
<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd], frameA: pydrake.multibody.tree.Frame_[AutoDiffXd], frameC: pydrake.multibody.tree.Frame_[AutoDiffXd], torque_stiffness_constants: numpy.ndarray[numpy.float64[3, 1]], torque_damping_constants: numpy.ndarray[numpy.float64[3, 1]], force_stiffness_constants: numpy.ndarray[numpy.float64[3, 1]], force_damping_constants: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a LinearBushingRollPitchYaw B that connects frames A and C,
where frame A is welded to a link L0 and frame C is welded to a link
L1.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameA</span></code>:</dt>
<dd>frame A of link (body) L0 that connects to bushing B.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameC</span></code>:</dt>
<dd>frame C of link (body) L1 that connects to bushing B.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">torque_stiffness_constants</span></code>:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> multiply the roll-pitch-yaw angles <code class="docutils literal notranslate"><span class="pre">[q₀</span> <span class="pre">q₁</span> <span class="pre">q₂]</span></code>
to produce the spring portion of the “gimbal” torques τ₀, τ₁, τ₂.
The SI units of <code class="docutils literal notranslate"><span class="pre">k₀,</span> <span class="pre">k₁,</span> <span class="pre">k₂</span></code> are N*m/rad.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">torque_damping_constants</span></code>:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">d₂]</span></code> multiply the roll-pitch-yaw rates <code class="docutils literal notranslate"><span class="pre">[q̇₀</span> <span class="pre">q̇₁</span> <span class="pre">q̇₂]</span></code>
to produce the damper portion of the “gimbal” torques τ₀, τ₁, τ₂.
The SI units of <code class="docutils literal notranslate"><span class="pre">d₀,</span> <span class="pre">d₁,</span> <span class="pre">d₂</span></code> are N*m*s/rad.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">force_stiffness_constants</span></code>:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> multiply the bushing displacements <code class="docutils literal notranslate"><span class="pre">[x</span> <span class="pre">y</span> <span class="pre">z]</span></code> to
form 𝐟ᴋ, the spring portion of the force 𝐟 = [fx fy fz]ʙ. The SI
units of <code class="docutils literal notranslate"><span class="pre">kx,</span> <span class="pre">ky,</span> <span class="pre">kz</span></code> are N/m.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">force_damping_constants</span></code>:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code> multiply the bushing displacement rates <code class="docutils literal notranslate"><span class="pre">[ẋ</span> <span class="pre">ẏ</span>
<span class="pre">ż]</span></code> to form 𝐟ᴅ, the damper portion of the force 𝐟 = [fx fy fz]ʙ.
The SI units of <code class="docutils literal notranslate"><span class="pre">dx,</span> <span class="pre">dy,</span> <span class="pre">dz</span></code> are N*s/m.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The LinearBushingRollPitchYaw class documentation describes the
stiffness and damping constants.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The net moment on C about Co is affected by both the gimbal torque
and the moment of 𝐟 about Co. Similarly, for the net moment on A
about Ao.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">math::RollPitchYaw describes the roll pitch yaw angles q₀, q₁, q₂.
The position from Ao to Co is p_AoCo_B = x 𝐁𝐱 + y 𝐁𝐲 + z 𝐁𝐳 = [x y
z]ʙ.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The ModelInstanceIndex assigned to this by the constructor is the
one assigned to frame C, i.e., frameC.model_instance().</p>
</div>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>All the stiffness and damping constants must be non-negative.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd].CalcBushingSpatialForceOnFrameA">
<code class="descname">CalcBushingSpatialForceOnFrameA</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd].CalcBushingSpatialForceOnFrameA" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate F_A_A, the bushing’s spatial force on frame A expressed in
A. F_A_A contains two vectors: the moment of all bushing forces on A
about Ao (−𝐭 + p_AoAp × −𝐟) and the net bushing force on A (−𝐟
expressed in A).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The state of the multibody system.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcBushingSpatialForceOnFrameC().</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if pitch angle is near gimbal-lock. For more info,</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RollPitchYaw::DoesCosPitchAngleViolateGimbalLockTolerance().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd].CalcBushingSpatialForceOnFrameC">
<code class="descname">CalcBushingSpatialForceOnFrameC</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd].CalcBushingSpatialForceOnFrameC" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate F_C_C, the bushing’s spatial force on frame C expressed in
C. F_C_C contains two vectors: the moment of all bushing forces on C
about Co (𝐭 + p_CoCp × 𝐟) and the resultant bushing force on C (𝐟
expressed in C).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The state of the multibody system.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcBushingSpatialForceOnFrameA().</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if pitch angle is near gimbal-lock. For more info,</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RollPitchYaw::DoesCosPitchAngleViolateGimbalLockTolerance().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd].force_damping_constants">
<code class="descname">force_damping_constants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd].force_damping_constants" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default force damping constants <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code> (units of
N*s/m). Refer to Basic_bushing_force_stiffness_and_damping “How to
choose force stiffness and damping constants” for more details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd].force_stiffness_constants">
<code class="descname">force_stiffness_constants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd].force_stiffness_constants" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default force stiffness constants <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> (units of
N/m). Refer to Basic_bushing_force_stiffness_and_damping “How to
choose force stiffness and damping constants” for more details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd].frameA">
<code class="descname">frameA</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Frame_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd].frameA" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns frame A, which is the frame that is welded to link (body) L0
and attached to the bushing.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd].frameC">
<code class="descname">frameC</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Frame_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd].frameC" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns frame C, which is the frame that is welded to link (body) L1
and attached to the bushing.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd].GetForceDampingConstants">
<code class="descname">GetForceDampingConstants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd].GetForceDampingConstants" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the force damping constants <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code> (units of N*s/m)
stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd].GetForceStiffnessConstants">
<code class="descname">GetForceStiffnessConstants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd].GetForceStiffnessConstants" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the force stiffness constants <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> (units of N/m)
stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd].GetTorqueDampingConstants">
<code class="descname">GetTorqueDampingConstants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd].GetTorqueDampingConstants" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the torque damping constants <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">d₂]</span></code> (units of
N*m*s/rad) stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd].GetTorqueStiffnessConstants">
<code class="descname">GetTorqueStiffnessConstants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd].GetTorqueStiffnessConstants" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the torque stiffness constants <code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> (units of
N*m/rad) stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd].link0">
<code class="descname">link0</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd].link0" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns link (body) L0 (frame A is welded to link L0).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd].link1">
<code class="descname">link1</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd].link1" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns link (body) L1 (frame C is welded to link L1).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd].SetForceDampingConstants">
<code class="descname">SetForceDampingConstants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], force_damping: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd].SetForceDampingConstants" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the force damping constants <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code> (units of N*s/m) in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd].SetForceStiffnessConstants">
<code class="descname">SetForceStiffnessConstants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], force_stiffness: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd].SetForceStiffnessConstants" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the force stiffness constants <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> (units of N/m) in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd].SetTorqueDampingConstants">
<code class="descname">SetTorqueDampingConstants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], torque_damping: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd].SetTorqueDampingConstants" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the torque damping constants <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">d₂]</span></code> (units of N*m*s/rad)
in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd].SetTorqueStiffnessConstants">
<code class="descname">SetTorqueStiffnessConstants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], torque_stiffness: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd].SetTorqueStiffnessConstants" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the torque stiffness constants <code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> (units of N*m/rad)
in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd].torque_damping_constants">
<code class="descname">torque_damping_constants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd].torque_damping_constants" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default torque damping constants <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">d₂]</span></code> (units of
N*m*s/rad). Refer to Basic_bushing_torque_stiffness_and_damping “How
to choose torque stiffness and damping constants” for more details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd].torque_stiffness_constants">
<code class="descname">torque_stiffness_constants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[AutoDiffXd].torque_stiffness_constants" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default torque stiffness constants <code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> (units
of N*m/rad). Refer to Basic_bushing_torque_stiffness_and_damping “How
to choose torque stiffness and damping constants” for more details.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">LinearBushingRollPitchYaw_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[Expression]" title="pydrake.multibody.tree.ForceElement_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ForceElement_[Expression]</span></code></a></p>
<p>This ForceElement models a massless flexible bushing that connects a
frame A of a link (body) L0 to a frame C of a link (body) L1. The
bushing can apply a torque and force due to stiffness (spring) and
dissipation (damper) properties. Frame B is the bushing frame whose
origin Bo is halfway between Ao (A’s origin) and Co (C’s origin) and
whose unit vectors 𝐁𝐱, 𝐁𝐲, 𝐁𝐳 are “halfway” (in an angle-axis sense)
between the unit vectors of frame A and frame C. Frame B is a
“floating” frame in the sense that it is calculated from the position
and orientation of frames A and C (B is not welded to the bushing).</p>
<p>&#64;image html drake/multibody/tree/images/LinearBushingRollPitchYaw.png
width=80%</p>
<p>The set of forces on frame C from the bushing is equivalent to a
torque 𝐭 on frame C and a force 𝐟 applied to a point Cp of C. The set
of forces on frame A from the bushing is equivalent to a torque −𝐭 on
frame A and a force −𝐟 applied to a point Ap of A. Points Ap and Cp
are coincident with Bo (frame B’s origin).</p>
<p>This “quasi-symmetric” bushing force/torque model was developed at
Toyota Research Institute and has advantages compared to traditional
bushing models because it employs a bushing-centered “symmetric” frame
B and it ensures the moment of −𝐟 on A about Ao is equal to the moment
of 𝐟 on C about Co. Traditional models differ as they lack a
“symmetric” frame B and apply −𝐟 at Ao, which means the moment of −𝐟
on A about Ao is always zero. Note: This bushing model is not fully
symmetric since the orientation between frames A and C is
parameterized with roll-pitch-yaw angles [q₀ q₁ q₂]. Since these
angles have an inherent sequence, they are not mathematically
symmetric.</p>
<p>The torque model depends on spring-damper “gimbal” torques <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">≜</span> <span class="pre">[τ₀</span>
<span class="pre">τ₁</span> <span class="pre">τ₂]</span></code> which themselves depend on roll-pitch-yaw angles <code class="docutils literal notranslate"><span class="pre">q</span> <span class="pre">≜</span> <span class="pre">[q₀</span> <span class="pre">q₁</span>
<span class="pre">q₂]</span></code> and rates <code class="docutils literal notranslate"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">[q̇₀</span> <span class="pre">q̇₁</span> <span class="pre">q̇₂]</span></code> via a diagonal torque-stiffness
matrix K₀₁₂ and a diagonal torque-damping matrix D₀₁₂ as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>⌈ τ₀ ⌉     ⌈k₀    0    0⌉ ⌈ q₀ ⌉     ⌈d₀    0    0⌉ ⌈ q̇₀ ⌉
τ ≜ | τ₁ | = − | 0   k₁    0| | q₁ |  −  | 0   d₁    0| | q̇₁ |
    ⌊ τ₂ ⌋     ⌊ 0    0   k₂⌋ ⌊ q₂ ⌋     ⌊ 0    0   d₂⌋ ⌊ q̇₂ ⌋
</pre></div>
</div>
<p>where k₀, k₁, k₂ and d₀, d₁, d₂ are torque stiffness and damping
constants and must have non-negative values.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">τ does not represent a vector expressed in one frame. Instead it
is regarded as a 3x1 array of torque scalars associated with
roll-pitch yaw.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As discussed in the Advanced section below, τ is not 𝐭 <code class="docutils literal notranslate"><span class="pre">(τ</span> <span class="pre">≠</span>
<span class="pre">𝐭)</span></code>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is a “linear” bushing model as gimbal torque τ varies
linearly with q and q̇ as τ = τᴋ + τᴅ where τᴋ = −K₀₁₂ ⋅ q and τᴅ
= −D₀₁₂ ⋅ q̇.</p>
</div>
<p>The bushing model for the net force 𝐟 on frame C from the bushing
depends on scalars x, y, z which are defined so 𝐫 (the position vector
from Ao to Co) can be expressed in frame B as <code class="docutils literal notranslate"><span class="pre">𝐫</span> <span class="pre">≜</span> <span class="pre">p_AoCo</span> <span class="pre">=</span> <span class="pre">[x</span> <span class="pre">y</span> <span class="pre">z]ʙ</span>
<span class="pre">=</span> <span class="pre">x</span> <span class="pre">𝐁𝐱</span> <span class="pre">+</span> <span class="pre">y</span> <span class="pre">𝐁𝐲</span> <span class="pre">+</span> <span class="pre">z</span> <span class="pre">𝐁𝐳</span></code>. The model for 𝐟 uses a diagonal
force-stiffness matrix Kxyᴢ, a diagonal force-damping matrix Dxyᴢ, and
defines fx, fy, fz so <code class="docutils literal notranslate"><span class="pre">𝐟</span> <span class="pre">=</span> <span class="pre">[fx</span> <span class="pre">fy</span> <span class="pre">fz]ʙ</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>⌈ fx ⌉      ⌈kx    0    0⌉ ⌈ x ⌉     ⌈dx    0    0⌉ ⌈ ẋ ⌉
| fy | =  − | 0   ky    0| | y |  −  | 0   dy    0| | ẏ |
⌊ fz ⌋      ⌊ 0    0   kz⌋ ⌊ z ⌋     ⌊ 0    0   dz⌋ ⌊ ż ⌋
</pre></div>
</div>
<p>where kx, ky, kz and dx, dy, dz are force stiffness and damping
constants and must have non-negative values.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is a “linear” bushing model as the force 𝐟 varies linearly
with 𝐫 and 𝐫̇̇ as 𝐟 = 𝐟ᴋ + 𝐟ᴅ where 𝐟ᴋ = −Kxyz ⋅ 𝐫 and 𝐟ᴅ = −Dxyz
⋅ 𝐫̇̇.</p>
</div>
<p>This bushing’s constructor sets the torque stiffness/damping constants
<code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> and <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">d₂]</span></code> and the force stiffness/damping
constants <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> and <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code>. The examples below
demonstrate how to model various joints that have a flexible (e.g.,
rubber) mount. The damping values below with ? may be set to 0 or a
reasonable positive number.</p>
<p>Bushing type | torque constants | force constants
——————————–<a href="#id69"><span class="problematic" id="id70">|:--------------------|</span></a>:——————
z-axis revolute joint | k₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">0]</span></code> | kxyz = <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> ^
| d₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">?]</span></code> | dxyz = <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code> x-axis prismatic joint
| k₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> | kxyz = <code class="docutils literal notranslate"><span class="pre">[0</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> ^ | d₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span>
<span class="pre">d₂]</span></code> | dxyz = <code class="docutils literal notranslate"><span class="pre">[?</span> <span class="pre">dy</span> <span class="pre">dz]</span></code> Ball and socket joint | k₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[0</span> <span class="pre">0</span>
<span class="pre">0]</span></code> | kxyz = <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> ^ | d₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[?</span> <span class="pre">?</span> <span class="pre">?]</span></code> | dxyz = <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span>
<span class="pre">dz]</span></code> Weld/fixed joint | k₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> | kxyz = <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code>
^ | d₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">d₂]</span></code> | dxyz = <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code></p>
<p>Angles q₀, q₁, q₂ are calculated from frame C’s orientation relative
to frame A, with <code class="docutils literal notranslate"><span class="pre">[−π</span> <span class="pre">&lt;</span> <span class="pre">q₀</span> <span class="pre">≤</span> <span class="pre">π,</span> <span class="pre">−π/2</span> <span class="pre">≤</span> <span class="pre">q₁</span> <span class="pre">≤</span> <span class="pre">π/2,</span> <span class="pre">−π</span> <span class="pre">&lt;</span> <span class="pre">q₂</span> <span class="pre">≤</span> <span class="pre">π]</span></code>,
hence, there is no angle wrapping and torque stiffness has a limited
range. Gimbal torques τ can be discontinuous if one of q₀, q₁, q₂ is
discontinuous and its associated torque spring constant is nonzero.
For example, τ₂ is discontinuous if <code class="docutils literal notranslate"><span class="pre">k₂</span> <span class="pre">≠</span> <span class="pre">0</span></code> and the bushing has a
large rotation so q₂ jumps from <code class="docutils literal notranslate"><span class="pre">≈</span> <span class="pre">−π</span> <span class="pre">to</span> <span class="pre">π</span></code>. τ can also be
discontinuous if one of q̇₀, q̇₁, q̇₂ is discontinuous and its
associated torque damper constant is nonzero. For example, τ₀ is
discontinuous if <code class="docutils literal notranslate"><span class="pre">d₀</span> <span class="pre">≠</span> <span class="pre">0</span></code> and q̇₀ is undefined (which occurs when
<code class="docutils literal notranslate"><span class="pre">pitch</span> <span class="pre">=</span> <span class="pre">q₁</span> <span class="pre">=</span> <span class="pre">π/2</span></code>). Note: Due to the relationship of 𝐭 to τ shown
below, 𝐭 is discontinuous if τ is discontinuous.</p>
<p>As shown below, there are multiple ways to estimate torque and force
stiffness and damping constants. Use a method or combination of
methods appropriate for your application. For example, some methods
are more useful for a real physical bushing whereas other methods
(called “penalty methods”) can be more useful when replacing an ideal
joint (such as a revolute or fixed/weld joint) with a bushing.</p>
<p>Consider a penalty method if you want a bushing to substitute for a
“hard” constraint (e.g., an ideal joint). Since a bushing is
inherently compliant it will violate a hard constraint somewhat. The
stiffer the bushing, the more accurately it enforces the hard
constraint, but at a cost of more computational time. To balance
accuracy versus time, consider your tolerance for constraint errors.
For example, is it OK for your bushing to displace xₘₐₓ = 1 mm for an
estimated Fxₘₐₓ = 100 N? Also, one way to choose a force damping
constant dx is by choosing a “reasonably small” settling time tₛ,
where settling time tₛ is the interval of time for a system to settle
to within 1% (0.01) of an equilibrium solution). Is tₛ = 0.01 s
negligible for a robot arm with a 10 s reach maneuver?</p>
<p><a href="#id45"><span class="problematic" id="id46">**</span></a>** How to choose a torque stiffness constant k₀ or damping constant
d₀. The estimate of stiffness k₀ depends on whether you are modeling a
physical bushing (consider stiffness methods 1 or 2 below) or whether
you are using a bushing to replace an ideal joint such as a revolute
or fixed/weld joint (consider stiffness “penalty methods” 3 or 4
below). 1. Use a static experiment, e.g., apply a known moment load
Mx, measure the associated angular displacement Δq (radians), and
estimate k₀ = Mx / Δq. 2. Use FEA (finite element analysis) software
to estimate k₀. 3. Pick a desired maximum angular displacement qₘₐₓ,
estimate a maximum moment load Mxₘₐₓ, and estimate <code class="docutils literal notranslate"><span class="pre">k₀</span> <span class="pre">=</span> <span class="pre">Mxₘₐₓ</span> <span class="pre">/</span>
<span class="pre">qₘₐₓ</span></code> (units of N*m/rad). 4. Choose a characteristic moment of
inertia I₀ (directionally dependent), choose a desired angular
frequency ωₙ &gt; 0 (in rad/s) and estimate <code class="docutils literal notranslate"><span class="pre">k₀</span> <span class="pre">=</span> <span class="pre">I₀</span> <span class="pre">ωₙ²</span></code> (units of
N*m/rad).</p>
<p>The estimate of damping d₀ depends on whether you are modeling a
physical bushing (consider damping method 1 below) or whether you are
using a bushing to enforce a constraint (consider damping methods 2 or
3 below). 1. Use experiments to estimate a damping ratio ζ and
settling time tₛ. Compute “undamped natural frequency” ωₙ from ζ and
tₛ (as shown below in the Advanced section), then <code class="docutils literal notranslate"><span class="pre">d₀</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">ζ</span> <span class="pre">k₀</span> <span class="pre">/</span> <span class="pre">ωₙ</span></code>
(units of N*m*s/rad). 2. Choose a damping ratio ζ (e.g., ζ = 1,
critical damping) and a desired settling time tₛ, calculate ωₙ (as
shown below in the Advanced section), then <code class="docutils literal notranslate"><span class="pre">d₀</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">ζ</span> <span class="pre">k₀</span> <span class="pre">/</span> <span class="pre">ωₙ</span></code> (units
of N*m*s/rad). 3. Choose a damping ratio ζ (e.g., ζ = 1, critical
damping), estimate a characteristic moment of inertia and calculate
<code class="docutils literal notranslate"><span class="pre">d₀</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">ζ</span> <span class="pre">√(I₀</span> <span class="pre">k₀)</span></code>.</p>
<p>Refer to Advanced_bushing_stiffness_and_damping “Advanced bushing
stiffness and damping” for more details.</p>
<p><a href="#id47"><span class="problematic" id="id48">**</span></a>** How to choose a force stiffness constant kx or damping constant
dx. The estimate of stiffness kx depends on whether you are modeling a
real bushing (consider stiffness methods 1 or 2 below) or whether you
are using a bushing to replace an ideal joint such as a revolute or
fixed/weld joint (consider stiffness “penalty methods” 3 or 4 below).
1. Use a static experiment, e.g., apply a known force load Fx, measure
the associated displacement (stretch) Δx (in meters), and estimate kx
= Fx / Δx. 2. Use FEA (finite element analysis) software to estimate
kx (units of N/m). 3. Pick a desired maximum displacement xₘₐₓ,
estimate a maximum force load Fxₘₐₓ, and estimate <code class="docutils literal notranslate"><span class="pre">kx</span> <span class="pre">=</span> <span class="pre">Fxₘₐₓ</span> <span class="pre">/</span>
<span class="pre">xₘₐₓ</span></code> (units of N/m). 4. Choose a characteristic mass m (which may be
directionally dependent), choose a desired angular frequency ωₙ &gt; 0
(in rad/s) and estimate <code class="docutils literal notranslate"><span class="pre">kx</span> <span class="pre">=</span> <span class="pre">m</span> <span class="pre">ωₙ²</span></code> (units of N/m).</p>
<p>The estimate of damping dx depends on whether you are modeling a
physical bushing (consider damping method 1 below) or whether you are
using a bushing to enforce a constraint (consider damping methods 2 or
3 below). 1. Use experiments to estimate a damping ratio ζ and
settling time tₛ. Compute “undamped natural frequency” ωₙ from ζ and
tₛ (as shown below in the Advanced section), then <code class="docutils literal notranslate"><span class="pre">dx</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">ζ</span> <span class="pre">kx</span> <span class="pre">/</span> <span class="pre">ωₙ</span></code>
(units of N*s/m). 2. Choose a damping ratio ζ (e.g., ζ = 1, critical
damping) and a desired settling time tₛ, calculate ωₙ (as shown below
in the Advanced section), then <code class="docutils literal notranslate"><span class="pre">dx</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">ζ</span> <span class="pre">kx</span> <span class="pre">/</span> <span class="pre">ωₙ</span></code> (units of N*s/m).
3. Choose a damping ratio ζ (e.g., ζ = 1, critical damping), estimate
a characteristic mass m and calculate <code class="docutils literal notranslate"><span class="pre">dx</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">ζ</span> <span class="pre">√(m</span> <span class="pre">kx)</span></code> (units of
N*s/m).</p>
<p>Refer to Advanced_bushing_stiffness_and_damping “Advanced bushing
stiffness and damping” for more details.</p>
<p><a href="#id49"><span class="problematic" id="id50">**</span></a>** Advanced: Relationship of 𝐭 to τ. To understand how “gimbal
torques” τ relate to 𝐭, it helps to remember that the RollPitchYaw
class documentation states that a Space-fixed (extrinsic) X-Y-Z
rotation with roll-pitch-yaw angles [q₀ q₁ q₂] is equivalent to a
Body-fixed (intrinsic) Z-Y-X rotation by yaw-pitch-roll angles [q₂ q₁
q₀]. In the context of “gimbal torques”, the Body-fixed Z-Y-X rotation
sequence with angles [q₂ q₁ q₀] is physical meaningful as it produces
torques associated with successive frames in a gimbal as τ₂ 𝐀𝐳, τ₁ 𝐏𝐲,
τ₀ 𝐂𝐱, where each of 𝐀𝐳, 𝐏𝐲, 𝐂𝐱 are unit vectors associated with a
frame in the yaw-pitch-roll rotation sequence and 𝐏𝐲 is a unit vector
of the “pitch” intermediate frame. As described earlier, torque 𝐭 is
the moment of the bushing forces on frame C about Cp. Scalars tx, ty,
tz are defined so 𝐭 can be expressed <code class="docutils literal notranslate"><span class="pre">𝐭</span> <span class="pre">=</span> <span class="pre">[tx</span> <span class="pre">ty</span> <span class="pre">tz]ᴀ</span> <span class="pre">=</span> <span class="pre">tx</span> <span class="pre">𝐀𝐱</span> <span class="pre">+</span> <span class="pre">ty</span> <span class="pre">𝐀𝐲</span>
<span class="pre">+</span> <span class="pre">tz</span> <span class="pre">𝐀𝐳</span></code>. As shown in code documentation, the relationship of [tx ty
tz] to [τ₀ τ₁ τ₂] was found by equating 𝐭’s power to τ’s power as 𝐭 ⋅
w_AC = τ ⋅ q̇.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>⌈ tx ⌉      ⌈ τ₀ ⌉            ⌈ cos(q₂)/cos(q₁)  sin(q₂)/cos(q₁)   0 ⌉
| ty | = Nᵀ | τ₁ |  where N = |   −sin(q2)            cos(q2)      0 |
⌊ tz ⌋      ⌊ τ₂ ⌋            ⌊ cos(q₂)*tan(q₁)   sin(q₂)*tan(q₁)  1 ⌋
</pre></div>
</div>
<p><a href="#id51"><span class="problematic" id="id52">**</span></a>** Advanced: More on how to choose bushing stiffness and damping
constants. The basics on how to choose bushing stiffness and damping
constants are at: - Basic_bushing_torque_stiffness_and_damping “How to
choose torque stiffness and damping constants” -
Basic_bushing_force_stiffness_and_damping “How to choose force
stiffness and damping constants”</p>
<p>The list below provides more detail on: The performance tradeoff
between high stiffness and long simulation time; loads that affect
estimates of Mxₘₐₓ or Fxₘₐₓ; and how a linear 2ⁿᵈ-order ODE provides
insight on how to experimentally determine stiffness and damping
constants. - Stiffness [k₀ k₁ k₂] and [kx ky kz] affect simulation
time and accuracy. Generally, a stiffer bushing better resembles an
ideal joint (e.g., a revolute joint or fixed/weld joint). However
(depending on integrator), a stiffer bushing usually increases
numerical integration time. - An estimate for a maximum load Mxₘₐₓ or
Fxₘₐₓ accounts for gravity forces, applied forces, inertia forces
(centripetal, Coriolis, gyroscopic), etc. - One way to determine
physical stiffness and damping constants is through the mathematical
intermediaries ωₙ (units of rad/s) and ζ (no units). The constant ωₙ
(called “undamped natural frequency” or “angular frequency”) and
constant ζ (called “damping ratio”) relate to the physical constants
mass m, damping constant dx, and stiffness constant kx via the
following prototypical linear constant-coefficient 2ⁿᵈ-order ODEs.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>m ẍ +     dx ẋ +  kx x = 0   or alternatively as
   ẍ + 2 ζ ωₙ ẋ + ωₙ² x = 0   where ωₙ² = kx/m,  ζ = dx / (2 √(m kx))
</pre></div>
</div>
<p>ωₙ and ζ also appear in the related ODEs for rotational systems,
namely</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>I₀ q̈ +     d₀ q̇ +  k₀ q = 0   or alternatively as
    q̈ + 2 ζ ωₙ q̇ + ωₙ² q = 0   where ωₙ² = k₀/I₀,  ζ = d₀ / (2 √(I₀ k₀))
</pre></div>
</div>
<p>One way to determine ωₙ is from settling time tₛ which approximates
the time for a system to settle to within a specified settling ratio
of an equilibrium solutions. Typical values for settling ratio are 1%
(0.01), 2% (0.02), 5% (0.05), and 10% (0.10). - When ζ &lt; 0.7
(underdamped), a commonly used approximation is ωₙ ≈
-ln(settling_ratio) / (ζ tₛ) which for settling ratios 0.01 and 0.05
give ωₙ ≈ 4.6 / (ζ tₛ) and ωₙ ≈ 3 / (ζ tₛ). Another commonly used
approximation is ωₙ ≈ -ln(settling_ratio √(1- ζ²)) / (ζ tₛ). See
<a class="reference external" href="https://en.wikipedia.org/wiki/Settling_time">https://en.wikipedia.org/wiki/Settling_time</a> or the book Modern Control
Engineering by Katsuhiko Ogata. Although these approximate formulas
for ωₙ are common, they are somewhat inaccurate. Settling time for
underdamped systems is discontinuous and requires solving a nonlinear
algebraic equation (an iterative process). For more information, see
<a class="reference external" href="http://www.scielo.org.co/pdf/rfiua/n66/n66a09.pdf">http://www.scielo.org.co/pdf/rfiua/n66/n66a09.pdf</a> [Ramos-Paja, et. al
2012], “Accurate calculation of settling time in second order systems:
a photovoltaic application”. Another reference is
<a class="reference external" href="https://courses.grainger.illinois.edu/ece486/sp2020/laboratory/docs/lab2/estimates.html">https://courses.grainger.illinois.edu/ece486/sp2020/laboratory/docs/lab2/estimates.html</a>
- When ζ ≈ 1 (critically damped), ωₙ is determined by choosing a
settling ratio and then solving for (ωₙ tₛ) via the nonlinear
algebraic equation (1 + ωₙ tₛ)*exp(-ωₙ tₛ) = settling_ratio. Settling
ratio | ωₙ ————– | ————- 0.01 | 6.64 / tₛ 0.02 | 5.83
/ tₛ 0.05 | 4.74 / tₛ 0.10 | 3.89 / tₛ See
<a class="reference external" href="https://electronics.stackexchange.com/questions/296567/over-and-critically-damped-systems-settling-time">https://electronics.stackexchange.com/questions/296567/over-and-critically-damped-systems-settling-time</a>
- When ζ ≥ 1.01 (overdamped), ωₙ ≈ -ln(2 settling_ratio sz/s₂) / (s₁
tₛ) where sz = √(ζ² - 1), s₁ = ζ - sz, s₂ = ζ + sz. The derivation and
approximation error estimates for this overdamped settling time
formula is ApproximateOverdampedSettlingTime “below”.</p>
<ul class="simple">
<li>For a real physical bushing, an experiment is one way to estimate damping</li>
</ul>
<p>constants.  For example, to estimate a torque damping constant d₀ associated
with underdamped vibrations (damping ratio 0 &lt; ζ &lt; 1), attach the bushing to
a massive rod, initially displace the rod by angle Δq, release the rod and
measure q(t).  From the q(t) measurement, estimate decay ratio (the ratio of
successive peak heights above the final steady-state value) calculate
logarithmic decrement δ = -ln(decay_ratio), calculate damping ratio
ζ = √(δ² / (4π² + δ²)), then calculate d₀ using d₀ = 2 ζ √(I₀ k₀) or
d₀ = 2 ζ k₀ / ωₙ. For more information, see
<a class="reference external" href="https://en.wikipedia.org/wiki/Damping_ratio#Logarithmic_decrement">https://en.wikipedia.org/wiki/Damping_ratio#Logarithmic_decrement</a></p>
<p><a href="#id53"><span class="problematic" id="id54">**</span></a>** Derivation: Approximate formula for overdamped settling time.
Since a literature reference for this formula was not found, the
derivation below was done at TRI (it has not been peer reviewed). This
formula results from the “dominant pole” solution in the prototypical
constant-coefficient linear 2ⁿᵈ-order ODE. For ẋ(0) = 0, mathematics
shows poles p₁ = -ωₙ s₁, p₂ = -ωₙ s₂, where sz = √(ζ² - 1), s₁ = ζ -
sz, s₂ = ζ + sz. and</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>x(t) / x(0) = p₂/(p₂-p₁) exp(p₁ t) - p₁/(p₂-p₁) exp(p₂ t)
             = s₂/(s₂-s₁) exp(p₁ t) - s₁/(s₂-s₁) exp(p₂ t)
             =  k/( k-1 ) exp(p₁ t) -  1/( k-1 ) exp(p₂ t) where k = s₂ / s₁
             ≈  k/( k-1 ) exp(p₁ t)                        since p₁ &gt; p₂
</pre></div>
</div>
<p>Note: k = s₂ / s₁ is real, k &gt; 0, s₂ = k s₁, and p₁ &gt; p₂ (p₁ is less
negative then p₂), so exp(p₁ t) decays to zero slower than exp(p₂ t)
and exp(p₁ t) ≫ exp(p₂ t) for sufficiently large t. Hence we assume
exp(p₂ t) ≈ 0 (which is why p₁ is called the “dominant pole”). Next,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>k/(k - 1) = s₂ / s₁ / (s₂/s₁ -1) = s₂ / (s₂ - s₁) = s₂ / (2 sz),  so
  x(t) / x(0)  ≈  s₂ / (2 sz) exp(-s₁ ωₙ t),                        hence
  settling_ratio ≈ s₂ / (2 sz) exp(-s₁ ωₙ tₛ),                      finally
  ωₙ ≈ -ln(settling_ratio 2 sz / s₂) / (s₁ tₛ)
</pre></div>
</div>
<p>The table below shows that there is little error in this approximate
formula for various settling ratios and ζ, particularly for ζ ≥ 1.1.
For 1.0 ≤ ζ &lt; 1.1, the critical damping estimates of ωₙ work well.
Settling ratio | ζ = 1.01 | ζ = 1.1 | ζ = 1.2 | ζ = 1.3 | ζ = 1.5
————– | ——– | ——- | ——- | ——- | ——–
0.01 | 1.98% | 0.005% | 2.9E-5% | 1.6E-7% | 2.4E-12% 0.02 | 2.91% |
0.016% | 1.8E-4% | 2.1E-6% | 1.6E-10% 0.05 | 5.10% | 0.076% | 2.3E-3%
| 7.0E-5% | 4.4E-8% 0.10 | 8.28% | 0.258% | 1.6E-2% | 1.0E-3% |
3.3E-6% Note: There is a related derivation in the reference below,
however, it needlessly makes the oversimplified approximation k/(k -
1) ≈ 1.
<a class="reference external" href="https://electronics.stackexchange.com/questions/296567/over-and-critically-damped-systems-settling-time">https://electronics.stackexchange.com/questions/296567/over-and-critically-damped-systems-settling-time</a></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The complete theory for this bushing is documented in the source
code. Please look there if you want more information.</p>
</div>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">T</span></code>:</dt>
<dd>The underlying scalar type. Must be a valid Eigen scalar.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">math::RollPitchYaw for definitions of roll, pitch, yaw <code class="docutils literal notranslate"><span class="pre">[q₀</span> <span class="pre">q₁</span>
<span class="pre">q₂]</span></code>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Per issue #12982, do not directly or indirectly call the following
methods as they have not yet been implemented and throw an
exception: CalcPotentialEnergy(), CalcConservativePower(),
CalcNonConservativePower().</p>
</div>
<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression], frameA: pydrake.multibody.tree.Frame_[Expression], frameC: pydrake.multibody.tree.Frame_[Expression], torque_stiffness_constants: numpy.ndarray[numpy.float64[3, 1]], torque_damping_constants: numpy.ndarray[numpy.float64[3, 1]], force_stiffness_constants: numpy.ndarray[numpy.float64[3, 1]], force_damping_constants: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a LinearBushingRollPitchYaw B that connects frames A and C,
where frame A is welded to a link L0 and frame C is welded to a link
L1.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameA</span></code>:</dt>
<dd>frame A of link (body) L0 that connects to bushing B.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameC</span></code>:</dt>
<dd>frame C of link (body) L1 that connects to bushing B.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">torque_stiffness_constants</span></code>:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> multiply the roll-pitch-yaw angles <code class="docutils literal notranslate"><span class="pre">[q₀</span> <span class="pre">q₁</span> <span class="pre">q₂]</span></code>
to produce the spring portion of the “gimbal” torques τ₀, τ₁, τ₂.
The SI units of <code class="docutils literal notranslate"><span class="pre">k₀,</span> <span class="pre">k₁,</span> <span class="pre">k₂</span></code> are N*m/rad.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">torque_damping_constants</span></code>:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">d₂]</span></code> multiply the roll-pitch-yaw rates <code class="docutils literal notranslate"><span class="pre">[q̇₀</span> <span class="pre">q̇₁</span> <span class="pre">q̇₂]</span></code>
to produce the damper portion of the “gimbal” torques τ₀, τ₁, τ₂.
The SI units of <code class="docutils literal notranslate"><span class="pre">d₀,</span> <span class="pre">d₁,</span> <span class="pre">d₂</span></code> are N*m*s/rad.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">force_stiffness_constants</span></code>:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> multiply the bushing displacements <code class="docutils literal notranslate"><span class="pre">[x</span> <span class="pre">y</span> <span class="pre">z]</span></code> to
form 𝐟ᴋ, the spring portion of the force 𝐟 = [fx fy fz]ʙ. The SI
units of <code class="docutils literal notranslate"><span class="pre">kx,</span> <span class="pre">ky,</span> <span class="pre">kz</span></code> are N/m.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">force_damping_constants</span></code>:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code> multiply the bushing displacement rates <code class="docutils literal notranslate"><span class="pre">[ẋ</span> <span class="pre">ẏ</span>
<span class="pre">ż]</span></code> to form 𝐟ᴅ, the damper portion of the force 𝐟 = [fx fy fz]ʙ.
The SI units of <code class="docutils literal notranslate"><span class="pre">dx,</span> <span class="pre">dy,</span> <span class="pre">dz</span></code> are N*s/m.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The LinearBushingRollPitchYaw class documentation describes the
stiffness and damping constants.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The net moment on C about Co is affected by both the gimbal torque
and the moment of 𝐟 about Co. Similarly, for the net moment on A
about Ao.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">math::RollPitchYaw describes the roll pitch yaw angles q₀, q₁, q₂.
The position from Ao to Co is p_AoCo_B = x 𝐁𝐱 + y 𝐁𝐲 + z 𝐁𝐳 = [x y
z]ʙ.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The ModelInstanceIndex assigned to this by the constructor is the
one assigned to frame C, i.e., frameC.model_instance().</p>
</div>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>All the stiffness and damping constants must be non-negative.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression].CalcBushingSpatialForceOnFrameA">
<code class="descname">CalcBushingSpatialForceOnFrameA</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression].CalcBushingSpatialForceOnFrameA" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate F_A_A, the bushing’s spatial force on frame A expressed in
A. F_A_A contains two vectors: the moment of all bushing forces on A
about Ao (−𝐭 + p_AoAp × −𝐟) and the net bushing force on A (−𝐟
expressed in A).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The state of the multibody system.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcBushingSpatialForceOnFrameC().</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if pitch angle is near gimbal-lock. For more info,</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RollPitchYaw::DoesCosPitchAngleViolateGimbalLockTolerance().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression].CalcBushingSpatialForceOnFrameC">
<code class="descname">CalcBushingSpatialForceOnFrameC</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression].CalcBushingSpatialForceOnFrameC" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate F_C_C, the bushing’s spatial force on frame C expressed in
C. F_C_C contains two vectors: the moment of all bushing forces on C
about Co (𝐭 + p_CoCp × 𝐟) and the resultant bushing force on C (𝐟
expressed in C).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The state of the multibody system.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcBushingSpatialForceOnFrameA().</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if pitch angle is near gimbal-lock. For more info,</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RollPitchYaw::DoesCosPitchAngleViolateGimbalLockTolerance().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression].force_damping_constants">
<code class="descname">force_damping_constants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression].force_damping_constants" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default force damping constants <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code> (units of
N*s/m). Refer to Basic_bushing_force_stiffness_and_damping “How to
choose force stiffness and damping constants” for more details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression].force_stiffness_constants">
<code class="descname">force_stiffness_constants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression].force_stiffness_constants" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default force stiffness constants <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> (units of
N/m). Refer to Basic_bushing_force_stiffness_and_damping “How to
choose force stiffness and damping constants” for more details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression].frameA">
<code class="descname">frameA</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Frame_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression].frameA" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns frame A, which is the frame that is welded to link (body) L0
and attached to the bushing.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression].frameC">
<code class="descname">frameC</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Frame_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression].frameC" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns frame C, which is the frame that is welded to link (body) L1
and attached to the bushing.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression].GetForceDampingConstants">
<code class="descname">GetForceDampingConstants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression].GetForceDampingConstants" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the force damping constants <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code> (units of N*s/m)
stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression].GetForceStiffnessConstants">
<code class="descname">GetForceStiffnessConstants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression].GetForceStiffnessConstants" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the force stiffness constants <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> (units of N/m)
stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression].GetTorqueDampingConstants">
<code class="descname">GetTorqueDampingConstants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression].GetTorqueDampingConstants" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the torque damping constants <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">d₂]</span></code> (units of
N*m*s/rad) stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression].GetTorqueStiffnessConstants">
<code class="descname">GetTorqueStiffnessConstants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression].GetTorqueStiffnessConstants" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the torque stiffness constants <code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> (units of
N*m/rad) stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression].link0">
<code class="descname">link0</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression].link0" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns link (body) L0 (frame A is welded to link L0).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression].link1">
<code class="descname">link1</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression].link1" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns link (body) L1 (frame C is welded to link L1).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression].SetForceDampingConstants">
<code class="descname">SetForceDampingConstants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression], context: pydrake.systems.framework.Context_[Expression], force_damping: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression].SetForceDampingConstants" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the force damping constants <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code> (units of N*s/m) in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression].SetForceStiffnessConstants">
<code class="descname">SetForceStiffnessConstants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression], context: pydrake.systems.framework.Context_[Expression], force_stiffness: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression].SetForceStiffnessConstants" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the force stiffness constants <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> (units of N/m) in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression].SetTorqueDampingConstants">
<code class="descname">SetTorqueDampingConstants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression], context: pydrake.systems.framework.Context_[Expression], torque_damping: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression].SetTorqueDampingConstants" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the torque damping constants <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">d₂]</span></code> (units of N*m*s/rad)
in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression].SetTorqueStiffnessConstants">
<code class="descname">SetTorqueStiffnessConstants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression], context: pydrake.systems.framework.Context_[Expression], torque_stiffness: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression].SetTorqueStiffnessConstants" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the torque stiffness constants <code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> (units of N*m/rad)
in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression].torque_damping_constants">
<code class="descname">torque_damping_constants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression].torque_damping_constants" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default torque damping constants <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">d₂]</span></code> (units of
N*m*s/rad). Refer to Basic_bushing_torque_stiffness_and_damping “How
to choose torque stiffness and damping constants” for more details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression].torque_stiffness_constants">
<code class="descname">torque_stiffness_constants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[Expression].torque_stiffness_constants" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default torque stiffness constants <code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> (units
of N*m/rad). Refer to Basic_bushing_torque_stiffness_and_damping “How
to choose torque stiffness and damping constants” for more details.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">LinearBushingRollPitchYaw_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[float]" title="pydrake.multibody.tree.ForceElement_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ForceElement_[float]</span></code></a></p>
<p>This ForceElement models a massless flexible bushing that connects a
frame A of a link (body) L0 to a frame C of a link (body) L1. The
bushing can apply a torque and force due to stiffness (spring) and
dissipation (damper) properties. Frame B is the bushing frame whose
origin Bo is halfway between Ao (A’s origin) and Co (C’s origin) and
whose unit vectors 𝐁𝐱, 𝐁𝐲, 𝐁𝐳 are “halfway” (in an angle-axis sense)
between the unit vectors of frame A and frame C. Frame B is a
“floating” frame in the sense that it is calculated from the position
and orientation of frames A and C (B is not welded to the bushing).</p>
<p>&#64;image html drake/multibody/tree/images/LinearBushingRollPitchYaw.png
width=80%</p>
<p>The set of forces on frame C from the bushing is equivalent to a
torque 𝐭 on frame C and a force 𝐟 applied to a point Cp of C. The set
of forces on frame A from the bushing is equivalent to a torque −𝐭 on
frame A and a force −𝐟 applied to a point Ap of A. Points Ap and Cp
are coincident with Bo (frame B’s origin).</p>
<p>This “quasi-symmetric” bushing force/torque model was developed at
Toyota Research Institute and has advantages compared to traditional
bushing models because it employs a bushing-centered “symmetric” frame
B and it ensures the moment of −𝐟 on A about Ao is equal to the moment
of 𝐟 on C about Co. Traditional models differ as they lack a
“symmetric” frame B and apply −𝐟 at Ao, which means the moment of −𝐟
on A about Ao is always zero. Note: This bushing model is not fully
symmetric since the orientation between frames A and C is
parameterized with roll-pitch-yaw angles [q₀ q₁ q₂]. Since these
angles have an inherent sequence, they are not mathematically
symmetric.</p>
<p>The torque model depends on spring-damper “gimbal” torques <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">≜</span> <span class="pre">[τ₀</span>
<span class="pre">τ₁</span> <span class="pre">τ₂]</span></code> which themselves depend on roll-pitch-yaw angles <code class="docutils literal notranslate"><span class="pre">q</span> <span class="pre">≜</span> <span class="pre">[q₀</span> <span class="pre">q₁</span>
<span class="pre">q₂]</span></code> and rates <code class="docutils literal notranslate"><span class="pre">q̇</span> <span class="pre">=</span> <span class="pre">[q̇₀</span> <span class="pre">q̇₁</span> <span class="pre">q̇₂]</span></code> via a diagonal torque-stiffness
matrix K₀₁₂ and a diagonal torque-damping matrix D₀₁₂ as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>⌈ τ₀ ⌉     ⌈k₀    0    0⌉ ⌈ q₀ ⌉     ⌈d₀    0    0⌉ ⌈ q̇₀ ⌉
τ ≜ | τ₁ | = − | 0   k₁    0| | q₁ |  −  | 0   d₁    0| | q̇₁ |
    ⌊ τ₂ ⌋     ⌊ 0    0   k₂⌋ ⌊ q₂ ⌋     ⌊ 0    0   d₂⌋ ⌊ q̇₂ ⌋
</pre></div>
</div>
<p>where k₀, k₁, k₂ and d₀, d₁, d₂ are torque stiffness and damping
constants and must have non-negative values.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">τ does not represent a vector expressed in one frame. Instead it
is regarded as a 3x1 array of torque scalars associated with
roll-pitch yaw.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">As discussed in the Advanced section below, τ is not 𝐭 <code class="docutils literal notranslate"><span class="pre">(τ</span> <span class="pre">≠</span>
<span class="pre">𝐭)</span></code>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is a “linear” bushing model as gimbal torque τ varies
linearly with q and q̇ as τ = τᴋ + τᴅ where τᴋ = −K₀₁₂ ⋅ q and τᴅ
= −D₀₁₂ ⋅ q̇.</p>
</div>
<p>The bushing model for the net force 𝐟 on frame C from the bushing
depends on scalars x, y, z which are defined so 𝐫 (the position vector
from Ao to Co) can be expressed in frame B as <code class="docutils literal notranslate"><span class="pre">𝐫</span> <span class="pre">≜</span> <span class="pre">p_AoCo</span> <span class="pre">=</span> <span class="pre">[x</span> <span class="pre">y</span> <span class="pre">z]ʙ</span>
<span class="pre">=</span> <span class="pre">x</span> <span class="pre">𝐁𝐱</span> <span class="pre">+</span> <span class="pre">y</span> <span class="pre">𝐁𝐲</span> <span class="pre">+</span> <span class="pre">z</span> <span class="pre">𝐁𝐳</span></code>. The model for 𝐟 uses a diagonal
force-stiffness matrix Kxyᴢ, a diagonal force-damping matrix Dxyᴢ, and
defines fx, fy, fz so <code class="docutils literal notranslate"><span class="pre">𝐟</span> <span class="pre">=</span> <span class="pre">[fx</span> <span class="pre">fy</span> <span class="pre">fz]ʙ</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>⌈ fx ⌉      ⌈kx    0    0⌉ ⌈ x ⌉     ⌈dx    0    0⌉ ⌈ ẋ ⌉
| fy | =  − | 0   ky    0| | y |  −  | 0   dy    0| | ẏ |
⌊ fz ⌋      ⌊ 0    0   kz⌋ ⌊ z ⌋     ⌊ 0    0   dz⌋ ⌊ ż ⌋
</pre></div>
</div>
<p>where kx, ky, kz and dx, dy, dz are force stiffness and damping
constants and must have non-negative values.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is a “linear” bushing model as the force 𝐟 varies linearly
with 𝐫 and 𝐫̇̇ as 𝐟 = 𝐟ᴋ + 𝐟ᴅ where 𝐟ᴋ = −Kxyz ⋅ 𝐫 and 𝐟ᴅ = −Dxyz
⋅ 𝐫̇̇.</p>
</div>
<p>This bushing’s constructor sets the torque stiffness/damping constants
<code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> and <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">d₂]</span></code> and the force stiffness/damping
constants <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> and <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code>. The examples below
demonstrate how to model various joints that have a flexible (e.g.,
rubber) mount. The damping values below with ? may be set to 0 or a
reasonable positive number.</p>
<p>Bushing type | torque constants | force constants
——————————–<a href="#id71"><span class="problematic" id="id72">|:--------------------|</span></a>:——————
z-axis revolute joint | k₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">0]</span></code> | kxyz = <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> ^
| d₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">?]</span></code> | dxyz = <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code> x-axis prismatic joint
| k₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> | kxyz = <code class="docutils literal notranslate"><span class="pre">[0</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> ^ | d₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span>
<span class="pre">d₂]</span></code> | dxyz = <code class="docutils literal notranslate"><span class="pre">[?</span> <span class="pre">dy</span> <span class="pre">dz]</span></code> Ball and socket joint | k₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[0</span> <span class="pre">0</span>
<span class="pre">0]</span></code> | kxyz = <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> ^ | d₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[?</span> <span class="pre">?</span> <span class="pre">?]</span></code> | dxyz = <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span>
<span class="pre">dz]</span></code> Weld/fixed joint | k₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> | kxyz = <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code>
^ | d₀₁₂ = <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">d₂]</span></code> | dxyz = <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code></p>
<p>Angles q₀, q₁, q₂ are calculated from frame C’s orientation relative
to frame A, with <code class="docutils literal notranslate"><span class="pre">[−π</span> <span class="pre">&lt;</span> <span class="pre">q₀</span> <span class="pre">≤</span> <span class="pre">π,</span> <span class="pre">−π/2</span> <span class="pre">≤</span> <span class="pre">q₁</span> <span class="pre">≤</span> <span class="pre">π/2,</span> <span class="pre">−π</span> <span class="pre">&lt;</span> <span class="pre">q₂</span> <span class="pre">≤</span> <span class="pre">π]</span></code>,
hence, there is no angle wrapping and torque stiffness has a limited
range. Gimbal torques τ can be discontinuous if one of q₀, q₁, q₂ is
discontinuous and its associated torque spring constant is nonzero.
For example, τ₂ is discontinuous if <code class="docutils literal notranslate"><span class="pre">k₂</span> <span class="pre">≠</span> <span class="pre">0</span></code> and the bushing has a
large rotation so q₂ jumps from <code class="docutils literal notranslate"><span class="pre">≈</span> <span class="pre">−π</span> <span class="pre">to</span> <span class="pre">π</span></code>. τ can also be
discontinuous if one of q̇₀, q̇₁, q̇₂ is discontinuous and its
associated torque damper constant is nonzero. For example, τ₀ is
discontinuous if <code class="docutils literal notranslate"><span class="pre">d₀</span> <span class="pre">≠</span> <span class="pre">0</span></code> and q̇₀ is undefined (which occurs when
<code class="docutils literal notranslate"><span class="pre">pitch</span> <span class="pre">=</span> <span class="pre">q₁</span> <span class="pre">=</span> <span class="pre">π/2</span></code>). Note: Due to the relationship of 𝐭 to τ shown
below, 𝐭 is discontinuous if τ is discontinuous.</p>
<p>As shown below, there are multiple ways to estimate torque and force
stiffness and damping constants. Use a method or combination of
methods appropriate for your application. For example, some methods
are more useful for a real physical bushing whereas other methods
(called “penalty methods”) can be more useful when replacing an ideal
joint (such as a revolute or fixed/weld joint) with a bushing.</p>
<p>Consider a penalty method if you want a bushing to substitute for a
“hard” constraint (e.g., an ideal joint). Since a bushing is
inherently compliant it will violate a hard constraint somewhat. The
stiffer the bushing, the more accurately it enforces the hard
constraint, but at a cost of more computational time. To balance
accuracy versus time, consider your tolerance for constraint errors.
For example, is it OK for your bushing to displace xₘₐₓ = 1 mm for an
estimated Fxₘₐₓ = 100 N? Also, one way to choose a force damping
constant dx is by choosing a “reasonably small” settling time tₛ,
where settling time tₛ is the interval of time for a system to settle
to within 1% (0.01) of an equilibrium solution). Is tₛ = 0.01 s
negligible for a robot arm with a 10 s reach maneuver?</p>
<p><a href="#id55"><span class="problematic" id="id56">**</span></a>** How to choose a torque stiffness constant k₀ or damping constant
d₀. The estimate of stiffness k₀ depends on whether you are modeling a
physical bushing (consider stiffness methods 1 or 2 below) or whether
you are using a bushing to replace an ideal joint such as a revolute
or fixed/weld joint (consider stiffness “penalty methods” 3 or 4
below). 1. Use a static experiment, e.g., apply a known moment load
Mx, measure the associated angular displacement Δq (radians), and
estimate k₀ = Mx / Δq. 2. Use FEA (finite element analysis) software
to estimate k₀. 3. Pick a desired maximum angular displacement qₘₐₓ,
estimate a maximum moment load Mxₘₐₓ, and estimate <code class="docutils literal notranslate"><span class="pre">k₀</span> <span class="pre">=</span> <span class="pre">Mxₘₐₓ</span> <span class="pre">/</span>
<span class="pre">qₘₐₓ</span></code> (units of N*m/rad). 4. Choose a characteristic moment of
inertia I₀ (directionally dependent), choose a desired angular
frequency ωₙ &gt; 0 (in rad/s) and estimate <code class="docutils literal notranslate"><span class="pre">k₀</span> <span class="pre">=</span> <span class="pre">I₀</span> <span class="pre">ωₙ²</span></code> (units of
N*m/rad).</p>
<p>The estimate of damping d₀ depends on whether you are modeling a
physical bushing (consider damping method 1 below) or whether you are
using a bushing to enforce a constraint (consider damping methods 2 or
3 below). 1. Use experiments to estimate a damping ratio ζ and
settling time tₛ. Compute “undamped natural frequency” ωₙ from ζ and
tₛ (as shown below in the Advanced section), then <code class="docutils literal notranslate"><span class="pre">d₀</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">ζ</span> <span class="pre">k₀</span> <span class="pre">/</span> <span class="pre">ωₙ</span></code>
(units of N*m*s/rad). 2. Choose a damping ratio ζ (e.g., ζ = 1,
critical damping) and a desired settling time tₛ, calculate ωₙ (as
shown below in the Advanced section), then <code class="docutils literal notranslate"><span class="pre">d₀</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">ζ</span> <span class="pre">k₀</span> <span class="pre">/</span> <span class="pre">ωₙ</span></code> (units
of N*m*s/rad). 3. Choose a damping ratio ζ (e.g., ζ = 1, critical
damping), estimate a characteristic moment of inertia and calculate
<code class="docutils literal notranslate"><span class="pre">d₀</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">ζ</span> <span class="pre">√(I₀</span> <span class="pre">k₀)</span></code>.</p>
<p>Refer to Advanced_bushing_stiffness_and_damping “Advanced bushing
stiffness and damping” for more details.</p>
<p><a href="#id57"><span class="problematic" id="id58">**</span></a>** How to choose a force stiffness constant kx or damping constant
dx. The estimate of stiffness kx depends on whether you are modeling a
real bushing (consider stiffness methods 1 or 2 below) or whether you
are using a bushing to replace an ideal joint such as a revolute or
fixed/weld joint (consider stiffness “penalty methods” 3 or 4 below).
1. Use a static experiment, e.g., apply a known force load Fx, measure
the associated displacement (stretch) Δx (in meters), and estimate kx
= Fx / Δx. 2. Use FEA (finite element analysis) software to estimate
kx (units of N/m). 3. Pick a desired maximum displacement xₘₐₓ,
estimate a maximum force load Fxₘₐₓ, and estimate <code class="docutils literal notranslate"><span class="pre">kx</span> <span class="pre">=</span> <span class="pre">Fxₘₐₓ</span> <span class="pre">/</span>
<span class="pre">xₘₐₓ</span></code> (units of N/m). 4. Choose a characteristic mass m (which may be
directionally dependent), choose a desired angular frequency ωₙ &gt; 0
(in rad/s) and estimate <code class="docutils literal notranslate"><span class="pre">kx</span> <span class="pre">=</span> <span class="pre">m</span> <span class="pre">ωₙ²</span></code> (units of N/m).</p>
<p>The estimate of damping dx depends on whether you are modeling a
physical bushing (consider damping method 1 below) or whether you are
using a bushing to enforce a constraint (consider damping methods 2 or
3 below). 1. Use experiments to estimate a damping ratio ζ and
settling time tₛ. Compute “undamped natural frequency” ωₙ from ζ and
tₛ (as shown below in the Advanced section), then <code class="docutils literal notranslate"><span class="pre">dx</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">ζ</span> <span class="pre">kx</span> <span class="pre">/</span> <span class="pre">ωₙ</span></code>
(units of N*s/m). 2. Choose a damping ratio ζ (e.g., ζ = 1, critical
damping) and a desired settling time tₛ, calculate ωₙ (as shown below
in the Advanced section), then <code class="docutils literal notranslate"><span class="pre">dx</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">ζ</span> <span class="pre">kx</span> <span class="pre">/</span> <span class="pre">ωₙ</span></code> (units of N*s/m).
3. Choose a damping ratio ζ (e.g., ζ = 1, critical damping), estimate
a characteristic mass m and calculate <code class="docutils literal notranslate"><span class="pre">dx</span> <span class="pre">=</span> <span class="pre">2</span> <span class="pre">ζ</span> <span class="pre">√(m</span> <span class="pre">kx)</span></code> (units of
N*s/m).</p>
<p>Refer to Advanced_bushing_stiffness_and_damping “Advanced bushing
stiffness and damping” for more details.</p>
<p><a href="#id59"><span class="problematic" id="id60">**</span></a>** Advanced: Relationship of 𝐭 to τ. To understand how “gimbal
torques” τ relate to 𝐭, it helps to remember that the RollPitchYaw
class documentation states that a Space-fixed (extrinsic) X-Y-Z
rotation with roll-pitch-yaw angles [q₀ q₁ q₂] is equivalent to a
Body-fixed (intrinsic) Z-Y-X rotation by yaw-pitch-roll angles [q₂ q₁
q₀]. In the context of “gimbal torques”, the Body-fixed Z-Y-X rotation
sequence with angles [q₂ q₁ q₀] is physical meaningful as it produces
torques associated with successive frames in a gimbal as τ₂ 𝐀𝐳, τ₁ 𝐏𝐲,
τ₀ 𝐂𝐱, where each of 𝐀𝐳, 𝐏𝐲, 𝐂𝐱 are unit vectors associated with a
frame in the yaw-pitch-roll rotation sequence and 𝐏𝐲 is a unit vector
of the “pitch” intermediate frame. As described earlier, torque 𝐭 is
the moment of the bushing forces on frame C about Cp. Scalars tx, ty,
tz are defined so 𝐭 can be expressed <code class="docutils literal notranslate"><span class="pre">𝐭</span> <span class="pre">=</span> <span class="pre">[tx</span> <span class="pre">ty</span> <span class="pre">tz]ᴀ</span> <span class="pre">=</span> <span class="pre">tx</span> <span class="pre">𝐀𝐱</span> <span class="pre">+</span> <span class="pre">ty</span> <span class="pre">𝐀𝐲</span>
<span class="pre">+</span> <span class="pre">tz</span> <span class="pre">𝐀𝐳</span></code>. As shown in code documentation, the relationship of [tx ty
tz] to [τ₀ τ₁ τ₂] was found by equating 𝐭’s power to τ’s power as 𝐭 ⋅
w_AC = τ ⋅ q̇.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>⌈ tx ⌉      ⌈ τ₀ ⌉            ⌈ cos(q₂)/cos(q₁)  sin(q₂)/cos(q₁)   0 ⌉
| ty | = Nᵀ | τ₁ |  where N = |   −sin(q2)            cos(q2)      0 |
⌊ tz ⌋      ⌊ τ₂ ⌋            ⌊ cos(q₂)*tan(q₁)   sin(q₂)*tan(q₁)  1 ⌋
</pre></div>
</div>
<p><a href="#id61"><span class="problematic" id="id62">**</span></a>** Advanced: More on how to choose bushing stiffness and damping
constants. The basics on how to choose bushing stiffness and damping
constants are at: - Basic_bushing_torque_stiffness_and_damping “How to
choose torque stiffness and damping constants” -
Basic_bushing_force_stiffness_and_damping “How to choose force
stiffness and damping constants”</p>
<p>The list below provides more detail on: The performance tradeoff
between high stiffness and long simulation time; loads that affect
estimates of Mxₘₐₓ or Fxₘₐₓ; and how a linear 2ⁿᵈ-order ODE provides
insight on how to experimentally determine stiffness and damping
constants. - Stiffness [k₀ k₁ k₂] and [kx ky kz] affect simulation
time and accuracy. Generally, a stiffer bushing better resembles an
ideal joint (e.g., a revolute joint or fixed/weld joint). However
(depending on integrator), a stiffer bushing usually increases
numerical integration time. - An estimate for a maximum load Mxₘₐₓ or
Fxₘₐₓ accounts for gravity forces, applied forces, inertia forces
(centripetal, Coriolis, gyroscopic), etc. - One way to determine
physical stiffness and damping constants is through the mathematical
intermediaries ωₙ (units of rad/s) and ζ (no units). The constant ωₙ
(called “undamped natural frequency” or “angular frequency”) and
constant ζ (called “damping ratio”) relate to the physical constants
mass m, damping constant dx, and stiffness constant kx via the
following prototypical linear constant-coefficient 2ⁿᵈ-order ODEs.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>m ẍ +     dx ẋ +  kx x = 0   or alternatively as
   ẍ + 2 ζ ωₙ ẋ + ωₙ² x = 0   where ωₙ² = kx/m,  ζ = dx / (2 √(m kx))
</pre></div>
</div>
<p>ωₙ and ζ also appear in the related ODEs for rotational systems,
namely</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>I₀ q̈ +     d₀ q̇ +  k₀ q = 0   or alternatively as
    q̈ + 2 ζ ωₙ q̇ + ωₙ² q = 0   where ωₙ² = k₀/I₀,  ζ = d₀ / (2 √(I₀ k₀))
</pre></div>
</div>
<p>One way to determine ωₙ is from settling time tₛ which approximates
the time for a system to settle to within a specified settling ratio
of an equilibrium solutions. Typical values for settling ratio are 1%
(0.01), 2% (0.02), 5% (0.05), and 10% (0.10). - When ζ &lt; 0.7
(underdamped), a commonly used approximation is ωₙ ≈
-ln(settling_ratio) / (ζ tₛ) which for settling ratios 0.01 and 0.05
give ωₙ ≈ 4.6 / (ζ tₛ) and ωₙ ≈ 3 / (ζ tₛ). Another commonly used
approximation is ωₙ ≈ -ln(settling_ratio √(1- ζ²)) / (ζ tₛ). See
<a class="reference external" href="https://en.wikipedia.org/wiki/Settling_time">https://en.wikipedia.org/wiki/Settling_time</a> or the book Modern Control
Engineering by Katsuhiko Ogata. Although these approximate formulas
for ωₙ are common, they are somewhat inaccurate. Settling time for
underdamped systems is discontinuous and requires solving a nonlinear
algebraic equation (an iterative process). For more information, see
<a class="reference external" href="http://www.scielo.org.co/pdf/rfiua/n66/n66a09.pdf">http://www.scielo.org.co/pdf/rfiua/n66/n66a09.pdf</a> [Ramos-Paja, et. al
2012], “Accurate calculation of settling time in second order systems:
a photovoltaic application”. Another reference is
<a class="reference external" href="https://courses.grainger.illinois.edu/ece486/sp2020/laboratory/docs/lab2/estimates.html">https://courses.grainger.illinois.edu/ece486/sp2020/laboratory/docs/lab2/estimates.html</a>
- When ζ ≈ 1 (critically damped), ωₙ is determined by choosing a
settling ratio and then solving for (ωₙ tₛ) via the nonlinear
algebraic equation (1 + ωₙ tₛ)*exp(-ωₙ tₛ) = settling_ratio. Settling
ratio | ωₙ ————– | ————- 0.01 | 6.64 / tₛ 0.02 | 5.83
/ tₛ 0.05 | 4.74 / tₛ 0.10 | 3.89 / tₛ See
<a class="reference external" href="https://electronics.stackexchange.com/questions/296567/over-and-critically-damped-systems-settling-time">https://electronics.stackexchange.com/questions/296567/over-and-critically-damped-systems-settling-time</a>
- When ζ ≥ 1.01 (overdamped), ωₙ ≈ -ln(2 settling_ratio sz/s₂) / (s₁
tₛ) where sz = √(ζ² - 1), s₁ = ζ - sz, s₂ = ζ + sz. The derivation and
approximation error estimates for this overdamped settling time
formula is ApproximateOverdampedSettlingTime “below”.</p>
<ul class="simple">
<li>For a real physical bushing, an experiment is one way to estimate damping</li>
</ul>
<p>constants.  For example, to estimate a torque damping constant d₀ associated
with underdamped vibrations (damping ratio 0 &lt; ζ &lt; 1), attach the bushing to
a massive rod, initially displace the rod by angle Δq, release the rod and
measure q(t).  From the q(t) measurement, estimate decay ratio (the ratio of
successive peak heights above the final steady-state value) calculate
logarithmic decrement δ = -ln(decay_ratio), calculate damping ratio
ζ = √(δ² / (4π² + δ²)), then calculate d₀ using d₀ = 2 ζ √(I₀ k₀) or
d₀ = 2 ζ k₀ / ωₙ. For more information, see
<a class="reference external" href="https://en.wikipedia.org/wiki/Damping_ratio#Logarithmic_decrement">https://en.wikipedia.org/wiki/Damping_ratio#Logarithmic_decrement</a></p>
<p><a href="#id63"><span class="problematic" id="id64">**</span></a>** Derivation: Approximate formula for overdamped settling time.
Since a literature reference for this formula was not found, the
derivation below was done at TRI (it has not been peer reviewed). This
formula results from the “dominant pole” solution in the prototypical
constant-coefficient linear 2ⁿᵈ-order ODE. For ẋ(0) = 0, mathematics
shows poles p₁ = -ωₙ s₁, p₂ = -ωₙ s₂, where sz = √(ζ² - 1), s₁ = ζ -
sz, s₂ = ζ + sz. and</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>x(t) / x(0) = p₂/(p₂-p₁) exp(p₁ t) - p₁/(p₂-p₁) exp(p₂ t)
             = s₂/(s₂-s₁) exp(p₁ t) - s₁/(s₂-s₁) exp(p₂ t)
             =  k/( k-1 ) exp(p₁ t) -  1/( k-1 ) exp(p₂ t) where k = s₂ / s₁
             ≈  k/( k-1 ) exp(p₁ t)                        since p₁ &gt; p₂
</pre></div>
</div>
<p>Note: k = s₂ / s₁ is real, k &gt; 0, s₂ = k s₁, and p₁ &gt; p₂ (p₁ is less
negative then p₂), so exp(p₁ t) decays to zero slower than exp(p₂ t)
and exp(p₁ t) ≫ exp(p₂ t) for sufficiently large t. Hence we assume
exp(p₂ t) ≈ 0 (which is why p₁ is called the “dominant pole”). Next,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>k/(k - 1) = s₂ / s₁ / (s₂/s₁ -1) = s₂ / (s₂ - s₁) = s₂ / (2 sz),  so
  x(t) / x(0)  ≈  s₂ / (2 sz) exp(-s₁ ωₙ t),                        hence
  settling_ratio ≈ s₂ / (2 sz) exp(-s₁ ωₙ tₛ),                      finally
  ωₙ ≈ -ln(settling_ratio 2 sz / s₂) / (s₁ tₛ)
</pre></div>
</div>
<p>The table below shows that there is little error in this approximate
formula for various settling ratios and ζ, particularly for ζ ≥ 1.1.
For 1.0 ≤ ζ &lt; 1.1, the critical damping estimates of ωₙ work well.
Settling ratio | ζ = 1.01 | ζ = 1.1 | ζ = 1.2 | ζ = 1.3 | ζ = 1.5
————– | ——– | ——- | ——- | ——- | ——–
0.01 | 1.98% | 0.005% | 2.9E-5% | 1.6E-7% | 2.4E-12% 0.02 | 2.91% |
0.016% | 1.8E-4% | 2.1E-6% | 1.6E-10% 0.05 | 5.10% | 0.076% | 2.3E-3%
| 7.0E-5% | 4.4E-8% 0.10 | 8.28% | 0.258% | 1.6E-2% | 1.0E-3% |
3.3E-6% Note: There is a related derivation in the reference below,
however, it needlessly makes the oversimplified approximation k/(k -
1) ≈ 1.
<a class="reference external" href="https://electronics.stackexchange.com/questions/296567/over-and-critically-damped-systems-settling-time">https://electronics.stackexchange.com/questions/296567/over-and-critically-damped-systems-settling-time</a></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The complete theory for this bushing is documented in the source
code. Please look there if you want more information.</p>
</div>
<dl class="docutils">
<dt>Template parameter <code class="docutils literal notranslate"><span class="pre">T</span></code>:</dt>
<dd>The underlying scalar type. Must be a valid Eigen scalar.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">math::RollPitchYaw for definitions of roll, pitch, yaw <code class="docutils literal notranslate"><span class="pre">[q₀</span> <span class="pre">q₁</span>
<span class="pre">q₂]</span></code>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Per issue #12982, do not directly or indirectly call the following
methods as they have not yet been implemented and throw an
exception: CalcPotentialEnergy(), CalcConservativePower(),
CalcNonConservativePower().</p>
</div>
<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[float], frameA: pydrake.multibody.tree.Frame_[float], frameC: pydrake.multibody.tree.Frame_[float], torque_stiffness_constants: numpy.ndarray[numpy.float64[3, 1]], torque_damping_constants: numpy.ndarray[numpy.float64[3, 1]], force_stiffness_constants: numpy.ndarray[numpy.float64[3, 1]], force_damping_constants: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a LinearBushingRollPitchYaw B that connects frames A and C,
where frame A is welded to a link L0 and frame C is welded to a link
L1.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameA</span></code>:</dt>
<dd>frame A of link (body) L0 that connects to bushing B.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">frameC</span></code>:</dt>
<dd>frame C of link (body) L1 that connects to bushing B.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">torque_stiffness_constants</span></code>:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> multiply the roll-pitch-yaw angles <code class="docutils literal notranslate"><span class="pre">[q₀</span> <span class="pre">q₁</span> <span class="pre">q₂]</span></code>
to produce the spring portion of the “gimbal” torques τ₀, τ₁, τ₂.
The SI units of <code class="docutils literal notranslate"><span class="pre">k₀,</span> <span class="pre">k₁,</span> <span class="pre">k₂</span></code> are N*m/rad.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">torque_damping_constants</span></code>:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">d₂]</span></code> multiply the roll-pitch-yaw rates <code class="docutils literal notranslate"><span class="pre">[q̇₀</span> <span class="pre">q̇₁</span> <span class="pre">q̇₂]</span></code>
to produce the damper portion of the “gimbal” torques τ₀, τ₁, τ₂.
The SI units of <code class="docutils literal notranslate"><span class="pre">d₀,</span> <span class="pre">d₁,</span> <span class="pre">d₂</span></code> are N*m*s/rad.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">force_stiffness_constants</span></code>:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> multiply the bushing displacements <code class="docutils literal notranslate"><span class="pre">[x</span> <span class="pre">y</span> <span class="pre">z]</span></code> to
form 𝐟ᴋ, the spring portion of the force 𝐟 = [fx fy fz]ʙ. The SI
units of <code class="docutils literal notranslate"><span class="pre">kx,</span> <span class="pre">ky,</span> <span class="pre">kz</span></code> are N/m.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">force_damping_constants</span></code>:</dt>
<dd><code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code> multiply the bushing displacement rates <code class="docutils literal notranslate"><span class="pre">[ẋ</span> <span class="pre">ẏ</span>
<span class="pre">ż]</span></code> to form 𝐟ᴅ, the damper portion of the force 𝐟 = [fx fy fz]ʙ.
The SI units of <code class="docutils literal notranslate"><span class="pre">dx,</span> <span class="pre">dy,</span> <span class="pre">dz</span></code> are N*s/m.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The LinearBushingRollPitchYaw class documentation describes the
stiffness and damping constants.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The net moment on C about Co is affected by both the gimbal torque
and the moment of 𝐟 about Co. Similarly, for the net moment on A
about Ao.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">math::RollPitchYaw describes the roll pitch yaw angles q₀, q₁, q₂.
The position from Ao to Co is p_AoCo_B = x 𝐁𝐱 + y 𝐁𝐲 + z 𝐁𝐳 = [x y
z]ʙ.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The ModelInstanceIndex assigned to this by the constructor is the
one assigned to frame C, i.e., frameC.model_instance().</p>
</div>
<dl class="docutils">
<dt>Precondition:</dt>
<dd>All the stiffness and damping constants must be non-negative.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[float].CalcBushingSpatialForceOnFrameA">
<code class="descname">CalcBushingSpatialForceOnFrameA</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[float]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[float].CalcBushingSpatialForceOnFrameA" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate F_A_A, the bushing’s spatial force on frame A expressed in
A. F_A_A contains two vectors: the moment of all bushing forces on A
about Ao (−𝐭 + p_AoAp × −𝐟) and the net bushing force on A (−𝐟
expressed in A).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The state of the multibody system.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcBushingSpatialForceOnFrameC().</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if pitch angle is near gimbal-lock. For more info,</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RollPitchYaw::DoesCosPitchAngleViolateGimbalLockTolerance().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[float].CalcBushingSpatialForceOnFrameC">
<code class="descname">CalcBushingSpatialForceOnFrameC</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[float]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[float].CalcBushingSpatialForceOnFrameC" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate F_C_C, the bushing’s spatial force on frame C expressed in
C. F_C_C contains two vectors: the moment of all bushing forces on C
about Co (𝐭 + p_CoCp × 𝐟) and the resultant bushing force on C (𝐟
expressed in C).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The state of the multibody system.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">CalcBushingSpatialForceOnFrameA().</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if pitch angle is near gimbal-lock. For more info,</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RollPitchYaw::DoesCosPitchAngleViolateGimbalLockTolerance().</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[float].force_damping_constants">
<code class="descname">force_damping_constants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[float].force_damping_constants" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default force damping constants <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code> (units of
N*s/m). Refer to Basic_bushing_force_stiffness_and_damping “How to
choose force stiffness and damping constants” for more details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[float].force_stiffness_constants">
<code class="descname">force_stiffness_constants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[float].force_stiffness_constants" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default force stiffness constants <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> (units of
N/m). Refer to Basic_bushing_force_stiffness_and_damping “How to
choose force stiffness and damping constants” for more details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[float].frameA">
<code class="descname">frameA</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Frame_[float]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[float].frameA" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns frame A, which is the frame that is welded to link (body) L0
and attached to the bushing.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[float].frameC">
<code class="descname">frameC</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Frame_[float]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[float].frameC" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns frame C, which is the frame that is welded to link (body) L1
and attached to the bushing.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[float].GetForceDampingConstants">
<code class="descname">GetForceDampingConstants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[float].GetForceDampingConstants" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the force damping constants <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code> (units of N*s/m)
stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[float].GetForceStiffnessConstants">
<code class="descname">GetForceStiffnessConstants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[float].GetForceStiffnessConstants" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the force stiffness constants <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> (units of N/m)
stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[float].GetTorqueDampingConstants">
<code class="descname">GetTorqueDampingConstants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[float].GetTorqueDampingConstants" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the torque damping constants <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">d₂]</span></code> (units of
N*m*s/rad) stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[float].GetTorqueStiffnessConstants">
<code class="descname">GetTorqueStiffnessConstants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[float].GetTorqueStiffnessConstants" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the torque stiffness constants <code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> (units of
N*m/rad) stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[float].link0">
<code class="descname">link0</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[float]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[float].link0" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns link (body) L0 (frame A is welded to link L0).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[float].link1">
<code class="descname">link1</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[float]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[float].link1" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns link (body) L1 (frame C is welded to link L1).</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[float].SetForceDampingConstants">
<code class="descname">SetForceDampingConstants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[float], context: pydrake.systems.framework.Context_[float], force_damping: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[float].SetForceDampingConstants" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the force damping constants <code class="docutils literal notranslate"><span class="pre">[dx</span> <span class="pre">dy</span> <span class="pre">dz]</span></code> (units of N*s/m) in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[float].SetForceStiffnessConstants">
<code class="descname">SetForceStiffnessConstants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[float], context: pydrake.systems.framework.Context_[float], force_stiffness: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[float].SetForceStiffnessConstants" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the force stiffness constants <code class="docutils literal notranslate"><span class="pre">[kx</span> <span class="pre">ky</span> <span class="pre">kz]</span></code> (units of N/m) in
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[float].SetTorqueDampingConstants">
<code class="descname">SetTorqueDampingConstants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[float], context: pydrake.systems.framework.Context_[float], torque_damping: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[float].SetTorqueDampingConstants" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the torque damping constants <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">d₂]</span></code> (units of N*m*s/rad)
in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[float].SetTorqueStiffnessConstants">
<code class="descname">SetTorqueStiffnessConstants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[float], context: pydrake.systems.framework.Context_[float], torque_stiffness: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[float].SetTorqueStiffnessConstants" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the torque stiffness constants <code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> (units of N*m/rad)
in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[float].torque_damping_constants">
<code class="descname">torque_damping_constants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[float].torque_damping_constants" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default torque damping constants <code class="docutils literal notranslate"><span class="pre">[d₀</span> <span class="pre">d₁</span> <span class="pre">d₂]</span></code> (units of
N*m*s/rad). Refer to Basic_bushing_torque_stiffness_and_damping “How
to choose torque stiffness and damping constants” for more details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearBushingRollPitchYaw_[float].torque_stiffness_constants">
<code class="descname">torque_stiffness_constants</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearBushingRollPitchYaw_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearBushingRollPitchYaw_[float].torque_stiffness_constants" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default torque stiffness constants <code class="docutils literal notranslate"><span class="pre">[k₀</span> <span class="pre">k₁</span> <span class="pre">k₂]</span></code> (units
of N*m/rad). Refer to Basic_bushing_torque_stiffness_and_damping “How
to choose torque stiffness and damping constants” for more details.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.LinearSpringDamper">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">LinearSpringDamper</code><a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.LinearSpringDamper_[float]" title="pydrake.multibody.tree.LinearSpringDamper_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.LinearSpringDamper_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.LinearSpringDamper_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">LinearSpringDamper_</code><a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.LinearSpringDamper_[float]" title="pydrake.multibody.tree.LinearSpringDamper_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">LinearSpringDamper_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd]" title="pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">LinearSpringDamper_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.LinearSpringDamper_[Expression]" title="pydrake.multibody.tree.LinearSpringDamper_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">LinearSpringDamper_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.LinearSpringDamper_.LinearSpringDamper_[float]">
<em class="property">class </em><code class="descname">LinearSpringDamper_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_.LinearSpringDamper_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[float]" title="pydrake.multibody.tree.ForceElement_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ForceElement_[float]</span></code></a></p>
<p>This ForceElement models a spring-damper attached between two points
on two different bodies. Given a point P on a body A and a point Q on
a body B with positions p_AP and p_BQ, respectively, this
spring-damper applies equal and opposite forces on bodies A and B
according to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>f_AP = (k⋅(ℓ - ℓ₀) + c⋅dℓ/dt)⋅r̂
  f_BQ = -f_AP
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">ℓ</span> <span class="pre">=</span> <span class="pre">‖p_WQ</span> <span class="pre">-</span> <span class="pre">p_WP‖</span></code> is the current length of the spring, dℓ/dt
its rate of change, <code class="docutils literal notranslate"><span class="pre">r̂</span> <span class="pre">=</span> <span class="pre">(p_WQ</span> <span class="pre">-</span> <span class="pre">p_WP)</span> <span class="pre">/</span> <span class="pre">ℓ</span></code> is the normalized
vector from P to Q, ℓ₀ is the free length of the spring and k and c
are the stiffness and damping of the spring-damper, respectively. This
ForceElement is meant to model finite free length springs attached
between two points. In this typical arrangement springs are usually
pre-loaded, meaning they apply a non-zero spring force in the static
configuration of the system. Thus, neither the free length ℓ₀ nor the
current length ℓ of the spring can ever be zero. The length of the
spring approaching zero would incur in a non-physical configuration
and therefore this element throws a RuntimeError exception in that
case. Note that:</p>
<ul class="simple">
<li>The applied force is always along the line connecting points P and</li>
</ul>
<p>Q. - Damping always dissipates energy. - Forces on bodies A and B are
equal and opposite according to Newton’s third law.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_.LinearSpringDamper_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[float], bodyA: pydrake.multibody.tree.Body_[float], p_AP: numpy.ndarray[numpy.float64[3, 1]], bodyB: pydrake.multibody.tree.Body_[float], p_BQ: numpy.ndarray[numpy.float64[3, 1]], free_length: float, stiffness: float, damping: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_.LinearSpringDamper_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor for a spring-damper between a point P on <code class="docutils literal notranslate"><span class="pre">bodyA</span></code> and a
point Q on <code class="docutils literal notranslate"><span class="pre">bodyB</span></code>. Point P is defined by its position <code class="docutils literal notranslate"><span class="pre">p_AP</span></code> as
measured and expressed in the body frame A and similarly, point Q is
defined by its position p_BQ as measured and expressed in body frame
B. The remaining parameters define:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">free_length</span></code>:</dt>
<dd>The free length of the spring ℓ₀, in meters, at which the spring
applies no forces. Since this force element is meant to model
finite length springs, ℓ₀ must be strictly positive.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">stiffness</span></code>:</dt>
<dd>The stiffness k of the spring in N/m. It must be non-negative.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt>
<dd>The damping c of the damper in N⋅s/m. It must be non-negative.
Refer to this class’s documentation for further details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal notranslate"><span class="pre">free_length</span></code> is negative or zero.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal notranslate"><span class="pre">stiffness</span></code> is negative.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal notranslate"><span class="pre">damping</span></code> is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_.LinearSpringDamper_[float].bodyA">
<code class="descname">bodyA</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[float]<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_.LinearSpringDamper_[float].bodyA" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_.LinearSpringDamper_[float].bodyB">
<code class="descname">bodyB</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[float]<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_.LinearSpringDamper_[float].bodyB" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_.LinearSpringDamper_[float].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_.LinearSpringDamper_[float].damping" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_.LinearSpringDamper_[float].free_length">
<code class="descname">free_length</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_.LinearSpringDamper_[float].free_length" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_.LinearSpringDamper_[float].p_AP">
<code class="descname">p_AP</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_.LinearSpringDamper_[float].p_AP" title="Permalink to this definition">¶</a></dt>
<dd><p>The position p_AP of point P on body A as measured and expressed in
body frame A.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_.LinearSpringDamper_[float].p_BQ">
<code class="descname">p_BQ</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_.LinearSpringDamper_[float].p_BQ" title="Permalink to this definition">¶</a></dt>
<dd><p>The position p_BQ of point Q on body B as measured and expressed in
body frame B.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_.LinearSpringDamper_[float].stiffness">
<code class="descname">stiffness</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_.LinearSpringDamper_[float].stiffness" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">LinearSpringDamper_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[AutoDiffXd]" title="pydrake.multibody.tree.ForceElement_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ForceElement_[AutoDiffXd]</span></code></a></p>
<p>This ForceElement models a spring-damper attached between two points
on two different bodies. Given a point P on a body A and a point Q on
a body B with positions p_AP and p_BQ, respectively, this
spring-damper applies equal and opposite forces on bodies A and B
according to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>f_AP = (k⋅(ℓ - ℓ₀) + c⋅dℓ/dt)⋅r̂
  f_BQ = -f_AP
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">ℓ</span> <span class="pre">=</span> <span class="pre">‖p_WQ</span> <span class="pre">-</span> <span class="pre">p_WP‖</span></code> is the current length of the spring, dℓ/dt
its rate of change, <code class="docutils literal notranslate"><span class="pre">r̂</span> <span class="pre">=</span> <span class="pre">(p_WQ</span> <span class="pre">-</span> <span class="pre">p_WP)</span> <span class="pre">/</span> <span class="pre">ℓ</span></code> is the normalized
vector from P to Q, ℓ₀ is the free length of the spring and k and c
are the stiffness and damping of the spring-damper, respectively. This
ForceElement is meant to model finite free length springs attached
between two points. In this typical arrangement springs are usually
pre-loaded, meaning they apply a non-zero spring force in the static
configuration of the system. Thus, neither the free length ℓ₀ nor the
current length ℓ of the spring can ever be zero. The length of the
spring approaching zero would incur in a non-physical configuration
and therefore this element throws a RuntimeError exception in that
case. Note that:</p>
<ul class="simple">
<li>The applied force is always along the line connecting points P and</li>
</ul>
<p>Q. - Damping always dissipates energy. - Forces on bodies A and B are
equal and opposite according to Newton’s third law.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd], bodyA: pydrake.multibody.tree.Body_[AutoDiffXd], p_AP: numpy.ndarray[numpy.float64[3, 1]], bodyB: pydrake.multibody.tree.Body_[AutoDiffXd], p_BQ: numpy.ndarray[numpy.float64[3, 1]], free_length: float, stiffness: float, damping: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor for a spring-damper between a point P on <code class="docutils literal notranslate"><span class="pre">bodyA</span></code> and a
point Q on <code class="docutils literal notranslate"><span class="pre">bodyB</span></code>. Point P is defined by its position <code class="docutils literal notranslate"><span class="pre">p_AP</span></code> as
measured and expressed in the body frame A and similarly, point Q is
defined by its position p_BQ as measured and expressed in body frame
B. The remaining parameters define:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">free_length</span></code>:</dt>
<dd>The free length of the spring ℓ₀, in meters, at which the spring
applies no forces. Since this force element is meant to model
finite length springs, ℓ₀ must be strictly positive.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">stiffness</span></code>:</dt>
<dd>The stiffness k of the spring in N/m. It must be non-negative.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt>
<dd>The damping c of the damper in N⋅s/m. It must be non-negative.
Refer to this class’s documentation for further details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal notranslate"><span class="pre">free_length</span></code> is negative or zero.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal notranslate"><span class="pre">stiffness</span></code> is negative.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal notranslate"><span class="pre">damping</span></code> is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd].bodyA">
<code class="descname">bodyA</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd].bodyA" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd].bodyB">
<code class="descname">bodyB</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd].bodyB" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd].damping" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd].free_length">
<code class="descname">free_length</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd].free_length" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd].p_AP">
<code class="descname">p_AP</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd].p_AP" title="Permalink to this definition">¶</a></dt>
<dd><p>The position p_AP of point P on body A as measured and expressed in
body frame A.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd].p_BQ">
<code class="descname">p_BQ</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd].p_BQ" title="Permalink to this definition">¶</a></dt>
<dd><p>The position p_BQ of point Q on body B as measured and expressed in
body frame B.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd].stiffness">
<code class="descname">stiffness</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[AutoDiffXd].stiffness" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">LinearSpringDamper_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[Expression]" title="pydrake.multibody.tree.ForceElement_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ForceElement_[Expression]</span></code></a></p>
<p>This ForceElement models a spring-damper attached between two points
on two different bodies. Given a point P on a body A and a point Q on
a body B with positions p_AP and p_BQ, respectively, this
spring-damper applies equal and opposite forces on bodies A and B
according to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>f_AP = (k⋅(ℓ - ℓ₀) + c⋅dℓ/dt)⋅r̂
  f_BQ = -f_AP
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">ℓ</span> <span class="pre">=</span> <span class="pre">‖p_WQ</span> <span class="pre">-</span> <span class="pre">p_WP‖</span></code> is the current length of the spring, dℓ/dt
its rate of change, <code class="docutils literal notranslate"><span class="pre">r̂</span> <span class="pre">=</span> <span class="pre">(p_WQ</span> <span class="pre">-</span> <span class="pre">p_WP)</span> <span class="pre">/</span> <span class="pre">ℓ</span></code> is the normalized
vector from P to Q, ℓ₀ is the free length of the spring and k and c
are the stiffness and damping of the spring-damper, respectively. This
ForceElement is meant to model finite free length springs attached
between two points. In this typical arrangement springs are usually
pre-loaded, meaning they apply a non-zero spring force in the static
configuration of the system. Thus, neither the free length ℓ₀ nor the
current length ℓ of the spring can ever be zero. The length of the
spring approaching zero would incur in a non-physical configuration
and therefore this element throws a RuntimeError exception in that
case. Note that:</p>
<ul class="simple">
<li>The applied force is always along the line connecting points P and</li>
</ul>
<p>Q. - Damping always dissipates energy. - Forces on bodies A and B are
equal and opposite according to Newton’s third law.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[Expression], bodyA: pydrake.multibody.tree.Body_[Expression], p_AP: numpy.ndarray[numpy.float64[3, 1]], bodyB: pydrake.multibody.tree.Body_[Expression], p_BQ: numpy.ndarray[numpy.float64[3, 1]], free_length: float, stiffness: float, damping: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor for a spring-damper between a point P on <code class="docutils literal notranslate"><span class="pre">bodyA</span></code> and a
point Q on <code class="docutils literal notranslate"><span class="pre">bodyB</span></code>. Point P is defined by its position <code class="docutils literal notranslate"><span class="pre">p_AP</span></code> as
measured and expressed in the body frame A and similarly, point Q is
defined by its position p_BQ as measured and expressed in body frame
B. The remaining parameters define:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">free_length</span></code>:</dt>
<dd>The free length of the spring ℓ₀, in meters, at which the spring
applies no forces. Since this force element is meant to model
finite length springs, ℓ₀ must be strictly positive.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">stiffness</span></code>:</dt>
<dd>The stiffness k of the spring in N/m. It must be non-negative.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt>
<dd>The damping c of the damper in N⋅s/m. It must be non-negative.
Refer to this class’s documentation for further details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal notranslate"><span class="pre">free_length</span></code> is negative or zero.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal notranslate"><span class="pre">stiffness</span></code> is negative.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal notranslate"><span class="pre">damping</span></code> is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[Expression].bodyA">
<code class="descname">bodyA</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[Expression].bodyA" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[Expression].bodyB">
<code class="descname">bodyB</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[Expression].bodyB" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[Expression].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[Expression].damping" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[Expression].free_length">
<code class="descname">free_length</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[Expression].free_length" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[Expression].p_AP">
<code class="descname">p_AP</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[Expression].p_AP" title="Permalink to this definition">¶</a></dt>
<dd><p>The position p_AP of point P on body A as measured and expressed in
body frame A.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[Expression].p_BQ">
<code class="descname">p_BQ</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[Expression].p_BQ" title="Permalink to this definition">¶</a></dt>
<dd><p>The position p_BQ of point Q on body B as measured and expressed in
body frame B.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[Expression].stiffness">
<code class="descname">stiffness</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[Expression].stiffness" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">LinearSpringDamper_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[float]" title="pydrake.multibody.tree.ForceElement_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ForceElement_[float]</span></code></a></p>
<p>This ForceElement models a spring-damper attached between two points
on two different bodies. Given a point P on a body A and a point Q on
a body B with positions p_AP and p_BQ, respectively, this
spring-damper applies equal and opposite forces on bodies A and B
according to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>f_AP = (k⋅(ℓ - ℓ₀) + c⋅dℓ/dt)⋅r̂
  f_BQ = -f_AP
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">ℓ</span> <span class="pre">=</span> <span class="pre">‖p_WQ</span> <span class="pre">-</span> <span class="pre">p_WP‖</span></code> is the current length of the spring, dℓ/dt
its rate of change, <code class="docutils literal notranslate"><span class="pre">r̂</span> <span class="pre">=</span> <span class="pre">(p_WQ</span> <span class="pre">-</span> <span class="pre">p_WP)</span> <span class="pre">/</span> <span class="pre">ℓ</span></code> is the normalized
vector from P to Q, ℓ₀ is the free length of the spring and k and c
are the stiffness and damping of the spring-damper, respectively. This
ForceElement is meant to model finite free length springs attached
between two points. In this typical arrangement springs are usually
pre-loaded, meaning they apply a non-zero spring force in the static
configuration of the system. Thus, neither the free length ℓ₀ nor the
current length ℓ of the spring can ever be zero. The length of the
spring approaching zero would incur in a non-physical configuration
and therefore this element throws a RuntimeError exception in that
case. Note that:</p>
<ul class="simple">
<li>The applied force is always along the line connecting points P and</li>
</ul>
<p>Q. - Damping always dissipates energy. - Forces on bodies A and B are
equal and opposite according to Newton’s third law.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[float], bodyA: pydrake.multibody.tree.Body_[float], p_AP: numpy.ndarray[numpy.float64[3, 1]], bodyB: pydrake.multibody.tree.Body_[float], p_BQ: numpy.ndarray[numpy.float64[3, 1]], free_length: float, stiffness: float, damping: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor for a spring-damper between a point P on <code class="docutils literal notranslate"><span class="pre">bodyA</span></code> and a
point Q on <code class="docutils literal notranslate"><span class="pre">bodyB</span></code>. Point P is defined by its position <code class="docutils literal notranslate"><span class="pre">p_AP</span></code> as
measured and expressed in the body frame A and similarly, point Q is
defined by its position p_BQ as measured and expressed in body frame
B. The remaining parameters define:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">free_length</span></code>:</dt>
<dd>The free length of the spring ℓ₀, in meters, at which the spring
applies no forces. Since this force element is meant to model
finite length springs, ℓ₀ must be strictly positive.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">stiffness</span></code>:</dt>
<dd>The stiffness k of the spring in N/m. It must be non-negative.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt>
<dd>The damping c of the damper in N⋅s/m. It must be non-negative.
Refer to this class’s documentation for further details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal notranslate"><span class="pre">free_length</span></code> is negative or zero.</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal notranslate"><span class="pre">stiffness</span></code> is negative.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal notranslate"><span class="pre">damping</span></code> is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[float].bodyA">
<code class="descname">bodyA</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[float]<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[float].bodyA" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[float].bodyB">
<code class="descname">bodyB</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.Body_[float]<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[float].bodyB" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[float].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[float].damping" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[float].free_length">
<code class="descname">free_length</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[float].free_length" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[float].p_AP">
<code class="descname">p_AP</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[float].p_AP" title="Permalink to this definition">¶</a></dt>
<dd><p>The position p_AP of point P on body A as measured and expressed in
body frame A.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[float].p_BQ">
<code class="descname">p_BQ</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[float].p_BQ" title="Permalink to this definition">¶</a></dt>
<dd><p>The position p_BQ of point Q on body B as measured and expressed in
body frame B.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.LinearSpringDamper_[float].stiffness">
<code class="descname">stiffness</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.LinearSpringDamper_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.LinearSpringDamper_[float].stiffness" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.ModelInstanceIndex">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">ModelInstanceIndex</code><a class="headerlink" href="#pydrake.multibody.tree.ModelInstanceIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Type used to identify model instances by index within a multibody tree
system.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.ModelInstanceIndex.__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.ModelInstanceIndex.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.ModelInstanceIndex) -&gt; None</li>
</ol>
<p>Default constructor; the result is an <em>invalid</em> index. This only
exists to serve applications which require a default constructor.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.ModelInstanceIndex, arg0: int) -&gt; None</li>
</ol>
<p>Construction from a non-negative <code class="docutils literal notranslate"><span class="pre">int</span></code> value. The value must lie in
the range of [0, 2³¹). Constructor only promises to test validity in
Debug build.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ModelInstanceIndex.is_valid">
<code class="descname">is_valid</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ModelInstanceIndex</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.ModelInstanceIndex.is_valid" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports if the index is valid–the only operation on an invalid index
that doesn’t throw an exception in Debug builds.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.MultibodyForces">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">MultibodyForces</code><a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.MultibodyForces_[float]" title="pydrake.multibody.tree.MultibodyForces_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.MultibodyForces_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.MultibodyForces_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">MultibodyForces_</code><a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.MultibodyForces_[float]" title="pydrake.multibody.tree.MultibodyForces_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultibodyForces_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.MultibodyForces_[AutoDiffXd]" title="pydrake.multibody.tree.MultibodyForces_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultibodyForces_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.MultibodyForces_[Expression]" title="pydrake.multibody.tree.MultibodyForces_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultibodyForces_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.MultibodyForces_.MultibodyForces_[float]">
<em class="property">class </em><code class="descname">MultibodyForces_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_.MultibodyForces_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>A class to hold a set of forces applied to a MultibodyTree system.
Forces can include generalized forces as well as body spatial forces.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_.MultibodyForces_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_.MultibodyForces_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.MultibodyForces_[float], plant: drake::multibody::MultibodyPlant&lt;double&gt;) -&gt; None</li>
</ol>
<p>Constructs a force object to store a set of forces to be applied to
the multibody model for <code class="docutils literal notranslate"><span class="pre">plant</span></code>. Forces are initialized to zero,
meaning no forces are applied. <code class="docutils literal notranslate"><span class="pre">plant</span></code> must have been already
finalized with MultibodyPlant::Finalize() or this constructor will
abort.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.MultibodyForces_[float], nb: int, nv: int) -&gt; None</li>
</ol>
<p>Number of bodies and number of generalized velocities overload. This
constructor is useful for constructing the MultibodyForces structure
before a MultibodyPlant has been consructed.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_.MultibodyForces_[float].AddInForces">
<code class="descname">AddInForces</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[float], addend: pydrake.multibody.tree.MultibodyForces_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_.MultibodyForces_[float].AddInForces" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds into <code class="docutils literal notranslate"><span class="pre">this</span></code> the force contribution stored in <code class="docutils literal notranslate"><span class="pre">addend</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_.MultibodyForces_[float].generalized_forces">
<code class="descname">generalized_forces</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_.MultibodyForces_[float].generalized_forces" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Returns a constant reference to the vector of generalized
forces stored by <code class="docutils literal notranslate"><span class="pre">this</span></code> forces object.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_.MultibodyForces_[float].mutable_generalized_forces">
<code class="descname">mutable_generalized_forces</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_.MultibodyForces_[float].mutable_generalized_forces" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Mutable version of generalized_forces().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_.MultibodyForces_[float].num_bodies">
<code class="descname">num_bodies</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_.MultibodyForces_[float].num_bodies" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of bodies for which <code class="docutils literal notranslate"><span class="pre">this</span></code> force object applies.
Determined at construction from the given model MultibodyTree object.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_.MultibodyForces_[float].num_velocities">
<code class="descname">num_velocities</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_.MultibodyForces_[float].num_velocities" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of generalized velocities for the model to which
these forces apply. The number of generalized forces in a multibody
model always equals the number of generalized velocities. Determined
at construction from the given model MultibodyTree object.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_.MultibodyForces_[float].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.MultibodyForces_[float]<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_.MultibodyForces_[float].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> to store zero forces (no applied forces).</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.MultibodyForces_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">MultibodyForces_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>A class to hold a set of forces applied to a MultibodyTree system.
Forces can include generalized forces as well as body spatial forces.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.MultibodyForces_[AutoDiffXd], plant: drake::multibody::MultibodyPlant&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;) -&gt; None</li>
</ol>
<p>Constructs a force object to store a set of forces to be applied to
the multibody model for <code class="docutils literal notranslate"><span class="pre">plant</span></code>. Forces are initialized to zero,
meaning no forces are applied. <code class="docutils literal notranslate"><span class="pre">plant</span></code> must have been already
finalized with MultibodyPlant::Finalize() or this constructor will
abort.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.MultibodyForces_[AutoDiffXd], nb: int, nv: int) -&gt; None</li>
</ol>
<p>Number of bodies and number of generalized velocities overload. This
constructor is useful for constructing the MultibodyForces structure
before a MultibodyPlant has been consructed.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_[AutoDiffXd].AddInForces">
<code class="descname">AddInForces</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[AutoDiffXd], addend: pydrake.multibody.tree.MultibodyForces_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_[AutoDiffXd].AddInForces" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds into <code class="docutils literal notranslate"><span class="pre">this</span></code> the force contribution stored in <code class="docutils literal notranslate"><span class="pre">addend</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_[AutoDiffXd].generalized_forces">
<code class="descname">generalized_forces</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_[AutoDiffXd].generalized_forces" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Returns a constant reference to the vector of generalized
forces stored by <code class="docutils literal notranslate"><span class="pre">this</span></code> forces object.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_[AutoDiffXd].mutable_generalized_forces">
<code class="descname">mutable_generalized_forces</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_[AutoDiffXd].mutable_generalized_forces" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Mutable version of generalized_forces().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_[AutoDiffXd].num_bodies">
<code class="descname">num_bodies</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_[AutoDiffXd].num_bodies" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of bodies for which <code class="docutils literal notranslate"><span class="pre">this</span></code> force object applies.
Determined at construction from the given model MultibodyTree object.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_[AutoDiffXd].num_velocities">
<code class="descname">num_velocities</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_[AutoDiffXd].num_velocities" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of generalized velocities for the model to which
these forces apply. The number of generalized forces in a multibody
model always equals the number of generalized velocities. Determined
at construction from the given model MultibodyTree object.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_[AutoDiffXd].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.MultibodyForces_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_[AutoDiffXd].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> to store zero forces (no applied forces).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.MultibodyForces_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">MultibodyForces_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>A class to hold a set of forces applied to a MultibodyTree system.
Forces can include generalized forces as well as body spatial forces.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.MultibodyForces_[Expression], plant: drake::multibody::MultibodyPlant&lt;drake::symbolic::Expression&gt;) -&gt; None</li>
</ol>
<p>Constructs a force object to store a set of forces to be applied to
the multibody model for <code class="docutils literal notranslate"><span class="pre">plant</span></code>. Forces are initialized to zero,
meaning no forces are applied. <code class="docutils literal notranslate"><span class="pre">plant</span></code> must have been already
finalized with MultibodyPlant::Finalize() or this constructor will
abort.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.MultibodyForces_[Expression], nb: int, nv: int) -&gt; None</li>
</ol>
<p>Number of bodies and number of generalized velocities overload. This
constructor is useful for constructing the MultibodyForces structure
before a MultibodyPlant has been consructed.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_[Expression].AddInForces">
<code class="descname">AddInForces</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[Expression], addend: pydrake.multibody.tree.MultibodyForces_[Expression]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_[Expression].AddInForces" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds into <code class="docutils literal notranslate"><span class="pre">this</span></code> the force contribution stored in <code class="docutils literal notranslate"><span class="pre">addend</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_[Expression].generalized_forces">
<code class="descname">generalized_forces</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_[Expression].generalized_forces" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Returns a constant reference to the vector of generalized
forces stored by <code class="docutils literal notranslate"><span class="pre">this</span></code> forces object.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_[Expression].mutable_generalized_forces">
<code class="descname">mutable_generalized_forces</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_[Expression].mutable_generalized_forces" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Mutable version of generalized_forces().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_[Expression].num_bodies">
<code class="descname">num_bodies</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[Expression]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_[Expression].num_bodies" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of bodies for which <code class="docutils literal notranslate"><span class="pre">this</span></code> force object applies.
Determined at construction from the given model MultibodyTree object.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_[Expression].num_velocities">
<code class="descname">num_velocities</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[Expression]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_[Expression].num_velocities" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of generalized velocities for the model to which
these forces apply. The number of generalized forces in a multibody
model always equals the number of generalized velocities. Determined
at construction from the given model MultibodyTree object.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_[Expression].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.MultibodyForces_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_[Expression].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> to store zero forces (no applied forces).</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.MultibodyForces_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">MultibodyForces_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>A class to hold a set of forces applied to a MultibodyTree system.
Forces can include generalized forces as well as body spatial forces.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.MultibodyForces_[float], plant: drake::multibody::MultibodyPlant&lt;double&gt;) -&gt; None</li>
</ol>
<p>Constructs a force object to store a set of forces to be applied to
the multibody model for <code class="docutils literal notranslate"><span class="pre">plant</span></code>. Forces are initialized to zero,
meaning no forces are applied. <code class="docutils literal notranslate"><span class="pre">plant</span></code> must have been already
finalized with MultibodyPlant::Finalize() or this constructor will
abort.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.MultibodyForces_[float], nb: int, nv: int) -&gt; None</li>
</ol>
<p>Number of bodies and number of generalized velocities overload. This
constructor is useful for constructing the MultibodyForces structure
before a MultibodyPlant has been consructed.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_[float].AddInForces">
<code class="descname">AddInForces</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[float], addend: pydrake.multibody.tree.MultibodyForces_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_[float].AddInForces" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds into <code class="docutils literal notranslate"><span class="pre">this</span></code> the force contribution stored in <code class="docutils literal notranslate"><span class="pre">addend</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_[float].generalized_forces">
<code class="descname">generalized_forces</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_[float].generalized_forces" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Returns a constant reference to the vector of generalized
forces stored by <code class="docutils literal notranslate"><span class="pre">this</span></code> forces object.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_[float].mutable_generalized_forces">
<code class="descname">mutable_generalized_forces</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_[float].mutable_generalized_forces" title="Permalink to this definition">¶</a></dt>
<dd><p>(Advanced) Mutable version of generalized_forces().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_[float].num_bodies">
<code class="descname">num_bodies</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_[float].num_bodies" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of bodies for which <code class="docutils literal notranslate"><span class="pre">this</span></code> force object applies.
Determined at construction from the given model MultibodyTree object.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_[float].num_velocities">
<code class="descname">num_velocities</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_[float].num_velocities" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of generalized velocities for the model to which
these forces apply. The number of generalized forces in a multibody
model always equals the number of generalized velocities. Determined
at construction from the given model MultibodyTree object.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.MultibodyForces_[float].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.MultibodyForces_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.MultibodyForces_[float]<a class="headerlink" href="#pydrake.multibody.tree.MultibodyForces_[float].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> to store zero forces (no applied forces).</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.PlanarJoint">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">PlanarJoint</code><a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.PlanarJoint_[float]" title="pydrake.multibody.tree.PlanarJoint_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.PlanarJoint_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.PlanarJoint_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">PlanarJoint_</code><a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.PlanarJoint_[float]" title="pydrake.multibody.tree.PlanarJoint_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">PlanarJoint_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.PlanarJoint_[AutoDiffXd]" title="pydrake.multibody.tree.PlanarJoint_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">PlanarJoint_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.PlanarJoint_[Expression]" title="pydrake.multibody.tree.PlanarJoint_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">PlanarJoint_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.PlanarJoint_.PlanarJoint_[float]">
<em class="property">class </em><code class="descname">PlanarJoint_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_.PlanarJoint_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[float]" title="pydrake.multibody.tree.Joint_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[float]</span></code></a></p>
<p>This joint models a planar joint allowing two bodies to translate and
rotate relative to one another in a plane with three degrees of
freedom. That is, given a frame F attached to the parent body P and a
frame M attached to the child body B (see the Joint class’s
documentation), this joint allows frame M to translate within the x-y
plane of frame F and to rotate about the z-axis, with M’s z-axis Mz
and F’s z-axis Fz coincident at all times. The translations along the
x- and y-axes of F, the rotation about the z-axis and their rates
specify the state of the joint. Zero (x, y, θ) corresponds to frames F
and M being coincident and aligned. Translation (x, y) is defined to
be positive in the direction of the respective axes and the rotation θ
is defined to be positive according to the right-hand-rule with the
thumb aligned in the direction of frame F’s z-axis.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_.PlanarJoint_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[float], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[float], frame_on_child: pydrake.multibody.tree.Frame_[float], damping: numpy.ndarray[numpy.float64[3, 1]] = array([0., 0., 0.])</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_.PlanarJoint_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor to create a planar joint between two bodies so that frame
F attached to the parent body P and frame M attached to the child body
B translate and rotate as described in the class’s documentation. This
constructor signature creates a joint with no joint limits, i.e. the
joint position, velocity and acceleration limits are the pair <code class="docutils literal notranslate"><span class="pre">(-∞,</span>
<span class="pre">∞)</span></code>. These can be set using the Joint methods set_position_limits(),
set_velocity_limits() and set_acceleration_limits(). The first three
arguments to this constructor are those of the Joint class
constructor. See the Joint class’s documentation for details. The
additional parameters are:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, in N⋅s/m for translation and N⋅m⋅s
for rotation, used to model losses within the joint. See
documentation of damping() for details on modelling of the damping
force and torque.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if any element of damping is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_.PlanarJoint_[float].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_.PlanarJoint_[float].damping" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s damping constant in N⋅s/m for the
translational degrees and N⋅m⋅s for the rotational degree. The damping
force (in N) is modeled as <code class="docutils literal notranslate"><span class="pre">fᵢ</span> <span class="pre">=</span> <span class="pre">-dampingᵢ⋅vᵢ,</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">2</span></code> i.e.
opposing motion, with vᵢ the translation rates along the i-th axis for
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see get_translational_velocity()) and fᵢ the force on
child body B at Mo and expressed in F. That is, f_BMo_F = (f₁, f₂).
The damping torque (in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span> <span class="pre">-damping₃⋅ω</span></code> i.e.
opposing motion, with ω the angular rate for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see
get_angular_velocity()) and τ the torque on child body B expressed in
frame F as t_B_F = τ⋅Fz_F.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_.PlanarJoint_[float].get_angular_velocity">
<code class="descname">get_angular_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_.PlanarJoint_[float].get_angular_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rate of change, in radians per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
angle θ from <code class="docutils literal notranslate"><span class="pre">context</span></code>. See class documentation for the definition
of this angle.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>:</dt>
<dd>The rate of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s angle θ as stored in the
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_.PlanarJoint_[float].get_default_rotation">
<code class="descname">get_default_rotation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_.PlanarJoint_[float].get_default_rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default angle for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt>
<dd>The default angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_.PlanarJoint_[float].get_default_translation">
<code class="descname">get_default_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[2, 1]]<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_.PlanarJoint_[float].get_default_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default position for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>:</dt>
<dd>The default position of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_.PlanarJoint_[float].get_rotation">
<code class="descname">get_rotation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_.PlanarJoint_[float].get_rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the angle θ of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt>
<dd>The angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code>. See class
documentation for details.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_.PlanarJoint_[float].get_translation">
<code class="descname">get_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[2, 1]]<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_.PlanarJoint_[float].get_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the position of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>:</dt>
<dd>The position of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code> ordered
as (x, y). See class documentation for details.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_.PlanarJoint_[float].get_translational_velocity">
<code class="descname">get_translational_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[2, 1]]<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_.PlanarJoint_[float].get_translational_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the translational velocity v_FoMo_F, in meters per second, of
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s Mo measured and expressed in frame F from
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">v_FoMo_F</span></code>:</dt>
<dd>The translational velocity of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint as stored in the
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_.PlanarJoint_[float].set_angular_velocity">
<code class="descname">set_angular_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[float], context: pydrake.systems.framework.Context_[float], theta_dot: float</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.PlanarJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_.PlanarJoint_[float].set_angular_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the rate of change, in radians per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
angle θ (see class documentation) to <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>. The new rate of
change gets stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>:</dt>
<dd>The desired rates of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s angle in radians
per second.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_.PlanarJoint_[float].set_default_pose">
<code class="descname">set_default_pose</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[float], p_FoMo_F: numpy.ndarray[numpy.float64[2, 1]], theta: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_.PlanarJoint_[float].set_default_pose" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default position and angle of this joint.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>:</dt>
<dd>The desired default position of the joint</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt>
<dd>The desired default angle of the joint</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_.PlanarJoint_[float].set_default_rotation">
<code class="descname">set_default_rotation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[float], theta: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_.PlanarJoint_[float].set_default_rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default angle of this joint.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt>
<dd>The desired default angle of the joint</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_.PlanarJoint_[float].set_default_translation">
<code class="descname">set_default_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[float], p_FoMo_F: numpy.ndarray[numpy.float64[2, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_.PlanarJoint_[float].set_default_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default position of this joint.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>:</dt>
<dd>The desired default position of the joint</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_.PlanarJoint_[float].set_pose">
<code class="descname">set_pose</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[float], context: pydrake.systems.framework.Context_[float], p_FoMo_F: numpy.ndarray[numpy.float64[2, 1]], theta: float</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.PlanarJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_.PlanarJoint_[float].set_pose" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the position of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals
<code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code> and its angle equals <code class="docutils literal notranslate"><span class="pre">theta</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>:</dt>
<dd>The desired position in meters to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> ordered
as (x, y). See class documentation for details.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt>
<dd>The desired angle in radians to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>. See
class documentation for details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_.PlanarJoint_[float].set_random_pose_distribution">
<code class="descname">set_random_pose_distribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[float], p_FoMo_F: numpy.ndarray[object[2, 1]], theta: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_.PlanarJoint_[float].set_random_pose_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the random distribution that the position and angle of this joint
will be randomly sampled from. See class documentation for details on
the definition of the position and angle.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_.PlanarJoint_[float].set_rotation">
<code class="descname">set_rotation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[float], context: pydrake.systems.framework.Context_[float], theta: float</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.PlanarJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_.PlanarJoint_[float].set_rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the angle θ of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals
<code class="docutils literal notranslate"><span class="pre">theta</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt>
<dd>The desired angle in radians to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>. See
class documentation for details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_.PlanarJoint_[float].set_translation">
<code class="descname">set_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[float], context: pydrake.systems.framework.Context_[float], p_FoMo_F: numpy.ndarray[numpy.float64[2, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.PlanarJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_.PlanarJoint_[float].set_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the position of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals
<code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>:</dt>
<dd>The desired position in meters to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> ordered
as (x, y). See class documentation for details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_.PlanarJoint_[float].set_translational_velocity">
<code class="descname">set_translational_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[float], context: pydrake.systems.framework.Context_[float], v_FoMo_F: numpy.ndarray[numpy.float64[2, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.PlanarJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_.PlanarJoint_[float].set_translational_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the translational velocity, in meters per second, of this
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s Mo measured and expressed in frame F to <code class="docutils literal notranslate"><span class="pre">v_FoMo_F</span></code>.
The new translational velocity gets stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v_FoMo_F</span></code>:</dt>
<dd>The desired translational velocity of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters per
second.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.PlanarJoint_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">PlanarJoint_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[AutoDiffXd]" title="pydrake.multibody.tree.Joint_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd]</span></code></a></p>
<p>This joint models a planar joint allowing two bodies to translate and
rotate relative to one another in a plane with three degrees of
freedom. That is, given a frame F attached to the parent body P and a
frame M attached to the child body B (see the Joint class’s
documentation), this joint allows frame M to translate within the x-y
plane of frame F and to rotate about the z-axis, with M’s z-axis Mz
and F’s z-axis Fz coincident at all times. The translations along the
x- and y-axes of F, the rotation about the z-axis and their rates
specify the state of the joint. Zero (x, y, θ) corresponds to frames F
and M being coincident and aligned. Translation (x, y) is defined to
be positive in the direction of the respective axes and the rotation θ
is defined to be positive according to the right-hand-rule with the
thumb aligned in the direction of frame F’s z-axis.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[AutoDiffXd], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_on_child: pydrake.multibody.tree.Frame_[AutoDiffXd], damping: numpy.ndarray[numpy.float64[3, 1]] = array([0., 0., 0.])</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor to create a planar joint between two bodies so that frame
F attached to the parent body P and frame M attached to the child body
B translate and rotate as described in the class’s documentation. This
constructor signature creates a joint with no joint limits, i.e. the
joint position, velocity and acceleration limits are the pair <code class="docutils literal notranslate"><span class="pre">(-∞,</span>
<span class="pre">∞)</span></code>. These can be set using the Joint methods set_position_limits(),
set_velocity_limits() and set_acceleration_limits(). The first three
arguments to this constructor are those of the Joint class
constructor. See the Joint class’s documentation for details. The
additional parameters are:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, in N⋅s/m for translation and N⋅m⋅s
for rotation, used to model losses within the joint. See
documentation of damping() for details on modelling of the damping
force and torque.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if any element of damping is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[AutoDiffXd].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[AutoDiffXd].damping" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s damping constant in N⋅s/m for the
translational degrees and N⋅m⋅s for the rotational degree. The damping
force (in N) is modeled as <code class="docutils literal notranslate"><span class="pre">fᵢ</span> <span class="pre">=</span> <span class="pre">-dampingᵢ⋅vᵢ,</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">2</span></code> i.e.
opposing motion, with vᵢ the translation rates along the i-th axis for
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see get_translational_velocity()) and fᵢ the force on
child body B at Mo and expressed in F. That is, f_BMo_F = (f₁, f₂).
The damping torque (in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span> <span class="pre">-damping₃⋅ω</span></code> i.e.
opposing motion, with ω the angular rate for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see
get_angular_velocity()) and τ the torque on child body B expressed in
frame F as t_B_F = τ⋅Fz_F.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[AutoDiffXd].get_angular_velocity">
<code class="descname">get_angular_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.autodiffutils.AutoDiffXd<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[AutoDiffXd].get_angular_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rate of change, in radians per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
angle θ from <code class="docutils literal notranslate"><span class="pre">context</span></code>. See class documentation for the definition
of this angle.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>:</dt>
<dd>The rate of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s angle θ as stored in the
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[AutoDiffXd].get_default_rotation">
<code class="descname">get_default_rotation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[AutoDiffXd].get_default_rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default angle for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt>
<dd>The default angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[AutoDiffXd].get_default_translation">
<code class="descname">get_default_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[2, 1]]<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[AutoDiffXd].get_default_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default position for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>:</dt>
<dd>The default position of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[AutoDiffXd].get_rotation">
<code class="descname">get_rotation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.autodiffutils.AutoDiffXd<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[AutoDiffXd].get_rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the angle θ of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt>
<dd>The angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code>. See class
documentation for details.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[AutoDiffXd].get_translation">
<code class="descname">get_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[2, 1]]<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[AutoDiffXd].get_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the position of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>:</dt>
<dd>The position of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code> ordered
as (x, y). See class documentation for details.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[AutoDiffXd].get_translational_velocity">
<code class="descname">get_translational_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[2, 1]]<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[AutoDiffXd].get_translational_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the translational velocity v_FoMo_F, in meters per second, of
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s Mo measured and expressed in frame F from
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">v_FoMo_F</span></code>:</dt>
<dd>The translational velocity of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint as stored in the
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[AutoDiffXd].set_angular_velocity">
<code class="descname">set_angular_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], theta_dot: pydrake.autodiffutils.AutoDiffXd</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.PlanarJoint_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[AutoDiffXd].set_angular_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the rate of change, in radians per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
angle θ (see class documentation) to <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>. The new rate of
change gets stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>:</dt>
<dd>The desired rates of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s angle in radians
per second.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[AutoDiffXd].set_default_pose">
<code class="descname">set_default_pose</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[AutoDiffXd], p_FoMo_F: numpy.ndarray[numpy.float64[2, 1]], theta: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[AutoDiffXd].set_default_pose" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default position and angle of this joint.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>:</dt>
<dd>The desired default position of the joint</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt>
<dd>The desired default angle of the joint</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[AutoDiffXd].set_default_rotation">
<code class="descname">set_default_rotation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[AutoDiffXd], theta: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[AutoDiffXd].set_default_rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default angle of this joint.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt>
<dd>The desired default angle of the joint</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[AutoDiffXd].set_default_translation">
<code class="descname">set_default_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[AutoDiffXd], p_FoMo_F: numpy.ndarray[numpy.float64[2, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[AutoDiffXd].set_default_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default position of this joint.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>:</dt>
<dd>The desired default position of the joint</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[AutoDiffXd].set_pose">
<code class="descname">set_pose</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], p_FoMo_F: numpy.ndarray[object[2, 1]], theta: pydrake.autodiffutils.AutoDiffXd</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.PlanarJoint_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[AutoDiffXd].set_pose" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the position of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals
<code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code> and its angle equals <code class="docutils literal notranslate"><span class="pre">theta</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>:</dt>
<dd>The desired position in meters to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> ordered
as (x, y). See class documentation for details.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt>
<dd>The desired angle in radians to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>. See
class documentation for details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[AutoDiffXd].set_random_pose_distribution">
<code class="descname">set_random_pose_distribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[AutoDiffXd], p_FoMo_F: numpy.ndarray[object[2, 1]], theta: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[AutoDiffXd].set_random_pose_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the random distribution that the position and angle of this joint
will be randomly sampled from. See class documentation for details on
the definition of the position and angle.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[AutoDiffXd].set_rotation">
<code class="descname">set_rotation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], theta: pydrake.autodiffutils.AutoDiffXd</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.PlanarJoint_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[AutoDiffXd].set_rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the angle θ of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals
<code class="docutils literal notranslate"><span class="pre">theta</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt>
<dd>The desired angle in radians to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>. See
class documentation for details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[AutoDiffXd].set_translation">
<code class="descname">set_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], p_FoMo_F: numpy.ndarray[object[2, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.PlanarJoint_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[AutoDiffXd].set_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the position of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals
<code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>:</dt>
<dd>The desired position in meters to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> ordered
as (x, y). See class documentation for details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[AutoDiffXd].set_translational_velocity">
<code class="descname">set_translational_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], v_FoMo_F: numpy.ndarray[object[2, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.PlanarJoint_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[AutoDiffXd].set_translational_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the translational velocity, in meters per second, of this
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s Mo measured and expressed in frame F to <code class="docutils literal notranslate"><span class="pre">v_FoMo_F</span></code>.
The new translational velocity gets stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v_FoMo_F</span></code>:</dt>
<dd>The desired translational velocity of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters per
second.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.PlanarJoint_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">PlanarJoint_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[Expression]" title="pydrake.multibody.tree.Joint_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[Expression]</span></code></a></p>
<p>This joint models a planar joint allowing two bodies to translate and
rotate relative to one another in a plane with three degrees of
freedom. That is, given a frame F attached to the parent body P and a
frame M attached to the child body B (see the Joint class’s
documentation), this joint allows frame M to translate within the x-y
plane of frame F and to rotate about the z-axis, with M’s z-axis Mz
and F’s z-axis Fz coincident at all times. The translations along the
x- and y-axes of F, the rotation about the z-axis and their rates
specify the state of the joint. Zero (x, y, θ) corresponds to frames F
and M being coincident and aligned. Translation (x, y) is defined to
be positive in the direction of the respective axes and the rotation θ
is defined to be positive according to the right-hand-rule with the
thumb aligned in the direction of frame F’s z-axis.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[Expression], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[Expression], frame_on_child: pydrake.multibody.tree.Frame_[Expression], damping: numpy.ndarray[numpy.float64[3, 1]] = array([0., 0., 0.])</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor to create a planar joint between two bodies so that frame
F attached to the parent body P and frame M attached to the child body
B translate and rotate as described in the class’s documentation. This
constructor signature creates a joint with no joint limits, i.e. the
joint position, velocity and acceleration limits are the pair <code class="docutils literal notranslate"><span class="pre">(-∞,</span>
<span class="pre">∞)</span></code>. These can be set using the Joint methods set_position_limits(),
set_velocity_limits() and set_acceleration_limits(). The first three
arguments to this constructor are those of the Joint class
constructor. See the Joint class’s documentation for details. The
additional parameters are:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, in N⋅s/m for translation and N⋅m⋅s
for rotation, used to model losses within the joint. See
documentation of damping() for details on modelling of the damping
force and torque.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if any element of damping is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[Expression].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[Expression].damping" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s damping constant in N⋅s/m for the
translational degrees and N⋅m⋅s for the rotational degree. The damping
force (in N) is modeled as <code class="docutils literal notranslate"><span class="pre">fᵢ</span> <span class="pre">=</span> <span class="pre">-dampingᵢ⋅vᵢ,</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">2</span></code> i.e.
opposing motion, with vᵢ the translation rates along the i-th axis for
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see get_translational_velocity()) and fᵢ the force on
child body B at Mo and expressed in F. That is, f_BMo_F = (f₁, f₂).
The damping torque (in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span> <span class="pre">-damping₃⋅ω</span></code> i.e.
opposing motion, with ω the angular rate for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see
get_angular_velocity()) and τ the torque on child body B expressed in
frame F as t_B_F = τ⋅Fz_F.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[Expression].get_angular_velocity">
<code class="descname">get_angular_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[Expression].get_angular_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rate of change, in radians per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
angle θ from <code class="docutils literal notranslate"><span class="pre">context</span></code>. See class documentation for the definition
of this angle.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>:</dt>
<dd>The rate of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s angle θ as stored in the
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[Expression].get_default_rotation">
<code class="descname">get_default_rotation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[Expression].get_default_rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default angle for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt>
<dd>The default angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[Expression].get_default_translation">
<code class="descname">get_default_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[2, 1]]<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[Expression].get_default_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default position for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>:</dt>
<dd>The default position of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[Expression].get_rotation">
<code class="descname">get_rotation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[Expression].get_rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the angle θ of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt>
<dd>The angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code>. See class
documentation for details.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[Expression].get_translation">
<code class="descname">get_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[2, 1]]<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[Expression].get_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the position of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>:</dt>
<dd>The position of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code> ordered
as (x, y). See class documentation for details.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[Expression].get_translational_velocity">
<code class="descname">get_translational_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[2, 1]]<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[Expression].get_translational_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the translational velocity v_FoMo_F, in meters per second, of
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s Mo measured and expressed in frame F from
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">v_FoMo_F</span></code>:</dt>
<dd>The translational velocity of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint as stored in the
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[Expression].set_angular_velocity">
<code class="descname">set_angular_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[Expression], context: pydrake.systems.framework.Context_[Expression], theta_dot: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.PlanarJoint_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[Expression].set_angular_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the rate of change, in radians per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
angle θ (see class documentation) to <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>. The new rate of
change gets stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>:</dt>
<dd>The desired rates of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s angle in radians
per second.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[Expression].set_default_pose">
<code class="descname">set_default_pose</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[Expression], p_FoMo_F: numpy.ndarray[numpy.float64[2, 1]], theta: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[Expression].set_default_pose" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default position and angle of this joint.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>:</dt>
<dd>The desired default position of the joint</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt>
<dd>The desired default angle of the joint</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[Expression].set_default_rotation">
<code class="descname">set_default_rotation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[Expression], theta: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[Expression].set_default_rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default angle of this joint.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt>
<dd>The desired default angle of the joint</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[Expression].set_default_translation">
<code class="descname">set_default_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[Expression], p_FoMo_F: numpy.ndarray[numpy.float64[2, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[Expression].set_default_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default position of this joint.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>:</dt>
<dd>The desired default position of the joint</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[Expression].set_pose">
<code class="descname">set_pose</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[Expression], context: pydrake.systems.framework.Context_[Expression], p_FoMo_F: numpy.ndarray[object[2, 1]], theta: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.PlanarJoint_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[Expression].set_pose" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the position of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals
<code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code> and its angle equals <code class="docutils literal notranslate"><span class="pre">theta</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>:</dt>
<dd>The desired position in meters to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> ordered
as (x, y). See class documentation for details.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt>
<dd>The desired angle in radians to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>. See
class documentation for details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[Expression].set_random_pose_distribution">
<code class="descname">set_random_pose_distribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[Expression], p_FoMo_F: numpy.ndarray[object[2, 1]], theta: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[Expression].set_random_pose_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the random distribution that the position and angle of this joint
will be randomly sampled from. See class documentation for details on
the definition of the position and angle.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[Expression].set_rotation">
<code class="descname">set_rotation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[Expression], context: pydrake.systems.framework.Context_[Expression], theta: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.PlanarJoint_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[Expression].set_rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the angle θ of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals
<code class="docutils literal notranslate"><span class="pre">theta</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt>
<dd>The desired angle in radians to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>. See
class documentation for details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[Expression].set_translation">
<code class="descname">set_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[Expression], context: pydrake.systems.framework.Context_[Expression], p_FoMo_F: numpy.ndarray[object[2, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.PlanarJoint_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[Expression].set_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the position of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals
<code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>:</dt>
<dd>The desired position in meters to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> ordered
as (x, y). See class documentation for details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[Expression].set_translational_velocity">
<code class="descname">set_translational_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[Expression], context: pydrake.systems.framework.Context_[Expression], v_FoMo_F: numpy.ndarray[object[2, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.PlanarJoint_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[Expression].set_translational_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the translational velocity, in meters per second, of this
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s Mo measured and expressed in frame F to <code class="docutils literal notranslate"><span class="pre">v_FoMo_F</span></code>.
The new translational velocity gets stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v_FoMo_F</span></code>:</dt>
<dd>The desired translational velocity of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters per
second.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.PlanarJoint_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">PlanarJoint_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[float]" title="pydrake.multibody.tree.Joint_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[float]</span></code></a></p>
<p>This joint models a planar joint allowing two bodies to translate and
rotate relative to one another in a plane with three degrees of
freedom. That is, given a frame F attached to the parent body P and a
frame M attached to the child body B (see the Joint class’s
documentation), this joint allows frame M to translate within the x-y
plane of frame F and to rotate about the z-axis, with M’s z-axis Mz
and F’s z-axis Fz coincident at all times. The translations along the
x- and y-axes of F, the rotation about the z-axis and their rates
specify the state of the joint. Zero (x, y, θ) corresponds to frames F
and M being coincident and aligned. Translation (x, y) is defined to
be positive in the direction of the respective axes and the rotation θ
is defined to be positive according to the right-hand-rule with the
thumb aligned in the direction of frame F’s z-axis.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[float], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[float], frame_on_child: pydrake.multibody.tree.Frame_[float], damping: numpy.ndarray[numpy.float64[3, 1]] = array([0., 0., 0.])</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor to create a planar joint between two bodies so that frame
F attached to the parent body P and frame M attached to the child body
B translate and rotate as described in the class’s documentation. This
constructor signature creates a joint with no joint limits, i.e. the
joint position, velocity and acceleration limits are the pair <code class="docutils literal notranslate"><span class="pre">(-∞,</span>
<span class="pre">∞)</span></code>. These can be set using the Joint methods set_position_limits(),
set_velocity_limits() and set_acceleration_limits(). The first three
arguments to this constructor are those of the Joint class
constructor. See the Joint class’s documentation for details. The
additional parameters are:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, in N⋅s/m for translation and N⋅m⋅s
for rotation, used to model losses within the joint. See
documentation of damping() for details on modelling of the damping
force and torque.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if any element of damping is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[float].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[float].damping" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s damping constant in N⋅s/m for the
translational degrees and N⋅m⋅s for the rotational degree. The damping
force (in N) is modeled as <code class="docutils literal notranslate"><span class="pre">fᵢ</span> <span class="pre">=</span> <span class="pre">-dampingᵢ⋅vᵢ,</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">2</span></code> i.e.
opposing motion, with vᵢ the translation rates along the i-th axis for
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see get_translational_velocity()) and fᵢ the force on
child body B at Mo and expressed in F. That is, f_BMo_F = (f₁, f₂).
The damping torque (in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span> <span class="pre">-damping₃⋅ω</span></code> i.e.
opposing motion, with ω the angular rate for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see
get_angular_velocity()) and τ the torque on child body B expressed in
frame F as t_B_F = τ⋅Fz_F.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[float].get_angular_velocity">
<code class="descname">get_angular_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[float].get_angular_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rate of change, in radians per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
angle θ from <code class="docutils literal notranslate"><span class="pre">context</span></code>. See class documentation for the definition
of this angle.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>:</dt>
<dd>The rate of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s angle θ as stored in the
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[float].get_default_rotation">
<code class="descname">get_default_rotation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[float].get_default_rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default angle for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt>
<dd>The default angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[float].get_default_translation">
<code class="descname">get_default_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[2, 1]]<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[float].get_default_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default position for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>:</dt>
<dd>The default position of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[float].get_rotation">
<code class="descname">get_rotation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[float].get_rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the angle θ of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt>
<dd>The angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code>. See class
documentation for details.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[float].get_translation">
<code class="descname">get_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[2, 1]]<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[float].get_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the position of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>:</dt>
<dd>The position of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code> ordered
as (x, y). See class documentation for details.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[float].get_translational_velocity">
<code class="descname">get_translational_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[2, 1]]<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[float].get_translational_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the translational velocity v_FoMo_F, in meters per second, of
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s Mo measured and expressed in frame F from
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">v_FoMo_F</span></code>:</dt>
<dd>The translational velocity of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint as stored in the
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[float].set_angular_velocity">
<code class="descname">set_angular_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[float], context: pydrake.systems.framework.Context_[float], theta_dot: float</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.PlanarJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[float].set_angular_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the rate of change, in radians per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
angle θ (see class documentation) to <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>. The new rate of
change gets stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>:</dt>
<dd>The desired rates of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s angle in radians
per second.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[float].set_default_pose">
<code class="descname">set_default_pose</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[float], p_FoMo_F: numpy.ndarray[numpy.float64[2, 1]], theta: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[float].set_default_pose" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default position and angle of this joint.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>:</dt>
<dd>The desired default position of the joint</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt>
<dd>The desired default angle of the joint</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[float].set_default_rotation">
<code class="descname">set_default_rotation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[float], theta: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[float].set_default_rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default angle of this joint.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt>
<dd>The desired default angle of the joint</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[float].set_default_translation">
<code class="descname">set_default_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[float], p_FoMo_F: numpy.ndarray[numpy.float64[2, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[float].set_default_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default position of this joint.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>:</dt>
<dd>The desired default position of the joint</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[float].set_pose">
<code class="descname">set_pose</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[float], context: pydrake.systems.framework.Context_[float], p_FoMo_F: numpy.ndarray[numpy.float64[2, 1]], theta: float</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.PlanarJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[float].set_pose" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the position of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals
<code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code> and its angle equals <code class="docutils literal notranslate"><span class="pre">theta</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>:</dt>
<dd>The desired position in meters to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> ordered
as (x, y). See class documentation for details.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt>
<dd>The desired angle in radians to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>. See
class documentation for details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[float].set_random_pose_distribution">
<code class="descname">set_random_pose_distribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[float], p_FoMo_F: numpy.ndarray[object[2, 1]], theta: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[float].set_random_pose_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the random distribution that the position and angle of this joint
will be randomly sampled from. See class documentation for details on
the definition of the position and angle.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[float].set_rotation">
<code class="descname">set_rotation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[float], context: pydrake.systems.framework.Context_[float], theta: float</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.PlanarJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[float].set_rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the angle θ of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals
<code class="docutils literal notranslate"><span class="pre">theta</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt>
<dd>The desired angle in radians to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>. See
class documentation for details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[float].set_translation">
<code class="descname">set_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[float], context: pydrake.systems.framework.Context_[float], p_FoMo_F: numpy.ndarray[numpy.float64[2, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.PlanarJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[float].set_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the position of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals
<code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_FoMo_F</span></code>:</dt>
<dd>The desired position in meters to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> ordered
as (x, y). See class documentation for details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PlanarJoint_[float].set_translational_velocity">
<code class="descname">set_translational_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PlanarJoint_[float], context: pydrake.systems.framework.Context_[float], v_FoMo_F: numpy.ndarray[numpy.float64[2, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.PlanarJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.PlanarJoint_[float].set_translational_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the translational velocity, in meters per second, of this
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s Mo measured and expressed in frame F to <code class="docutils literal notranslate"><span class="pre">v_FoMo_F</span></code>.
The new translational velocity gets stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">v_FoMo_F</span></code>:</dt>
<dd>The desired translational velocity of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters per
second.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.PrismaticJoint">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">PrismaticJoint</code><a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.PrismaticJoint_[float]" title="pydrake.multibody.tree.PrismaticJoint_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.PrismaticJoint_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.PrismaticJoint_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">PrismaticJoint_</code><a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.PrismaticJoint_[float]" title="pydrake.multibody.tree.PrismaticJoint_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">PrismaticJoint_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd]" title="pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">PrismaticJoint_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.PrismaticJoint_[Expression]" title="pydrake.multibody.tree.PrismaticJoint_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">PrismaticJoint_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float]">
<em class="property">class </em><code class="descname">PrismaticJoint_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[float]" title="pydrake.multibody.tree.Joint_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[float]</span></code></a></p>
<p>This Joint allows two bodies to translate relative to one another
along a common axis. That is, given a frame F attached to the parent
body P and a frame M attached to the child body B (see the Joint
class’s documentation), this Joint allows frames F and M to translate
with respect to each other along an axis â. The translation distance
is defined positive when child body B translates along the direction
of â. Axis â is constant and has the same measures in both frames F
and M, that is, <code class="docutils literal notranslate"><span class="pre">â_F</span> <span class="pre">=</span> <span class="pre">â_M</span></code>.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[float], frame_on_child: pydrake.multibody.tree.Frame_[float], axis: numpy.ndarray[numpy.float64[3, 1]], pos_lower_limit: float = -inf, pos_upper_limit: float = inf, damping: float = 0</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor to create a prismatic joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B, translate relatively to one another along a common axis.
See this class’s documentation for further details on the definition
of these frames and translation distance. The first three arguments to
this constructor are those of the Joint class constructor. See the
Joint class’s documentation for details. The additional parameter
<code class="docutils literal notranslate"><span class="pre">axis</span></code> is:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">axis</span></code>:</dt>
<dd>A vector in ℝ³ specifying the translation axis for this joint.
Given that frame M only translates with respect to F and there is
no relative rotation, the measures of <code class="docutils literal notranslate"><span class="pre">axis</span></code> in either frame F
or M are exactly the same, that is, <code class="docutils literal notranslate"><span class="pre">axis_F</span> <span class="pre">=</span> <span class="pre">axis_M</span></code>. This
vector can have any length, only the direction is used.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pos_lower_limit</span></code>:</dt>
<dd>Lower position limit, in meters, for the translation coordinate
(see get_translation()).</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pos_upper_limit</span></code>:</dt>
<dd>Upper position limit, in meters, for the translation coordinate
(see get_translation()).</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, in N⋅s/m, used to model losses within
the joint. The damping force (in N) is modeled as <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">=</span>
<span class="pre">-damping⋅v</span></code>, i.e. opposing motion, with v the translational speed
for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see get_translation_rate()).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the L2 norm of <code class="docutils literal notranslate"><span class="pre">axis</span></code> is less than the square</li>
<li>root of machine epsilon.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first">RuntimeError if damping is negative.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">RuntimeError if pos_lower_limit &gt; pos_upper_limit.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].acceleration_lower_limit">
<code class="descname">acceleration_lower_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].acceleration_lower_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the acceleration lower limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters per
second squared.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].acceleration_upper_limit">
<code class="descname">acceleration_upper_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].acceleration_upper_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the acceleration upper limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters per
second squared.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].damping" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s damping constant in N⋅s/m.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].get_default_translation">
<code class="descname">get_default_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].get_default_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default translation. Wrapper for the more general
<code class="docutils literal notranslate"><span class="pre">Joint::default_positions()</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The default translation of <code class="docutils literal notranslate"><span class="pre">this</span></code> stored in
<code class="docutils literal notranslate"><span class="pre">default_positions_</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].get_translation">
<code class="descname">get_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].get_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the translation distance of <code class="docutils literal notranslate"><span class="pre">this</span></code> mobilizer from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The translation coordinate of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint read from
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].get_translation_rate">
<code class="descname">get_translation_rate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].get_translation_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rate of change, in meters per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
translation distance (see get_translation()) from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The rate of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s translation read from
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].position_lower_limit">
<code class="descname">position_lower_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].position_lower_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the position lower limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].position_upper_limit">
<code class="descname">position_upper_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].position_upper_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the position upper limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].set_default_translation">
<code class="descname">set_default_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float], translation: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].set_default_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">default_positions</span></code> of this joint (in this case a single
translation)</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">translation</span></code>:</dt>
<dd>The desired default translation of the joint</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].set_random_translation_distribution">
<code class="descname">set_random_translation_distribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float], translation: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].set_random_translation_distribution" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].set_translation">
<code class="descname">set_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float], context: pydrake.systems.framework.Context_[float], translation: float</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.PrismaticJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].set_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the generalized coordinate corresponding to
the translation distance of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals <code class="docutils literal notranslate"><span class="pre">translation</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">translation</span></code>:</dt>
<dd>The desired translation in meters to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].set_translation_rate">
<code class="descname">set_translation_rate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float], context: pydrake.systems.framework.Context_[float], translation_dot: float</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.PrismaticJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].set_translation_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the rate of change, in meters per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
translation distance to <code class="docutils literal notranslate"><span class="pre">translation_dot</span></code>. The new rate of change
<code class="docutils literal notranslate"><span class="pre">translation_dot</span></code> gets stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">translation_dot</span></code>:</dt>
<dd>The desired rate of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joints’s translation in
meters per second.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].translation_axis">
<code class="descname">translation_axis</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].translation_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the axis of translation for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint as a unit vector.
Since the measures of this axis in either frame F or M are the same
(see this class’s documentation for frame definitions) then, <code class="docutils literal notranslate"><span class="pre">axis</span> <span class="pre">=</span>
<span class="pre">axis_F</span> <span class="pre">=</span> <span class="pre">axis_M</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].velocity_lower_limit">
<code class="descname">velocity_lower_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].velocity_lower_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the velocity lower limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters per
second.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].velocity_upper_limit">
<code class="descname">velocity_upper_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_.PrismaticJoint_[float].velocity_upper_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the velocity upper limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters per
second.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">PrismaticJoint_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[AutoDiffXd]" title="pydrake.multibody.tree.Joint_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd]</span></code></a></p>
<p>This Joint allows two bodies to translate relative to one another
along a common axis. That is, given a frame F attached to the parent
body P and a frame M attached to the child body B (see the Joint
class’s documentation), this Joint allows frames F and M to translate
with respect to each other along an axis â. The translation distance
is defined positive when child body B translates along the direction
of â. Axis â is constant and has the same measures in both frames F
and M, that is, <code class="docutils literal notranslate"><span class="pre">â_F</span> <span class="pre">=</span> <span class="pre">â_M</span></code>.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_on_child: pydrake.multibody.tree.Frame_[AutoDiffXd], axis: numpy.ndarray[numpy.float64[3, 1]], pos_lower_limit: float = -inf, pos_upper_limit: float = inf, damping: float = 0</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor to create a prismatic joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B, translate relatively to one another along a common axis.
See this class’s documentation for further details on the definition
of these frames and translation distance. The first three arguments to
this constructor are those of the Joint class constructor. See the
Joint class’s documentation for details. The additional parameter
<code class="docutils literal notranslate"><span class="pre">axis</span></code> is:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">axis</span></code>:</dt>
<dd>A vector in ℝ³ specifying the translation axis for this joint.
Given that frame M only translates with respect to F and there is
no relative rotation, the measures of <code class="docutils literal notranslate"><span class="pre">axis</span></code> in either frame F
or M are exactly the same, that is, <code class="docutils literal notranslate"><span class="pre">axis_F</span> <span class="pre">=</span> <span class="pre">axis_M</span></code>. This
vector can have any length, only the direction is used.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pos_lower_limit</span></code>:</dt>
<dd>Lower position limit, in meters, for the translation coordinate
(see get_translation()).</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pos_upper_limit</span></code>:</dt>
<dd>Upper position limit, in meters, for the translation coordinate
(see get_translation()).</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, in N⋅s/m, used to model losses within
the joint. The damping force (in N) is modeled as <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">=</span>
<span class="pre">-damping⋅v</span></code>, i.e. opposing motion, with v the translational speed
for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see get_translation_rate()).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the L2 norm of <code class="docutils literal notranslate"><span class="pre">axis</span></code> is less than the square</li>
<li>root of machine epsilon.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first">RuntimeError if damping is negative.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">RuntimeError if pos_lower_limit &gt; pos_upper_limit.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].acceleration_lower_limit">
<code class="descname">acceleration_lower_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].acceleration_lower_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the acceleration lower limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters per
second squared.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].acceleration_upper_limit">
<code class="descname">acceleration_upper_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].acceleration_upper_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the acceleration upper limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters per
second squared.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].damping" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s damping constant in N⋅s/m.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].get_default_translation">
<code class="descname">get_default_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].get_default_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default translation. Wrapper for the more general
<code class="docutils literal notranslate"><span class="pre">Joint::default_positions()</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The default translation of <code class="docutils literal notranslate"><span class="pre">this</span></code> stored in
<code class="docutils literal notranslate"><span class="pre">default_positions_</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].get_translation">
<code class="descname">get_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.autodiffutils.AutoDiffXd<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].get_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the translation distance of <code class="docutils literal notranslate"><span class="pre">this</span></code> mobilizer from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The translation coordinate of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint read from
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].get_translation_rate">
<code class="descname">get_translation_rate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.autodiffutils.AutoDiffXd<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].get_translation_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rate of change, in meters per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
translation distance (see get_translation()) from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The rate of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s translation read from
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].position_lower_limit">
<code class="descname">position_lower_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].position_lower_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the position lower limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].position_upper_limit">
<code class="descname">position_upper_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].position_upper_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the position upper limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].set_default_translation">
<code class="descname">set_default_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd], translation: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].set_default_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">default_positions</span></code> of this joint (in this case a single
translation)</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">translation</span></code>:</dt>
<dd>The desired default translation of the joint</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].set_random_translation_distribution">
<code class="descname">set_random_translation_distribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd], translation: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].set_random_translation_distribution" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].set_translation">
<code class="descname">set_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], translation: pydrake.autodiffutils.AutoDiffXd</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].set_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the generalized coordinate corresponding to
the translation distance of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals <code class="docutils literal notranslate"><span class="pre">translation</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">translation</span></code>:</dt>
<dd>The desired translation in meters to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].set_translation_rate">
<code class="descname">set_translation_rate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], translation_dot: pydrake.autodiffutils.AutoDiffXd</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].set_translation_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the rate of change, in meters per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
translation distance to <code class="docutils literal notranslate"><span class="pre">translation_dot</span></code>. The new rate of change
<code class="docutils literal notranslate"><span class="pre">translation_dot</span></code> gets stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">translation_dot</span></code>:</dt>
<dd>The desired rate of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joints’s translation in
meters per second.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].translation_axis">
<code class="descname">translation_axis</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].translation_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the axis of translation for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint as a unit vector.
Since the measures of this axis in either frame F or M are the same
(see this class’s documentation for frame definitions) then, <code class="docutils literal notranslate"><span class="pre">axis</span> <span class="pre">=</span>
<span class="pre">axis_F</span> <span class="pre">=</span> <span class="pre">axis_M</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].velocity_lower_limit">
<code class="descname">velocity_lower_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].velocity_lower_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the velocity lower limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters per
second.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].velocity_upper_limit">
<code class="descname">velocity_upper_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[AutoDiffXd].velocity_upper_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the velocity upper limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters per
second.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.PrismaticJoint_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">PrismaticJoint_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[Expression]" title="pydrake.multibody.tree.Joint_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[Expression]</span></code></a></p>
<p>This Joint allows two bodies to translate relative to one another
along a common axis. That is, given a frame F attached to the parent
body P and a frame M attached to the child body B (see the Joint
class’s documentation), this Joint allows frames F and M to translate
with respect to each other along an axis â. The translation distance
is defined positive when child body B translates along the direction
of â. Axis â is constant and has the same measures in both frames F
and M, that is, <code class="docutils literal notranslate"><span class="pre">â_F</span> <span class="pre">=</span> <span class="pre">â_M</span></code>.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[Expression], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[Expression], frame_on_child: pydrake.multibody.tree.Frame_[Expression], axis: numpy.ndarray[numpy.float64[3, 1]], pos_lower_limit: float = -inf, pos_upper_limit: float = inf, damping: float = 0</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor to create a prismatic joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B, translate relatively to one another along a common axis.
See this class’s documentation for further details on the definition
of these frames and translation distance. The first three arguments to
this constructor are those of the Joint class constructor. See the
Joint class’s documentation for details. The additional parameter
<code class="docutils literal notranslate"><span class="pre">axis</span></code> is:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">axis</span></code>:</dt>
<dd>A vector in ℝ³ specifying the translation axis for this joint.
Given that frame M only translates with respect to F and there is
no relative rotation, the measures of <code class="docutils literal notranslate"><span class="pre">axis</span></code> in either frame F
or M are exactly the same, that is, <code class="docutils literal notranslate"><span class="pre">axis_F</span> <span class="pre">=</span> <span class="pre">axis_M</span></code>. This
vector can have any length, only the direction is used.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pos_lower_limit</span></code>:</dt>
<dd>Lower position limit, in meters, for the translation coordinate
(see get_translation()).</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pos_upper_limit</span></code>:</dt>
<dd>Upper position limit, in meters, for the translation coordinate
(see get_translation()).</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, in N⋅s/m, used to model losses within
the joint. The damping force (in N) is modeled as <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">=</span>
<span class="pre">-damping⋅v</span></code>, i.e. opposing motion, with v the translational speed
for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see get_translation_rate()).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the L2 norm of <code class="docutils literal notranslate"><span class="pre">axis</span></code> is less than the square</li>
<li>root of machine epsilon.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first">RuntimeError if damping is negative.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">RuntimeError if pos_lower_limit &gt; pos_upper_limit.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[Expression].acceleration_lower_limit">
<code class="descname">acceleration_lower_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[Expression].acceleration_lower_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the acceleration lower limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters per
second squared.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[Expression].acceleration_upper_limit">
<code class="descname">acceleration_upper_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[Expression].acceleration_upper_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the acceleration upper limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters per
second squared.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[Expression].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[Expression].damping" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s damping constant in N⋅s/m.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[Expression].get_default_translation">
<code class="descname">get_default_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[Expression].get_default_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default translation. Wrapper for the more general
<code class="docutils literal notranslate"><span class="pre">Joint::default_positions()</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The default translation of <code class="docutils literal notranslate"><span class="pre">this</span></code> stored in
<code class="docutils literal notranslate"><span class="pre">default_positions_</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[Expression].get_translation">
<code class="descname">get_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[Expression].get_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the translation distance of <code class="docutils literal notranslate"><span class="pre">this</span></code> mobilizer from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The translation coordinate of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint read from
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[Expression].get_translation_rate">
<code class="descname">get_translation_rate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[Expression].get_translation_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rate of change, in meters per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
translation distance (see get_translation()) from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The rate of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s translation read from
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[Expression].position_lower_limit">
<code class="descname">position_lower_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[Expression].position_lower_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the position lower limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[Expression].position_upper_limit">
<code class="descname">position_upper_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[Expression].position_upper_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the position upper limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[Expression].set_default_translation">
<code class="descname">set_default_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[Expression], translation: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[Expression].set_default_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">default_positions</span></code> of this joint (in this case a single
translation)</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">translation</span></code>:</dt>
<dd>The desired default translation of the joint</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[Expression].set_random_translation_distribution">
<code class="descname">set_random_translation_distribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[Expression], translation: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[Expression].set_random_translation_distribution" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[Expression].set_translation">
<code class="descname">set_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[Expression], context: pydrake.systems.framework.Context_[Expression], translation: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.PrismaticJoint_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[Expression].set_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the generalized coordinate corresponding to
the translation distance of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals <code class="docutils literal notranslate"><span class="pre">translation</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">translation</span></code>:</dt>
<dd>The desired translation in meters to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[Expression].set_translation_rate">
<code class="descname">set_translation_rate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[Expression], context: pydrake.systems.framework.Context_[Expression], translation_dot: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.PrismaticJoint_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[Expression].set_translation_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the rate of change, in meters per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
translation distance to <code class="docutils literal notranslate"><span class="pre">translation_dot</span></code>. The new rate of change
<code class="docutils literal notranslate"><span class="pre">translation_dot</span></code> gets stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">translation_dot</span></code>:</dt>
<dd>The desired rate of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joints’s translation in
meters per second.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[Expression].translation_axis">
<code class="descname">translation_axis</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[Expression].translation_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the axis of translation for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint as a unit vector.
Since the measures of this axis in either frame F or M are the same
(see this class’s documentation for frame definitions) then, <code class="docutils literal notranslate"><span class="pre">axis</span> <span class="pre">=</span>
<span class="pre">axis_F</span> <span class="pre">=</span> <span class="pre">axis_M</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[Expression].velocity_lower_limit">
<code class="descname">velocity_lower_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[Expression].velocity_lower_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the velocity lower limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters per
second.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[Expression].velocity_upper_limit">
<code class="descname">velocity_upper_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[Expression].velocity_upper_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the velocity upper limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters per
second.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.PrismaticJoint_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">PrismaticJoint_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[float]" title="pydrake.multibody.tree.Joint_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[float]</span></code></a></p>
<p>This Joint allows two bodies to translate relative to one another
along a common axis. That is, given a frame F attached to the parent
body P and a frame M attached to the child body B (see the Joint
class’s documentation), this Joint allows frames F and M to translate
with respect to each other along an axis â. The translation distance
is defined positive when child body B translates along the direction
of â. Axis â is constant and has the same measures in both frames F
and M, that is, <code class="docutils literal notranslate"><span class="pre">â_F</span> <span class="pre">=</span> <span class="pre">â_M</span></code>.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[float], frame_on_child: pydrake.multibody.tree.Frame_[float], axis: numpy.ndarray[numpy.float64[3, 1]], pos_lower_limit: float = -inf, pos_upper_limit: float = inf, damping: float = 0</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor to create a prismatic joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B, translate relatively to one another along a common axis.
See this class’s documentation for further details on the definition
of these frames and translation distance. The first three arguments to
this constructor are those of the Joint class constructor. See the
Joint class’s documentation for details. The additional parameter
<code class="docutils literal notranslate"><span class="pre">axis</span></code> is:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">axis</span></code>:</dt>
<dd>A vector in ℝ³ specifying the translation axis for this joint.
Given that frame M only translates with respect to F and there is
no relative rotation, the measures of <code class="docutils literal notranslate"><span class="pre">axis</span></code> in either frame F
or M are exactly the same, that is, <code class="docutils literal notranslate"><span class="pre">axis_F</span> <span class="pre">=</span> <span class="pre">axis_M</span></code>. This
vector can have any length, only the direction is used.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pos_lower_limit</span></code>:</dt>
<dd>Lower position limit, in meters, for the translation coordinate
(see get_translation()).</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pos_upper_limit</span></code>:</dt>
<dd>Upper position limit, in meters, for the translation coordinate
(see get_translation()).</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, in N⋅s/m, used to model losses within
the joint. The damping force (in N) is modeled as <code class="docutils literal notranslate"><span class="pre">f</span> <span class="pre">=</span>
<span class="pre">-damping⋅v</span></code>, i.e. opposing motion, with v the translational speed
for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see get_translation_rate()).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the L2 norm of <code class="docutils literal notranslate"><span class="pre">axis</span></code> is less than the square</li>
<li>root of machine epsilon.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first">RuntimeError if damping is negative.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">RuntimeError if pos_lower_limit &gt; pos_upper_limit.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[float].acceleration_lower_limit">
<code class="descname">acceleration_lower_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[float].acceleration_lower_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the acceleration lower limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters per
second squared.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[float].acceleration_upper_limit">
<code class="descname">acceleration_upper_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[float].acceleration_upper_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the acceleration upper limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters per
second squared.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[float].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[float].damping" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s damping constant in N⋅s/m.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[float].get_default_translation">
<code class="descname">get_default_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[float].get_default_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default translation. Wrapper for the more general
<code class="docutils literal notranslate"><span class="pre">Joint::default_positions()</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The default translation of <code class="docutils literal notranslate"><span class="pre">this</span></code> stored in
<code class="docutils literal notranslate"><span class="pre">default_positions_</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[float].get_translation">
<code class="descname">get_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[float].get_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the translation distance of <code class="docutils literal notranslate"><span class="pre">this</span></code> mobilizer from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The translation coordinate of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint read from
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[float].get_translation_rate">
<code class="descname">get_translation_rate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[float].get_translation_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rate of change, in meters per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
translation distance (see get_translation()) from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The rate of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s translation read from
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[float].position_lower_limit">
<code class="descname">position_lower_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[float].position_lower_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the position lower limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[float].position_upper_limit">
<code class="descname">position_upper_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[float].position_upper_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the position upper limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[float].set_default_translation">
<code class="descname">set_default_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float], translation: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[float].set_default_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">default_positions</span></code> of this joint (in this case a single
translation)</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">translation</span></code>:</dt>
<dd>The desired default translation of the joint</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[float].set_random_translation_distribution">
<code class="descname">set_random_translation_distribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float], translation: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[float].set_random_translation_distribution" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[float].set_translation">
<code class="descname">set_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float], context: pydrake.systems.framework.Context_[float], translation: float</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.PrismaticJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[float].set_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the generalized coordinate corresponding to
the translation distance of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals <code class="docutils literal notranslate"><span class="pre">translation</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">translation</span></code>:</dt>
<dd>The desired translation in meters to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[float].set_translation_rate">
<code class="descname">set_translation_rate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float], context: pydrake.systems.framework.Context_[float], translation_dot: float</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.PrismaticJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[float].set_translation_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the rate of change, in meters per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
translation distance to <code class="docutils literal notranslate"><span class="pre">translation_dot</span></code>. The new rate of change
<code class="docutils literal notranslate"><span class="pre">translation_dot</span></code> gets stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">translation_dot</span></code>:</dt>
<dd>The desired rate of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joints’s translation in
meters per second.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[float].translation_axis">
<code class="descname">translation_axis</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[float].translation_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the axis of translation for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint as a unit vector.
Since the measures of this axis in either frame F or M are the same
(see this class’s documentation for frame definitions) then, <code class="docutils literal notranslate"><span class="pre">axis</span> <span class="pre">=</span>
<span class="pre">axis_F</span> <span class="pre">=</span> <span class="pre">axis_M</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[float].velocity_lower_limit">
<code class="descname">velocity_lower_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[float].velocity_lower_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the velocity lower limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters per
second.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.PrismaticJoint_[float].velocity_upper_limit">
<code class="descname">velocity_upper_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.PrismaticJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.PrismaticJoint_[float].velocity_upper_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the velocity upper limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters per
second.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.RevoluteJoint">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">RevoluteJoint</code><a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.RevoluteJoint_[float]" title="pydrake.multibody.tree.RevoluteJoint_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.RevoluteJoint_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.RevoluteJoint_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">RevoluteJoint_</code><a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.RevoluteJoint_[float]" title="pydrake.multibody.tree.RevoluteJoint_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">RevoluteJoint_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd]" title="pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">RevoluteJoint_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.RevoluteJoint_[Expression]" title="pydrake.multibody.tree.RevoluteJoint_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">RevoluteJoint_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float]">
<em class="property">class </em><code class="descname">RevoluteJoint_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[float]" title="pydrake.multibody.tree.Joint_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[float]</span></code></a></p>
<p>This Joint allows two bodies to rotate relatively to one another
around a common axis. That is, given a frame F attached to the parent
body P and a frame M attached to the child body B (see the Joint
class’s documentation), this Joint allows frames F and M to rotate
with respect to each other about an axis â. The rotation angle’s sign
is defined such that child body B rotates about axis â according to
the right hand rule, with thumb aligned in the axis direction. Axis â
is constant and has the same measures in both frames F and M, that is,
<code class="docutils literal notranslate"><span class="pre">â_F</span> <span class="pre">=</span> <span class="pre">â_M</span></code>.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.RevoluteJoint_[float], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[float], frame_on_child: pydrake.multibody.tree.Frame_[float], axis: numpy.ndarray[numpy.float64[3, 1]], damping: float = 0) -&gt; None</li>
</ol>
<p>Constructor to create a revolute joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B, rotate relatively to one another about a common axis.
See this class’s documentation for further details on the definition
of these frames and rotation angle. This constructor signature creates
a joint with no joint limits, i.e. the joint position, velocity and
acceleration limits are the pair <code class="docutils literal notranslate"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. The first three
arguments to this constructor are those of the Joint class
constructor. See the Joint class’s documentation for details. The
additional parameters are:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">axis</span></code>:</dt>
<dd>A vector in ℝ³ specifying the axis of revolution for this joint.
Given that frame M only rotates with respect to F and their
origins are coincident at all times, the measures of <code class="docutils literal notranslate"><span class="pre">axis</span></code> in
either frame F or M are exactly the same, that is, <code class="docutils literal notranslate"><span class="pre">axis_F</span> <span class="pre">=</span>
<span class="pre">axis_M</span></code>. In other words, <code class="docutils literal notranslate"><span class="pre">axis_F</span></code> (or <code class="docutils literal notranslate"><span class="pre">axis_M</span></code>) is the
eigenvector of <code class="docutils literal notranslate"><span class="pre">R_FM</span></code> with eigenvalue equal to one. This vector
can have any length, only the direction is used. This method
aborts if <code class="docutils literal notranslate"><span class="pre">axis</span></code> is the zero vector.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, in N⋅m⋅s, used to model losses within
the joint. The damping torque (in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span>
<span class="pre">-damping⋅ω</span></code>, i.e. opposing motion, with ω the angular rate for
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see get_angular_rate()).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if damping is negative.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.RevoluteJoint_[float], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[float], frame_on_child: pydrake.multibody.tree.Frame_[float], axis: numpy.ndarray[numpy.float64[3, 1]], pos_lower_limit: float, pos_upper_limit: float, damping: float = 0.0) -&gt; None</li>
</ol>
<p>Constructor to create a revolute joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B, rotate relatively to one another about a common axis.
See this class’s documentation for further details on the definition
of these frames and rotation angle. The first three arguments to this
constructor are those of the Joint class constructor. See the Joint
class’s documentation for details. The additional parameters are:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">axis</span></code>:</dt>
<dd>A vector in ℝ³ specifying the axis of revolution for this joint.
Given that frame M only rotates with respect to F and their
origins are coincident at all times, the measures of <code class="docutils literal notranslate"><span class="pre">axis</span></code> in
either frame F or M are exactly the same, that is, <code class="docutils literal notranslate"><span class="pre">axis_F</span> <span class="pre">=</span>
<span class="pre">axis_M</span></code>. In other words, <code class="docutils literal notranslate"><span class="pre">axis_F</span></code> (or <code class="docutils literal notranslate"><span class="pre">axis_M</span></code>) is the
eigenvector of <code class="docutils literal notranslate"><span class="pre">R_FM</span></code> with eigenvalue equal to one. This vector
can have any length, only the direction is used.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pos_lower_limit</span></code>:</dt>
<dd>Lower position limit, in radians, for the rotation coordinate (see
get_angle()).</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pos_upper_limit</span></code>:</dt>
<dd>Upper position limit, in radians, for the rotation coordinate (see
get_angle()).</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, in N⋅m⋅s, used to model losses within
the joint. The damping torque (in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span>
<span class="pre">-damping⋅ω</span></code>, i.e. opposing motion, with ω the angular rate for
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see get_angular_rate()).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the L2 norm of <code class="docutils literal notranslate"><span class="pre">axis</span></code> is less than the square</li>
<li>root of machine epsilon.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first">RuntimeError if damping is negative.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">RuntimeError if pos_lower_limit &gt; pos_upper_limit.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].acceleration_lower_limit">
<code class="descname">acceleration_lower_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].acceleration_lower_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the acceleration lower limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in radians /
s².</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].acceleration_upper_limit">
<code class="descname">acceleration_upper_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].acceleration_upper_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the acceleration upper limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in radians /
s².</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].damping" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s damping constant in N⋅m⋅s.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].get_angle">
<code class="descname">get_angle</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].get_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rotation angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> mobilizer from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The angle coordinate of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].get_angular_rate">
<code class="descname">get_angular_rate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].get_angular_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rate of change, in radians per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
angle (see get_angle()) from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The rate of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s angle as stored in the
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].get_default_angle">
<code class="descname">get_default_angle</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].get_default_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default rotation angle. Wrapper for the more general
<code class="docutils literal notranslate"><span class="pre">Joint::default_positions()</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The default angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> stored in <code class="docutils literal notranslate"><span class="pre">default_positions_</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].position_lower_limit">
<code class="descname">position_lower_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].position_lower_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the position lower limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in radians.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].position_upper_limit">
<code class="descname">position_upper_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].position_upper_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the position upper limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in radians.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].revolute_axis">
<code class="descname">revolute_axis</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].revolute_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the axis of revolution of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint as a unit vector.
Since the measures of this axis in either frame F or M are the same
(see this class’s documentation for frame definitions) then, <code class="docutils literal notranslate"><span class="pre">axis</span> <span class="pre">=</span>
<span class="pre">axis_F</span> <span class="pre">=</span> <span class="pre">axis_M</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].set_angle">
<code class="descname">set_angle</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[float], context: pydrake.systems.framework.Context_[float], angle: float</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RevoluteJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].set_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the generalized coordinate corresponding
to the rotation angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals <code class="docutils literal notranslate"><span class="pre">angle</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angle</span></code>:</dt>
<dd>The desired angle in radians to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].set_angular_rate">
<code class="descname">set_angular_rate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[float], context: pydrake.systems.framework.Context_[float], angle: float</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RevoluteJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].set_angular_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the rate of change, in radians per second, of this <code class="docutils literal notranslate"><span class="pre">this</span></code>
joint’s angle to <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>. The new rate of change <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>
gets stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>:</dt>
<dd>The desired rate of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joints’s angle in radians
per second.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].set_default_angle">
<code class="descname">set_default_angle</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[float], angle: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].set_default_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">default_positions</span></code> of this joint (in this case a single
angle).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angle</span></code>:</dt>
<dd>The desired default angle of the joint</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].set_random_angle_distribution">
<code class="descname">set_random_angle_distribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[float], angle: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].set_random_angle_distribution" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].velocity_lower_limit">
<code class="descname">velocity_lower_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].velocity_lower_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the velocity lower limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in radians / s.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].velocity_upper_limit">
<code class="descname">velocity_upper_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_.RevoluteJoint_[float].velocity_upper_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the velocity upper limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in radians / s.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">RevoluteJoint_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[AutoDiffXd]" title="pydrake.multibody.tree.Joint_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd]</span></code></a></p>
<p>This Joint allows two bodies to rotate relatively to one another
around a common axis. That is, given a frame F attached to the parent
body P and a frame M attached to the child body B (see the Joint
class’s documentation), this Joint allows frames F and M to rotate
with respect to each other about an axis â. The rotation angle’s sign
is defined such that child body B rotates about axis â according to
the right hand rule, with thumb aligned in the axis direction. Axis â
is constant and has the same measures in both frames F and M, that is,
<code class="docutils literal notranslate"><span class="pre">â_F</span> <span class="pre">=</span> <span class="pre">â_M</span></code>.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_on_child: pydrake.multibody.tree.Frame_[AutoDiffXd], axis: numpy.ndarray[numpy.float64[3, 1]], damping: float = 0) -&gt; None</li>
</ol>
<p>Constructor to create a revolute joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B, rotate relatively to one another about a common axis.
See this class’s documentation for further details on the definition
of these frames and rotation angle. This constructor signature creates
a joint with no joint limits, i.e. the joint position, velocity and
acceleration limits are the pair <code class="docutils literal notranslate"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. The first three
arguments to this constructor are those of the Joint class
constructor. See the Joint class’s documentation for details. The
additional parameters are:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">axis</span></code>:</dt>
<dd>A vector in ℝ³ specifying the axis of revolution for this joint.
Given that frame M only rotates with respect to F and their
origins are coincident at all times, the measures of <code class="docutils literal notranslate"><span class="pre">axis</span></code> in
either frame F or M are exactly the same, that is, <code class="docutils literal notranslate"><span class="pre">axis_F</span> <span class="pre">=</span>
<span class="pre">axis_M</span></code>. In other words, <code class="docutils literal notranslate"><span class="pre">axis_F</span></code> (or <code class="docutils literal notranslate"><span class="pre">axis_M</span></code>) is the
eigenvector of <code class="docutils literal notranslate"><span class="pre">R_FM</span></code> with eigenvalue equal to one. This vector
can have any length, only the direction is used. This method
aborts if <code class="docutils literal notranslate"><span class="pre">axis</span></code> is the zero vector.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, in N⋅m⋅s, used to model losses within
the joint. The damping torque (in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span>
<span class="pre">-damping⋅ω</span></code>, i.e. opposing motion, with ω the angular rate for
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see get_angular_rate()).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if damping is negative.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_on_child: pydrake.multibody.tree.Frame_[AutoDiffXd], axis: numpy.ndarray[numpy.float64[3, 1]], pos_lower_limit: float, pos_upper_limit: float, damping: float = 0.0) -&gt; None</li>
</ol>
<p>Constructor to create a revolute joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B, rotate relatively to one another about a common axis.
See this class’s documentation for further details on the definition
of these frames and rotation angle. The first three arguments to this
constructor are those of the Joint class constructor. See the Joint
class’s documentation for details. The additional parameters are:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">axis</span></code>:</dt>
<dd>A vector in ℝ³ specifying the axis of revolution for this joint.
Given that frame M only rotates with respect to F and their
origins are coincident at all times, the measures of <code class="docutils literal notranslate"><span class="pre">axis</span></code> in
either frame F or M are exactly the same, that is, <code class="docutils literal notranslate"><span class="pre">axis_F</span> <span class="pre">=</span>
<span class="pre">axis_M</span></code>. In other words, <code class="docutils literal notranslate"><span class="pre">axis_F</span></code> (or <code class="docutils literal notranslate"><span class="pre">axis_M</span></code>) is the
eigenvector of <code class="docutils literal notranslate"><span class="pre">R_FM</span></code> with eigenvalue equal to one. This vector
can have any length, only the direction is used.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pos_lower_limit</span></code>:</dt>
<dd>Lower position limit, in radians, for the rotation coordinate (see
get_angle()).</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pos_upper_limit</span></code>:</dt>
<dd>Upper position limit, in radians, for the rotation coordinate (see
get_angle()).</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, in N⋅m⋅s, used to model losses within
the joint. The damping torque (in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span>
<span class="pre">-damping⋅ω</span></code>, i.e. opposing motion, with ω the angular rate for
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see get_angular_rate()).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the L2 norm of <code class="docutils literal notranslate"><span class="pre">axis</span></code> is less than the square</li>
<li>root of machine epsilon.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first">RuntimeError if damping is negative.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">RuntimeError if pos_lower_limit &gt; pos_upper_limit.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].acceleration_lower_limit">
<code class="descname">acceleration_lower_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].acceleration_lower_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the acceleration lower limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in radians /
s².</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].acceleration_upper_limit">
<code class="descname">acceleration_upper_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].acceleration_upper_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the acceleration upper limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in radians /
s².</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].damping" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s damping constant in N⋅m⋅s.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].get_angle">
<code class="descname">get_angle</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.autodiffutils.AutoDiffXd<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].get_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rotation angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> mobilizer from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The angle coordinate of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].get_angular_rate">
<code class="descname">get_angular_rate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.autodiffutils.AutoDiffXd<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].get_angular_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rate of change, in radians per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
angle (see get_angle()) from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The rate of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s angle as stored in the
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].get_default_angle">
<code class="descname">get_default_angle</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].get_default_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default rotation angle. Wrapper for the more general
<code class="docutils literal notranslate"><span class="pre">Joint::default_positions()</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The default angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> stored in <code class="docutils literal notranslate"><span class="pre">default_positions_</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].position_lower_limit">
<code class="descname">position_lower_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].position_lower_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the position lower limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in radians.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].position_upper_limit">
<code class="descname">position_upper_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].position_upper_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the position upper limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in radians.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].revolute_axis">
<code class="descname">revolute_axis</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].revolute_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the axis of revolution of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint as a unit vector.
Since the measures of this axis in either frame F or M are the same
(see this class’s documentation for frame definitions) then, <code class="docutils literal notranslate"><span class="pre">axis</span> <span class="pre">=</span>
<span class="pre">axis_F</span> <span class="pre">=</span> <span class="pre">axis_M</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].set_angle">
<code class="descname">set_angle</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], angle: pydrake.autodiffutils.AutoDiffXd</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].set_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the generalized coordinate corresponding
to the rotation angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals <code class="docutils literal notranslate"><span class="pre">angle</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angle</span></code>:</dt>
<dd>The desired angle in radians to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].set_angular_rate">
<code class="descname">set_angular_rate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], angle: pydrake.autodiffutils.AutoDiffXd</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].set_angular_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the rate of change, in radians per second, of this <code class="docutils literal notranslate"><span class="pre">this</span></code>
joint’s angle to <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>. The new rate of change <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>
gets stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>:</dt>
<dd>The desired rate of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joints’s angle in radians
per second.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].set_default_angle">
<code class="descname">set_default_angle</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd], angle: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].set_default_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">default_positions</span></code> of this joint (in this case a single
angle).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angle</span></code>:</dt>
<dd>The desired default angle of the joint</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].set_random_angle_distribution">
<code class="descname">set_random_angle_distribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd], angle: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].set_random_angle_distribution" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].velocity_lower_limit">
<code class="descname">velocity_lower_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].velocity_lower_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the velocity lower limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in radians / s.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].velocity_upper_limit">
<code class="descname">velocity_upper_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd].velocity_upper_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the velocity upper limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in radians / s.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.RevoluteJoint_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">RevoluteJoint_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[Expression]" title="pydrake.multibody.tree.Joint_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[Expression]</span></code></a></p>
<p>This Joint allows two bodies to rotate relatively to one another
around a common axis. That is, given a frame F attached to the parent
body P and a frame M attached to the child body B (see the Joint
class’s documentation), this Joint allows frames F and M to rotate
with respect to each other about an axis â. The rotation angle’s sign
is defined such that child body B rotates about axis â according to
the right hand rule, with thumb aligned in the axis direction. Axis â
is constant and has the same measures in both frames F and M, that is,
<code class="docutils literal notranslate"><span class="pre">â_F</span> <span class="pre">=</span> <span class="pre">â_M</span></code>.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.RevoluteJoint_[Expression], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[Expression], frame_on_child: pydrake.multibody.tree.Frame_[Expression], axis: numpy.ndarray[numpy.float64[3, 1]], damping: float = 0) -&gt; None</li>
</ol>
<p>Constructor to create a revolute joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B, rotate relatively to one another about a common axis.
See this class’s documentation for further details on the definition
of these frames and rotation angle. This constructor signature creates
a joint with no joint limits, i.e. the joint position, velocity and
acceleration limits are the pair <code class="docutils literal notranslate"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. The first three
arguments to this constructor are those of the Joint class
constructor. See the Joint class’s documentation for details. The
additional parameters are:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">axis</span></code>:</dt>
<dd>A vector in ℝ³ specifying the axis of revolution for this joint.
Given that frame M only rotates with respect to F and their
origins are coincident at all times, the measures of <code class="docutils literal notranslate"><span class="pre">axis</span></code> in
either frame F or M are exactly the same, that is, <code class="docutils literal notranslate"><span class="pre">axis_F</span> <span class="pre">=</span>
<span class="pre">axis_M</span></code>. In other words, <code class="docutils literal notranslate"><span class="pre">axis_F</span></code> (or <code class="docutils literal notranslate"><span class="pre">axis_M</span></code>) is the
eigenvector of <code class="docutils literal notranslate"><span class="pre">R_FM</span></code> with eigenvalue equal to one. This vector
can have any length, only the direction is used. This method
aborts if <code class="docutils literal notranslate"><span class="pre">axis</span></code> is the zero vector.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, in N⋅m⋅s, used to model losses within
the joint. The damping torque (in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span>
<span class="pre">-damping⋅ω</span></code>, i.e. opposing motion, with ω the angular rate for
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see get_angular_rate()).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if damping is negative.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.RevoluteJoint_[Expression], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[Expression], frame_on_child: pydrake.multibody.tree.Frame_[Expression], axis: numpy.ndarray[numpy.float64[3, 1]], pos_lower_limit: float, pos_upper_limit: float, damping: float = 0.0) -&gt; None</li>
</ol>
<p>Constructor to create a revolute joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B, rotate relatively to one another about a common axis.
See this class’s documentation for further details on the definition
of these frames and rotation angle. The first three arguments to this
constructor are those of the Joint class constructor. See the Joint
class’s documentation for details. The additional parameters are:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">axis</span></code>:</dt>
<dd>A vector in ℝ³ specifying the axis of revolution for this joint.
Given that frame M only rotates with respect to F and their
origins are coincident at all times, the measures of <code class="docutils literal notranslate"><span class="pre">axis</span></code> in
either frame F or M are exactly the same, that is, <code class="docutils literal notranslate"><span class="pre">axis_F</span> <span class="pre">=</span>
<span class="pre">axis_M</span></code>. In other words, <code class="docutils literal notranslate"><span class="pre">axis_F</span></code> (or <code class="docutils literal notranslate"><span class="pre">axis_M</span></code>) is the
eigenvector of <code class="docutils literal notranslate"><span class="pre">R_FM</span></code> with eigenvalue equal to one. This vector
can have any length, only the direction is used.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pos_lower_limit</span></code>:</dt>
<dd>Lower position limit, in radians, for the rotation coordinate (see
get_angle()).</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pos_upper_limit</span></code>:</dt>
<dd>Upper position limit, in radians, for the rotation coordinate (see
get_angle()).</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, in N⋅m⋅s, used to model losses within
the joint. The damping torque (in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span>
<span class="pre">-damping⋅ω</span></code>, i.e. opposing motion, with ω the angular rate for
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see get_angular_rate()).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the L2 norm of <code class="docutils literal notranslate"><span class="pre">axis</span></code> is less than the square</li>
<li>root of machine epsilon.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first">RuntimeError if damping is negative.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">RuntimeError if pos_lower_limit &gt; pos_upper_limit.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[Expression].acceleration_lower_limit">
<code class="descname">acceleration_lower_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[Expression].acceleration_lower_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the acceleration lower limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in radians /
s².</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[Expression].acceleration_upper_limit">
<code class="descname">acceleration_upper_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[Expression].acceleration_upper_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the acceleration upper limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in radians /
s².</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[Expression].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[Expression].damping" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s damping constant in N⋅m⋅s.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[Expression].get_angle">
<code class="descname">get_angle</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[Expression].get_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rotation angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> mobilizer from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The angle coordinate of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[Expression].get_angular_rate">
<code class="descname">get_angular_rate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[Expression].get_angular_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rate of change, in radians per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
angle (see get_angle()) from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The rate of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s angle as stored in the
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[Expression].get_default_angle">
<code class="descname">get_default_angle</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[Expression].get_default_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default rotation angle. Wrapper for the more general
<code class="docutils literal notranslate"><span class="pre">Joint::default_positions()</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The default angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> stored in <code class="docutils literal notranslate"><span class="pre">default_positions_</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[Expression].position_lower_limit">
<code class="descname">position_lower_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[Expression].position_lower_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the position lower limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in radians.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[Expression].position_upper_limit">
<code class="descname">position_upper_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[Expression].position_upper_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the position upper limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in radians.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[Expression].revolute_axis">
<code class="descname">revolute_axis</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[Expression].revolute_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the axis of revolution of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint as a unit vector.
Since the measures of this axis in either frame F or M are the same
(see this class’s documentation for frame definitions) then, <code class="docutils literal notranslate"><span class="pre">axis</span> <span class="pre">=</span>
<span class="pre">axis_F</span> <span class="pre">=</span> <span class="pre">axis_M</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[Expression].set_angle">
<code class="descname">set_angle</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[Expression], context: pydrake.systems.framework.Context_[Expression], angle: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RevoluteJoint_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[Expression].set_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the generalized coordinate corresponding
to the rotation angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals <code class="docutils literal notranslate"><span class="pre">angle</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angle</span></code>:</dt>
<dd>The desired angle in radians to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[Expression].set_angular_rate">
<code class="descname">set_angular_rate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[Expression], context: pydrake.systems.framework.Context_[Expression], angle: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RevoluteJoint_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[Expression].set_angular_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the rate of change, in radians per second, of this <code class="docutils literal notranslate"><span class="pre">this</span></code>
joint’s angle to <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>. The new rate of change <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>
gets stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>:</dt>
<dd>The desired rate of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joints’s angle in radians
per second.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[Expression].set_default_angle">
<code class="descname">set_default_angle</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[Expression], angle: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[Expression].set_default_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">default_positions</span></code> of this joint (in this case a single
angle).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angle</span></code>:</dt>
<dd>The desired default angle of the joint</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[Expression].set_random_angle_distribution">
<code class="descname">set_random_angle_distribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[Expression], angle: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[Expression].set_random_angle_distribution" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[Expression].velocity_lower_limit">
<code class="descname">velocity_lower_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[Expression].velocity_lower_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the velocity lower limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in radians / s.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[Expression].velocity_upper_limit">
<code class="descname">velocity_upper_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[Expression].velocity_upper_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the velocity upper limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in radians / s.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.RevoluteJoint_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">RevoluteJoint_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[float]" title="pydrake.multibody.tree.Joint_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[float]</span></code></a></p>
<p>This Joint allows two bodies to rotate relatively to one another
around a common axis. That is, given a frame F attached to the parent
body P and a frame M attached to the child body B (see the Joint
class’s documentation), this Joint allows frames F and M to rotate
with respect to each other about an axis â. The rotation angle’s sign
is defined such that child body B rotates about axis â according to
the right hand rule, with thumb aligned in the axis direction. Axis â
is constant and has the same measures in both frames F and M, that is,
<code class="docutils literal notranslate"><span class="pre">â_F</span> <span class="pre">=</span> <span class="pre">â_M</span></code>.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.RevoluteJoint_[float], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[float], frame_on_child: pydrake.multibody.tree.Frame_[float], axis: numpy.ndarray[numpy.float64[3, 1]], damping: float = 0) -&gt; None</li>
</ol>
<p>Constructor to create a revolute joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B, rotate relatively to one another about a common axis.
See this class’s documentation for further details on the definition
of these frames and rotation angle. This constructor signature creates
a joint with no joint limits, i.e. the joint position, velocity and
acceleration limits are the pair <code class="docutils literal notranslate"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. The first three
arguments to this constructor are those of the Joint class
constructor. See the Joint class’s documentation for details. The
additional parameters are:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">axis</span></code>:</dt>
<dd>A vector in ℝ³ specifying the axis of revolution for this joint.
Given that frame M only rotates with respect to F and their
origins are coincident at all times, the measures of <code class="docutils literal notranslate"><span class="pre">axis</span></code> in
either frame F or M are exactly the same, that is, <code class="docutils literal notranslate"><span class="pre">axis_F</span> <span class="pre">=</span>
<span class="pre">axis_M</span></code>. In other words, <code class="docutils literal notranslate"><span class="pre">axis_F</span></code> (or <code class="docutils literal notranslate"><span class="pre">axis_M</span></code>) is the
eigenvector of <code class="docutils literal notranslate"><span class="pre">R_FM</span></code> with eigenvalue equal to one. This vector
can have any length, only the direction is used. This method
aborts if <code class="docutils literal notranslate"><span class="pre">axis</span></code> is the zero vector.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, in N⋅m⋅s, used to model losses within
the joint. The damping torque (in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span>
<span class="pre">-damping⋅ω</span></code>, i.e. opposing motion, with ω the angular rate for
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see get_angular_rate()).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if damping is negative.</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.RevoluteJoint_[float], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[float], frame_on_child: pydrake.multibody.tree.Frame_[float], axis: numpy.ndarray[numpy.float64[3, 1]], pos_lower_limit: float, pos_upper_limit: float, damping: float = 0.0) -&gt; None</li>
</ol>
<p>Constructor to create a revolute joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B, rotate relatively to one another about a common axis.
See this class’s documentation for further details on the definition
of these frames and rotation angle. The first three arguments to this
constructor are those of the Joint class constructor. See the Joint
class’s documentation for details. The additional parameters are:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">axis</span></code>:</dt>
<dd>A vector in ℝ³ specifying the axis of revolution for this joint.
Given that frame M only rotates with respect to F and their
origins are coincident at all times, the measures of <code class="docutils literal notranslate"><span class="pre">axis</span></code> in
either frame F or M are exactly the same, that is, <code class="docutils literal notranslate"><span class="pre">axis_F</span> <span class="pre">=</span>
<span class="pre">axis_M</span></code>. In other words, <code class="docutils literal notranslate"><span class="pre">axis_F</span></code> (or <code class="docutils literal notranslate"><span class="pre">axis_M</span></code>) is the
eigenvector of <code class="docutils literal notranslate"><span class="pre">R_FM</span></code> with eigenvalue equal to one. This vector
can have any length, only the direction is used.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pos_lower_limit</span></code>:</dt>
<dd>Lower position limit, in radians, for the rotation coordinate (see
get_angle()).</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">pos_upper_limit</span></code>:</dt>
<dd>Upper position limit, in radians, for the rotation coordinate (see
get_angle()).</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, in N⋅m⋅s, used to model losses within
the joint. The damping torque (in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span>
<span class="pre">-damping⋅ω</span></code>, i.e. opposing motion, with ω the angular rate for
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see get_angular_rate()).</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the L2 norm of <code class="docutils literal notranslate"><span class="pre">axis</span></code> is less than the square</li>
<li>root of machine epsilon.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first">RuntimeError if damping is negative.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">RuntimeError if pos_lower_limit &gt; pos_upper_limit.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[float].acceleration_lower_limit">
<code class="descname">acceleration_lower_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[float].acceleration_lower_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the acceleration lower limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in radians /
s².</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[float].acceleration_upper_limit">
<code class="descname">acceleration_upper_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[float].acceleration_upper_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the acceleration upper limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in radians /
s².</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[float].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[float].damping" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s damping constant in N⋅m⋅s.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[float].get_angle">
<code class="descname">get_angle</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[float].get_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rotation angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> mobilizer from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The angle coordinate of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[float].get_angular_rate">
<code class="descname">get_angular_rate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[float].get_angular_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rate of change, in radians per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
angle (see get_angle()) from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The rate of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s angle as stored in the
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[float].get_default_angle">
<code class="descname">get_default_angle</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[float].get_default_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default rotation angle. Wrapper for the more general
<code class="docutils literal notranslate"><span class="pre">Joint::default_positions()</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The default angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> stored in <code class="docutils literal notranslate"><span class="pre">default_positions_</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[float].position_lower_limit">
<code class="descname">position_lower_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[float].position_lower_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the position lower limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in radians.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[float].position_upper_limit">
<code class="descname">position_upper_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[float].position_upper_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the position upper limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in radians.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[float].revolute_axis">
<code class="descname">revolute_axis</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[float].revolute_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the axis of revolution of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint as a unit vector.
Since the measures of this axis in either frame F or M are the same
(see this class’s documentation for frame definitions) then, <code class="docutils literal notranslate"><span class="pre">axis</span> <span class="pre">=</span>
<span class="pre">axis_F</span> <span class="pre">=</span> <span class="pre">axis_M</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[float].set_angle">
<code class="descname">set_angle</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[float], context: pydrake.systems.framework.Context_[float], angle: float</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RevoluteJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[float].set_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the generalized coordinate corresponding
to the rotation angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals <code class="docutils literal notranslate"><span class="pre">angle</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angle</span></code>:</dt>
<dd>The desired angle in radians to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[float].set_angular_rate">
<code class="descname">set_angular_rate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[float], context: pydrake.systems.framework.Context_[float], angle: float</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RevoluteJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[float].set_angular_rate" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the rate of change, in radians per second, of this <code class="docutils literal notranslate"><span class="pre">this</span></code>
joint’s angle to <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>. The new rate of change <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>
gets stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the MultibodyTree this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>:</dt>
<dd>The desired rate of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joints’s angle in radians
per second.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[float].set_default_angle">
<code class="descname">set_default_angle</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[float], angle: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[float].set_default_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">default_positions</span></code> of this joint (in this case a single
angle).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angle</span></code>:</dt>
<dd>The desired default angle of the joint</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[float].set_random_angle_distribution">
<code class="descname">set_random_angle_distribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[float], angle: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[float].set_random_angle_distribution" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[float].velocity_lower_limit">
<code class="descname">velocity_lower_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[float].velocity_lower_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the velocity lower limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in radians / s.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteJoint_[float].velocity_upper_limit">
<code class="descname">velocity_upper_limit</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteJoint_[float].velocity_upper_limit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the velocity upper limit for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in radians / s.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.RevoluteSpring">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">RevoluteSpring</code><a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.RevoluteSpring_[float]" title="pydrake.multibody.tree.RevoluteSpring_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.RevoluteSpring_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.RevoluteSpring_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">RevoluteSpring_</code><a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.RevoluteSpring_[float]" title="pydrake.multibody.tree.RevoluteSpring_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">RevoluteSpring_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.RevoluteSpring_[AutoDiffXd]" title="pydrake.multibody.tree.RevoluteSpring_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">RevoluteSpring_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.RevoluteSpring_[Expression]" title="pydrake.multibody.tree.RevoluteSpring_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">RevoluteSpring_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.RevoluteSpring_.RevoluteSpring_[float]">
<em class="property">class </em><code class="descname">RevoluteSpring_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring_.RevoluteSpring_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[float]" title="pydrake.multibody.tree.ForceElement_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ForceElement_[float]</span></code></a></p>
<p>This ForceElement models a torsional spring attached to a
RevoluteJoint and applies a torque to that joint</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>τ = -k⋅(θ - θ₀)
</pre></div>
</div>
<p>where θ₀ is the nominal joint position. Note that joint damping exists
within the RevoluteJoint itself, and so is not included here.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteSpring_.RevoluteSpring_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteSpring_[float], joint: pydrake.multibody.tree.RevoluteJoint_[float], nominal_angle: float, stiffness: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring_.RevoluteSpring_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor for a spring attached to the given joint</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">nominal_angle</span></code>:</dt>
<dd>The nominal angle of the spring θ₀, in radians, at which the
spring applies no moment.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">stiffness</span></code>:</dt>
<dd>The stiffness k of the spring in N⋅m/rad.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal notranslate"><span class="pre">stiffness</span></code> is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteSpring_.RevoluteSpring_[float].joint">
<code class="descname">joint</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteSpring_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RevoluteJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring_.RevoluteSpring_[float].joint" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteSpring_.RevoluteSpring_[float].nominal_angle">
<code class="descname">nominal_angle</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteSpring_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring_.RevoluteSpring_[float].nominal_angle" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteSpring_.RevoluteSpring_[float].stiffness">
<code class="descname">stiffness</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteSpring_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring_.RevoluteSpring_[float].stiffness" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.RevoluteSpring_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">RevoluteSpring_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[AutoDiffXd]" title="pydrake.multibody.tree.ForceElement_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ForceElement_[AutoDiffXd]</span></code></a></p>
<p>This ForceElement models a torsional spring attached to a
RevoluteJoint and applies a torque to that joint</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>τ = -k⋅(θ - θ₀)
</pre></div>
</div>
<p>where θ₀ is the nominal joint position. Note that joint damping exists
within the RevoluteJoint itself, and so is not included here.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteSpring_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteSpring_[AutoDiffXd], joint: pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd], nominal_angle: float, stiffness: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor for a spring attached to the given joint</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">nominal_angle</span></code>:</dt>
<dd>The nominal angle of the spring θ₀, in radians, at which the
spring applies no moment.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">stiffness</span></code>:</dt>
<dd>The stiffness k of the spring in N⋅m/rad.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal notranslate"><span class="pre">stiffness</span></code> is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteSpring_[AutoDiffXd].joint">
<code class="descname">joint</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteSpring_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RevoluteJoint_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring_[AutoDiffXd].joint" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteSpring_[AutoDiffXd].nominal_angle">
<code class="descname">nominal_angle</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteSpring_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring_[AutoDiffXd].nominal_angle" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteSpring_[AutoDiffXd].stiffness">
<code class="descname">stiffness</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteSpring_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring_[AutoDiffXd].stiffness" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.RevoluteSpring_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">RevoluteSpring_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[Expression]" title="pydrake.multibody.tree.ForceElement_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ForceElement_[Expression]</span></code></a></p>
<p>This ForceElement models a torsional spring attached to a
RevoluteJoint and applies a torque to that joint</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>τ = -k⋅(θ - θ₀)
</pre></div>
</div>
<p>where θ₀ is the nominal joint position. Note that joint damping exists
within the RevoluteJoint itself, and so is not included here.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteSpring_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteSpring_[Expression], joint: pydrake.multibody.tree.RevoluteJoint_[Expression], nominal_angle: float, stiffness: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor for a spring attached to the given joint</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">nominal_angle</span></code>:</dt>
<dd>The nominal angle of the spring θ₀, in radians, at which the
spring applies no moment.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">stiffness</span></code>:</dt>
<dd>The stiffness k of the spring in N⋅m/rad.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal notranslate"><span class="pre">stiffness</span></code> is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteSpring_[Expression].joint">
<code class="descname">joint</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteSpring_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RevoluteJoint_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring_[Expression].joint" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteSpring_[Expression].nominal_angle">
<code class="descname">nominal_angle</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteSpring_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring_[Expression].nominal_angle" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteSpring_[Expression].stiffness">
<code class="descname">stiffness</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteSpring_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring_[Expression].stiffness" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.RevoluteSpring_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">RevoluteSpring_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[float]" title="pydrake.multibody.tree.ForceElement_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ForceElement_[float]</span></code></a></p>
<p>This ForceElement models a torsional spring attached to a
RevoluteJoint and applies a torque to that joint</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>τ = -k⋅(θ - θ₀)
</pre></div>
</div>
<p>where θ₀ is the nominal joint position. Note that joint damping exists
within the RevoluteJoint itself, and so is not included here.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteSpring_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteSpring_[float], joint: pydrake.multibody.tree.RevoluteJoint_[float], nominal_angle: float, stiffness: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor for a spring attached to the given joint</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">nominal_angle</span></code>:</dt>
<dd>The nominal angle of the spring θ₀, in radians, at which the
spring applies no moment.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">stiffness</span></code>:</dt>
<dd>The stiffness k of the spring in N⋅m/rad.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if <code class="docutils literal notranslate"><span class="pre">stiffness</span></code> is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteSpring_[float].joint">
<code class="descname">joint</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteSpring_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RevoluteJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring_[float].joint" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteSpring_[float].nominal_angle">
<code class="descname">nominal_angle</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteSpring_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring_[float].nominal_angle" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RevoluteSpring_[float].stiffness">
<code class="descname">stiffness</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RevoluteSpring_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RevoluteSpring_[float].stiffness" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.RigidBody">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">RigidBody</code><a class="headerlink" href="#pydrake.multibody.tree.RigidBody" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.RigidBody_[float]" title="pydrake.multibody.tree.RigidBody_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.RigidBody_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.RigidBody_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">RigidBody_</code><a class="headerlink" href="#pydrake.multibody.tree.RigidBody_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.RigidBody_[float]" title="pydrake.multibody.tree.RigidBody_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">RigidBody_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.RigidBody_[AutoDiffXd]" title="pydrake.multibody.tree.RigidBody_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">RigidBody_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.RigidBody_[Expression]" title="pydrake.multibody.tree.RigidBody_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">RigidBody_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.RigidBody_.RigidBody_[float]">
<em class="property">class </em><code class="descname">RigidBody_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.RigidBody_.RigidBody_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Body_[float]" title="pydrake.multibody.tree.Body_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Body_[float]</span></code></a></p>
<p>The term <strong>rigid body</strong> implies that the deformations of the body
under consideration are so small that they have no significant effect
on the overall motions of the body and therefore deformations can be
neglected. If deformations are neglected, the distance between any two
points on the rigid body remains constant at all times. This
invariance of the distance between two arbitrary points is often taken
as the definition of a rigid body in classical treatments of multibody
mechanics [Goldstein 2001]. It can be demonstrated that the
unconstrained three-dimensional motions of a rigid body can be
described by six coordinates and thus it is often said that a free
body in space has six <strong>degrees of freedom</strong>. These degrees of freedom
obey the Newton-Euler equations of motion. However, within a
MultibodyTree, a RigidBody is <em>not</em> free in space; instead, it is
assigned a limited number of degrees of freedom (0-6) with respect to
its parent body in the multibody tree by its Mobilizer (also called a
“tree joint” or “inboard joint”). Additional constraints on
permissible motion can be added using Constraint objects to remove
more degrees of freedom.</p>
<ul class="simple">
<li><dl class="first docutils">
<dt>[Goldstein 2001] H Goldstein, CP Poole, JL Safko, Classical Mechanics</dt>
<dd>(3rd Edition), Addison-Wesley, 2001.</dd>
</dl>
</li>
</ul>
<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_.RigidBody_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.RigidBody_.RigidBody_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.RigidBody_[float], M_BBo_B: drake::multibody::SpatialInertia&lt;double&gt;) -&gt; None</li>
</ol>
<p>(Deprecated.)</p>
<dl class="docutils">
<dt>Deprecated:</dt>
<dd>The body_name parameter to the RigidBody constructor is now
required. This will be removed from Drake on or after 2022-12-01.</dd>
</dl>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.RigidBody_[float], body_name: str, M_BBo_B: drake::multibody::SpatialInertia&lt;double&gt;) -&gt; None</li>
</ol>
<p>Constructs a RigidBody named <code class="docutils literal notranslate"><span class="pre">body_name</span></code> with the given default
SpatialInertia.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_name</span></code>:</dt>
<dd>A name associated with <code class="docutils literal notranslate"><span class="pre">this</span></code> body.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt>
<dd>Spatial inertia of <code class="docutils literal notranslate"><span class="pre">this</span></code> body B about the frame’s origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code>
and expressed in the body frame B.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">See multibody_spatial_inertia for details on the monogram notation
used for spatial inertia quantities.</p>
</div>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.tree.RigidBody_[float], body_name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex, M_BBo_B: drake::multibody::SpatialInertia&lt;double&gt;) -&gt; None</li>
</ol>
<p>Constructs a RigidBody named <code class="docutils literal notranslate"><span class="pre">body_name</span></code> with the given default
SpatialInertia.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_name</span></code>:</dt>
<dd>A name associated with <code class="docutils literal notranslate"><span class="pre">this</span></code> body.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>:</dt>
<dd>The model instance associated with <code class="docutils literal notranslate"><span class="pre">this</span></code> body.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt>
<dd>Spatial inertia of <code class="docutils literal notranslate"><span class="pre">this</span></code> body B about the frame’s origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code>
and expressed in the body frame B.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">See multibody_spatial_inertia for details on the monogram notation
used for spatial inertia quantities.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_.RigidBody_[float].default_com">
<code class="descname">default_com</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_.RigidBody_[float].default_com" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default value of this rigid body’s center of mass as
measured and expressed in this body’s frame. This value is initially
supplied at construction when specifying this body’s SpatialInertia.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_BoBcm_B</span></code>:</dt>
<dd>The position of this rigid body B’s center of mass <code class="docutils literal notranslate"><span class="pre">Bcm</span></code>
measured from Bo (B’s frame origin) and expressed in B (body B’s
frame).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_.RigidBody_[float].default_mass">
<code class="descname">default_mass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_.RigidBody_[float].default_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns this rigid body’s default mass, which is initially supplied at
construction when specifying this rigid body’s SpatialInertia.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In general, a rigid body’s mass can be a constant property stored
in this rigid body’s SpatialInertia or a parameter that is stored
in a Context. The default constant mass value is used to
initialize the mass parameter in the Context.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_.RigidBody_[float].default_rotational_inertia">
<code class="descname">default_rotational_inertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[float]</em><span class="sig-paren">)</span> &#x2192; drake::multibody::RotationalInertia&lt;double&gt;<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_.RigidBody_[float].default_rotational_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default value of this body B’s rotational inertia about Bo
(B’s origin), expressed in B (this body’s frame). This value is
calculated from the SpatialInertia supplied at construction of this
body.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">I_BBo_B</span></code>:</dt>
<dd>body B’s rotational inertia about Bo, expressed in B.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_.RigidBody_[float].default_spatial_inertia">
<code class="descname">default_spatial_inertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[float]</em><span class="sig-paren">)</span> &#x2192; drake::multibody::SpatialInertia&lt;double&gt;<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_.RigidBody_[float].default_spatial_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default value of this body B’s spatial inertia about Bo (B’s
origin) and expressed in B (this body’s frame).</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt>
<dd>body B’s spatial inertia about Bo, expressed in B.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_.RigidBody_[float].default_unit_inertia">
<code class="descname">default_unit_inertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[float]</em><span class="sig-paren">)</span> &#x2192; drake::multibody::UnitInertia&lt;double&gt;<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_.RigidBody_[float].default_unit_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default value of this body B’s unit inertia about Bo (body
B’s origin), expressed in B (this body’s frame). This value is
initially supplied at construction when specifying this body’s
SpatialInertia.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_BBo_B</span></code>:</dt>
<dd>rigid body B’s unit inertia about Bo, expressed in B.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_.RigidBody_[float].SetCenterOfMassInBodyFrame">
<code class="descname">SetCenterOfMassInBodyFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[float], context: pydrake.systems.framework.Context_[float], com: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_.RigidBody_[float].SetCenterOfMassInBodyFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the center of mass stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> to <code class="docutils literal notranslate"><span class="pre">center_of_mass</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidBody is not owned by a</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">MultibodyPlant</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_.RigidBody_[float].SetMass">
<code class="descname">SetMass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[float], context: pydrake.systems.framework.Context_[float], mass: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_.RigidBody_[float].SetMass" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the mass stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> to <code class="docutils literal notranslate"><span class="pre">mass</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidBody is not owned by a</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">MultibodyPlant</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_.RigidBody_[float].SetSpatialInertiaInBodyFrame">
<code class="descname">SetSpatialInertiaInBodyFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[float], context: pydrake.systems.framework.Context_[float], M_Bo_B: drake::multibody::SpatialInertia&lt;double&gt;</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_.RigidBody_[float].SetSpatialInertiaInBodyFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the spatial inertia stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> to <code class="docutils literal notranslate"><span class="pre">M_Bo_B</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidBody is not owned by a</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">MultibodyPlant</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.RigidBody_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">RigidBody_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Body_[AutoDiffXd]" title="pydrake.multibody.tree.Body_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Body_[AutoDiffXd]</span></code></a></p>
<p>The term <strong>rigid body</strong> implies that the deformations of the body
under consideration are so small that they have no significant effect
on the overall motions of the body and therefore deformations can be
neglected. If deformations are neglected, the distance between any two
points on the rigid body remains constant at all times. This
invariance of the distance between two arbitrary points is often taken
as the definition of a rigid body in classical treatments of multibody
mechanics [Goldstein 2001]. It can be demonstrated that the
unconstrained three-dimensional motions of a rigid body can be
described by six coordinates and thus it is often said that a free
body in space has six <strong>degrees of freedom</strong>. These degrees of freedom
obey the Newton-Euler equations of motion. However, within a
MultibodyTree, a RigidBody is <em>not</em> free in space; instead, it is
assigned a limited number of degrees of freedom (0-6) with respect to
its parent body in the multibody tree by its Mobilizer (also called a
“tree joint” or “inboard joint”). Additional constraints on
permissible motion can be added using Constraint objects to remove
more degrees of freedom.</p>
<ul class="simple">
<li><dl class="first docutils">
<dt>[Goldstein 2001] H Goldstein, CP Poole, JL Safko, Classical Mechanics</dt>
<dd>(3rd Edition), Addison-Wesley, 2001.</dd>
</dl>
</li>
</ul>
<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.RigidBody_[AutoDiffXd], M_BBo_B: pydrake.multibody.tree.SpatialInertia_[float]) -&gt; None</li>
</ol>
<p>(Deprecated.)</p>
<dl class="docutils">
<dt>Deprecated:</dt>
<dd>The body_name parameter to the RigidBody constructor is now
required. This will be removed from Drake on or after 2022-12-01.</dd>
</dl>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.RigidBody_[AutoDiffXd], body_name: str, M_BBo_B: pydrake.multibody.tree.SpatialInertia_[float]) -&gt; None</li>
</ol>
<p>Constructs a RigidBody named <code class="docutils literal notranslate"><span class="pre">body_name</span></code> with the given default
SpatialInertia.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_name</span></code>:</dt>
<dd>A name associated with <code class="docutils literal notranslate"><span class="pre">this</span></code> body.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt>
<dd>Spatial inertia of <code class="docutils literal notranslate"><span class="pre">this</span></code> body B about the frame’s origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code>
and expressed in the body frame B.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">See multibody_spatial_inertia for details on the monogram notation
used for spatial inertia quantities.</p>
</div>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.tree.RigidBody_[AutoDiffXd], body_name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex, M_BBo_B: pydrake.multibody.tree.SpatialInertia_[float]) -&gt; None</li>
</ol>
<p>Constructs a RigidBody named <code class="docutils literal notranslate"><span class="pre">body_name</span></code> with the given default
SpatialInertia.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_name</span></code>:</dt>
<dd>A name associated with <code class="docutils literal notranslate"><span class="pre">this</span></code> body.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>:</dt>
<dd>The model instance associated with <code class="docutils literal notranslate"><span class="pre">this</span></code> body.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt>
<dd>Spatial inertia of <code class="docutils literal notranslate"><span class="pre">this</span></code> body B about the frame’s origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code>
and expressed in the body frame B.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">See multibody_spatial_inertia for details on the monogram notation
used for spatial inertia quantities.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_[AutoDiffXd].default_com">
<code class="descname">default_com</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[AutoDiffXd].default_com" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default value of this rigid body’s center of mass as
measured and expressed in this body’s frame. This value is initially
supplied at construction when specifying this body’s SpatialInertia.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_BoBcm_B</span></code>:</dt>
<dd>The position of this rigid body B’s center of mass <code class="docutils literal notranslate"><span class="pre">Bcm</span></code>
measured from Bo (B’s frame origin) and expressed in B (body B’s
frame).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_[AutoDiffXd].default_mass">
<code class="descname">default_mass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[AutoDiffXd].default_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns this rigid body’s default mass, which is initially supplied at
construction when specifying this rigid body’s SpatialInertia.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In general, a rigid body’s mass can be a constant property stored
in this rigid body’s SpatialInertia or a parameter that is stored
in a Context. The default constant mass value is used to
initialize the mass parameter in the Context.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_[AutoDiffXd].default_rotational_inertia">
<code class="descname">default_rotational_inertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RotationalInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[AutoDiffXd].default_rotational_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default value of this body B’s rotational inertia about Bo
(B’s origin), expressed in B (this body’s frame). This value is
calculated from the SpatialInertia supplied at construction of this
body.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">I_BBo_B</span></code>:</dt>
<dd>body B’s rotational inertia about Bo, expressed in B.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_[AutoDiffXd].default_spatial_inertia">
<code class="descname">default_spatial_inertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.SpatialInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[AutoDiffXd].default_spatial_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default value of this body B’s spatial inertia about Bo (B’s
origin) and expressed in B (this body’s frame).</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt>
<dd>body B’s spatial inertia about Bo, expressed in B.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_[AutoDiffXd].default_unit_inertia">
<code class="descname">default_unit_inertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[AutoDiffXd].default_unit_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default value of this body B’s unit inertia about Bo (body
B’s origin), expressed in B (this body’s frame). This value is
initially supplied at construction when specifying this body’s
SpatialInertia.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_BBo_B</span></code>:</dt>
<dd>rigid body B’s unit inertia about Bo, expressed in B.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_[AutoDiffXd].SetCenterOfMassInBodyFrame">
<code class="descname">SetCenterOfMassInBodyFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], com: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[AutoDiffXd].SetCenterOfMassInBodyFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the center of mass stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> to <code class="docutils literal notranslate"><span class="pre">center_of_mass</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidBody is not owned by a</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">MultibodyPlant</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_[AutoDiffXd].SetMass">
<code class="descname">SetMass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], mass: pydrake.autodiffutils.AutoDiffXd</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[AutoDiffXd].SetMass" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the mass stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> to <code class="docutils literal notranslate"><span class="pre">mass</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidBody is not owned by a</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">MultibodyPlant</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_[AutoDiffXd].SetSpatialInertiaInBodyFrame">
<code class="descname">SetSpatialInertiaInBodyFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], M_Bo_B: drake::multibody::SpatialInertia&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[AutoDiffXd].SetSpatialInertiaInBodyFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the spatial inertia stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> to <code class="docutils literal notranslate"><span class="pre">M_Bo_B</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidBody is not owned by a</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">MultibodyPlant</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.RigidBody_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">RigidBody_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Body_[Expression]" title="pydrake.multibody.tree.Body_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Body_[Expression]</span></code></a></p>
<p>The term <strong>rigid body</strong> implies that the deformations of the body
under consideration are so small that they have no significant effect
on the overall motions of the body and therefore deformations can be
neglected. If deformations are neglected, the distance between any two
points on the rigid body remains constant at all times. This
invariance of the distance between two arbitrary points is often taken
as the definition of a rigid body in classical treatments of multibody
mechanics [Goldstein 2001]. It can be demonstrated that the
unconstrained three-dimensional motions of a rigid body can be
described by six coordinates and thus it is often said that a free
body in space has six <strong>degrees of freedom</strong>. These degrees of freedom
obey the Newton-Euler equations of motion. However, within a
MultibodyTree, a RigidBody is <em>not</em> free in space; instead, it is
assigned a limited number of degrees of freedom (0-6) with respect to
its parent body in the multibody tree by its Mobilizer (also called a
“tree joint” or “inboard joint”). Additional constraints on
permissible motion can be added using Constraint objects to remove
more degrees of freedom.</p>
<ul class="simple">
<li><dl class="first docutils">
<dt>[Goldstein 2001] H Goldstein, CP Poole, JL Safko, Classical Mechanics</dt>
<dd>(3rd Edition), Addison-Wesley, 2001.</dd>
</dl>
</li>
</ul>
<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.RigidBody_[Expression], M_BBo_B: pydrake.multibody.tree.SpatialInertia_[float]) -&gt; None</li>
</ol>
<p>(Deprecated.)</p>
<dl class="docutils">
<dt>Deprecated:</dt>
<dd>The body_name parameter to the RigidBody constructor is now
required. This will be removed from Drake on or after 2022-12-01.</dd>
</dl>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.RigidBody_[Expression], body_name: str, M_BBo_B: pydrake.multibody.tree.SpatialInertia_[float]) -&gt; None</li>
</ol>
<p>Constructs a RigidBody named <code class="docutils literal notranslate"><span class="pre">body_name</span></code> with the given default
SpatialInertia.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_name</span></code>:</dt>
<dd>A name associated with <code class="docutils literal notranslate"><span class="pre">this</span></code> body.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt>
<dd>Spatial inertia of <code class="docutils literal notranslate"><span class="pre">this</span></code> body B about the frame’s origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code>
and expressed in the body frame B.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">See multibody_spatial_inertia for details on the monogram notation
used for spatial inertia quantities.</p>
</div>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.tree.RigidBody_[Expression], body_name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex, M_BBo_B: pydrake.multibody.tree.SpatialInertia_[float]) -&gt; None</li>
</ol>
<p>Constructs a RigidBody named <code class="docutils literal notranslate"><span class="pre">body_name</span></code> with the given default
SpatialInertia.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_name</span></code>:</dt>
<dd>A name associated with <code class="docutils literal notranslate"><span class="pre">this</span></code> body.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>:</dt>
<dd>The model instance associated with <code class="docutils literal notranslate"><span class="pre">this</span></code> body.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt>
<dd>Spatial inertia of <code class="docutils literal notranslate"><span class="pre">this</span></code> body B about the frame’s origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code>
and expressed in the body frame B.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">See multibody_spatial_inertia for details on the monogram notation
used for spatial inertia quantities.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_[Expression].default_com">
<code class="descname">default_com</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[Expression].default_com" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default value of this rigid body’s center of mass as
measured and expressed in this body’s frame. This value is initially
supplied at construction when specifying this body’s SpatialInertia.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_BoBcm_B</span></code>:</dt>
<dd>The position of this rigid body B’s center of mass <code class="docutils literal notranslate"><span class="pre">Bcm</span></code>
measured from Bo (B’s frame origin) and expressed in B (body B’s
frame).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_[Expression].default_mass">
<code class="descname">default_mass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[Expression].default_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns this rigid body’s default mass, which is initially supplied at
construction when specifying this rigid body’s SpatialInertia.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In general, a rigid body’s mass can be a constant property stored
in this rigid body’s SpatialInertia or a parameter that is stored
in a Context. The default constant mass value is used to
initialize the mass parameter in the Context.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_[Expression].default_rotational_inertia">
<code class="descname">default_rotational_inertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RotationalInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[Expression].default_rotational_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default value of this body B’s rotational inertia about Bo
(B’s origin), expressed in B (this body’s frame). This value is
calculated from the SpatialInertia supplied at construction of this
body.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">I_BBo_B</span></code>:</dt>
<dd>body B’s rotational inertia about Bo, expressed in B.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_[Expression].default_spatial_inertia">
<code class="descname">default_spatial_inertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.SpatialInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[Expression].default_spatial_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default value of this body B’s spatial inertia about Bo (B’s
origin) and expressed in B (this body’s frame).</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt>
<dd>body B’s spatial inertia about Bo, expressed in B.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_[Expression].default_unit_inertia">
<code class="descname">default_unit_inertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[Expression].default_unit_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default value of this body B’s unit inertia about Bo (body
B’s origin), expressed in B (this body’s frame). This value is
initially supplied at construction when specifying this body’s
SpatialInertia.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_BBo_B</span></code>:</dt>
<dd>rigid body B’s unit inertia about Bo, expressed in B.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_[Expression].SetCenterOfMassInBodyFrame">
<code class="descname">SetCenterOfMassInBodyFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[Expression], context: pydrake.systems.framework.Context_[Expression], com: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[Expression].SetCenterOfMassInBodyFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the center of mass stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> to <code class="docutils literal notranslate"><span class="pre">center_of_mass</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidBody is not owned by a</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">MultibodyPlant</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_[Expression].SetMass">
<code class="descname">SetMass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[Expression], context: pydrake.systems.framework.Context_[Expression], mass: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[Expression].SetMass" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the mass stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> to <code class="docutils literal notranslate"><span class="pre">mass</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidBody is not owned by a</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">MultibodyPlant</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_[Expression].SetSpatialInertiaInBodyFrame">
<code class="descname">SetSpatialInertiaInBodyFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[Expression], context: pydrake.systems.framework.Context_[Expression], M_Bo_B: drake::multibody::SpatialInertia&lt;drake::symbolic::Expression&gt;</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[Expression].SetSpatialInertiaInBodyFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the spatial inertia stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> to <code class="docutils literal notranslate"><span class="pre">M_Bo_B</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidBody is not owned by a</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">MultibodyPlant</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.RigidBody_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">RigidBody_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Body_[float]" title="pydrake.multibody.tree.Body_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Body_[float]</span></code></a></p>
<p>The term <strong>rigid body</strong> implies that the deformations of the body
under consideration are so small that they have no significant effect
on the overall motions of the body and therefore deformations can be
neglected. If deformations are neglected, the distance between any two
points on the rigid body remains constant at all times. This
invariance of the distance between two arbitrary points is often taken
as the definition of a rigid body in classical treatments of multibody
mechanics [Goldstein 2001]. It can be demonstrated that the
unconstrained three-dimensional motions of a rigid body can be
described by six coordinates and thus it is often said that a free
body in space has six <strong>degrees of freedom</strong>. These degrees of freedom
obey the Newton-Euler equations of motion. However, within a
MultibodyTree, a RigidBody is <em>not</em> free in space; instead, it is
assigned a limited number of degrees of freedom (0-6) with respect to
its parent body in the multibody tree by its Mobilizer (also called a
“tree joint” or “inboard joint”). Additional constraints on
permissible motion can be added using Constraint objects to remove
more degrees of freedom.</p>
<ul class="simple">
<li><dl class="first docutils">
<dt>[Goldstein 2001] H Goldstein, CP Poole, JL Safko, Classical Mechanics</dt>
<dd>(3rd Edition), Addison-Wesley, 2001.</dd>
</dl>
</li>
</ul>
<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.RigidBody_[float], M_BBo_B: drake::multibody::SpatialInertia&lt;double&gt;) -&gt; None</li>
</ol>
<p>(Deprecated.)</p>
<dl class="docutils">
<dt>Deprecated:</dt>
<dd>The body_name parameter to the RigidBody constructor is now
required. This will be removed from Drake on or after 2022-12-01.</dd>
</dl>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.RigidBody_[float], body_name: str, M_BBo_B: drake::multibody::SpatialInertia&lt;double&gt;) -&gt; None</li>
</ol>
<p>Constructs a RigidBody named <code class="docutils literal notranslate"><span class="pre">body_name</span></code> with the given default
SpatialInertia.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_name</span></code>:</dt>
<dd>A name associated with <code class="docutils literal notranslate"><span class="pre">this</span></code> body.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt>
<dd>Spatial inertia of <code class="docutils literal notranslate"><span class="pre">this</span></code> body B about the frame’s origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code>
and expressed in the body frame B.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">See multibody_spatial_inertia for details on the monogram notation
used for spatial inertia quantities.</p>
</div>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.tree.RigidBody_[float], body_name: str, model_instance: pydrake.multibody.tree.ModelInstanceIndex, M_BBo_B: drake::multibody::SpatialInertia&lt;double&gt;) -&gt; None</li>
</ol>
<p>Constructs a RigidBody named <code class="docutils literal notranslate"><span class="pre">body_name</span></code> with the given default
SpatialInertia.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">body_name</span></code>:</dt>
<dd>A name associated with <code class="docutils literal notranslate"><span class="pre">this</span></code> body.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">model_instance</span></code>:</dt>
<dd>The model instance associated with <code class="docutils literal notranslate"><span class="pre">this</span></code> body.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt>
<dd>Spatial inertia of <code class="docutils literal notranslate"><span class="pre">this</span></code> body B about the frame’s origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code>
and expressed in the body frame B.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">See multibody_spatial_inertia for details on the monogram notation
used for spatial inertia quantities.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_[float].default_com">
<code class="descname">default_com</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[float].default_com" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default value of this rigid body’s center of mass as
measured and expressed in this body’s frame. This value is initially
supplied at construction when specifying this body’s SpatialInertia.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">p_BoBcm_B</span></code>:</dt>
<dd>The position of this rigid body B’s center of mass <code class="docutils literal notranslate"><span class="pre">Bcm</span></code>
measured from Bo (B’s frame origin) and expressed in B (body B’s
frame).</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_[float].default_mass">
<code class="descname">default_mass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[float].default_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns this rigid body’s default mass, which is initially supplied at
construction when specifying this rigid body’s SpatialInertia.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In general, a rigid body’s mass can be a constant property stored
in this rigid body’s SpatialInertia or a parameter that is stored
in a Context. The default constant mass value is used to
initialize the mass parameter in the Context.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_[float].default_rotational_inertia">
<code class="descname">default_rotational_inertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[float]</em><span class="sig-paren">)</span> &#x2192; drake::multibody::RotationalInertia&lt;double&gt;<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[float].default_rotational_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default value of this body B’s rotational inertia about Bo
(B’s origin), expressed in B (this body’s frame). This value is
calculated from the SpatialInertia supplied at construction of this
body.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">I_BBo_B</span></code>:</dt>
<dd>body B’s rotational inertia about Bo, expressed in B.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_[float].default_spatial_inertia">
<code class="descname">default_spatial_inertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[float]</em><span class="sig-paren">)</span> &#x2192; drake::multibody::SpatialInertia&lt;double&gt;<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[float].default_spatial_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default value of this body B’s spatial inertia about Bo (B’s
origin) and expressed in B (this body’s frame).</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_BBo_B</span></code>:</dt>
<dd>body B’s spatial inertia about Bo, expressed in B.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_[float].default_unit_inertia">
<code class="descname">default_unit_inertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[float]</em><span class="sig-paren">)</span> &#x2192; drake::multibody::UnitInertia&lt;double&gt;<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[float].default_unit_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the default value of this body B’s unit inertia about Bo (body
B’s origin), expressed in B (this body’s frame). This value is
initially supplied at construction when specifying this body’s
SpatialInertia.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_BBo_B</span></code>:</dt>
<dd>rigid body B’s unit inertia about Bo, expressed in B.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_[float].SetCenterOfMassInBodyFrame">
<code class="descname">SetCenterOfMassInBodyFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[float], context: pydrake.systems.framework.Context_[float], com: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[float].SetCenterOfMassInBodyFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the center of mass stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> to <code class="docutils literal notranslate"><span class="pre">center_of_mass</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidBody is not owned by a</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">MultibodyPlant</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_[float].SetMass">
<code class="descname">SetMass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[float], context: pydrake.systems.framework.Context_[float], mass: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[float].SetMass" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the mass stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> to <code class="docutils literal notranslate"><span class="pre">mass</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidBody is not owned by a</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">MultibodyPlant</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RigidBody_[float].SetSpatialInertiaInBodyFrame">
<code class="descname">SetSpatialInertiaInBodyFrame</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RigidBody_[float], context: pydrake.systems.framework.Context_[float], M_Bo_B: drake::multibody::SpatialInertia&lt;double&gt;</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RigidBody_[float].SetSpatialInertiaInBodyFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the spatial inertia stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> to <code class="docutils literal notranslate"><span class="pre">M_Bo_B</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if <code class="docutils literal notranslate"><span class="pre">this</span></code> RigidBody is not owned by a</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">MultibodyPlant</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.RotationalInertia">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">RotationalInertia</code><a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.RotationalInertia_[float]" title="pydrake.multibody.tree.RotationalInertia_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.RotationalInertia_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.RotationalInertia_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">RotationalInertia_</code><a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.RotationalInertia_[float]" title="pydrake.multibody.tree.RotationalInertia_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotationalInertia_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]" title="pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotationalInertia_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.RotationalInertia_[Expression]" title="pydrake.multibody.tree.RotationalInertia_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">RotationalInertia_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float]">
<em class="property">class </em><code class="descname">RotationalInertia_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class describes the mass distribution (inertia properties) of a
body or composite body about a particular point. Herein, “composite
body” means one body or a collection of bodies that are welded
together. In this documentation, “body” and “composite body” are used
interchangeably.</p>
<p>A <strong>rigid</strong> body’s mass distribution is described by three quantities:
the body’s mass; the body’s center of mass; and the body’s rotational
inertia about a particular point. The term <strong>rotational inertia</strong> is
used here and by [Jain 2010] to distinguish from a body’s <strong>spatial
inertia</strong>. In this class, a 3x3 <strong>inertia matrix</strong> I represents a
body’s rotational inertia about a point and expressed in a frame. More
specifically, <code class="docutils literal notranslate"><span class="pre">I_BP_E</span></code> is the inertia matrix of a body B about-point
P and expressed-in frame E (herein frame E’s orthogonal unit vectors
Ex, Ey, Ez are denoted 𝐱̂, 𝐲̂, 𝐳̂).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span> <span class="n">Ixx</span> <span class="n">Ixy</span> <span class="n">Ixz</span> <span class="o">|</span>
<span class="n">I</span> <span class="o">=</span> <span class="o">|</span> <span class="n">Ixy</span> <span class="n">Iyy</span> <span class="n">Iyz</span> <span class="o">|</span>
    <span class="o">|</span> <span class="n">Ixz</span> <span class="n">Iyz</span> <span class="n">Izz</span> <span class="o">|</span>
</pre></div>
</div>
<p>The moments of inertia Ixx, Iyy, Izz and products of inertia Ixy, Ixz,
Iyz are defined in terms of the mass dm of a differential volume of
the body. The position of dm from about-point P is xx̂ + yŷ + zẑ =
[x, y, z]_E.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Ixx = ∫ (y² + z²) dm
Iyy = ∫ (x² + z²) dm
Izz = ∫ (x² + y²) dm
Ixy = - ∫ x y dm
Ixz = - ∫ x z dm
Iyz = - ∫ y z dm
</pre></div>
</div>
<p>We use the negated convention for products of inertia, so that I
serves to relate angular velocity ω and angular momentum h via <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">=</span> <span class="pre">I</span>
<span class="pre">⋅</span> <span class="pre">ω</span></code>. Ensure your products of inertia follow this negative sign
convention.</p>
<p>The 3x3 inertia matrix is symmetric and its diagonal elements (moments
of inertia) and off-diagonal elements (products of inertia) are
associated with a body (or composite body) S, an about-point P, and an
expressed-in frame E (𝐱̂, 𝐲̂, 𝐳̂̂). A rotational inertia is
ill-defined unless there is a body S, about-point P, and expressed-in
frame E. The user of this class is responsible for tracking the body
S, about-point P and expressed-in frame E (none of these are stored in
this class).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class does not store the about-point nor the expressed-in
frame, nor does this class help enforce consistency of the
about-point or expressed-in frame. To help users of this class
track the about-point and expressed-in frame, we strongly
recommend the following notation.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In typeset material, use the symbol <span class="math notranslate nohighlight">\([I^{S/P}]_E\)</span> to
represent the rotational inertia (inertia matrix) of a body (or
composite body) S about-point P, expressed in frame E. In code and
comments, use the monogram notation <code class="docutils literal notranslate"><span class="pre">I_SP_E</span></code> (e.g., as described
in multibody_spatial_inertia). If the about-point P is fixed to a
body B, the point is named <span class="math notranslate nohighlight">\(B_P\)</span> and this appears in
code/comments as <code class="docutils literal notranslate"><span class="pre">Bp</span></code>. Examples: <code class="docutils literal notranslate"><span class="pre">I_BBp_E</span></code> is rigid body B’s
rotational inertia about-point Bp expressed-in frame E; I_BBo_E is
B’s rotational inertia about-point <code class="docutils literal notranslate"><span class="pre">Bo</span></code> (body B’s origin)
expressed-in frame E; and I_BBcm_E is B’s inertia matrix
about-point <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> (B’s center of mass) expressed-in frame E.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The rotational inertia (inertia matrix) can be re-expressed in
terms of a special frame whose orthogonal unit vectors are
parallel to <strong>principal axes of inertia</strong> so that the inertia
matrix is diagonalized with elements called <strong>principal moments of
inertia</strong>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The formal definition of the inertia matrix <span class="math notranslate nohighlight">\(I^{S/P}\)</span> of a
system S about a point P follows the definition of the inertia
dyadic 𝐈 of S about P, which begins by modeling S with n particles
S₁ … Sₙ (e.g., 12 grams of carbon can be modeled with n = 6.02 *
10²³ molecules/particles). The inertia dyadic 𝐈₁ of one particle
S₁ about point P is defined [Kane, 1985] in terms of m₁ (mass of
S₁), ᴾ𝐩ˢ¹ (position vector from P to S₁), and the unit dyadic 𝐔
which is defined by the property 𝐔 ⋅ 𝐯 = 𝐯 where 𝐯 is is any
vector (this definition of 𝐔 is analogous to defining the identity
matrix by the property 𝑰𝒅𝒆𝒏𝒕𝒊𝒕𝒚𝑴𝒂𝒕𝒓𝒊𝒙 * 𝒂𝒏𝒚𝑴𝒂𝒕𝒓𝒊𝒙 = 𝒂𝒏𝒚𝑴𝒂𝒕𝒓𝒊𝒙).</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>𝐈₁ = m₁ * [𝐔 * (ᴾ𝐩ˢ¹ ⋅ ᴾ𝐩ˢ¹)  -  ᴾ𝐩ˢ¹ * ᴾ𝐩ˢ¹]
</pre></div>
</div>
<p>Note: The vector dot-product (⋅) above produces a scalar whereas the
vector multiply (*) produces a dyadic which is a 2nd-order tensor
(ᴾ𝐩ˢ¹ * ᴾ𝐩ˢ¹ is similar to the matrix outer-product of a 3x1 matrix
multiplied by a 1x3 matrix). An example inertia dyadic for a single
particle is shown further below. The inertia dyadic 𝐈 of the entire
system S is defined by summing the inertia dyadic of each particle Sᵢ
about P (i = 1, … n), i.e.,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>𝐈 = 𝐈₁ + 𝐈₂ + ... 𝐈ₙ
</pre></div>
</div>
<p>The elements of the inertia matrix <span class="math notranslate nohighlight">\([I^{S/P}]_E\)</span> expressed in
frame E (in terms of orthogonal unit vectors 𝐱̂, 𝐲̂, 𝐳̂̂) are found by
pre-dot multiplying and post-dot multiplying 𝐈 with appropriate unit
vectors.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Ixx = 𝐱̂ ⋅ 𝐈 ⋅ 𝐱̂     Ixy = 𝐱̂ ⋅ 𝐈 ⋅ 𝐲̂      Ixz = 𝐱̂ ⋅ 𝐈 ⋅ 𝐳̂̂
   Iyx = 𝐲̂ ⋅ 𝐈 ⋅ 𝐱̂     Iyy = 𝐲̂ ⋅ 𝐈 ⋅ 𝐲̂      Iyz = 𝐲̂ ⋅ 𝐈 ⋅ 𝐳̂̂
   Izx = 𝐳̂̂ ⋅ 𝐈 ⋅ 𝐱̂     Izy = 𝐳̂̂ ⋅ 𝐈 ⋅ 𝐲̂      Izz = 𝐳̂̂ ⋅ 𝐈 ⋅ 𝐳̂̂
</pre></div>
</div>
<p>The inertia dyadic 𝐈ᴮ of a rigid body B about Bcm (B’s center of mass)
is related to various dynamic quantities. For example, B’s angular
momentum 𝐇 about Bcm in a frame N and B’s kinetic energy KE in N
relate to 𝐈ᴮ by</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>𝐇 = 𝐈ᴮ ⋅ 𝛚
   KE = 1/2 𝛚 ⋅ 𝐈ᴮ ⋅ 𝛚  +  1/2 mᴮ 𝐯 ⋅ 𝐯
</pre></div>
</div>
<p>where 𝛚 is B’s angular velocity in N, 𝐯 is Bcm’s translational
velocity in N, and mᴮ is B’s mass. When frame N happens to be a
Newtonian frame (also called an inertial frame or
non-rotating/non-accelerating frame), the moment 𝐓 of all forces on B
about Bcm relates to 𝐈ᴮ and 𝛂 (B’s angular acceleration in N) by
Euler’s rigid body equation as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>𝐓 = 𝐈ᴮ ⋅ 𝛂  +  𝛚 × 𝐈ᴮ ⋅ 𝛚
</pre></div>
</div>
<p>Example: For a particle Q of mass m whose position vector from a point
O is written in terms of right-handed orthogonal unit vectors 𝐱̂, 𝐲̂,
𝐳̂ (below), the inertia dyadic 𝐈 of particle Q about point O is
defined and calculated</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>𝐩 = x 𝐱̂  +  y 𝐲̂                               (given)
    𝐈 = m * [𝐔 * (𝐩 ⋅ 𝐩)  -  𝐩 * 𝐩]              (definition)
      = m * [𝐔 * (x² + y²)  -  (x𝐱̂ + y𝐲̂̂) * (x𝐱̂ + y𝐲̂)
      = m * [(𝐱̂𝐱̂ + 𝐲̂𝐲̂ + 𝐳̂𝐳̂) * (x² + y²) - (x²𝐱̂𝐱̂ + xy𝐱̂𝐲̂̂ + xy𝐲̂̂𝐱̂ + y²𝐲̂̂𝐲̂̂)]
      = m * [y²𝐱̂𝐱̂ + x²𝐲̂𝐲̂ + (x² + y²)𝐳̂𝐳̂ - xy𝐱̂𝐲̂̂ - xy𝐲̂̂𝐱̂]
</pre></div>
</div>
<p>which means the inertia matrix for particle Q about point O for 𝐱̂,
𝐲̂, 𝐳̂ is</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>|  m y²     -m x y         0     |
I = | -m x y     m x²          0     |
    |    0         0     m (x² + y²) |
</pre></div>
</div>
<p>[Kane, 1985] pg. 68. “Dynamics: Theory and Applications,” McGraw-Hill
Co., New York, 1985 (with D. A. Levinson). Available for free .pdf
download: <a class="reference external" href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Several methods in this class throw a RuntimeError for invalid
rotational inertia operations in debug releases only. This
provides speed in a release build while facilitating debugging in
debug builds. In addition, these validity tests are only performed
for scalar types for which drake::scalar_predicate&lt;T&gt;::is_bool is
<code class="docutils literal notranslate"><span class="pre">True</span></code>. For instance, validity checks are not performed when T
is symbolic::Expression.</p>
</div>
<p>Various methods in this class require numerical (not symbolic) data
types.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.RotationalInertia_[float]) -&gt; None</li>
</ol>
<p>Constructs a rotational inertia that has all its moments/products of
inertia equal to NaN (helps quickly detect uninitialized values).</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.RotationalInertia_[float], Ixx: float, Iyy: float, Izz: float) -&gt; None</li>
</ol>
<p>Creates a rotational inertia with moments of inertia <code class="docutils literal notranslate"><span class="pre">Ixx</span></code>, <cite>Iyy</cite>,
<code class="docutils literal notranslate"><span class="pre">Izz</span></code>, and with each product of inertia set to zero.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError for Debug builds if not CouldBePhysicallyValid().</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.tree.RotationalInertia_[float], Ixx: float, Iyy: float, Izz: float, Ixy: float, Ixz: float, Iyz: float) -&gt; None</li>
</ol>
<p>Creates a rotational inertia with moments of inertia <code class="docutils literal notranslate"><span class="pre">Ixx</span></code>, <cite>Iyy</cite>,
<code class="docutils literal notranslate"><span class="pre">Izz</span></code>, and with products of inertia <code class="docutils literal notranslate"><span class="pre">Ixy</span></code>, <cite>Ixz</cite>, <code class="docutils literal notranslate"><span class="pre">Iyz</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError for Debug builds if not CouldBePhysicallyValid().</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="4">
<li>__init__(self: pydrake.multibody.tree.RotationalInertia_[float], mass: float, p_PQ_E: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</li>
</ol>
<p>Constructs a rotational inertia for a particle Q of mass <code class="docutils literal notranslate"><span class="pre">mass</span></code>,
whose position vector from about-point P is p_PQ_E (E is expressed-in
frame). This RuntimeError exception only occurs if <code class="docutils literal notranslate"><span class="pre">mass</span></code> &lt; 0.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt>
<dd>The mass of particle Q.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PQ_E</span></code>:</dt>
<dd>Position from about-point P to Q, expressed-in frame E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">I_QP_E</span></code>:</dt>
<dd>, Q’s rotational inertia about-point P expressed-in frame E.</dd>
<dt>Remark:</dt>
<dd>Negating the position vector p_PQ_E has no affect on the result.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError for Debug builds if not CouldBePhysicallyValid().</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float].CalcMaximumPossibleMomentOfInertia">
<code class="descname">CalcMaximumPossibleMomentOfInertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float].CalcMaximumPossibleMomentOfInertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the maximum possible moment of inertia for <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational
inertia about-point P for any expressed-in frame E.</p>
<dl class="docutils">
<dt>Remark:</dt>
<dd>The maximum moment Imax has range: trace / 3 &lt;= Imax &lt;= trace / 2.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Trace()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float].CalcPrincipalMomentsOfInertia">
<code class="descname">CalcPrincipalMomentsOfInertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float].CalcPrincipalMomentsOfInertia" title="Permalink to this definition">¶</a></dt>
<dd><p>This method takes <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia about-point P,
expressed-in frame E, and computes its principal moments of inertia
about-point P, but expressed-in a frame aligned with the principal
axes.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">: This method only works for a rotational inertia with scalar type
T that can be converted to a double (discarding any supplemental
scalar data such as derivatives of an AutoDiffXd).</p>
</div>
<dl class="docutils">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">principal_moments</span></code>:</dt>
<dd>The vector of principal moments of inertia <code class="docutils literal notranslate"><span class="pre">[Ixx</span> <span class="pre">Iyy</span> <span class="pre">Izz]</span></code>
sorted in ascending order.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if eigenvalue solver fails or if scalar type T cannot</li>
<li>be converted to a double.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float].cols">
<code class="descname">cols</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float].cols" title="Permalink to this definition">¶</a></dt>
<dd><p>For consistency with Eigen’s API, the cols() method returns 3.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float].CopyToFullMatrix3">
<code class="descname">CopyToFullMatrix3</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 3]]<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float].CopyToFullMatrix3" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a full 3x3 matrix copy of this rotational inertia. The returned
copy is symmetric and includes both lower and upper parts of the
matrix.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float].CouldBePhysicallyValid">
<code class="descname">CouldBePhysicallyValid</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float].CouldBePhysicallyValid" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs several necessary checks to verify whether <code class="docutils literal notranslate"><span class="pre">this</span></code>
rotational inertia <em>could</em> be physically valid, including:</p>
<ul class="simple">
<li>No NaN moments or products of inertia.</li>
<li>Ixx, Iyy, Izz and principal moments are all non-negative.</li>
<li>Ixx, Iyy  Izz and principal moments satisfy the triangle inequality:
- <code class="docutils literal notranslate"><span class="pre">Ixx</span> <span class="pre">+</span> <span class="pre">Iyy</span> <span class="pre">&gt;=</span> <span class="pre">Izz</span></code>
- <cite>Ixx + Izz &gt;= Iyy</cite>
- <code class="docutils literal notranslate"><span class="pre">Iyy</span> <span class="pre">+</span> <span class="pre">Izz</span> <span class="pre">&gt;=</span> <span class="pre">Ixx</span></code></li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">These checks are necessary (but NOT sufficient) conditions for a
rotational inertia to be physically valid. The sufficient
condition requires a rotational inertia to satisfy the above
checks <em>after</em> <code class="docutils literal notranslate"><span class="pre">this</span></code> is shifted to the center of mass, i.e.,
the sufficient condition requires calling CouldBePhysicallyValid()
when the about-point is Bcm (the body’s center of mass). Note:
this class does not know its about-point or its center of mass
location.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><code class="docutils literal notranslate"><span class="pre">True</span></code> for a plausible rotational inertia passing the above
necessary but insufficient checks and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if principal moments of inertia cannot be calculated</li>
<li>(eigenvalue solver) or if scalar type T cannot be converted to a</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">double.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float].get_moments">
<code class="descname">get_moments</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float].get_moments" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns 3-element vector with moments of inertia [Ixx, Iyy, Izz].</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float].get_products">
<code class="descname">get_products</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float].get_products" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns 3-element vector with products of inertia [Ixy, Ixz, Iyz].</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float].IsNaN">
<code class="descname">IsNaN</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float].IsNaN" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if any moment/product in <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia
is NaN. Otherwise returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float].IsNearlyEqualTo">
<code class="descname">IsNearlyEqualTo</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[float], other: pydrake.multibody.tree.RotationalInertia_[float], precision: float</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float].IsNearlyEqualTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Compares <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia to <code class="docutils literal notranslate"><span class="pre">other</span></code> rotional inertia
within the specified <code class="docutils literal notranslate"><span class="pre">precision</span></code> (which is a dimensionless number
specifying the relative precision to which the comparison is
performed). Denoting <code class="docutils literal notranslate"><span class="pre">I_maxA</span></code> as the largest element value that can
appear in a valid <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia (independent of the
expressed-in frame E) and denoting <code class="docutils literal notranslate"><span class="pre">I_maxB</span></code> as the largest element
value that can appear in a valid <code class="docutils literal notranslate"><span class="pre">other</span></code> rotational inertia
(independent of the expressed-in frame E), <code class="docutils literal notranslate"><span class="pre">this</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code> are
considered nearly equal to each other, if: ‖this - other‖∞ &lt; precision
* min(I_maxA, I_maxB)</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other</span></code>:</dt>
<dd>Rotational inertia to compare with <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">precision</span></code>:</dt>
<dd>is a dimensionless real positive number that is usually based on
two factors, namely expected accuracy of moments/products of
inertia (e.g., from end-user or CAD) and/or machine-precision.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">True</span></code> if the absolute value of each moment/product of inertia
in <code class="docutils literal notranslate"><span class="pre">this</span></code> is within <code class="docutils literal notranslate"><span class="pre">epsilon</span></code> of the corresponding moment/
product absolute value in <code class="docutils literal notranslate"><span class="pre">other</span></code>. Otherwise returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">: This method only works if all moments of inertia with scalar
type T in <code class="docutils literal notranslate"><span class="pre">this</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code> can be converted to a double
(discarding supplemental scalar data such as derivatives of an
AutoDiffXd). It fails at runtime if type T cannot be converted to
<code class="docutils literal notranslate"><span class="pre">double</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float].ReExpress">
<code class="descname">ReExpress</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[float], R_AE: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RotationalInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float].ReExpress" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-expresses <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia <code class="docutils literal notranslate"><span class="pre">I_BP_E</span></code> to <code class="docutils literal notranslate"><span class="pre">I_BP_A</span></code>
i.e., re-expresses body B’s rotational inertia from frame E to frame
A.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_AE</span></code>:</dt>
<dd>RotationMatrix relating frames A and E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">I_BP_A</span></code>:</dt>
<dd>Rotational inertia of B about-point P expressed-in frame A.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError for Debug builds if the rotational inertia that is</li>
<li>re-expressed-in frame A violates CouldBePhysicallyValid().</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ReExpressInPlace()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float].rows">
<code class="descname">rows</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float].rows" title="Permalink to this definition">¶</a></dt>
<dd><p>For consistency with Eigen’s API, the rows() method returns 3.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float].SetToNaN">
<code class="descname">SetToNaN</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float].SetToNaN" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia so all its elements are equal to NaN.
This helps quickly detect uninitialized moments/products of inertia.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia so all its moments/products of
inertia are zero, e.g., for convenient initialization before a
computation or for inertia calculations involving a particle
(point-mass). Note: Real 3D massive physical objects have non-zero
moments of inertia.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float].ShiftFromCenterOfMass">
<code class="descname">ShiftFromCenterOfMass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[float], mass: float, p_BcmQ_E: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RotationalInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float].ShiftFromCenterOfMass" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the rotational inertia that results from shifting <code class="docutils literal notranslate"><span class="pre">this</span></code>
rotational inertia for a body (or composite body) B from about-point
Bcm (B’s center of mass) to about-point Q. I.e., shifts <code class="docutils literal notranslate"><span class="pre">I_BBcm_E</span></code>
to <code class="docutils literal notranslate"><span class="pre">I_BQ_E</span></code> (both are expressed-in frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt>
<dd>The mass of body (or composite body) B.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BcmQ_E</span></code>:</dt>
<dd>Position vector from Bcm to Q, expressed-in frame E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">I_BQ_E</span></code>:</dt>
<dd>B’s rotational inertia about-point Q expressed-in frame E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError for Debug builds if the rotational inertia that is</li>
<li>shifted to about-point Q violates CouldBePhysicallyValid().</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Remark:</dt>
<dd>Negating the position vector p_BcmQ_E has no affect on the result.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float].ShiftToCenterOfMass">
<code class="descname">ShiftToCenterOfMass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[float], mass: float, p_QBcm_E: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RotationalInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float].ShiftToCenterOfMass" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the rotational inertia that results from shifting <code class="docutils literal notranslate"><span class="pre">this</span></code>
rotational inertia for a body (or composite body) B from about-point Q
to about-point <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> (B’s center of mass). I.e., shifts <code class="docutils literal notranslate"><span class="pre">I_BQ_E</span></code>
to <code class="docutils literal notranslate"><span class="pre">I_BBcm_E</span></code> (both are expressed-in frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt>
<dd>The mass of body (or composite body) B.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_QBcm_E</span></code>:</dt>
<dd>Position vector from Q to <code class="docutils literal notranslate"><span class="pre">Bcm</span></code>, expressed-in frame E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">I_BBcm_E</span></code>:</dt>
<dd>B’s rotational inertia about-point <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> expressed-in frame E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError for Debug builds if the rotational inertia that is</li>
<li>shifted to about-point <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> violates CouldBePhysicallyValid().</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Remark:</dt>
<dd>Negating the position vector <code class="docutils literal notranslate"><span class="pre">p_QBcm_E</span></code> has no affect on the
result.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float].ShiftToThenAwayFromCenterOfMass">
<code class="descname">ShiftToThenAwayFromCenterOfMass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[float], mass: float, p_PBcm_E: numpy.ndarray[numpy.float64[3, 1]], p_QBcm_E: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RotationalInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float].ShiftToThenAwayFromCenterOfMass" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the rotational inertia that results from shifting <code class="docutils literal notranslate"><span class="pre">this</span></code>
rotational inertia for a body (or composite body) B from about-point P
to about-point Q via Bcm (B’s center of mass). I.e., shifts <code class="docutils literal notranslate"><span class="pre">I_BP_E</span></code>
to <code class="docutils literal notranslate"><span class="pre">I_BQ_E</span></code> (both are expressed-in frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt>
<dd>The mass of body (or composite body) B.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PBcm_E</span></code>:</dt>
<dd>Position vector from P to Bcm, expressed-in frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_QBcm_E</span></code>:</dt>
<dd>Position vector from Q to Bcm, expressed-in frame E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">I_BQ_E</span></code>:</dt>
<dd>, B’s rotational inertia about-point Q expressed-in frame E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError for Debug builds if the rotational inertia that is</li>
<li>shifted to about-point Q violates CouldBePhysicallyValid().</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Remark:</dt>
<dd>Negating either (or both) position vectors p_PBcm_E and p_QBcm_E
has no affect on the result.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float].Trace">
<code class="descname">Trace</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float].Trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a rotational inertia’s trace (i.e., Ixx + Iyy + Izz, the sum
of the diagonal elements of the inertia matrix). The trace happens to
be invariant to its expressed-in frame (i.e., the trace does not
depend on the frame in which it is expressed). The trace is useful
because the largest moment of inertia Imax has range: trace / 3 &lt;=
Imax &lt;= trace / 2, and the largest possible product of inertia must be
&lt;= Imax / 2. Hence, trace / 3 and trace / 2 give a lower and upper
bound on the largest possible element that can be in a valid
rotational inertia.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float].TriaxiallySymmetric">
<em class="property">static </em><code class="descname">TriaxiallySymmetric</code><span class="sig-paren">(</span><em>I_triaxial: float</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RotationalInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_.RotationalInertia_[float].TriaxiallySymmetric" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">RotationalInertia_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class describes the mass distribution (inertia properties) of a
body or composite body about a particular point. Herein, “composite
body” means one body or a collection of bodies that are welded
together. In this documentation, “body” and “composite body” are used
interchangeably.</p>
<p>A <strong>rigid</strong> body’s mass distribution is described by three quantities:
the body’s mass; the body’s center of mass; and the body’s rotational
inertia about a particular point. The term <strong>rotational inertia</strong> is
used here and by [Jain 2010] to distinguish from a body’s <strong>spatial
inertia</strong>. In this class, a 3x3 <strong>inertia matrix</strong> I represents a
body’s rotational inertia about a point and expressed in a frame. More
specifically, <code class="docutils literal notranslate"><span class="pre">I_BP_E</span></code> is the inertia matrix of a body B about-point
P and expressed-in frame E (herein frame E’s orthogonal unit vectors
Ex, Ey, Ez are denoted 𝐱̂, 𝐲̂, 𝐳̂).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span> <span class="n">Ixx</span> <span class="n">Ixy</span> <span class="n">Ixz</span> <span class="o">|</span>
<span class="n">I</span> <span class="o">=</span> <span class="o">|</span> <span class="n">Ixy</span> <span class="n">Iyy</span> <span class="n">Iyz</span> <span class="o">|</span>
    <span class="o">|</span> <span class="n">Ixz</span> <span class="n">Iyz</span> <span class="n">Izz</span> <span class="o">|</span>
</pre></div>
</div>
<p>The moments of inertia Ixx, Iyy, Izz and products of inertia Ixy, Ixz,
Iyz are defined in terms of the mass dm of a differential volume of
the body. The position of dm from about-point P is xx̂ + yŷ + zẑ =
[x, y, z]_E.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Ixx = ∫ (y² + z²) dm
Iyy = ∫ (x² + z²) dm
Izz = ∫ (x² + y²) dm
Ixy = - ∫ x y dm
Ixz = - ∫ x z dm
Iyz = - ∫ y z dm
</pre></div>
</div>
<p>We use the negated convention for products of inertia, so that I
serves to relate angular velocity ω and angular momentum h via <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">=</span> <span class="pre">I</span>
<span class="pre">⋅</span> <span class="pre">ω</span></code>. Ensure your products of inertia follow this negative sign
convention.</p>
<p>The 3x3 inertia matrix is symmetric and its diagonal elements (moments
of inertia) and off-diagonal elements (products of inertia) are
associated with a body (or composite body) S, an about-point P, and an
expressed-in frame E (𝐱̂, 𝐲̂, 𝐳̂̂). A rotational inertia is
ill-defined unless there is a body S, about-point P, and expressed-in
frame E. The user of this class is responsible for tracking the body
S, about-point P and expressed-in frame E (none of these are stored in
this class).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class does not store the about-point nor the expressed-in
frame, nor does this class help enforce consistency of the
about-point or expressed-in frame. To help users of this class
track the about-point and expressed-in frame, we strongly
recommend the following notation.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In typeset material, use the symbol <span class="math notranslate nohighlight">\([I^{S/P}]_E\)</span> to
represent the rotational inertia (inertia matrix) of a body (or
composite body) S about-point P, expressed in frame E. In code and
comments, use the monogram notation <code class="docutils literal notranslate"><span class="pre">I_SP_E</span></code> (e.g., as described
in multibody_spatial_inertia). If the about-point P is fixed to a
body B, the point is named <span class="math notranslate nohighlight">\(B_P\)</span> and this appears in
code/comments as <code class="docutils literal notranslate"><span class="pre">Bp</span></code>. Examples: <code class="docutils literal notranslate"><span class="pre">I_BBp_E</span></code> is rigid body B’s
rotational inertia about-point Bp expressed-in frame E; I_BBo_E is
B’s rotational inertia about-point <code class="docutils literal notranslate"><span class="pre">Bo</span></code> (body B’s origin)
expressed-in frame E; and I_BBcm_E is B’s inertia matrix
about-point <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> (B’s center of mass) expressed-in frame E.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The rotational inertia (inertia matrix) can be re-expressed in
terms of a special frame whose orthogonal unit vectors are
parallel to <strong>principal axes of inertia</strong> so that the inertia
matrix is diagonalized with elements called <strong>principal moments of
inertia</strong>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The formal definition of the inertia matrix <span class="math notranslate nohighlight">\(I^{S/P}\)</span> of a
system S about a point P follows the definition of the inertia
dyadic 𝐈 of S about P, which begins by modeling S with n particles
S₁ … Sₙ (e.g., 12 grams of carbon can be modeled with n = 6.02 *
10²³ molecules/particles). The inertia dyadic 𝐈₁ of one particle
S₁ about point P is defined [Kane, 1985] in terms of m₁ (mass of
S₁), ᴾ𝐩ˢ¹ (position vector from P to S₁), and the unit dyadic 𝐔
which is defined by the property 𝐔 ⋅ 𝐯 = 𝐯 where 𝐯 is is any
vector (this definition of 𝐔 is analogous to defining the identity
matrix by the property 𝑰𝒅𝒆𝒏𝒕𝒊𝒕𝒚𝑴𝒂𝒕𝒓𝒊𝒙 * 𝒂𝒏𝒚𝑴𝒂𝒕𝒓𝒊𝒙 = 𝒂𝒏𝒚𝑴𝒂𝒕𝒓𝒊𝒙).</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>𝐈₁ = m₁ * [𝐔 * (ᴾ𝐩ˢ¹ ⋅ ᴾ𝐩ˢ¹)  -  ᴾ𝐩ˢ¹ * ᴾ𝐩ˢ¹]
</pre></div>
</div>
<p>Note: The vector dot-product (⋅) above produces a scalar whereas the
vector multiply (*) produces a dyadic which is a 2nd-order tensor
(ᴾ𝐩ˢ¹ * ᴾ𝐩ˢ¹ is similar to the matrix outer-product of a 3x1 matrix
multiplied by a 1x3 matrix). An example inertia dyadic for a single
particle is shown further below. The inertia dyadic 𝐈 of the entire
system S is defined by summing the inertia dyadic of each particle Sᵢ
about P (i = 1, … n), i.e.,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>𝐈 = 𝐈₁ + 𝐈₂ + ... 𝐈ₙ
</pre></div>
</div>
<p>The elements of the inertia matrix <span class="math notranslate nohighlight">\([I^{S/P}]_E\)</span> expressed in
frame E (in terms of orthogonal unit vectors 𝐱̂, 𝐲̂, 𝐳̂̂) are found by
pre-dot multiplying and post-dot multiplying 𝐈 with appropriate unit
vectors.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Ixx = 𝐱̂ ⋅ 𝐈 ⋅ 𝐱̂     Ixy = 𝐱̂ ⋅ 𝐈 ⋅ 𝐲̂      Ixz = 𝐱̂ ⋅ 𝐈 ⋅ 𝐳̂̂
   Iyx = 𝐲̂ ⋅ 𝐈 ⋅ 𝐱̂     Iyy = 𝐲̂ ⋅ 𝐈 ⋅ 𝐲̂      Iyz = 𝐲̂ ⋅ 𝐈 ⋅ 𝐳̂̂
   Izx = 𝐳̂̂ ⋅ 𝐈 ⋅ 𝐱̂     Izy = 𝐳̂̂ ⋅ 𝐈 ⋅ 𝐲̂      Izz = 𝐳̂̂ ⋅ 𝐈 ⋅ 𝐳̂̂
</pre></div>
</div>
<p>The inertia dyadic 𝐈ᴮ of a rigid body B about Bcm (B’s center of mass)
is related to various dynamic quantities. For example, B’s angular
momentum 𝐇 about Bcm in a frame N and B’s kinetic energy KE in N
relate to 𝐈ᴮ by</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>𝐇 = 𝐈ᴮ ⋅ 𝛚
   KE = 1/2 𝛚 ⋅ 𝐈ᴮ ⋅ 𝛚  +  1/2 mᴮ 𝐯 ⋅ 𝐯
</pre></div>
</div>
<p>where 𝛚 is B’s angular velocity in N, 𝐯 is Bcm’s translational
velocity in N, and mᴮ is B’s mass. When frame N happens to be a
Newtonian frame (also called an inertial frame or
non-rotating/non-accelerating frame), the moment 𝐓 of all forces on B
about Bcm relates to 𝐈ᴮ and 𝛂 (B’s angular acceleration in N) by
Euler’s rigid body equation as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>𝐓 = 𝐈ᴮ ⋅ 𝛂  +  𝛚 × 𝐈ᴮ ⋅ 𝛚
</pre></div>
</div>
<p>Example: For a particle Q of mass m whose position vector from a point
O is written in terms of right-handed orthogonal unit vectors 𝐱̂, 𝐲̂,
𝐳̂ (below), the inertia dyadic 𝐈 of particle Q about point O is
defined and calculated</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>𝐩 = x 𝐱̂  +  y 𝐲̂                               (given)
    𝐈 = m * [𝐔 * (𝐩 ⋅ 𝐩)  -  𝐩 * 𝐩]              (definition)
      = m * [𝐔 * (x² + y²)  -  (x𝐱̂ + y𝐲̂̂) * (x𝐱̂ + y𝐲̂)
      = m * [(𝐱̂𝐱̂ + 𝐲̂𝐲̂ + 𝐳̂𝐳̂) * (x² + y²) - (x²𝐱̂𝐱̂ + xy𝐱̂𝐲̂̂ + xy𝐲̂̂𝐱̂ + y²𝐲̂̂𝐲̂̂)]
      = m * [y²𝐱̂𝐱̂ + x²𝐲̂𝐲̂ + (x² + y²)𝐳̂𝐳̂ - xy𝐱̂𝐲̂̂ - xy𝐲̂̂𝐱̂]
</pre></div>
</div>
<p>which means the inertia matrix for particle Q about point O for 𝐱̂,
𝐲̂, 𝐳̂ is</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>|  m y²     -m x y         0     |
I = | -m x y     m x²          0     |
    |    0         0     m (x² + y²) |
</pre></div>
</div>
<p>[Kane, 1985] pg. 68. “Dynamics: Theory and Applications,” McGraw-Hill
Co., New York, 1985 (with D. A. Levinson). Available for free .pdf
download: <a class="reference external" href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Several methods in this class throw a RuntimeError for invalid
rotational inertia operations in debug releases only. This
provides speed in a release build while facilitating debugging in
debug builds. In addition, these validity tests are only performed
for scalar types for which drake::scalar_predicate&lt;T&gt;::is_bool is
<code class="docutils literal notranslate"><span class="pre">True</span></code>. For instance, validity checks are not performed when T
is symbolic::Expression.</p>
</div>
<p>Various methods in this class require numerical (not symbolic) data
types.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]) -&gt; None</li>
</ol>
<p>Constructs a rotational inertia that has all its moments/products of
inertia equal to NaN (helps quickly detect uninitialized values).</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.RotationalInertia_[AutoDiffXd], Ixx: pydrake.autodiffutils.AutoDiffXd, Iyy: pydrake.autodiffutils.AutoDiffXd, Izz: pydrake.autodiffutils.AutoDiffXd) -&gt; None</li>
</ol>
<p>Creates a rotational inertia with moments of inertia <code class="docutils literal notranslate"><span class="pre">Ixx</span></code>, <cite>Iyy</cite>,
<code class="docutils literal notranslate"><span class="pre">Izz</span></code>, and with each product of inertia set to zero.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError for Debug builds if not CouldBePhysicallyValid().</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.tree.RotationalInertia_[AutoDiffXd], Ixx: pydrake.autodiffutils.AutoDiffXd, Iyy: pydrake.autodiffutils.AutoDiffXd, Izz: pydrake.autodiffutils.AutoDiffXd, Ixy: pydrake.autodiffutils.AutoDiffXd, Ixz: pydrake.autodiffutils.AutoDiffXd, Iyz: pydrake.autodiffutils.AutoDiffXd) -&gt; None</li>
</ol>
<p>Creates a rotational inertia with moments of inertia <code class="docutils literal notranslate"><span class="pre">Ixx</span></code>, <cite>Iyy</cite>,
<code class="docutils literal notranslate"><span class="pre">Izz</span></code>, and with products of inertia <code class="docutils literal notranslate"><span class="pre">Ixy</span></code>, <cite>Ixz</cite>, <code class="docutils literal notranslate"><span class="pre">Iyz</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError for Debug builds if not CouldBePhysicallyValid().</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="4">
<li>__init__(self: pydrake.multibody.tree.RotationalInertia_[AutoDiffXd], mass: pydrake.autodiffutils.AutoDiffXd, p_PQ_E: numpy.ndarray[object[3, 1]]) -&gt; None</li>
</ol>
<p>Constructs a rotational inertia for a particle Q of mass <code class="docutils literal notranslate"><span class="pre">mass</span></code>,
whose position vector from about-point P is p_PQ_E (E is expressed-in
frame). This RuntimeError exception only occurs if <code class="docutils literal notranslate"><span class="pre">mass</span></code> &lt; 0.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt>
<dd>The mass of particle Q.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PQ_E</span></code>:</dt>
<dd>Position from about-point P to Q, expressed-in frame E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">I_QP_E</span></code>:</dt>
<dd>, Q’s rotational inertia about-point P expressed-in frame E.</dd>
<dt>Remark:</dt>
<dd>Negating the position vector p_PQ_E has no affect on the result.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError for Debug builds if not CouldBePhysicallyValid().</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[AutoDiffXd].CalcMaximumPossibleMomentOfInertia">
<code class="descname">CalcMaximumPossibleMomentOfInertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.autodiffutils.AutoDiffXd<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[AutoDiffXd].CalcMaximumPossibleMomentOfInertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the maximum possible moment of inertia for <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational
inertia about-point P for any expressed-in frame E.</p>
<dl class="docutils">
<dt>Remark:</dt>
<dd>The maximum moment Imax has range: trace / 3 &lt;= Imax &lt;= trace / 2.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Trace()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[AutoDiffXd].CalcPrincipalMomentsOfInertia">
<code class="descname">CalcPrincipalMomentsOfInertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[AutoDiffXd].CalcPrincipalMomentsOfInertia" title="Permalink to this definition">¶</a></dt>
<dd><p>This method takes <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia about-point P,
expressed-in frame E, and computes its principal moments of inertia
about-point P, but expressed-in a frame aligned with the principal
axes.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">: This method only works for a rotational inertia with scalar type
T that can be converted to a double (discarding any supplemental
scalar data such as derivatives of an AutoDiffXd).</p>
</div>
<dl class="docutils">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">principal_moments</span></code>:</dt>
<dd>The vector of principal moments of inertia <code class="docutils literal notranslate"><span class="pre">[Ixx</span> <span class="pre">Iyy</span> <span class="pre">Izz]</span></code>
sorted in ascending order.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if eigenvalue solver fails or if scalar type T cannot</li>
<li>be converted to a double.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[AutoDiffXd].cols">
<code class="descname">cols</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[AutoDiffXd].cols" title="Permalink to this definition">¶</a></dt>
<dd><p>For consistency with Eigen’s API, the cols() method returns 3.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[AutoDiffXd].CopyToFullMatrix3">
<code class="descname">CopyToFullMatrix3</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 3]]<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[AutoDiffXd].CopyToFullMatrix3" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a full 3x3 matrix copy of this rotational inertia. The returned
copy is symmetric and includes both lower and upper parts of the
matrix.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[AutoDiffXd].CouldBePhysicallyValid">
<code class="descname">CouldBePhysicallyValid</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[AutoDiffXd].CouldBePhysicallyValid" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs several necessary checks to verify whether <code class="docutils literal notranslate"><span class="pre">this</span></code>
rotational inertia <em>could</em> be physically valid, including:</p>
<ul class="simple">
<li>No NaN moments or products of inertia.</li>
<li>Ixx, Iyy, Izz and principal moments are all non-negative.</li>
<li>Ixx, Iyy  Izz and principal moments satisfy the triangle inequality:
- <code class="docutils literal notranslate"><span class="pre">Ixx</span> <span class="pre">+</span> <span class="pre">Iyy</span> <span class="pre">&gt;=</span> <span class="pre">Izz</span></code>
- <cite>Ixx + Izz &gt;= Iyy</cite>
- <code class="docutils literal notranslate"><span class="pre">Iyy</span> <span class="pre">+</span> <span class="pre">Izz</span> <span class="pre">&gt;=</span> <span class="pre">Ixx</span></code></li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">These checks are necessary (but NOT sufficient) conditions for a
rotational inertia to be physically valid. The sufficient
condition requires a rotational inertia to satisfy the above
checks <em>after</em> <code class="docutils literal notranslate"><span class="pre">this</span></code> is shifted to the center of mass, i.e.,
the sufficient condition requires calling CouldBePhysicallyValid()
when the about-point is Bcm (the body’s center of mass). Note:
this class does not know its about-point or its center of mass
location.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><code class="docutils literal notranslate"><span class="pre">True</span></code> for a plausible rotational inertia passing the above
necessary but insufficient checks and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if principal moments of inertia cannot be calculated</li>
<li>(eigenvalue solver) or if scalar type T cannot be converted to a</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">double.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[AutoDiffXd].get_moments">
<code class="descname">get_moments</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[AutoDiffXd].get_moments" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns 3-element vector with moments of inertia [Ixx, Iyy, Izz].</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[AutoDiffXd].get_products">
<code class="descname">get_products</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[AutoDiffXd].get_products" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns 3-element vector with products of inertia [Ixy, Ixz, Iyz].</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[AutoDiffXd].IsNaN">
<code class="descname">IsNaN</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[AutoDiffXd].IsNaN" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if any moment/product in <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia
is NaN. Otherwise returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[AutoDiffXd].IsNearlyEqualTo">
<code class="descname">IsNearlyEqualTo</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[AutoDiffXd], other: pydrake.multibody.tree.RotationalInertia_[AutoDiffXd], precision: float</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[AutoDiffXd].IsNearlyEqualTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Compares <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia to <code class="docutils literal notranslate"><span class="pre">other</span></code> rotional inertia
within the specified <code class="docutils literal notranslate"><span class="pre">precision</span></code> (which is a dimensionless number
specifying the relative precision to which the comparison is
performed). Denoting <code class="docutils literal notranslate"><span class="pre">I_maxA</span></code> as the largest element value that can
appear in a valid <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia (independent of the
expressed-in frame E) and denoting <code class="docutils literal notranslate"><span class="pre">I_maxB</span></code> as the largest element
value that can appear in a valid <code class="docutils literal notranslate"><span class="pre">other</span></code> rotational inertia
(independent of the expressed-in frame E), <code class="docutils literal notranslate"><span class="pre">this</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code> are
considered nearly equal to each other, if: ‖this - other‖∞ &lt; precision
* min(I_maxA, I_maxB)</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other</span></code>:</dt>
<dd>Rotational inertia to compare with <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">precision</span></code>:</dt>
<dd>is a dimensionless real positive number that is usually based on
two factors, namely expected accuracy of moments/products of
inertia (e.g., from end-user or CAD) and/or machine-precision.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">True</span></code> if the absolute value of each moment/product of inertia
in <code class="docutils literal notranslate"><span class="pre">this</span></code> is within <code class="docutils literal notranslate"><span class="pre">epsilon</span></code> of the corresponding moment/
product absolute value in <code class="docutils literal notranslate"><span class="pre">other</span></code>. Otherwise returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">: This method only works if all moments of inertia with scalar
type T in <code class="docutils literal notranslate"><span class="pre">this</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code> can be converted to a double
(discarding supplemental scalar data such as derivatives of an
AutoDiffXd). It fails at runtime if type T cannot be converted to
<code class="docutils literal notranslate"><span class="pre">double</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[AutoDiffXd].ReExpress">
<code class="descname">ReExpress</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[AutoDiffXd], R_AE: pydrake.math.RotationMatrix_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[AutoDiffXd].ReExpress" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-expresses <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia <code class="docutils literal notranslate"><span class="pre">I_BP_E</span></code> to <code class="docutils literal notranslate"><span class="pre">I_BP_A</span></code>
i.e., re-expresses body B’s rotational inertia from frame E to frame
A.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_AE</span></code>:</dt>
<dd>RotationMatrix relating frames A and E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">I_BP_A</span></code>:</dt>
<dd>Rotational inertia of B about-point P expressed-in frame A.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError for Debug builds if the rotational inertia that is</li>
<li>re-expressed-in frame A violates CouldBePhysicallyValid().</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ReExpressInPlace()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[AutoDiffXd].rows">
<code class="descname">rows</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[AutoDiffXd].rows" title="Permalink to this definition">¶</a></dt>
<dd><p>For consistency with Eigen’s API, the rows() method returns 3.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[AutoDiffXd].SetToNaN">
<code class="descname">SetToNaN</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[AutoDiffXd].SetToNaN" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia so all its elements are equal to NaN.
This helps quickly detect uninitialized moments/products of inertia.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[AutoDiffXd].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[AutoDiffXd].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia so all its moments/products of
inertia are zero, e.g., for convenient initialization before a
computation or for inertia calculations involving a particle
(point-mass). Note: Real 3D massive physical objects have non-zero
moments of inertia.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[AutoDiffXd].ShiftFromCenterOfMass">
<code class="descname">ShiftFromCenterOfMass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[AutoDiffXd], mass: pydrake.autodiffutils.AutoDiffXd, p_BcmQ_E: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[AutoDiffXd].ShiftFromCenterOfMass" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the rotational inertia that results from shifting <code class="docutils literal notranslate"><span class="pre">this</span></code>
rotational inertia for a body (or composite body) B from about-point
Bcm (B’s center of mass) to about-point Q. I.e., shifts <code class="docutils literal notranslate"><span class="pre">I_BBcm_E</span></code>
to <code class="docutils literal notranslate"><span class="pre">I_BQ_E</span></code> (both are expressed-in frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt>
<dd>The mass of body (or composite body) B.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BcmQ_E</span></code>:</dt>
<dd>Position vector from Bcm to Q, expressed-in frame E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">I_BQ_E</span></code>:</dt>
<dd>B’s rotational inertia about-point Q expressed-in frame E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError for Debug builds if the rotational inertia that is</li>
<li>shifted to about-point Q violates CouldBePhysicallyValid().</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Remark:</dt>
<dd>Negating the position vector p_BcmQ_E has no affect on the result.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[AutoDiffXd].ShiftToCenterOfMass">
<code class="descname">ShiftToCenterOfMass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[AutoDiffXd], mass: pydrake.autodiffutils.AutoDiffXd, p_QBcm_E: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[AutoDiffXd].ShiftToCenterOfMass" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the rotational inertia that results from shifting <code class="docutils literal notranslate"><span class="pre">this</span></code>
rotational inertia for a body (or composite body) B from about-point Q
to about-point <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> (B’s center of mass). I.e., shifts <code class="docutils literal notranslate"><span class="pre">I_BQ_E</span></code>
to <code class="docutils literal notranslate"><span class="pre">I_BBcm_E</span></code> (both are expressed-in frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt>
<dd>The mass of body (or composite body) B.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_QBcm_E</span></code>:</dt>
<dd>Position vector from Q to <code class="docutils literal notranslate"><span class="pre">Bcm</span></code>, expressed-in frame E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">I_BBcm_E</span></code>:</dt>
<dd>B’s rotational inertia about-point <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> expressed-in frame E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError for Debug builds if the rotational inertia that is</li>
<li>shifted to about-point <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> violates CouldBePhysicallyValid().</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Remark:</dt>
<dd>Negating the position vector <code class="docutils literal notranslate"><span class="pre">p_QBcm_E</span></code> has no affect on the
result.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[AutoDiffXd].ShiftToThenAwayFromCenterOfMass">
<code class="descname">ShiftToThenAwayFromCenterOfMass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[AutoDiffXd], mass: pydrake.autodiffutils.AutoDiffXd, p_PBcm_E: numpy.ndarray[object[3, 1]], p_QBcm_E: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[AutoDiffXd].ShiftToThenAwayFromCenterOfMass" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the rotational inertia that results from shifting <code class="docutils literal notranslate"><span class="pre">this</span></code>
rotational inertia for a body (or composite body) B from about-point P
to about-point Q via Bcm (B’s center of mass). I.e., shifts <code class="docutils literal notranslate"><span class="pre">I_BP_E</span></code>
to <code class="docutils literal notranslate"><span class="pre">I_BQ_E</span></code> (both are expressed-in frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt>
<dd>The mass of body (or composite body) B.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PBcm_E</span></code>:</dt>
<dd>Position vector from P to Bcm, expressed-in frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_QBcm_E</span></code>:</dt>
<dd>Position vector from Q to Bcm, expressed-in frame E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">I_BQ_E</span></code>:</dt>
<dd>, B’s rotational inertia about-point Q expressed-in frame E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError for Debug builds if the rotational inertia that is</li>
<li>shifted to about-point Q violates CouldBePhysicallyValid().</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Remark:</dt>
<dd>Negating either (or both) position vectors p_PBcm_E and p_QBcm_E
has no affect on the result.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[AutoDiffXd].Trace">
<code class="descname">Trace</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.autodiffutils.AutoDiffXd<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[AutoDiffXd].Trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a rotational inertia’s trace (i.e., Ixx + Iyy + Izz, the sum
of the diagonal elements of the inertia matrix). The trace happens to
be invariant to its expressed-in frame (i.e., the trace does not
depend on the frame in which it is expressed). The trace is useful
because the largest moment of inertia Imax has range: trace / 3 &lt;=
Imax &lt;= trace / 2, and the largest possible product of inertia must be
&lt;= Imax / 2. Hence, trace / 3 and trace / 2 give a lower and upper
bound on the largest possible element that can be in a valid
rotational inertia.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.RotationalInertia_[AutoDiffXd].TriaxiallySymmetric">
<em class="property">static </em><code class="descname">TriaxiallySymmetric</code><span class="sig-paren">(</span><em>I_triaxial: pydrake.autodiffutils.AutoDiffXd</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[AutoDiffXd].TriaxiallySymmetric" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.RotationalInertia_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">RotationalInertia_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class describes the mass distribution (inertia properties) of a
body or composite body about a particular point. Herein, “composite
body” means one body or a collection of bodies that are welded
together. In this documentation, “body” and “composite body” are used
interchangeably.</p>
<p>A <strong>rigid</strong> body’s mass distribution is described by three quantities:
the body’s mass; the body’s center of mass; and the body’s rotational
inertia about a particular point. The term <strong>rotational inertia</strong> is
used here and by [Jain 2010] to distinguish from a body’s <strong>spatial
inertia</strong>. In this class, a 3x3 <strong>inertia matrix</strong> I represents a
body’s rotational inertia about a point and expressed in a frame. More
specifically, <code class="docutils literal notranslate"><span class="pre">I_BP_E</span></code> is the inertia matrix of a body B about-point
P and expressed-in frame E (herein frame E’s orthogonal unit vectors
Ex, Ey, Ez are denoted 𝐱̂, 𝐲̂, 𝐳̂).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span> <span class="n">Ixx</span> <span class="n">Ixy</span> <span class="n">Ixz</span> <span class="o">|</span>
<span class="n">I</span> <span class="o">=</span> <span class="o">|</span> <span class="n">Ixy</span> <span class="n">Iyy</span> <span class="n">Iyz</span> <span class="o">|</span>
    <span class="o">|</span> <span class="n">Ixz</span> <span class="n">Iyz</span> <span class="n">Izz</span> <span class="o">|</span>
</pre></div>
</div>
<p>The moments of inertia Ixx, Iyy, Izz and products of inertia Ixy, Ixz,
Iyz are defined in terms of the mass dm of a differential volume of
the body. The position of dm from about-point P is xx̂ + yŷ + zẑ =
[x, y, z]_E.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Ixx = ∫ (y² + z²) dm
Iyy = ∫ (x² + z²) dm
Izz = ∫ (x² + y²) dm
Ixy = - ∫ x y dm
Ixz = - ∫ x z dm
Iyz = - ∫ y z dm
</pre></div>
</div>
<p>We use the negated convention for products of inertia, so that I
serves to relate angular velocity ω and angular momentum h via <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">=</span> <span class="pre">I</span>
<span class="pre">⋅</span> <span class="pre">ω</span></code>. Ensure your products of inertia follow this negative sign
convention.</p>
<p>The 3x3 inertia matrix is symmetric and its diagonal elements (moments
of inertia) and off-diagonal elements (products of inertia) are
associated with a body (or composite body) S, an about-point P, and an
expressed-in frame E (𝐱̂, 𝐲̂, 𝐳̂̂). A rotational inertia is
ill-defined unless there is a body S, about-point P, and expressed-in
frame E. The user of this class is responsible for tracking the body
S, about-point P and expressed-in frame E (none of these are stored in
this class).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class does not store the about-point nor the expressed-in
frame, nor does this class help enforce consistency of the
about-point or expressed-in frame. To help users of this class
track the about-point and expressed-in frame, we strongly
recommend the following notation.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In typeset material, use the symbol <span class="math notranslate nohighlight">\([I^{S/P}]_E\)</span> to
represent the rotational inertia (inertia matrix) of a body (or
composite body) S about-point P, expressed in frame E. In code and
comments, use the monogram notation <code class="docutils literal notranslate"><span class="pre">I_SP_E</span></code> (e.g., as described
in multibody_spatial_inertia). If the about-point P is fixed to a
body B, the point is named <span class="math notranslate nohighlight">\(B_P\)</span> and this appears in
code/comments as <code class="docutils literal notranslate"><span class="pre">Bp</span></code>. Examples: <code class="docutils literal notranslate"><span class="pre">I_BBp_E</span></code> is rigid body B’s
rotational inertia about-point Bp expressed-in frame E; I_BBo_E is
B’s rotational inertia about-point <code class="docutils literal notranslate"><span class="pre">Bo</span></code> (body B’s origin)
expressed-in frame E; and I_BBcm_E is B’s inertia matrix
about-point <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> (B’s center of mass) expressed-in frame E.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The rotational inertia (inertia matrix) can be re-expressed in
terms of a special frame whose orthogonal unit vectors are
parallel to <strong>principal axes of inertia</strong> so that the inertia
matrix is diagonalized with elements called <strong>principal moments of
inertia</strong>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The formal definition of the inertia matrix <span class="math notranslate nohighlight">\(I^{S/P}\)</span> of a
system S about a point P follows the definition of the inertia
dyadic 𝐈 of S about P, which begins by modeling S with n particles
S₁ … Sₙ (e.g., 12 grams of carbon can be modeled with n = 6.02 *
10²³ molecules/particles). The inertia dyadic 𝐈₁ of one particle
S₁ about point P is defined [Kane, 1985] in terms of m₁ (mass of
S₁), ᴾ𝐩ˢ¹ (position vector from P to S₁), and the unit dyadic 𝐔
which is defined by the property 𝐔 ⋅ 𝐯 = 𝐯 where 𝐯 is is any
vector (this definition of 𝐔 is analogous to defining the identity
matrix by the property 𝑰𝒅𝒆𝒏𝒕𝒊𝒕𝒚𝑴𝒂𝒕𝒓𝒊𝒙 * 𝒂𝒏𝒚𝑴𝒂𝒕𝒓𝒊𝒙 = 𝒂𝒏𝒚𝑴𝒂𝒕𝒓𝒊𝒙).</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>𝐈₁ = m₁ * [𝐔 * (ᴾ𝐩ˢ¹ ⋅ ᴾ𝐩ˢ¹)  -  ᴾ𝐩ˢ¹ * ᴾ𝐩ˢ¹]
</pre></div>
</div>
<p>Note: The vector dot-product (⋅) above produces a scalar whereas the
vector multiply (*) produces a dyadic which is a 2nd-order tensor
(ᴾ𝐩ˢ¹ * ᴾ𝐩ˢ¹ is similar to the matrix outer-product of a 3x1 matrix
multiplied by a 1x3 matrix). An example inertia dyadic for a single
particle is shown further below. The inertia dyadic 𝐈 of the entire
system S is defined by summing the inertia dyadic of each particle Sᵢ
about P (i = 1, … n), i.e.,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>𝐈 = 𝐈₁ + 𝐈₂ + ... 𝐈ₙ
</pre></div>
</div>
<p>The elements of the inertia matrix <span class="math notranslate nohighlight">\([I^{S/P}]_E\)</span> expressed in
frame E (in terms of orthogonal unit vectors 𝐱̂, 𝐲̂, 𝐳̂̂) are found by
pre-dot multiplying and post-dot multiplying 𝐈 with appropriate unit
vectors.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Ixx = 𝐱̂ ⋅ 𝐈 ⋅ 𝐱̂     Ixy = 𝐱̂ ⋅ 𝐈 ⋅ 𝐲̂      Ixz = 𝐱̂ ⋅ 𝐈 ⋅ 𝐳̂̂
   Iyx = 𝐲̂ ⋅ 𝐈 ⋅ 𝐱̂     Iyy = 𝐲̂ ⋅ 𝐈 ⋅ 𝐲̂      Iyz = 𝐲̂ ⋅ 𝐈 ⋅ 𝐳̂̂
   Izx = 𝐳̂̂ ⋅ 𝐈 ⋅ 𝐱̂     Izy = 𝐳̂̂ ⋅ 𝐈 ⋅ 𝐲̂      Izz = 𝐳̂̂ ⋅ 𝐈 ⋅ 𝐳̂̂
</pre></div>
</div>
<p>The inertia dyadic 𝐈ᴮ of a rigid body B about Bcm (B’s center of mass)
is related to various dynamic quantities. For example, B’s angular
momentum 𝐇 about Bcm in a frame N and B’s kinetic energy KE in N
relate to 𝐈ᴮ by</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>𝐇 = 𝐈ᴮ ⋅ 𝛚
   KE = 1/2 𝛚 ⋅ 𝐈ᴮ ⋅ 𝛚  +  1/2 mᴮ 𝐯 ⋅ 𝐯
</pre></div>
</div>
<p>where 𝛚 is B’s angular velocity in N, 𝐯 is Bcm’s translational
velocity in N, and mᴮ is B’s mass. When frame N happens to be a
Newtonian frame (also called an inertial frame or
non-rotating/non-accelerating frame), the moment 𝐓 of all forces on B
about Bcm relates to 𝐈ᴮ and 𝛂 (B’s angular acceleration in N) by
Euler’s rigid body equation as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>𝐓 = 𝐈ᴮ ⋅ 𝛂  +  𝛚 × 𝐈ᴮ ⋅ 𝛚
</pre></div>
</div>
<p>Example: For a particle Q of mass m whose position vector from a point
O is written in terms of right-handed orthogonal unit vectors 𝐱̂, 𝐲̂,
𝐳̂ (below), the inertia dyadic 𝐈 of particle Q about point O is
defined and calculated</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>𝐩 = x 𝐱̂  +  y 𝐲̂                               (given)
    𝐈 = m * [𝐔 * (𝐩 ⋅ 𝐩)  -  𝐩 * 𝐩]              (definition)
      = m * [𝐔 * (x² + y²)  -  (x𝐱̂ + y𝐲̂̂) * (x𝐱̂ + y𝐲̂)
      = m * [(𝐱̂𝐱̂ + 𝐲̂𝐲̂ + 𝐳̂𝐳̂) * (x² + y²) - (x²𝐱̂𝐱̂ + xy𝐱̂𝐲̂̂ + xy𝐲̂̂𝐱̂ + y²𝐲̂̂𝐲̂̂)]
      = m * [y²𝐱̂𝐱̂ + x²𝐲̂𝐲̂ + (x² + y²)𝐳̂𝐳̂ - xy𝐱̂𝐲̂̂ - xy𝐲̂̂𝐱̂]
</pre></div>
</div>
<p>which means the inertia matrix for particle Q about point O for 𝐱̂,
𝐲̂, 𝐳̂ is</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>|  m y²     -m x y         0     |
I = | -m x y     m x²          0     |
    |    0         0     m (x² + y²) |
</pre></div>
</div>
<p>[Kane, 1985] pg. 68. “Dynamics: Theory and Applications,” McGraw-Hill
Co., New York, 1985 (with D. A. Levinson). Available for free .pdf
download: <a class="reference external" href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Several methods in this class throw a RuntimeError for invalid
rotational inertia operations in debug releases only. This
provides speed in a release build while facilitating debugging in
debug builds. In addition, these validity tests are only performed
for scalar types for which drake::scalar_predicate&lt;T&gt;::is_bool is
<code class="docutils literal notranslate"><span class="pre">True</span></code>. For instance, validity checks are not performed when T
is symbolic::Expression.</p>
</div>
<p>Various methods in this class require numerical (not symbolic) data
types.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.RotationalInertia_[Expression]) -&gt; None</li>
</ol>
<p>Constructs a rotational inertia that has all its moments/products of
inertia equal to NaN (helps quickly detect uninitialized values).</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.RotationalInertia_[Expression], Ixx: pydrake.symbolic.Expression, Iyy: pydrake.symbolic.Expression, Izz: pydrake.symbolic.Expression) -&gt; None</li>
</ol>
<p>Creates a rotational inertia with moments of inertia <code class="docutils literal notranslate"><span class="pre">Ixx</span></code>, <cite>Iyy</cite>,
<code class="docutils literal notranslate"><span class="pre">Izz</span></code>, and with each product of inertia set to zero.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError for Debug builds if not CouldBePhysicallyValid().</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.tree.RotationalInertia_[Expression], Ixx: pydrake.symbolic.Expression, Iyy: pydrake.symbolic.Expression, Izz: pydrake.symbolic.Expression, Ixy: pydrake.symbolic.Expression, Ixz: pydrake.symbolic.Expression, Iyz: pydrake.symbolic.Expression) -&gt; None</li>
</ol>
<p>Creates a rotational inertia with moments of inertia <code class="docutils literal notranslate"><span class="pre">Ixx</span></code>, <cite>Iyy</cite>,
<code class="docutils literal notranslate"><span class="pre">Izz</span></code>, and with products of inertia <code class="docutils literal notranslate"><span class="pre">Ixy</span></code>, <cite>Ixz</cite>, <code class="docutils literal notranslate"><span class="pre">Iyz</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError for Debug builds if not CouldBePhysicallyValid().</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="4">
<li>__init__(self: pydrake.multibody.tree.RotationalInertia_[Expression], mass: pydrake.symbolic.Expression, p_PQ_E: numpy.ndarray[object[3, 1]]) -&gt; None</li>
</ol>
<p>Constructs a rotational inertia for a particle Q of mass <code class="docutils literal notranslate"><span class="pre">mass</span></code>,
whose position vector from about-point P is p_PQ_E (E is expressed-in
frame). This RuntimeError exception only occurs if <code class="docutils literal notranslate"><span class="pre">mass</span></code> &lt; 0.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt>
<dd>The mass of particle Q.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PQ_E</span></code>:</dt>
<dd>Position from about-point P to Q, expressed-in frame E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">I_QP_E</span></code>:</dt>
<dd>, Q’s rotational inertia about-point P expressed-in frame E.</dd>
<dt>Remark:</dt>
<dd>Negating the position vector p_PQ_E has no affect on the result.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError for Debug builds if not CouldBePhysicallyValid().</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[Expression].CalcMaximumPossibleMomentOfInertia">
<code class="descname">CalcMaximumPossibleMomentOfInertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[Expression].CalcMaximumPossibleMomentOfInertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the maximum possible moment of inertia for <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational
inertia about-point P for any expressed-in frame E.</p>
<dl class="docutils">
<dt>Remark:</dt>
<dd>The maximum moment Imax has range: trace / 3 &lt;= Imax &lt;= trace / 2.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Trace()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[Expression].CalcPrincipalMomentsOfInertia">
<code class="descname">CalcPrincipalMomentsOfInertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[Expression].CalcPrincipalMomentsOfInertia" title="Permalink to this definition">¶</a></dt>
<dd><p>This method takes <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia about-point P,
expressed-in frame E, and computes its principal moments of inertia
about-point P, but expressed-in a frame aligned with the principal
axes.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">: This method only works for a rotational inertia with scalar type
T that can be converted to a double (discarding any supplemental
scalar data such as derivatives of an AutoDiffXd).</p>
</div>
<dl class="docutils">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">principal_moments</span></code>:</dt>
<dd>The vector of principal moments of inertia <code class="docutils literal notranslate"><span class="pre">[Ixx</span> <span class="pre">Iyy</span> <span class="pre">Izz]</span></code>
sorted in ascending order.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if eigenvalue solver fails or if scalar type T cannot</li>
<li>be converted to a double.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[Expression].cols">
<code class="descname">cols</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[Expression]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[Expression].cols" title="Permalink to this definition">¶</a></dt>
<dd><p>For consistency with Eigen’s API, the cols() method returns 3.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[Expression].CopyToFullMatrix3">
<code class="descname">CopyToFullMatrix3</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 3]]<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[Expression].CopyToFullMatrix3" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a full 3x3 matrix copy of this rotational inertia. The returned
copy is symmetric and includes both lower and upper parts of the
matrix.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[Expression].CouldBePhysicallyValid">
<code class="descname">CouldBePhysicallyValid</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Formula<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[Expression].CouldBePhysicallyValid" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs several necessary checks to verify whether <code class="docutils literal notranslate"><span class="pre">this</span></code>
rotational inertia <em>could</em> be physically valid, including:</p>
<ul class="simple">
<li>No NaN moments or products of inertia.</li>
<li>Ixx, Iyy, Izz and principal moments are all non-negative.</li>
<li>Ixx, Iyy  Izz and principal moments satisfy the triangle inequality:
- <code class="docutils literal notranslate"><span class="pre">Ixx</span> <span class="pre">+</span> <span class="pre">Iyy</span> <span class="pre">&gt;=</span> <span class="pre">Izz</span></code>
- <cite>Ixx + Izz &gt;= Iyy</cite>
- <code class="docutils literal notranslate"><span class="pre">Iyy</span> <span class="pre">+</span> <span class="pre">Izz</span> <span class="pre">&gt;=</span> <span class="pre">Ixx</span></code></li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">These checks are necessary (but NOT sufficient) conditions for a
rotational inertia to be physically valid. The sufficient
condition requires a rotational inertia to satisfy the above
checks <em>after</em> <code class="docutils literal notranslate"><span class="pre">this</span></code> is shifted to the center of mass, i.e.,
the sufficient condition requires calling CouldBePhysicallyValid()
when the about-point is Bcm (the body’s center of mass). Note:
this class does not know its about-point or its center of mass
location.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><code class="docutils literal notranslate"><span class="pre">True</span></code> for a plausible rotational inertia passing the above
necessary but insufficient checks and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if principal moments of inertia cannot be calculated</li>
<li>(eigenvalue solver) or if scalar type T cannot be converted to a</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">double.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[Expression].get_moments">
<code class="descname">get_moments</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[Expression].get_moments" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns 3-element vector with moments of inertia [Ixx, Iyy, Izz].</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[Expression].get_products">
<code class="descname">get_products</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[Expression].get_products" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns 3-element vector with products of inertia [Ixy, Ixz, Iyz].</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[Expression].IsNaN">
<code class="descname">IsNaN</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Formula<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[Expression].IsNaN" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if any moment/product in <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia
is NaN. Otherwise returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[Expression].IsNearlyEqualTo">
<code class="descname">IsNearlyEqualTo</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[Expression], other: pydrake.multibody.tree.RotationalInertia_[Expression], precision: float</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Formula<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[Expression].IsNearlyEqualTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Compares <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia to <code class="docutils literal notranslate"><span class="pre">other</span></code> rotional inertia
within the specified <code class="docutils literal notranslate"><span class="pre">precision</span></code> (which is a dimensionless number
specifying the relative precision to which the comparison is
performed). Denoting <code class="docutils literal notranslate"><span class="pre">I_maxA</span></code> as the largest element value that can
appear in a valid <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia (independent of the
expressed-in frame E) and denoting <code class="docutils literal notranslate"><span class="pre">I_maxB</span></code> as the largest element
value that can appear in a valid <code class="docutils literal notranslate"><span class="pre">other</span></code> rotational inertia
(independent of the expressed-in frame E), <code class="docutils literal notranslate"><span class="pre">this</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code> are
considered nearly equal to each other, if: ‖this - other‖∞ &lt; precision
* min(I_maxA, I_maxB)</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other</span></code>:</dt>
<dd>Rotational inertia to compare with <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">precision</span></code>:</dt>
<dd>is a dimensionless real positive number that is usually based on
two factors, namely expected accuracy of moments/products of
inertia (e.g., from end-user or CAD) and/or machine-precision.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">True</span></code> if the absolute value of each moment/product of inertia
in <code class="docutils literal notranslate"><span class="pre">this</span></code> is within <code class="docutils literal notranslate"><span class="pre">epsilon</span></code> of the corresponding moment/
product absolute value in <code class="docutils literal notranslate"><span class="pre">other</span></code>. Otherwise returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">: This method only works if all moments of inertia with scalar
type T in <code class="docutils literal notranslate"><span class="pre">this</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code> can be converted to a double
(discarding supplemental scalar data such as derivatives of an
AutoDiffXd). It fails at runtime if type T cannot be converted to
<code class="docutils literal notranslate"><span class="pre">double</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[Expression].ReExpress">
<code class="descname">ReExpress</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[Expression], R_AE: pydrake.math.RotationMatrix_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RotationalInertia_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[Expression].ReExpress" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-expresses <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia <code class="docutils literal notranslate"><span class="pre">I_BP_E</span></code> to <code class="docutils literal notranslate"><span class="pre">I_BP_A</span></code>
i.e., re-expresses body B’s rotational inertia from frame E to frame
A.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_AE</span></code>:</dt>
<dd>RotationMatrix relating frames A and E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">I_BP_A</span></code>:</dt>
<dd>Rotational inertia of B about-point P expressed-in frame A.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError for Debug builds if the rotational inertia that is</li>
<li>re-expressed-in frame A violates CouldBePhysicallyValid().</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ReExpressInPlace()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[Expression].rows">
<code class="descname">rows</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[Expression]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[Expression].rows" title="Permalink to this definition">¶</a></dt>
<dd><p>For consistency with Eigen’s API, the rows() method returns 3.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[Expression].SetToNaN">
<code class="descname">SetToNaN</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[Expression]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[Expression].SetToNaN" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia so all its elements are equal to NaN.
This helps quickly detect uninitialized moments/products of inertia.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[Expression].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[Expression]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[Expression].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia so all its moments/products of
inertia are zero, e.g., for convenient initialization before a
computation or for inertia calculations involving a particle
(point-mass). Note: Real 3D massive physical objects have non-zero
moments of inertia.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[Expression].ShiftFromCenterOfMass">
<code class="descname">ShiftFromCenterOfMass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[Expression], mass: pydrake.symbolic.Expression, p_BcmQ_E: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RotationalInertia_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[Expression].ShiftFromCenterOfMass" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the rotational inertia that results from shifting <code class="docutils literal notranslate"><span class="pre">this</span></code>
rotational inertia for a body (or composite body) B from about-point
Bcm (B’s center of mass) to about-point Q. I.e., shifts <code class="docutils literal notranslate"><span class="pre">I_BBcm_E</span></code>
to <code class="docutils literal notranslate"><span class="pre">I_BQ_E</span></code> (both are expressed-in frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt>
<dd>The mass of body (or composite body) B.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BcmQ_E</span></code>:</dt>
<dd>Position vector from Bcm to Q, expressed-in frame E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">I_BQ_E</span></code>:</dt>
<dd>B’s rotational inertia about-point Q expressed-in frame E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError for Debug builds if the rotational inertia that is</li>
<li>shifted to about-point Q violates CouldBePhysicallyValid().</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Remark:</dt>
<dd>Negating the position vector p_BcmQ_E has no affect on the result.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[Expression].ShiftToCenterOfMass">
<code class="descname">ShiftToCenterOfMass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[Expression], mass: pydrake.symbolic.Expression, p_QBcm_E: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RotationalInertia_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[Expression].ShiftToCenterOfMass" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the rotational inertia that results from shifting <code class="docutils literal notranslate"><span class="pre">this</span></code>
rotational inertia for a body (or composite body) B from about-point Q
to about-point <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> (B’s center of mass). I.e., shifts <code class="docutils literal notranslate"><span class="pre">I_BQ_E</span></code>
to <code class="docutils literal notranslate"><span class="pre">I_BBcm_E</span></code> (both are expressed-in frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt>
<dd>The mass of body (or composite body) B.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_QBcm_E</span></code>:</dt>
<dd>Position vector from Q to <code class="docutils literal notranslate"><span class="pre">Bcm</span></code>, expressed-in frame E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">I_BBcm_E</span></code>:</dt>
<dd>B’s rotational inertia about-point <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> expressed-in frame E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError for Debug builds if the rotational inertia that is</li>
<li>shifted to about-point <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> violates CouldBePhysicallyValid().</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Remark:</dt>
<dd>Negating the position vector <code class="docutils literal notranslate"><span class="pre">p_QBcm_E</span></code> has no affect on the
result.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[Expression].ShiftToThenAwayFromCenterOfMass">
<code class="descname">ShiftToThenAwayFromCenterOfMass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[Expression], mass: pydrake.symbolic.Expression, p_PBcm_E: numpy.ndarray[object[3, 1]], p_QBcm_E: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RotationalInertia_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[Expression].ShiftToThenAwayFromCenterOfMass" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the rotational inertia that results from shifting <code class="docutils literal notranslate"><span class="pre">this</span></code>
rotational inertia for a body (or composite body) B from about-point P
to about-point Q via Bcm (B’s center of mass). I.e., shifts <code class="docutils literal notranslate"><span class="pre">I_BP_E</span></code>
to <code class="docutils literal notranslate"><span class="pre">I_BQ_E</span></code> (both are expressed-in frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt>
<dd>The mass of body (or composite body) B.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PBcm_E</span></code>:</dt>
<dd>Position vector from P to Bcm, expressed-in frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_QBcm_E</span></code>:</dt>
<dd>Position vector from Q to Bcm, expressed-in frame E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">I_BQ_E</span></code>:</dt>
<dd>, B’s rotational inertia about-point Q expressed-in frame E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError for Debug builds if the rotational inertia that is</li>
<li>shifted to about-point Q violates CouldBePhysicallyValid().</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Remark:</dt>
<dd>Negating either (or both) position vectors p_PBcm_E and p_QBcm_E
has no affect on the result.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[Expression].Trace">
<code class="descname">Trace</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[Expression].Trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a rotational inertia’s trace (i.e., Ixx + Iyy + Izz, the sum
of the diagonal elements of the inertia matrix). The trace happens to
be invariant to its expressed-in frame (i.e., the trace does not
depend on the frame in which it is expressed). The trace is useful
because the largest moment of inertia Imax has range: trace / 3 &lt;=
Imax &lt;= trace / 2, and the largest possible product of inertia must be
&lt;= Imax / 2. Hence, trace / 3 and trace / 2 give a lower and upper
bound on the largest possible element that can be in a valid
rotational inertia.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.RotationalInertia_[Expression].TriaxiallySymmetric">
<em class="property">static </em><code class="descname">TriaxiallySymmetric</code><span class="sig-paren">(</span><em>I_triaxial: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RotationalInertia_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[Expression].TriaxiallySymmetric" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.RotationalInertia_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">RotationalInertia_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class describes the mass distribution (inertia properties) of a
body or composite body about a particular point. Herein, “composite
body” means one body or a collection of bodies that are welded
together. In this documentation, “body” and “composite body” are used
interchangeably.</p>
<p>A <strong>rigid</strong> body’s mass distribution is described by three quantities:
the body’s mass; the body’s center of mass; and the body’s rotational
inertia about a particular point. The term <strong>rotational inertia</strong> is
used here and by [Jain 2010] to distinguish from a body’s <strong>spatial
inertia</strong>. In this class, a 3x3 <strong>inertia matrix</strong> I represents a
body’s rotational inertia about a point and expressed in a frame. More
specifically, <code class="docutils literal notranslate"><span class="pre">I_BP_E</span></code> is the inertia matrix of a body B about-point
P and expressed-in frame E (herein frame E’s orthogonal unit vectors
Ex, Ey, Ez are denoted 𝐱̂, 𝐲̂, 𝐳̂).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span> <span class="n">Ixx</span> <span class="n">Ixy</span> <span class="n">Ixz</span> <span class="o">|</span>
<span class="n">I</span> <span class="o">=</span> <span class="o">|</span> <span class="n">Ixy</span> <span class="n">Iyy</span> <span class="n">Iyz</span> <span class="o">|</span>
    <span class="o">|</span> <span class="n">Ixz</span> <span class="n">Iyz</span> <span class="n">Izz</span> <span class="o">|</span>
</pre></div>
</div>
<p>The moments of inertia Ixx, Iyy, Izz and products of inertia Ixy, Ixz,
Iyz are defined in terms of the mass dm of a differential volume of
the body. The position of dm from about-point P is xx̂ + yŷ + zẑ =
[x, y, z]_E.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Ixx = ∫ (y² + z²) dm
Iyy = ∫ (x² + z²) dm
Izz = ∫ (x² + y²) dm
Ixy = - ∫ x y dm
Ixz = - ∫ x z dm
Iyz = - ∫ y z dm
</pre></div>
</div>
<p>We use the negated convention for products of inertia, so that I
serves to relate angular velocity ω and angular momentum h via <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">=</span> <span class="pre">I</span>
<span class="pre">⋅</span> <span class="pre">ω</span></code>. Ensure your products of inertia follow this negative sign
convention.</p>
<p>The 3x3 inertia matrix is symmetric and its diagonal elements (moments
of inertia) and off-diagonal elements (products of inertia) are
associated with a body (or composite body) S, an about-point P, and an
expressed-in frame E (𝐱̂, 𝐲̂, 𝐳̂̂). A rotational inertia is
ill-defined unless there is a body S, about-point P, and expressed-in
frame E. The user of this class is responsible for tracking the body
S, about-point P and expressed-in frame E (none of these are stored in
this class).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class does not store the about-point nor the expressed-in
frame, nor does this class help enforce consistency of the
about-point or expressed-in frame. To help users of this class
track the about-point and expressed-in frame, we strongly
recommend the following notation.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In typeset material, use the symbol <span class="math notranslate nohighlight">\([I^{S/P}]_E\)</span> to
represent the rotational inertia (inertia matrix) of a body (or
composite body) S about-point P, expressed in frame E. In code and
comments, use the monogram notation <code class="docutils literal notranslate"><span class="pre">I_SP_E</span></code> (e.g., as described
in multibody_spatial_inertia). If the about-point P is fixed to a
body B, the point is named <span class="math notranslate nohighlight">\(B_P\)</span> and this appears in
code/comments as <code class="docutils literal notranslate"><span class="pre">Bp</span></code>. Examples: <code class="docutils literal notranslate"><span class="pre">I_BBp_E</span></code> is rigid body B’s
rotational inertia about-point Bp expressed-in frame E; I_BBo_E is
B’s rotational inertia about-point <code class="docutils literal notranslate"><span class="pre">Bo</span></code> (body B’s origin)
expressed-in frame E; and I_BBcm_E is B’s inertia matrix
about-point <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> (B’s center of mass) expressed-in frame E.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The rotational inertia (inertia matrix) can be re-expressed in
terms of a special frame whose orthogonal unit vectors are
parallel to <strong>principal axes of inertia</strong> so that the inertia
matrix is diagonalized with elements called <strong>principal moments of
inertia</strong>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The formal definition of the inertia matrix <span class="math notranslate nohighlight">\(I^{S/P}\)</span> of a
system S about a point P follows the definition of the inertia
dyadic 𝐈 of S about P, which begins by modeling S with n particles
S₁ … Sₙ (e.g., 12 grams of carbon can be modeled with n = 6.02 *
10²³ molecules/particles). The inertia dyadic 𝐈₁ of one particle
S₁ about point P is defined [Kane, 1985] in terms of m₁ (mass of
S₁), ᴾ𝐩ˢ¹ (position vector from P to S₁), and the unit dyadic 𝐔
which is defined by the property 𝐔 ⋅ 𝐯 = 𝐯 where 𝐯 is is any
vector (this definition of 𝐔 is analogous to defining the identity
matrix by the property 𝑰𝒅𝒆𝒏𝒕𝒊𝒕𝒚𝑴𝒂𝒕𝒓𝒊𝒙 * 𝒂𝒏𝒚𝑴𝒂𝒕𝒓𝒊𝒙 = 𝒂𝒏𝒚𝑴𝒂𝒕𝒓𝒊𝒙).</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>𝐈₁ = m₁ * [𝐔 * (ᴾ𝐩ˢ¹ ⋅ ᴾ𝐩ˢ¹)  -  ᴾ𝐩ˢ¹ * ᴾ𝐩ˢ¹]
</pre></div>
</div>
<p>Note: The vector dot-product (⋅) above produces a scalar whereas the
vector multiply (*) produces a dyadic which is a 2nd-order tensor
(ᴾ𝐩ˢ¹ * ᴾ𝐩ˢ¹ is similar to the matrix outer-product of a 3x1 matrix
multiplied by a 1x3 matrix). An example inertia dyadic for a single
particle is shown further below. The inertia dyadic 𝐈 of the entire
system S is defined by summing the inertia dyadic of each particle Sᵢ
about P (i = 1, … n), i.e.,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>𝐈 = 𝐈₁ + 𝐈₂ + ... 𝐈ₙ
</pre></div>
</div>
<p>The elements of the inertia matrix <span class="math notranslate nohighlight">\([I^{S/P}]_E\)</span> expressed in
frame E (in terms of orthogonal unit vectors 𝐱̂, 𝐲̂, 𝐳̂̂) are found by
pre-dot multiplying and post-dot multiplying 𝐈 with appropriate unit
vectors.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Ixx = 𝐱̂ ⋅ 𝐈 ⋅ 𝐱̂     Ixy = 𝐱̂ ⋅ 𝐈 ⋅ 𝐲̂      Ixz = 𝐱̂ ⋅ 𝐈 ⋅ 𝐳̂̂
   Iyx = 𝐲̂ ⋅ 𝐈 ⋅ 𝐱̂     Iyy = 𝐲̂ ⋅ 𝐈 ⋅ 𝐲̂      Iyz = 𝐲̂ ⋅ 𝐈 ⋅ 𝐳̂̂
   Izx = 𝐳̂̂ ⋅ 𝐈 ⋅ 𝐱̂     Izy = 𝐳̂̂ ⋅ 𝐈 ⋅ 𝐲̂      Izz = 𝐳̂̂ ⋅ 𝐈 ⋅ 𝐳̂̂
</pre></div>
</div>
<p>The inertia dyadic 𝐈ᴮ of a rigid body B about Bcm (B’s center of mass)
is related to various dynamic quantities. For example, B’s angular
momentum 𝐇 about Bcm in a frame N and B’s kinetic energy KE in N
relate to 𝐈ᴮ by</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>𝐇 = 𝐈ᴮ ⋅ 𝛚
   KE = 1/2 𝛚 ⋅ 𝐈ᴮ ⋅ 𝛚  +  1/2 mᴮ 𝐯 ⋅ 𝐯
</pre></div>
</div>
<p>where 𝛚 is B’s angular velocity in N, 𝐯 is Bcm’s translational
velocity in N, and mᴮ is B’s mass. When frame N happens to be a
Newtonian frame (also called an inertial frame or
non-rotating/non-accelerating frame), the moment 𝐓 of all forces on B
about Bcm relates to 𝐈ᴮ and 𝛂 (B’s angular acceleration in N) by
Euler’s rigid body equation as</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>𝐓 = 𝐈ᴮ ⋅ 𝛂  +  𝛚 × 𝐈ᴮ ⋅ 𝛚
</pre></div>
</div>
<p>Example: For a particle Q of mass m whose position vector from a point
O is written in terms of right-handed orthogonal unit vectors 𝐱̂, 𝐲̂,
𝐳̂ (below), the inertia dyadic 𝐈 of particle Q about point O is
defined and calculated</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>𝐩 = x 𝐱̂  +  y 𝐲̂                               (given)
    𝐈 = m * [𝐔 * (𝐩 ⋅ 𝐩)  -  𝐩 * 𝐩]              (definition)
      = m * [𝐔 * (x² + y²)  -  (x𝐱̂ + y𝐲̂̂) * (x𝐱̂ + y𝐲̂)
      = m * [(𝐱̂𝐱̂ + 𝐲̂𝐲̂ + 𝐳̂𝐳̂) * (x² + y²) - (x²𝐱̂𝐱̂ + xy𝐱̂𝐲̂̂ + xy𝐲̂̂𝐱̂ + y²𝐲̂̂𝐲̂̂)]
      = m * [y²𝐱̂𝐱̂ + x²𝐲̂𝐲̂ + (x² + y²)𝐳̂𝐳̂ - xy𝐱̂𝐲̂̂ - xy𝐲̂̂𝐱̂]
</pre></div>
</div>
<p>which means the inertia matrix for particle Q about point O for 𝐱̂,
𝐲̂, 𝐳̂ is</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>|  m y²     -m x y         0     |
I = | -m x y     m x²          0     |
    |    0         0     m (x² + y²) |
</pre></div>
</div>
<p>[Kane, 1985] pg. 68. “Dynamics: Theory and Applications,” McGraw-Hill
Co., New York, 1985 (with D. A. Levinson). Available for free .pdf
download: <a class="reference external" href="https://ecommons.cornell.edu/handle/1813/637">https://ecommons.cornell.edu/handle/1813/637</a></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Several methods in this class throw a RuntimeError for invalid
rotational inertia operations in debug releases only. This
provides speed in a release build while facilitating debugging in
debug builds. In addition, these validity tests are only performed
for scalar types for which drake::scalar_predicate&lt;T&gt;::is_bool is
<code class="docutils literal notranslate"><span class="pre">True</span></code>. For instance, validity checks are not performed when T
is symbolic::Expression.</p>
</div>
<p>Various methods in this class require numerical (not symbolic) data
types.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.RotationalInertia_[float]) -&gt; None</li>
</ol>
<p>Constructs a rotational inertia that has all its moments/products of
inertia equal to NaN (helps quickly detect uninitialized values).</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.RotationalInertia_[float], Ixx: float, Iyy: float, Izz: float) -&gt; None</li>
</ol>
<p>Creates a rotational inertia with moments of inertia <code class="docutils literal notranslate"><span class="pre">Ixx</span></code>, <cite>Iyy</cite>,
<code class="docutils literal notranslate"><span class="pre">Izz</span></code>, and with each product of inertia set to zero.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError for Debug builds if not CouldBePhysicallyValid().</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.tree.RotationalInertia_[float], Ixx: float, Iyy: float, Izz: float, Ixy: float, Ixz: float, Iyz: float) -&gt; None</li>
</ol>
<p>Creates a rotational inertia with moments of inertia <code class="docutils literal notranslate"><span class="pre">Ixx</span></code>, <cite>Iyy</cite>,
<code class="docutils literal notranslate"><span class="pre">Izz</span></code>, and with products of inertia <code class="docutils literal notranslate"><span class="pre">Ixy</span></code>, <cite>Ixz</cite>, <code class="docutils literal notranslate"><span class="pre">Iyz</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError for Debug builds if not CouldBePhysicallyValid().</td>
</tr>
</tbody>
</table>
<ol class="arabic simple" start="4">
<li>__init__(self: pydrake.multibody.tree.RotationalInertia_[float], mass: float, p_PQ_E: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</li>
</ol>
<p>Constructs a rotational inertia for a particle Q of mass <code class="docutils literal notranslate"><span class="pre">mass</span></code>,
whose position vector from about-point P is p_PQ_E (E is expressed-in
frame). This RuntimeError exception only occurs if <code class="docutils literal notranslate"><span class="pre">mass</span></code> &lt; 0.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt>
<dd>The mass of particle Q.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PQ_E</span></code>:</dt>
<dd>Position from about-point P to Q, expressed-in frame E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">I_QP_E</span></code>:</dt>
<dd>, Q’s rotational inertia about-point P expressed-in frame E.</dd>
<dt>Remark:</dt>
<dd>Negating the position vector p_PQ_E has no affect on the result.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError for Debug builds if not CouldBePhysicallyValid().</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[float].CalcMaximumPossibleMomentOfInertia">
<code class="descname">CalcMaximumPossibleMomentOfInertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[float].CalcMaximumPossibleMomentOfInertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the maximum possible moment of inertia for <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational
inertia about-point P for any expressed-in frame E.</p>
<dl class="docutils">
<dt>Remark:</dt>
<dd>The maximum moment Imax has range: trace / 3 &lt;= Imax &lt;= trace / 2.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">Trace()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[float].CalcPrincipalMomentsOfInertia">
<code class="descname">CalcPrincipalMomentsOfInertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[float].CalcPrincipalMomentsOfInertia" title="Permalink to this definition">¶</a></dt>
<dd><p>This method takes <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia about-point P,
expressed-in frame E, and computes its principal moments of inertia
about-point P, but expressed-in a frame aligned with the principal
axes.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">: This method only works for a rotational inertia with scalar type
T that can be converted to a double (discarding any supplemental
scalar data such as derivatives of an AutoDiffXd).</p>
</div>
<dl class="docutils">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">principal_moments</span></code>:</dt>
<dd>The vector of principal moments of inertia <code class="docutils literal notranslate"><span class="pre">[Ixx</span> <span class="pre">Iyy</span> <span class="pre">Izz]</span></code>
sorted in ascending order.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if eigenvalue solver fails or if scalar type T cannot</li>
<li>be converted to a double.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[float].cols">
<code class="descname">cols</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[float].cols" title="Permalink to this definition">¶</a></dt>
<dd><p>For consistency with Eigen’s API, the cols() method returns 3.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[float].CopyToFullMatrix3">
<code class="descname">CopyToFullMatrix3</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 3]]<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[float].CopyToFullMatrix3" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets a full 3x3 matrix copy of this rotational inertia. The returned
copy is symmetric and includes both lower and upper parts of the
matrix.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[float].CouldBePhysicallyValid">
<code class="descname">CouldBePhysicallyValid</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[float].CouldBePhysicallyValid" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs several necessary checks to verify whether <code class="docutils literal notranslate"><span class="pre">this</span></code>
rotational inertia <em>could</em> be physically valid, including:</p>
<ul class="simple">
<li>No NaN moments or products of inertia.</li>
<li>Ixx, Iyy, Izz and principal moments are all non-negative.</li>
<li>Ixx, Iyy  Izz and principal moments satisfy the triangle inequality:
- <code class="docutils literal notranslate"><span class="pre">Ixx</span> <span class="pre">+</span> <span class="pre">Iyy</span> <span class="pre">&gt;=</span> <span class="pre">Izz</span></code>
- <cite>Ixx + Izz &gt;= Iyy</cite>
- <code class="docutils literal notranslate"><span class="pre">Iyy</span> <span class="pre">+</span> <span class="pre">Izz</span> <span class="pre">&gt;=</span> <span class="pre">Ixx</span></code></li>
</ul>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">These checks are necessary (but NOT sufficient) conditions for a
rotational inertia to be physically valid. The sufficient
condition requires a rotational inertia to satisfy the above
checks <em>after</em> <code class="docutils literal notranslate"><span class="pre">this</span></code> is shifted to the center of mass, i.e.,
the sufficient condition requires calling CouldBePhysicallyValid()
when the about-point is Bcm (the body’s center of mass). Note:
this class does not know its about-point or its center of mass
location.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><code class="docutils literal notranslate"><span class="pre">True</span></code> for a plausible rotational inertia passing the above
necessary but insufficient checks and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError if principal moments of inertia cannot be calculated</li>
<li>(eigenvalue solver) or if scalar type T cannot be converted to a</li>
<li><code class="xref py py-exc docutils literal notranslate"><span class="pre">double.</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[float].get_moments">
<code class="descname">get_moments</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[float].get_moments" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns 3-element vector with moments of inertia [Ixx, Iyy, Izz].</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[float].get_products">
<code class="descname">get_products</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[float].get_products" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns 3-element vector with products of inertia [Ixy, Ixz, Iyz].</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[float].IsNaN">
<code class="descname">IsNaN</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[float].IsNaN" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if any moment/product in <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia
is NaN. Otherwise returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[float].IsNearlyEqualTo">
<code class="descname">IsNearlyEqualTo</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[float], other: pydrake.multibody.tree.RotationalInertia_[float], precision: float</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[float].IsNearlyEqualTo" title="Permalink to this definition">¶</a></dt>
<dd><p>Compares <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia to <code class="docutils literal notranslate"><span class="pre">other</span></code> rotional inertia
within the specified <code class="docutils literal notranslate"><span class="pre">precision</span></code> (which is a dimensionless number
specifying the relative precision to which the comparison is
performed). Denoting <code class="docutils literal notranslate"><span class="pre">I_maxA</span></code> as the largest element value that can
appear in a valid <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia (independent of the
expressed-in frame E) and denoting <code class="docutils literal notranslate"><span class="pre">I_maxB</span></code> as the largest element
value that can appear in a valid <code class="docutils literal notranslate"><span class="pre">other</span></code> rotational inertia
(independent of the expressed-in frame E), <code class="docutils literal notranslate"><span class="pre">this</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code> are
considered nearly equal to each other, if: ‖this - other‖∞ &lt; precision
* min(I_maxA, I_maxB)</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">other</span></code>:</dt>
<dd>Rotational inertia to compare with <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">precision</span></code>:</dt>
<dd>is a dimensionless real positive number that is usually based on
two factors, namely expected accuracy of moments/products of
inertia (e.g., from end-user or CAD) and/or machine-precision.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><code class="docutils literal notranslate"><span class="pre">True</span></code> if the absolute value of each moment/product of inertia
in <code class="docutils literal notranslate"><span class="pre">this</span></code> is within <code class="docutils literal notranslate"><span class="pre">epsilon</span></code> of the corresponding moment/
product absolute value in <code class="docutils literal notranslate"><span class="pre">other</span></code>. Otherwise returns <code class="docutils literal notranslate"><span class="pre">False</span></code>.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">: This method only works if all moments of inertia with scalar
type T in <code class="docutils literal notranslate"><span class="pre">this</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span></code> can be converted to a double
(discarding supplemental scalar data such as derivatives of an
AutoDiffXd). It fails at runtime if type T cannot be converted to
<code class="docutils literal notranslate"><span class="pre">double</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[float].ReExpress">
<code class="descname">ReExpress</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[float], R_AE: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RotationalInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[float].ReExpress" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-expresses <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia <code class="docutils literal notranslate"><span class="pre">I_BP_E</span></code> to <code class="docutils literal notranslate"><span class="pre">I_BP_A</span></code>
i.e., re-expresses body B’s rotational inertia from frame E to frame
A.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_AE</span></code>:</dt>
<dd>RotationMatrix relating frames A and E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">I_BP_A</span></code>:</dt>
<dd>Rotational inertia of B about-point P expressed-in frame A.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError for Debug builds if the rotational inertia that is</li>
<li>re-expressed-in frame A violates CouldBePhysicallyValid().</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ReExpressInPlace()</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[float].rows">
<code class="descname">rows</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[float]</em><span class="sig-paren">)</span> &#x2192; int<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[float].rows" title="Permalink to this definition">¶</a></dt>
<dd><p>For consistency with Eigen’s API, the rows() method returns 3.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[float].SetToNaN">
<code class="descname">SetToNaN</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[float].SetToNaN" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia so all its elements are equal to NaN.
This helps quickly detect uninitialized moments/products of inertia.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[float].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[float].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> rotational inertia so all its moments/products of
inertia are zero, e.g., for convenient initialization before a
computation or for inertia calculations involving a particle
(point-mass). Note: Real 3D massive physical objects have non-zero
moments of inertia.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[float].ShiftFromCenterOfMass">
<code class="descname">ShiftFromCenterOfMass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[float], mass: float, p_BcmQ_E: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RotationalInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[float].ShiftFromCenterOfMass" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the rotational inertia that results from shifting <code class="docutils literal notranslate"><span class="pre">this</span></code>
rotational inertia for a body (or composite body) B from about-point
Bcm (B’s center of mass) to about-point Q. I.e., shifts <code class="docutils literal notranslate"><span class="pre">I_BBcm_E</span></code>
to <code class="docutils literal notranslate"><span class="pre">I_BQ_E</span></code> (both are expressed-in frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt>
<dd>The mass of body (or composite body) B.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BcmQ_E</span></code>:</dt>
<dd>Position vector from Bcm to Q, expressed-in frame E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">I_BQ_E</span></code>:</dt>
<dd>B’s rotational inertia about-point Q expressed-in frame E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError for Debug builds if the rotational inertia that is</li>
<li>shifted to about-point Q violates CouldBePhysicallyValid().</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Remark:</dt>
<dd>Negating the position vector p_BcmQ_E has no affect on the result.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[float].ShiftToCenterOfMass">
<code class="descname">ShiftToCenterOfMass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[float], mass: float, p_QBcm_E: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RotationalInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[float].ShiftToCenterOfMass" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the rotational inertia that results from shifting <code class="docutils literal notranslate"><span class="pre">this</span></code>
rotational inertia for a body (or composite body) B from about-point Q
to about-point <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> (B’s center of mass). I.e., shifts <code class="docutils literal notranslate"><span class="pre">I_BQ_E</span></code>
to <code class="docutils literal notranslate"><span class="pre">I_BBcm_E</span></code> (both are expressed-in frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt>
<dd>The mass of body (or composite body) B.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_QBcm_E</span></code>:</dt>
<dd>Position vector from Q to <code class="docutils literal notranslate"><span class="pre">Bcm</span></code>, expressed-in frame E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">I_BBcm_E</span></code>:</dt>
<dd>B’s rotational inertia about-point <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> expressed-in frame E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError for Debug builds if the rotational inertia that is</li>
<li>shifted to about-point <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> violates CouldBePhysicallyValid().</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Remark:</dt>
<dd>Negating the position vector <code class="docutils literal notranslate"><span class="pre">p_QBcm_E</span></code> has no affect on the
result.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[float].ShiftToThenAwayFromCenterOfMass">
<code class="descname">ShiftToThenAwayFromCenterOfMass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[float], mass: float, p_PBcm_E: numpy.ndarray[numpy.float64[3, 1]], p_QBcm_E: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RotationalInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[float].ShiftToThenAwayFromCenterOfMass" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the rotational inertia that results from shifting <code class="docutils literal notranslate"><span class="pre">this</span></code>
rotational inertia for a body (or composite body) B from about-point P
to about-point Q via Bcm (B’s center of mass). I.e., shifts <code class="docutils literal notranslate"><span class="pre">I_BP_E</span></code>
to <code class="docutils literal notranslate"><span class="pre">I_BQ_E</span></code> (both are expressed-in frame E).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt>
<dd>The mass of body (or composite body) B.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PBcm_E</span></code>:</dt>
<dd>Position vector from P to Bcm, expressed-in frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_QBcm_E</span></code>:</dt>
<dd>Position vector from Q to Bcm, expressed-in frame E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">I_BQ_E</span></code>:</dt>
<dd>, B’s rotational inertia about-point Q expressed-in frame E.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError for Debug builds if the rotational inertia that is</li>
<li>shifted to about-point Q violates CouldBePhysicallyValid().</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Remark:</dt>
<dd>Negating either (or both) position vectors p_PBcm_E and p_QBcm_E
has no affect on the result.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.RotationalInertia_[float].Trace">
<code class="descname">Trace</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.RotationalInertia_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[float].Trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a rotational inertia’s trace (i.e., Ixx + Iyy + Izz, the sum
of the diagonal elements of the inertia matrix). The trace happens to
be invariant to its expressed-in frame (i.e., the trace does not
depend on the frame in which it is expressed). The trace is useful
because the largest moment of inertia Imax has range: trace / 3 &lt;=
Imax &lt;= trace / 2, and the largest possible product of inertia must be
&lt;= Imax / 2. Hence, trace / 3 and trace / 2 give a lower and upper
bound on the largest possible element that can be in a valid
rotational inertia.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.RotationalInertia_[float].TriaxiallySymmetric">
<em class="property">static </em><code class="descname">TriaxiallySymmetric</code><span class="sig-paren">(</span><em>I_triaxial: float</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RotationalInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.RotationalInertia_[float].TriaxiallySymmetric" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.ScrewJoint">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">ScrewJoint</code><a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.ScrewJoint_[float]" title="pydrake.multibody.tree.ScrewJoint_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ScrewJoint_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.ScrewJoint_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">ScrewJoint_</code><a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.ScrewJoint_[float]" title="pydrake.multibody.tree.ScrewJoint_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">ScrewJoint_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.ScrewJoint_[AutoDiffXd]" title="pydrake.multibody.tree.ScrewJoint_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">ScrewJoint_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.ScrewJoint_[Expression]" title="pydrake.multibody.tree.ScrewJoint_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">ScrewJoint_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.ScrewJoint_.ScrewJoint_[float]">
<em class="property">class </em><code class="descname">ScrewJoint_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_.ScrewJoint_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[float]" title="pydrake.multibody.tree.Joint_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[float]</span></code></a></p>
<p>This joint models a screw joint allowing two bodies to rotate about
one axis while translating along that same axis with one degree of
freedom. That is, given a frame F attached to the parent body P and a
frame M attached to the child body B (see the Joint class’s
documentation), this joint allows frame M to translate (while
rotating) along an axis â. Axis â is constant and has the same
measures in both frames F and M, that is, <code class="docutils literal notranslate"><span class="pre">â_F</span> <span class="pre">=</span> <span class="pre">â_M</span></code>. The
rotation about the <code class="docutils literal notranslate"><span class="pre">â_F</span></code> axis and its rate specify the state of the
joint. Zero (θ) corresponds to frames F and M being coincident and
aligned. The translation distance is defined positive when child body
B translates along the direction of â, and the rotation θ is defined
to be positive according to the right-hand-rule with the thumb aligned
in the direction of the <code class="docutils literal notranslate"><span class="pre">â_F</span></code> axis.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_.ScrewJoint_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_.ScrewJoint_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.ScrewJoint_[float], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[float], frame_on_child: pydrake.multibody.tree.Frame_[float], screw_pitch: Optional[float] = None, damping: Optional[float] = None) -&gt; None</li>
</ol>
<p>Constructor to create a screw joint between two bodies so that frame F
attached to the parent body P and frame M attached to the child body B
translate and rotate as described in the class’s documentation. This
constructor signature creates a joint with the axis â set to the
z-axis and no joint limits, i.e. the joint angular position, angular
velocity and angular acceleration limits are the pair <code class="docutils literal notranslate"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>.
These can be set using the Joint methods set_position_limits(),
set_velocity_limits() and set_acceleration_limits() in radians,
radians/s, radians/s² units. The first three arguments to this
constructor are those of the Joint class constructor. See the Joint
class’s documentation for details. The additional parameters are:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">screw_pitch</span></code>:</dt>
<dd>Amount of translation in meters occurring over a one full screw
revolution. It’s domain is (-∞, ∞). When the screw pitch is
negative, positive rotation will result in translating towards the
negative direction of z-axis. When the screw pitch is zero, this
joint will behave like a revolute joint.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, N⋅m⋅s/rad for rotation, used to model
losses within the joint. See documentation of damping() for
details on modelling of the damping torque.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if damping is negative.</td>
</tr>
</tbody>
</table>
<p>The defaults values for screw_pitch and damping are deprecated and will removed on 2023-02-01.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.ScrewJoint_[float], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[float], frame_on_child: pydrake.multibody.tree.Frame_[float], axis: numpy.ndarray[numpy.float64[3, 1]], screw_pitch: float, damping: float) -&gt; None</li>
</ol>
<p>Constructor to create a screw joint between two bodies so that frame F
attached to the parent body P and frame M attached to the child body B
translate and rotate as described in the class’s documentation. This
constructor signature creates a joint with no joint limits, i.e. the
joint angular position, angular velocity and angular acceleration
limits are the pair <code class="docutils literal notranslate"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. These can be set using the Joint
methods set_position_limits(), set_velocity_limits() and
set_acceleration_limits() in radians, radians/s, radians/s² units. The
first three arguments to this constructor are those of the Joint class
constructor. See the Joint class’s documentation for details. The
additional parameters are:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">axis</span></code>:</dt>
<dd>A vector in ℝ³ specifying the axis of motion for this joint. The
coordinates of <code class="docutils literal notranslate"><span class="pre">axis</span></code> expressed in frames F and M are the same
at all times, that is, <code class="docutils literal notranslate"><span class="pre">axis_F</span> <span class="pre">=</span> <span class="pre">axis_M</span></code>. In other words,
<code class="docutils literal notranslate"><span class="pre">axis_F</span></code> (or <code class="docutils literal notranslate"><span class="pre">axis_M</span></code>) is the eigenvector of <code class="docutils literal notranslate"><span class="pre">R_FM</span></code> with
eigenvalue equal to one. This vector can have any length, only the
direction is used.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">screw_pitch</span></code>:</dt>
<dd>Amount of translation in meters occurring over a one full screw
revolution. It’s domain is (-∞, ∞). When the screw pitch is
negative, positive rotation will result in translating towards the
negative direction of â-axis. When the screw pitch is zero, this
joint will behave like a revolute joint.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, N⋅m⋅s/rad for rotation, used to model
losses within the joint. See documentation of damping() for
details on modelling of the damping torque.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the L2 norm of <code class="docutils literal notranslate"><span class="pre">axis</span></code> is less than the square</li>
<li>root of machine epsilon.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">RuntimeError if damping is negative.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_.ScrewJoint_[float].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_.ScrewJoint_[float].damping" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s damping constant N⋅m⋅s for the rotational
degree. The damping torque (in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span> <span class="pre">-damping⋅ω</span></code>
i.e. opposing motion, with ω the angular rate for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see
get_angular_velocity()) and τ the torque on child body B expressed in
frame F as t_B_F = τ⋅Fâ_F.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_.ScrewJoint_[float].get_angular_velocity">
<code class="descname">get_angular_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_.ScrewJoint_[float].get_angular_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rate of change, in radians per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
angle θ from <code class="docutils literal notranslate"><span class="pre">context</span></code>. See class documentation for the definition
of this angle.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>:</dt>
<dd>The rate of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s angle θ as stored in the
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_.ScrewJoint_[float].get_default_rotation">
<code class="descname">get_default_rotation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_.ScrewJoint_[float].get_default_rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default angle for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt>
<dd>The default angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_.ScrewJoint_[float].get_default_translation">
<code class="descname">get_default_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_.ScrewJoint_[float].get_default_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default position for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">z</span></code>:</dt>
<dd>The default position of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_.ScrewJoint_[float].get_rotation">
<code class="descname">get_rotation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_.ScrewJoint_[float].get_rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the angle θ of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt>
<dd>The angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code>. See class
documentation for details.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_.ScrewJoint_[float].get_translation">
<code class="descname">get_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_.ScrewJoint_[float].get_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the translation of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">z</span></code>:</dt>
<dd>The translation of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code> as
(z). See class documentation for details.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_.ScrewJoint_[float].get_translational_velocity">
<code class="descname">get_translational_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_.ScrewJoint_[float].get_translational_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the translational velocity vz, in meters per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code>
joint’s Mo measured and expressed in frame F from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">vz</span></code>:</dt>
<dd>The translational velocity of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint as stored in the
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_.ScrewJoint_[float].screw_pitch">
<code class="descname">screw_pitch</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_.ScrewJoint_[float].screw_pitch" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s amount of translation in meters occurring
over a one full revolution.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_.ScrewJoint_[float].set_angular_velocity">
<code class="descname">set_angular_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[float], context: pydrake.systems.framework.Context_[float], theta_dot: float</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ScrewJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_.ScrewJoint_[float].set_angular_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the rate of change, in radians per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
angle θ (see class documentation) to <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>. The new rate of
change gets stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>:</dt>
<dd>The desired rates of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s angle in radians
per second.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_.ScrewJoint_[float].set_default_rotation">
<code class="descname">set_default_rotation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[float], theta: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_.ScrewJoint_[float].set_default_rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default angle of this joint. This will change the
<code class="docutils literal notranslate"><span class="pre">default_translation</span></code> too, because they are not independent in this
joint.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt>
<dd>The desired default angle of the joint</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_.ScrewJoint_[float].set_default_translation">
<code class="descname">set_default_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[float], z: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_.ScrewJoint_[float].set_default_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default translation of this joint. This will change the
<code class="docutils literal notranslate"><span class="pre">default_rotation</span></code> too, which are not independent in this joint.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">z</span></code>:</dt>
<dd>The desired default translation of the joint</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if pitch is very near zero.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_.ScrewJoint_[float].set_random_pose_distribution">
<code class="descname">set_random_pose_distribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[float], theta: numpy.ndarray[object[1, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_.ScrewJoint_[float].set_random_pose_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the random distribution that the angle of this joint will be
randomly sampled from. See class documentation for details on the
definition of the position and angle.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_.ScrewJoint_[float].set_translation">
<code class="descname">set_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[float], context: pydrake.systems.framework.Context_[float], translation: float</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ScrewJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_.ScrewJoint_[float].set_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the translation of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals
to (z).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">z</span></code>:</dt>
<dd>The desired translation in meters to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> as
(z). See class documentation for details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_.ScrewJoint_[float].set_translational_velocity">
<code class="descname">set_translational_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[float], context: pydrake.systems.framework.Context_[float], translation_dot: float</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ScrewJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_.ScrewJoint_[float].set_translational_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the translational velocity, in meters per second, of this
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s Mo along frame F’s â-axis to <code class="docutils literal notranslate"><span class="pre">vz</span></code>. The new
translational velocity gets stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">vz</span></code>:</dt>
<dd>The desired translational velocity of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters per
second along F frame’s â-axis.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.ScrewJoint_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">ScrewJoint_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[AutoDiffXd]" title="pydrake.multibody.tree.Joint_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd]</span></code></a></p>
<p>This joint models a screw joint allowing two bodies to rotate about
one axis while translating along that same axis with one degree of
freedom. That is, given a frame F attached to the parent body P and a
frame M attached to the child body B (see the Joint class’s
documentation), this joint allows frame M to translate (while
rotating) along an axis â. Axis â is constant and has the same
measures in both frames F and M, that is, <code class="docutils literal notranslate"><span class="pre">â_F</span> <span class="pre">=</span> <span class="pre">â_M</span></code>. The
rotation about the <code class="docutils literal notranslate"><span class="pre">â_F</span></code> axis and its rate specify the state of the
joint. Zero (θ) corresponds to frames F and M being coincident and
aligned. The translation distance is defined positive when child body
B translates along the direction of â, and the rotation θ is defined
to be positive according to the right-hand-rule with the thumb aligned
in the direction of the <code class="docutils literal notranslate"><span class="pre">â_F</span></code> axis.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.ScrewJoint_[AutoDiffXd], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_on_child: pydrake.multibody.tree.Frame_[AutoDiffXd], screw_pitch: Optional[float] = None, damping: Optional[float] = None) -&gt; None</li>
</ol>
<p>Constructor to create a screw joint between two bodies so that frame F
attached to the parent body P and frame M attached to the child body B
translate and rotate as described in the class’s documentation. This
constructor signature creates a joint with the axis â set to the
z-axis and no joint limits, i.e. the joint angular position, angular
velocity and angular acceleration limits are the pair <code class="docutils literal notranslate"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>.
These can be set using the Joint methods set_position_limits(),
set_velocity_limits() and set_acceleration_limits() in radians,
radians/s, radians/s² units. The first three arguments to this
constructor are those of the Joint class constructor. See the Joint
class’s documentation for details. The additional parameters are:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">screw_pitch</span></code>:</dt>
<dd>Amount of translation in meters occurring over a one full screw
revolution. It’s domain is (-∞, ∞). When the screw pitch is
negative, positive rotation will result in translating towards the
negative direction of z-axis. When the screw pitch is zero, this
joint will behave like a revolute joint.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, N⋅m⋅s/rad for rotation, used to model
losses within the joint. See documentation of damping() for
details on modelling of the damping torque.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if damping is negative.</td>
</tr>
</tbody>
</table>
<p>The defaults values for screw_pitch and damping are deprecated and will removed on 2023-02-01.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.ScrewJoint_[AutoDiffXd], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_on_child: pydrake.multibody.tree.Frame_[AutoDiffXd], axis: numpy.ndarray[numpy.float64[3, 1]], screw_pitch: float, damping: float) -&gt; None</li>
</ol>
<p>Constructor to create a screw joint between two bodies so that frame F
attached to the parent body P and frame M attached to the child body B
translate and rotate as described in the class’s documentation. This
constructor signature creates a joint with no joint limits, i.e. the
joint angular position, angular velocity and angular acceleration
limits are the pair <code class="docutils literal notranslate"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. These can be set using the Joint
methods set_position_limits(), set_velocity_limits() and
set_acceleration_limits() in radians, radians/s, radians/s² units. The
first three arguments to this constructor are those of the Joint class
constructor. See the Joint class’s documentation for details. The
additional parameters are:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">axis</span></code>:</dt>
<dd>A vector in ℝ³ specifying the axis of motion for this joint. The
coordinates of <code class="docutils literal notranslate"><span class="pre">axis</span></code> expressed in frames F and M are the same
at all times, that is, <code class="docutils literal notranslate"><span class="pre">axis_F</span> <span class="pre">=</span> <span class="pre">axis_M</span></code>. In other words,
<code class="docutils literal notranslate"><span class="pre">axis_F</span></code> (or <code class="docutils literal notranslate"><span class="pre">axis_M</span></code>) is the eigenvector of <code class="docutils literal notranslate"><span class="pre">R_FM</span></code> with
eigenvalue equal to one. This vector can have any length, only the
direction is used.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">screw_pitch</span></code>:</dt>
<dd>Amount of translation in meters occurring over a one full screw
revolution. It’s domain is (-∞, ∞). When the screw pitch is
negative, positive rotation will result in translating towards the
negative direction of â-axis. When the screw pitch is zero, this
joint will behave like a revolute joint.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, N⋅m⋅s/rad for rotation, used to model
losses within the joint. See documentation of damping() for
details on modelling of the damping torque.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the L2 norm of <code class="docutils literal notranslate"><span class="pre">axis</span></code> is less than the square</li>
<li>root of machine epsilon.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">RuntimeError if damping is negative.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[AutoDiffXd].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[AutoDiffXd].damping" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s damping constant N⋅m⋅s for the rotational
degree. The damping torque (in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span> <span class="pre">-damping⋅ω</span></code>
i.e. opposing motion, with ω the angular rate for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see
get_angular_velocity()) and τ the torque on child body B expressed in
frame F as t_B_F = τ⋅Fâ_F.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[AutoDiffXd].get_angular_velocity">
<code class="descname">get_angular_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.autodiffutils.AutoDiffXd<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[AutoDiffXd].get_angular_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rate of change, in radians per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
angle θ from <code class="docutils literal notranslate"><span class="pre">context</span></code>. See class documentation for the definition
of this angle.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>:</dt>
<dd>The rate of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s angle θ as stored in the
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[AutoDiffXd].get_default_rotation">
<code class="descname">get_default_rotation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[AutoDiffXd].get_default_rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default angle for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt>
<dd>The default angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[AutoDiffXd].get_default_translation">
<code class="descname">get_default_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[AutoDiffXd].get_default_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default position for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">z</span></code>:</dt>
<dd>The default position of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[AutoDiffXd].get_rotation">
<code class="descname">get_rotation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.autodiffutils.AutoDiffXd<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[AutoDiffXd].get_rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the angle θ of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt>
<dd>The angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code>. See class
documentation for details.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[AutoDiffXd].get_translation">
<code class="descname">get_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.autodiffutils.AutoDiffXd<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[AutoDiffXd].get_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the translation of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">z</span></code>:</dt>
<dd>The translation of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code> as
(z). See class documentation for details.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[AutoDiffXd].get_translational_velocity">
<code class="descname">get_translational_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.autodiffutils.AutoDiffXd<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[AutoDiffXd].get_translational_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the translational velocity vz, in meters per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code>
joint’s Mo measured and expressed in frame F from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">vz</span></code>:</dt>
<dd>The translational velocity of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint as stored in the
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[AutoDiffXd].screw_pitch">
<code class="descname">screw_pitch</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[AutoDiffXd].screw_pitch" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s amount of translation in meters occurring
over a one full revolution.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[AutoDiffXd].set_angular_velocity">
<code class="descname">set_angular_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], theta_dot: pydrake.autodiffutils.AutoDiffXd</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ScrewJoint_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[AutoDiffXd].set_angular_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the rate of change, in radians per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
angle θ (see class documentation) to <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>. The new rate of
change gets stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>:</dt>
<dd>The desired rates of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s angle in radians
per second.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[AutoDiffXd].set_default_rotation">
<code class="descname">set_default_rotation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[AutoDiffXd], theta: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[AutoDiffXd].set_default_rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default angle of this joint. This will change the
<code class="docutils literal notranslate"><span class="pre">default_translation</span></code> too, because they are not independent in this
joint.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt>
<dd>The desired default angle of the joint</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[AutoDiffXd].set_default_translation">
<code class="descname">set_default_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[AutoDiffXd], z: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[AutoDiffXd].set_default_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default translation of this joint. This will change the
<code class="docutils literal notranslate"><span class="pre">default_rotation</span></code> too, which are not independent in this joint.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">z</span></code>:</dt>
<dd>The desired default translation of the joint</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if pitch is very near zero.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[AutoDiffXd].set_random_pose_distribution">
<code class="descname">set_random_pose_distribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[AutoDiffXd], theta: numpy.ndarray[object[1, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[AutoDiffXd].set_random_pose_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the random distribution that the angle of this joint will be
randomly sampled from. See class documentation for details on the
definition of the position and angle.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[AutoDiffXd].set_translation">
<code class="descname">set_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], translation: pydrake.autodiffutils.AutoDiffXd</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ScrewJoint_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[AutoDiffXd].set_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the translation of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals
to (z).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">z</span></code>:</dt>
<dd>The desired translation in meters to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> as
(z). See class documentation for details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[AutoDiffXd].set_translational_velocity">
<code class="descname">set_translational_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], translation_dot: pydrake.autodiffutils.AutoDiffXd</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ScrewJoint_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[AutoDiffXd].set_translational_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the translational velocity, in meters per second, of this
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s Mo along frame F’s â-axis to <code class="docutils literal notranslate"><span class="pre">vz</span></code>. The new
translational velocity gets stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">vz</span></code>:</dt>
<dd>The desired translational velocity of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters per
second along F frame’s â-axis.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.ScrewJoint_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">ScrewJoint_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[Expression]" title="pydrake.multibody.tree.Joint_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[Expression]</span></code></a></p>
<p>This joint models a screw joint allowing two bodies to rotate about
one axis while translating along that same axis with one degree of
freedom. That is, given a frame F attached to the parent body P and a
frame M attached to the child body B (see the Joint class’s
documentation), this joint allows frame M to translate (while
rotating) along an axis â. Axis â is constant and has the same
measures in both frames F and M, that is, <code class="docutils literal notranslate"><span class="pre">â_F</span> <span class="pre">=</span> <span class="pre">â_M</span></code>. The
rotation about the <code class="docutils literal notranslate"><span class="pre">â_F</span></code> axis and its rate specify the state of the
joint. Zero (θ) corresponds to frames F and M being coincident and
aligned. The translation distance is defined positive when child body
B translates along the direction of â, and the rotation θ is defined
to be positive according to the right-hand-rule with the thumb aligned
in the direction of the <code class="docutils literal notranslate"><span class="pre">â_F</span></code> axis.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.ScrewJoint_[Expression], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[Expression], frame_on_child: pydrake.multibody.tree.Frame_[Expression], screw_pitch: Optional[float] = None, damping: Optional[float] = None) -&gt; None</li>
</ol>
<p>Constructor to create a screw joint between two bodies so that frame F
attached to the parent body P and frame M attached to the child body B
translate and rotate as described in the class’s documentation. This
constructor signature creates a joint with the axis â set to the
z-axis and no joint limits, i.e. the joint angular position, angular
velocity and angular acceleration limits are the pair <code class="docutils literal notranslate"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>.
These can be set using the Joint methods set_position_limits(),
set_velocity_limits() and set_acceleration_limits() in radians,
radians/s, radians/s² units. The first three arguments to this
constructor are those of the Joint class constructor. See the Joint
class’s documentation for details. The additional parameters are:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">screw_pitch</span></code>:</dt>
<dd>Amount of translation in meters occurring over a one full screw
revolution. It’s domain is (-∞, ∞). When the screw pitch is
negative, positive rotation will result in translating towards the
negative direction of z-axis. When the screw pitch is zero, this
joint will behave like a revolute joint.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, N⋅m⋅s/rad for rotation, used to model
losses within the joint. See documentation of damping() for
details on modelling of the damping torque.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if damping is negative.</td>
</tr>
</tbody>
</table>
<p>The defaults values for screw_pitch and damping are deprecated and will removed on 2023-02-01.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.ScrewJoint_[Expression], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[Expression], frame_on_child: pydrake.multibody.tree.Frame_[Expression], axis: numpy.ndarray[numpy.float64[3, 1]], screw_pitch: float, damping: float) -&gt; None</li>
</ol>
<p>Constructor to create a screw joint between two bodies so that frame F
attached to the parent body P and frame M attached to the child body B
translate and rotate as described in the class’s documentation. This
constructor signature creates a joint with no joint limits, i.e. the
joint angular position, angular velocity and angular acceleration
limits are the pair <code class="docutils literal notranslate"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. These can be set using the Joint
methods set_position_limits(), set_velocity_limits() and
set_acceleration_limits() in radians, radians/s, radians/s² units. The
first three arguments to this constructor are those of the Joint class
constructor. See the Joint class’s documentation for details. The
additional parameters are:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">axis</span></code>:</dt>
<dd>A vector in ℝ³ specifying the axis of motion for this joint. The
coordinates of <code class="docutils literal notranslate"><span class="pre">axis</span></code> expressed in frames F and M are the same
at all times, that is, <code class="docutils literal notranslate"><span class="pre">axis_F</span> <span class="pre">=</span> <span class="pre">axis_M</span></code>. In other words,
<code class="docutils literal notranslate"><span class="pre">axis_F</span></code> (or <code class="docutils literal notranslate"><span class="pre">axis_M</span></code>) is the eigenvector of <code class="docutils literal notranslate"><span class="pre">R_FM</span></code> with
eigenvalue equal to one. This vector can have any length, only the
direction is used.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">screw_pitch</span></code>:</dt>
<dd>Amount of translation in meters occurring over a one full screw
revolution. It’s domain is (-∞, ∞). When the screw pitch is
negative, positive rotation will result in translating towards the
negative direction of â-axis. When the screw pitch is zero, this
joint will behave like a revolute joint.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, N⋅m⋅s/rad for rotation, used to model
losses within the joint. See documentation of damping() for
details on modelling of the damping torque.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the L2 norm of <code class="docutils literal notranslate"><span class="pre">axis</span></code> is less than the square</li>
<li>root of machine epsilon.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">RuntimeError if damping is negative.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[Expression].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[Expression].damping" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s damping constant N⋅m⋅s for the rotational
degree. The damping torque (in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span> <span class="pre">-damping⋅ω</span></code>
i.e. opposing motion, with ω the angular rate for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see
get_angular_velocity()) and τ the torque on child body B expressed in
frame F as t_B_F = τ⋅Fâ_F.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[Expression].get_angular_velocity">
<code class="descname">get_angular_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[Expression].get_angular_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rate of change, in radians per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
angle θ from <code class="docutils literal notranslate"><span class="pre">context</span></code>. See class documentation for the definition
of this angle.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>:</dt>
<dd>The rate of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s angle θ as stored in the
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[Expression].get_default_rotation">
<code class="descname">get_default_rotation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[Expression].get_default_rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default angle for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt>
<dd>The default angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[Expression].get_default_translation">
<code class="descname">get_default_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[Expression].get_default_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default position for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">z</span></code>:</dt>
<dd>The default position of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[Expression].get_rotation">
<code class="descname">get_rotation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[Expression].get_rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the angle θ of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt>
<dd>The angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code>. See class
documentation for details.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[Expression].get_translation">
<code class="descname">get_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[Expression].get_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the translation of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">z</span></code>:</dt>
<dd>The translation of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code> as
(z). See class documentation for details.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[Expression].get_translational_velocity">
<code class="descname">get_translational_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[Expression].get_translational_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the translational velocity vz, in meters per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code>
joint’s Mo measured and expressed in frame F from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">vz</span></code>:</dt>
<dd>The translational velocity of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint as stored in the
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[Expression].screw_pitch">
<code class="descname">screw_pitch</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[Expression].screw_pitch" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s amount of translation in meters occurring
over a one full revolution.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[Expression].set_angular_velocity">
<code class="descname">set_angular_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[Expression], context: pydrake.systems.framework.Context_[Expression], theta_dot: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ScrewJoint_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[Expression].set_angular_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the rate of change, in radians per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
angle θ (see class documentation) to <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>. The new rate of
change gets stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>:</dt>
<dd>The desired rates of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s angle in radians
per second.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[Expression].set_default_rotation">
<code class="descname">set_default_rotation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[Expression], theta: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[Expression].set_default_rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default angle of this joint. This will change the
<code class="docutils literal notranslate"><span class="pre">default_translation</span></code> too, because they are not independent in this
joint.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt>
<dd>The desired default angle of the joint</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[Expression].set_default_translation">
<code class="descname">set_default_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[Expression], z: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[Expression].set_default_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default translation of this joint. This will change the
<code class="docutils literal notranslate"><span class="pre">default_rotation</span></code> too, which are not independent in this joint.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">z</span></code>:</dt>
<dd>The desired default translation of the joint</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if pitch is very near zero.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[Expression].set_random_pose_distribution">
<code class="descname">set_random_pose_distribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[Expression], theta: numpy.ndarray[object[1, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[Expression].set_random_pose_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the random distribution that the angle of this joint will be
randomly sampled from. See class documentation for details on the
definition of the position and angle.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[Expression].set_translation">
<code class="descname">set_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[Expression], context: pydrake.systems.framework.Context_[Expression], translation: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ScrewJoint_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[Expression].set_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the translation of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals
to (z).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">z</span></code>:</dt>
<dd>The desired translation in meters to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> as
(z). See class documentation for details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[Expression].set_translational_velocity">
<code class="descname">set_translational_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[Expression], context: pydrake.systems.framework.Context_[Expression], translation_dot: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ScrewJoint_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[Expression].set_translational_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the translational velocity, in meters per second, of this
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s Mo along frame F’s â-axis to <code class="docutils literal notranslate"><span class="pre">vz</span></code>. The new
translational velocity gets stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">vz</span></code>:</dt>
<dd>The desired translational velocity of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters per
second along F frame’s â-axis.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.ScrewJoint_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">ScrewJoint_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[float]" title="pydrake.multibody.tree.Joint_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[float]</span></code></a></p>
<p>This joint models a screw joint allowing two bodies to rotate about
one axis while translating along that same axis with one degree of
freedom. That is, given a frame F attached to the parent body P and a
frame M attached to the child body B (see the Joint class’s
documentation), this joint allows frame M to translate (while
rotating) along an axis â. Axis â is constant and has the same
measures in both frames F and M, that is, <code class="docutils literal notranslate"><span class="pre">â_F</span> <span class="pre">=</span> <span class="pre">â_M</span></code>. The
rotation about the <code class="docutils literal notranslate"><span class="pre">â_F</span></code> axis and its rate specify the state of the
joint. Zero (θ) corresponds to frames F and M being coincident and
aligned. The translation distance is defined positive when child body
B translates along the direction of â, and the rotation θ is defined
to be positive according to the right-hand-rule with the thumb aligned
in the direction of the <code class="docutils literal notranslate"><span class="pre">â_F</span></code> axis.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.ScrewJoint_[float], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[float], frame_on_child: pydrake.multibody.tree.Frame_[float], screw_pitch: Optional[float] = None, damping: Optional[float] = None) -&gt; None</li>
</ol>
<p>Constructor to create a screw joint between two bodies so that frame F
attached to the parent body P and frame M attached to the child body B
translate and rotate as described in the class’s documentation. This
constructor signature creates a joint with the axis â set to the
z-axis and no joint limits, i.e. the joint angular position, angular
velocity and angular acceleration limits are the pair <code class="docutils literal notranslate"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>.
These can be set using the Joint methods set_position_limits(),
set_velocity_limits() and set_acceleration_limits() in radians,
radians/s, radians/s² units. The first three arguments to this
constructor are those of the Joint class constructor. See the Joint
class’s documentation for details. The additional parameters are:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">screw_pitch</span></code>:</dt>
<dd>Amount of translation in meters occurring over a one full screw
revolution. It’s domain is (-∞, ∞). When the screw pitch is
negative, positive rotation will result in translating towards the
negative direction of z-axis. When the screw pitch is zero, this
joint will behave like a revolute joint.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, N⋅m⋅s/rad for rotation, used to model
losses within the joint. See documentation of damping() for
details on modelling of the damping torque.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if damping is negative.</td>
</tr>
</tbody>
</table>
<p>The defaults values for screw_pitch and damping are deprecated and will removed on 2023-02-01.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.ScrewJoint_[float], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[float], frame_on_child: pydrake.multibody.tree.Frame_[float], axis: numpy.ndarray[numpy.float64[3, 1]], screw_pitch: float, damping: float) -&gt; None</li>
</ol>
<p>Constructor to create a screw joint between two bodies so that frame F
attached to the parent body P and frame M attached to the child body B
translate and rotate as described in the class’s documentation. This
constructor signature creates a joint with no joint limits, i.e. the
joint angular position, angular velocity and angular acceleration
limits are the pair <code class="docutils literal notranslate"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. These can be set using the Joint
methods set_position_limits(), set_velocity_limits() and
set_acceleration_limits() in radians, radians/s, radians/s² units. The
first three arguments to this constructor are those of the Joint class
constructor. See the Joint class’s documentation for details. The
additional parameters are:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">axis</span></code>:</dt>
<dd>A vector in ℝ³ specifying the axis of motion for this joint. The
coordinates of <code class="docutils literal notranslate"><span class="pre">axis</span></code> expressed in frames F and M are the same
at all times, that is, <code class="docutils literal notranslate"><span class="pre">axis_F</span> <span class="pre">=</span> <span class="pre">axis_M</span></code>. In other words,
<code class="docutils literal notranslate"><span class="pre">axis_F</span></code> (or <code class="docutils literal notranslate"><span class="pre">axis_M</span></code>) is the eigenvector of <code class="docutils literal notranslate"><span class="pre">R_FM</span></code> with
eigenvalue equal to one. This vector can have any length, only the
direction is used.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">screw_pitch</span></code>:</dt>
<dd>Amount of translation in meters occurring over a one full screw
revolution. It’s domain is (-∞, ∞). When the screw pitch is
negative, positive rotation will result in translating towards the
negative direction of â-axis. When the screw pitch is zero, this
joint will behave like a revolute joint.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, N⋅m⋅s/rad for rotation, used to model
losses within the joint. See documentation of damping() for
details on modelling of the damping torque.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first simple">
<li>RuntimeError if the L2 norm of <code class="docutils literal notranslate"><span class="pre">axis</span></code> is less than the square</li>
<li>root of machine epsilon.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last">RuntimeError if damping is negative.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[float].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[float].damping" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s damping constant N⋅m⋅s for the rotational
degree. The damping torque (in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τ</span> <span class="pre">=</span> <span class="pre">-damping⋅ω</span></code>
i.e. opposing motion, with ω the angular rate for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint (see
get_angular_velocity()) and τ the torque on child body B expressed in
frame F as t_B_F = τ⋅Fâ_F.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[float].get_angular_velocity">
<code class="descname">get_angular_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[float].get_angular_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rate of change, in radians per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
angle θ from <code class="docutils literal notranslate"><span class="pre">context</span></code>. See class documentation for the definition
of this angle.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>:</dt>
<dd>The rate of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s angle θ as stored in the
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[float].get_default_rotation">
<code class="descname">get_default_rotation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[float].get_default_rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default angle for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt>
<dd>The default angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[float].get_default_translation">
<code class="descname">get_default_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[float].get_default_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default position for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</p>
<dl class="docutils">
<dt>Returns <code class="docutils literal notranslate"><span class="pre">z</span></code>:</dt>
<dd>The default position of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[float].get_rotation">
<code class="descname">get_rotation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[float].get_rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the angle θ of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt>
<dd>The angle of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code>. See class
documentation for details.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[float].get_translation">
<code class="descname">get_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[float].get_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the translation of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">z</span></code>:</dt>
<dd>The translation of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code> as
(z). See class documentation for details.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[float].get_translational_velocity">
<code class="descname">get_translational_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[float].get_translational_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the translational velocity vz, in meters per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code>
joint’s Mo measured and expressed in frame F from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">vz</span></code>:</dt>
<dd>The translational velocity of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint as stored in the
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[float].screw_pitch">
<code class="descname">screw_pitch</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[float].screw_pitch" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s amount of translation in meters occurring
over a one full revolution.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[float].set_angular_velocity">
<code class="descname">set_angular_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[float], context: pydrake.systems.framework.Context_[float], theta_dot: float</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ScrewJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[float].set_angular_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the rate of change, in radians per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
angle θ (see class documentation) to <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>. The new rate of
change gets stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>:</dt>
<dd>The desired rates of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s angle in radians
per second.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[float].set_default_rotation">
<code class="descname">set_default_rotation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[float], theta: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[float].set_default_rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default angle of this joint. This will change the
<code class="docutils literal notranslate"><span class="pre">default_translation</span></code> too, because they are not independent in this
joint.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta</span></code>:</dt>
<dd>The desired default angle of the joint</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[float].set_default_translation">
<code class="descname">set_default_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[float], z: float</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[float].set_default_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default translation of this joint. This will change the
<code class="docutils literal notranslate"><span class="pre">default_rotation</span></code> too, which are not independent in this joint.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">z</span></code>:</dt>
<dd>The desired default translation of the joint</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if pitch is very near zero.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[float].set_random_pose_distribution">
<code class="descname">set_random_pose_distribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[float], theta: numpy.ndarray[object[1, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[float].set_random_pose_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the random distribution that the angle of this joint will be
randomly sampled from. See class documentation for details on the
definition of the position and angle.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[float].set_translation">
<code class="descname">set_translation</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[float], context: pydrake.systems.framework.Context_[float], translation: float</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ScrewJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[float].set_translation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the translation of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals
to (z).</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">z</span></code>:</dt>
<dd>The desired translation in meters to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> as
(z). See class documentation for details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.ScrewJoint_[float].set_translational_velocity">
<code class="descname">set_translational_velocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.ScrewJoint_[float], context: pydrake.systems.framework.Context_[float], translation_dot: float</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ScrewJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.ScrewJoint_[float].set_translational_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the translational velocity, in meters per second, of this
<code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s Mo along frame F’s â-axis to <code class="docutils literal notranslate"><span class="pre">vz</span></code>. The new
translational velocity gets stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">vz</span></code>:</dt>
<dd>The desired translational velocity of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint in meters per
second along F frame’s â-axis.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.SpatialInertia">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">SpatialInertia</code><a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.SpatialInertia_[float]" title="pydrake.multibody.tree.SpatialInertia_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.SpatialInertia_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.SpatialInertia_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">SpatialInertia_</code><a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.SpatialInertia_[float]" title="pydrake.multibody.tree.SpatialInertia_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialInertia_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]" title="pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialInertia_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.SpatialInertia_[Expression]" title="pydrake.multibody.tree.SpatialInertia_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialInertia_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float]">
<em class="property">class </em><code class="descname">SpatialInertia_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents the physical concept of a <em>Spatial Inertia</em>. A
spatial inertia (or spatial mass matrix) encapsulates the mass, center
of mass, and rotational inertia of the mass distribution of a body or
composite body S, where with “composite body” we mean a collection of
bodies welded together containing at least one body (throughout this
documentation “body” is many times used instead of “composite body”
but the same concepts apply to a collection of bodies as well.) A
spatial inertia is an element of ℝ⁶ˣ⁶ that is symmetric, and positive
semi-definite. It logically consists of <code class="docutils literal notranslate"><span class="pre">3x3</span></code> sub-matrices arranged
like so, [Jain 2010]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Spatial mass matrix
          ------------ ------------
       0 |            |            |
       1 |    I_SP    | m p_PScm×  |
       2 |            |            |
          ------------ ------------
       3 |            |            |
       4 | -m p_PScm× |     m Id   |
       5 |            |            |
          ------------ ------------
               Symbol: M
</pre></div>
</div>
<p>where, with the monogram notation described in
multibody_spatial_inertia, <code class="docutils literal notranslate"><span class="pre">I_SP</span></code> is the rotational inertia of body
or composite body S computed about a point P, m is the mass of this
composite body, <code class="docutils literal notranslate"><span class="pre">p_PScm</span></code> is the position vector from point P to the
center of mass <code class="docutils literal notranslate"><span class="pre">Scm</span></code> of the composite body S with <code class="docutils literal notranslate"><span class="pre">p_PScm×</span></code>
denoting its skew-symmetric cross product matrix (defined such that
<code class="docutils literal notranslate"><span class="pre">a×</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">a.cross(b)</span></code>), and <code class="docutils literal notranslate"><span class="pre">Id</span></code> is the identity matrix in ℝ³ˣ³. See
Section 2.1, p. 17 of [Jain 2010]. The logical arrangement as shown
above is chosen to be consistent with our logical arrangement for
spatial vectors as documented in multibody_spatial_algebra for which
the rotational component comes first followed by the translational
component.</p>
<p>In typeset material we use the symbol <span class="math notranslate nohighlight">\([M^{S/P}]_E\)</span> to represent
the spatial inertia of a body or composite body S about point P,
expressed in frame E. For this inertia, the monogram notation reads
<code class="docutils literal notranslate"><span class="pre">M_SP_E</span></code>. If the point P is fixed to a body B, we write that point
as <span class="math notranslate nohighlight">\(B_P\)</span> which appears in code and comments as <code class="docutils literal notranslate"><span class="pre">Bp</span></code>. So if the
body or composite body is B and the about point is <code class="docutils literal notranslate"><span class="pre">Bp</span></code>, the
monogram notation reads <code class="docutils literal notranslate"><span class="pre">M_BBp_E</span></code>, which can be abbreviated to
<code class="docutils literal notranslate"><span class="pre">M_Bp_E</span></code> since the about point <code class="docutils literal notranslate"><span class="pre">Bp</span></code> also identifies the body.
Common cases are that the about point is the origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code> of the
body, or it’s the center of mass <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> for which the rotational
inertia in monogram notation would read as <code class="docutils literal notranslate"><span class="pre">I_Bo_E</span></code> and <code class="docutils literal notranslate"><span class="pre">I_Bcm_E</span></code>,
respectively. Given <code class="docutils literal notranslate"><span class="pre">M_BP_E</span></code> (<span class="math notranslate nohighlight">\([M^{B/P}]_E\)</span>), the rotational
inertia of this spatial inertia is <code class="docutils literal notranslate"><span class="pre">I_BP_E</span></code> (<span class="math notranslate nohighlight">\([I^{B/P}]_E\)</span>)
and the position vector of the center of mass measured from point P
and expressed in E is <code class="docutils literal notranslate"><span class="pre">p_PBcm_E</span></code> (<span class="math notranslate nohighlight">\([^Pp^{B_{cm}}]_E\)</span>).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class does not implement any mechanism to track the frame E
in which a spatial inertia is expressed or about what point is
computed. Methods and operators on this class have no means to
determine frame consistency through operations. It is therefore
the responsibility of users of this class to keep track of frames
in which operations are performed. We suggest doing that using
disciplined notation, as described above.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Several methods in this class throw a RuntimeError for invalid
rotational inertia operations in debug releases only. This
provides speed in a release build while facilitating debugging in
debug builds. In addition, these validity tests are only performed
for scalar types for which drake::scalar_predicate&lt;T&gt;::is_bool is
<code class="docutils literal notranslate"><span class="pre">True</span></code>. For instance, validity checks are not performed when T
is symbolic::Expression.</p>
</div>
<ul class="simple">
<li><dl class="first docutils">
<dt>[Jain 2010]  Jain, A., 2010. Robot and multibody dynamics: analysis and</dt>
<dd>algorithms. Springer Science &amp; Business Media.</dd>
</dl>
</li>
</ul>
<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.SpatialInertia_[float]) -&gt; None</li>
</ol>
<p>Default SpatialInertia constructor initializes mass, center of mass
and rotational inertia to invalid NaN’s for a quick detection of
uninitialized values.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.SpatialInertia_[float], mass: float, p_PScm_E: numpy.ndarray[numpy.float64[3, 1]], G_SP_E: pydrake.multibody.tree.UnitInertia_[float], skip_validity_check: bool = False) -&gt; None</li>
</ol>
<p>Constructs a spatial inertia for a physical body or composite body S
about a point P from a given mass, center of mass and rotational
inertia. The center of mass is specified by the position vector
<code class="docutils literal notranslate"><span class="pre">p_PScm_E</span></code> from point P to the center of mass point <code class="docutils literal notranslate"><span class="pre">Scm</span></code>,
expressed in a frame E. The rotational inertia is provided as the
UnitInertia <code class="docutils literal notranslate"><span class="pre">G_SP_E</span></code> of the body or composite body S computed about
point P and expressed in frame E.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The third argument of this constructor is unusual in that it is an
UnitInertia (not a traditional RotationalInertia) and its inertia
is about the arbitrary point P (not Scm – S’s center of mass).</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">MakeFromCentralInertia a factory method with traditional utility.</p>
</div>
<p>This constructor checks for the physical validity of the resulting
SpatialInertia with IsPhysicallyValid() and throws a RuntimeError
exception in the event the provided input parameters lead to
non-physically viable spatial inertia. Since this check has
non-negligable runtime costs, it can be disabled by setting the
optional argument <code class="docutils literal notranslate"><span class="pre">skip_validity_check</span></code> to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt>
<dd>The mass of the body or composite body S.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PScm_E</span></code>:</dt>
<dd>The position vector from point P to the center of mass of body or
composite body S expressed in frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">G_SP_E</span></code>:</dt>
<dd>UnitInertia of the body or composite body S computed about origin
point P and expressed in frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">skip_validity_check</span></code>:</dt>
<dd>If true, skips the validity check described above. Defaults to
false.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].CalcComMoment">
<code class="descname">CalcComMoment</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].CalcComMoment" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the center of mass moment vector <code class="docutils literal notranslate"><span class="pre">mass</span> <span class="pre">*</span> <span class="pre">p_PScm_E</span></code> given
the position vector <code class="docutils literal notranslate"><span class="pre">p_PScm_E</span></code> from the <em>about point</em> P to the
center of mass <code class="docutils literal notranslate"><span class="pre">Scm</span></code> of the body or composite body S, expressed in
frame E. See the documentation of this class for details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].CalcRotationalInertia">
<code class="descname">CalcRotationalInertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RotationalInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].CalcRotationalInertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the rotational inertia <code class="docutils literal notranslate"><span class="pre">I_SP_E</span> <span class="pre">=</span> <span class="pre">mass</span> <span class="pre">*</span> <span class="pre">G_SP_E</span></code> of this
spatial inertia, computed about point P and expressed in frame E. See
the documentation of this class for details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].CopyToFullMatrix6">
<code class="descname">CopyToFullMatrix6</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[6, 6]]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].CopyToFullMatrix6" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy to a full 6x6 matrix representation.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].get_com">
<code class="descname">get_com</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].get_com" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a constant reference to the position vector <code class="docutils literal notranslate"><span class="pre">p_PScm_E</span></code> from the
<em>about point</em> P to the center of mass <code class="docutils literal notranslate"><span class="pre">Scm</span></code> of the body or composite
body S, expressed in frame E. See the documentation of this class for
details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].get_mass">
<code class="descname">get_mass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].get_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a constant reference to the mass of this spatial inertia.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].get_unit_inertia">
<code class="descname">get_unit_inertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].get_unit_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a constant reference to the unit inertia <code class="docutils literal notranslate"><span class="pre">G_SP_E</span></code> of this
spatial inertia, computed about point P and expressed in frame E. See
the documentation of this class for details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].IsNaN">
<code class="descname">IsNaN</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].IsNaN" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if any of the elements in this spatial inertia is NaN
and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].IsPhysicallyValid">
<code class="descname">IsPhysicallyValid</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].IsPhysicallyValid" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a number of checks to verify that this is a physically valid
spatial inertia. The checks performed are:</p>
<ul class="simple">
<li>No NaN entries.</li>
<li>Non-negative mass.</li>
<li>Non-negative principal moments about the center of mass.</li>
<li>Principal moments about the center of mass must satisfy the triangle
inequality:
- <code class="docutils literal notranslate"><span class="pre">Ixx</span> <span class="pre">+</span> <span class="pre">Iyy</span> <span class="pre">&gt;=</span> <span class="pre">Izz</span></code>
- <cite>Ixx + Izz &gt;= Iyy</cite>
- <code class="docutils literal notranslate"><span class="pre">Iyy</span> <span class="pre">+</span> <span class="pre">Izz</span> <span class="pre">&gt;=</span> <span class="pre">Ixx</span></code></li>
</ul>
<p>These are the tests performed by
RotationalInertia::CouldBePhysicallyValid() which become a sufficient
condition when performed on a rotational inertia about a body’s center
of mass.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RotationalInertia::CouldBePhysicallyValid().</p>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].MakeFromCentralInertia">
<em class="property">static </em><code class="descname">MakeFromCentralInertia</code><span class="sig-paren">(</span><em>mass: float, p_PScm_E: numpy.ndarray[numpy.float64[3, 1]], I_SScm_E: pydrake.multibody.tree.RotationalInertia_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.SpatialInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].MakeFromCentralInertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a spatial inertia for a physical body or composite body S
about a point P from a given mass, center of mass, and central
rotational inertia. For example, this method creates a body’s
SpatialInertia about its body origin Bo from the body’s mass, position
vector from Bo to the body’s center of mass, and rotational inertia
about the body’s center of mass.</p>
<p>This method checks for the physical validity of the resulting
SpatialInertia with IsPhysicallyValid() and throws a RuntimeError
exception in the event the provided input parameters lead to a
non-physically viable spatial inertia.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt>
<dd>The mass of the body or composite body S.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PScm_E</span></code>:</dt>
<dd>The position vector from point P to point <code class="docutils literal notranslate"><span class="pre">Scm</span></code> (S’s center of
mass), expressed in a frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">I_SScm_E</span></code>:</dt>
<dd>S’s RotationalInertia about Scm, expressed in frame E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_SP_E</span></code>:</dt>
<dd>S’s spatial inertia about point P, expressed in frame E.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].ReExpress">
<code class="descname">ReExpress</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float], R_AE: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.SpatialInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].ReExpress" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial inertia <code class="docutils literal notranslate"><span class="pre">M_SP_E</span></code> for some body or composite
body S, taken about a point P and expressed in frame E, this method
computes the same inertia re-expressed in another frame A.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_AE</span></code>:</dt>
<dd>RotationMatrix relating frames A and E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_SP_A</span></code>:</dt>
<dd>The same spatial inertia of S about P but now re-expressed in
frame A.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ReExpressInPlace() for details.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].SetNaN">
<code class="descname">SetNaN</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].SetNaN" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial inertia to have NaN entries. Typically used for
quick detection of uninitialized values.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float], p_PQ_E: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.SpatialInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_.SpatialInertia_[float].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial inertia <code class="docutils literal notranslate"><span class="pre">M_SP_E</span></code> for some body or composite
body S, computed about point P, and expressed in frame E, this method
uses the <em>Parallel Axis Theorem</em> for spatial inertias to compute the
same spatial inertia about a new point Q. The result still is
expressed in frame E.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() for more details.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PQ_E</span></code>:</dt>
<dd>Vector from the original about point P to the new about point Q,
expressed in the same frame E <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial inertia is
expressed in.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_SQ_E</span></code>:</dt>
<dd>This same spatial inertia for body or composite body S but
computed about a new point Q.</dd>
</dl>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">SpatialInertia_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents the physical concept of a <em>Spatial Inertia</em>. A
spatial inertia (or spatial mass matrix) encapsulates the mass, center
of mass, and rotational inertia of the mass distribution of a body or
composite body S, where with “composite body” we mean a collection of
bodies welded together containing at least one body (throughout this
documentation “body” is many times used instead of “composite body”
but the same concepts apply to a collection of bodies as well.) A
spatial inertia is an element of ℝ⁶ˣ⁶ that is symmetric, and positive
semi-definite. It logically consists of <code class="docutils literal notranslate"><span class="pre">3x3</span></code> sub-matrices arranged
like so, [Jain 2010]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Spatial mass matrix
          ------------ ------------
       0 |            |            |
       1 |    I_SP    | m p_PScm×  |
       2 |            |            |
          ------------ ------------
       3 |            |            |
       4 | -m p_PScm× |     m Id   |
       5 |            |            |
          ------------ ------------
               Symbol: M
</pre></div>
</div>
<p>where, with the monogram notation described in
multibody_spatial_inertia, <code class="docutils literal notranslate"><span class="pre">I_SP</span></code> is the rotational inertia of body
or composite body S computed about a point P, m is the mass of this
composite body, <code class="docutils literal notranslate"><span class="pre">p_PScm</span></code> is the position vector from point P to the
center of mass <code class="docutils literal notranslate"><span class="pre">Scm</span></code> of the composite body S with <code class="docutils literal notranslate"><span class="pre">p_PScm×</span></code>
denoting its skew-symmetric cross product matrix (defined such that
<code class="docutils literal notranslate"><span class="pre">a×</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">a.cross(b)</span></code>), and <code class="docutils literal notranslate"><span class="pre">Id</span></code> is the identity matrix in ℝ³ˣ³. See
Section 2.1, p. 17 of [Jain 2010]. The logical arrangement as shown
above is chosen to be consistent with our logical arrangement for
spatial vectors as documented in multibody_spatial_algebra for which
the rotational component comes first followed by the translational
component.</p>
<p>In typeset material we use the symbol <span class="math notranslate nohighlight">\([M^{S/P}]_E\)</span> to represent
the spatial inertia of a body or composite body S about point P,
expressed in frame E. For this inertia, the monogram notation reads
<code class="docutils literal notranslate"><span class="pre">M_SP_E</span></code>. If the point P is fixed to a body B, we write that point
as <span class="math notranslate nohighlight">\(B_P\)</span> which appears in code and comments as <code class="docutils literal notranslate"><span class="pre">Bp</span></code>. So if the
body or composite body is B and the about point is <code class="docutils literal notranslate"><span class="pre">Bp</span></code>, the
monogram notation reads <code class="docutils literal notranslate"><span class="pre">M_BBp_E</span></code>, which can be abbreviated to
<code class="docutils literal notranslate"><span class="pre">M_Bp_E</span></code> since the about point <code class="docutils literal notranslate"><span class="pre">Bp</span></code> also identifies the body.
Common cases are that the about point is the origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code> of the
body, or it’s the center of mass <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> for which the rotational
inertia in monogram notation would read as <code class="docutils literal notranslate"><span class="pre">I_Bo_E</span></code> and <code class="docutils literal notranslate"><span class="pre">I_Bcm_E</span></code>,
respectively. Given <code class="docutils literal notranslate"><span class="pre">M_BP_E</span></code> (<span class="math notranslate nohighlight">\([M^{B/P}]_E\)</span>), the rotational
inertia of this spatial inertia is <code class="docutils literal notranslate"><span class="pre">I_BP_E</span></code> (<span class="math notranslate nohighlight">\([I^{B/P}]_E\)</span>)
and the position vector of the center of mass measured from point P
and expressed in E is <code class="docutils literal notranslate"><span class="pre">p_PBcm_E</span></code> (<span class="math notranslate nohighlight">\([^Pp^{B_{cm}}]_E\)</span>).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class does not implement any mechanism to track the frame E
in which a spatial inertia is expressed or about what point is
computed. Methods and operators on this class have no means to
determine frame consistency through operations. It is therefore
the responsibility of users of this class to keep track of frames
in which operations are performed. We suggest doing that using
disciplined notation, as described above.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Several methods in this class throw a RuntimeError for invalid
rotational inertia operations in debug releases only. This
provides speed in a release build while facilitating debugging in
debug builds. In addition, these validity tests are only performed
for scalar types for which drake::scalar_predicate&lt;T&gt;::is_bool is
<code class="docutils literal notranslate"><span class="pre">True</span></code>. For instance, validity checks are not performed when T
is symbolic::Expression.</p>
</div>
<ul class="simple">
<li><dl class="first docutils">
<dt>[Jain 2010]  Jain, A., 2010. Robot and multibody dynamics: analysis and</dt>
<dd>algorithms. Springer Science &amp; Business Media.</dd>
</dl>
</li>
</ul>
<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]) -&gt; None</li>
</ol>
<p>Default SpatialInertia constructor initializes mass, center of mass
and rotational inertia to invalid NaN’s for a quick detection of
uninitialized values.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.SpatialInertia_[AutoDiffXd], mass: pydrake.autodiffutils.AutoDiffXd, p_PScm_E: numpy.ndarray[object[3, 1]], G_SP_E: pydrake.multibody.tree.UnitInertia_[AutoDiffXd], skip_validity_check: bool = False) -&gt; None</li>
</ol>
<p>Constructs a spatial inertia for a physical body or composite body S
about a point P from a given mass, center of mass and rotational
inertia. The center of mass is specified by the position vector
<code class="docutils literal notranslate"><span class="pre">p_PScm_E</span></code> from point P to the center of mass point <code class="docutils literal notranslate"><span class="pre">Scm</span></code>,
expressed in a frame E. The rotational inertia is provided as the
UnitInertia <code class="docutils literal notranslate"><span class="pre">G_SP_E</span></code> of the body or composite body S computed about
point P and expressed in frame E.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The third argument of this constructor is unusual in that it is an
UnitInertia (not a traditional RotationalInertia) and its inertia
is about the arbitrary point P (not Scm – S’s center of mass).</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">MakeFromCentralInertia a factory method with traditional utility.</p>
</div>
<p>This constructor checks for the physical validity of the resulting
SpatialInertia with IsPhysicallyValid() and throws a RuntimeError
exception in the event the provided input parameters lead to
non-physically viable spatial inertia. Since this check has
non-negligable runtime costs, it can be disabled by setting the
optional argument <code class="docutils literal notranslate"><span class="pre">skip_validity_check</span></code> to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt>
<dd>The mass of the body or composite body S.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PScm_E</span></code>:</dt>
<dd>The position vector from point P to the center of mass of body or
composite body S expressed in frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">G_SP_E</span></code>:</dt>
<dd>UnitInertia of the body or composite body S computed about origin
point P and expressed in frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">skip_validity_check</span></code>:</dt>
<dd>If true, skips the validity check described above. Defaults to
false.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].CalcComMoment">
<code class="descname">CalcComMoment</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].CalcComMoment" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the center of mass moment vector <code class="docutils literal notranslate"><span class="pre">mass</span> <span class="pre">*</span> <span class="pre">p_PScm_E</span></code> given
the position vector <code class="docutils literal notranslate"><span class="pre">p_PScm_E</span></code> from the <em>about point</em> P to the
center of mass <code class="docutils literal notranslate"><span class="pre">Scm</span></code> of the body or composite body S, expressed in
frame E. See the documentation of this class for details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].CalcRotationalInertia">
<code class="descname">CalcRotationalInertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].CalcRotationalInertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the rotational inertia <code class="docutils literal notranslate"><span class="pre">I_SP_E</span> <span class="pre">=</span> <span class="pre">mass</span> <span class="pre">*</span> <span class="pre">G_SP_E</span></code> of this
spatial inertia, computed about point P and expressed in frame E. See
the documentation of this class for details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].CopyToFullMatrix6">
<code class="descname">CopyToFullMatrix6</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[6, 6]]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].CopyToFullMatrix6" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy to a full 6x6 matrix representation.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].get_com">
<code class="descname">get_com</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].get_com" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a constant reference to the position vector <code class="docutils literal notranslate"><span class="pre">p_PScm_E</span></code> from the
<em>about point</em> P to the center of mass <code class="docutils literal notranslate"><span class="pre">Scm</span></code> of the body or composite
body S, expressed in frame E. See the documentation of this class for
details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].get_mass">
<code class="descname">get_mass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.autodiffutils.AutoDiffXd<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].get_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a constant reference to the mass of this spatial inertia.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].get_unit_inertia">
<code class="descname">get_unit_inertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].get_unit_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a constant reference to the unit inertia <code class="docutils literal notranslate"><span class="pre">G_SP_E</span></code> of this
spatial inertia, computed about point P and expressed in frame E. See
the documentation of this class for details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].IsNaN">
<code class="descname">IsNaN</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].IsNaN" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if any of the elements in this spatial inertia is NaN
and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].IsPhysicallyValid">
<code class="descname">IsPhysicallyValid</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].IsPhysicallyValid" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a number of checks to verify that this is a physically valid
spatial inertia. The checks performed are:</p>
<ul class="simple">
<li>No NaN entries.</li>
<li>Non-negative mass.</li>
<li>Non-negative principal moments about the center of mass.</li>
<li>Principal moments about the center of mass must satisfy the triangle
inequality:
- <code class="docutils literal notranslate"><span class="pre">Ixx</span> <span class="pre">+</span> <span class="pre">Iyy</span> <span class="pre">&gt;=</span> <span class="pre">Izz</span></code>
- <cite>Ixx + Izz &gt;= Iyy</cite>
- <code class="docutils literal notranslate"><span class="pre">Iyy</span> <span class="pre">+</span> <span class="pre">Izz</span> <span class="pre">&gt;=</span> <span class="pre">Ixx</span></code></li>
</ul>
<p>These are the tests performed by
RotationalInertia::CouldBePhysicallyValid() which become a sufficient
condition when performed on a rotational inertia about a body’s center
of mass.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RotationalInertia::CouldBePhysicallyValid().</p>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].MakeFromCentralInertia">
<em class="property">static </em><code class="descname">MakeFromCentralInertia</code><span class="sig-paren">(</span><em>mass: pydrake.autodiffutils.AutoDiffXd, p_PScm_E: numpy.ndarray[object[3, 1]], I_SScm_E: pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].MakeFromCentralInertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a spatial inertia for a physical body or composite body S
about a point P from a given mass, center of mass, and central
rotational inertia. For example, this method creates a body’s
SpatialInertia about its body origin Bo from the body’s mass, position
vector from Bo to the body’s center of mass, and rotational inertia
about the body’s center of mass.</p>
<p>This method checks for the physical validity of the resulting
SpatialInertia with IsPhysicallyValid() and throws a RuntimeError
exception in the event the provided input parameters lead to a
non-physically viable spatial inertia.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt>
<dd>The mass of the body or composite body S.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PScm_E</span></code>:</dt>
<dd>The position vector from point P to point <code class="docutils literal notranslate"><span class="pre">Scm</span></code> (S’s center of
mass), expressed in a frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">I_SScm_E</span></code>:</dt>
<dd>S’s RotationalInertia about Scm, expressed in frame E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_SP_E</span></code>:</dt>
<dd>S’s spatial inertia about point P, expressed in frame E.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].ReExpress">
<code class="descname">ReExpress</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[AutoDiffXd], R_AE: pydrake.math.RotationMatrix_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].ReExpress" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial inertia <code class="docutils literal notranslate"><span class="pre">M_SP_E</span></code> for some body or composite
body S, taken about a point P and expressed in frame E, this method
computes the same inertia re-expressed in another frame A.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_AE</span></code>:</dt>
<dd>RotationMatrix relating frames A and E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_SP_A</span></code>:</dt>
<dd>The same spatial inertia of S about P but now re-expressed in
frame A.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ReExpressInPlace() for details.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].SetNaN">
<code class="descname">SetNaN</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].SetNaN" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial inertia to have NaN entries. Typically used for
quick detection of uninitialized values.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[AutoDiffXd], p_PQ_E: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.SpatialInertia_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[AutoDiffXd].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial inertia <code class="docutils literal notranslate"><span class="pre">M_SP_E</span></code> for some body or composite
body S, computed about point P, and expressed in frame E, this method
uses the <em>Parallel Axis Theorem</em> for spatial inertias to compute the
same spatial inertia about a new point Q. The result still is
expressed in frame E.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() for more details.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PQ_E</span></code>:</dt>
<dd>Vector from the original about point P to the new about point Q,
expressed in the same frame E <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial inertia is
expressed in.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_SQ_E</span></code>:</dt>
<dd>This same spatial inertia for body or composite body S but
computed about a new point Q.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.SpatialInertia_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">SpatialInertia_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents the physical concept of a <em>Spatial Inertia</em>. A
spatial inertia (or spatial mass matrix) encapsulates the mass, center
of mass, and rotational inertia of the mass distribution of a body or
composite body S, where with “composite body” we mean a collection of
bodies welded together containing at least one body (throughout this
documentation “body” is many times used instead of “composite body”
but the same concepts apply to a collection of bodies as well.) A
spatial inertia is an element of ℝ⁶ˣ⁶ that is symmetric, and positive
semi-definite. It logically consists of <code class="docutils literal notranslate"><span class="pre">3x3</span></code> sub-matrices arranged
like so, [Jain 2010]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Spatial mass matrix
          ------------ ------------
       0 |            |            |
       1 |    I_SP    | m p_PScm×  |
       2 |            |            |
          ------------ ------------
       3 |            |            |
       4 | -m p_PScm× |     m Id   |
       5 |            |            |
          ------------ ------------
               Symbol: M
</pre></div>
</div>
<p>where, with the monogram notation described in
multibody_spatial_inertia, <code class="docutils literal notranslate"><span class="pre">I_SP</span></code> is the rotational inertia of body
or composite body S computed about a point P, m is the mass of this
composite body, <code class="docutils literal notranslate"><span class="pre">p_PScm</span></code> is the position vector from point P to the
center of mass <code class="docutils literal notranslate"><span class="pre">Scm</span></code> of the composite body S with <code class="docutils literal notranslate"><span class="pre">p_PScm×</span></code>
denoting its skew-symmetric cross product matrix (defined such that
<code class="docutils literal notranslate"><span class="pre">a×</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">a.cross(b)</span></code>), and <code class="docutils literal notranslate"><span class="pre">Id</span></code> is the identity matrix in ℝ³ˣ³. See
Section 2.1, p. 17 of [Jain 2010]. The logical arrangement as shown
above is chosen to be consistent with our logical arrangement for
spatial vectors as documented in multibody_spatial_algebra for which
the rotational component comes first followed by the translational
component.</p>
<p>In typeset material we use the symbol <span class="math notranslate nohighlight">\([M^{S/P}]_E\)</span> to represent
the spatial inertia of a body or composite body S about point P,
expressed in frame E. For this inertia, the monogram notation reads
<code class="docutils literal notranslate"><span class="pre">M_SP_E</span></code>. If the point P is fixed to a body B, we write that point
as <span class="math notranslate nohighlight">\(B_P\)</span> which appears in code and comments as <code class="docutils literal notranslate"><span class="pre">Bp</span></code>. So if the
body or composite body is B and the about point is <code class="docutils literal notranslate"><span class="pre">Bp</span></code>, the
monogram notation reads <code class="docutils literal notranslate"><span class="pre">M_BBp_E</span></code>, which can be abbreviated to
<code class="docutils literal notranslate"><span class="pre">M_Bp_E</span></code> since the about point <code class="docutils literal notranslate"><span class="pre">Bp</span></code> also identifies the body.
Common cases are that the about point is the origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code> of the
body, or it’s the center of mass <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> for which the rotational
inertia in monogram notation would read as <code class="docutils literal notranslate"><span class="pre">I_Bo_E</span></code> and <code class="docutils literal notranslate"><span class="pre">I_Bcm_E</span></code>,
respectively. Given <code class="docutils literal notranslate"><span class="pre">M_BP_E</span></code> (<span class="math notranslate nohighlight">\([M^{B/P}]_E\)</span>), the rotational
inertia of this spatial inertia is <code class="docutils literal notranslate"><span class="pre">I_BP_E</span></code> (<span class="math notranslate nohighlight">\([I^{B/P}]_E\)</span>)
and the position vector of the center of mass measured from point P
and expressed in E is <code class="docutils literal notranslate"><span class="pre">p_PBcm_E</span></code> (<span class="math notranslate nohighlight">\([^Pp^{B_{cm}}]_E\)</span>).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class does not implement any mechanism to track the frame E
in which a spatial inertia is expressed or about what point is
computed. Methods and operators on this class have no means to
determine frame consistency through operations. It is therefore
the responsibility of users of this class to keep track of frames
in which operations are performed. We suggest doing that using
disciplined notation, as described above.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Several methods in this class throw a RuntimeError for invalid
rotational inertia operations in debug releases only. This
provides speed in a release build while facilitating debugging in
debug builds. In addition, these validity tests are only performed
for scalar types for which drake::scalar_predicate&lt;T&gt;::is_bool is
<code class="docutils literal notranslate"><span class="pre">True</span></code>. For instance, validity checks are not performed when T
is symbolic::Expression.</p>
</div>
<ul class="simple">
<li><dl class="first docutils">
<dt>[Jain 2010]  Jain, A., 2010. Robot and multibody dynamics: analysis and</dt>
<dd>algorithms. Springer Science &amp; Business Media.</dd>
</dl>
</li>
</ul>
<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.SpatialInertia_[Expression]) -&gt; None</li>
</ol>
<p>Default SpatialInertia constructor initializes mass, center of mass
and rotational inertia to invalid NaN’s for a quick detection of
uninitialized values.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.SpatialInertia_[Expression], mass: pydrake.symbolic.Expression, p_PScm_E: numpy.ndarray[object[3, 1]], G_SP_E: pydrake.multibody.tree.UnitInertia_[Expression], skip_validity_check: bool = False) -&gt; None</li>
</ol>
<p>Constructs a spatial inertia for a physical body or composite body S
about a point P from a given mass, center of mass and rotational
inertia. The center of mass is specified by the position vector
<code class="docutils literal notranslate"><span class="pre">p_PScm_E</span></code> from point P to the center of mass point <code class="docutils literal notranslate"><span class="pre">Scm</span></code>,
expressed in a frame E. The rotational inertia is provided as the
UnitInertia <code class="docutils literal notranslate"><span class="pre">G_SP_E</span></code> of the body or composite body S computed about
point P and expressed in frame E.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The third argument of this constructor is unusual in that it is an
UnitInertia (not a traditional RotationalInertia) and its inertia
is about the arbitrary point P (not Scm – S’s center of mass).</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">MakeFromCentralInertia a factory method with traditional utility.</p>
</div>
<p>This constructor checks for the physical validity of the resulting
SpatialInertia with IsPhysicallyValid() and throws a RuntimeError
exception in the event the provided input parameters lead to
non-physically viable spatial inertia. Since this check has
non-negligable runtime costs, it can be disabled by setting the
optional argument <code class="docutils literal notranslate"><span class="pre">skip_validity_check</span></code> to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt>
<dd>The mass of the body or composite body S.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PScm_E</span></code>:</dt>
<dd>The position vector from point P to the center of mass of body or
composite body S expressed in frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">G_SP_E</span></code>:</dt>
<dd>UnitInertia of the body or composite body S computed about origin
point P and expressed in frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">skip_validity_check</span></code>:</dt>
<dd>If true, skips the validity check described above. Defaults to
false.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[Expression].CalcComMoment">
<code class="descname">CalcComMoment</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[Expression].CalcComMoment" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the center of mass moment vector <code class="docutils literal notranslate"><span class="pre">mass</span> <span class="pre">*</span> <span class="pre">p_PScm_E</span></code> given
the position vector <code class="docutils literal notranslate"><span class="pre">p_PScm_E</span></code> from the <em>about point</em> P to the
center of mass <code class="docutils literal notranslate"><span class="pre">Scm</span></code> of the body or composite body S, expressed in
frame E. See the documentation of this class for details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[Expression].CalcRotationalInertia">
<code class="descname">CalcRotationalInertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RotationalInertia_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[Expression].CalcRotationalInertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the rotational inertia <code class="docutils literal notranslate"><span class="pre">I_SP_E</span> <span class="pre">=</span> <span class="pre">mass</span> <span class="pre">*</span> <span class="pre">G_SP_E</span></code> of this
spatial inertia, computed about point P and expressed in frame E. See
the documentation of this class for details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[Expression].CopyToFullMatrix6">
<code class="descname">CopyToFullMatrix6</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[6, 6]]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[Expression].CopyToFullMatrix6" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy to a full 6x6 matrix representation.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[Expression].get_com">
<code class="descname">get_com</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[Expression].get_com" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a constant reference to the position vector <code class="docutils literal notranslate"><span class="pre">p_PScm_E</span></code> from the
<em>about point</em> P to the center of mass <code class="docutils literal notranslate"><span class="pre">Scm</span></code> of the body or composite
body S, expressed in frame E. See the documentation of this class for
details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[Expression].get_mass">
<code class="descname">get_mass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[Expression].get_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a constant reference to the mass of this spatial inertia.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[Expression].get_unit_inertia">
<code class="descname">get_unit_inertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[Expression].get_unit_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a constant reference to the unit inertia <code class="docutils literal notranslate"><span class="pre">G_SP_E</span></code> of this
spatial inertia, computed about point P and expressed in frame E. See
the documentation of this class for details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[Expression].IsNaN">
<code class="descname">IsNaN</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Formula<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[Expression].IsNaN" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if any of the elements in this spatial inertia is NaN
and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[Expression].IsPhysicallyValid">
<code class="descname">IsPhysicallyValid</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Formula<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[Expression].IsPhysicallyValid" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a number of checks to verify that this is a physically valid
spatial inertia. The checks performed are:</p>
<ul class="simple">
<li>No NaN entries.</li>
<li>Non-negative mass.</li>
<li>Non-negative principal moments about the center of mass.</li>
<li>Principal moments about the center of mass must satisfy the triangle
inequality:
- <code class="docutils literal notranslate"><span class="pre">Ixx</span> <span class="pre">+</span> <span class="pre">Iyy</span> <span class="pre">&gt;=</span> <span class="pre">Izz</span></code>
- <cite>Ixx + Izz &gt;= Iyy</cite>
- <code class="docutils literal notranslate"><span class="pre">Iyy</span> <span class="pre">+</span> <span class="pre">Izz</span> <span class="pre">&gt;=</span> <span class="pre">Ixx</span></code></li>
</ul>
<p>These are the tests performed by
RotationalInertia::CouldBePhysicallyValid() which become a sufficient
condition when performed on a rotational inertia about a body’s center
of mass.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RotationalInertia::CouldBePhysicallyValid().</p>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.SpatialInertia_[Expression].MakeFromCentralInertia">
<em class="property">static </em><code class="descname">MakeFromCentralInertia</code><span class="sig-paren">(</span><em>mass: pydrake.symbolic.Expression, p_PScm_E: numpy.ndarray[object[3, 1]], I_SScm_E: pydrake.multibody.tree.RotationalInertia_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.SpatialInertia_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[Expression].MakeFromCentralInertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a spatial inertia for a physical body or composite body S
about a point P from a given mass, center of mass, and central
rotational inertia. For example, this method creates a body’s
SpatialInertia about its body origin Bo from the body’s mass, position
vector from Bo to the body’s center of mass, and rotational inertia
about the body’s center of mass.</p>
<p>This method checks for the physical validity of the resulting
SpatialInertia with IsPhysicallyValid() and throws a RuntimeError
exception in the event the provided input parameters lead to a
non-physically viable spatial inertia.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt>
<dd>The mass of the body or composite body S.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PScm_E</span></code>:</dt>
<dd>The position vector from point P to point <code class="docutils literal notranslate"><span class="pre">Scm</span></code> (S’s center of
mass), expressed in a frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">I_SScm_E</span></code>:</dt>
<dd>S’s RotationalInertia about Scm, expressed in frame E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_SP_E</span></code>:</dt>
<dd>S’s spatial inertia about point P, expressed in frame E.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[Expression].ReExpress">
<code class="descname">ReExpress</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[Expression], R_AE: pydrake.math.RotationMatrix_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.SpatialInertia_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[Expression].ReExpress" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial inertia <code class="docutils literal notranslate"><span class="pre">M_SP_E</span></code> for some body or composite
body S, taken about a point P and expressed in frame E, this method
computes the same inertia re-expressed in another frame A.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_AE</span></code>:</dt>
<dd>RotationMatrix relating frames A and E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_SP_A</span></code>:</dt>
<dd>The same spatial inertia of S about P but now re-expressed in
frame A.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ReExpressInPlace() for details.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[Expression].SetNaN">
<code class="descname">SetNaN</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[Expression]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[Expression].SetNaN" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial inertia to have NaN entries. Typically used for
quick detection of uninitialized values.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[Expression].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[Expression], p_PQ_E: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.SpatialInertia_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[Expression].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial inertia <code class="docutils literal notranslate"><span class="pre">M_SP_E</span></code> for some body or composite
body S, computed about point P, and expressed in frame E, this method
uses the <em>Parallel Axis Theorem</em> for spatial inertias to compute the
same spatial inertia about a new point Q. The result still is
expressed in frame E.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() for more details.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PQ_E</span></code>:</dt>
<dd>Vector from the original about point P to the new about point Q,
expressed in the same frame E <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial inertia is
expressed in.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_SQ_E</span></code>:</dt>
<dd>This same spatial inertia for body or composite body S but
computed about a new point Q.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.SpatialInertia_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">SpatialInertia_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class represents the physical concept of a <em>Spatial Inertia</em>. A
spatial inertia (or spatial mass matrix) encapsulates the mass, center
of mass, and rotational inertia of the mass distribution of a body or
composite body S, where with “composite body” we mean a collection of
bodies welded together containing at least one body (throughout this
documentation “body” is many times used instead of “composite body”
but the same concepts apply to a collection of bodies as well.) A
spatial inertia is an element of ℝ⁶ˣ⁶ that is symmetric, and positive
semi-definite. It logically consists of <code class="docutils literal notranslate"><span class="pre">3x3</span></code> sub-matrices arranged
like so, [Jain 2010]:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>Spatial mass matrix
          ------------ ------------
       0 |            |            |
       1 |    I_SP    | m p_PScm×  |
       2 |            |            |
          ------------ ------------
       3 |            |            |
       4 | -m p_PScm× |     m Id   |
       5 |            |            |
          ------------ ------------
               Symbol: M
</pre></div>
</div>
<p>where, with the monogram notation described in
multibody_spatial_inertia, <code class="docutils literal notranslate"><span class="pre">I_SP</span></code> is the rotational inertia of body
or composite body S computed about a point P, m is the mass of this
composite body, <code class="docutils literal notranslate"><span class="pre">p_PScm</span></code> is the position vector from point P to the
center of mass <code class="docutils literal notranslate"><span class="pre">Scm</span></code> of the composite body S with <code class="docutils literal notranslate"><span class="pre">p_PScm×</span></code>
denoting its skew-symmetric cross product matrix (defined such that
<code class="docutils literal notranslate"><span class="pre">a×</span> <span class="pre">b</span> <span class="pre">=</span> <span class="pre">a.cross(b)</span></code>), and <code class="docutils literal notranslate"><span class="pre">Id</span></code> is the identity matrix in ℝ³ˣ³. See
Section 2.1, p. 17 of [Jain 2010]. The logical arrangement as shown
above is chosen to be consistent with our logical arrangement for
spatial vectors as documented in multibody_spatial_algebra for which
the rotational component comes first followed by the translational
component.</p>
<p>In typeset material we use the symbol <span class="math notranslate nohighlight">\([M^{S/P}]_E\)</span> to represent
the spatial inertia of a body or composite body S about point P,
expressed in frame E. For this inertia, the monogram notation reads
<code class="docutils literal notranslate"><span class="pre">M_SP_E</span></code>. If the point P is fixed to a body B, we write that point
as <span class="math notranslate nohighlight">\(B_P\)</span> which appears in code and comments as <code class="docutils literal notranslate"><span class="pre">Bp</span></code>. So if the
body or composite body is B and the about point is <code class="docutils literal notranslate"><span class="pre">Bp</span></code>, the
monogram notation reads <code class="docutils literal notranslate"><span class="pre">M_BBp_E</span></code>, which can be abbreviated to
<code class="docutils literal notranslate"><span class="pre">M_Bp_E</span></code> since the about point <code class="docutils literal notranslate"><span class="pre">Bp</span></code> also identifies the body.
Common cases are that the about point is the origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code> of the
body, or it’s the center of mass <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> for which the rotational
inertia in monogram notation would read as <code class="docutils literal notranslate"><span class="pre">I_Bo_E</span></code> and <code class="docutils literal notranslate"><span class="pre">I_Bcm_E</span></code>,
respectively. Given <code class="docutils literal notranslate"><span class="pre">M_BP_E</span></code> (<span class="math notranslate nohighlight">\([M^{B/P}]_E\)</span>), the rotational
inertia of this spatial inertia is <code class="docutils literal notranslate"><span class="pre">I_BP_E</span></code> (<span class="math notranslate nohighlight">\([I^{B/P}]_E\)</span>)
and the position vector of the center of mass measured from point P
and expressed in E is <code class="docutils literal notranslate"><span class="pre">p_PBcm_E</span></code> (<span class="math notranslate nohighlight">\([^Pp^{B_{cm}}]_E\)</span>).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class does not implement any mechanism to track the frame E
in which a spatial inertia is expressed or about what point is
computed. Methods and operators on this class have no means to
determine frame consistency through operations. It is therefore
the responsibility of users of this class to keep track of frames
in which operations are performed. We suggest doing that using
disciplined notation, as described above.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Several methods in this class throw a RuntimeError for invalid
rotational inertia operations in debug releases only. This
provides speed in a release build while facilitating debugging in
debug builds. In addition, these validity tests are only performed
for scalar types for which drake::scalar_predicate&lt;T&gt;::is_bool is
<code class="docutils literal notranslate"><span class="pre">True</span></code>. For instance, validity checks are not performed when T
is symbolic::Expression.</p>
</div>
<ul class="simple">
<li><dl class="first docutils">
<dt>[Jain 2010]  Jain, A., 2010. Robot and multibody dynamics: analysis and</dt>
<dd>algorithms. Springer Science &amp; Business Media.</dd>
</dl>
</li>
</ul>
<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.SpatialInertia_[float]) -&gt; None</li>
</ol>
<p>Default SpatialInertia constructor initializes mass, center of mass
and rotational inertia to invalid NaN’s for a quick detection of
uninitialized values.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.SpatialInertia_[float], mass: float, p_PScm_E: numpy.ndarray[numpy.float64[3, 1]], G_SP_E: pydrake.multibody.tree.UnitInertia_[float], skip_validity_check: bool = False) -&gt; None</li>
</ol>
<p>Constructs a spatial inertia for a physical body or composite body S
about a point P from a given mass, center of mass and rotational
inertia. The center of mass is specified by the position vector
<code class="docutils literal notranslate"><span class="pre">p_PScm_E</span></code> from point P to the center of mass point <code class="docutils literal notranslate"><span class="pre">Scm</span></code>,
expressed in a frame E. The rotational inertia is provided as the
UnitInertia <code class="docutils literal notranslate"><span class="pre">G_SP_E</span></code> of the body or composite body S computed about
point P and expressed in frame E.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The third argument of this constructor is unusual in that it is an
UnitInertia (not a traditional RotationalInertia) and its inertia
is about the arbitrary point P (not Scm – S’s center of mass).</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">MakeFromCentralInertia a factory method with traditional utility.</p>
</div>
<p>This constructor checks for the physical validity of the resulting
SpatialInertia with IsPhysicallyValid() and throws a RuntimeError
exception in the event the provided input parameters lead to
non-physically viable spatial inertia. Since this check has
non-negligable runtime costs, it can be disabled by setting the
optional argument <code class="docutils literal notranslate"><span class="pre">skip_validity_check</span></code> to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt>
<dd>The mass of the body or composite body S.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PScm_E</span></code>:</dt>
<dd>The position vector from point P to the center of mass of body or
composite body S expressed in frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">G_SP_E</span></code>:</dt>
<dd>UnitInertia of the body or composite body S computed about origin
point P and expressed in frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">skip_validity_check</span></code>:</dt>
<dd>If true, skips the validity check described above. Defaults to
false.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[float].CalcComMoment">
<code class="descname">CalcComMoment</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[float].CalcComMoment" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the center of mass moment vector <code class="docutils literal notranslate"><span class="pre">mass</span> <span class="pre">*</span> <span class="pre">p_PScm_E</span></code> given
the position vector <code class="docutils literal notranslate"><span class="pre">p_PScm_E</span></code> from the <em>about point</em> P to the
center of mass <code class="docutils literal notranslate"><span class="pre">Scm</span></code> of the body or composite body S, expressed in
frame E. See the documentation of this class for details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[float].CalcRotationalInertia">
<code class="descname">CalcRotationalInertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.RotationalInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[float].CalcRotationalInertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the rotational inertia <code class="docutils literal notranslate"><span class="pre">I_SP_E</span> <span class="pre">=</span> <span class="pre">mass</span> <span class="pre">*</span> <span class="pre">G_SP_E</span></code> of this
spatial inertia, computed about point P and expressed in frame E. See
the documentation of this class for details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[float].CopyToFullMatrix6">
<code class="descname">CopyToFullMatrix6</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[6, 6]]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[float].CopyToFullMatrix6" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy to a full 6x6 matrix representation.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[float].get_com">
<code class="descname">get_com</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[float].get_com" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a constant reference to the position vector <code class="docutils literal notranslate"><span class="pre">p_PScm_E</span></code> from the
<em>about point</em> P to the center of mass <code class="docutils literal notranslate"><span class="pre">Scm</span></code> of the body or composite
body S, expressed in frame E. See the documentation of this class for
details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[float].get_mass">
<code class="descname">get_mass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[float].get_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a constant reference to the mass of this spatial inertia.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[float].get_unit_inertia">
<code class="descname">get_unit_inertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[float].get_unit_inertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a constant reference to the unit inertia <code class="docutils literal notranslate"><span class="pre">G_SP_E</span></code> of this
spatial inertia, computed about point P and expressed in frame E. See
the documentation of this class for details.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[float].IsNaN">
<code class="descname">IsNaN</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[float].IsNaN" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if any of the elements in this spatial inertia is NaN
and <code class="docutils literal notranslate"><span class="pre">False</span></code> otherwise.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[float].IsPhysicallyValid">
<code class="descname">IsPhysicallyValid</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float]</em><span class="sig-paren">)</span> &#x2192; bool<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[float].IsPhysicallyValid" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a number of checks to verify that this is a physically valid
spatial inertia. The checks performed are:</p>
<ul class="simple">
<li>No NaN entries.</li>
<li>Non-negative mass.</li>
<li>Non-negative principal moments about the center of mass.</li>
<li>Principal moments about the center of mass must satisfy the triangle
inequality:
- <code class="docutils literal notranslate"><span class="pre">Ixx</span> <span class="pre">+</span> <span class="pre">Iyy</span> <span class="pre">&gt;=</span> <span class="pre">Izz</span></code>
- <cite>Ixx + Izz &gt;= Iyy</cite>
- <code class="docutils literal notranslate"><span class="pre">Iyy</span> <span class="pre">+</span> <span class="pre">Izz</span> <span class="pre">&gt;=</span> <span class="pre">Ixx</span></code></li>
</ul>
<p>These are the tests performed by
RotationalInertia::CouldBePhysicallyValid() which become a sufficient
condition when performed on a rotational inertia about a body’s center
of mass.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">RotationalInertia::CouldBePhysicallyValid().</p>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.SpatialInertia_[float].MakeFromCentralInertia">
<em class="property">static </em><code class="descname">MakeFromCentralInertia</code><span class="sig-paren">(</span><em>mass: float, p_PScm_E: numpy.ndarray[numpy.float64[3, 1]], I_SScm_E: pydrake.multibody.tree.RotationalInertia_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.SpatialInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[float].MakeFromCentralInertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a spatial inertia for a physical body or composite body S
about a point P from a given mass, center of mass, and central
rotational inertia. For example, this method creates a body’s
SpatialInertia about its body origin Bo from the body’s mass, position
vector from Bo to the body’s center of mass, and rotational inertia
about the body’s center of mass.</p>
<p>This method checks for the physical validity of the resulting
SpatialInertia with IsPhysicallyValid() and throws a RuntimeError
exception in the event the provided input parameters lead to a
non-physically viable spatial inertia.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">mass</span></code>:</dt>
<dd>The mass of the body or composite body S.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PScm_E</span></code>:</dt>
<dd>The position vector from point P to point <code class="docutils literal notranslate"><span class="pre">Scm</span></code> (S’s center of
mass), expressed in a frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">I_SScm_E</span></code>:</dt>
<dd>S’s RotationalInertia about Scm, expressed in frame E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_SP_E</span></code>:</dt>
<dd>S’s spatial inertia about point P, expressed in frame E.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[float].ReExpress">
<code class="descname">ReExpress</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float], R_AE: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.SpatialInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[float].ReExpress" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial inertia <code class="docutils literal notranslate"><span class="pre">M_SP_E</span></code> for some body or composite
body S, taken about a point P and expressed in frame E, this method
computes the same inertia re-expressed in another frame A.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_AE</span></code>:</dt>
<dd>RotationMatrix relating frames A and E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_SP_A</span></code>:</dt>
<dd>The same spatial inertia of S about P but now re-expressed in
frame A.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ReExpressInPlace() for details.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[float].SetNaN">
<code class="descname">SetNaN</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[float].SetNaN" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial inertia to have NaN entries. Typically used for
quick detection of uninitialized values.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.SpatialInertia_[float].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.SpatialInertia_[float], p_PQ_E: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.SpatialInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.SpatialInertia_[float].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial inertia <code class="docutils literal notranslate"><span class="pre">M_SP_E</span></code> for some body or composite
body S, computed about point P, and expressed in frame E, this method
uses the <em>Parallel Axis Theorem</em> for spatial inertias to compute the
same spatial inertia about a new point Q. The result still is
expressed in frame E.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() for more details.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PQ_E</span></code>:</dt>
<dd>Vector from the original about point P to the new about point Q,
expressed in the same frame E <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial inertia is
expressed in.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">M_SQ_E</span></code>:</dt>
<dd>This same spatial inertia for body or composite body S but
computed about a new point Q.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">UniformGravityFieldElement</code><a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.UniformGravityFieldElement_[float]" title="pydrake.multibody.tree.UniformGravityFieldElement_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.UniformGravityFieldElement_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">UniformGravityFieldElement_</code><a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.UniformGravityFieldElement_[float]" title="pydrake.multibody.tree.UniformGravityFieldElement_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">UniformGravityFieldElement_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd]" title="pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">UniformGravityFieldElement_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.UniformGravityFieldElement_[Expression]" title="pydrake.multibody.tree.UniformGravityFieldElement_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">UniformGravityFieldElement_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement_.UniformGravityFieldElement_[float]">
<em class="property">class </em><code class="descname">UniformGravityFieldElement_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement_.UniformGravityFieldElement_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[float]" title="pydrake.multibody.tree.ForceElement_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ForceElement_[float]</span></code></a></p>
<p>This ForceElement allows modeling the effect of a uniform gravity
field as felt by bodies on the surface of the Earth. This gravity
field acts on all bodies in the MultibodyTree model.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement_.UniformGravityFieldElement_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement_.UniformGravityFieldElement_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.UniformGravityFieldElement_[float]) -&gt; None</li>
</ol>
<p>Constructs a uniform gravity field element with a default strength (on
the earth’s surface) and direction (-z).</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.UniformGravityFieldElement_[float], g_W: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</li>
</ol>
<p>Constructs a uniform gravity field element with a strength given by
the acceleration of gravity vector <code class="docutils literal notranslate"><span class="pre">g_W</span></code>, expressed in the world
frame W.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement_.UniformGravityFieldElement_[float].CalcGravityGeneralizedForces">
<code class="descname">CalcGravityGeneralizedForces</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniformGravityFieldElement_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement_.UniformGravityFieldElement_[float].CalcGravityGeneralizedForces" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the generalized forces <code class="docutils literal notranslate"><span class="pre">tau_g(q)</span></code> due to <code class="docutils literal notranslate"><span class="pre">this</span></code> gravity
field element as a function of the generalized positions <code class="docutils literal notranslate"><span class="pre">q</span></code> stored
in the input <code class="docutils literal notranslate"><span class="pre">context</span></code>, for the multibody model to which <code class="docutils literal notranslate"><span class="pre">this</span></code>
element belongs. <code class="docutils literal notranslate"><span class="pre">tau_g(q)</span></code> is defined such that it appears on the
right hand side of the equations of motion together with any other
generalized forces, like so:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Mv̇</span> <span class="o">+</span> <span class="n">C</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="n">v</span> <span class="o">=</span> <span class="n">tau_g</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">+</span> <span class="n">tau_app</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">tau_app</span></code> includes any other generalized forces applied on the
system.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context storing the state of the multibody model to which this
element belongs.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">tau_g A vector containing the generalized forces due to this
gravity field force element. The generalized forces are consistent
with the vector of generalized velocities <code class="docutils literal notranslate"><span class="pre">v</span></code> for the parent
MultibodyTree model so that the inner product <code class="docutils literal notranslate"><span class="pre">v⋅tau_g</span></code>
corresponds to the power applied by the gravity forces on the
mechanical system. That is, <code class="docutils literal notranslate"><span class="pre">v⋅tau_g</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> corresponds to
potential energy going into the system, as either mechanical
kinetic energy, some other potential energy, or heat, and
therefore to a decrease of potential energy.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement_.UniformGravityFieldElement_[float].gravity_vector">
<code class="descname">gravity_vector</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniformGravityFieldElement_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement_.UniformGravityFieldElement_[float].gravity_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the acceleration of the gravity vector in m/s², expressed in
the world frame W.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement_.UniformGravityFieldElement_[float].kDefaultStrength">
<code class="descname">kDefaultStrength</code><em class="property"> = 9.81</em><a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement_.UniformGravityFieldElement_[float].kDefaultStrength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement_.UniformGravityFieldElement_[float].set_gravity_vector">
<code class="descname">set_gravity_vector</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniformGravityFieldElement_[float], arg0: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement_.UniformGravityFieldElement_[float].set_gravity_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the acceleration of gravity vector, expressed in the world frame
W in m/s².</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">UniformGravityFieldElement_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[AutoDiffXd]" title="pydrake.multibody.tree.ForceElement_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ForceElement_[AutoDiffXd]</span></code></a></p>
<p>This ForceElement allows modeling the effect of a uniform gravity
field as felt by bodies on the surface of the Earth. This gravity
field acts on all bodies in the MultibodyTree model.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd]) -&gt; None</li>
</ol>
<p>Constructs a uniform gravity field element with a default strength (on
the earth’s surface) and direction (-z).</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd], g_W: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</li>
</ol>
<p>Constructs a uniform gravity field element with a strength given by
the acceleration of gravity vector <code class="docutils literal notranslate"><span class="pre">g_W</span></code>, expressed in the world
frame W.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd].CalcGravityGeneralizedForces">
<code class="descname">CalcGravityGeneralizedForces</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd].CalcGravityGeneralizedForces" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the generalized forces <code class="docutils literal notranslate"><span class="pre">tau_g(q)</span></code> due to <code class="docutils literal notranslate"><span class="pre">this</span></code> gravity
field element as a function of the generalized positions <code class="docutils literal notranslate"><span class="pre">q</span></code> stored
in the input <code class="docutils literal notranslate"><span class="pre">context</span></code>, for the multibody model to which <code class="docutils literal notranslate"><span class="pre">this</span></code>
element belongs. <code class="docutils literal notranslate"><span class="pre">tau_g(q)</span></code> is defined such that it appears on the
right hand side of the equations of motion together with any other
generalized forces, like so:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Mv̇</span> <span class="o">+</span> <span class="n">C</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="n">v</span> <span class="o">=</span> <span class="n">tau_g</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">+</span> <span class="n">tau_app</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">tau_app</span></code> includes any other generalized forces applied on the
system.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context storing the state of the multibody model to which this
element belongs.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">tau_g A vector containing the generalized forces due to this
gravity field force element. The generalized forces are consistent
with the vector of generalized velocities <code class="docutils literal notranslate"><span class="pre">v</span></code> for the parent
MultibodyTree model so that the inner product <code class="docutils literal notranslate"><span class="pre">v⋅tau_g</span></code>
corresponds to the power applied by the gravity forces on the
mechanical system. That is, <code class="docutils literal notranslate"><span class="pre">v⋅tau_g</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> corresponds to
potential energy going into the system, as either mechanical
kinetic energy, some other potential energy, or heat, and
therefore to a decrease of potential energy.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd].gravity_vector">
<code class="descname">gravity_vector</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd].gravity_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the acceleration of the gravity vector in m/s², expressed in
the world frame W.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd].kDefaultStrength">
<code class="descname">kDefaultStrength</code><em class="property"> = 9.81</em><a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd].kDefaultStrength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd].set_gravity_vector">
<code class="descname">set_gravity_vector</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd], arg0: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement_[AutoDiffXd].set_gravity_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the acceleration of gravity vector, expressed in the world frame
W in m/s².</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">UniformGravityFieldElement_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[Expression]" title="pydrake.multibody.tree.ForceElement_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ForceElement_[Expression]</span></code></a></p>
<p>This ForceElement allows modeling the effect of a uniform gravity
field as felt by bodies on the surface of the Earth. This gravity
field acts on all bodies in the MultibodyTree model.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.UniformGravityFieldElement_[Expression]) -&gt; None</li>
</ol>
<p>Constructs a uniform gravity field element with a default strength (on
the earth’s surface) and direction (-z).</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.UniformGravityFieldElement_[Expression], g_W: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</li>
</ol>
<p>Constructs a uniform gravity field element with a strength given by
the acceleration of gravity vector <code class="docutils literal notranslate"><span class="pre">g_W</span></code>, expressed in the world
frame W.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement_[Expression].CalcGravityGeneralizedForces">
<code class="descname">CalcGravityGeneralizedForces</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniformGravityFieldElement_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement_[Expression].CalcGravityGeneralizedForces" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the generalized forces <code class="docutils literal notranslate"><span class="pre">tau_g(q)</span></code> due to <code class="docutils literal notranslate"><span class="pre">this</span></code> gravity
field element as a function of the generalized positions <code class="docutils literal notranslate"><span class="pre">q</span></code> stored
in the input <code class="docutils literal notranslate"><span class="pre">context</span></code>, for the multibody model to which <code class="docutils literal notranslate"><span class="pre">this</span></code>
element belongs. <code class="docutils literal notranslate"><span class="pre">tau_g(q)</span></code> is defined such that it appears on the
right hand side of the equations of motion together with any other
generalized forces, like so:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Mv̇</span> <span class="o">+</span> <span class="n">C</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="n">v</span> <span class="o">=</span> <span class="n">tau_g</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">+</span> <span class="n">tau_app</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">tau_app</span></code> includes any other generalized forces applied on the
system.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context storing the state of the multibody model to which this
element belongs.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">tau_g A vector containing the generalized forces due to this
gravity field force element. The generalized forces are consistent
with the vector of generalized velocities <code class="docutils literal notranslate"><span class="pre">v</span></code> for the parent
MultibodyTree model so that the inner product <code class="docutils literal notranslate"><span class="pre">v⋅tau_g</span></code>
corresponds to the power applied by the gravity forces on the
mechanical system. That is, <code class="docutils literal notranslate"><span class="pre">v⋅tau_g</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> corresponds to
potential energy going into the system, as either mechanical
kinetic energy, some other potential energy, or heat, and
therefore to a decrease of potential energy.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement_[Expression].gravity_vector">
<code class="descname">gravity_vector</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniformGravityFieldElement_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement_[Expression].gravity_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the acceleration of the gravity vector in m/s², expressed in
the world frame W.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement_[Expression].kDefaultStrength">
<code class="descname">kDefaultStrength</code><em class="property"> = 9.81</em><a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement_[Expression].kDefaultStrength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement_[Expression].set_gravity_vector">
<code class="descname">set_gravity_vector</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniformGravityFieldElement_[Expression], arg0: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement_[Expression].set_gravity_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the acceleration of gravity vector, expressed in the world frame
W in m/s².</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">UniformGravityFieldElement_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.ForceElement_[float]" title="pydrake.multibody.tree.ForceElement_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.ForceElement_[float]</span></code></a></p>
<p>This ForceElement allows modeling the effect of a uniform gravity
field as felt by bodies on the surface of the Earth. This gravity
field acts on all bodies in the MultibodyTree model.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.UniformGravityFieldElement_[float]) -&gt; None</li>
</ol>
<p>Constructs a uniform gravity field element with a default strength (on
the earth’s surface) and direction (-z).</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.UniformGravityFieldElement_[float], g_W: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</li>
</ol>
<p>Constructs a uniform gravity field element with a strength given by
the acceleration of gravity vector <code class="docutils literal notranslate"><span class="pre">g_W</span></code>, expressed in the world
frame W.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement_[float].CalcGravityGeneralizedForces">
<code class="descname">CalcGravityGeneralizedForces</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniformGravityFieldElement_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[m, 1]]<a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement_[float].CalcGravityGeneralizedForces" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the generalized forces <code class="docutils literal notranslate"><span class="pre">tau_g(q)</span></code> due to <code class="docutils literal notranslate"><span class="pre">this</span></code> gravity
field element as a function of the generalized positions <code class="docutils literal notranslate"><span class="pre">q</span></code> stored
in the input <code class="docutils literal notranslate"><span class="pre">context</span></code>, for the multibody model to which <code class="docutils literal notranslate"><span class="pre">this</span></code>
element belongs. <code class="docutils literal notranslate"><span class="pre">tau_g(q)</span></code> is defined such that it appears on the
right hand side of the equations of motion together with any other
generalized forces, like so:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Mv̇</span> <span class="o">+</span> <span class="n">C</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span><span class="n">v</span> <span class="o">=</span> <span class="n">tau_g</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">+</span> <span class="n">tau_app</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">tau_app</span></code> includes any other generalized forces applied on the
system.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context storing the state of the multibody model to which this
element belongs.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">tau_g A vector containing the generalized forces due to this
gravity field force element. The generalized forces are consistent
with the vector of generalized velocities <code class="docutils literal notranslate"><span class="pre">v</span></code> for the parent
MultibodyTree model so that the inner product <code class="docutils literal notranslate"><span class="pre">v⋅tau_g</span></code>
corresponds to the power applied by the gravity forces on the
mechanical system. That is, <code class="docutils literal notranslate"><span class="pre">v⋅tau_g</span> <span class="pre">&gt;</span> <span class="pre">0</span></code> corresponds to
potential energy going into the system, as either mechanical
kinetic energy, some other potential energy, or heat, and
therefore to a decrease of potential energy.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement_[float].gravity_vector">
<code class="descname">gravity_vector</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniformGravityFieldElement_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement_[float].gravity_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the acceleration of the gravity vector in m/s², expressed in
the world frame W.</p>
</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement_[float].kDefaultStrength">
<code class="descname">kDefaultStrength</code><em class="property"> = 9.81</em><a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement_[float].kDefaultStrength" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniformGravityFieldElement_[float].set_gravity_vector">
<code class="descname">set_gravity_vector</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniformGravityFieldElement_[float], arg0: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.UniformGravityFieldElement_[float].set_gravity_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the acceleration of gravity vector, expressed in the world frame
W in m/s².</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.UnitInertia">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">UnitInertia</code><a class="headerlink" href="#pydrake.multibody.tree.UnitInertia" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.UnitInertia_[float]" title="pydrake.multibody.tree.UnitInertia_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.UnitInertia_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.UnitInertia_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">UnitInertia_</code><a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.UnitInertia_[float]" title="pydrake.multibody.tree.UnitInertia_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnitInertia_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.UnitInertia_[AutoDiffXd]" title="pydrake.multibody.tree.UnitInertia_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnitInertia_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.UnitInertia_[Expression]" title="pydrake.multibody.tree.UnitInertia_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnitInertia_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.UnitInertia_.UnitInertia_[float]">
<em class="property">class </em><code class="descname">UnitInertia_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_.UnitInertia_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.RotationalInertia_[float]" title="pydrake.multibody.tree.RotationalInertia_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.RotationalInertia_[float]</span></code></a></p>
<p>This class is used to represent rotational inertias for unit mass
bodies. Therefore, unlike RotationalInertia whose units are kg⋅m², the
units of a UnitInertia are those of length squared. A unit inertia is
a useful concept to represent the geometric distribution of mass in a
body regardless of the actual value of the body mass. The rotational
inertia of a body can therefore be obtained by multiplying its unit
inertia by its mass. Unit inertia matrices can also be called
<strong>gyration</strong> matrices and therefore we choose to represent them in
source code notation with the capital letter G. In contrast, the
capital letter I is used to represent non-unit mass rotational
inertias. This class restricts the set of allowed operations on a unit
inertia to ensure the unit-mass invariant. For instance,
multiplication by a scalar can only return a general RotationalInertia
but not a UnitInertia.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class has no means to check at construction from user
provided parameters whether it actually represents the unit
inertia or gyration matrix of a unit-mass body. However, as
previously noted, once a unit inertia is created, a number of
operations are disallowed to ensure the unit-mass invariant. Also
notice that once a unit inertia is created, it <em>is</em> the unit
inertia of <em>some</em> body, perhaps with scaled geometry from the
user’s intention.</p>
</div>
<dl class="method">
<dt id="pydrake.multibody.tree.UnitInertia_.UnitInertia_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_.UnitInertia_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.UnitInertia_[float]) -&gt; None</li>
</ol>
<p>Default UnitInertia constructor sets all entries to NaN for quick
detection of uninitialized values.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.UnitInertia_[float], Ixx: float, Iyy: float, Izz: float) -&gt; None</li>
</ol>
<p>Creates a unit inertia with moments of inertia <code class="docutils literal notranslate"><span class="pre">Ixx</span></code>, <cite>Iyy</cite>,
<code class="docutils literal notranslate"><span class="pre">Izz</span></code>, and with each product of inertia set to zero. In debug
builds, throws RuntimeError if unit inertia constructed from these
arguments violates RotationalInertia::CouldBePhysicallyValid().</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.tree.UnitInertia_[float], Ixx: float, Iyy: float, Izz: float, Ixy: float, Ixz: float, Iyz: float) -&gt; None</li>
</ol>
<p>Creates a unit inertia with moments of inertia <code class="docutils literal notranslate"><span class="pre">Ixx</span></code>, <cite>Iyy</cite>,
<code class="docutils literal notranslate"><span class="pre">Izz</span></code>, and with products of inertia <code class="docutils literal notranslate"><span class="pre">Ixy</span></code>, <cite>Ixz</cite>, <code class="docutils literal notranslate"><span class="pre">Iyz</span></code>. In
debug builds, throws RuntimeError if unit inertia constructed from
these arguments violates RotationalInertia::CouldBePhysicallyValid().</p>
<ol class="arabic simple" start="4">
<li>__init__(self: pydrake.multibody.tree.UnitInertia_[float], I: pydrake.multibody.tree.RotationalInertia_[float]) -&gt; None</li>
</ol>
<p>Constructs a UnitInertia from a RotationalInertia. This constructor
has no way to verify that the input rotational inertia actually is a
unit inertia. But the construction will nevertheless succeed, and the
values of the input rotational inertia will henceforth be considered a
valid unit inertia. It is the responsibility of the user to pass a
valid unit inertia.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_.UnitInertia_[float].AxiallySymmetric">
<em class="property">static </em><code class="descname">AxiallySymmetric</code><span class="sig-paren">(</span><em>J: float, K: float, b_E: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_.UnitInertia_[float].AxiallySymmetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the unit inertia for a unit-mass body B for which there exists
a line L passing through the body’s center of mass <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> having the
property that the body’s moment of inertia about all lines
perpendicular to L are equal. Examples of bodies with an axially
symmetric inertia include axisymmetric objects such as cylinders and
cones. Other commonly occurring geometries with this property are, for
instance, propellers with 3+ evenly spaced blades. Given a unit vector
b defining the symmetry line L, the moment of inertia J about this
line L and the moment of inertia K about any line perpendicular to L,
the axially symmetric unit inertia G is computed as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>G = K * Id + (J - K) * b ⊗ b
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">Id</span></code> is the identity matrix and ⊗ denotes the tensor product
operator. See Mitiguy, P., 2016. Advanced Dynamics &amp; Motion
Simulation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError - J is negative. J can be zero. - K is negative. K</li>
<li>can be zero. - J ≤ 2 * K, this corresponds to the triangle</li>
<li>inequality, see CouldBePhysicallyValid(). - <code class="docutils literal notranslate"><span class="pre">b_E</span></code> is the zero</li>
<li>vector. That is if <code class="docutils literal notranslate"><span class="pre">‖b_E‖₂</span> <span class="pre">≤</span> <span class="pre">ε</span></code>, where ε is the machine epsilon.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">J is a principal moment of inertia with principal axis equal to b.
K is a principal moment with multiplicity of two. Any two axes
perpendicular to b are principal axes with principal moment K.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">J</span></code>:</dt>
<dd>Unit inertia about axis b.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">K</span></code>:</dt>
<dd>Unit inertia about any axis perpendicular to b.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b_E</span></code>:</dt>
<dd>Vector defining the symmetry axis, expressed in a frame E. <code class="docutils literal notranslate"><span class="pre">b_E</span></code>
can have a norm different from one; however, it will be normalized
before using it. Therefore its norm is ignored and only its
direction is used.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_Bcm_E</span></code>:</dt>
<dd>An axially symmetric unit inertia about body B’s center of mass,
expressed in the same frame E as the input unit vector <code class="docutils literal notranslate"><span class="pre">b_E</span></code>.</dd>
</dl>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_.UnitInertia_[float].HollowSphere">
<em class="property">static </em><code class="descname">HollowSphere</code><span class="sig-paren">(</span><em>r: float</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_.UnitInertia_[float].HollowSphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the unit inertia for a unit-mass hollow sphere of radius
<code class="docutils literal notranslate"><span class="pre">r</span></code> consisting of an infinitesimally thin shell of uniform density.
The unit inertia is taken about the center of the sphere.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_.UnitInertia_[float].PointMass">
<em class="property">static </em><code class="descname">PointMass</code><span class="sig-paren">(</span><em>p_FQ: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_.UnitInertia_[float].PointMass" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a unit inertia for a point mass of unit mass located at
point Q, whose location in a frame F is given by the position vector
<code class="docutils literal notranslate"><span class="pre">p_FQ</span></code> (that is, p_FoQ_F). The unit inertia <code class="docutils literal notranslate"><span class="pre">G_QFo_F</span></code> of point
mass Q about the origin <code class="docutils literal notranslate"><span class="pre">Fo</span></code> of frame F and expressed in F for this
unit mass point equals the square of the cross product matrix of
<code class="docutils literal notranslate"><span class="pre">p_FQ</span></code>. In coordinate-free form:</p>
<div class="math notranslate nohighlight">
\[G^{Q/F_o} = (^Fp^Q_\times)^2 = (^Fp^Q_\times)^T \, ^Fp^Q_\times =
-^Fp^Q_\times \, ^Fp^Q_\times\]</div>
<p>where <span class="math notranslate nohighlight">\(^Fp^Q_\times\)</span> is the cross product matrix of vector
<span class="math notranslate nohighlight">\(^Fp^Q\)</span>. In source code the above expression is written as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>G_QFo_F = px_FQ² = px_FQᵀ * px_FQ = -px_FQ * px_FQ
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">px_FQ</span></code> denotes the cross product matrix of the position
vector <code class="docutils literal notranslate"><span class="pre">p_FQ</span></code> (expressed in F) such that the cross product with
another vector <code class="docutils literal notranslate"><span class="pre">a</span></code> can be obtained as <code class="docutils literal notranslate"><span class="pre">px.cross(a)</span> <span class="pre">=</span> <span class="pre">px</span> <span class="pre">*</span> <span class="pre">a</span></code>. The
cross product matrix <code class="docutils literal notranslate"><span class="pre">px</span></code> is skew-symmetric. The square of the cross
product matrix is a symmetric matrix with non-negative diagonals and
obeys the triangle inequality. Matrix <code class="docutils literal notranslate"><span class="pre">px²</span></code> can be used to compute
the triple vector product as <code class="docutils literal notranslate"><span class="pre">-p</span> <span class="pre">x</span> <span class="pre">(p</span> <span class="pre">x</span> <span class="pre">a)</span> <span class="pre">=</span> <span class="pre">-p.cross(p.cross(a))</span> <span class="pre">=</span>
<span class="pre">px²</span> <span class="pre">*</span> <span class="pre">a</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UnitInertia_.UnitInertia_[float].ReExpress">
<code class="descname">ReExpress</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UnitInertia_[float], R_AE: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_.UnitInertia_[float].ReExpress" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <code class="docutils literal notranslate"><span class="pre">this</span></code> unit inertia <code class="docutils literal notranslate"><span class="pre">G_BP_E</span></code> of a body B about a point P and
expressed in frame E, this method computes the same unit inertia
re-expressed in another frame A as <code class="docutils literal notranslate"><span class="pre">G_BP_A</span> <span class="pre">=</span> <span class="pre">R_AE</span> <span class="pre">*</span> <span class="pre">G_BP_E</span> <span class="pre">*</span>
<span class="pre">(R_AE)ᵀ</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_AE</span></code>:</dt>
<dd>RotationMatrix relating frames A and E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_BP_A</span></code>:</dt>
<dd>The same unit inertia for body B about point P but now
re-expressed in frame A.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UnitInertia_.UnitInertia_[float].SetFromRotationalInertia">
<code class="descname">SetFromRotationalInertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UnitInertia_[float], I: pydrake.multibody.tree.RotationalInertia_[float], mass: float</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_.UnitInertia_[float].SetFromRotationalInertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> unit inertia from a generally non-unit inertia I
corresponding to a body with a given <code class="docutils literal notranslate"><span class="pre">mass</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In Debug builds, this operation aborts if the provided <code class="docutils literal notranslate"><span class="pre">mass</span></code> is
not strictly positive.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UnitInertia_.UnitInertia_[float].ShiftFromCenterOfMass">
<code class="descname">ShiftFromCenterOfMass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UnitInertia_[float], p_BcmQ_E: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_.UnitInertia_[float].ShiftFromCenterOfMass" title="Permalink to this definition">¶</a></dt>
<dd><p>Shifts this central unit inertia to a different point, and returns the
result. See ShiftFromCenterOfMassInPlace() for details.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BcmQ_E</span></code>:</dt>
<dd>A vector from the body’s centroid <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> to point Q expressed in
the same frame E in which <code class="docutils literal notranslate"><span class="pre">this</span></code> inertia is expressed.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_BQ_E</span></code>:</dt>
<dd>This same unit inertia taken about a point Q instead of the
centroid <code class="docutils literal notranslate"><span class="pre">Bcm</span></code>.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UnitInertia_.UnitInertia_[float].ShiftToCenterOfMass">
<code class="descname">ShiftToCenterOfMass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UnitInertia_[float], p_QBcm_E: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_.UnitInertia_[float].ShiftToCenterOfMass" title="Permalink to this definition">¶</a></dt>
<dd><p>For the unit inertia <code class="docutils literal notranslate"><span class="pre">G_BQ_E</span></code> of a body or composite body B computed
about a point Q and expressed in a frame E, this method shifts this
inertia using the parallel axis theorem to be computed about the
center of mass <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> of B. See ShiftToCenterOfMassInPlace() for
details.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_QBcm_E</span></code>:</dt>
<dd>A position vector from the about point Q to the body’s centroid
<code class="docutils literal notranslate"><span class="pre">Bcm</span></code> expressed in the same frame E in which <code class="docutils literal notranslate"><span class="pre">this</span></code> inertia is
expressed.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_Bcm_E</span></code>:</dt>
<dd>This same unit which has now been taken about point <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> so
that it can be written as <code class="docutils literal notranslate"><span class="pre">G_BBcm_E</span></code>, or <code class="docutils literal notranslate"><span class="pre">G_Bcm_E</span></code>.</dd>
</dl>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This operation could result in a non-physical rotational inertia.
Use with care. See ShiftToCenterOfMassInPlace() for details.</p>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_.UnitInertia_[float].SolidBox">
<em class="property">static </em><code class="descname">SolidBox</code><span class="sig-paren">(</span><em>Lx: float</em>, <em>Ly: float</em>, <em>Lz: float</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_.UnitInertia_[float].SolidBox" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the unit inertia for a unit-mass solid box of uniform density
taken about its geometric center. If one length is zero the inertia
corresponds to that of a thin rectangular sheet. If two lengths are
zero the inertia corresponds to that of a thin rod in the remaining
direction.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Lx</span></code>:</dt>
<dd>The length of the box edge in the principal x-axis.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Ly</span></code>:</dt>
<dd>The length of the box edge in the principal y-axis.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Lz</span></code>:</dt>
<dd>The length of the box edge in the principal z-axis.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if any of Lx, Ly, Lz are negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_.UnitInertia_[float].SolidCube">
<em class="property">static </em><code class="descname">SolidCube</code><span class="sig-paren">(</span><em>L: float</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_.UnitInertia_[float].SolidCube" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the unit inertia for a unit-mass solid cube (a box with
equal-sized sides) of uniform density taken about its geometric
center.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">L</span></code>:</dt>
<dd>The length of each of the cube’s sides.</dd>
</dl>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_.UnitInertia_[float].SolidCylinder">
<em class="property">static </em><code class="descname">SolidCylinder</code><span class="sig-paren">(</span><em>r: float</em>, <em>L: float</em>, <em>b_E: numpy.ndarray[numpy.float64[3</em>, <em>1]] = array([0.</em>, <em>0.</em>, <em>1.])</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_.UnitInertia_[float].SolidCylinder" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the unit inertia for a unit-mass cylinder B, of uniform
density, having its axis of revolution along input vector <code class="docutils literal notranslate"><span class="pre">b_E</span></code>. The
resulting unit inertia is computed about the cylinder’s center of mass
<code class="docutils literal notranslate"><span class="pre">Bcm</span></code> and is expressed in the same frame E as the input axis of
revolution <code class="docutils literal notranslate"><span class="pre">b_E</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">r</span></code>:</dt>
<dd>The radius of the cylinder, it must be non-negative.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">L</span></code>:</dt>
<dd>The length of the cylinder, it must be non-negative.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b_E</span></code>:</dt>
<dd>Vector defining the axis of revolution of the cylinder, expressed
in a frame E. <code class="docutils literal notranslate"><span class="pre">b_E</span></code> can have a norm different from one; however,
it will be normalized before using it. Therefore its norm is
ignored and only its direction is used. It defaults to
<code class="docutils literal notranslate"><span class="pre">Vector3&lt;T&gt;::UnitZ()</span></code>.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_Bcm_E</span></code>:</dt>
<dd>The unit inertia for a solid cylinder B, of uniform density, with
axis of revolution along <code class="docutils literal notranslate"><span class="pre">b_E</span></code>, computed about the cylinder’s
center of mass <code class="docutils literal notranslate"><span class="pre">Bcm</span></code>, and expressed in the same frame E as the
input axis of rotation <code class="docutils literal notranslate"><span class="pre">b_E</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError - Radius r is negative. - Length L is negative. -</li>
<li><code class="docutils literal notranslate"><span class="pre">b_E</span></code> is the zero vector. That is if <code class="docutils literal notranslate"><span class="pre">‖b_E‖₂</span> <span class="pre">≤</span> <span class="pre">ε</span></code>, where ε is</li>
<li>the machine epsilon.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_.UnitInertia_[float].SolidCylinderAboutEnd">
<em class="property">static </em><code class="descname">SolidCylinderAboutEnd</code><span class="sig-paren">(</span><em>r: float</em>, <em>L: float</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_.UnitInertia_[float].SolidCylinderAboutEnd" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the unit inertia for a unit-mass cylinder of uniform density
oriented along the z-axis computed about a point at the center of its
base.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">r</span></code>:</dt>
<dd>The radius of the cylinder.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">L</span></code>:</dt>
<dd>The length of the cylinder.</dd>
</dl>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_.UnitInertia_[float].SolidSphere">
<em class="property">static </em><code class="descname">SolidSphere</code><span class="sig-paren">(</span><em>r: float</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_.UnitInertia_[float].SolidSphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the unit inertia for a unit-mass solid sphere of uniform
density and radius <code class="docutils literal notranslate"><span class="pre">r</span></code> taken about its center.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_.UnitInertia_[float].StraightLine">
<em class="property">static </em><code class="descname">StraightLine</code><span class="sig-paren">(</span><em>K: float, b_E: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_.UnitInertia_[float].StraightLine" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the unit inertia for a body B of unit-mass uniformly
distributed along a straight, finite, line L with direction <code class="docutils literal notranslate"><span class="pre">b_E</span></code>
and with moment of inertia K about any axis perpendicular to this
line. Since the mass of the body is uniformly distributed on this line
L, its center of mass is located right at the center. As an example,
consider the inertia of a thin rod for which its transversal
dimensions can be neglected, see ThinRod().</p>
<p>This method aborts if K is not positive.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is the particular case for an axially symmetric unit inertia
with zero moment about its axis, see AxiallySymmetric().</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">K</span></code>:</dt>
<dd>Unit inertia about any axis perpendicular to the line.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b_E</span></code>:</dt>
<dd>Vector defining the direction of the line, expressed in a frame E.
<code class="docutils literal notranslate"><span class="pre">b_E</span></code> can have a norm different from one. Its norm is ignored
and only its direction is needed.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_Bcm_E</span></code>:</dt>
<dd>The unit inertia for a body B of unit mass uniformly distributed
along a straight line L, about its center of mass <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> which is
located at the center of the line, expressed in the same frame E
as the input unit vector <code class="docutils literal notranslate"><span class="pre">b_E</span></code>.</dd>
</dl>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_.UnitInertia_[float].ThinRod">
<em class="property">static </em><code class="descname">ThinRod</code><span class="sig-paren">(</span><em>L: float, b_E: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_.UnitInertia_[float].ThinRod" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the unit inertia for a unit mass rod B of length L, about its
center of mass, with its mass uniformly distributed along a line
parallel to vector <code class="docutils literal notranslate"><span class="pre">b_E</span></code>.</p>
<p>This method aborts if L is not positive.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">L</span></code>:</dt>
<dd>The length of the rod. It must be positive.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b_E</span></code>:</dt>
<dd>Vector defining the axis of the rod, expressed in a frame E.
<code class="docutils literal notranslate"><span class="pre">b_E</span></code> can have a norm different from one. Its norm is ignored
and only its direction is needed.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_Bcm_E</span></code>:</dt>
<dd>The unit inertia of the rod B about its center of mass <code class="docutils literal notranslate"><span class="pre">Bcm</span></code>,
expressed in the same frame E as the input unit vector <code class="docutils literal notranslate"><span class="pre">b_E</span></code>.</dd>
</dl>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_.UnitInertia_[float].TriaxiallySymmetric">
<em class="property">static </em><code class="descname">TriaxiallySymmetric</code><span class="sig-paren">(</span><em>I_triaxial: float</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_.UnitInertia_[float].TriaxiallySymmetric" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.UnitInertia_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">UnitInertia_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]" title="pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]</span></code></a></p>
<p>This class is used to represent rotational inertias for unit mass
bodies. Therefore, unlike RotationalInertia whose units are kg⋅m², the
units of a UnitInertia are those of length squared. A unit inertia is
a useful concept to represent the geometric distribution of mass in a
body regardless of the actual value of the body mass. The rotational
inertia of a body can therefore be obtained by multiplying its unit
inertia by its mass. Unit inertia matrices can also be called
<strong>gyration</strong> matrices and therefore we choose to represent them in
source code notation with the capital letter G. In contrast, the
capital letter I is used to represent non-unit mass rotational
inertias. This class restricts the set of allowed operations on a unit
inertia to ensure the unit-mass invariant. For instance,
multiplication by a scalar can only return a general RotationalInertia
but not a UnitInertia.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class has no means to check at construction from user
provided parameters whether it actually represents the unit
inertia or gyration matrix of a unit-mass body. However, as
previously noted, once a unit inertia is created, a number of
operations are disallowed to ensure the unit-mass invariant. Also
notice that once a unit inertia is created, it <em>is</em> the unit
inertia of <em>some</em> body, perhaps with scaled geometry from the
user’s intention.</p>
</div>
<dl class="method">
<dt id="pydrake.multibody.tree.UnitInertia_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.UnitInertia_[AutoDiffXd]) -&gt; None</li>
</ol>
<p>Default UnitInertia constructor sets all entries to NaN for quick
detection of uninitialized values.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.UnitInertia_[AutoDiffXd], Ixx: pydrake.autodiffutils.AutoDiffXd, Iyy: pydrake.autodiffutils.AutoDiffXd, Izz: pydrake.autodiffutils.AutoDiffXd) -&gt; None</li>
</ol>
<p>Creates a unit inertia with moments of inertia <code class="docutils literal notranslate"><span class="pre">Ixx</span></code>, <cite>Iyy</cite>,
<code class="docutils literal notranslate"><span class="pre">Izz</span></code>, and with each product of inertia set to zero. In debug
builds, throws RuntimeError if unit inertia constructed from these
arguments violates RotationalInertia::CouldBePhysicallyValid().</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.tree.UnitInertia_[AutoDiffXd], Ixx: pydrake.autodiffutils.AutoDiffXd, Iyy: pydrake.autodiffutils.AutoDiffXd, Izz: pydrake.autodiffutils.AutoDiffXd, Ixy: pydrake.autodiffutils.AutoDiffXd, Ixz: pydrake.autodiffutils.AutoDiffXd, Iyz: pydrake.autodiffutils.AutoDiffXd) -&gt; None</li>
</ol>
<p>Creates a unit inertia with moments of inertia <code class="docutils literal notranslate"><span class="pre">Ixx</span></code>, <cite>Iyy</cite>,
<code class="docutils literal notranslate"><span class="pre">Izz</span></code>, and with products of inertia <code class="docutils literal notranslate"><span class="pre">Ixy</span></code>, <cite>Ixz</cite>, <code class="docutils literal notranslate"><span class="pre">Iyz</span></code>. In
debug builds, throws RuntimeError if unit inertia constructed from
these arguments violates RotationalInertia::CouldBePhysicallyValid().</p>
<ol class="arabic simple" start="4">
<li>__init__(self: pydrake.multibody.tree.UnitInertia_[AutoDiffXd], I: pydrake.multibody.tree.RotationalInertia_[AutoDiffXd]) -&gt; None</li>
</ol>
<p>Constructs a UnitInertia from a RotationalInertia. This constructor
has no way to verify that the input rotational inertia actually is a
unit inertia. But the construction will nevertheless succeed, and the
values of the input rotational inertia will henceforth be considered a
valid unit inertia. It is the responsibility of the user to pass a
valid unit inertia.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_[AutoDiffXd].AxiallySymmetric">
<em class="property">static </em><code class="descname">AxiallySymmetric</code><span class="sig-paren">(</span><em>J: pydrake.autodiffutils.AutoDiffXd, K: pydrake.autodiffutils.AutoDiffXd, b_E: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[AutoDiffXd].AxiallySymmetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the unit inertia for a unit-mass body B for which there exists
a line L passing through the body’s center of mass <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> having the
property that the body’s moment of inertia about all lines
perpendicular to L are equal. Examples of bodies with an axially
symmetric inertia include axisymmetric objects such as cylinders and
cones. Other commonly occurring geometries with this property are, for
instance, propellers with 3+ evenly spaced blades. Given a unit vector
b defining the symmetry line L, the moment of inertia J about this
line L and the moment of inertia K about any line perpendicular to L,
the axially symmetric unit inertia G is computed as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>G = K * Id + (J - K) * b ⊗ b
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">Id</span></code> is the identity matrix and ⊗ denotes the tensor product
operator. See Mitiguy, P., 2016. Advanced Dynamics &amp; Motion
Simulation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError - J is negative. J can be zero. - K is negative. K</li>
<li>can be zero. - J ≤ 2 * K, this corresponds to the triangle</li>
<li>inequality, see CouldBePhysicallyValid(). - <code class="docutils literal notranslate"><span class="pre">b_E</span></code> is the zero</li>
<li>vector. That is if <code class="docutils literal notranslate"><span class="pre">‖b_E‖₂</span> <span class="pre">≤</span> <span class="pre">ε</span></code>, where ε is the machine epsilon.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">J is a principal moment of inertia with principal axis equal to b.
K is a principal moment with multiplicity of two. Any two axes
perpendicular to b are principal axes with principal moment K.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">J</span></code>:</dt>
<dd>Unit inertia about axis b.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">K</span></code>:</dt>
<dd>Unit inertia about any axis perpendicular to b.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b_E</span></code>:</dt>
<dd>Vector defining the symmetry axis, expressed in a frame E. <code class="docutils literal notranslate"><span class="pre">b_E</span></code>
can have a norm different from one; however, it will be normalized
before using it. Therefore its norm is ignored and only its
direction is used.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_Bcm_E</span></code>:</dt>
<dd>An axially symmetric unit inertia about body B’s center of mass,
expressed in the same frame E as the input unit vector <code class="docutils literal notranslate"><span class="pre">b_E</span></code>.</dd>
</dl>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_[AutoDiffXd].HollowSphere">
<em class="property">static </em><code class="descname">HollowSphere</code><span class="sig-paren">(</span><em>r: pydrake.autodiffutils.AutoDiffXd</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[AutoDiffXd].HollowSphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the unit inertia for a unit-mass hollow sphere of radius
<code class="docutils literal notranslate"><span class="pre">r</span></code> consisting of an infinitesimally thin shell of uniform density.
The unit inertia is taken about the center of the sphere.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_[AutoDiffXd].PointMass">
<em class="property">static </em><code class="descname">PointMass</code><span class="sig-paren">(</span><em>p_FQ: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[AutoDiffXd].PointMass" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a unit inertia for a point mass of unit mass located at
point Q, whose location in a frame F is given by the position vector
<code class="docutils literal notranslate"><span class="pre">p_FQ</span></code> (that is, p_FoQ_F). The unit inertia <code class="docutils literal notranslate"><span class="pre">G_QFo_F</span></code> of point
mass Q about the origin <code class="docutils literal notranslate"><span class="pre">Fo</span></code> of frame F and expressed in F for this
unit mass point equals the square of the cross product matrix of
<code class="docutils literal notranslate"><span class="pre">p_FQ</span></code>. In coordinate-free form:</p>
<div class="math notranslate nohighlight">
\[G^{Q/F_o} = (^Fp^Q_\times)^2 = (^Fp^Q_\times)^T \, ^Fp^Q_\times =
-^Fp^Q_\times \, ^Fp^Q_\times\]</div>
<p>where <span class="math notranslate nohighlight">\(^Fp^Q_\times\)</span> is the cross product matrix of vector
<span class="math notranslate nohighlight">\(^Fp^Q\)</span>. In source code the above expression is written as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>G_QFo_F = px_FQ² = px_FQᵀ * px_FQ = -px_FQ * px_FQ
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">px_FQ</span></code> denotes the cross product matrix of the position
vector <code class="docutils literal notranslate"><span class="pre">p_FQ</span></code> (expressed in F) such that the cross product with
another vector <code class="docutils literal notranslate"><span class="pre">a</span></code> can be obtained as <code class="docutils literal notranslate"><span class="pre">px.cross(a)</span> <span class="pre">=</span> <span class="pre">px</span> <span class="pre">*</span> <span class="pre">a</span></code>. The
cross product matrix <code class="docutils literal notranslate"><span class="pre">px</span></code> is skew-symmetric. The square of the cross
product matrix is a symmetric matrix with non-negative diagonals and
obeys the triangle inequality. Matrix <code class="docutils literal notranslate"><span class="pre">px²</span></code> can be used to compute
the triple vector product as <code class="docutils literal notranslate"><span class="pre">-p</span> <span class="pre">x</span> <span class="pre">(p</span> <span class="pre">x</span> <span class="pre">a)</span> <span class="pre">=</span> <span class="pre">-p.cross(p.cross(a))</span> <span class="pre">=</span>
<span class="pre">px²</span> <span class="pre">*</span> <span class="pre">a</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UnitInertia_[AutoDiffXd].ReExpress">
<code class="descname">ReExpress</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UnitInertia_[AutoDiffXd], R_AE: pydrake.math.RotationMatrix_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[AutoDiffXd].ReExpress" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <code class="docutils literal notranslate"><span class="pre">this</span></code> unit inertia <code class="docutils literal notranslate"><span class="pre">G_BP_E</span></code> of a body B about a point P and
expressed in frame E, this method computes the same unit inertia
re-expressed in another frame A as <code class="docutils literal notranslate"><span class="pre">G_BP_A</span> <span class="pre">=</span> <span class="pre">R_AE</span> <span class="pre">*</span> <span class="pre">G_BP_E</span> <span class="pre">*</span>
<span class="pre">(R_AE)ᵀ</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_AE</span></code>:</dt>
<dd>RotationMatrix relating frames A and E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_BP_A</span></code>:</dt>
<dd>The same unit inertia for body B about point P but now
re-expressed in frame A.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UnitInertia_[AutoDiffXd].SetFromRotationalInertia">
<code class="descname">SetFromRotationalInertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UnitInertia_[AutoDiffXd], I: pydrake.multibody.tree.RotationalInertia_[AutoDiffXd], mass: pydrake.autodiffutils.AutoDiffXd</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[AutoDiffXd].SetFromRotationalInertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> unit inertia from a generally non-unit inertia I
corresponding to a body with a given <code class="docutils literal notranslate"><span class="pre">mass</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In Debug builds, this operation aborts if the provided <code class="docutils literal notranslate"><span class="pre">mass</span></code> is
not strictly positive.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UnitInertia_[AutoDiffXd].ShiftFromCenterOfMass">
<code class="descname">ShiftFromCenterOfMass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UnitInertia_[AutoDiffXd], p_BcmQ_E: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[AutoDiffXd].ShiftFromCenterOfMass" title="Permalink to this definition">¶</a></dt>
<dd><p>Shifts this central unit inertia to a different point, and returns the
result. See ShiftFromCenterOfMassInPlace() for details.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BcmQ_E</span></code>:</dt>
<dd>A vector from the body’s centroid <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> to point Q expressed in
the same frame E in which <code class="docutils literal notranslate"><span class="pre">this</span></code> inertia is expressed.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_BQ_E</span></code>:</dt>
<dd>This same unit inertia taken about a point Q instead of the
centroid <code class="docutils literal notranslate"><span class="pre">Bcm</span></code>.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UnitInertia_[AutoDiffXd].ShiftToCenterOfMass">
<code class="descname">ShiftToCenterOfMass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UnitInertia_[AutoDiffXd], p_QBcm_E: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[AutoDiffXd].ShiftToCenterOfMass" title="Permalink to this definition">¶</a></dt>
<dd><p>For the unit inertia <code class="docutils literal notranslate"><span class="pre">G_BQ_E</span></code> of a body or composite body B computed
about a point Q and expressed in a frame E, this method shifts this
inertia using the parallel axis theorem to be computed about the
center of mass <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> of B. See ShiftToCenterOfMassInPlace() for
details.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_QBcm_E</span></code>:</dt>
<dd>A position vector from the about point Q to the body’s centroid
<code class="docutils literal notranslate"><span class="pre">Bcm</span></code> expressed in the same frame E in which <code class="docutils literal notranslate"><span class="pre">this</span></code> inertia is
expressed.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_Bcm_E</span></code>:</dt>
<dd>This same unit which has now been taken about point <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> so
that it can be written as <code class="docutils literal notranslate"><span class="pre">G_BBcm_E</span></code>, or <code class="docutils literal notranslate"><span class="pre">G_Bcm_E</span></code>.</dd>
</dl>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This operation could result in a non-physical rotational inertia.
Use with care. See ShiftToCenterOfMassInPlace() for details.</p>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_[AutoDiffXd].SolidBox">
<em class="property">static </em><code class="descname">SolidBox</code><span class="sig-paren">(</span><em>Lx: pydrake.autodiffutils.AutoDiffXd</em>, <em>Ly: pydrake.autodiffutils.AutoDiffXd</em>, <em>Lz: pydrake.autodiffutils.AutoDiffXd</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[AutoDiffXd].SolidBox" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the unit inertia for a unit-mass solid box of uniform density
taken about its geometric center. If one length is zero the inertia
corresponds to that of a thin rectangular sheet. If two lengths are
zero the inertia corresponds to that of a thin rod in the remaining
direction.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Lx</span></code>:</dt>
<dd>The length of the box edge in the principal x-axis.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Ly</span></code>:</dt>
<dd>The length of the box edge in the principal y-axis.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Lz</span></code>:</dt>
<dd>The length of the box edge in the principal z-axis.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if any of Lx, Ly, Lz are negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_[AutoDiffXd].SolidCube">
<em class="property">static </em><code class="descname">SolidCube</code><span class="sig-paren">(</span><em>L: pydrake.autodiffutils.AutoDiffXd</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[AutoDiffXd].SolidCube" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the unit inertia for a unit-mass solid cube (a box with
equal-sized sides) of uniform density taken about its geometric
center.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">L</span></code>:</dt>
<dd>The length of each of the cube’s sides.</dd>
</dl>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_[AutoDiffXd].SolidCylinder">
<em class="property">static </em><code class="descname">SolidCylinder</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[AutoDiffXd].SolidCylinder" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>SolidCylinder(r: pydrake.autodiffutils.AutoDiffXd, L: pydrake.autodiffutils.AutoDiffXd, b_E: numpy.ndarray[object[3, 1]] = array([&lt;AutoDiffXd 0.0 nderiv=0&gt;, &lt;AutoDiffXd 0.0 nderiv=0&gt;,</dt>
<dd>&lt;AutoDiffXd 1.0 nderiv=0&gt;], dtype=object)) -&gt; pydrake.multibody.tree.UnitInertia_[AutoDiffXd]</dd>
</dl>
<p>Computes the unit inertia for a unit-mass cylinder B, of uniform
density, having its axis of revolution along input vector <code class="docutils literal notranslate"><span class="pre">b_E</span></code>. The
resulting unit inertia is computed about the cylinder’s center of mass
<code class="docutils literal notranslate"><span class="pre">Bcm</span></code> and is expressed in the same frame E as the input axis of
revolution <code class="docutils literal notranslate"><span class="pre">b_E</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">r</span></code>:</dt>
<dd>The radius of the cylinder, it must be non-negative.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">L</span></code>:</dt>
<dd>The length of the cylinder, it must be non-negative.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b_E</span></code>:</dt>
<dd>Vector defining the axis of revolution of the cylinder, expressed
in a frame E. <code class="docutils literal notranslate"><span class="pre">b_E</span></code> can have a norm different from one; however,
it will be normalized before using it. Therefore its norm is
ignored and only its direction is used. It defaults to
<code class="docutils literal notranslate"><span class="pre">Vector3&lt;T&gt;::UnitZ()</span></code>.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_Bcm_E</span></code>:</dt>
<dd>The unit inertia for a solid cylinder B, of uniform density, with
axis of revolution along <code class="docutils literal notranslate"><span class="pre">b_E</span></code>, computed about the cylinder’s
center of mass <code class="docutils literal notranslate"><span class="pre">Bcm</span></code>, and expressed in the same frame E as the
input axis of rotation <code class="docutils literal notranslate"><span class="pre">b_E</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError - Radius r is negative. - Length L is negative. -</li>
<li><code class="docutils literal notranslate"><span class="pre">b_E</span></code> is the zero vector. That is if <code class="docutils literal notranslate"><span class="pre">‖b_E‖₂</span> <span class="pre">≤</span> <span class="pre">ε</span></code>, where ε is</li>
<li>the machine epsilon.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_[AutoDiffXd].SolidCylinderAboutEnd">
<em class="property">static </em><code class="descname">SolidCylinderAboutEnd</code><span class="sig-paren">(</span><em>r: pydrake.autodiffutils.AutoDiffXd</em>, <em>L: pydrake.autodiffutils.AutoDiffXd</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[AutoDiffXd].SolidCylinderAboutEnd" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the unit inertia for a unit-mass cylinder of uniform density
oriented along the z-axis computed about a point at the center of its
base.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">r</span></code>:</dt>
<dd>The radius of the cylinder.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">L</span></code>:</dt>
<dd>The length of the cylinder.</dd>
</dl>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_[AutoDiffXd].SolidSphere">
<em class="property">static </em><code class="descname">SolidSphere</code><span class="sig-paren">(</span><em>r: pydrake.autodiffutils.AutoDiffXd</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[AutoDiffXd].SolidSphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the unit inertia for a unit-mass solid sphere of uniform
density and radius <code class="docutils literal notranslate"><span class="pre">r</span></code> taken about its center.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_[AutoDiffXd].StraightLine">
<em class="property">static </em><code class="descname">StraightLine</code><span class="sig-paren">(</span><em>K: pydrake.autodiffutils.AutoDiffXd, b_E: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[AutoDiffXd].StraightLine" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the unit inertia for a body B of unit-mass uniformly
distributed along a straight, finite, line L with direction <code class="docutils literal notranslate"><span class="pre">b_E</span></code>
and with moment of inertia K about any axis perpendicular to this
line. Since the mass of the body is uniformly distributed on this line
L, its center of mass is located right at the center. As an example,
consider the inertia of a thin rod for which its transversal
dimensions can be neglected, see ThinRod().</p>
<p>This method aborts if K is not positive.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is the particular case for an axially symmetric unit inertia
with zero moment about its axis, see AxiallySymmetric().</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">K</span></code>:</dt>
<dd>Unit inertia about any axis perpendicular to the line.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b_E</span></code>:</dt>
<dd>Vector defining the direction of the line, expressed in a frame E.
<code class="docutils literal notranslate"><span class="pre">b_E</span></code> can have a norm different from one. Its norm is ignored
and only its direction is needed.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_Bcm_E</span></code>:</dt>
<dd>The unit inertia for a body B of unit mass uniformly distributed
along a straight line L, about its center of mass <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> which is
located at the center of the line, expressed in the same frame E
as the input unit vector <code class="docutils literal notranslate"><span class="pre">b_E</span></code>.</dd>
</dl>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_[AutoDiffXd].ThinRod">
<em class="property">static </em><code class="descname">ThinRod</code><span class="sig-paren">(</span><em>L: pydrake.autodiffutils.AutoDiffXd, b_E: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[AutoDiffXd].ThinRod" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the unit inertia for a unit mass rod B of length L, about its
center of mass, with its mass uniformly distributed along a line
parallel to vector <code class="docutils literal notranslate"><span class="pre">b_E</span></code>.</p>
<p>This method aborts if L is not positive.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">L</span></code>:</dt>
<dd>The length of the rod. It must be positive.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b_E</span></code>:</dt>
<dd>Vector defining the axis of the rod, expressed in a frame E.
<code class="docutils literal notranslate"><span class="pre">b_E</span></code> can have a norm different from one. Its norm is ignored
and only its direction is needed.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_Bcm_E</span></code>:</dt>
<dd>The unit inertia of the rod B about its center of mass <code class="docutils literal notranslate"><span class="pre">Bcm</span></code>,
expressed in the same frame E as the input unit vector <code class="docutils literal notranslate"><span class="pre">b_E</span></code>.</dd>
</dl>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_[AutoDiffXd].TriaxiallySymmetric">
<em class="property">static </em><code class="descname">TriaxiallySymmetric</code><span class="sig-paren">(</span><em>I_triaxial: pydrake.autodiffutils.AutoDiffXd</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[AutoDiffXd].TriaxiallySymmetric" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.UnitInertia_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">UnitInertia_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.RotationalInertia_[Expression]" title="pydrake.multibody.tree.RotationalInertia_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.RotationalInertia_[Expression]</span></code></a></p>
<p>This class is used to represent rotational inertias for unit mass
bodies. Therefore, unlike RotationalInertia whose units are kg⋅m², the
units of a UnitInertia are those of length squared. A unit inertia is
a useful concept to represent the geometric distribution of mass in a
body regardless of the actual value of the body mass. The rotational
inertia of a body can therefore be obtained by multiplying its unit
inertia by its mass. Unit inertia matrices can also be called
<strong>gyration</strong> matrices and therefore we choose to represent them in
source code notation with the capital letter G. In contrast, the
capital letter I is used to represent non-unit mass rotational
inertias. This class restricts the set of allowed operations on a unit
inertia to ensure the unit-mass invariant. For instance,
multiplication by a scalar can only return a general RotationalInertia
but not a UnitInertia.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class has no means to check at construction from user
provided parameters whether it actually represents the unit
inertia or gyration matrix of a unit-mass body. However, as
previously noted, once a unit inertia is created, a number of
operations are disallowed to ensure the unit-mass invariant. Also
notice that once a unit inertia is created, it <em>is</em> the unit
inertia of <em>some</em> body, perhaps with scaled geometry from the
user’s intention.</p>
</div>
<dl class="method">
<dt id="pydrake.multibody.tree.UnitInertia_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.UnitInertia_[Expression]) -&gt; None</li>
</ol>
<p>Default UnitInertia constructor sets all entries to NaN for quick
detection of uninitialized values.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.UnitInertia_[Expression], Ixx: pydrake.symbolic.Expression, Iyy: pydrake.symbolic.Expression, Izz: pydrake.symbolic.Expression) -&gt; None</li>
</ol>
<p>Creates a unit inertia with moments of inertia <code class="docutils literal notranslate"><span class="pre">Ixx</span></code>, <cite>Iyy</cite>,
<code class="docutils literal notranslate"><span class="pre">Izz</span></code>, and with each product of inertia set to zero. In debug
builds, throws RuntimeError if unit inertia constructed from these
arguments violates RotationalInertia::CouldBePhysicallyValid().</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.tree.UnitInertia_[Expression], Ixx: pydrake.symbolic.Expression, Iyy: pydrake.symbolic.Expression, Izz: pydrake.symbolic.Expression, Ixy: pydrake.symbolic.Expression, Ixz: pydrake.symbolic.Expression, Iyz: pydrake.symbolic.Expression) -&gt; None</li>
</ol>
<p>Creates a unit inertia with moments of inertia <code class="docutils literal notranslate"><span class="pre">Ixx</span></code>, <cite>Iyy</cite>,
<code class="docutils literal notranslate"><span class="pre">Izz</span></code>, and with products of inertia <code class="docutils literal notranslate"><span class="pre">Ixy</span></code>, <cite>Ixz</cite>, <code class="docutils literal notranslate"><span class="pre">Iyz</span></code>. In
debug builds, throws RuntimeError if unit inertia constructed from
these arguments violates RotationalInertia::CouldBePhysicallyValid().</p>
<ol class="arabic simple" start="4">
<li>__init__(self: pydrake.multibody.tree.UnitInertia_[Expression], I: pydrake.multibody.tree.RotationalInertia_[Expression]) -&gt; None</li>
</ol>
<p>Constructs a UnitInertia from a RotationalInertia. This constructor
has no way to verify that the input rotational inertia actually is a
unit inertia. But the construction will nevertheless succeed, and the
values of the input rotational inertia will henceforth be considered a
valid unit inertia. It is the responsibility of the user to pass a
valid unit inertia.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_[Expression].AxiallySymmetric">
<em class="property">static </em><code class="descname">AxiallySymmetric</code><span class="sig-paren">(</span><em>J: pydrake.symbolic.Expression, K: pydrake.symbolic.Expression, b_E: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[Expression].AxiallySymmetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the unit inertia for a unit-mass body B for which there exists
a line L passing through the body’s center of mass <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> having the
property that the body’s moment of inertia about all lines
perpendicular to L are equal. Examples of bodies with an axially
symmetric inertia include axisymmetric objects such as cylinders and
cones. Other commonly occurring geometries with this property are, for
instance, propellers with 3+ evenly spaced blades. Given a unit vector
b defining the symmetry line L, the moment of inertia J about this
line L and the moment of inertia K about any line perpendicular to L,
the axially symmetric unit inertia G is computed as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>G = K * Id + (J - K) * b ⊗ b
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">Id</span></code> is the identity matrix and ⊗ denotes the tensor product
operator. See Mitiguy, P., 2016. Advanced Dynamics &amp; Motion
Simulation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError - J is negative. J can be zero. - K is negative. K</li>
<li>can be zero. - J ≤ 2 * K, this corresponds to the triangle</li>
<li>inequality, see CouldBePhysicallyValid(). - <code class="docutils literal notranslate"><span class="pre">b_E</span></code> is the zero</li>
<li>vector. That is if <code class="docutils literal notranslate"><span class="pre">‖b_E‖₂</span> <span class="pre">≤</span> <span class="pre">ε</span></code>, where ε is the machine epsilon.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">J is a principal moment of inertia with principal axis equal to b.
K is a principal moment with multiplicity of two. Any two axes
perpendicular to b are principal axes with principal moment K.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">J</span></code>:</dt>
<dd>Unit inertia about axis b.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">K</span></code>:</dt>
<dd>Unit inertia about any axis perpendicular to b.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b_E</span></code>:</dt>
<dd>Vector defining the symmetry axis, expressed in a frame E. <code class="docutils literal notranslate"><span class="pre">b_E</span></code>
can have a norm different from one; however, it will be normalized
before using it. Therefore its norm is ignored and only its
direction is used.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_Bcm_E</span></code>:</dt>
<dd>An axially symmetric unit inertia about body B’s center of mass,
expressed in the same frame E as the input unit vector <code class="docutils literal notranslate"><span class="pre">b_E</span></code>.</dd>
</dl>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_[Expression].HollowSphere">
<em class="property">static </em><code class="descname">HollowSphere</code><span class="sig-paren">(</span><em>r: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[Expression].HollowSphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the unit inertia for a unit-mass hollow sphere of radius
<code class="docutils literal notranslate"><span class="pre">r</span></code> consisting of an infinitesimally thin shell of uniform density.
The unit inertia is taken about the center of the sphere.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_[Expression].PointMass">
<em class="property">static </em><code class="descname">PointMass</code><span class="sig-paren">(</span><em>p_FQ: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[Expression].PointMass" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a unit inertia for a point mass of unit mass located at
point Q, whose location in a frame F is given by the position vector
<code class="docutils literal notranslate"><span class="pre">p_FQ</span></code> (that is, p_FoQ_F). The unit inertia <code class="docutils literal notranslate"><span class="pre">G_QFo_F</span></code> of point
mass Q about the origin <code class="docutils literal notranslate"><span class="pre">Fo</span></code> of frame F and expressed in F for this
unit mass point equals the square of the cross product matrix of
<code class="docutils literal notranslate"><span class="pre">p_FQ</span></code>. In coordinate-free form:</p>
<div class="math notranslate nohighlight">
\[G^{Q/F_o} = (^Fp^Q_\times)^2 = (^Fp^Q_\times)^T \, ^Fp^Q_\times =
-^Fp^Q_\times \, ^Fp^Q_\times\]</div>
<p>where <span class="math notranslate nohighlight">\(^Fp^Q_\times\)</span> is the cross product matrix of vector
<span class="math notranslate nohighlight">\(^Fp^Q\)</span>. In source code the above expression is written as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>G_QFo_F = px_FQ² = px_FQᵀ * px_FQ = -px_FQ * px_FQ
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">px_FQ</span></code> denotes the cross product matrix of the position
vector <code class="docutils literal notranslate"><span class="pre">p_FQ</span></code> (expressed in F) such that the cross product with
another vector <code class="docutils literal notranslate"><span class="pre">a</span></code> can be obtained as <code class="docutils literal notranslate"><span class="pre">px.cross(a)</span> <span class="pre">=</span> <span class="pre">px</span> <span class="pre">*</span> <span class="pre">a</span></code>. The
cross product matrix <code class="docutils literal notranslate"><span class="pre">px</span></code> is skew-symmetric. The square of the cross
product matrix is a symmetric matrix with non-negative diagonals and
obeys the triangle inequality. Matrix <code class="docutils literal notranslate"><span class="pre">px²</span></code> can be used to compute
the triple vector product as <code class="docutils literal notranslate"><span class="pre">-p</span> <span class="pre">x</span> <span class="pre">(p</span> <span class="pre">x</span> <span class="pre">a)</span> <span class="pre">=</span> <span class="pre">-p.cross(p.cross(a))</span> <span class="pre">=</span>
<span class="pre">px²</span> <span class="pre">*</span> <span class="pre">a</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UnitInertia_[Expression].ReExpress">
<code class="descname">ReExpress</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UnitInertia_[Expression], R_AE: pydrake.math.RotationMatrix_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[Expression].ReExpress" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <code class="docutils literal notranslate"><span class="pre">this</span></code> unit inertia <code class="docutils literal notranslate"><span class="pre">G_BP_E</span></code> of a body B about a point P and
expressed in frame E, this method computes the same unit inertia
re-expressed in another frame A as <code class="docutils literal notranslate"><span class="pre">G_BP_A</span> <span class="pre">=</span> <span class="pre">R_AE</span> <span class="pre">*</span> <span class="pre">G_BP_E</span> <span class="pre">*</span>
<span class="pre">(R_AE)ᵀ</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_AE</span></code>:</dt>
<dd>RotationMatrix relating frames A and E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_BP_A</span></code>:</dt>
<dd>The same unit inertia for body B about point P but now
re-expressed in frame A.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UnitInertia_[Expression].SetFromRotationalInertia">
<code class="descname">SetFromRotationalInertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UnitInertia_[Expression], I: pydrake.multibody.tree.RotationalInertia_[Expression], mass: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[Expression].SetFromRotationalInertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> unit inertia from a generally non-unit inertia I
corresponding to a body with a given <code class="docutils literal notranslate"><span class="pre">mass</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In Debug builds, this operation aborts if the provided <code class="docutils literal notranslate"><span class="pre">mass</span></code> is
not strictly positive.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UnitInertia_[Expression].ShiftFromCenterOfMass">
<code class="descname">ShiftFromCenterOfMass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UnitInertia_[Expression], p_BcmQ_E: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[Expression].ShiftFromCenterOfMass" title="Permalink to this definition">¶</a></dt>
<dd><p>Shifts this central unit inertia to a different point, and returns the
result. See ShiftFromCenterOfMassInPlace() for details.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BcmQ_E</span></code>:</dt>
<dd>A vector from the body’s centroid <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> to point Q expressed in
the same frame E in which <code class="docutils literal notranslate"><span class="pre">this</span></code> inertia is expressed.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_BQ_E</span></code>:</dt>
<dd>This same unit inertia taken about a point Q instead of the
centroid <code class="docutils literal notranslate"><span class="pre">Bcm</span></code>.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UnitInertia_[Expression].ShiftToCenterOfMass">
<code class="descname">ShiftToCenterOfMass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UnitInertia_[Expression], p_QBcm_E: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[Expression].ShiftToCenterOfMass" title="Permalink to this definition">¶</a></dt>
<dd><p>For the unit inertia <code class="docutils literal notranslate"><span class="pre">G_BQ_E</span></code> of a body or composite body B computed
about a point Q and expressed in a frame E, this method shifts this
inertia using the parallel axis theorem to be computed about the
center of mass <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> of B. See ShiftToCenterOfMassInPlace() for
details.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_QBcm_E</span></code>:</dt>
<dd>A position vector from the about point Q to the body’s centroid
<code class="docutils literal notranslate"><span class="pre">Bcm</span></code> expressed in the same frame E in which <code class="docutils literal notranslate"><span class="pre">this</span></code> inertia is
expressed.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_Bcm_E</span></code>:</dt>
<dd>This same unit which has now been taken about point <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> so
that it can be written as <code class="docutils literal notranslate"><span class="pre">G_BBcm_E</span></code>, or <code class="docutils literal notranslate"><span class="pre">G_Bcm_E</span></code>.</dd>
</dl>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This operation could result in a non-physical rotational inertia.
Use with care. See ShiftToCenterOfMassInPlace() for details.</p>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_[Expression].SolidBox">
<em class="property">static </em><code class="descname">SolidBox</code><span class="sig-paren">(</span><em>Lx: pydrake.symbolic.Expression</em>, <em>Ly: pydrake.symbolic.Expression</em>, <em>Lz: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[Expression].SolidBox" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the unit inertia for a unit-mass solid box of uniform density
taken about its geometric center. If one length is zero the inertia
corresponds to that of a thin rectangular sheet. If two lengths are
zero the inertia corresponds to that of a thin rod in the remaining
direction.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Lx</span></code>:</dt>
<dd>The length of the box edge in the principal x-axis.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Ly</span></code>:</dt>
<dd>The length of the box edge in the principal y-axis.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Lz</span></code>:</dt>
<dd>The length of the box edge in the principal z-axis.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if any of Lx, Ly, Lz are negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_[Expression].SolidCube">
<em class="property">static </em><code class="descname">SolidCube</code><span class="sig-paren">(</span><em>L: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[Expression].SolidCube" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the unit inertia for a unit-mass solid cube (a box with
equal-sized sides) of uniform density taken about its geometric
center.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">L</span></code>:</dt>
<dd>The length of each of the cube’s sides.</dd>
</dl>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_[Expression].SolidCylinder">
<em class="property">static </em><code class="descname">SolidCylinder</code><span class="sig-paren">(</span><em>r: pydrake.symbolic.Expression, L: pydrake.symbolic.Expression, b_E: numpy.ndarray[object[3, 1]] = array([&lt;Expression &quot;0&quot;&gt;, &lt;Expression &quot;0&quot;&gt;, &lt;Expression &quot;1&quot;&gt;], dtype=object)</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[Expression].SolidCylinder" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the unit inertia for a unit-mass cylinder B, of uniform
density, having its axis of revolution along input vector <code class="docutils literal notranslate"><span class="pre">b_E</span></code>. The
resulting unit inertia is computed about the cylinder’s center of mass
<code class="docutils literal notranslate"><span class="pre">Bcm</span></code> and is expressed in the same frame E as the input axis of
revolution <code class="docutils literal notranslate"><span class="pre">b_E</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">r</span></code>:</dt>
<dd>The radius of the cylinder, it must be non-negative.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">L</span></code>:</dt>
<dd>The length of the cylinder, it must be non-negative.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b_E</span></code>:</dt>
<dd>Vector defining the axis of revolution of the cylinder, expressed
in a frame E. <code class="docutils literal notranslate"><span class="pre">b_E</span></code> can have a norm different from one; however,
it will be normalized before using it. Therefore its norm is
ignored and only its direction is used. It defaults to
<code class="docutils literal notranslate"><span class="pre">Vector3&lt;T&gt;::UnitZ()</span></code>.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_Bcm_E</span></code>:</dt>
<dd>The unit inertia for a solid cylinder B, of uniform density, with
axis of revolution along <code class="docutils literal notranslate"><span class="pre">b_E</span></code>, computed about the cylinder’s
center of mass <code class="docutils literal notranslate"><span class="pre">Bcm</span></code>, and expressed in the same frame E as the
input axis of rotation <code class="docutils literal notranslate"><span class="pre">b_E</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError - Radius r is negative. - Length L is negative. -</li>
<li><code class="docutils literal notranslate"><span class="pre">b_E</span></code> is the zero vector. That is if <code class="docutils literal notranslate"><span class="pre">‖b_E‖₂</span> <span class="pre">≤</span> <span class="pre">ε</span></code>, where ε is</li>
<li>the machine epsilon.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_[Expression].SolidCylinderAboutEnd">
<em class="property">static </em><code class="descname">SolidCylinderAboutEnd</code><span class="sig-paren">(</span><em>r: pydrake.symbolic.Expression</em>, <em>L: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[Expression].SolidCylinderAboutEnd" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the unit inertia for a unit-mass cylinder of uniform density
oriented along the z-axis computed about a point at the center of its
base.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">r</span></code>:</dt>
<dd>The radius of the cylinder.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">L</span></code>:</dt>
<dd>The length of the cylinder.</dd>
</dl>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_[Expression].SolidSphere">
<em class="property">static </em><code class="descname">SolidSphere</code><span class="sig-paren">(</span><em>r: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[Expression].SolidSphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the unit inertia for a unit-mass solid sphere of uniform
density and radius <code class="docutils literal notranslate"><span class="pre">r</span></code> taken about its center.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_[Expression].StraightLine">
<em class="property">static </em><code class="descname">StraightLine</code><span class="sig-paren">(</span><em>K: pydrake.symbolic.Expression, b_E: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[Expression].StraightLine" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the unit inertia for a body B of unit-mass uniformly
distributed along a straight, finite, line L with direction <code class="docutils literal notranslate"><span class="pre">b_E</span></code>
and with moment of inertia K about any axis perpendicular to this
line. Since the mass of the body is uniformly distributed on this line
L, its center of mass is located right at the center. As an example,
consider the inertia of a thin rod for which its transversal
dimensions can be neglected, see ThinRod().</p>
<p>This method aborts if K is not positive.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is the particular case for an axially symmetric unit inertia
with zero moment about its axis, see AxiallySymmetric().</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">K</span></code>:</dt>
<dd>Unit inertia about any axis perpendicular to the line.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b_E</span></code>:</dt>
<dd>Vector defining the direction of the line, expressed in a frame E.
<code class="docutils literal notranslate"><span class="pre">b_E</span></code> can have a norm different from one. Its norm is ignored
and only its direction is needed.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_Bcm_E</span></code>:</dt>
<dd>The unit inertia for a body B of unit mass uniformly distributed
along a straight line L, about its center of mass <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> which is
located at the center of the line, expressed in the same frame E
as the input unit vector <code class="docutils literal notranslate"><span class="pre">b_E</span></code>.</dd>
</dl>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_[Expression].ThinRod">
<em class="property">static </em><code class="descname">ThinRod</code><span class="sig-paren">(</span><em>L: pydrake.symbolic.Expression, b_E: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[Expression].ThinRod" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the unit inertia for a unit mass rod B of length L, about its
center of mass, with its mass uniformly distributed along a line
parallel to vector <code class="docutils literal notranslate"><span class="pre">b_E</span></code>.</p>
<p>This method aborts if L is not positive.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">L</span></code>:</dt>
<dd>The length of the rod. It must be positive.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b_E</span></code>:</dt>
<dd>Vector defining the axis of the rod, expressed in a frame E.
<code class="docutils literal notranslate"><span class="pre">b_E</span></code> can have a norm different from one. Its norm is ignored
and only its direction is needed.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_Bcm_E</span></code>:</dt>
<dd>The unit inertia of the rod B about its center of mass <code class="docutils literal notranslate"><span class="pre">Bcm</span></code>,
expressed in the same frame E as the input unit vector <code class="docutils literal notranslate"><span class="pre">b_E</span></code>.</dd>
</dl>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_[Expression].TriaxiallySymmetric">
<em class="property">static </em><code class="descname">TriaxiallySymmetric</code><span class="sig-paren">(</span><em>I_triaxial: pydrake.symbolic.Expression</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[Expression].TriaxiallySymmetric" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.UnitInertia_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">UnitInertia_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.RotationalInertia_[float]" title="pydrake.multibody.tree.RotationalInertia_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.RotationalInertia_[float]</span></code></a></p>
<p>This class is used to represent rotational inertias for unit mass
bodies. Therefore, unlike RotationalInertia whose units are kg⋅m², the
units of a UnitInertia are those of length squared. A unit inertia is
a useful concept to represent the geometric distribution of mass in a
body regardless of the actual value of the body mass. The rotational
inertia of a body can therefore be obtained by multiplying its unit
inertia by its mass. Unit inertia matrices can also be called
<strong>gyration</strong> matrices and therefore we choose to represent them in
source code notation with the capital letter G. In contrast, the
capital letter I is used to represent non-unit mass rotational
inertias. This class restricts the set of allowed operations on a unit
inertia to ensure the unit-mass invariant. For instance,
multiplication by a scalar can only return a general RotationalInertia
but not a UnitInertia.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This class has no means to check at construction from user
provided parameters whether it actually represents the unit
inertia or gyration matrix of a unit-mass body. However, as
previously noted, once a unit inertia is created, a number of
operations are disallowed to ensure the unit-mass invariant. Also
notice that once a unit inertia is created, it <em>is</em> the unit
inertia of <em>some</em> body, perhaps with scaled geometry from the
user’s intention.</p>
</div>
<dl class="method">
<dt id="pydrake.multibody.tree.UnitInertia_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.UnitInertia_[float]) -&gt; None</li>
</ol>
<p>Default UnitInertia constructor sets all entries to NaN for quick
detection of uninitialized values.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.UnitInertia_[float], Ixx: float, Iyy: float, Izz: float) -&gt; None</li>
</ol>
<p>Creates a unit inertia with moments of inertia <code class="docutils literal notranslate"><span class="pre">Ixx</span></code>, <cite>Iyy</cite>,
<code class="docutils literal notranslate"><span class="pre">Izz</span></code>, and with each product of inertia set to zero. In debug
builds, throws RuntimeError if unit inertia constructed from these
arguments violates RotationalInertia::CouldBePhysicallyValid().</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.tree.UnitInertia_[float], Ixx: float, Iyy: float, Izz: float, Ixy: float, Ixz: float, Iyz: float) -&gt; None</li>
</ol>
<p>Creates a unit inertia with moments of inertia <code class="docutils literal notranslate"><span class="pre">Ixx</span></code>, <cite>Iyy</cite>,
<code class="docutils literal notranslate"><span class="pre">Izz</span></code>, and with products of inertia <code class="docutils literal notranslate"><span class="pre">Ixy</span></code>, <cite>Ixz</cite>, <code class="docutils literal notranslate"><span class="pre">Iyz</span></code>. In
debug builds, throws RuntimeError if unit inertia constructed from
these arguments violates RotationalInertia::CouldBePhysicallyValid().</p>
<ol class="arabic simple" start="4">
<li>__init__(self: pydrake.multibody.tree.UnitInertia_[float], I: pydrake.multibody.tree.RotationalInertia_[float]) -&gt; None</li>
</ol>
<p>Constructs a UnitInertia from a RotationalInertia. This constructor
has no way to verify that the input rotational inertia actually is a
unit inertia. But the construction will nevertheless succeed, and the
values of the input rotational inertia will henceforth be considered a
valid unit inertia. It is the responsibility of the user to pass a
valid unit inertia.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_[float].AxiallySymmetric">
<em class="property">static </em><code class="descname">AxiallySymmetric</code><span class="sig-paren">(</span><em>J: float, K: float, b_E: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[float].AxiallySymmetric" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the unit inertia for a unit-mass body B for which there exists
a line L passing through the body’s center of mass <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> having the
property that the body’s moment of inertia about all lines
perpendicular to L are equal. Examples of bodies with an axially
symmetric inertia include axisymmetric objects such as cylinders and
cones. Other commonly occurring geometries with this property are, for
instance, propellers with 3+ evenly spaced blades. Given a unit vector
b defining the symmetry line L, the moment of inertia J about this
line L and the moment of inertia K about any line perpendicular to L,
the axially symmetric unit inertia G is computed as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>G = K * Id + (J - K) * b ⊗ b
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">Id</span></code> is the identity matrix and ⊗ denotes the tensor product
operator. See Mitiguy, P., 2016. Advanced Dynamics &amp; Motion
Simulation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError - J is negative. J can be zero. - K is negative. K</li>
<li>can be zero. - J ≤ 2 * K, this corresponds to the triangle</li>
<li>inequality, see CouldBePhysicallyValid(). - <code class="docutils literal notranslate"><span class="pre">b_E</span></code> is the zero</li>
<li>vector. That is if <code class="docutils literal notranslate"><span class="pre">‖b_E‖₂</span> <span class="pre">≤</span> <span class="pre">ε</span></code>, where ε is the machine epsilon.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">J is a principal moment of inertia with principal axis equal to b.
K is a principal moment with multiplicity of two. Any two axes
perpendicular to b are principal axes with principal moment K.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">J</span></code>:</dt>
<dd>Unit inertia about axis b.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">K</span></code>:</dt>
<dd>Unit inertia about any axis perpendicular to b.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b_E</span></code>:</dt>
<dd>Vector defining the symmetry axis, expressed in a frame E. <code class="docutils literal notranslate"><span class="pre">b_E</span></code>
can have a norm different from one; however, it will be normalized
before using it. Therefore its norm is ignored and only its
direction is used.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_Bcm_E</span></code>:</dt>
<dd>An axially symmetric unit inertia about body B’s center of mass,
expressed in the same frame E as the input unit vector <code class="docutils literal notranslate"><span class="pre">b_E</span></code>.</dd>
</dl>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_[float].HollowSphere">
<em class="property">static </em><code class="descname">HollowSphere</code><span class="sig-paren">(</span><em>r: float</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[float].HollowSphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the unit inertia for a unit-mass hollow sphere of radius
<code class="docutils literal notranslate"><span class="pre">r</span></code> consisting of an infinitesimally thin shell of uniform density.
The unit inertia is taken about the center of the sphere.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_[float].PointMass">
<em class="property">static </em><code class="descname">PointMass</code><span class="sig-paren">(</span><em>p_FQ: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[float].PointMass" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a unit inertia for a point mass of unit mass located at
point Q, whose location in a frame F is given by the position vector
<code class="docutils literal notranslate"><span class="pre">p_FQ</span></code> (that is, p_FoQ_F). The unit inertia <code class="docutils literal notranslate"><span class="pre">G_QFo_F</span></code> of point
mass Q about the origin <code class="docutils literal notranslate"><span class="pre">Fo</span></code> of frame F and expressed in F for this
unit mass point equals the square of the cross product matrix of
<code class="docutils literal notranslate"><span class="pre">p_FQ</span></code>. In coordinate-free form:</p>
<div class="math notranslate nohighlight">
\[G^{Q/F_o} = (^Fp^Q_\times)^2 = (^Fp^Q_\times)^T \, ^Fp^Q_\times =
-^Fp^Q_\times \, ^Fp^Q_\times\]</div>
<p>where <span class="math notranslate nohighlight">\(^Fp^Q_\times\)</span> is the cross product matrix of vector
<span class="math notranslate nohighlight">\(^Fp^Q\)</span>. In source code the above expression is written as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>G_QFo_F = px_FQ² = px_FQᵀ * px_FQ = -px_FQ * px_FQ
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">px_FQ</span></code> denotes the cross product matrix of the position
vector <code class="docutils literal notranslate"><span class="pre">p_FQ</span></code> (expressed in F) such that the cross product with
another vector <code class="docutils literal notranslate"><span class="pre">a</span></code> can be obtained as <code class="docutils literal notranslate"><span class="pre">px.cross(a)</span> <span class="pre">=</span> <span class="pre">px</span> <span class="pre">*</span> <span class="pre">a</span></code>. The
cross product matrix <code class="docutils literal notranslate"><span class="pre">px</span></code> is skew-symmetric. The square of the cross
product matrix is a symmetric matrix with non-negative diagonals and
obeys the triangle inequality. Matrix <code class="docutils literal notranslate"><span class="pre">px²</span></code> can be used to compute
the triple vector product as <code class="docutils literal notranslate"><span class="pre">-p</span> <span class="pre">x</span> <span class="pre">(p</span> <span class="pre">x</span> <span class="pre">a)</span> <span class="pre">=</span> <span class="pre">-p.cross(p.cross(a))</span> <span class="pre">=</span>
<span class="pre">px²</span> <span class="pre">*</span> <span class="pre">a</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UnitInertia_[float].ReExpress">
<code class="descname">ReExpress</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UnitInertia_[float], R_AE: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[float].ReExpress" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <code class="docutils literal notranslate"><span class="pre">this</span></code> unit inertia <code class="docutils literal notranslate"><span class="pre">G_BP_E</span></code> of a body B about a point P and
expressed in frame E, this method computes the same unit inertia
re-expressed in another frame A as <code class="docutils literal notranslate"><span class="pre">G_BP_A</span> <span class="pre">=</span> <span class="pre">R_AE</span> <span class="pre">*</span> <span class="pre">G_BP_E</span> <span class="pre">*</span>
<span class="pre">(R_AE)ᵀ</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">R_AE</span></code>:</dt>
<dd>RotationMatrix relating frames A and E.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_BP_A</span></code>:</dt>
<dd>The same unit inertia for body B about point P but now
re-expressed in frame A.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UnitInertia_[float].SetFromRotationalInertia">
<code class="descname">SetFromRotationalInertia</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UnitInertia_[float], I: pydrake.multibody.tree.RotationalInertia_[float], mass: float</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[float].SetFromRotationalInertia" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets <code class="docutils literal notranslate"><span class="pre">this</span></code> unit inertia from a generally non-unit inertia I
corresponding to a body with a given <code class="docutils literal notranslate"><span class="pre">mass</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In Debug builds, this operation aborts if the provided <code class="docutils literal notranslate"><span class="pre">mass</span></code> is
not strictly positive.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UnitInertia_[float].ShiftFromCenterOfMass">
<code class="descname">ShiftFromCenterOfMass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UnitInertia_[float], p_BcmQ_E: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[float].ShiftFromCenterOfMass" title="Permalink to this definition">¶</a></dt>
<dd><p>Shifts this central unit inertia to a different point, and returns the
result. See ShiftFromCenterOfMassInPlace() for details.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BcmQ_E</span></code>:</dt>
<dd>A vector from the body’s centroid <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> to point Q expressed in
the same frame E in which <code class="docutils literal notranslate"><span class="pre">this</span></code> inertia is expressed.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_BQ_E</span></code>:</dt>
<dd>This same unit inertia taken about a point Q instead of the
centroid <code class="docutils literal notranslate"><span class="pre">Bcm</span></code>.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UnitInertia_[float].ShiftToCenterOfMass">
<code class="descname">ShiftToCenterOfMass</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UnitInertia_[float], p_QBcm_E: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[float].ShiftToCenterOfMass" title="Permalink to this definition">¶</a></dt>
<dd><p>For the unit inertia <code class="docutils literal notranslate"><span class="pre">G_BQ_E</span></code> of a body or composite body B computed
about a point Q and expressed in a frame E, this method shifts this
inertia using the parallel axis theorem to be computed about the
center of mass <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> of B. See ShiftToCenterOfMassInPlace() for
details.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_QBcm_E</span></code>:</dt>
<dd>A position vector from the about point Q to the body’s centroid
<code class="docutils literal notranslate"><span class="pre">Bcm</span></code> expressed in the same frame E in which <code class="docutils literal notranslate"><span class="pre">this</span></code> inertia is
expressed.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_Bcm_E</span></code>:</dt>
<dd>This same unit which has now been taken about point <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> so
that it can be written as <code class="docutils literal notranslate"><span class="pre">G_BBcm_E</span></code>, or <code class="docutils literal notranslate"><span class="pre">G_Bcm_E</span></code>.</dd>
</dl>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This operation could result in a non-physical rotational inertia.
Use with care. See ShiftToCenterOfMassInPlace() for details.</p>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_[float].SolidBox">
<em class="property">static </em><code class="descname">SolidBox</code><span class="sig-paren">(</span><em>Lx: float</em>, <em>Ly: float</em>, <em>Lz: float</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[float].SolidBox" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the unit inertia for a unit-mass solid box of uniform density
taken about its geometric center. If one length is zero the inertia
corresponds to that of a thin rectangular sheet. If two lengths are
zero the inertia corresponds to that of a thin rod in the remaining
direction.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Lx</span></code>:</dt>
<dd>The length of the box edge in the principal x-axis.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Ly</span></code>:</dt>
<dd>The length of the box edge in the principal y-axis.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">Lz</span></code>:</dt>
<dd>The length of the box edge in the principal z-axis.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if any of Lx, Ly, Lz are negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_[float].SolidCube">
<em class="property">static </em><code class="descname">SolidCube</code><span class="sig-paren">(</span><em>L: float</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[float].SolidCube" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the unit inertia for a unit-mass solid cube (a box with
equal-sized sides) of uniform density taken about its geometric
center.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">L</span></code>:</dt>
<dd>The length of each of the cube’s sides.</dd>
</dl>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_[float].SolidCylinder">
<em class="property">static </em><code class="descname">SolidCylinder</code><span class="sig-paren">(</span><em>r: float</em>, <em>L: float</em>, <em>b_E: numpy.ndarray[numpy.float64[3</em>, <em>1]] = array([0.</em>, <em>0.</em>, <em>1.])</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[float].SolidCylinder" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the unit inertia for a unit-mass cylinder B, of uniform
density, having its axis of revolution along input vector <code class="docutils literal notranslate"><span class="pre">b_E</span></code>. The
resulting unit inertia is computed about the cylinder’s center of mass
<code class="docutils literal notranslate"><span class="pre">Bcm</span></code> and is expressed in the same frame E as the input axis of
revolution <code class="docutils literal notranslate"><span class="pre">b_E</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">r</span></code>:</dt>
<dd>The radius of the cylinder, it must be non-negative.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">L</span></code>:</dt>
<dd>The length of the cylinder, it must be non-negative.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b_E</span></code>:</dt>
<dd>Vector defining the axis of revolution of the cylinder, expressed
in a frame E. <code class="docutils literal notranslate"><span class="pre">b_E</span></code> can have a norm different from one; however,
it will be normalized before using it. Therefore its norm is
ignored and only its direction is used. It defaults to
<code class="docutils literal notranslate"><span class="pre">Vector3&lt;T&gt;::UnitZ()</span></code>.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_Bcm_E</span></code>:</dt>
<dd>The unit inertia for a solid cylinder B, of uniform density, with
axis of revolution along <code class="docutils literal notranslate"><span class="pre">b_E</span></code>, computed about the cylinder’s
center of mass <code class="docutils literal notranslate"><span class="pre">Bcm</span></code>, and expressed in the same frame E as the
input axis of rotation <code class="docutils literal notranslate"><span class="pre">b_E</span></code>.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>RuntimeError - Radius r is negative. - Length L is negative. -</li>
<li><code class="docutils literal notranslate"><span class="pre">b_E</span></code> is the zero vector. That is if <code class="docutils literal notranslate"><span class="pre">‖b_E‖₂</span> <span class="pre">≤</span> <span class="pre">ε</span></code>, where ε is</li>
<li>the machine epsilon.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_[float].SolidCylinderAboutEnd">
<em class="property">static </em><code class="descname">SolidCylinderAboutEnd</code><span class="sig-paren">(</span><em>r: float</em>, <em>L: float</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[float].SolidCylinderAboutEnd" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the unit inertia for a unit-mass cylinder of uniform density
oriented along the z-axis computed about a point at the center of its
base.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">r</span></code>:</dt>
<dd>The radius of the cylinder.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">L</span></code>:</dt>
<dd>The length of the cylinder.</dd>
</dl>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_[float].SolidSphere">
<em class="property">static </em><code class="descname">SolidSphere</code><span class="sig-paren">(</span><em>r: float</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[float].SolidSphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the unit inertia for a unit-mass solid sphere of uniform
density and radius <code class="docutils literal notranslate"><span class="pre">r</span></code> taken about its center.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_[float].StraightLine">
<em class="property">static </em><code class="descname">StraightLine</code><span class="sig-paren">(</span><em>K: float, b_E: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[float].StraightLine" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the unit inertia for a body B of unit-mass uniformly
distributed along a straight, finite, line L with direction <code class="docutils literal notranslate"><span class="pre">b_E</span></code>
and with moment of inertia K about any axis perpendicular to this
line. Since the mass of the body is uniformly distributed on this line
L, its center of mass is located right at the center. As an example,
consider the inertia of a thin rod for which its transversal
dimensions can be neglected, see ThinRod().</p>
<p>This method aborts if K is not positive.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is the particular case for an axially symmetric unit inertia
with zero moment about its axis, see AxiallySymmetric().</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">K</span></code>:</dt>
<dd>Unit inertia about any axis perpendicular to the line.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b_E</span></code>:</dt>
<dd>Vector defining the direction of the line, expressed in a frame E.
<code class="docutils literal notranslate"><span class="pre">b_E</span></code> can have a norm different from one. Its norm is ignored
and only its direction is needed.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_Bcm_E</span></code>:</dt>
<dd>The unit inertia for a body B of unit mass uniformly distributed
along a straight line L, about its center of mass <code class="docutils literal notranslate"><span class="pre">Bcm</span></code> which is
located at the center of the line, expressed in the same frame E
as the input unit vector <code class="docutils literal notranslate"><span class="pre">b_E</span></code>.</dd>
</dl>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_[float].ThinRod">
<em class="property">static </em><code class="descname">ThinRod</code><span class="sig-paren">(</span><em>L: float, b_E: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[float].ThinRod" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the unit inertia for a unit mass rod B of length L, about its
center of mass, with its mass uniformly distributed along a line
parallel to vector <code class="docutils literal notranslate"><span class="pre">b_E</span></code>.</p>
<p>This method aborts if L is not positive.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">L</span></code>:</dt>
<dd>The length of the rod. It must be positive.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">b_E</span></code>:</dt>
<dd>Vector defining the axis of the rod, expressed in a frame E.
<code class="docutils literal notranslate"><span class="pre">b_E</span></code> can have a norm different from one. Its norm is ignored
and only its direction is needed.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">G_Bcm_E</span></code>:</dt>
<dd>The unit inertia of the rod B about its center of mass <code class="docutils literal notranslate"><span class="pre">Bcm</span></code>,
expressed in the same frame E as the input unit vector <code class="docutils literal notranslate"><span class="pre">b_E</span></code>.</dd>
</dl>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.tree.UnitInertia_[float].TriaxiallySymmetric">
<em class="property">static </em><code class="descname">TriaxiallySymmetric</code><span class="sig-paren">(</span><em>I_triaxial: float</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UnitInertia_[float]<a class="headerlink" href="#pydrake.multibody.tree.UnitInertia_[float].TriaxiallySymmetric" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.UniversalJoint">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">UniversalJoint</code><a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.UniversalJoint_[float]" title="pydrake.multibody.tree.UniversalJoint_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.UniversalJoint_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.UniversalJoint_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">UniversalJoint_</code><a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.UniversalJoint_[float]" title="pydrake.multibody.tree.UniversalJoint_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">UniversalJoint_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.UniversalJoint_[AutoDiffXd]" title="pydrake.multibody.tree.UniversalJoint_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">UniversalJoint_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.UniversalJoint_[Expression]" title="pydrake.multibody.tree.UniversalJoint_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">UniversalJoint_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.UniversalJoint_.UniversalJoint_[float]">
<em class="property">class </em><code class="descname">UniversalJoint_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_.UniversalJoint_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[float]" title="pydrake.multibody.tree.Joint_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[float]</span></code></a></p>
<p>This joint models a universal joint allowing two bodies to rotate
relative to one another with two degrees of freedom. A universal joint
can be thought of as a mechanism consisting of three bodies; the
parent body P, an intermediate cross-shaped body I, and the child body
B. In a physical universal joint, body I has a significantly smaller
mass than P or B. This universal joint model corresponds to the
mathematical limit of having a body I of negligible mass. Given a
frame F attached to the parent body P and a frame M attached to the
child body B (see the Joint class’s documentation), the orientation of
M in F can then naturally be defined as follows using a body fixed
rotation sequence. A first rotation of θ₁ about Fx defines the
orientation R_FI of the intermediate frame I attached to body I
(notice that by definition Ix = Fx at all times). A second rotation of
θ₂ about Iy defines the orientation R_IM of frame M (notice that by
definition My = Iy at all times). Mathematically, the orientation of
frame M in F is given by</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>R_FM(q) = R_FI(θ₁) * R_IM(θ₂)
</pre></div>
</div>
<p>No translational motion of M in F is allowed and the origins, <code class="docutils literal notranslate"><span class="pre">Mo</span></code>
and <code class="docutils literal notranslate"><span class="pre">Fo</span></code>, of frames M and F respectively remain coincident. The
angles of rotation about F’s x-axis and M’s y-axis, along with their
rates, specify the state of the joint. Zero θ₁, θ₂ angles corresponds
to frames F, I, and M being coincident. Angles (θ₁, θ₂) are defined to
be positive according to the right-hand-rule with the thumb aligned in
the direction of their respective axes.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_.UniversalJoint_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[float], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[float], frame_on_child: pydrake.multibody.tree.Frame_[float], damping: float = 0</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_.UniversalJoint_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor to create a universal joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B rotate as described in the class’s documentation. See
class documentation for details on the angles defining orientation.
This constructor signature creates a joint with no joint limits, i.e.
the joint position, velocity and acceleration limits are the pair
<code class="docutils literal notranslate"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. These can be set using the Joint methods
set_position_limits(), set_velocity_limits() and
set_acceleration_limits(). The first three arguments to this
constructor are those of the Joint class constructor. See the Joint
class’s documentation for details. The additional parameters are:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, in N⋅m⋅s, used to model losses within
the joint. See documentation of damping() for details on modelling
of the damping torque.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if damping is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_.UniversalJoint_[float].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_.UniversalJoint_[float].damping" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s damping constant in N⋅m⋅s. The damping torque
(in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τᵢ</span> <span class="pre">=</span> <span class="pre">-damping⋅ωᵢ,</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">2</span></code> i.e. opposing
motion, with ωᵢ the angular rates about the i-th axis for <code class="docutils literal notranslate"><span class="pre">this</span></code>
joint (see get_angular_rates())and τᵢ the torque on child body B about
the same i-th axis.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_.UniversalJoint_[float].get_angles">
<code class="descname">get_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[2, 1]]<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_.UniversalJoint_[float].get_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rotation angles of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint from <code class="docutils literal notranslate"><span class="pre">context</span></code>. See class
documentation for the definition of these angles.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The angle coordinates of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code>
ordered as (θ₁, θ₂).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_.UniversalJoint_[float].get_angular_rates">
<code class="descname">get_angular_rates</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[2, 1]]<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_.UniversalJoint_[float].get_angular_rates" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rates of change, in radians per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
angles (see class documentation) from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The rates of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s angles as stored in the
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_.UniversalJoint_[float].get_default_angles">
<code class="descname">get_default_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[2, 1]]<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_.UniversalJoint_[float].get_default_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default angles for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint. Wrapper for the more
general <code class="docutils literal notranslate"><span class="pre">Joint::default_positions()</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The default angles of <code class="docutils literal notranslate"><span class="pre">this</span></code> stored in <code class="docutils literal notranslate"><span class="pre">default_positions_</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_.UniversalJoint_[float].set_angles">
<code class="descname">set_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[float], context: pydrake.systems.framework.Context_[float], angles: numpy.ndarray[numpy.float64[2, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UniversalJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_.UniversalJoint_[float].set_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the generalized coordinates corresponding
to the rotation angles of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals <code class="docutils literal notranslate"><span class="pre">angles</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angles</span></code>:</dt>
<dd>The desired angles in radians to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> ordered
as (θ₁, θ₂). See class documentation for details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_.UniversalJoint_[float].set_angular_rates">
<code class="descname">set_angular_rates</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[float], context: pydrake.systems.framework.Context_[float], theta_dot: numpy.ndarray[numpy.float64[2, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UniversalJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_.UniversalJoint_[float].set_angular_rates" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the rates of change, in radians per second, of this <code class="docutils literal notranslate"><span class="pre">this</span></code>
joint’s angles (see class documentation) to <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>. The new
rates of change get stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>:</dt>
<dd>The desired rates of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joints’s angles in radians
per second.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_.UniversalJoint_[float].set_default_angles">
<code class="descname">set_default_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[float], angles: numpy.ndarray[numpy.float64[2, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_.UniversalJoint_[float].set_default_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default angles of this joint.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angles</span></code>:</dt>
<dd>The desired default angles of the joint</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_.UniversalJoint_[float].set_random_angles_distribution">
<code class="descname">set_random_angles_distribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[float], angles: numpy.ndarray[object[2, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_.UniversalJoint_[float].set_random_angles_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the random distribution that angles of this joint will be
randomly sampled from. See class documentation for details on the
definition of the angles.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.UniversalJoint_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">UniversalJoint_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[AutoDiffXd]" title="pydrake.multibody.tree.Joint_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd]</span></code></a></p>
<p>This joint models a universal joint allowing two bodies to rotate
relative to one another with two degrees of freedom. A universal joint
can be thought of as a mechanism consisting of three bodies; the
parent body P, an intermediate cross-shaped body I, and the child body
B. In a physical universal joint, body I has a significantly smaller
mass than P or B. This universal joint model corresponds to the
mathematical limit of having a body I of negligible mass. Given a
frame F attached to the parent body P and a frame M attached to the
child body B (see the Joint class’s documentation), the orientation of
M in F can then naturally be defined as follows using a body fixed
rotation sequence. A first rotation of θ₁ about Fx defines the
orientation R_FI of the intermediate frame I attached to body I
(notice that by definition Ix = Fx at all times). A second rotation of
θ₂ about Iy defines the orientation R_IM of frame M (notice that by
definition My = Iy at all times). Mathematically, the orientation of
frame M in F is given by</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>R_FM(q) = R_FI(θ₁) * R_IM(θ₂)
</pre></div>
</div>
<p>No translational motion of M in F is allowed and the origins, <code class="docutils literal notranslate"><span class="pre">Mo</span></code>
and <code class="docutils literal notranslate"><span class="pre">Fo</span></code>, of frames M and F respectively remain coincident. The
angles of rotation about F’s x-axis and M’s y-axis, along with their
rates, specify the state of the joint. Zero θ₁, θ₂ angles corresponds
to frames F, I, and M being coincident. Angles (θ₁, θ₂) are defined to
be positive according to the right-hand-rule with the thumb aligned in
the direction of their respective axes.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[AutoDiffXd], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_on_child: pydrake.multibody.tree.Frame_[AutoDiffXd], damping: float = 0</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor to create a universal joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B rotate as described in the class’s documentation. See
class documentation for details on the angles defining orientation.
This constructor signature creates a joint with no joint limits, i.e.
the joint position, velocity and acceleration limits are the pair
<code class="docutils literal notranslate"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. These can be set using the Joint methods
set_position_limits(), set_velocity_limits() and
set_acceleration_limits(). The first three arguments to this
constructor are those of the Joint class constructor. See the Joint
class’s documentation for details. The additional parameters are:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, in N⋅m⋅s, used to model losses within
the joint. See documentation of damping() for details on modelling
of the damping torque.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if damping is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[AutoDiffXd].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[AutoDiffXd].damping" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s damping constant in N⋅m⋅s. The damping torque
(in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τᵢ</span> <span class="pre">=</span> <span class="pre">-damping⋅ωᵢ,</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">2</span></code> i.e. opposing
motion, with ωᵢ the angular rates about the i-th axis for <code class="docutils literal notranslate"><span class="pre">this</span></code>
joint (see get_angular_rates())and τᵢ the torque on child body B about
the same i-th axis.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[AutoDiffXd].get_angles">
<code class="descname">get_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[2, 1]]<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[AutoDiffXd].get_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rotation angles of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint from <code class="docutils literal notranslate"><span class="pre">context</span></code>. See class
documentation for the definition of these angles.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The angle coordinates of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code>
ordered as (θ₁, θ₂).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[AutoDiffXd].get_angular_rates">
<code class="descname">get_angular_rates</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[2, 1]]<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[AutoDiffXd].get_angular_rates" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rates of change, in radians per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
angles (see class documentation) from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The rates of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s angles as stored in the
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[AutoDiffXd].get_default_angles">
<code class="descname">get_default_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[2, 1]]<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[AutoDiffXd].get_default_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default angles for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint. Wrapper for the more
general <code class="docutils literal notranslate"><span class="pre">Joint::default_positions()</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The default angles of <code class="docutils literal notranslate"><span class="pre">this</span></code> stored in <code class="docutils literal notranslate"><span class="pre">default_positions_</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[AutoDiffXd].set_angles">
<code class="descname">set_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], angles: numpy.ndarray[object[2, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UniversalJoint_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[AutoDiffXd].set_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the generalized coordinates corresponding
to the rotation angles of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals <code class="docutils literal notranslate"><span class="pre">angles</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angles</span></code>:</dt>
<dd>The desired angles in radians to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> ordered
as (θ₁, θ₂). See class documentation for details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[AutoDiffXd].set_angular_rates">
<code class="descname">set_angular_rates</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[AutoDiffXd], context: pydrake.systems.framework.Context_[AutoDiffXd], theta_dot: numpy.ndarray[object[2, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UniversalJoint_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[AutoDiffXd].set_angular_rates" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the rates of change, in radians per second, of this <code class="docutils literal notranslate"><span class="pre">this</span></code>
joint’s angles (see class documentation) to <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>. The new
rates of change get stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>:</dt>
<dd>The desired rates of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joints’s angles in radians
per second.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[AutoDiffXd].set_default_angles">
<code class="descname">set_default_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[AutoDiffXd], angles: numpy.ndarray[numpy.float64[2, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[AutoDiffXd].set_default_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default angles of this joint.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angles</span></code>:</dt>
<dd>The desired default angles of the joint</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[AutoDiffXd].set_random_angles_distribution">
<code class="descname">set_random_angles_distribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[AutoDiffXd], angles: numpy.ndarray[object[2, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[AutoDiffXd].set_random_angles_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the random distribution that angles of this joint will be
randomly sampled from. See class documentation for details on the
definition of the angles.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.UniversalJoint_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">UniversalJoint_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[Expression]" title="pydrake.multibody.tree.Joint_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[Expression]</span></code></a></p>
<p>This joint models a universal joint allowing two bodies to rotate
relative to one another with two degrees of freedom. A universal joint
can be thought of as a mechanism consisting of three bodies; the
parent body P, an intermediate cross-shaped body I, and the child body
B. In a physical universal joint, body I has a significantly smaller
mass than P or B. This universal joint model corresponds to the
mathematical limit of having a body I of negligible mass. Given a
frame F attached to the parent body P and a frame M attached to the
child body B (see the Joint class’s documentation), the orientation of
M in F can then naturally be defined as follows using a body fixed
rotation sequence. A first rotation of θ₁ about Fx defines the
orientation R_FI of the intermediate frame I attached to body I
(notice that by definition Ix = Fx at all times). A second rotation of
θ₂ about Iy defines the orientation R_IM of frame M (notice that by
definition My = Iy at all times). Mathematically, the orientation of
frame M in F is given by</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>R_FM(q) = R_FI(θ₁) * R_IM(θ₂)
</pre></div>
</div>
<p>No translational motion of M in F is allowed and the origins, <code class="docutils literal notranslate"><span class="pre">Mo</span></code>
and <code class="docutils literal notranslate"><span class="pre">Fo</span></code>, of frames M and F respectively remain coincident. The
angles of rotation about F’s x-axis and M’s y-axis, along with their
rates, specify the state of the joint. Zero θ₁, θ₂ angles corresponds
to frames F, I, and M being coincident. Angles (θ₁, θ₂) are defined to
be positive according to the right-hand-rule with the thumb aligned in
the direction of their respective axes.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[Expression], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[Expression], frame_on_child: pydrake.multibody.tree.Frame_[Expression], damping: float = 0</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor to create a universal joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B rotate as described in the class’s documentation. See
class documentation for details on the angles defining orientation.
This constructor signature creates a joint with no joint limits, i.e.
the joint position, velocity and acceleration limits are the pair
<code class="docutils literal notranslate"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. These can be set using the Joint methods
set_position_limits(), set_velocity_limits() and
set_acceleration_limits(). The first three arguments to this
constructor are those of the Joint class constructor. See the Joint
class’s documentation for details. The additional parameters are:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, in N⋅m⋅s, used to model losses within
the joint. See documentation of damping() for details on modelling
of the damping torque.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if damping is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[Expression].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[Expression]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[Expression].damping" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s damping constant in N⋅m⋅s. The damping torque
(in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τᵢ</span> <span class="pre">=</span> <span class="pre">-damping⋅ωᵢ,</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">2</span></code> i.e. opposing
motion, with ωᵢ the angular rates about the i-th axis for <code class="docutils literal notranslate"><span class="pre">this</span></code>
joint (see get_angular_rates())and τᵢ the torque on child body B about
the same i-th axis.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[Expression].get_angles">
<code class="descname">get_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[2, 1]]<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[Expression].get_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rotation angles of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint from <code class="docutils literal notranslate"><span class="pre">context</span></code>. See class
documentation for the definition of these angles.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The angle coordinates of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code>
ordered as (θ₁, θ₂).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[Expression].get_angular_rates">
<code class="descname">get_angular_rates</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[Expression], context: pydrake.systems.framework.Context_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[2, 1]]<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[Expression].get_angular_rates" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rates of change, in radians per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
angles (see class documentation) from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The rates of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s angles as stored in the
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[Expression].get_default_angles">
<code class="descname">get_default_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[2, 1]]<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[Expression].get_default_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default angles for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint. Wrapper for the more
general <code class="docutils literal notranslate"><span class="pre">Joint::default_positions()</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The default angles of <code class="docutils literal notranslate"><span class="pre">this</span></code> stored in <code class="docutils literal notranslate"><span class="pre">default_positions_</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[Expression].set_angles">
<code class="descname">set_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[Expression], context: pydrake.systems.framework.Context_[Expression], angles: numpy.ndarray[object[2, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UniversalJoint_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[Expression].set_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the generalized coordinates corresponding
to the rotation angles of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals <code class="docutils literal notranslate"><span class="pre">angles</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angles</span></code>:</dt>
<dd>The desired angles in radians to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> ordered
as (θ₁, θ₂). See class documentation for details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[Expression].set_angular_rates">
<code class="descname">set_angular_rates</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[Expression], context: pydrake.systems.framework.Context_[Expression], theta_dot: numpy.ndarray[object[2, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UniversalJoint_[Expression]<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[Expression].set_angular_rates" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the rates of change, in radians per second, of this <code class="docutils literal notranslate"><span class="pre">this</span></code>
joint’s angles (see class documentation) to <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>. The new
rates of change get stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>:</dt>
<dd>The desired rates of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joints’s angles in radians
per second.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[Expression].set_default_angles">
<code class="descname">set_default_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[Expression], angles: numpy.ndarray[numpy.float64[2, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[Expression].set_default_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default angles of this joint.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angles</span></code>:</dt>
<dd>The desired default angles of the joint</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[Expression].set_random_angles_distribution">
<code class="descname">set_random_angles_distribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[Expression], angles: numpy.ndarray[object[2, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[Expression].set_random_angles_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the random distribution that angles of this joint will be
randomly sampled from. See class documentation for details on the
definition of the angles.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.UniversalJoint_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">UniversalJoint_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[float]" title="pydrake.multibody.tree.Joint_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[float]</span></code></a></p>
<p>This joint models a universal joint allowing two bodies to rotate
relative to one another with two degrees of freedom. A universal joint
can be thought of as a mechanism consisting of three bodies; the
parent body P, an intermediate cross-shaped body I, and the child body
B. In a physical universal joint, body I has a significantly smaller
mass than P or B. This universal joint model corresponds to the
mathematical limit of having a body I of negligible mass. Given a
frame F attached to the parent body P and a frame M attached to the
child body B (see the Joint class’s documentation), the orientation of
M in F can then naturally be defined as follows using a body fixed
rotation sequence. A first rotation of θ₁ about Fx defines the
orientation R_FI of the intermediate frame I attached to body I
(notice that by definition Ix = Fx at all times). A second rotation of
θ₂ about Iy defines the orientation R_IM of frame M (notice that by
definition My = Iy at all times). Mathematically, the orientation of
frame M in F is given by</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>R_FM(q) = R_FI(θ₁) * R_IM(θ₂)
</pre></div>
</div>
<p>No translational motion of M in F is allowed and the origins, <code class="docutils literal notranslate"><span class="pre">Mo</span></code>
and <code class="docutils literal notranslate"><span class="pre">Fo</span></code>, of frames M and F respectively remain coincident. The
angles of rotation about F’s x-axis and M’s y-axis, along with their
rates, specify the state of the joint. Zero θ₁, θ₂ angles corresponds
to frames F, I, and M being coincident. Angles (θ₁, θ₂) are defined to
be positive according to the right-hand-rule with the thumb aligned in
the direction of their respective axes.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[float], name: str, frame_on_parent: pydrake.multibody.tree.Frame_[float], frame_on_child: pydrake.multibody.tree.Frame_[float], damping: float = 0</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor to create a universal joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B rotate as described in the class’s documentation. See
class documentation for details on the angles defining orientation.
This constructor signature creates a joint with no joint limits, i.e.
the joint position, velocity and acceleration limits are the pair
<code class="docutils literal notranslate"><span class="pre">(-∞,</span> <span class="pre">∞)</span></code>. These can be set using the Joint methods
set_position_limits(), set_velocity_limits() and
set_acceleration_limits(). The first three arguments to this
constructor are those of the Joint class constructor. See the Joint
class’s documentation for details. The additional parameters are:</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">damping</span></code>:</dt>
<dd>Viscous damping coefficient, in N⋅m⋅s, used to model losses within
the joint. See documentation of damping() for details on modelling
of the damping torque.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body">RuntimeError if damping is negative.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[float].damping">
<code class="descname">damping</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[float].damping" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s damping constant in N⋅m⋅s. The damping torque
(in N⋅m) is modeled as <code class="docutils literal notranslate"><span class="pre">τᵢ</span> <span class="pre">=</span> <span class="pre">-damping⋅ωᵢ,</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">1,</span> <span class="pre">2</span></code> i.e. opposing
motion, with ωᵢ the angular rates about the i-th axis for <code class="docutils literal notranslate"><span class="pre">this</span></code>
joint (see get_angular_rates())and τᵢ the torque on child body B about
the same i-th axis.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[float].get_angles">
<code class="descname">get_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[2, 1]]<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[float].get_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rotation angles of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint from <code class="docutils literal notranslate"><span class="pre">context</span></code>. See class
documentation for the definition of these angles.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The angle coordinates of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint stored in the <code class="docutils literal notranslate"><span class="pre">context</span></code>
ordered as (θ₁, θ₂).</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[float].get_angular_rates">
<code class="descname">get_angular_rates</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[float], context: pydrake.systems.framework.Context_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[2, 1]]<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[float].get_angular_rates" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the rates of change, in radians per second, of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s
angles (see class documentation) from <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The rates of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint’s angles as stored in the
<code class="docutils literal notranslate"><span class="pre">context</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[float].get_default_angles">
<code class="descname">get_default_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[2, 1]]<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[float].get_default_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the default angles for <code class="docutils literal notranslate"><span class="pre">this</span></code> joint. Wrapper for the more
general <code class="docutils literal notranslate"><span class="pre">Joint::default_positions()</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">The default angles of <code class="docutils literal notranslate"><span class="pre">this</span></code> stored in <code class="docutils literal notranslate"><span class="pre">default_positions_</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[float].set_angles">
<code class="descname">set_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[float], context: pydrake.systems.framework.Context_[float], angles: numpy.ndarray[numpy.float64[2, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UniversalJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[float].set_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the <code class="docutils literal notranslate"><span class="pre">context</span></code> so that the generalized coordinates corresponding
to the rotation angles of <code class="docutils literal notranslate"><span class="pre">this</span></code> joint equals <code class="docutils literal notranslate"><span class="pre">angles</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angles</span></code>:</dt>
<dd>The desired angles in radians to be stored in <code class="docutils literal notranslate"><span class="pre">context</span></code> ordered
as (θ₁, θ₂). See class documentation for details.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[float].set_angular_rates">
<code class="descname">set_angular_rates</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[float], context: pydrake.systems.framework.Context_[float], theta_dot: numpy.ndarray[numpy.float64[2, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.UniversalJoint_[float]<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[float].set_angular_rates" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the rates of change, in radians per second, of this <code class="docutils literal notranslate"><span class="pre">this</span></code>
joint’s angles (see class documentation) to <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>. The new
rates of change get stored in <code class="docutils literal notranslate"><span class="pre">context</span></code>.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">context</span></code>:</dt>
<dd>The context of the model this joint belongs to.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">theta_dot</span></code>:</dt>
<dd>The desired rates of change of <code class="docutils literal notranslate"><span class="pre">this</span></code> joints’s angles in radians
per second.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a constant reference to <code class="docutils literal notranslate"><span class="pre">this</span></code> joint.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[float].set_default_angles">
<code class="descname">set_default_angles</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[float], angles: numpy.ndarray[numpy.float64[2, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[float].set_default_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the default angles of this joint.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">angles</span></code>:</dt>
<dd>The desired default angles of the joint</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.UniversalJoint_[float].set_random_angles_distribution">
<code class="descname">set_random_angles_distribution</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.UniversalJoint_[float], angles: numpy.ndarray[object[2, 1]]</em><span class="sig-paren">)</span> &#x2192; None<a class="headerlink" href="#pydrake.multibody.tree.UniversalJoint_[float].set_random_angles_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the random distribution that angles of this joint will be
randomly sampled from. See class documentation for details on the
definition of the angles.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.tree.WeldJoint">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">WeldJoint</code><a class="headerlink" href="#pydrake.multibody.tree.WeldJoint" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.tree.WeldJoint_[float]" title="pydrake.multibody.tree.WeldJoint_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.WeldJoint_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.tree.WeldJoint_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">WeldJoint_</code><a class="headerlink" href="#pydrake.multibody.tree.WeldJoint_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.tree.WeldJoint_[float]" title="pydrake.multibody.tree.WeldJoint_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">WeldJoint_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.WeldJoint_[AutoDiffXd]" title="pydrake.multibody.tree.WeldJoint_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">WeldJoint_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.tree.WeldJoint_[Expression]" title="pydrake.multibody.tree.WeldJoint_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">WeldJoint_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.tree.WeldJoint_.WeldJoint_[float]">
<em class="property">class </em><code class="descname">WeldJoint_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.WeldJoint_.WeldJoint_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[float]" title="pydrake.multibody.tree.Joint_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[float]</span></code></a></p>
<p>This Joint fixes the relative pose between two frames as if “welding”
them together.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.WeldJoint_.WeldJoint_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.WeldJoint_.WeldJoint_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.WeldJoint_[float], name: str, frame_on_parent_F: pydrake.multibody.tree.Frame_[float], frame_on_child_M: pydrake.multibody.tree.Frame_[float], X_FM: pydrake.math.RigidTransform_[float]) -&gt; None</li>
</ol>
<p>Constructor for a WeldJoint between a <code class="docutils literal notranslate"><span class="pre">frame_on_parent_F</span></code> and a
<code class="docutils literal notranslate"><span class="pre">frame_on_child_M</span></code> so that their relative pose <code class="docutils literal notranslate"><span class="pre">X_FM</span></code> is fixed as
if they were “welded” together.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.WeldJoint_[float], name: str, frame_on_parent_P: pydrake.multibody.tree.Frame_[float], frame_on_child_C: pydrake.multibody.tree.Frame_[float], X_PC: pydrake.math.RigidTransform_[float]) -&gt; None</li>
</ol>
<dl class="docutils">
<dt>Deprecated:</dt>
<dd>WeldJoint frame notation has changed. Use the constructor that uses <cite>frame_on_parent_F</cite>, <cite>frame_on_child_M</cite>, and <cite>X_FM</cite>. The deprecated code will be removed from Drake on or after 2022-12-01.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.WeldJoint_.WeldJoint_[float].X_FM">
<code class="descname">X_FM</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.WeldJoint_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.multibody.tree.WeldJoint_.WeldJoint_[float].X_FM" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pose X_FM of frame M in F.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.WeldJoint_.WeldJoint_[float].X_PC">
<code class="descname">X_PC</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.WeldJoint_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.multibody.tree.WeldJoint_.WeldJoint_[float].X_PC" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pose X_PC of frame C in P. (Deprecated.)</p>
<dl class="docutils">
<dt>Deprecated:</dt>
<dd>WeldJoint frame notation has changed. Use <code class="docutils literal notranslate"><span class="pre">X_FM()</span></code> instead. This
will be removed from Drake on or after 2022-12-01.</dd>
</dl>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.WeldJoint_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">WeldJoint_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.tree.WeldJoint_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[AutoDiffXd]" title="pydrake.multibody.tree.Joint_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[AutoDiffXd]</span></code></a></p>
<p>This Joint fixes the relative pose between two frames as if “welding”
them together.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.WeldJoint_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.WeldJoint_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.WeldJoint_[AutoDiffXd], name: str, frame_on_parent_F: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_on_child_M: pydrake.multibody.tree.Frame_[AutoDiffXd], X_FM: pydrake.math.RigidTransform_[float]) -&gt; None</li>
</ol>
<p>Constructor for a WeldJoint between a <code class="docutils literal notranslate"><span class="pre">frame_on_parent_F</span></code> and a
<code class="docutils literal notranslate"><span class="pre">frame_on_child_M</span></code> so that their relative pose <code class="docutils literal notranslate"><span class="pre">X_FM</span></code> is fixed as
if they were “welded” together.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.WeldJoint_[AutoDiffXd], name: str, frame_on_parent_P: pydrake.multibody.tree.Frame_[AutoDiffXd], frame_on_child_C: pydrake.multibody.tree.Frame_[AutoDiffXd], X_PC: pydrake.math.RigidTransform_[float]) -&gt; None</li>
</ol>
<dl class="docutils">
<dt>Deprecated:</dt>
<dd>WeldJoint frame notation has changed. Use the constructor that uses <cite>frame_on_parent_F</cite>, <cite>frame_on_child_M</cite>, and <cite>X_FM</cite>. The deprecated code will be removed from Drake on or after 2022-12-01.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.WeldJoint_[AutoDiffXd].X_FM">
<code class="descname">X_FM</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.WeldJoint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.multibody.tree.WeldJoint_[AutoDiffXd].X_FM" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pose X_FM of frame M in F.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.WeldJoint_[AutoDiffXd].X_PC">
<code class="descname">X_PC</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.WeldJoint_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.multibody.tree.WeldJoint_[AutoDiffXd].X_PC" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pose X_PC of frame C in P. (Deprecated.)</p>
<dl class="docutils">
<dt>Deprecated:</dt>
<dd>WeldJoint frame notation has changed. Use <code class="docutils literal notranslate"><span class="pre">X_FM()</span></code> instead. This
will be removed from Drake on or after 2022-12-01.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.WeldJoint_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">WeldJoint_[Expression]</code><a class="headerlink" href="#pydrake.multibody.tree.WeldJoint_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[Expression]" title="pydrake.multibody.tree.Joint_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[Expression]</span></code></a></p>
<p>This Joint fixes the relative pose between two frames as if “welding”
them together.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.WeldJoint_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.WeldJoint_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.WeldJoint_[Expression], name: str, frame_on_parent_F: pydrake.multibody.tree.Frame_[Expression], frame_on_child_M: pydrake.multibody.tree.Frame_[Expression], X_FM: pydrake.math.RigidTransform_[float]) -&gt; None</li>
</ol>
<p>Constructor for a WeldJoint between a <code class="docutils literal notranslate"><span class="pre">frame_on_parent_F</span></code> and a
<code class="docutils literal notranslate"><span class="pre">frame_on_child_M</span></code> so that their relative pose <code class="docutils literal notranslate"><span class="pre">X_FM</span></code> is fixed as
if they were “welded” together.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.WeldJoint_[Expression], name: str, frame_on_parent_P: pydrake.multibody.tree.Frame_[Expression], frame_on_child_C: pydrake.multibody.tree.Frame_[Expression], X_PC: pydrake.math.RigidTransform_[float]) -&gt; None</li>
</ol>
<dl class="docutils">
<dt>Deprecated:</dt>
<dd>WeldJoint frame notation has changed. Use the constructor that uses <cite>frame_on_parent_F</cite>, <cite>frame_on_child_M</cite>, and <cite>X_FM</cite>. The deprecated code will be removed from Drake on or after 2022-12-01.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.WeldJoint_[Expression].X_FM">
<code class="descname">X_FM</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.WeldJoint_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.multibody.tree.WeldJoint_[Expression].X_FM" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pose X_FM of frame M in F.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.WeldJoint_[Expression].X_PC">
<code class="descname">X_PC</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.WeldJoint_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.multibody.tree.WeldJoint_[Expression].X_PC" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pose X_PC of frame C in P. (Deprecated.)</p>
<dl class="docutils">
<dt>Deprecated:</dt>
<dd>WeldJoint frame notation has changed. Use <code class="docutils literal notranslate"><span class="pre">X_FM()</span></code> instead. This
will be removed from Drake on or after 2022-12-01.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.tree.WeldJoint_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.tree.</code><code class="descname">WeldJoint_[float]</code><a class="headerlink" href="#pydrake.multibody.tree.WeldJoint_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pydrake.multibody.tree.Joint_[float]" title="pydrake.multibody.tree.Joint_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.tree.Joint_[float]</span></code></a></p>
<p>This Joint fixes the relative pose between two frames as if “welding”
them together.</p>
<dl class="method">
<dt id="pydrake.multibody.tree.WeldJoint_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.tree.WeldJoint_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>__init__(self: pydrake.multibody.tree.WeldJoint_[float], name: str, frame_on_parent_F: pydrake.multibody.tree.Frame_[float], frame_on_child_M: pydrake.multibody.tree.Frame_[float], X_FM: pydrake.math.RigidTransform_[float]) -&gt; None</li>
</ol>
<p>Constructor for a WeldJoint between a <code class="docutils literal notranslate"><span class="pre">frame_on_parent_F</span></code> and a
<code class="docutils literal notranslate"><span class="pre">frame_on_child_M</span></code> so that their relative pose <code class="docutils literal notranslate"><span class="pre">X_FM</span></code> is fixed as
if they were “welded” together.</p>
<ol class="arabic simple" start="2">
<li>__init__(self: pydrake.multibody.tree.WeldJoint_[float], name: str, frame_on_parent_P: pydrake.multibody.tree.Frame_[float], frame_on_child_C: pydrake.multibody.tree.Frame_[float], X_PC: pydrake.math.RigidTransform_[float]) -&gt; None</li>
</ol>
<dl class="docutils">
<dt>Deprecated:</dt>
<dd>WeldJoint frame notation has changed. Use the constructor that uses <cite>frame_on_parent_F</cite>, <cite>frame_on_child_M</cite>, and <cite>X_FM</cite>. The deprecated code will be removed from Drake on or after 2022-12-01.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.WeldJoint_[float].X_FM">
<code class="descname">X_FM</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.WeldJoint_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.multibody.tree.WeldJoint_[float].X_FM" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pose X_FM of frame M in F.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.tree.WeldJoint_[float].X_PC">
<code class="descname">X_PC</code><span class="sig-paren">(</span><em>self: pydrake.multibody.tree.WeldJoint_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.math.RigidTransform_[float]<a class="headerlink" href="#pydrake.multibody.tree.WeldJoint_[float].X_PC" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the pose X_PC of frame C in P. (Deprecated.)</p>
<dl class="docutils">
<dt>Deprecated:</dt>
<dd>WeldJoint frame notation has changed. Use <code class="docutils literal notranslate"><span class="pre">X_FM()</span></code> instead. This
will be removed from Drake on or after 2022-12-01.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="pydrake.multibody.tree.world_frame_index">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">world_frame_index</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.FrameIndex<a class="headerlink" href="#pydrake.multibody.tree.world_frame_index" title="Permalink to this definition">¶</a></dt>
<dd><p>For every MultibodyPlant the <strong>world</strong> frame <em>always</em> has this unique
index and it is always zero.</p>
</dd></dl>

<dl class="function">
<dt id="pydrake.multibody.tree.world_index">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">world_index</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.BodyIndex<a class="headerlink" href="#pydrake.multibody.tree.world_index" title="Permalink to this definition">¶</a></dt>
<dd><p>For every MultibodyPlant the <strong>world</strong> body <em>always</em> has this unique
index and it is always zero.</p>
</dd></dl>

<dl class="function">
<dt id="pydrake.multibody.tree.world_model_instance">
<code class="descclassname">pydrake.multibody.tree.</code><code class="descname">world_model_instance</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.tree.ModelInstanceIndex<a class="headerlink" href="#pydrake.multibody.tree.world_model_instance" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the model instance containing the <em>world</em> body. For every
MultibodyPlant the <strong>world</strong> body <em>always</em> has this unique model
instance and it is always zero (as described in #3088).</p>
</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="pydrake.perception.html" class="btn btn-neutral float-right" title="pydrake.perception" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="pydrake.multibody.plant.html" class="btn btn-neutral float-left" title="pydrake.multibody.plant" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>

    </p>
  </div>
</footer>
<script>
  /* Enables clicking for the mobile "hamburger" (three-line) menu item. */
  const siteHeader = document.querySelector('.site-header')
  const mobileButton = document.querySelector('.menu-mobile-toggle')
  const body = document.querySelector('body')

  mobileButton.addEventListener('click', function(event) {
    siteHeader.classList.toggle('open');
    body.classList.toggle('overflow-hidden');
  })
</script>
<footer class="site-footer padding">
  <div class="contain">
    <a href="/" class="drake-logo">
      <img src="/images/drake-logo.svg">
    </a>
    <div class="footer-menu">
      <ul>
        <li>
          <a href="/doxygen_cxx/index.html" class="site-menu-item">C++</a>
        </li>
        <li>
          <a href="/pydrake/index.html" class="site-menu-item">Python</a>
        </li>
        <li class="github-link">
          <a href="https://github.com/RobotLocomotion/drake" class="site-menu-item">GitHub <img src="/third_party/images/GitHub-Mark-64px.png"></a>
        </li>
      </ul>
    </div>
  </div>


</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>