

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pydrake.multibody.math &mdash; pydrake  documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="pydrake.multibody.meshcat" href="pydrake.multibody.meshcat.html" />
    <link rel="prev" title="pydrake.multibody.inverse_kinematics" href="pydrake.multibody.inverse_kinematics.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> pydrake
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search pydrake only…" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
  <form id="ddg-search-form" class="wy_form" action="https://duckduckgo.com/" method="get">
    <input type="text" name="q" placeholder="Search all of Drake…" />
    <input type="hidden" name="sites" value="drake.mit.edu" />
  </form>
</div>


          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="pydrake.all.html">pydrake.all</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.autodiffutils.html">pydrake.autodiffutils</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.common.html">pydrake.common</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.examples.html">pydrake.examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.forwarddiff.html">pydrake.forwarddiff</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.geometry.html">pydrake.geometry</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.lcm.html">pydrake.lcm</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.manipulation.html">pydrake.manipulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.math.html">pydrake.math</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="pydrake.multibody.html">pydrake.multibody</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.all.html">pydrake.multibody.all</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.benchmarks.html">pydrake.multibody.benchmarks</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.inverse_kinematics.html">pydrake.multibody.inverse_kinematics</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">pydrake.multibody.math</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.meshcat.html">pydrake.multibody.meshcat</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.optimization.html">pydrake.multibody.optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.parsing.html">pydrake.multibody.parsing</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.plant.html">pydrake.multibody.plant</a></li>
<li class="toctree-l2"><a class="reference internal" href="pydrake.multibody.tree.html">pydrake.multibody.tree</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.perception.html">pydrake.perception</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.polynomial.html">pydrake.polynomial</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.solvers.html">pydrake.solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.symbolic.html">pydrake.symbolic</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.systems.html">pydrake.systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.trajectories.html">pydrake.trajectories</a></li>
<li class="toctree-l1"><a class="reference internal" href="pydrake.visualization.html">pydrake.visualization</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pydrake</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
          <li><a href="pydrake.multibody.html">pydrake.multibody</a> &raquo;</li>
        
      <li>pydrake.multibody.math</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-pydrake.multibody.math">
<span id="pydrake-multibody-math"></span><h1>pydrake.multibody.math<a class="headerlink" href="#module-pydrake.multibody.math" title="Permalink to this headline">¶</a></h1>
<p>Bindings for multibody math.</p>
<dl class="attribute">
<dt id="pydrake.multibody.math.SpatialAcceleration">
<code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialAcceleration</code><a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.math.SpatialAcceleration_[float]" title="pydrake.multibody.math.SpatialAcceleration_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.math.SpatialAcceleration_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.math.SpatialAcceleration_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialAcceleration_</code><a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.math.SpatialAcceleration_[float]" title="pydrake.multibody.math.SpatialAcceleration_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialAcceleration_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]" title="pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialAcceleration_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.math.SpatialAcceleration_[Expression]" title="pydrake.multibody.math.SpatialAcceleration_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialAcceleration_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float]">
<em class="property">class </em><code class="descname">SpatialAcceleration_[float]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is used to represent a <em>spatial acceleration</em> that combines
rotational (angular acceleration) and translational (linear
acceleration) components. While a SpatialVelocity <code class="docutils literal notranslate"><span class="pre">V_XY</span></code> represents
the motion of a “moving frame” Y measured with respect to a
“measured-in” frame X, the SpatialAcceleration <code class="docutils literal notranslate"><span class="pre">A_XY</span></code> represents the
rate of change of this spatial velocity <code class="docutils literal notranslate"><span class="pre">V_XY</span></code> in frame X. That is
<span class="math notranslate nohighlight">\(^XA^Y = \frac{^Xd}{dt}\,{^XV^Y}\)</span> where <span class="math notranslate nohighlight">\(\frac{^Xd}{dt}\)</span>
denotes the time derivative taken in frame X. That is, to compute an
acceleration we need to specify in what frame the time derivative is
taken, see [Mitiguy 2016, §6.1] for a more in depth discussion on
this. Time derivatives can be taken in different frames, and they
transform according to the “Transport Theorem”, which in Drake is
implemented in drake::math::ConvertTimeDerivativeToOtherFrame(). In
source code comments we write <code class="docutils literal notranslate"><span class="pre">A_XY</span> <span class="pre">=</span> <span class="pre">DtX(V_XY)</span></code>, where <code class="docutils literal notranslate"><span class="pre">DtX()</span></code> is
the operator that takes the time derivative in the X frame. By
convention, and unless otherwise stated, we assume that the frame in
which the time derivative is taken is the “measured-in” frame, i.e.
the time derivative used in <code class="docutils literal notranslate"><span class="pre">A_XY</span></code> is in frame X by default (i.e.
DtX()). To perform numerical computations, we need to specify an
“expressed-in” frame E (which may be distinct from either X or Y), so
that components can be expressed as real numbers. Only the vector
values are stored in a SpatialAcceleration object; the frames must be
understood from context and it is the responsibility of the user to
keep track of them. That is best accomplished through disciplined
notation. In source code we use monogram notation where capital A is
used to designate a spatial acceleration quantity. The same monogram
notation rules for SpatialVelocity are also used for
SpatialAcceleration. That is, the spatial acceleration of a frame Y
measured in X and expressed in E is denoted with <code class="docutils literal notranslate"><span class="pre">A_XY_E</span></code>. For a
more detailed introduction on spatial vectors and the monogram
notation please refer to section multibody_spatial_vectors.</p>
<p>[Mitiguy 2016] Mitiguy, P., 2016. Advanced Dynamics &amp; Motion
Simulation.</p>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialAcceleration_[float]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialAcceleration_[float], alpha: numpy.ndarray[numpy.float64[3, 1]], a: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>SpatialAcceleration constructor from an angular acceleration <code class="docutils literal notranslate"><span class="pre">alpha</span></code>
and a linear acceleration <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialAcceleration_[float], A: numpy.ndarray[numpy.float64[6, 1]]) -&gt; None</li>
</ol>
<p>SpatialAcceleration constructor from an Eigen expression that
represents a six-dimensional vector. Under the hood, spatial
accelerations are 6-element quantities that are pairs of ordinary
3-vectors. Elements 0-2 constitute the angular acceleration component
while elements 3-5 constitute the translational acceleration. The
argument <code class="docutils literal notranslate"><span class="pre">A</span></code> in this constructor is the concatenation of the
rotational 3D component followed by the translational 3D component.
This constructor will assert the size of <code class="docutils literal notranslate"><span class="pre">A</span></code> is six (6) at
compile-time for fixed sized Eigen expressions and at run-time for
dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].ComposeWithMovingFrameAcceleration">
<code class="descname">ComposeWithMovingFrameAcceleration</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[float], p_PB_E: numpy.ndarray[numpy.float64[3, 1]], w_WP_E: numpy.ndarray[numpy.float64[3, 1]], V_PB_E: pydrake.multibody.math.SpatialVelocity_[float], A_PB_E: pydrake.multibody.math.SpatialAcceleration_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].ComposeWithMovingFrameAcceleration" title="Permalink to this definition">¶</a></dt>
<dd><p>This method composes <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WP</span></code> of a frame
P measured in a frame W, with that of a third frame B moving in P with
spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_PB</span></code>. The result is the spatial acceleration
<code class="docutils literal notranslate"><span class="pre">A_WB</span></code> of frame B measured in W. At the instant in which the
accelerations are composed, frame B is located with its origin Bo at
<code class="docutils literal notranslate"><span class="pre">p_PB</span></code> from P’s origin Po.</p>
<p>This operation can be written in a more compact form in terms of the
rigid shift operator <code class="docutils literal notranslate"><span class="pre">Φᵀ(p_PB)</span></code> (see SpatialVelocity::Shift()) as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A_WB</span> <span class="o">=</span> <span class="n">Φᵀ</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="n">A_WP</span> <span class="o">+</span> <span class="n">Ac_WB</span><span class="p">(</span><span class="n">w_WP</span><span class="p">,</span> <span class="n">V_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">A_PB_W</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">Φᵀ(p_PB)</span> <span class="pre">A_WP</span></code> denotes the application of the rigid shift
operation as in SpatialVelocity::Shift() and <code class="docutils literal notranslate"><span class="pre">Ac_WB(w_WP,</span> <span class="pre">V_PB)</span></code>
contains the centrifugal and Coriolis terms:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Ac_WB</span><span class="p">(</span><span class="n">w_WP</span><span class="p">,</span> <span class="n">V_PB</span><span class="p">)</span> <span class="o">=</span> <span class="o">|</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB_W</span>                          <span class="o">|</span>
                      <span class="o">|</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB_W</span> <span class="o">+</span> <span class="mi">2</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB_W</span> <span class="o">|</span>
                                  <span class="o">^^^</span>                <span class="o">^^^</span>
                              <span class="n">centrifugal</span>         <span class="n">Coriolis</span>
</pre></div>
</div>
<p>The equation above shows that composing spatial accelerations cannot
be simply accomplished by adding <code class="docutils literal notranslate"><span class="pre">A_WP</span></code> with <code class="docutils literal notranslate"><span class="pre">A_PB</span></code>. Moreover, we
see that, unlike with angular velocities, angular accelerations cannot
be added in order to compose them. That is <code class="docutils literal notranslate"><span class="pre">w_AC</span> <span class="pre">=</span> <span class="pre">w_AB</span> <span class="pre">+</span> <span class="pre">w_BC</span></code> but
<code class="docutils literal notranslate"><span class="pre">alpha_AC</span> <span class="pre">≠</span> <span class="pre">alpha_AB</span> <span class="pre">+</span> <span class="pre">alpha_BC</span></code> due to the cross term <code class="docutils literal notranslate"><span class="pre">w_AC</span> <span class="pre">x</span>
<span class="pre">w_BC</span></code>. See the derivation below for more details.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">SpatialVelocity::ComposeWithMovingFrameVelocity() for the
composition of SpatialVelocity quantities.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method is the extension to the Shift() operator, which
computes the spatial acceleration frame P shifted to B as if frame
B moved rigidly with P, that is, for when <code class="docutils literal notranslate"><span class="pre">V_PB</span></code> and <code class="docutils literal notranslate"><span class="pre">A_PB</span></code>
are both zero. In other words the results from Shift() equal the
results from this method when <code class="docutils literal notranslate"><span class="pre">V_PB</span></code> and <code class="docutils literal notranslate"><span class="pre">A_PB</span></code> are both zero.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PB_E</span></code>:</dt>
<dd>Shift vector from P’s origin to B’s origin, expressed in frame E.
The “from” point <code class="docutils literal notranslate"><span class="pre">Po</span></code> must be the point whose acceleration is
currently represented in <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration, and E must
be the same expressed-in frame as for <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial
acceleration.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">w_WP_E</span></code>:</dt>
<dd>Angular velocity of frame P measured in frame W and expressed in
frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">V_PB_E</span></code>:</dt>
<dd>The spatial velocity of a third frame B in motion with respect to
P, expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">A_PB_E</span></code>:</dt>
<dd>The spatial acceleration of a third frame B in motion with respect
to P, expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial
acceleration.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">A_WB_E</span></code>:</dt>
<dd>The spatial acceleration of frame B in W, expressed in frame E.</dd>
</dl>
<p>** Derivation **</p>
<p>The spatial velocity of frame B in W can be obtained by composing
<code class="docutils literal notranslate"><span class="pre">V_WP</span></code> with <code class="docutils literal notranslate"><span class="pre">V_PB</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">V_WB</span> <span class="o">=</span> <span class="n">V_WPb</span> <span class="o">+</span> <span class="n">V_PB</span> <span class="o">=</span> <span class="n">Φᵀ</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="n">V_WP</span> <span class="o">+</span> <span class="n">V_PB</span>                        <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>This operation can be performed with the method
SpatialVelocity::ComposeWithMovingFrameVelocity().</p>
<ul class="simple">
<li>Translational acceleration component *</li>
</ul>
<p>The translational velocity <code class="docutils literal notranslate"><span class="pre">v_WB</span></code> of point B in W corresponds to the
translational component in Eq. (1):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_WB</span> <span class="o">=</span> <span class="n">v_WP</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">v_PB</span>                                  <span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Therefore, for the translational acceleration we have:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a_WB</span> <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_WB</span><span class="p">)</span>
        <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_WP</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">v_PB</span><span class="p">)</span>
        <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_WP</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_PB</span><span class="p">)</span>
        <span class="o">=</span> <span class="n">a_WP</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_WP</span><span class="p">)</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">DtW</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_PB</span><span class="p">)</span>
        <span class="o">=</span> <span class="n">a_WP</span> <span class="o">+</span> <span class="n">alpha_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">DtW</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_PB</span><span class="p">)</span>     <span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>with <code class="docutils literal notranslate"><span class="pre">a_WP</span> <span class="pre">=</span> <span class="pre">DtW(v_WP)</span></code> and <code class="docutils literal notranslate"><span class="pre">alpha_WP</span> <span class="pre">=</span> <span class="pre">DtW(w_WP)</span></code> by definition.
The term DtW(p_PB) in Eq. (3) is obtained by converting the vector
time derivative from <code class="docutils literal notranslate"><span class="pre">DtW()</span></code> to <code class="docutils literal notranslate"><span class="pre">DtP()</span></code>, see
drake::math::ConvertTimeDerivativeToOtherFrame():</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DtW</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="o">=</span> <span class="n">DtP</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span>
            <span class="o">=</span> <span class="n">v_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span>                                    <span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>since <code class="docutils literal notranslate"><span class="pre">v_PB</span> <span class="pre">=</span> <span class="pre">DtP(p_PB)</span></code> by definition. Similarly, the term
<code class="docutils literal notranslate"><span class="pre">DtW(v_PB)</span></code> in Eq. (3) is also obtained by converting the time
derivative from <code class="docutils literal notranslate"><span class="pre">DtW()</span></code> to <code class="docutils literal notranslate"><span class="pre">DtP()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DtW</span><span class="p">(</span><span class="n">v_PB</span><span class="p">)</span> <span class="o">=</span> <span class="n">DtP</span><span class="p">(</span><span class="n">v_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span>
            <span class="o">=</span> <span class="n">a_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span>                                    <span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>with <code class="docutils literal notranslate"><span class="pre">a_PB</span> <span class="pre">=</span> <span class="pre">DtP(v_PB)</span></code> by definition. Using Eqs. (4) and (5) in Eq.
(3) yields for the translational acceleration:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a_WB</span> <span class="o">=</span> <span class="n">a_WP</span> <span class="o">+</span> <span class="n">alpha_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">a_PB</span> <span class="o">+</span> <span class="n">ac_WB</span>
  <span class="n">ac_WB</span> <span class="o">=</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="p">(</span><span class="n">v_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span>                 <span class="p">(</span><span class="mi">6</span><span class="p">)</span>
</pre></div>
</div>
<p>where finally the term <code class="docutils literal notranslate"><span class="pre">ac_WB</span></code> can be written as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ac_WB</span> <span class="o">=</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span>                      <span class="p">(</span><span class="mi">7</span><span class="p">)</span>
</pre></div>
</div>
<p>which includes the effect of angular acceleration of P in W <code class="docutils literal notranslate"><span class="pre">alpha_WP</span>
<span class="pre">x</span> <span class="pre">p_PB</span></code>, the centrifugal acceleration <code class="docutils literal notranslate"><span class="pre">w_WP</span> <span class="pre">x</span> <span class="pre">w_WP</span> <span class="pre">x</span> <span class="pre">p_PB</span></code>, the
Coriolis acceleration <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">w_WP</span> <span class="pre">x</span> <span class="pre">v_PB</span></code> due to the motion of B in P
and, the additional acceleration of B in P <code class="docutils literal notranslate"><span class="pre">a_PB</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Alternatively, we can write an efficient version of the
centrifugal term <code class="docutils literal notranslate"><span class="pre">ac_WB</span></code> in Eq. (6) for when the velocities of P
and B are available (e.g. from velocity kinematics). This is
accomplished by adding and subtracting v_WP within the
parenthesized term in Eq. (6) and grouping together v_WB = v_WPb +
v_PB = v_WP + w_WP x p_PB + v_PB:</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ac_WB</span> <span class="o">=</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="p">(</span><span class="n">v_WB</span> <span class="o">-</span> <span class="n">v_WP</span><span class="p">)</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span>
        <span class="o">=</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="p">(</span><span class="n">v_WB</span> <span class="o">-</span> <span class="n">v_WP</span> <span class="o">+</span> <span class="n">v_PB</span><span class="p">)</span>                               <span class="p">(</span><span class="mi">6</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>which simplifies the expression from three cross products to one.</p>
<ul class="simple">
<li>Rotational acceleration component *</li>
</ul>
<p>The rotational velocity <code class="docutils literal notranslate"><span class="pre">w_WB</span></code> of frame B in W corresponds to the
rotational component in Eq. (1):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">w_WB</span> <span class="o">=</span> <span class="n">w_WP</span> <span class="o">+</span> <span class="n">w_PB</span>                                                <span class="p">(</span><span class="mi">8</span><span class="p">)</span>
</pre></div>
</div>
<p>Therefore, the rotational acceleration of B in W corresponds to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">alpha_WB</span> <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_WB</span><span class="p">)</span> <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_WP</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_PB</span><span class="p">)</span>
           <span class="o">=</span> <span class="n">alpha_WP</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_PB</span><span class="p">)</span>                                   <span class="p">(</span><span class="mi">9</span><span class="p">)</span>
</pre></div>
</div>
<p>where the last term in Eq. (9) can be converted to a time derivative
in P as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DtW</span><span class="p">(</span><span class="n">w_PB</span><span class="p">)</span> <span class="o">=</span> <span class="n">DtP</span><span class="p">(</span><span class="n">w_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB</span> <span class="o">=</span> <span class="n">alpha_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB</span>      <span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">alpha_PB</span> <span class="pre">=</span> <span class="pre">DtP(w_PB)</span></code> by definition. Thus, the final
expression for <code class="docutils literal notranslate"><span class="pre">alpha_WB</span></code> is obtained by using Eq. (10) into Eq.
(9):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">alpha_WB</span> <span class="o">=</span> <span class="n">alpha_WP</span> <span class="o">+</span> <span class="n">alpha_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB</span>                      <span class="p">(</span><span class="mi">11</span><span class="p">)</span>
</pre></div>
</div>
<p>Equation (11) shows that angular accelerations cannot be simply added
as angular velocities can but there exists an additional term <code class="docutils literal notranslate"><span class="pre">w_WP</span> <span class="pre">x</span>
<span class="pre">w_PB</span></code>.</p>
<ul class="simple">
<li>The spatial acceleration *</li>
</ul>
<p>The rotational and translational components of the spatial
acceleration are given by Eqs. (11) and (6) respectively:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A_WB</span><span class="o">.</span><span class="n">rotational</span><span class="p">()</span> <span class="o">=</span> <span class="n">alpha_WB</span>
                    <span class="o">=</span> <span class="p">{</span><span class="n">alpha_WP</span><span class="p">}</span> <span class="o">+</span> <span class="n">alpha_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB</span>           <span class="p">(</span><span class="mi">12</span><span class="p">)</span>
  <span class="n">A_WB</span><span class="o">.</span><span class="n">translational</span><span class="p">()</span> <span class="o">=</span> <span class="n">a_WB</span>
                       <span class="o">=</span> <span class="p">{</span><span class="n">a_WP</span> <span class="o">+</span> <span class="n">alpha_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span><span class="p">}</span>
                       <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span> <span class="o">+</span> <span class="n">a_PB</span>                     <span class="p">(</span><span class="mi">13</span><span class="p">)</span>
</pre></div>
</div>
<p>where we have placed within curly brackets <code class="docutils literal notranslate"><span class="pre">{}</span></code> all the terms that
also appear in the Shift() operation, which is equivalent to this
method when <code class="docutils literal notranslate"><span class="pre">V_PB</span></code> and <code class="docutils literal notranslate"><span class="pre">A_PB</span></code> are both zero. In the equations
above <code class="docutils literal notranslate"><span class="pre">alpha_WP</span> <span class="pre">=</span> <span class="pre">A_WP.rotational()</span></code> and <code class="docutils literal notranslate"><span class="pre">a_WP</span> <span class="pre">=</span>
<span class="pre">A_WP.translational()</span></code>. The above expression can be written in a more
compact form in terms of the rigid shift operator <code class="docutils literal notranslate"><span class="pre">Φᵀ(p_PB)</span></code> (see
SpatialVelocity::Shift()) as presented in the main body of this
documentation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A_WB</span> <span class="o">=</span> <span class="n">Φᵀ</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span><span class="n">A_WP</span> <span class="o">+</span> <span class="n">Ac_WB</span><span class="p">(</span><span class="n">w_WP</span><span class="p">,</span> <span class="n">V_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">A_PB_W</span>                  <span class="p">(</span><span class="mi">14</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">Ac_WB(w_WP,</span> <span class="pre">V_PB)</span></code> contains the centrifugal and Coriolis
terms:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Ac_WB</span><span class="p">(</span><span class="n">w_WP</span><span class="p">,</span> <span class="n">V_PB</span><span class="p">)</span> <span class="o">=</span> <span class="o">|</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB_W</span>                          <span class="o">|</span>
                      <span class="o">|</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB_W</span> <span class="o">+</span> <span class="mi">2</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB_W</span> <span class="o">|</span>
                                  <span class="o">^^^</span>                <span class="o">^^^</span>
                              <span class="n">centrifugal</span>         <span class="n">Coriolis</span>
</pre></div>
</div>
<p>As usual, for computation, all quantities above must be expressed in a
common frame E; we add an <code class="docutils literal notranslate"><span class="pre">_E</span></code> suffix to each symbol to indicate
that.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[float], R_FE: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>Shift(self: pydrake.multibody.math.SpatialAcceleration_[float], p_PoQ_E: numpy.ndarray[numpy.float64[3, 1]], w_WP_E: numpy.ndarray[numpy.float64[3, 1]]) -&gt; pydrake.multibody.math.SpatialAcceleration_[float]</li>
</ol>
<p>Shifts <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WP</span></code> of a frame P into the
spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WPq</span></code> of a frame <code class="docutils literal notranslate"><span class="pre">Pq</span></code> which is an offset
frame rigidly aligned with P, but with its origin shifted to a point Q
by an offset p_PoQ. Frame <code class="docutils literal notranslate"><span class="pre">Pq</span></code> is instantaneously moving together
with frame P as if rigidly attached to it. As an example of
application, this operation can be used to compute <code class="docutils literal notranslate"><span class="pre">A_WPq</span></code> where P
is a frame on a rigid body and Q is another point on that same body.
Therefore P and <code class="docutils literal notranslate"><span class="pre">Pq</span></code> move together with the spatial velocity
<code class="docutils literal notranslate"><span class="pre">V_PPq</span></code> being zero at all times. This is an alternate signature for
shifting a spatial acceleration that does not change the original
object. See ShiftInPlace() for more information and a description of
the arguments.</p>
<ol class="arabic simple" start="2">
<li>Shift(self: pydrake.multibody.math.SpatialAcceleration_[float], p_PoQ_E: numpy.ndarray[numpy.float64[3, 1]]) -&gt; pydrake.multibody.math.SpatialAcceleration_[float]</li>
</ol>
<p>(Advanced) Given <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WP</span></code> of a frame P
in a second frame W, this operation is only valid when the angular
velocity <code class="docutils literal notranslate"><span class="pre">w_WP</span></code> of P in W is zero. Refer to Shift(const Vector3&lt;T&gt;&amp;,
const Vector3&lt;T&gt;&amp;) for the full version that includes velocity terms.
This method can be used to avoid unnecessary computation when shifting
<code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration of a frame P into the spatial
acceleration of the shifted frame <code class="docutils literal notranslate"><span class="pre">Pq</span></code>. The shift position vector is
given by <code class="docutils literal notranslate"><span class="pre">p_PoQ_E</span></code>, expresssed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code>
spatial` acceleration. Mathematically, this returns <code class="docutils literal notranslate"><span class="pre">A_WPq</span> <span class="pre">=</span>
<span class="pre">Φᵀ(p_PoQ)A_WP</span></code>, where <code class="docutils literal notranslate"><span class="pre">Φ(p_PoQ)</span></code> is the rigid shift operator, see
SpatialVelocity::Shift().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_.SpatialAcceleration_[float].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> SpatialVector, i.e. rotational and
translational components are both zero.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialAcceleration_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is used to represent a <em>spatial acceleration</em> that combines
rotational (angular acceleration) and translational (linear
acceleration) components. While a SpatialVelocity <code class="docutils literal notranslate"><span class="pre">V_XY</span></code> represents
the motion of a “moving frame” Y measured with respect to a
“measured-in” frame X, the SpatialAcceleration <code class="docutils literal notranslate"><span class="pre">A_XY</span></code> represents the
rate of change of this spatial velocity <code class="docutils literal notranslate"><span class="pre">V_XY</span></code> in frame X. That is
<span class="math notranslate nohighlight">\(^XA^Y = \frac{^Xd}{dt}\,{^XV^Y}\)</span> where <span class="math notranslate nohighlight">\(\frac{^Xd}{dt}\)</span>
denotes the time derivative taken in frame X. That is, to compute an
acceleration we need to specify in what frame the time derivative is
taken, see [Mitiguy 2016, §6.1] for a more in depth discussion on
this. Time derivatives can be taken in different frames, and they
transform according to the “Transport Theorem”, which in Drake is
implemented in drake::math::ConvertTimeDerivativeToOtherFrame(). In
source code comments we write <code class="docutils literal notranslate"><span class="pre">A_XY</span> <span class="pre">=</span> <span class="pre">DtX(V_XY)</span></code>, where <code class="docutils literal notranslate"><span class="pre">DtX()</span></code> is
the operator that takes the time derivative in the X frame. By
convention, and unless otherwise stated, we assume that the frame in
which the time derivative is taken is the “measured-in” frame, i.e.
the time derivative used in <code class="docutils literal notranslate"><span class="pre">A_XY</span></code> is in frame X by default (i.e.
DtX()). To perform numerical computations, we need to specify an
“expressed-in” frame E (which may be distinct from either X or Y), so
that components can be expressed as real numbers. Only the vector
values are stored in a SpatialAcceleration object; the frames must be
understood from context and it is the responsibility of the user to
keep track of them. That is best accomplished through disciplined
notation. In source code we use monogram notation where capital A is
used to designate a spatial acceleration quantity. The same monogram
notation rules for SpatialVelocity are also used for
SpatialAcceleration. That is, the spatial acceleration of a frame Y
measured in X and expressed in E is denoted with <code class="docutils literal notranslate"><span class="pre">A_XY_E</span></code>. For a
more detailed introduction on spatial vectors and the monogram
notation please refer to section multibody_spatial_vectors.</p>
<p>[Mitiguy 2016] Mitiguy, P., 2016. Advanced Dynamics &amp; Motion
Simulation.</p>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd], alpha: numpy.ndarray[object[3, 1]], a: numpy.ndarray[object[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>SpatialAcceleration constructor from an angular acceleration <code class="docutils literal notranslate"><span class="pre">alpha</span></code>
and a linear acceleration <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd], A: numpy.ndarray[object[6, 1]]) -&gt; None</li>
</ol>
<p>SpatialAcceleration constructor from an Eigen expression that
represents a six-dimensional vector. Under the hood, spatial
accelerations are 6-element quantities that are pairs of ordinary
3-vectors. Elements 0-2 constitute the angular acceleration component
while elements 3-5 constitute the translational acceleration. The
argument <code class="docutils literal notranslate"><span class="pre">A</span></code> in this constructor is the concatenation of the
rotational 3D component followed by the translational 3D component.
This constructor will assert the size of <code class="docutils literal notranslate"><span class="pre">A</span></code> is six (6) at
compile-time for fixed sized Eigen expressions and at run-time for
dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].ComposeWithMovingFrameAcceleration">
<code class="descname">ComposeWithMovingFrameAcceleration</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd], p_PB_E: numpy.ndarray[object[3, 1]], w_WP_E: numpy.ndarray[object[3, 1]], V_PB_E: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd], A_PB_E: pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].ComposeWithMovingFrameAcceleration" title="Permalink to this definition">¶</a></dt>
<dd><p>This method composes <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WP</span></code> of a frame
P measured in a frame W, with that of a third frame B moving in P with
spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_PB</span></code>. The result is the spatial acceleration
<code class="docutils literal notranslate"><span class="pre">A_WB</span></code> of frame B measured in W. At the instant in which the
accelerations are composed, frame B is located with its origin Bo at
<code class="docutils literal notranslate"><span class="pre">p_PB</span></code> from P’s origin Po.</p>
<p>This operation can be written in a more compact form in terms of the
rigid shift operator <code class="docutils literal notranslate"><span class="pre">Φᵀ(p_PB)</span></code> (see SpatialVelocity::Shift()) as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A_WB</span> <span class="o">=</span> <span class="n">Φᵀ</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="n">A_WP</span> <span class="o">+</span> <span class="n">Ac_WB</span><span class="p">(</span><span class="n">w_WP</span><span class="p">,</span> <span class="n">V_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">A_PB_W</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">Φᵀ(p_PB)</span> <span class="pre">A_WP</span></code> denotes the application of the rigid shift
operation as in SpatialVelocity::Shift() and <code class="docutils literal notranslate"><span class="pre">Ac_WB(w_WP,</span> <span class="pre">V_PB)</span></code>
contains the centrifugal and Coriolis terms:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Ac_WB</span><span class="p">(</span><span class="n">w_WP</span><span class="p">,</span> <span class="n">V_PB</span><span class="p">)</span> <span class="o">=</span> <span class="o">|</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB_W</span>                          <span class="o">|</span>
                      <span class="o">|</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB_W</span> <span class="o">+</span> <span class="mi">2</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB_W</span> <span class="o">|</span>
                                  <span class="o">^^^</span>                <span class="o">^^^</span>
                              <span class="n">centrifugal</span>         <span class="n">Coriolis</span>
</pre></div>
</div>
<p>The equation above shows that composing spatial accelerations cannot
be simply accomplished by adding <code class="docutils literal notranslate"><span class="pre">A_WP</span></code> with <code class="docutils literal notranslate"><span class="pre">A_PB</span></code>. Moreover, we
see that, unlike with angular velocities, angular accelerations cannot
be added in order to compose them. That is <code class="docutils literal notranslate"><span class="pre">w_AC</span> <span class="pre">=</span> <span class="pre">w_AB</span> <span class="pre">+</span> <span class="pre">w_BC</span></code> but
<code class="docutils literal notranslate"><span class="pre">alpha_AC</span> <span class="pre">≠</span> <span class="pre">alpha_AB</span> <span class="pre">+</span> <span class="pre">alpha_BC</span></code> due to the cross term <code class="docutils literal notranslate"><span class="pre">w_AC</span> <span class="pre">x</span>
<span class="pre">w_BC</span></code>. See the derivation below for more details.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">SpatialVelocity::ComposeWithMovingFrameVelocity() for the
composition of SpatialVelocity quantities.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method is the extension to the Shift() operator, which
computes the spatial acceleration frame P shifted to B as if frame
B moved rigidly with P, that is, for when <code class="docutils literal notranslate"><span class="pre">V_PB</span></code> and <code class="docutils literal notranslate"><span class="pre">A_PB</span></code>
are both zero. In other words the results from Shift() equal the
results from this method when <code class="docutils literal notranslate"><span class="pre">V_PB</span></code> and <code class="docutils literal notranslate"><span class="pre">A_PB</span></code> are both zero.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PB_E</span></code>:</dt>
<dd>Shift vector from P’s origin to B’s origin, expressed in frame E.
The “from” point <code class="docutils literal notranslate"><span class="pre">Po</span></code> must be the point whose acceleration is
currently represented in <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration, and E must
be the same expressed-in frame as for <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial
acceleration.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">w_WP_E</span></code>:</dt>
<dd>Angular velocity of frame P measured in frame W and expressed in
frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">V_PB_E</span></code>:</dt>
<dd>The spatial velocity of a third frame B in motion with respect to
P, expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">A_PB_E</span></code>:</dt>
<dd>The spatial acceleration of a third frame B in motion with respect
to P, expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial
acceleration.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">A_WB_E</span></code>:</dt>
<dd>The spatial acceleration of frame B in W, expressed in frame E.</dd>
</dl>
<p>** Derivation **</p>
<p>The spatial velocity of frame B in W can be obtained by composing
<code class="docutils literal notranslate"><span class="pre">V_WP</span></code> with <code class="docutils literal notranslate"><span class="pre">V_PB</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">V_WB</span> <span class="o">=</span> <span class="n">V_WPb</span> <span class="o">+</span> <span class="n">V_PB</span> <span class="o">=</span> <span class="n">Φᵀ</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="n">V_WP</span> <span class="o">+</span> <span class="n">V_PB</span>                        <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>This operation can be performed with the method
SpatialVelocity::ComposeWithMovingFrameVelocity().</p>
<ul class="simple">
<li>Translational acceleration component *</li>
</ul>
<p>The translational velocity <code class="docutils literal notranslate"><span class="pre">v_WB</span></code> of point B in W corresponds to the
translational component in Eq. (1):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_WB</span> <span class="o">=</span> <span class="n">v_WP</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">v_PB</span>                                  <span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Therefore, for the translational acceleration we have:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a_WB</span> <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_WB</span><span class="p">)</span>
        <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_WP</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">v_PB</span><span class="p">)</span>
        <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_WP</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_PB</span><span class="p">)</span>
        <span class="o">=</span> <span class="n">a_WP</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_WP</span><span class="p">)</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">DtW</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_PB</span><span class="p">)</span>
        <span class="o">=</span> <span class="n">a_WP</span> <span class="o">+</span> <span class="n">alpha_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">DtW</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_PB</span><span class="p">)</span>     <span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>with <code class="docutils literal notranslate"><span class="pre">a_WP</span> <span class="pre">=</span> <span class="pre">DtW(v_WP)</span></code> and <code class="docutils literal notranslate"><span class="pre">alpha_WP</span> <span class="pre">=</span> <span class="pre">DtW(w_WP)</span></code> by definition.
The term DtW(p_PB) in Eq. (3) is obtained by converting the vector
time derivative from <code class="docutils literal notranslate"><span class="pre">DtW()</span></code> to <code class="docutils literal notranslate"><span class="pre">DtP()</span></code>, see
drake::math::ConvertTimeDerivativeToOtherFrame():</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DtW</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="o">=</span> <span class="n">DtP</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span>
            <span class="o">=</span> <span class="n">v_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span>                                    <span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>since <code class="docutils literal notranslate"><span class="pre">v_PB</span> <span class="pre">=</span> <span class="pre">DtP(p_PB)</span></code> by definition. Similarly, the term
<code class="docutils literal notranslate"><span class="pre">DtW(v_PB)</span></code> in Eq. (3) is also obtained by converting the time
derivative from <code class="docutils literal notranslate"><span class="pre">DtW()</span></code> to <code class="docutils literal notranslate"><span class="pre">DtP()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DtW</span><span class="p">(</span><span class="n">v_PB</span><span class="p">)</span> <span class="o">=</span> <span class="n">DtP</span><span class="p">(</span><span class="n">v_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span>
            <span class="o">=</span> <span class="n">a_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span>                                    <span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>with <code class="docutils literal notranslate"><span class="pre">a_PB</span> <span class="pre">=</span> <span class="pre">DtP(v_PB)</span></code> by definition. Using Eqs. (4) and (5) in Eq.
(3) yields for the translational acceleration:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a_WB</span> <span class="o">=</span> <span class="n">a_WP</span> <span class="o">+</span> <span class="n">alpha_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">a_PB</span> <span class="o">+</span> <span class="n">ac_WB</span>
  <span class="n">ac_WB</span> <span class="o">=</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="p">(</span><span class="n">v_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span>                 <span class="p">(</span><span class="mi">6</span><span class="p">)</span>
</pre></div>
</div>
<p>where finally the term <code class="docutils literal notranslate"><span class="pre">ac_WB</span></code> can be written as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ac_WB</span> <span class="o">=</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span>                      <span class="p">(</span><span class="mi">7</span><span class="p">)</span>
</pre></div>
</div>
<p>which includes the effect of angular acceleration of P in W <code class="docutils literal notranslate"><span class="pre">alpha_WP</span>
<span class="pre">x</span> <span class="pre">p_PB</span></code>, the centrifugal acceleration <code class="docutils literal notranslate"><span class="pre">w_WP</span> <span class="pre">x</span> <span class="pre">w_WP</span> <span class="pre">x</span> <span class="pre">p_PB</span></code>, the
Coriolis acceleration <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">w_WP</span> <span class="pre">x</span> <span class="pre">v_PB</span></code> due to the motion of B in P
and, the additional acceleration of B in P <code class="docutils literal notranslate"><span class="pre">a_PB</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Alternatively, we can write an efficient version of the
centrifugal term <code class="docutils literal notranslate"><span class="pre">ac_WB</span></code> in Eq. (6) for when the velocities of P
and B are available (e.g. from velocity kinematics). This is
accomplished by adding and subtracting v_WP within the
parenthesized term in Eq. (6) and grouping together v_WB = v_WPb +
v_PB = v_WP + w_WP x p_PB + v_PB:</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ac_WB</span> <span class="o">=</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="p">(</span><span class="n">v_WB</span> <span class="o">-</span> <span class="n">v_WP</span><span class="p">)</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span>
        <span class="o">=</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="p">(</span><span class="n">v_WB</span> <span class="o">-</span> <span class="n">v_WP</span> <span class="o">+</span> <span class="n">v_PB</span><span class="p">)</span>                               <span class="p">(</span><span class="mi">6</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>which simplifies the expression from three cross products to one.</p>
<ul class="simple">
<li>Rotational acceleration component *</li>
</ul>
<p>The rotational velocity <code class="docutils literal notranslate"><span class="pre">w_WB</span></code> of frame B in W corresponds to the
rotational component in Eq. (1):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">w_WB</span> <span class="o">=</span> <span class="n">w_WP</span> <span class="o">+</span> <span class="n">w_PB</span>                                                <span class="p">(</span><span class="mi">8</span><span class="p">)</span>
</pre></div>
</div>
<p>Therefore, the rotational acceleration of B in W corresponds to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">alpha_WB</span> <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_WB</span><span class="p">)</span> <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_WP</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_PB</span><span class="p">)</span>
           <span class="o">=</span> <span class="n">alpha_WP</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_PB</span><span class="p">)</span>                                   <span class="p">(</span><span class="mi">9</span><span class="p">)</span>
</pre></div>
</div>
<p>where the last term in Eq. (9) can be converted to a time derivative
in P as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DtW</span><span class="p">(</span><span class="n">w_PB</span><span class="p">)</span> <span class="o">=</span> <span class="n">DtP</span><span class="p">(</span><span class="n">w_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB</span> <span class="o">=</span> <span class="n">alpha_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB</span>      <span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">alpha_PB</span> <span class="pre">=</span> <span class="pre">DtP(w_PB)</span></code> by definition. Thus, the final
expression for <code class="docutils literal notranslate"><span class="pre">alpha_WB</span></code> is obtained by using Eq. (10) into Eq.
(9):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">alpha_WB</span> <span class="o">=</span> <span class="n">alpha_WP</span> <span class="o">+</span> <span class="n">alpha_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB</span>                      <span class="p">(</span><span class="mi">11</span><span class="p">)</span>
</pre></div>
</div>
<p>Equation (11) shows that angular accelerations cannot be simply added
as angular velocities can but there exists an additional term <code class="docutils literal notranslate"><span class="pre">w_WP</span> <span class="pre">x</span>
<span class="pre">w_PB</span></code>.</p>
<ul class="simple">
<li>The spatial acceleration *</li>
</ul>
<p>The rotational and translational components of the spatial
acceleration are given by Eqs. (11) and (6) respectively:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A_WB</span><span class="o">.</span><span class="n">rotational</span><span class="p">()</span> <span class="o">=</span> <span class="n">alpha_WB</span>
                    <span class="o">=</span> <span class="p">{</span><span class="n">alpha_WP</span><span class="p">}</span> <span class="o">+</span> <span class="n">alpha_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB</span>           <span class="p">(</span><span class="mi">12</span><span class="p">)</span>
  <span class="n">A_WB</span><span class="o">.</span><span class="n">translational</span><span class="p">()</span> <span class="o">=</span> <span class="n">a_WB</span>
                       <span class="o">=</span> <span class="p">{</span><span class="n">a_WP</span> <span class="o">+</span> <span class="n">alpha_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span><span class="p">}</span>
                       <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span> <span class="o">+</span> <span class="n">a_PB</span>                     <span class="p">(</span><span class="mi">13</span><span class="p">)</span>
</pre></div>
</div>
<p>where we have placed within curly brackets <code class="docutils literal notranslate"><span class="pre">{}</span></code> all the terms that
also appear in the Shift() operation, which is equivalent to this
method when <code class="docutils literal notranslate"><span class="pre">V_PB</span></code> and <code class="docutils literal notranslate"><span class="pre">A_PB</span></code> are both zero. In the equations
above <code class="docutils literal notranslate"><span class="pre">alpha_WP</span> <span class="pre">=</span> <span class="pre">A_WP.rotational()</span></code> and <code class="docutils literal notranslate"><span class="pre">a_WP</span> <span class="pre">=</span>
<span class="pre">A_WP.translational()</span></code>. The above expression can be written in a more
compact form in terms of the rigid shift operator <code class="docutils literal notranslate"><span class="pre">Φᵀ(p_PB)</span></code> (see
SpatialVelocity::Shift()) as presented in the main body of this
documentation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A_WB</span> <span class="o">=</span> <span class="n">Φᵀ</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span><span class="n">A_WP</span> <span class="o">+</span> <span class="n">Ac_WB</span><span class="p">(</span><span class="n">w_WP</span><span class="p">,</span> <span class="n">V_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">A_PB_W</span>                  <span class="p">(</span><span class="mi">14</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">Ac_WB(w_WP,</span> <span class="pre">V_PB)</span></code> contains the centrifugal and Coriolis
terms:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Ac_WB</span><span class="p">(</span><span class="n">w_WP</span><span class="p">,</span> <span class="n">V_PB</span><span class="p">)</span> <span class="o">=</span> <span class="o">|</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB_W</span>                          <span class="o">|</span>
                      <span class="o">|</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB_W</span> <span class="o">+</span> <span class="mi">2</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB_W</span> <span class="o">|</span>
                                  <span class="o">^^^</span>                <span class="o">^^^</span>
                              <span class="n">centrifugal</span>         <span class="n">Coriolis</span>
</pre></div>
</div>
<p>As usual, for computation, all quantities above must be expressed in a
common frame E; we add an <code class="docutils literal notranslate"><span class="pre">_E</span></code> suffix to each symbol to indicate
that.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd], R_FE: pydrake.math.RotationMatrix_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>Shift(self: pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd], p_PoQ_E: numpy.ndarray[object[3, 1]], w_WP_E: numpy.ndarray[object[3, 1]]) -&gt; pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]</li>
</ol>
<p>Shifts <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WP</span></code> of a frame P into the
spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WPq</span></code> of a frame <code class="docutils literal notranslate"><span class="pre">Pq</span></code> which is an offset
frame rigidly aligned with P, but with its origin shifted to a point Q
by an offset p_PoQ. Frame <code class="docutils literal notranslate"><span class="pre">Pq</span></code> is instantaneously moving together
with frame P as if rigidly attached to it. As an example of
application, this operation can be used to compute <code class="docutils literal notranslate"><span class="pre">A_WPq</span></code> where P
is a frame on a rigid body and Q is another point on that same body.
Therefore P and <code class="docutils literal notranslate"><span class="pre">Pq</span></code> move together with the spatial velocity
<code class="docutils literal notranslate"><span class="pre">V_PPq</span></code> being zero at all times. This is an alternate signature for
shifting a spatial acceleration that does not change the original
object. See ShiftInPlace() for more information and a description of
the arguments.</p>
<ol class="arabic simple" start="2">
<li>Shift(self: pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd], p_PoQ_E: numpy.ndarray[object[3, 1]]) -&gt; pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]</li>
</ol>
<p>(Advanced) Given <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WP</span></code> of a frame P
in a second frame W, this operation is only valid when the angular
velocity <code class="docutils literal notranslate"><span class="pre">w_WP</span></code> of P in W is zero. Refer to Shift(const Vector3&lt;T&gt;&amp;,
const Vector3&lt;T&gt;&amp;) for the full version that includes velocity terms.
This method can be used to avoid unnecessary computation when shifting
<code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration of a frame P into the spatial
acceleration of the shifted frame <code class="docutils literal notranslate"><span class="pre">Pq</span></code>. The shift position vector is
given by <code class="docutils literal notranslate"><span class="pre">p_PoQ_E</span></code>, expresssed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code>
spatial` acceleration. Mathematically, this returns <code class="docutils literal notranslate"><span class="pre">A_WPq</span> <span class="pre">=</span>
<span class="pre">Φᵀ(p_PoQ)A_WP</span></code>, where <code class="docutils literal notranslate"><span class="pre">Φ(p_PoQ)</span></code> is the rigid shift operator, see
SpatialVelocity::Shift().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[AutoDiffXd].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> SpatialVector, i.e. rotational and
translational components are both zero.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.math.SpatialAcceleration_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialAcceleration_[Expression]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is used to represent a <em>spatial acceleration</em> that combines
rotational (angular acceleration) and translational (linear
acceleration) components. While a SpatialVelocity <code class="docutils literal notranslate"><span class="pre">V_XY</span></code> represents
the motion of a “moving frame” Y measured with respect to a
“measured-in” frame X, the SpatialAcceleration <code class="docutils literal notranslate"><span class="pre">A_XY</span></code> represents the
rate of change of this spatial velocity <code class="docutils literal notranslate"><span class="pre">V_XY</span></code> in frame X. That is
<span class="math notranslate nohighlight">\(^XA^Y = \frac{^Xd}{dt}\,{^XV^Y}\)</span> where <span class="math notranslate nohighlight">\(\frac{^Xd}{dt}\)</span>
denotes the time derivative taken in frame X. That is, to compute an
acceleration we need to specify in what frame the time derivative is
taken, see [Mitiguy 2016, §6.1] for a more in depth discussion on
this. Time derivatives can be taken in different frames, and they
transform according to the “Transport Theorem”, which in Drake is
implemented in drake::math::ConvertTimeDerivativeToOtherFrame(). In
source code comments we write <code class="docutils literal notranslate"><span class="pre">A_XY</span> <span class="pre">=</span> <span class="pre">DtX(V_XY)</span></code>, where <code class="docutils literal notranslate"><span class="pre">DtX()</span></code> is
the operator that takes the time derivative in the X frame. By
convention, and unless otherwise stated, we assume that the frame in
which the time derivative is taken is the “measured-in” frame, i.e.
the time derivative used in <code class="docutils literal notranslate"><span class="pre">A_XY</span></code> is in frame X by default (i.e.
DtX()). To perform numerical computations, we need to specify an
“expressed-in” frame E (which may be distinct from either X or Y), so
that components can be expressed as real numbers. Only the vector
values are stored in a SpatialAcceleration object; the frames must be
understood from context and it is the responsibility of the user to
keep track of them. That is best accomplished through disciplined
notation. In source code we use monogram notation where capital A is
used to designate a spatial acceleration quantity. The same monogram
notation rules for SpatialVelocity are also used for
SpatialAcceleration. That is, the spatial acceleration of a frame Y
measured in X and expressed in E is denoted with <code class="docutils literal notranslate"><span class="pre">A_XY_E</span></code>. For a
more detailed introduction on spatial vectors and the monogram
notation please refer to section multibody_spatial_vectors.</p>
<p>[Mitiguy 2016] Mitiguy, P., 2016. Advanced Dynamics &amp; Motion
Simulation.</p>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialAcceleration_[Expression]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialAcceleration_[Expression], alpha: numpy.ndarray[object[3, 1]], a: numpy.ndarray[object[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>SpatialAcceleration constructor from an angular acceleration <code class="docutils literal notranslate"><span class="pre">alpha</span></code>
and a linear acceleration <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialAcceleration_[Expression], A: numpy.ndarray[object[6, 1]]) -&gt; None</li>
</ol>
<p>SpatialAcceleration constructor from an Eigen expression that
represents a six-dimensional vector. Under the hood, spatial
accelerations are 6-element quantities that are pairs of ordinary
3-vectors. Elements 0-2 constitute the angular acceleration component
while elements 3-5 constitute the translational acceleration. The
argument <code class="docutils literal notranslate"><span class="pre">A</span></code> in this constructor is the concatenation of the
rotational 3D component followed by the translational 3D component.
This constructor will assert the size of <code class="docutils literal notranslate"><span class="pre">A</span></code> is six (6) at
compile-time for fixed sized Eigen expressions and at run-time for
dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[Expression].ComposeWithMovingFrameAcceleration">
<code class="descname">ComposeWithMovingFrameAcceleration</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[Expression], p_PB_E: numpy.ndarray[object[3, 1]], w_WP_E: numpy.ndarray[object[3, 1]], V_PB_E: pydrake.multibody.math.SpatialVelocity_[Expression], A_PB_E: pydrake.multibody.math.SpatialAcceleration_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[Expression].ComposeWithMovingFrameAcceleration" title="Permalink to this definition">¶</a></dt>
<dd><p>This method composes <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WP</span></code> of a frame
P measured in a frame W, with that of a third frame B moving in P with
spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_PB</span></code>. The result is the spatial acceleration
<code class="docutils literal notranslate"><span class="pre">A_WB</span></code> of frame B measured in W. At the instant in which the
accelerations are composed, frame B is located with its origin Bo at
<code class="docutils literal notranslate"><span class="pre">p_PB</span></code> from P’s origin Po.</p>
<p>This operation can be written in a more compact form in terms of the
rigid shift operator <code class="docutils literal notranslate"><span class="pre">Φᵀ(p_PB)</span></code> (see SpatialVelocity::Shift()) as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A_WB</span> <span class="o">=</span> <span class="n">Φᵀ</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="n">A_WP</span> <span class="o">+</span> <span class="n">Ac_WB</span><span class="p">(</span><span class="n">w_WP</span><span class="p">,</span> <span class="n">V_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">A_PB_W</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">Φᵀ(p_PB)</span> <span class="pre">A_WP</span></code> denotes the application of the rigid shift
operation as in SpatialVelocity::Shift() and <code class="docutils literal notranslate"><span class="pre">Ac_WB(w_WP,</span> <span class="pre">V_PB)</span></code>
contains the centrifugal and Coriolis terms:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Ac_WB</span><span class="p">(</span><span class="n">w_WP</span><span class="p">,</span> <span class="n">V_PB</span><span class="p">)</span> <span class="o">=</span> <span class="o">|</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB_W</span>                          <span class="o">|</span>
                      <span class="o">|</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB_W</span> <span class="o">+</span> <span class="mi">2</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB_W</span> <span class="o">|</span>
                                  <span class="o">^^^</span>                <span class="o">^^^</span>
                              <span class="n">centrifugal</span>         <span class="n">Coriolis</span>
</pre></div>
</div>
<p>The equation above shows that composing spatial accelerations cannot
be simply accomplished by adding <code class="docutils literal notranslate"><span class="pre">A_WP</span></code> with <code class="docutils literal notranslate"><span class="pre">A_PB</span></code>. Moreover, we
see that, unlike with angular velocities, angular accelerations cannot
be added in order to compose them. That is <code class="docutils literal notranslate"><span class="pre">w_AC</span> <span class="pre">=</span> <span class="pre">w_AB</span> <span class="pre">+</span> <span class="pre">w_BC</span></code> but
<code class="docutils literal notranslate"><span class="pre">alpha_AC</span> <span class="pre">≠</span> <span class="pre">alpha_AB</span> <span class="pre">+</span> <span class="pre">alpha_BC</span></code> due to the cross term <code class="docutils literal notranslate"><span class="pre">w_AC</span> <span class="pre">x</span>
<span class="pre">w_BC</span></code>. See the derivation below for more details.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">SpatialVelocity::ComposeWithMovingFrameVelocity() for the
composition of SpatialVelocity quantities.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method is the extension to the Shift() operator, which
computes the spatial acceleration frame P shifted to B as if frame
B moved rigidly with P, that is, for when <code class="docutils literal notranslate"><span class="pre">V_PB</span></code> and <code class="docutils literal notranslate"><span class="pre">A_PB</span></code>
are both zero. In other words the results from Shift() equal the
results from this method when <code class="docutils literal notranslate"><span class="pre">V_PB</span></code> and <code class="docutils literal notranslate"><span class="pre">A_PB</span></code> are both zero.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PB_E</span></code>:</dt>
<dd>Shift vector from P’s origin to B’s origin, expressed in frame E.
The “from” point <code class="docutils literal notranslate"><span class="pre">Po</span></code> must be the point whose acceleration is
currently represented in <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration, and E must
be the same expressed-in frame as for <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial
acceleration.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">w_WP_E</span></code>:</dt>
<dd>Angular velocity of frame P measured in frame W and expressed in
frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">V_PB_E</span></code>:</dt>
<dd>The spatial velocity of a third frame B in motion with respect to
P, expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">A_PB_E</span></code>:</dt>
<dd>The spatial acceleration of a third frame B in motion with respect
to P, expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial
acceleration.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">A_WB_E</span></code>:</dt>
<dd>The spatial acceleration of frame B in W, expressed in frame E.</dd>
</dl>
<p>** Derivation **</p>
<p>The spatial velocity of frame B in W can be obtained by composing
<code class="docutils literal notranslate"><span class="pre">V_WP</span></code> with <code class="docutils literal notranslate"><span class="pre">V_PB</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">V_WB</span> <span class="o">=</span> <span class="n">V_WPb</span> <span class="o">+</span> <span class="n">V_PB</span> <span class="o">=</span> <span class="n">Φᵀ</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="n">V_WP</span> <span class="o">+</span> <span class="n">V_PB</span>                        <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>This operation can be performed with the method
SpatialVelocity::ComposeWithMovingFrameVelocity().</p>
<ul class="simple">
<li>Translational acceleration component *</li>
</ul>
<p>The translational velocity <code class="docutils literal notranslate"><span class="pre">v_WB</span></code> of point B in W corresponds to the
translational component in Eq. (1):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_WB</span> <span class="o">=</span> <span class="n">v_WP</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">v_PB</span>                                  <span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Therefore, for the translational acceleration we have:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a_WB</span> <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_WB</span><span class="p">)</span>
        <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_WP</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">v_PB</span><span class="p">)</span>
        <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_WP</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_PB</span><span class="p">)</span>
        <span class="o">=</span> <span class="n">a_WP</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_WP</span><span class="p">)</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">DtW</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_PB</span><span class="p">)</span>
        <span class="o">=</span> <span class="n">a_WP</span> <span class="o">+</span> <span class="n">alpha_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">DtW</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_PB</span><span class="p">)</span>     <span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>with <code class="docutils literal notranslate"><span class="pre">a_WP</span> <span class="pre">=</span> <span class="pre">DtW(v_WP)</span></code> and <code class="docutils literal notranslate"><span class="pre">alpha_WP</span> <span class="pre">=</span> <span class="pre">DtW(w_WP)</span></code> by definition.
The term DtW(p_PB) in Eq. (3) is obtained by converting the vector
time derivative from <code class="docutils literal notranslate"><span class="pre">DtW()</span></code> to <code class="docutils literal notranslate"><span class="pre">DtP()</span></code>, see
drake::math::ConvertTimeDerivativeToOtherFrame():</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DtW</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="o">=</span> <span class="n">DtP</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span>
            <span class="o">=</span> <span class="n">v_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span>                                    <span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>since <code class="docutils literal notranslate"><span class="pre">v_PB</span> <span class="pre">=</span> <span class="pre">DtP(p_PB)</span></code> by definition. Similarly, the term
<code class="docutils literal notranslate"><span class="pre">DtW(v_PB)</span></code> in Eq. (3) is also obtained by converting the time
derivative from <code class="docutils literal notranslate"><span class="pre">DtW()</span></code> to <code class="docutils literal notranslate"><span class="pre">DtP()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DtW</span><span class="p">(</span><span class="n">v_PB</span><span class="p">)</span> <span class="o">=</span> <span class="n">DtP</span><span class="p">(</span><span class="n">v_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span>
            <span class="o">=</span> <span class="n">a_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span>                                    <span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>with <code class="docutils literal notranslate"><span class="pre">a_PB</span> <span class="pre">=</span> <span class="pre">DtP(v_PB)</span></code> by definition. Using Eqs. (4) and (5) in Eq.
(3) yields for the translational acceleration:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a_WB</span> <span class="o">=</span> <span class="n">a_WP</span> <span class="o">+</span> <span class="n">alpha_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">a_PB</span> <span class="o">+</span> <span class="n">ac_WB</span>
  <span class="n">ac_WB</span> <span class="o">=</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="p">(</span><span class="n">v_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span>                 <span class="p">(</span><span class="mi">6</span><span class="p">)</span>
</pre></div>
</div>
<p>where finally the term <code class="docutils literal notranslate"><span class="pre">ac_WB</span></code> can be written as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ac_WB</span> <span class="o">=</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span>                      <span class="p">(</span><span class="mi">7</span><span class="p">)</span>
</pre></div>
</div>
<p>which includes the effect of angular acceleration of P in W <code class="docutils literal notranslate"><span class="pre">alpha_WP</span>
<span class="pre">x</span> <span class="pre">p_PB</span></code>, the centrifugal acceleration <code class="docutils literal notranslate"><span class="pre">w_WP</span> <span class="pre">x</span> <span class="pre">w_WP</span> <span class="pre">x</span> <span class="pre">p_PB</span></code>, the
Coriolis acceleration <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">w_WP</span> <span class="pre">x</span> <span class="pre">v_PB</span></code> due to the motion of B in P
and, the additional acceleration of B in P <code class="docutils literal notranslate"><span class="pre">a_PB</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Alternatively, we can write an efficient version of the
centrifugal term <code class="docutils literal notranslate"><span class="pre">ac_WB</span></code> in Eq. (6) for when the velocities of P
and B are available (e.g. from velocity kinematics). This is
accomplished by adding and subtracting v_WP within the
parenthesized term in Eq. (6) and grouping together v_WB = v_WPb +
v_PB = v_WP + w_WP x p_PB + v_PB:</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ac_WB</span> <span class="o">=</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="p">(</span><span class="n">v_WB</span> <span class="o">-</span> <span class="n">v_WP</span><span class="p">)</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span>
        <span class="o">=</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="p">(</span><span class="n">v_WB</span> <span class="o">-</span> <span class="n">v_WP</span> <span class="o">+</span> <span class="n">v_PB</span><span class="p">)</span>                               <span class="p">(</span><span class="mi">6</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>which simplifies the expression from three cross products to one.</p>
<ul class="simple">
<li>Rotational acceleration component *</li>
</ul>
<p>The rotational velocity <code class="docutils literal notranslate"><span class="pre">w_WB</span></code> of frame B in W corresponds to the
rotational component in Eq. (1):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">w_WB</span> <span class="o">=</span> <span class="n">w_WP</span> <span class="o">+</span> <span class="n">w_PB</span>                                                <span class="p">(</span><span class="mi">8</span><span class="p">)</span>
</pre></div>
</div>
<p>Therefore, the rotational acceleration of B in W corresponds to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">alpha_WB</span> <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_WB</span><span class="p">)</span> <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_WP</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_PB</span><span class="p">)</span>
           <span class="o">=</span> <span class="n">alpha_WP</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_PB</span><span class="p">)</span>                                   <span class="p">(</span><span class="mi">9</span><span class="p">)</span>
</pre></div>
</div>
<p>where the last term in Eq. (9) can be converted to a time derivative
in P as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DtW</span><span class="p">(</span><span class="n">w_PB</span><span class="p">)</span> <span class="o">=</span> <span class="n">DtP</span><span class="p">(</span><span class="n">w_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB</span> <span class="o">=</span> <span class="n">alpha_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB</span>      <span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">alpha_PB</span> <span class="pre">=</span> <span class="pre">DtP(w_PB)</span></code> by definition. Thus, the final
expression for <code class="docutils literal notranslate"><span class="pre">alpha_WB</span></code> is obtained by using Eq. (10) into Eq.
(9):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">alpha_WB</span> <span class="o">=</span> <span class="n">alpha_WP</span> <span class="o">+</span> <span class="n">alpha_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB</span>                      <span class="p">(</span><span class="mi">11</span><span class="p">)</span>
</pre></div>
</div>
<p>Equation (11) shows that angular accelerations cannot be simply added
as angular velocities can but there exists an additional term <code class="docutils literal notranslate"><span class="pre">w_WP</span> <span class="pre">x</span>
<span class="pre">w_PB</span></code>.</p>
<ul class="simple">
<li>The spatial acceleration *</li>
</ul>
<p>The rotational and translational components of the spatial
acceleration are given by Eqs. (11) and (6) respectively:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A_WB</span><span class="o">.</span><span class="n">rotational</span><span class="p">()</span> <span class="o">=</span> <span class="n">alpha_WB</span>
                    <span class="o">=</span> <span class="p">{</span><span class="n">alpha_WP</span><span class="p">}</span> <span class="o">+</span> <span class="n">alpha_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB</span>           <span class="p">(</span><span class="mi">12</span><span class="p">)</span>
  <span class="n">A_WB</span><span class="o">.</span><span class="n">translational</span><span class="p">()</span> <span class="o">=</span> <span class="n">a_WB</span>
                       <span class="o">=</span> <span class="p">{</span><span class="n">a_WP</span> <span class="o">+</span> <span class="n">alpha_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span><span class="p">}</span>
                       <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span> <span class="o">+</span> <span class="n">a_PB</span>                     <span class="p">(</span><span class="mi">13</span><span class="p">)</span>
</pre></div>
</div>
<p>where we have placed within curly brackets <code class="docutils literal notranslate"><span class="pre">{}</span></code> all the terms that
also appear in the Shift() operation, which is equivalent to this
method when <code class="docutils literal notranslate"><span class="pre">V_PB</span></code> and <code class="docutils literal notranslate"><span class="pre">A_PB</span></code> are both zero. In the equations
above <code class="docutils literal notranslate"><span class="pre">alpha_WP</span> <span class="pre">=</span> <span class="pre">A_WP.rotational()</span></code> and <code class="docutils literal notranslate"><span class="pre">a_WP</span> <span class="pre">=</span>
<span class="pre">A_WP.translational()</span></code>. The above expression can be written in a more
compact form in terms of the rigid shift operator <code class="docutils literal notranslate"><span class="pre">Φᵀ(p_PB)</span></code> (see
SpatialVelocity::Shift()) as presented in the main body of this
documentation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A_WB</span> <span class="o">=</span> <span class="n">Φᵀ</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span><span class="n">A_WP</span> <span class="o">+</span> <span class="n">Ac_WB</span><span class="p">(</span><span class="n">w_WP</span><span class="p">,</span> <span class="n">V_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">A_PB_W</span>                  <span class="p">(</span><span class="mi">14</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">Ac_WB(w_WP,</span> <span class="pre">V_PB)</span></code> contains the centrifugal and Coriolis
terms:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Ac_WB</span><span class="p">(</span><span class="n">w_WP</span><span class="p">,</span> <span class="n">V_PB</span><span class="p">)</span> <span class="o">=</span> <span class="o">|</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB_W</span>                          <span class="o">|</span>
                      <span class="o">|</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB_W</span> <span class="o">+</span> <span class="mi">2</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB_W</span> <span class="o">|</span>
                                  <span class="o">^^^</span>                <span class="o">^^^</span>
                              <span class="n">centrifugal</span>         <span class="n">Coriolis</span>
</pre></div>
</div>
<p>As usual, for computation, all quantities above must be expressed in a
common frame E; we add an <code class="docutils literal notranslate"><span class="pre">_E</span></code> suffix to each symbol to indicate
that.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[Expression].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[Expression].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[Expression].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[Expression], R_FE: pydrake.math.RotationMatrix_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[Expression].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[Expression].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[Expression].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[Expression].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[Expression].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[Expression].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[Expression].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>Shift(self: pydrake.multibody.math.SpatialAcceleration_[Expression], p_PoQ_E: numpy.ndarray[object[3, 1]], w_WP_E: numpy.ndarray[object[3, 1]]) -&gt; pydrake.multibody.math.SpatialAcceleration_[Expression]</li>
</ol>
<p>Shifts <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WP</span></code> of a frame P into the
spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WPq</span></code> of a frame <code class="docutils literal notranslate"><span class="pre">Pq</span></code> which is an offset
frame rigidly aligned with P, but with its origin shifted to a point Q
by an offset p_PoQ. Frame <code class="docutils literal notranslate"><span class="pre">Pq</span></code> is instantaneously moving together
with frame P as if rigidly attached to it. As an example of
application, this operation can be used to compute <code class="docutils literal notranslate"><span class="pre">A_WPq</span></code> where P
is a frame on a rigid body and Q is another point on that same body.
Therefore P and <code class="docutils literal notranslate"><span class="pre">Pq</span></code> move together with the spatial velocity
<code class="docutils literal notranslate"><span class="pre">V_PPq</span></code> being zero at all times. This is an alternate signature for
shifting a spatial acceleration that does not change the original
object. See ShiftInPlace() for more information and a description of
the arguments.</p>
<ol class="arabic simple" start="2">
<li>Shift(self: pydrake.multibody.math.SpatialAcceleration_[Expression], p_PoQ_E: numpy.ndarray[object[3, 1]]) -&gt; pydrake.multibody.math.SpatialAcceleration_[Expression]</li>
</ol>
<p>(Advanced) Given <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WP</span></code> of a frame P
in a second frame W, this operation is only valid when the angular
velocity <code class="docutils literal notranslate"><span class="pre">w_WP</span></code> of P in W is zero. Refer to Shift(const Vector3&lt;T&gt;&amp;,
const Vector3&lt;T&gt;&amp;) for the full version that includes velocity terms.
This method can be used to avoid unnecessary computation when shifting
<code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration of a frame P into the spatial
acceleration of the shifted frame <code class="docutils literal notranslate"><span class="pre">Pq</span></code>. The shift position vector is
given by <code class="docutils literal notranslate"><span class="pre">p_PoQ_E</span></code>, expresssed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code>
spatial` acceleration. Mathematically, this returns <code class="docutils literal notranslate"><span class="pre">A_WPq</span> <span class="pre">=</span>
<span class="pre">Φᵀ(p_PoQ)A_WP</span></code>, where <code class="docutils literal notranslate"><span class="pre">Φ(p_PoQ)</span></code> is the rigid shift operator, see
SpatialVelocity::Shift().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[Expression].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[Expression].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialAcceleration_[Expression].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[Expression].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> SpatialVector, i.e. rotational and
translational components are both zero.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.math.SpatialAcceleration_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialAcceleration_[float]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is used to represent a <em>spatial acceleration</em> that combines
rotational (angular acceleration) and translational (linear
acceleration) components. While a SpatialVelocity <code class="docutils literal notranslate"><span class="pre">V_XY</span></code> represents
the motion of a “moving frame” Y measured with respect to a
“measured-in” frame X, the SpatialAcceleration <code class="docutils literal notranslate"><span class="pre">A_XY</span></code> represents the
rate of change of this spatial velocity <code class="docutils literal notranslate"><span class="pre">V_XY</span></code> in frame X. That is
<span class="math notranslate nohighlight">\(^XA^Y = \frac{^Xd}{dt}\,{^XV^Y}\)</span> where <span class="math notranslate nohighlight">\(\frac{^Xd}{dt}\)</span>
denotes the time derivative taken in frame X. That is, to compute an
acceleration we need to specify in what frame the time derivative is
taken, see [Mitiguy 2016, §6.1] for a more in depth discussion on
this. Time derivatives can be taken in different frames, and they
transform according to the “Transport Theorem”, which in Drake is
implemented in drake::math::ConvertTimeDerivativeToOtherFrame(). In
source code comments we write <code class="docutils literal notranslate"><span class="pre">A_XY</span> <span class="pre">=</span> <span class="pre">DtX(V_XY)</span></code>, where <code class="docutils literal notranslate"><span class="pre">DtX()</span></code> is
the operator that takes the time derivative in the X frame. By
convention, and unless otherwise stated, we assume that the frame in
which the time derivative is taken is the “measured-in” frame, i.e.
the time derivative used in <code class="docutils literal notranslate"><span class="pre">A_XY</span></code> is in frame X by default (i.e.
DtX()). To perform numerical computations, we need to specify an
“expressed-in” frame E (which may be distinct from either X or Y), so
that components can be expressed as real numbers. Only the vector
values are stored in a SpatialAcceleration object; the frames must be
understood from context and it is the responsibility of the user to
keep track of them. That is best accomplished through disciplined
notation. In source code we use monogram notation where capital A is
used to designate a spatial acceleration quantity. The same monogram
notation rules for SpatialVelocity are also used for
SpatialAcceleration. That is, the spatial acceleration of a frame Y
measured in X and expressed in E is denoted with <code class="docutils literal notranslate"><span class="pre">A_XY_E</span></code>. For a
more detailed introduction on spatial vectors and the monogram
notation please refer to section multibody_spatial_vectors.</p>
<p>[Mitiguy 2016] Mitiguy, P., 2016. Advanced Dynamics &amp; Motion
Simulation.</p>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialAcceleration_[float]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialAcceleration_[float], alpha: numpy.ndarray[numpy.float64[3, 1]], a: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>SpatialAcceleration constructor from an angular acceleration <code class="docutils literal notranslate"><span class="pre">alpha</span></code>
and a linear acceleration <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialAcceleration_[float], A: numpy.ndarray[numpy.float64[6, 1]]) -&gt; None</li>
</ol>
<p>SpatialAcceleration constructor from an Eigen expression that
represents a six-dimensional vector. Under the hood, spatial
accelerations are 6-element quantities that are pairs of ordinary
3-vectors. Elements 0-2 constitute the angular acceleration component
while elements 3-5 constitute the translational acceleration. The
argument <code class="docutils literal notranslate"><span class="pre">A</span></code> in this constructor is the concatenation of the
rotational 3D component followed by the translational 3D component.
This constructor will assert the size of <code class="docutils literal notranslate"><span class="pre">A</span></code> is six (6) at
compile-time for fixed sized Eigen expressions and at run-time for
dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[float].ComposeWithMovingFrameAcceleration">
<code class="descname">ComposeWithMovingFrameAcceleration</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[float], p_PB_E: numpy.ndarray[numpy.float64[3, 1]], w_WP_E: numpy.ndarray[numpy.float64[3, 1]], V_PB_E: pydrake.multibody.math.SpatialVelocity_[float], A_PB_E: pydrake.multibody.math.SpatialAcceleration_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[float].ComposeWithMovingFrameAcceleration" title="Permalink to this definition">¶</a></dt>
<dd><p>This method composes <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WP</span></code> of a frame
P measured in a frame W, with that of a third frame B moving in P with
spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_PB</span></code>. The result is the spatial acceleration
<code class="docutils literal notranslate"><span class="pre">A_WB</span></code> of frame B measured in W. At the instant in which the
accelerations are composed, frame B is located with its origin Bo at
<code class="docutils literal notranslate"><span class="pre">p_PB</span></code> from P’s origin Po.</p>
<p>This operation can be written in a more compact form in terms of the
rigid shift operator <code class="docutils literal notranslate"><span class="pre">Φᵀ(p_PB)</span></code> (see SpatialVelocity::Shift()) as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A_WB</span> <span class="o">=</span> <span class="n">Φᵀ</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="n">A_WP</span> <span class="o">+</span> <span class="n">Ac_WB</span><span class="p">(</span><span class="n">w_WP</span><span class="p">,</span> <span class="n">V_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">A_PB_W</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">Φᵀ(p_PB)</span> <span class="pre">A_WP</span></code> denotes the application of the rigid shift
operation as in SpatialVelocity::Shift() and <code class="docutils literal notranslate"><span class="pre">Ac_WB(w_WP,</span> <span class="pre">V_PB)</span></code>
contains the centrifugal and Coriolis terms:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Ac_WB</span><span class="p">(</span><span class="n">w_WP</span><span class="p">,</span> <span class="n">V_PB</span><span class="p">)</span> <span class="o">=</span> <span class="o">|</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB_W</span>                          <span class="o">|</span>
                      <span class="o">|</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB_W</span> <span class="o">+</span> <span class="mi">2</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB_W</span> <span class="o">|</span>
                                  <span class="o">^^^</span>                <span class="o">^^^</span>
                              <span class="n">centrifugal</span>         <span class="n">Coriolis</span>
</pre></div>
</div>
<p>The equation above shows that composing spatial accelerations cannot
be simply accomplished by adding <code class="docutils literal notranslate"><span class="pre">A_WP</span></code> with <code class="docutils literal notranslate"><span class="pre">A_PB</span></code>. Moreover, we
see that, unlike with angular velocities, angular accelerations cannot
be added in order to compose them. That is <code class="docutils literal notranslate"><span class="pre">w_AC</span> <span class="pre">=</span> <span class="pre">w_AB</span> <span class="pre">+</span> <span class="pre">w_BC</span></code> but
<code class="docutils literal notranslate"><span class="pre">alpha_AC</span> <span class="pre">≠</span> <span class="pre">alpha_AB</span> <span class="pre">+</span> <span class="pre">alpha_BC</span></code> due to the cross term <code class="docutils literal notranslate"><span class="pre">w_AC</span> <span class="pre">x</span>
<span class="pre">w_BC</span></code>. See the derivation below for more details.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">SpatialVelocity::ComposeWithMovingFrameVelocity() for the
composition of SpatialVelocity quantities.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This method is the extension to the Shift() operator, which
computes the spatial acceleration frame P shifted to B as if frame
B moved rigidly with P, that is, for when <code class="docutils literal notranslate"><span class="pre">V_PB</span></code> and <code class="docutils literal notranslate"><span class="pre">A_PB</span></code>
are both zero. In other words the results from Shift() equal the
results from this method when <code class="docutils literal notranslate"><span class="pre">V_PB</span></code> and <code class="docutils literal notranslate"><span class="pre">A_PB</span></code> are both zero.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PB_E</span></code>:</dt>
<dd>Shift vector from P’s origin to B’s origin, expressed in frame E.
The “from” point <code class="docutils literal notranslate"><span class="pre">Po</span></code> must be the point whose acceleration is
currently represented in <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration, and E must
be the same expressed-in frame as for <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial
acceleration.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">w_WP_E</span></code>:</dt>
<dd>Angular velocity of frame P measured in frame W and expressed in
frame E.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">V_PB_E</span></code>:</dt>
<dd>The spatial velocity of a third frame B in motion with respect to
P, expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">A_PB_E</span></code>:</dt>
<dd>The spatial acceleration of a third frame B in motion with respect
to P, expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial
acceleration.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">A_WB_E</span></code>:</dt>
<dd>The spatial acceleration of frame B in W, expressed in frame E.</dd>
</dl>
<p>** Derivation **</p>
<p>The spatial velocity of frame B in W can be obtained by composing
<code class="docutils literal notranslate"><span class="pre">V_WP</span></code> with <code class="docutils literal notranslate"><span class="pre">V_PB</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">V_WB</span> <span class="o">=</span> <span class="n">V_WPb</span> <span class="o">+</span> <span class="n">V_PB</span> <span class="o">=</span> <span class="n">Φᵀ</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="n">V_WP</span> <span class="o">+</span> <span class="n">V_PB</span>                        <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>This operation can be performed with the method
SpatialVelocity::ComposeWithMovingFrameVelocity().</p>
<ul class="simple">
<li>Translational acceleration component *</li>
</ul>
<p>The translational velocity <code class="docutils literal notranslate"><span class="pre">v_WB</span></code> of point B in W corresponds to the
translational component in Eq. (1):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">v_WB</span> <span class="o">=</span> <span class="n">v_WP</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">v_PB</span>                                  <span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Therefore, for the translational acceleration we have:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a_WB</span> <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_WB</span><span class="p">)</span>
        <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_WP</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">v_PB</span><span class="p">)</span>
        <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_WP</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_PB</span><span class="p">)</span>
        <span class="o">=</span> <span class="n">a_WP</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_WP</span><span class="p">)</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">DtW</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_PB</span><span class="p">)</span>
        <span class="o">=</span> <span class="n">a_WP</span> <span class="o">+</span> <span class="n">alpha_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">DtW</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">v_PB</span><span class="p">)</span>     <span class="p">(</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
<p>with <code class="docutils literal notranslate"><span class="pre">a_WP</span> <span class="pre">=</span> <span class="pre">DtW(v_WP)</span></code> and <code class="docutils literal notranslate"><span class="pre">alpha_WP</span> <span class="pre">=</span> <span class="pre">DtW(w_WP)</span></code> by definition.
The term DtW(p_PB) in Eq. (3) is obtained by converting the vector
time derivative from <code class="docutils literal notranslate"><span class="pre">DtW()</span></code> to <code class="docutils literal notranslate"><span class="pre">DtP()</span></code>, see
drake::math::ConvertTimeDerivativeToOtherFrame():</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DtW</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="o">=</span> <span class="n">DtP</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span>
            <span class="o">=</span> <span class="n">v_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span>                                    <span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>since <code class="docutils literal notranslate"><span class="pre">v_PB</span> <span class="pre">=</span> <span class="pre">DtP(p_PB)</span></code> by definition. Similarly, the term
<code class="docutils literal notranslate"><span class="pre">DtW(v_PB)</span></code> in Eq. (3) is also obtained by converting the time
derivative from <code class="docutils literal notranslate"><span class="pre">DtW()</span></code> to <code class="docutils literal notranslate"><span class="pre">DtP()</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DtW</span><span class="p">(</span><span class="n">v_PB</span><span class="p">)</span> <span class="o">=</span> <span class="n">DtP</span><span class="p">(</span><span class="n">v_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span>
            <span class="o">=</span> <span class="n">a_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span>                                    <span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>with <code class="docutils literal notranslate"><span class="pre">a_PB</span> <span class="pre">=</span> <span class="pre">DtP(v_PB)</span></code> by definition. Using Eqs. (4) and (5) in Eq.
(3) yields for the translational acceleration:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a_WB</span> <span class="o">=</span> <span class="n">a_WP</span> <span class="o">+</span> <span class="n">alpha_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">a_PB</span> <span class="o">+</span> <span class="n">ac_WB</span>
  <span class="n">ac_WB</span> <span class="o">=</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="p">(</span><span class="n">v_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span>                 <span class="p">(</span><span class="mi">6</span><span class="p">)</span>
</pre></div>
</div>
<p>where finally the term <code class="docutils literal notranslate"><span class="pre">ac_WB</span></code> can be written as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ac_WB</span> <span class="o">=</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span>                      <span class="p">(</span><span class="mi">7</span><span class="p">)</span>
</pre></div>
</div>
<p>which includes the effect of angular acceleration of P in W <code class="docutils literal notranslate"><span class="pre">alpha_WP</span>
<span class="pre">x</span> <span class="pre">p_PB</span></code>, the centrifugal acceleration <code class="docutils literal notranslate"><span class="pre">w_WP</span> <span class="pre">x</span> <span class="pre">w_WP</span> <span class="pre">x</span> <span class="pre">p_PB</span></code>, the
Coriolis acceleration <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">w_WP</span> <span class="pre">x</span> <span class="pre">v_PB</span></code> due to the motion of B in P
and, the additional acceleration of B in P <code class="docutils literal notranslate"><span class="pre">a_PB</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Alternatively, we can write an efficient version of the
centrifugal term <code class="docutils literal notranslate"><span class="pre">ac_WB</span></code> in Eq. (6) for when the velocities of P
and B are available (e.g. from velocity kinematics). This is
accomplished by adding and subtracting v_WP within the
parenthesized term in Eq. (6) and grouping together v_WB = v_WPb +
v_PB = v_WP + w_WP x p_PB + v_PB:</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ac_WB</span> <span class="o">=</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="p">(</span><span class="n">v_WB</span> <span class="o">-</span> <span class="n">v_WP</span><span class="p">)</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span>
        <span class="o">=</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="p">(</span><span class="n">v_WB</span> <span class="o">-</span> <span class="n">v_WP</span> <span class="o">+</span> <span class="n">v_PB</span><span class="p">)</span>                               <span class="p">(</span><span class="mi">6</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>which simplifies the expression from three cross products to one.</p>
<ul class="simple">
<li>Rotational acceleration component *</li>
</ul>
<p>The rotational velocity <code class="docutils literal notranslate"><span class="pre">w_WB</span></code> of frame B in W corresponds to the
rotational component in Eq. (1):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">w_WB</span> <span class="o">=</span> <span class="n">w_WP</span> <span class="o">+</span> <span class="n">w_PB</span>                                                <span class="p">(</span><span class="mi">8</span><span class="p">)</span>
</pre></div>
</div>
<p>Therefore, the rotational acceleration of B in W corresponds to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">alpha_WB</span> <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_WB</span><span class="p">)</span> <span class="o">=</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_WP</span><span class="p">)</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_PB</span><span class="p">)</span>
           <span class="o">=</span> <span class="n">alpha_WP</span> <span class="o">+</span> <span class="n">DtW</span><span class="p">(</span><span class="n">w_PB</span><span class="p">)</span>                                   <span class="p">(</span><span class="mi">9</span><span class="p">)</span>
</pre></div>
</div>
<p>where the last term in Eq. (9) can be converted to a time derivative
in P as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">DtW</span><span class="p">(</span><span class="n">w_PB</span><span class="p">)</span> <span class="o">=</span> <span class="n">DtP</span><span class="p">(</span><span class="n">w_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB</span> <span class="o">=</span> <span class="n">alpha_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB</span>      <span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">alpha_PB</span> <span class="pre">=</span> <span class="pre">DtP(w_PB)</span></code> by definition. Thus, the final
expression for <code class="docutils literal notranslate"><span class="pre">alpha_WB</span></code> is obtained by using Eq. (10) into Eq.
(9):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">alpha_WB</span> <span class="o">=</span> <span class="n">alpha_WP</span> <span class="o">+</span> <span class="n">alpha_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB</span>                      <span class="p">(</span><span class="mi">11</span><span class="p">)</span>
</pre></div>
</div>
<p>Equation (11) shows that angular accelerations cannot be simply added
as angular velocities can but there exists an additional term <code class="docutils literal notranslate"><span class="pre">w_WP</span> <span class="pre">x</span>
<span class="pre">w_PB</span></code>.</p>
<ul class="simple">
<li>The spatial acceleration *</li>
</ul>
<p>The rotational and translational components of the spatial
acceleration are given by Eqs. (11) and (6) respectively:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A_WB</span><span class="o">.</span><span class="n">rotational</span><span class="p">()</span> <span class="o">=</span> <span class="n">alpha_WB</span>
                    <span class="o">=</span> <span class="p">{</span><span class="n">alpha_WP</span><span class="p">}</span> <span class="o">+</span> <span class="n">alpha_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB</span>           <span class="p">(</span><span class="mi">12</span><span class="p">)</span>
  <span class="n">A_WB</span><span class="o">.</span><span class="n">translational</span><span class="p">()</span> <span class="o">=</span> <span class="n">a_WB</span>
                       <span class="o">=</span> <span class="p">{</span><span class="n">a_WP</span> <span class="o">+</span> <span class="n">alpha_WP</span> <span class="n">x</span> <span class="n">p_PB</span> <span class="o">+</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB</span><span class="p">}</span>
                       <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB</span> <span class="o">+</span> <span class="n">a_PB</span>                     <span class="p">(</span><span class="mi">13</span><span class="p">)</span>
</pre></div>
</div>
<p>where we have placed within curly brackets <code class="docutils literal notranslate"><span class="pre">{}</span></code> all the terms that
also appear in the Shift() operation, which is equivalent to this
method when <code class="docutils literal notranslate"><span class="pre">V_PB</span></code> and <code class="docutils literal notranslate"><span class="pre">A_PB</span></code> are both zero. In the equations
above <code class="docutils literal notranslate"><span class="pre">alpha_WP</span> <span class="pre">=</span> <span class="pre">A_WP.rotational()</span></code> and <code class="docutils literal notranslate"><span class="pre">a_WP</span> <span class="pre">=</span>
<span class="pre">A_WP.translational()</span></code>. The above expression can be written in a more
compact form in terms of the rigid shift operator <code class="docutils literal notranslate"><span class="pre">Φᵀ(p_PB)</span></code> (see
SpatialVelocity::Shift()) as presented in the main body of this
documentation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A_WB</span> <span class="o">=</span> <span class="n">Φᵀ</span><span class="p">(</span><span class="n">p_PB</span><span class="p">)</span><span class="n">A_WP</span> <span class="o">+</span> <span class="n">Ac_WB</span><span class="p">(</span><span class="n">w_WP</span><span class="p">,</span> <span class="n">V_PB</span><span class="p">)</span> <span class="o">+</span> <span class="n">A_PB_W</span>                  <span class="p">(</span><span class="mi">14</span><span class="p">)</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">Ac_WB(w_WP,</span> <span class="pre">V_PB)</span></code> contains the centrifugal and Coriolis
terms:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Ac_WB</span><span class="p">(</span><span class="n">w_WP</span><span class="p">,</span> <span class="n">V_PB</span><span class="p">)</span> <span class="o">=</span> <span class="o">|</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_PB_W</span>                          <span class="o">|</span>
                      <span class="o">|</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">p_PB_W</span> <span class="o">+</span> <span class="mi">2</span> <span class="n">w_WP</span> <span class="n">x</span> <span class="n">v_PB_W</span> <span class="o">|</span>
                                  <span class="o">^^^</span>                <span class="o">^^^</span>
                              <span class="n">centrifugal</span>         <span class="n">Coriolis</span>
</pre></div>
</div>
<p>As usual, for computation, all quantities above must be expressed in a
common frame E; we add an <code class="docutils literal notranslate"><span class="pre">_E</span></code> suffix to each symbol to indicate
that.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[float].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[float].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[float].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[float], R_FE: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[float].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[float].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[float].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[float].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[float].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[float].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[float].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>Shift(self: pydrake.multibody.math.SpatialAcceleration_[float], p_PoQ_E: numpy.ndarray[numpy.float64[3, 1]], w_WP_E: numpy.ndarray[numpy.float64[3, 1]]) -&gt; pydrake.multibody.math.SpatialAcceleration_[float]</li>
</ol>
<p>Shifts <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WP</span></code> of a frame P into the
spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WPq</span></code> of a frame <code class="docutils literal notranslate"><span class="pre">Pq</span></code> which is an offset
frame rigidly aligned with P, but with its origin shifted to a point Q
by an offset p_PoQ. Frame <code class="docutils literal notranslate"><span class="pre">Pq</span></code> is instantaneously moving together
with frame P as if rigidly attached to it. As an example of
application, this operation can be used to compute <code class="docutils literal notranslate"><span class="pre">A_WPq</span></code> where P
is a frame on a rigid body and Q is another point on that same body.
Therefore P and <code class="docutils literal notranslate"><span class="pre">Pq</span></code> move together with the spatial velocity
<code class="docutils literal notranslate"><span class="pre">V_PPq</span></code> being zero at all times. This is an alternate signature for
shifting a spatial acceleration that does not change the original
object. See ShiftInPlace() for more information and a description of
the arguments.</p>
<ol class="arabic simple" start="2">
<li>Shift(self: pydrake.multibody.math.SpatialAcceleration_[float], p_PoQ_E: numpy.ndarray[numpy.float64[3, 1]]) -&gt; pydrake.multibody.math.SpatialAcceleration_[float]</li>
</ol>
<p>(Advanced) Given <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration <code class="docutils literal notranslate"><span class="pre">A_WP</span></code> of a frame P
in a second frame W, this operation is only valid when the angular
velocity <code class="docutils literal notranslate"><span class="pre">w_WP</span></code> of P in W is zero. Refer to Shift(const Vector3&lt;T&gt;&amp;,
const Vector3&lt;T&gt;&amp;) for the full version that includes velocity terms.
This method can be used to avoid unnecessary computation when shifting
<code class="docutils literal notranslate"><span class="pre">this</span></code> spatial acceleration of a frame P into the spatial
acceleration of the shifted frame <code class="docutils literal notranslate"><span class="pre">Pq</span></code>. The shift position vector is
given by <code class="docutils literal notranslate"><span class="pre">p_PoQ_E</span></code>, expresssed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code>
spatial` acceleration. Mathematically, this returns <code class="docutils literal notranslate"><span class="pre">A_WPq</span> <span class="pre">=</span>
<span class="pre">Φᵀ(p_PoQ)A_WP</span></code>, where <code class="docutils literal notranslate"><span class="pre">Φ(p_PoQ)</span></code> is the rigid shift operator, see
SpatialVelocity::Shift().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialAcceleration_[float].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialAcceleration_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[float].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialAcceleration_[float].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialAcceleration_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialAcceleration_[float].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> SpatialVector, i.e. rotational and
translational components are both zero.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.math.SpatialForce">
<code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialForce</code><a class="headerlink" href="#pydrake.multibody.math.SpatialForce" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.math.SpatialForce_[float]" title="pydrake.multibody.math.SpatialForce_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.math.SpatialForce_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.math.SpatialForce_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialForce_</code><a class="headerlink" href="#pydrake.multibody.math.SpatialForce_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.math.SpatialForce_[float]" title="pydrake.multibody.math.SpatialForce_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialForce_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.math.SpatialForce_[AutoDiffXd]" title="pydrake.multibody.math.SpatialForce_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialForce_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.math.SpatialForce_[Expression]" title="pydrake.multibody.math.SpatialForce_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialForce_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.math.SpatialForce_.SpatialForce_[float]">
<em class="property">class </em><code class="descname">SpatialForce_[float]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialForce_.SpatialForce_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is used to represent a <em>spatial force</em> (also called a
<em>wrench</em>) that combines both rotational (torque) and translational
force components. Spatial forces are 6-element quantities that are
pairs of ordinary 3-vectors. Elements 0-2 are the torque component
while elements 3-5 are the force component. Both vectors must be
expressed in the same frame, and the translational force is applied to
a particular point of a body, but neither the frame nor the point are
stored with a SpatialForce object; they must be understood from
context. It is the responsibility of the user to keep track of the
application point and the expressed-in frame. That is best
accomplished through disciplined notation. In source code we use
monogram notation where capital F is used to designate a spatial force
quantity. We write a point P fixed to body (or frame) B as <span class="math notranslate nohighlight">\(B_P\)</span>
which appears in code and comments as <code class="docutils literal notranslate"><span class="pre">Bp</span></code>. Then we write a
particular spatial force as <code class="docutils literal notranslate"><span class="pre">F_Bp_E</span></code> where the <code class="docutils literal notranslate"><span class="pre">_E</span></code> suffix
indicates that the expressed-in frame is E. This symbol represents a
torque applied to body B, and a force applied to point P on B, with
both vectors expressed in E. Very often the application point will be
the body origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code>; if no point is shown the origin is understood,
so <code class="docutils literal notranslate"><span class="pre">F_B_E</span></code> means <code class="docutils literal notranslate"><span class="pre">F_Bo_E</span></code>. For a more detailed introduction on
spatial vectors and the monogram notation please refer to section
multibody_spatial_vectors.</p>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_.SpatialForce_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialForce_.SpatialForce_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialForce_[float]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialForce_[float], tau: numpy.ndarray[numpy.float64[3, 1]], f: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>SpatialForce constructor from a torque <code class="docutils literal notranslate"><span class="pre">tau</span></code> and a force <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialForce_[float], F: numpy.ndarray[numpy.float64[6, 1]]) -&gt; None</li>
</ol>
<p>SpatialForce constructor from an Eigen expression that represents a
six-dimensional vector. This constructor will assert the size of F is
six (6) at compile-time for fixed sized Eigen expressions and at
run-time for dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_.SpatialForce_[float].dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[float], V_IBp_E: pydrake.multibody.math.SpatialVelocity_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_.SpatialForce_[float].dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial force <code class="docutils literal notranslate"><span class="pre">F_Bp_E</span></code> applied at point P of body B
and expressed in a frame E, this method computes the 6-dimensional dot
product with the spatial velocity <code class="docutils literal notranslate"><span class="pre">V_IBp_E</span></code> of body B at point P,
measured in an inertial frame I and expressed in the same frame E in
which the spatial force is expressed. This dot-product represents the
power generated by <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial force when its body and
application point have the given spatial velocity. Although the two
spatial vectors must be expressed in the same frame, the result is
independent of that frame.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The result of this method cannot be interpreted as power unless
the spatial velocity is measured in an inertial frame I.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_.SpatialForce_[float].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_.SpatialForce_[float].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_.SpatialForce_[float].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[float], R_FE: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_.SpatialForce_[float].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_.SpatialForce_[float].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_.SpatialForce_[float].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_.SpatialForce_[float].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_.SpatialForce_[float].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_.SpatialForce_[float].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[float], p_BpBq_E: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_.SpatialForce_[float].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift of a SpatialForce from one application point to another. This is
an alternate signature for shifting a spatial force’s application
point that does not change the original object. See ShiftInPlace() for
more information.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BpBq_E</span></code>:</dt>
<dd>Shift vector from point P of body B to point Q of B, expressed in
frame E. The “from” point <code class="docutils literal notranslate"><span class="pre">Bp</span></code> must be the current application
point of <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial force, and E must be the same
expressed-in frame as for this spatial force.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">F_Bq_E</span></code>:</dt>
<dd>The equivalent shifted spatial force, now applied at point Q
rather than P.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() to compute the shifted spatial force in-place
modifying the original object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_.SpatialForce_[float].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_.SpatialForce_[float].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialForce_.SpatialForce_[float].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_.SpatialForce_[float].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> SpatialVector, i.e. rotational and
translational components are both zero.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.math.SpatialForce_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialForce_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is used to represent a <em>spatial force</em> (also called a
<em>wrench</em>) that combines both rotational (torque) and translational
force components. Spatial forces are 6-element quantities that are
pairs of ordinary 3-vectors. Elements 0-2 are the torque component
while elements 3-5 are the force component. Both vectors must be
expressed in the same frame, and the translational force is applied to
a particular point of a body, but neither the frame nor the point are
stored with a SpatialForce object; they must be understood from
context. It is the responsibility of the user to keep track of the
application point and the expressed-in frame. That is best
accomplished through disciplined notation. In source code we use
monogram notation where capital F is used to designate a spatial force
quantity. We write a point P fixed to body (or frame) B as <span class="math notranslate nohighlight">\(B_P\)</span>
which appears in code and comments as <code class="docutils literal notranslate"><span class="pre">Bp</span></code>. Then we write a
particular spatial force as <code class="docutils literal notranslate"><span class="pre">F_Bp_E</span></code> where the <code class="docutils literal notranslate"><span class="pre">_E</span></code> suffix
indicates that the expressed-in frame is E. This symbol represents a
torque applied to body B, and a force applied to point P on B, with
both vectors expressed in E. Very often the application point will be
the body origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code>; if no point is shown the origin is understood,
so <code class="docutils literal notranslate"><span class="pre">F_B_E</span></code> means <code class="docutils literal notranslate"><span class="pre">F_Bo_E</span></code>. For a more detailed introduction on
spatial vectors and the monogram notation please refer to section
multibody_spatial_vectors.</p>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialForce_[AutoDiffXd]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialForce_[AutoDiffXd], tau: numpy.ndarray[object[3, 1]], f: numpy.ndarray[object[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>SpatialForce constructor from a torque <code class="docutils literal notranslate"><span class="pre">tau</span></code> and a force <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialForce_[AutoDiffXd], F: numpy.ndarray[object[6, 1]]) -&gt; None</li>
</ol>
<p>SpatialForce constructor from an Eigen expression that represents a
six-dimensional vector. This constructor will assert the size of F is
six (6) at compile-time for fixed sized Eigen expressions and at
run-time for dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[AutoDiffXd].dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[AutoDiffXd], V_IBp_E: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.autodiffutils.AutoDiffXd<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[AutoDiffXd].dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial force <code class="docutils literal notranslate"><span class="pre">F_Bp_E</span></code> applied at point P of body B
and expressed in a frame E, this method computes the 6-dimensional dot
product with the spatial velocity <code class="docutils literal notranslate"><span class="pre">V_IBp_E</span></code> of body B at point P,
measured in an inertial frame I and expressed in the same frame E in
which the spatial force is expressed. This dot-product represents the
power generated by <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial force when its body and
application point have the given spatial velocity. Although the two
spatial vectors must be expressed in the same frame, the result is
independent of that frame.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The result of this method cannot be interpreted as power unless
the spatial velocity is measured in an inertial frame I.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[AutoDiffXd].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[AutoDiffXd].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[AutoDiffXd].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[AutoDiffXd], R_FE: pydrake.math.RotationMatrix_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[AutoDiffXd].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[AutoDiffXd].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[AutoDiffXd].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[AutoDiffXd].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[AutoDiffXd].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[AutoDiffXd].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[AutoDiffXd], p_BpBq_E: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[AutoDiffXd].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift of a SpatialForce from one application point to another. This is
an alternate signature for shifting a spatial force’s application
point that does not change the original object. See ShiftInPlace() for
more information.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BpBq_E</span></code>:</dt>
<dd>Shift vector from point P of body B to point Q of B, expressed in
frame E. The “from” point <code class="docutils literal notranslate"><span class="pre">Bp</span></code> must be the current application
point of <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial force, and E must be the same
expressed-in frame as for this spatial force.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">F_Bq_E</span></code>:</dt>
<dd>The equivalent shifted spatial force, now applied at point Q
rather than P.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() to compute the shifted spatial force in-place
modifying the original object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[AutoDiffXd].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[AutoDiffXd].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialForce_[AutoDiffXd].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[AutoDiffXd].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> SpatialVector, i.e. rotational and
translational components are both zero.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.math.SpatialForce_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialForce_[Expression]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is used to represent a <em>spatial force</em> (also called a
<em>wrench</em>) that combines both rotational (torque) and translational
force components. Spatial forces are 6-element quantities that are
pairs of ordinary 3-vectors. Elements 0-2 are the torque component
while elements 3-5 are the force component. Both vectors must be
expressed in the same frame, and the translational force is applied to
a particular point of a body, but neither the frame nor the point are
stored with a SpatialForce object; they must be understood from
context. It is the responsibility of the user to keep track of the
application point and the expressed-in frame. That is best
accomplished through disciplined notation. In source code we use
monogram notation where capital F is used to designate a spatial force
quantity. We write a point P fixed to body (or frame) B as <span class="math notranslate nohighlight">\(B_P\)</span>
which appears in code and comments as <code class="docutils literal notranslate"><span class="pre">Bp</span></code>. Then we write a
particular spatial force as <code class="docutils literal notranslate"><span class="pre">F_Bp_E</span></code> where the <code class="docutils literal notranslate"><span class="pre">_E</span></code> suffix
indicates that the expressed-in frame is E. This symbol represents a
torque applied to body B, and a force applied to point P on B, with
both vectors expressed in E. Very often the application point will be
the body origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code>; if no point is shown the origin is understood,
so <code class="docutils literal notranslate"><span class="pre">F_B_E</span></code> means <code class="docutils literal notranslate"><span class="pre">F_Bo_E</span></code>. For a more detailed introduction on
spatial vectors and the monogram notation please refer to section
multibody_spatial_vectors.</p>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialForce_[Expression]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialForce_[Expression], tau: numpy.ndarray[object[3, 1]], f: numpy.ndarray[object[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>SpatialForce constructor from a torque <code class="docutils literal notranslate"><span class="pre">tau</span></code> and a force <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialForce_[Expression], F: numpy.ndarray[object[6, 1]]) -&gt; None</li>
</ol>
<p>SpatialForce constructor from an Eigen expression that represents a
six-dimensional vector. This constructor will assert the size of F is
six (6) at compile-time for fixed sized Eigen expressions and at
run-time for dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[Expression].dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[Expression], V_IBp_E: pydrake.multibody.math.SpatialVelocity_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[Expression].dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial force <code class="docutils literal notranslate"><span class="pre">F_Bp_E</span></code> applied at point P of body B
and expressed in a frame E, this method computes the 6-dimensional dot
product with the spatial velocity <code class="docutils literal notranslate"><span class="pre">V_IBp_E</span></code> of body B at point P,
measured in an inertial frame I and expressed in the same frame E in
which the spatial force is expressed. This dot-product represents the
power generated by <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial force when its body and
application point have the given spatial velocity. Although the two
spatial vectors must be expressed in the same frame, the result is
independent of that frame.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The result of this method cannot be interpreted as power unless
the spatial velocity is measured in an inertial frame I.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[Expression].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[Expression].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[Expression].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[Expression], R_FE: pydrake.math.RotationMatrix_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[Expression].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[Expression].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[Expression].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[Expression].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[Expression].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[Expression].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[Expression], p_BpBq_E: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[Expression].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift of a SpatialForce from one application point to another. This is
an alternate signature for shifting a spatial force’s application
point that does not change the original object. See ShiftInPlace() for
more information.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BpBq_E</span></code>:</dt>
<dd>Shift vector from point P of body B to point Q of B, expressed in
frame E. The “from” point <code class="docutils literal notranslate"><span class="pre">Bp</span></code> must be the current application
point of <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial force, and E must be the same
expressed-in frame as for this spatial force.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">F_Bq_E</span></code>:</dt>
<dd>The equivalent shifted spatial force, now applied at point Q
rather than P.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() to compute the shifted spatial force in-place
modifying the original object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[Expression].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[Expression].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialForce_[Expression].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[Expression].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> SpatialVector, i.e. rotational and
translational components are both zero.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.math.SpatialForce_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialForce_[float]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is used to represent a <em>spatial force</em> (also called a
<em>wrench</em>) that combines both rotational (torque) and translational
force components. Spatial forces are 6-element quantities that are
pairs of ordinary 3-vectors. Elements 0-2 are the torque component
while elements 3-5 are the force component. Both vectors must be
expressed in the same frame, and the translational force is applied to
a particular point of a body, but neither the frame nor the point are
stored with a SpatialForce object; they must be understood from
context. It is the responsibility of the user to keep track of the
application point and the expressed-in frame. That is best
accomplished through disciplined notation. In source code we use
monogram notation where capital F is used to designate a spatial force
quantity. We write a point P fixed to body (or frame) B as <span class="math notranslate nohighlight">\(B_P\)</span>
which appears in code and comments as <code class="docutils literal notranslate"><span class="pre">Bp</span></code>. Then we write a
particular spatial force as <code class="docutils literal notranslate"><span class="pre">F_Bp_E</span></code> where the <code class="docutils literal notranslate"><span class="pre">_E</span></code> suffix
indicates that the expressed-in frame is E. This symbol represents a
torque applied to body B, and a force applied to point P on B, with
both vectors expressed in E. Very often the application point will be
the body origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code>; if no point is shown the origin is understood,
so <code class="docutils literal notranslate"><span class="pre">F_B_E</span></code> means <code class="docutils literal notranslate"><span class="pre">F_Bo_E</span></code>. For a more detailed introduction on
spatial vectors and the monogram notation please refer to section
multibody_spatial_vectors.</p>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialForce_[float]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialForce_[float], tau: numpy.ndarray[numpy.float64[3, 1]], f: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>SpatialForce constructor from a torque <code class="docutils literal notranslate"><span class="pre">tau</span></code> and a force <code class="docutils literal notranslate"><span class="pre">f</span></code>.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialForce_[float], F: numpy.ndarray[numpy.float64[6, 1]]) -&gt; None</li>
</ol>
<p>SpatialForce constructor from an Eigen expression that represents a
six-dimensional vector. This constructor will assert the size of F is
six (6) at compile-time for fixed sized Eigen expressions and at
run-time for dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[float].dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[float], V_IBp_E: pydrake.multibody.math.SpatialVelocity_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[float].dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial force <code class="docutils literal notranslate"><span class="pre">F_Bp_E</span></code> applied at point P of body B
and expressed in a frame E, this method computes the 6-dimensional dot
product with the spatial velocity <code class="docutils literal notranslate"><span class="pre">V_IBp_E</span></code> of body B at point P,
measured in an inertial frame I and expressed in the same frame E in
which the spatial force is expressed. This dot-product represents the
power generated by <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial force when its body and
application point have the given spatial velocity. Although the two
spatial vectors must be expressed in the same frame, the result is
independent of that frame.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The result of this method cannot be interpreted as power unless
the spatial velocity is measured in an inertial frame I.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[float].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[float].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[float].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[float], R_FE: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[float].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[float].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[float].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[float].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[float].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[float].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[float], p_BpBq_E: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[float].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift of a SpatialForce from one application point to another. This is
an alternate signature for shifting a spatial force’s application
point that does not change the original object. See ShiftInPlace() for
more information.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BpBq_E</span></code>:</dt>
<dd>Shift vector from point P of body B to point Q of B, expressed in
frame E. The “from” point <code class="docutils literal notranslate"><span class="pre">Bp</span></code> must be the current application
point of <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial force, and E must be the same
expressed-in frame as for this spatial force.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">F_Bq_E</span></code>:</dt>
<dd>The equivalent shifted spatial force, now applied at point Q
rather than P.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() to compute the shifted spatial force in-place
modifying the original object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialForce_[float].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialForce_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[float].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialForce_[float].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialForce_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialForce_[float].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> SpatialVector, i.e. rotational and
translational components are both zero.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.math.SpatialMomentum">
<code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialMomentum</code><a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.math.SpatialMomentum_[float]" title="pydrake.multibody.math.SpatialMomentum_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.math.SpatialMomentum_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.math.SpatialMomentum_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialMomentum_</code><a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.math.SpatialMomentum_[float]" title="pydrake.multibody.math.SpatialMomentum_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialMomentum_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]" title="pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialMomentum_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.math.SpatialMomentum_[Expression]" title="pydrake.multibody.math.SpatialMomentum_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialMomentum_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float]">
<em class="property">class </em><code class="descname">SpatialMomentum_[float]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is used to represent the <em>spatial momentum</em> of a particle,
system of particles or body (whether rigid or soft.) The linear
momentum <code class="docutils literal notranslate"><span class="pre">l_NS</span></code> of a system of particles S in a reference frame N is
defined by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>l_NS = ∑l_NQi = ∑mᵢv_NQi
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">mᵢ</span></code> and <code class="docutils literal notranslate"><span class="pre">v_NQi</span></code> are the mass and linear velocity (in frame
N) of the i-th particle in the system, respectively. Their product
<code class="docutils literal notranslate"><span class="pre">l_NQi</span> <span class="pre">=</span> <span class="pre">mᵢv_NQi</span></code> is the linear momentum of the i-th particle in the
N reference frame. The angular momentum <code class="docutils literal notranslate"><span class="pre">h_NSp</span></code> of a system of
particles S in a reference frame N about an arbitrary point P is
defined by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>h_NSp = ∑ p_PQi x l_NQi
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">p_PQi</span></code> is the position vector from point P to the i-th
particle position <code class="docutils literal notranslate"><span class="pre">Qi</span></code>. The definitions above extend to a continuum
of particles as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>h_NSp = ∫p_PQ(r) x v_NQ(r) ρ(r)d³r
  l_NS = ∫v_NQ(r) ρ(r)d³r
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">ρ(r)</span></code> is the density of the body at each material location
<code class="docutils literal notranslate"><span class="pre">r</span></code>. In particular, the continuum version above also applies to
rigid bodies.</p>
<p>Spatial momenta are elements of F⁶ (see [Featherstone 2008]) that
combine both rotational (angular momentum) and translational (linear
momentum) components. Spatial momenta are 6-element quantities that
are pairs of ordinary 3-vectors. Elements 0-2 are the angular momentum
component while elements 3-5 are the linear momentum component. As
with any other spatial vector, both vector components must be
expressed in the same frame.</p>
<p>Neither the expressed-in frame nor the about-point are stored with a
SpatialMomentum object; they must be understood from context. It is
the responsibility of the user to keep track of the about-point and
the expressed-in frame. That is best accomplished through disciplined
notation. In source code we use monogram notation where L designates a
spatial momentum quantity. The spatial momentum of a system S in a
frame N about an arbitrary point P, expressed in a frame E is typeset
as <span class="math notranslate nohighlight">\([^NL^{S/P}]_E\)</span>, which appears in code as <code class="docutils literal notranslate"><span class="pre">L_NSP_E</span></code>. The
spatial momentum of a body B in a frame N about the body origin Bo is
explicitly typeset as L_NBBo_E, but we abbreviate it as L_NBo_E.
Similarly, the spatial momentum of a system S in a frame N about Scm
(the system center of mass), expressed in a frame E is explicitly
typeset as L_NSScm_E, but we abbreviate it as L_NScm_E. For a more
detailed introduction on spatial vectors and the monogram notation
please refer to section multibody_spatial_vectors.</p>
<ul class="simple">
<li><dl class="first docutils">
<dt>[Featherstone 2008] Featherstone, R., 2008. Rigid body dynamics</dt>
<dd>algorithms. Springer.</dd>
</dl>
</li>
</ul>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialMomentum_[float]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialMomentum_[float], h: numpy.ndarray[numpy.float64[3, 1]], l: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>SpatialMomentum constructor from an angular momentum h and a linear
momentum l.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialMomentum_[float], L: numpy.ndarray[numpy.float64[6, 1]]) -&gt; None</li>
</ol>
<p>SpatialMomentum constructor from an Eigen expression that represents a
six-dimensional vector. This constructor will assert the size of L is
six (6) at compile-time for fixed sized Eigen expressions and at
run-time for dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[float], V_IBp_E: pydrake.multibody.math.SpatialVelocity_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial momentum <code class="docutils literal notranslate"><span class="pre">L_NBp_E</span></code> of a rigid body B, about
point P and, expressed in a frame E, this method computes the dot
product with the spatial velocity <code class="docutils literal notranslate"><span class="pre">V_NBp_E</span></code> of body B frame shifted
to point P, measured in an inertial (or Newtonian) frame N and
expressed in the same frame E in which the spatial momentum is
expressed. This dot-product is twice the kinetic energy <code class="docutils literal notranslate"><span class="pre">ke_NB</span></code> of
body B in reference frame N. The kinetic energy <code class="docutils literal notranslate"><span class="pre">ke_NB</span></code> is
independent of the about-point P and so is this dot product. Therefore
it is always true that:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>ke_NB = 1/2 (L_NBp⋅V_NBp) = 1/2 (L_NBcm⋅V_NBcm)
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">L_NBcm</span></code> is the spatial momentum about the center of mass of
body B and <code class="docutils literal notranslate"><span class="pre">V_NBcm</span></code> is the spatial velocity of frame B shifted to
its center of mass. The above is true due to how spatial momentum and
velocity shift when changing point P, see SpatialMomentum::Shift() and
SpatialVelocity::Shift().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[float], R_FE: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[float], p_BpBq_E: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift of a SpatialMomentum from one application point to another. This
is an alternate signature for shifting a spatial momentum’s
about-point that does not change the original object. See
ShiftInPlace() for more information.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PQ_E</span></code>:</dt>
<dd>Shift vector from point P to point Q.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">L_NSq_E</span></code>:</dt>
<dd>The equivalent shifted spatial momentum, now applied at point Q
rather than P.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() to compute the shifted spatial momentum in-place
modifying the original object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_.SpatialMomentum_[float].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> SpatialVector, i.e. rotational and
translational components are both zero.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialMomentum_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is used to represent the <em>spatial momentum</em> of a particle,
system of particles or body (whether rigid or soft.) The linear
momentum <code class="docutils literal notranslate"><span class="pre">l_NS</span></code> of a system of particles S in a reference frame N is
defined by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>l_NS = ∑l_NQi = ∑mᵢv_NQi
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">mᵢ</span></code> and <code class="docutils literal notranslate"><span class="pre">v_NQi</span></code> are the mass and linear velocity (in frame
N) of the i-th particle in the system, respectively. Their product
<code class="docutils literal notranslate"><span class="pre">l_NQi</span> <span class="pre">=</span> <span class="pre">mᵢv_NQi</span></code> is the linear momentum of the i-th particle in the
N reference frame. The angular momentum <code class="docutils literal notranslate"><span class="pre">h_NSp</span></code> of a system of
particles S in a reference frame N about an arbitrary point P is
defined by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>h_NSp = ∑ p_PQi x l_NQi
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">p_PQi</span></code> is the position vector from point P to the i-th
particle position <code class="docutils literal notranslate"><span class="pre">Qi</span></code>. The definitions above extend to a continuum
of particles as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>h_NSp = ∫p_PQ(r) x v_NQ(r) ρ(r)d³r
  l_NS = ∫v_NQ(r) ρ(r)d³r
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">ρ(r)</span></code> is the density of the body at each material location
<code class="docutils literal notranslate"><span class="pre">r</span></code>. In particular, the continuum version above also applies to
rigid bodies.</p>
<p>Spatial momenta are elements of F⁶ (see [Featherstone 2008]) that
combine both rotational (angular momentum) and translational (linear
momentum) components. Spatial momenta are 6-element quantities that
are pairs of ordinary 3-vectors. Elements 0-2 are the angular momentum
component while elements 3-5 are the linear momentum component. As
with any other spatial vector, both vector components must be
expressed in the same frame.</p>
<p>Neither the expressed-in frame nor the about-point are stored with a
SpatialMomentum object; they must be understood from context. It is
the responsibility of the user to keep track of the about-point and
the expressed-in frame. That is best accomplished through disciplined
notation. In source code we use monogram notation where L designates a
spatial momentum quantity. The spatial momentum of a system S in a
frame N about an arbitrary point P, expressed in a frame E is typeset
as <span class="math notranslate nohighlight">\([^NL^{S/P}]_E\)</span>, which appears in code as <code class="docutils literal notranslate"><span class="pre">L_NSP_E</span></code>. The
spatial momentum of a body B in a frame N about the body origin Bo is
explicitly typeset as L_NBBo_E, but we abbreviate it as L_NBo_E.
Similarly, the spatial momentum of a system S in a frame N about Scm
(the system center of mass), expressed in a frame E is explicitly
typeset as L_NSScm_E, but we abbreviate it as L_NScm_E. For a more
detailed introduction on spatial vectors and the monogram notation
please refer to section multibody_spatial_vectors.</p>
<ul class="simple">
<li><dl class="first docutils">
<dt>[Featherstone 2008] Featherstone, R., 2008. Rigid body dynamics</dt>
<dd>algorithms. Springer.</dd>
</dl>
</li>
</ul>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialMomentum_[AutoDiffXd], h: numpy.ndarray[object[3, 1]], l: numpy.ndarray[object[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>SpatialMomentum constructor from an angular momentum h and a linear
momentum l.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialMomentum_[AutoDiffXd], L: numpy.ndarray[object[6, 1]]) -&gt; None</li>
</ol>
<p>SpatialMomentum constructor from an Eigen expression that represents a
six-dimensional vector. This constructor will assert the size of L is
six (6) at compile-time for fixed sized Eigen expressions and at
run-time for dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[AutoDiffXd], V_IBp_E: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.autodiffutils.AutoDiffXd<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial momentum <code class="docutils literal notranslate"><span class="pre">L_NBp_E</span></code> of a rigid body B, about
point P and, expressed in a frame E, this method computes the dot
product with the spatial velocity <code class="docutils literal notranslate"><span class="pre">V_NBp_E</span></code> of body B frame shifted
to point P, measured in an inertial (or Newtonian) frame N and
expressed in the same frame E in which the spatial momentum is
expressed. This dot-product is twice the kinetic energy <code class="docutils literal notranslate"><span class="pre">ke_NB</span></code> of
body B in reference frame N. The kinetic energy <code class="docutils literal notranslate"><span class="pre">ke_NB</span></code> is
independent of the about-point P and so is this dot product. Therefore
it is always true that:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>ke_NB = 1/2 (L_NBp⋅V_NBp) = 1/2 (L_NBcm⋅V_NBcm)
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">L_NBcm</span></code> is the spatial momentum about the center of mass of
body B and <code class="docutils literal notranslate"><span class="pre">V_NBcm</span></code> is the spatial velocity of frame B shifted to
its center of mass. The above is true due to how spatial momentum and
velocity shift when changing point P, see SpatialMomentum::Shift() and
SpatialVelocity::Shift().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[AutoDiffXd], R_FE: pydrake.math.RotationMatrix_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[AutoDiffXd], p_BpBq_E: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift of a SpatialMomentum from one application point to another. This
is an alternate signature for shifting a spatial momentum’s
about-point that does not change the original object. See
ShiftInPlace() for more information.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PQ_E</span></code>:</dt>
<dd>Shift vector from point P to point Q.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">L_NSq_E</span></code>:</dt>
<dd>The equivalent shifted spatial momentum, now applied at point Q
rather than P.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() to compute the shifted spatial momentum in-place
modifying the original object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[AutoDiffXd].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> SpatialVector, i.e. rotational and
translational components are both zero.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.math.SpatialMomentum_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialMomentum_[Expression]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is used to represent the <em>spatial momentum</em> of a particle,
system of particles or body (whether rigid or soft.) The linear
momentum <code class="docutils literal notranslate"><span class="pre">l_NS</span></code> of a system of particles S in a reference frame N is
defined by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>l_NS = ∑l_NQi = ∑mᵢv_NQi
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">mᵢ</span></code> and <code class="docutils literal notranslate"><span class="pre">v_NQi</span></code> are the mass and linear velocity (in frame
N) of the i-th particle in the system, respectively. Their product
<code class="docutils literal notranslate"><span class="pre">l_NQi</span> <span class="pre">=</span> <span class="pre">mᵢv_NQi</span></code> is the linear momentum of the i-th particle in the
N reference frame. The angular momentum <code class="docutils literal notranslate"><span class="pre">h_NSp</span></code> of a system of
particles S in a reference frame N about an arbitrary point P is
defined by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>h_NSp = ∑ p_PQi x l_NQi
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">p_PQi</span></code> is the position vector from point P to the i-th
particle position <code class="docutils literal notranslate"><span class="pre">Qi</span></code>. The definitions above extend to a continuum
of particles as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>h_NSp = ∫p_PQ(r) x v_NQ(r) ρ(r)d³r
  l_NS = ∫v_NQ(r) ρ(r)d³r
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">ρ(r)</span></code> is the density of the body at each material location
<code class="docutils literal notranslate"><span class="pre">r</span></code>. In particular, the continuum version above also applies to
rigid bodies.</p>
<p>Spatial momenta are elements of F⁶ (see [Featherstone 2008]) that
combine both rotational (angular momentum) and translational (linear
momentum) components. Spatial momenta are 6-element quantities that
are pairs of ordinary 3-vectors. Elements 0-2 are the angular momentum
component while elements 3-5 are the linear momentum component. As
with any other spatial vector, both vector components must be
expressed in the same frame.</p>
<p>Neither the expressed-in frame nor the about-point are stored with a
SpatialMomentum object; they must be understood from context. It is
the responsibility of the user to keep track of the about-point and
the expressed-in frame. That is best accomplished through disciplined
notation. In source code we use monogram notation where L designates a
spatial momentum quantity. The spatial momentum of a system S in a
frame N about an arbitrary point P, expressed in a frame E is typeset
as <span class="math notranslate nohighlight">\([^NL^{S/P}]_E\)</span>, which appears in code as <code class="docutils literal notranslate"><span class="pre">L_NSP_E</span></code>. The
spatial momentum of a body B in a frame N about the body origin Bo is
explicitly typeset as L_NBBo_E, but we abbreviate it as L_NBo_E.
Similarly, the spatial momentum of a system S in a frame N about Scm
(the system center of mass), expressed in a frame E is explicitly
typeset as L_NSScm_E, but we abbreviate it as L_NScm_E. For a more
detailed introduction on spatial vectors and the monogram notation
please refer to section multibody_spatial_vectors.</p>
<ul class="simple">
<li><dl class="first docutils">
<dt>[Featherstone 2008] Featherstone, R., 2008. Rigid body dynamics</dt>
<dd>algorithms. Springer.</dd>
</dl>
</li>
</ul>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialMomentum_[Expression]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialMomentum_[Expression], h: numpy.ndarray[object[3, 1]], l: numpy.ndarray[object[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>SpatialMomentum constructor from an angular momentum h and a linear
momentum l.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialMomentum_[Expression], L: numpy.ndarray[object[6, 1]]) -&gt; None</li>
</ol>
<p>SpatialMomentum constructor from an Eigen expression that represents a
six-dimensional vector. This constructor will assert the size of L is
six (6) at compile-time for fixed sized Eigen expressions and at
run-time for dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[Expression].dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[Expression], V_IBp_E: pydrake.multibody.math.SpatialVelocity_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.symbolic.Expression<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[Expression].dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial momentum <code class="docutils literal notranslate"><span class="pre">L_NBp_E</span></code> of a rigid body B, about
point P and, expressed in a frame E, this method computes the dot
product with the spatial velocity <code class="docutils literal notranslate"><span class="pre">V_NBp_E</span></code> of body B frame shifted
to point P, measured in an inertial (or Newtonian) frame N and
expressed in the same frame E in which the spatial momentum is
expressed. This dot-product is twice the kinetic energy <code class="docutils literal notranslate"><span class="pre">ke_NB</span></code> of
body B in reference frame N. The kinetic energy <code class="docutils literal notranslate"><span class="pre">ke_NB</span></code> is
independent of the about-point P and so is this dot product. Therefore
it is always true that:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>ke_NB = 1/2 (L_NBp⋅V_NBp) = 1/2 (L_NBcm⋅V_NBcm)
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">L_NBcm</span></code> is the spatial momentum about the center of mass of
body B and <code class="docutils literal notranslate"><span class="pre">V_NBcm</span></code> is the spatial velocity of frame B shifted to
its center of mass. The above is true due to how spatial momentum and
velocity shift when changing point P, see SpatialMomentum::Shift() and
SpatialVelocity::Shift().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[Expression].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[Expression].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[Expression].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[Expression], R_FE: pydrake.math.RotationMatrix_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[Expression].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[Expression].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[Expression].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[Expression].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[Expression].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[Expression].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[Expression], p_BpBq_E: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[Expression].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift of a SpatialMomentum from one application point to another. This
is an alternate signature for shifting a spatial momentum’s
about-point that does not change the original object. See
ShiftInPlace() for more information.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PQ_E</span></code>:</dt>
<dd>Shift vector from point P to point Q.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">L_NSq_E</span></code>:</dt>
<dd>The equivalent shifted spatial momentum, now applied at point Q
rather than P.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() to compute the shifted spatial momentum in-place
modifying the original object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[Expression].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[Expression].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialMomentum_[Expression].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[Expression].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> SpatialVector, i.e. rotational and
translational components are both zero.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.math.SpatialMomentum_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialMomentum_[float]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is used to represent the <em>spatial momentum</em> of a particle,
system of particles or body (whether rigid or soft.) The linear
momentum <code class="docutils literal notranslate"><span class="pre">l_NS</span></code> of a system of particles S in a reference frame N is
defined by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>l_NS = ∑l_NQi = ∑mᵢv_NQi
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">mᵢ</span></code> and <code class="docutils literal notranslate"><span class="pre">v_NQi</span></code> are the mass and linear velocity (in frame
N) of the i-th particle in the system, respectively. Their product
<code class="docutils literal notranslate"><span class="pre">l_NQi</span> <span class="pre">=</span> <span class="pre">mᵢv_NQi</span></code> is the linear momentum of the i-th particle in the
N reference frame. The angular momentum <code class="docutils literal notranslate"><span class="pre">h_NSp</span></code> of a system of
particles S in a reference frame N about an arbitrary point P is
defined by:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>h_NSp = ∑ p_PQi x l_NQi
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">p_PQi</span></code> is the position vector from point P to the i-th
particle position <code class="docutils literal notranslate"><span class="pre">Qi</span></code>. The definitions above extend to a continuum
of particles as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>h_NSp = ∫p_PQ(r) x v_NQ(r) ρ(r)d³r
  l_NS = ∫v_NQ(r) ρ(r)d³r
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">ρ(r)</span></code> is the density of the body at each material location
<code class="docutils literal notranslate"><span class="pre">r</span></code>. In particular, the continuum version above also applies to
rigid bodies.</p>
<p>Spatial momenta are elements of F⁶ (see [Featherstone 2008]) that
combine both rotational (angular momentum) and translational (linear
momentum) components. Spatial momenta are 6-element quantities that
are pairs of ordinary 3-vectors. Elements 0-2 are the angular momentum
component while elements 3-5 are the linear momentum component. As
with any other spatial vector, both vector components must be
expressed in the same frame.</p>
<p>Neither the expressed-in frame nor the about-point are stored with a
SpatialMomentum object; they must be understood from context. It is
the responsibility of the user to keep track of the about-point and
the expressed-in frame. That is best accomplished through disciplined
notation. In source code we use monogram notation where L designates a
spatial momentum quantity. The spatial momentum of a system S in a
frame N about an arbitrary point P, expressed in a frame E is typeset
as <span class="math notranslate nohighlight">\([^NL^{S/P}]_E\)</span>, which appears in code as <code class="docutils literal notranslate"><span class="pre">L_NSP_E</span></code>. The
spatial momentum of a body B in a frame N about the body origin Bo is
explicitly typeset as L_NBBo_E, but we abbreviate it as L_NBo_E.
Similarly, the spatial momentum of a system S in a frame N about Scm
(the system center of mass), expressed in a frame E is explicitly
typeset as L_NSScm_E, but we abbreviate it as L_NScm_E. For a more
detailed introduction on spatial vectors and the monogram notation
please refer to section multibody_spatial_vectors.</p>
<ul class="simple">
<li><dl class="first docutils">
<dt>[Featherstone 2008] Featherstone, R., 2008. Rigid body dynamics</dt>
<dd>algorithms. Springer.</dd>
</dl>
</li>
</ul>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialMomentum_[float]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialMomentum_[float], h: numpy.ndarray[numpy.float64[3, 1]], l: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>SpatialMomentum constructor from an angular momentum h and a linear
momentum l.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialMomentum_[float], L: numpy.ndarray[numpy.float64[6, 1]]) -&gt; None</li>
</ol>
<p>SpatialMomentum constructor from an Eigen expression that represents a
six-dimensional vector. This constructor will assert the size of L is
six (6) at compile-time for fixed sized Eigen expressions and at
run-time for dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[float].dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[float], V_IBp_E: pydrake.multibody.math.SpatialVelocity_[float]</em><span class="sig-paren">)</span> &#x2192; float<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[float].dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Given <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial momentum <code class="docutils literal notranslate"><span class="pre">L_NBp_E</span></code> of a rigid body B, about
point P and, expressed in a frame E, this method computes the dot
product with the spatial velocity <code class="docutils literal notranslate"><span class="pre">V_NBp_E</span></code> of body B frame shifted
to point P, measured in an inertial (or Newtonian) frame N and
expressed in the same frame E in which the spatial momentum is
expressed. This dot-product is twice the kinetic energy <code class="docutils literal notranslate"><span class="pre">ke_NB</span></code> of
body B in reference frame N. The kinetic energy <code class="docutils literal notranslate"><span class="pre">ke_NB</span></code> is
independent of the about-point P and so is this dot product. Therefore
it is always true that:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>ke_NB = 1/2 (L_NBp⋅V_NBp) = 1/2 (L_NBcm⋅V_NBcm)
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">L_NBcm</span></code> is the spatial momentum about the center of mass of
body B and <code class="docutils literal notranslate"><span class="pre">V_NBcm</span></code> is the spatial velocity of frame B shifted to
its center of mass. The above is true due to how spatial momentum and
velocity shift when changing point P, see SpatialMomentum::Shift() and
SpatialVelocity::Shift().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[float].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[float].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[float].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[float], R_FE: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[float].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[float].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[float].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[float].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[float].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[float].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[float], p_BpBq_E: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[float].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift of a SpatialMomentum from one application point to another. This
is an alternate signature for shifting a spatial momentum’s
about-point that does not change the original object. See
ShiftInPlace() for more information.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PQ_E</span></code>:</dt>
<dd>Shift vector from point P to point Q.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">L_NSq_E</span></code>:</dt>
<dd>The equivalent shifted spatial momentum, now applied at point Q
rather than P.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() to compute the shifted spatial momentum in-place
modifying the original object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialMomentum_[float].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialMomentum_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[float].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialMomentum_[float].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialMomentum_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialMomentum_[float].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> SpatialVector, i.e. rotational and
translational components are both zero.</p>
</dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pydrake.multibody.math.SpatialVelocity">
<code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialVelocity</code><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>alias of <a class="reference internal" href="#pydrake.multibody.math.SpatialVelocity_[float]" title="pydrake.multibody.math.SpatialVelocity_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">pydrake.multibody.math.SpatialVelocity_[float]</span></code></a></p>
</dd></dl>

<dl class="template">
<dt id="pydrake.multibody.math.SpatialVelocity_">
<em class="property">template </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialVelocity_</code><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiations: <a class="reference internal" href="#pydrake.multibody.math.SpatialVelocity_[float]" title="pydrake.multibody.math.SpatialVelocity_[float]"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialVelocity_[float]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]" title="pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialVelocity_[AutoDiffXd]</span></code></a>, <a class="reference internal" href="#pydrake.multibody.math.SpatialVelocity_[Expression]" title="pydrake.multibody.math.SpatialVelocity_[Expression]"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpatialVelocity_[Expression]</span></code></a></p>
<dl class="class">
<dt id="pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float]">
<em class="property">class </em><code class="descname">SpatialVelocity_[float]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is used to represent a <em>spatial velocity</em> (also called a
<em>twist</em>) that combines rotational (angular) and translational (linear)
velocity components. Spatial velocities are 6-element quantities that
are pairs of ordinary 3-vectors. Elements 0-2 are the angular velocity
component while elements 3-5 are the translational velocity. Spatial
velocities represent the motion of a “moving frame” B measured with
respect to a “measured-in” frame A. In addition, the two contained
vectors must be expressed in the same “expressed-in” frame E, which
may be distinct from either A or B. Finally, while angular velocity is
identical for any frame fixed to a rigid body, translational velocity
refers to a particular point. Only the vector values are stored in a
SpatialVelocity object; the three frames and the point must be
understood from context. It is the responsibility of the user to keep
track of them. That is best accomplished through disciplined notation.
In source code we use monogram notation where capital V is used to
designate a spatial velocity quantity. We write a point P fixed to
body (or frame) B as <span class="math notranslate nohighlight">\(B_P\)</span> which appears in code and comments as
<code class="docutils literal notranslate"><span class="pre">Bp</span></code>. Then we write a particular spatial velocity as <code class="docutils literal notranslate"><span class="pre">V_ABp_E</span></code>
where the <code class="docutils literal notranslate"><span class="pre">_E</span></code> suffix indicates that the expressed-in frame is E.
This symbol represents the angular velocity of frame B in frame A, and
the translational velocity of point P in A, where P is fixed to frame
B, with both vectors expressed in E. Very often the point of interest
will be the body origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code>; if no point is shown the origin is
understood, so <code class="docutils literal notranslate"><span class="pre">V_AB_E</span></code> means <code class="docutils literal notranslate"><span class="pre">V_ABo_E</span></code>. For a more detailed
introduction on spatial vectors and the monogram notation please refer
to section multibody_spatial_vectors.</p>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialVelocity_[float]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialVelocity_[float], w: numpy.ndarray[numpy.float64[3, 1]], v: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>SpatialVelocity constructor from an angular velocity <code class="docutils literal notranslate"><span class="pre">w</span></code> and a
linear velocity <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialVelocity_[float], V: numpy.ndarray[numpy.float64[6, 1]]) -&gt; None</li>
</ol>
<p>SpatialVelocity constructor from an Eigen expression that represents a
six-dimensional vector. This constructor will assert the size of V is
six (6) at compile-time for fixed sized Eigen expressions and at
run-time for dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].ComposeWithMovingFrameVelocity">
<code class="descname">ComposeWithMovingFrameVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[float], p_PoBo_E: numpy.ndarray[numpy.float64[3, 1]], V_PB_E: pydrake.multibody.math.SpatialVelocity_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].ComposeWithMovingFrameVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>This method composes <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity <code class="docutils literal notranslate"><span class="pre">V_WP</span></code> of a frame P
measured in a frame W, with that of a third frame B moving in P with
spatial velocity <code class="docutils literal notranslate"><span class="pre">V_PB</span></code>. The result is the spatial velocity <code class="docutils literal notranslate"><span class="pre">V_WB</span></code>
of frame B measured in W. At the instant in which the velocities are
composed, frame B is located with its origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code> at <code class="docutils literal notranslate"><span class="pre">p_PoBo</span></code> from
P’s origin Po.</p>
<p>The composition cannot be performed directly since frames P and B do
not have the same origins. To perform the composition <code class="docutils literal notranslate"><span class="pre">V_WB</span></code>, the
velocity of P needs to be shifted to point <code class="docutils literal notranslate"><span class="pre">Bo</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">V_WB_E</span> <span class="o">=</span> <span class="n">V_WPb_E</span> <span class="o">+</span> <span class="n">V_PB_E</span> <span class="o">=</span> <span class="n">V_WP_E</span><span class="o">.</span><span class="n">Shift</span><span class="p">(</span><span class="n">p_PoBo_E</span><span class="p">)</span> <span class="o">+</span> <span class="n">V_PB_E</span>
</pre></div>
</div>
<p>where p_PoBo is the position vector from P’s origin to B’s origin and
<code class="docutils literal notranslate"><span class="pre">V_WPb</span></code> is the spatial velocity of a new frame <code class="docutils literal notranslate"><span class="pre">Pb</span></code> which is an
offset frame rigidly aligned with P, but with its origin shifted to
B’s origin. The key is that in the expression above, the two spatial
velocities being added must be for frames with the same origin point,
in this case Bo.</p>
<p>For computation, all quantities above must be expressed in a common
frame E; we add an <code class="docutils literal notranslate"><span class="pre">_E</span></code> suffix to each symbol to indicate that.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If frame B moves rigidly together with frame P, as in a rigid
body, <code class="docutils literal notranslate"><span class="pre">V_PB</span> <span class="pre">=</span> <span class="pre">0</span></code> and the result of this method equals that of
the Shift() operation.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PoBo_E</span></code>:</dt>
<dd>Shift vector from P’s origin to B’s origin, expressed in frame E.
The “from” point <code class="docutils literal notranslate"><span class="pre">Po</span></code> must be the point whose velocity is
currently represented in <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity, and E must be
the same expressed-in frame as for <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">V_PB_E</span></code>:</dt>
<dd>The spatial velocity of a third frame B in motion with respect to
P, expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">V_WB_E</span></code>:</dt>
<dd>The spatial velocity of frame B in W resulting from the
composition of <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity <code class="docutils literal notranslate"><span class="pre">V_WP</span></code> and B’s velocity
in P, <code class="docutils literal notranslate"><span class="pre">V_PB</span></code>. The result is expressed in the same frame E as
<code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>dot(self: pydrake.multibody.math.SpatialVelocity_[float], F_Q_E: drake::multibody::SpatialForce&lt;double&gt;) -&gt; float</li>
</ol>
<p>Given <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity <code class="docutils literal notranslate"><span class="pre">V_IBp_E</span></code> of point P of body B,
measured in an inertial frame I and expressed in a frame E, this
method computes the 6-dimensional dot product with the spatial force
<code class="docutils literal notranslate"><span class="pre">F_Bp_E</span></code> applied to point P, and expressed in the same frame E in
which the spatial velocity is expressed. This dot-product represents
the power generated by the spatial force when its body and application
point have <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity. Although the two spatial vectors
must be expressed in the same frame, the result is independent of that
frame.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The result of this method cannot be interpreted as power unless
<code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity is measured in an inertial frame I,
which cannot be enforced by this class.</p>
</div>
<ol class="arabic simple" start="2">
<li>dot(self: pydrake.multibody.math.SpatialVelocity_[float], L_NBp_E: drake::multibody::SpatialMomentum&lt;double&gt;) -&gt; float</li>
</ol>
<p>Given <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity <code class="docutils literal notranslate"><span class="pre">V_NBp_E</span></code> of rigid body B frame
shifted to point P, measured in an inertial (or Newtonian) frame N
and, expressed in a frame E this method computes the dot product with
the spatial momentum <code class="docutils literal notranslate"><span class="pre">L_NBp_E</span></code> of rigid body B, about point P, and
expressed in the same frame E. This dot-product is twice the kinetic
energy <code class="docutils literal notranslate"><span class="pre">ke_NB</span></code> of body B in reference frame N. The kinetic energy
<code class="docutils literal notranslate"><span class="pre">ke_NB</span></code> is independent of the about-point P and so is this dot
product. Therefore it is always true that:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>ke_NB = 1/2 (L_NBp⋅V_NBp) = 1/2 (L_NBcm⋅V_NBcm)
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">L_NBcm</span></code> is the spatial momentum about the center of mass of
body B and <code class="docutils literal notranslate"><span class="pre">V_NBcm</span></code> is the spatial velocity of frame B shifted to
its center of mass. The above is true due to how spatial momentum and
velocity shift when changing point P, see SpatialMomentum::Shift() and
SpatialVelocity::Shift().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[float], R_FE: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[float], p_BpBq_E: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift of a SpatialVelocity from one point on a rigid body or frame to
another point on the same body or frame. This is an alternate
signature for shifting a spatial velocity’s point that does not change
the original object. See ShiftInPlace() for more information.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BpBq_E</span></code>:</dt>
<dd>Shift vector from point P of body B to point Q of B, expressed in
frame E. The “from” point <code class="docutils literal notranslate"><span class="pre">Bp</span></code> must be the point whose velocity
is currently represented in this spatial velocity, and E must be
the same expressed-in frame as for this spatial velocity.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">V_ABq_E</span></code>:</dt>
<dd>The spatial velocity of frame B at point Q, measured in frame A
and expressed in frame E.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() to compute the shifted spatial velocity in-place
modifying the original object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_.SpatialVelocity_[float].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> SpatialVector, i.e. rotational and
translational components are both zero.</p>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialVelocity_[AutoDiffXd]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is used to represent a <em>spatial velocity</em> (also called a
<em>twist</em>) that combines rotational (angular) and translational (linear)
velocity components. Spatial velocities are 6-element quantities that
are pairs of ordinary 3-vectors. Elements 0-2 are the angular velocity
component while elements 3-5 are the translational velocity. Spatial
velocities represent the motion of a “moving frame” B measured with
respect to a “measured-in” frame A. In addition, the two contained
vectors must be expressed in the same “expressed-in” frame E, which
may be distinct from either A or B. Finally, while angular velocity is
identical for any frame fixed to a rigid body, translational velocity
refers to a particular point. Only the vector values are stored in a
SpatialVelocity object; the three frames and the point must be
understood from context. It is the responsibility of the user to keep
track of them. That is best accomplished through disciplined notation.
In source code we use monogram notation where capital V is used to
designate a spatial velocity quantity. We write a point P fixed to
body (or frame) B as <span class="math notranslate nohighlight">\(B_P\)</span> which appears in code and comments as
<code class="docutils literal notranslate"><span class="pre">Bp</span></code>. Then we write a particular spatial velocity as <code class="docutils literal notranslate"><span class="pre">V_ABp_E</span></code>
where the <code class="docutils literal notranslate"><span class="pre">_E</span></code> suffix indicates that the expressed-in frame is E.
This symbol represents the angular velocity of frame B in frame A, and
the translational velocity of point P in A, where P is fixed to frame
B, with both vectors expressed in E. Very often the point of interest
will be the body origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code>; if no point is shown the origin is
understood, so <code class="docutils literal notranslate"><span class="pre">V_AB_E</span></code> means <code class="docutils literal notranslate"><span class="pre">V_ABo_E</span></code>. For a more detailed
introduction on spatial vectors and the monogram notation please refer
to section multibody_spatial_vectors.</p>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd], w: numpy.ndarray[object[3, 1]], v: numpy.ndarray[object[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>SpatialVelocity constructor from an angular velocity <code class="docutils literal notranslate"><span class="pre">w</span></code> and a
linear velocity <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd], V: numpy.ndarray[object[6, 1]]) -&gt; None</li>
</ol>
<p>SpatialVelocity constructor from an Eigen expression that represents a
six-dimensional vector. This constructor will assert the size of V is
six (6) at compile-time for fixed sized Eigen expressions and at
run-time for dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].ComposeWithMovingFrameVelocity">
<code class="descname">ComposeWithMovingFrameVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd], p_PoBo_E: numpy.ndarray[object[3, 1]], V_PB_E: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].ComposeWithMovingFrameVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>This method composes <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity <code class="docutils literal notranslate"><span class="pre">V_WP</span></code> of a frame P
measured in a frame W, with that of a third frame B moving in P with
spatial velocity <code class="docutils literal notranslate"><span class="pre">V_PB</span></code>. The result is the spatial velocity <code class="docutils literal notranslate"><span class="pre">V_WB</span></code>
of frame B measured in W. At the instant in which the velocities are
composed, frame B is located with its origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code> at <code class="docutils literal notranslate"><span class="pre">p_PoBo</span></code> from
P’s origin Po.</p>
<p>The composition cannot be performed directly since frames P and B do
not have the same origins. To perform the composition <code class="docutils literal notranslate"><span class="pre">V_WB</span></code>, the
velocity of P needs to be shifted to point <code class="docutils literal notranslate"><span class="pre">Bo</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">V_WB_E</span> <span class="o">=</span> <span class="n">V_WPb_E</span> <span class="o">+</span> <span class="n">V_PB_E</span> <span class="o">=</span> <span class="n">V_WP_E</span><span class="o">.</span><span class="n">Shift</span><span class="p">(</span><span class="n">p_PoBo_E</span><span class="p">)</span> <span class="o">+</span> <span class="n">V_PB_E</span>
</pre></div>
</div>
<p>where p_PoBo is the position vector from P’s origin to B’s origin and
<code class="docutils literal notranslate"><span class="pre">V_WPb</span></code> is the spatial velocity of a new frame <code class="docutils literal notranslate"><span class="pre">Pb</span></code> which is an
offset frame rigidly aligned with P, but with its origin shifted to
B’s origin. The key is that in the expression above, the two spatial
velocities being added must be for frames with the same origin point,
in this case Bo.</p>
<p>For computation, all quantities above must be expressed in a common
frame E; we add an <code class="docutils literal notranslate"><span class="pre">_E</span></code> suffix to each symbol to indicate that.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If frame B moves rigidly together with frame P, as in a rigid
body, <code class="docutils literal notranslate"><span class="pre">V_PB</span> <span class="pre">=</span> <span class="pre">0</span></code> and the result of this method equals that of
the Shift() operation.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PoBo_E</span></code>:</dt>
<dd>Shift vector from P’s origin to B’s origin, expressed in frame E.
The “from” point <code class="docutils literal notranslate"><span class="pre">Po</span></code> must be the point whose velocity is
currently represented in <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity, and E must be
the same expressed-in frame as for <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">V_PB_E</span></code>:</dt>
<dd>The spatial velocity of a third frame B in motion with respect to
P, expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">V_WB_E</span></code>:</dt>
<dd>The spatial velocity of frame B in W resulting from the
composition of <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity <code class="docutils literal notranslate"><span class="pre">V_WP</span></code> and B’s velocity
in P, <code class="docutils literal notranslate"><span class="pre">V_PB</span></code>. The result is expressed in the same frame E as
<code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>dot(self: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd], F_Q_E: drake::multibody::SpatialForce&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;) -&gt; pydrake.autodiffutils.AutoDiffXd</li>
</ol>
<p>Given <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity <code class="docutils literal notranslate"><span class="pre">V_IBp_E</span></code> of point P of body B,
measured in an inertial frame I and expressed in a frame E, this
method computes the 6-dimensional dot product with the spatial force
<code class="docutils literal notranslate"><span class="pre">F_Bp_E</span></code> applied to point P, and expressed in the same frame E in
which the spatial velocity is expressed. This dot-product represents
the power generated by the spatial force when its body and application
point have <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity. Although the two spatial vectors
must be expressed in the same frame, the result is independent of that
frame.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The result of this method cannot be interpreted as power unless
<code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity is measured in an inertial frame I,
which cannot be enforced by this class.</p>
</div>
<ol class="arabic simple" start="2">
<li>dot(self: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd], L_NBp_E: drake::multibody::SpatialMomentum&lt;Eigen::AutoDiffScalar&lt;Eigen::Matrix&lt;double, -1, 1, 0, -1, 1&gt; &gt; &gt;) -&gt; pydrake.autodiffutils.AutoDiffXd</li>
</ol>
<p>Given <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity <code class="docutils literal notranslate"><span class="pre">V_NBp_E</span></code> of rigid body B frame
shifted to point P, measured in an inertial (or Newtonian) frame N
and, expressed in a frame E this method computes the dot product with
the spatial momentum <code class="docutils literal notranslate"><span class="pre">L_NBp_E</span></code> of rigid body B, about point P, and
expressed in the same frame E. This dot-product is twice the kinetic
energy <code class="docutils literal notranslate"><span class="pre">ke_NB</span></code> of body B in reference frame N. The kinetic energy
<code class="docutils literal notranslate"><span class="pre">ke_NB</span></code> is independent of the about-point P and so is this dot
product. Therefore it is always true that:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>ke_NB = 1/2 (L_NBp⋅V_NBp) = 1/2 (L_NBcm⋅V_NBcm)
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">L_NBcm</span></code> is the spatial momentum about the center of mass of
body B and <code class="docutils literal notranslate"><span class="pre">V_NBcm</span></code> is the spatial velocity of frame B shifted to
its center of mass. The above is true due to how spatial momentum and
velocity shift when changing point P, see SpatialMomentum::Shift() and
SpatialVelocity::Shift().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd], R_FE: pydrake.math.RotationMatrix_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd], p_BpBq_E: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift of a SpatialVelocity from one point on a rigid body or frame to
another point on the same body or frame. This is an alternate
signature for shifting a spatial velocity’s point that does not change
the original object. See ShiftInPlace() for more information.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BpBq_E</span></code>:</dt>
<dd>Shift vector from point P of body B to point Q of B, expressed in
frame E. The “from” point <code class="docutils literal notranslate"><span class="pre">Bp</span></code> must be the point whose velocity
is currently represented in this spatial velocity, and E must be
the same expressed-in frame as for this spatial velocity.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">V_ABq_E</span></code>:</dt>
<dd>The spatial velocity of frame B at point Q, measured in frame A
and expressed in frame E.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() to compute the shifted spatial velocity in-place
modifying the original object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[AutoDiffXd]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[AutoDiffXd].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> SpatialVector, i.e. rotational and
translational components are both zero.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.math.SpatialVelocity_[Expression]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialVelocity_[Expression]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[Expression]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is used to represent a <em>spatial velocity</em> (also called a
<em>twist</em>) that combines rotational (angular) and translational (linear)
velocity components. Spatial velocities are 6-element quantities that
are pairs of ordinary 3-vectors. Elements 0-2 are the angular velocity
component while elements 3-5 are the translational velocity. Spatial
velocities represent the motion of a “moving frame” B measured with
respect to a “measured-in” frame A. In addition, the two contained
vectors must be expressed in the same “expressed-in” frame E, which
may be distinct from either A or B. Finally, while angular velocity is
identical for any frame fixed to a rigid body, translational velocity
refers to a particular point. Only the vector values are stored in a
SpatialVelocity object; the three frames and the point must be
understood from context. It is the responsibility of the user to keep
track of them. That is best accomplished through disciplined notation.
In source code we use monogram notation where capital V is used to
designate a spatial velocity quantity. We write a point P fixed to
body (or frame) B as <span class="math notranslate nohighlight">\(B_P\)</span> which appears in code and comments as
<code class="docutils literal notranslate"><span class="pre">Bp</span></code>. Then we write a particular spatial velocity as <code class="docutils literal notranslate"><span class="pre">V_ABp_E</span></code>
where the <code class="docutils literal notranslate"><span class="pre">_E</span></code> suffix indicates that the expressed-in frame is E.
This symbol represents the angular velocity of frame B in frame A, and
the translational velocity of point P in A, where P is fixed to frame
B, with both vectors expressed in E. Very often the point of interest
will be the body origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code>; if no point is shown the origin is
understood, so <code class="docutils literal notranslate"><span class="pre">V_AB_E</span></code> means <code class="docutils literal notranslate"><span class="pre">V_ABo_E</span></code>. For a more detailed
introduction on spatial vectors and the monogram notation please refer
to section multibody_spatial_vectors.</p>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[Expression].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[Expression].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialVelocity_[Expression]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialVelocity_[Expression], w: numpy.ndarray[object[3, 1]], v: numpy.ndarray[object[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>SpatialVelocity constructor from an angular velocity <code class="docutils literal notranslate"><span class="pre">w</span></code> and a
linear velocity <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialVelocity_[Expression], V: numpy.ndarray[object[6, 1]]) -&gt; None</li>
</ol>
<p>SpatialVelocity constructor from an Eigen expression that represents a
six-dimensional vector. This constructor will assert the size of V is
six (6) at compile-time for fixed sized Eigen expressions and at
run-time for dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[Expression].ComposeWithMovingFrameVelocity">
<code class="descname">ComposeWithMovingFrameVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[Expression], p_PoBo_E: numpy.ndarray[object[3, 1]], V_PB_E: pydrake.multibody.math.SpatialVelocity_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[Expression].ComposeWithMovingFrameVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>This method composes <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity <code class="docutils literal notranslate"><span class="pre">V_WP</span></code> of a frame P
measured in a frame W, with that of a third frame B moving in P with
spatial velocity <code class="docutils literal notranslate"><span class="pre">V_PB</span></code>. The result is the spatial velocity <code class="docutils literal notranslate"><span class="pre">V_WB</span></code>
of frame B measured in W. At the instant in which the velocities are
composed, frame B is located with its origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code> at <code class="docutils literal notranslate"><span class="pre">p_PoBo</span></code> from
P’s origin Po.</p>
<p>The composition cannot be performed directly since frames P and B do
not have the same origins. To perform the composition <code class="docutils literal notranslate"><span class="pre">V_WB</span></code>, the
velocity of P needs to be shifted to point <code class="docutils literal notranslate"><span class="pre">Bo</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">V_WB_E</span> <span class="o">=</span> <span class="n">V_WPb_E</span> <span class="o">+</span> <span class="n">V_PB_E</span> <span class="o">=</span> <span class="n">V_WP_E</span><span class="o">.</span><span class="n">Shift</span><span class="p">(</span><span class="n">p_PoBo_E</span><span class="p">)</span> <span class="o">+</span> <span class="n">V_PB_E</span>
</pre></div>
</div>
<p>where p_PoBo is the position vector from P’s origin to B’s origin and
<code class="docutils literal notranslate"><span class="pre">V_WPb</span></code> is the spatial velocity of a new frame <code class="docutils literal notranslate"><span class="pre">Pb</span></code> which is an
offset frame rigidly aligned with P, but with its origin shifted to
B’s origin. The key is that in the expression above, the two spatial
velocities being added must be for frames with the same origin point,
in this case Bo.</p>
<p>For computation, all quantities above must be expressed in a common
frame E; we add an <code class="docutils literal notranslate"><span class="pre">_E</span></code> suffix to each symbol to indicate that.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If frame B moves rigidly together with frame P, as in a rigid
body, <code class="docutils literal notranslate"><span class="pre">V_PB</span> <span class="pre">=</span> <span class="pre">0</span></code> and the result of this method equals that of
the Shift() operation.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PoBo_E</span></code>:</dt>
<dd>Shift vector from P’s origin to B’s origin, expressed in frame E.
The “from” point <code class="docutils literal notranslate"><span class="pre">Po</span></code> must be the point whose velocity is
currently represented in <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity, and E must be
the same expressed-in frame as for <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">V_PB_E</span></code>:</dt>
<dd>The spatial velocity of a third frame B in motion with respect to
P, expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">V_WB_E</span></code>:</dt>
<dd>The spatial velocity of frame B in W resulting from the
composition of <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity <code class="docutils literal notranslate"><span class="pre">V_WP</span></code> and B’s velocity
in P, <code class="docutils literal notranslate"><span class="pre">V_PB</span></code>. The result is expressed in the same frame E as
<code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[Expression].dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[Expression].dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>dot(self: pydrake.multibody.math.SpatialVelocity_[Expression], F_Q_E: drake::multibody::SpatialForce&lt;drake::symbolic::Expression&gt;) -&gt; pydrake.symbolic.Expression</li>
</ol>
<p>Given <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity <code class="docutils literal notranslate"><span class="pre">V_IBp_E</span></code> of point P of body B,
measured in an inertial frame I and expressed in a frame E, this
method computes the 6-dimensional dot product with the spatial force
<code class="docutils literal notranslate"><span class="pre">F_Bp_E</span></code> applied to point P, and expressed in the same frame E in
which the spatial velocity is expressed. This dot-product represents
the power generated by the spatial force when its body and application
point have <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity. Although the two spatial vectors
must be expressed in the same frame, the result is independent of that
frame.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The result of this method cannot be interpreted as power unless
<code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity is measured in an inertial frame I,
which cannot be enforced by this class.</p>
</div>
<ol class="arabic simple" start="2">
<li>dot(self: pydrake.multibody.math.SpatialVelocity_[Expression], L_NBp_E: drake::multibody::SpatialMomentum&lt;drake::symbolic::Expression&gt;) -&gt; pydrake.symbolic.Expression</li>
</ol>
<p>Given <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity <code class="docutils literal notranslate"><span class="pre">V_NBp_E</span></code> of rigid body B frame
shifted to point P, measured in an inertial (or Newtonian) frame N
and, expressed in a frame E this method computes the dot product with
the spatial momentum <code class="docutils literal notranslate"><span class="pre">L_NBp_E</span></code> of rigid body B, about point P, and
expressed in the same frame E. This dot-product is twice the kinetic
energy <code class="docutils literal notranslate"><span class="pre">ke_NB</span></code> of body B in reference frame N. The kinetic energy
<code class="docutils literal notranslate"><span class="pre">ke_NB</span></code> is independent of the about-point P and so is this dot
product. Therefore it is always true that:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>ke_NB = 1/2 (L_NBp⋅V_NBp) = 1/2 (L_NBcm⋅V_NBcm)
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">L_NBcm</span></code> is the spatial momentum about the center of mass of
body B and <code class="docutils literal notranslate"><span class="pre">V_NBcm</span></code> is the spatial velocity of frame B shifted to
its center of mass. The above is true due to how spatial momentum and
velocity shift when changing point P, see SpatialMomentum::Shift() and
SpatialVelocity::Shift().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[Expression].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[Expression].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[Expression].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[Expression], R_FE: pydrake.math.RotationMatrix_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[Expression].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[Expression].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[Expression].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[Expression].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[Expression]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[Expression].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[Expression].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[Expression], p_BpBq_E: numpy.ndarray[object[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[Expression].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift of a SpatialVelocity from one point on a rigid body or frame to
another point on the same body or frame. This is an alternate
signature for shifting a spatial velocity’s point that does not change
the original object. See ShiftInPlace() for more information.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BpBq_E</span></code>:</dt>
<dd>Shift vector from point P of body B to point Q of B, expressed in
frame E. The “from” point <code class="docutils literal notranslate"><span class="pre">Bp</span></code> must be the point whose velocity
is currently represented in this spatial velocity, and E must be
the same expressed-in frame as for this spatial velocity.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">V_ABq_E</span></code>:</dt>
<dd>The spatial velocity of frame B at point Q, measured in frame A
and expressed in frame E.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() to compute the shifted spatial velocity in-place
modifying the original object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[Expression].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[Expression]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[object[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[Expression].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialVelocity_[Expression].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[Expression]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[Expression].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> SpatialVector, i.e. rotational and
translational components are both zero.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pydrake.multibody.math.SpatialVelocity_[float]">
<em class="property">class </em><code class="descclassname">pydrake.multibody.math.</code><code class="descname">SpatialVelocity_[float]</code><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[float]" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is used to represent a <em>spatial velocity</em> (also called a
<em>twist</em>) that combines rotational (angular) and translational (linear)
velocity components. Spatial velocities are 6-element quantities that
are pairs of ordinary 3-vectors. Elements 0-2 are the angular velocity
component while elements 3-5 are the translational velocity. Spatial
velocities represent the motion of a “moving frame” B measured with
respect to a “measured-in” frame A. In addition, the two contained
vectors must be expressed in the same “expressed-in” frame E, which
may be distinct from either A or B. Finally, while angular velocity is
identical for any frame fixed to a rigid body, translational velocity
refers to a particular point. Only the vector values are stored in a
SpatialVelocity object; the three frames and the point must be
understood from context. It is the responsibility of the user to keep
track of them. That is best accomplished through disciplined notation.
In source code we use monogram notation where capital V is used to
designate a spatial velocity quantity. We write a point P fixed to
body (or frame) B as <span class="math notranslate nohighlight">\(B_P\)</span> which appears in code and comments as
<code class="docutils literal notranslate"><span class="pre">Bp</span></code>. Then we write a particular spatial velocity as <code class="docutils literal notranslate"><span class="pre">V_ABp_E</span></code>
where the <code class="docutils literal notranslate"><span class="pre">_E</span></code> suffix indicates that the expressed-in frame is E.
This symbol represents the angular velocity of frame B in frame A, and
the translational velocity of point P in A, where P is fixed to frame
B, with both vectors expressed in E. Very often the point of interest
will be the body origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code>; if no point is shown the origin is
understood, so <code class="docutils literal notranslate"><span class="pre">V_AB_E</span></code> means <code class="docutils literal notranslate"><span class="pre">V_ABo_E</span></code>. For a more detailed
introduction on spatial vectors and the monogram notation please refer
to section multibody_spatial_vectors.</p>
<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[float].__init__">
<code class="descname">__init__</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[float].__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialVelocity_[float]) -&gt; None</p>
<blockquote>
<div><p>Constructs to all NaNs.</p>
<dl class="docutils">
<dt>Note:</dt>
<dd><p class="first last">This is different from C++, which in Release builds may leave memory
uninitialized. In pydrake, the function call overhead already trumps
any overhead from NAN-initialization, so we err on the side of
safety.</p>
</dd>
</dl>
</div></blockquote>
</li>
<li><p class="first">__init__(self: pydrake.multibody.math.SpatialVelocity_[float], w: numpy.ndarray[numpy.float64[3, 1]], v: numpy.ndarray[numpy.float64[3, 1]]) -&gt; None</p>
</li>
</ol>
<p>SpatialVelocity constructor from an angular velocity <code class="docutils literal notranslate"><span class="pre">w</span></code> and a
linear velocity <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p>
<ol class="arabic simple" start="3">
<li>__init__(self: pydrake.multibody.math.SpatialVelocity_[float], V: numpy.ndarray[numpy.float64[6, 1]]) -&gt; None</li>
</ol>
<p>SpatialVelocity constructor from an Eigen expression that represents a
six-dimensional vector. This constructor will assert the size of V is
six (6) at compile-time for fixed sized Eigen expressions and at
run-time for dynamic sized Eigen expressions.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[float].ComposeWithMovingFrameVelocity">
<code class="descname">ComposeWithMovingFrameVelocity</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[float], p_PoBo_E: numpy.ndarray[numpy.float64[3, 1]], V_PB_E: pydrake.multibody.math.SpatialVelocity_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[float].ComposeWithMovingFrameVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>This method composes <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity <code class="docutils literal notranslate"><span class="pre">V_WP</span></code> of a frame P
measured in a frame W, with that of a third frame B moving in P with
spatial velocity <code class="docutils literal notranslate"><span class="pre">V_PB</span></code>. The result is the spatial velocity <code class="docutils literal notranslate"><span class="pre">V_WB</span></code>
of frame B measured in W. At the instant in which the velocities are
composed, frame B is located with its origin <code class="docutils literal notranslate"><span class="pre">Bo</span></code> at <code class="docutils literal notranslate"><span class="pre">p_PoBo</span></code> from
P’s origin Po.</p>
<p>The composition cannot be performed directly since frames P and B do
not have the same origins. To perform the composition <code class="docutils literal notranslate"><span class="pre">V_WB</span></code>, the
velocity of P needs to be shifted to point <code class="docutils literal notranslate"><span class="pre">Bo</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">V_WB_E</span> <span class="o">=</span> <span class="n">V_WPb_E</span> <span class="o">+</span> <span class="n">V_PB_E</span> <span class="o">=</span> <span class="n">V_WP_E</span><span class="o">.</span><span class="n">Shift</span><span class="p">(</span><span class="n">p_PoBo_E</span><span class="p">)</span> <span class="o">+</span> <span class="n">V_PB_E</span>
</pre></div>
</div>
<p>where p_PoBo is the position vector from P’s origin to B’s origin and
<code class="docutils literal notranslate"><span class="pre">V_WPb</span></code> is the spatial velocity of a new frame <code class="docutils literal notranslate"><span class="pre">Pb</span></code> which is an
offset frame rigidly aligned with P, but with its origin shifted to
B’s origin. The key is that in the expression above, the two spatial
velocities being added must be for frames with the same origin point,
in this case Bo.</p>
<p>For computation, all quantities above must be expressed in a common
frame E; we add an <code class="docutils literal notranslate"><span class="pre">_E</span></code> suffix to each symbol to indicate that.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If frame B moves rigidly together with frame P, as in a rigid
body, <code class="docutils literal notranslate"><span class="pre">V_PB</span> <span class="pre">=</span> <span class="pre">0</span></code> and the result of this method equals that of
the Shift() operation.</p>
</div>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_PoBo_E</span></code>:</dt>
<dd>Shift vector from P’s origin to B’s origin, expressed in frame E.
The “from” point <code class="docutils literal notranslate"><span class="pre">Po</span></code> must be the point whose velocity is
currently represented in <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity, and E must be
the same expressed-in frame as for <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity.</dd>
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">V_PB_E</span></code>:</dt>
<dd>The spatial velocity of a third frame B in motion with respect to
P, expressed in the same frame E as <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">V_WB_E</span></code>:</dt>
<dd>The spatial velocity of frame B in W resulting from the
composition of <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity <code class="docutils literal notranslate"><span class="pre">V_WP</span></code> and B’s velocity
in P, <code class="docutils literal notranslate"><span class="pre">V_PB</span></code>. The result is expressed in the same frame E as
<code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[float].dot">
<code class="descname">dot</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[float].dot" title="Permalink to this definition">¶</a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic simple">
<li>dot(self: pydrake.multibody.math.SpatialVelocity_[float], F_Q_E: drake::multibody::SpatialForce&lt;double&gt;) -&gt; float</li>
</ol>
<p>Given <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity <code class="docutils literal notranslate"><span class="pre">V_IBp_E</span></code> of point P of body B,
measured in an inertial frame I and expressed in a frame E, this
method computes the 6-dimensional dot product with the spatial force
<code class="docutils literal notranslate"><span class="pre">F_Bp_E</span></code> applied to point P, and expressed in the same frame E in
which the spatial velocity is expressed. This dot-product represents
the power generated by the spatial force when its body and application
point have <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity. Although the two spatial vectors
must be expressed in the same frame, the result is independent of that
frame.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The result of this method cannot be interpreted as power unless
<code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity is measured in an inertial frame I,
which cannot be enforced by this class.</p>
</div>
<ol class="arabic simple" start="2">
<li>dot(self: pydrake.multibody.math.SpatialVelocity_[float], L_NBp_E: drake::multibody::SpatialMomentum&lt;double&gt;) -&gt; float</li>
</ol>
<p>Given <code class="docutils literal notranslate"><span class="pre">this</span></code> spatial velocity <code class="docutils literal notranslate"><span class="pre">V_NBp_E</span></code> of rigid body B frame
shifted to point P, measured in an inertial (or Newtonian) frame N
and, expressed in a frame E this method computes the dot product with
the spatial momentum <code class="docutils literal notranslate"><span class="pre">L_NBp_E</span></code> of rigid body B, about point P, and
expressed in the same frame E. This dot-product is twice the kinetic
energy <code class="docutils literal notranslate"><span class="pre">ke_NB</span></code> of body B in reference frame N. The kinetic energy
<code class="docutils literal notranslate"><span class="pre">ke_NB</span></code> is independent of the about-point P and so is this dot
product. Therefore it is always true that:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>ke_NB = 1/2 (L_NBp⋅V_NBp) = 1/2 (L_NBcm⋅V_NBcm)
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">L_NBcm</span></code> is the spatial momentum about the center of mass of
body B and <code class="docutils literal notranslate"><span class="pre">V_NBcm</span></code> is the spatial velocity of frame B shifted to
its center of mass. The above is true due to how spatial momentum and
velocity shift when changing point P, see SpatialMomentum::Shift() and
SpatialVelocity::Shift().</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[float].get_coeffs">
<code class="descname">get_coeffs</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[6, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[float].get_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a constant reference to the underlying storage.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[float].Rotate">
<code class="descname">Rotate</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[float], R_FE: pydrake.math.RotationMatrix_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[float].Rotate" title="Permalink to this definition">¶</a></dt>
<dd><p>Provides a Python-only implementation of rotating / re-expressing a
spatial vector.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is done because defining <code class="docutils literal notranslate"><span class="pre">__rmatmul__</span></code> on this class does
not disambiguate against the definitions of
<code class="docutils literal notranslate"><span class="pre">RotationMatrix.__matmul__</span></code>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[float].rotational">
<code class="descname">rotational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[float].rotational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the rotational component of this spatial vector.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[float].SetZero">
<code class="descname">SetZero</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[float]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[float].SetZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets both rotational and translational components of <code class="docutils literal notranslate"><span class="pre">this</span></code>
SpatialVector to zero.</p>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[float].Shift">
<code class="descname">Shift</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[float], p_BpBq_E: numpy.ndarray[numpy.float64[3, 1]]</em><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[float].Shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Shift of a SpatialVelocity from one point on a rigid body or frame to
another point on the same body or frame. This is an alternate
signature for shifting a spatial velocity’s point that does not change
the original object. See ShiftInPlace() for more information.</p>
<dl class="docutils">
<dt>Parameter <code class="docutils literal notranslate"><span class="pre">p_BpBq_E</span></code>:</dt>
<dd>Shift vector from point P of body B to point Q of B, expressed in
frame E. The “from” point <code class="docutils literal notranslate"><span class="pre">Bp</span></code> must be the point whose velocity
is currently represented in this spatial velocity, and E must be
the same expressed-in frame as for this spatial velocity.</dd>
<dt>Returns <code class="docutils literal notranslate"><span class="pre">V_ABq_E</span></code>:</dt>
<dd>The spatial velocity of frame B at point Q, measured in frame A
and expressed in frame E.</dd>
</dl>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last">ShiftInPlace() to compute the shifted spatial velocity in-place
modifying the original object.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pydrake.multibody.math.SpatialVelocity_[float].translational">
<code class="descname">translational</code><span class="sig-paren">(</span><em>self: pydrake.multibody.math.SpatialVelocity_[float]</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray[numpy.float64[3, 1]]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[float].translational" title="Permalink to this definition">¶</a></dt>
<dd><p>Const access to the translational component of this spatial vector.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="pydrake.multibody.math.SpatialVelocity_[float].Zero">
<em class="property">static </em><code class="descname">Zero</code><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; pydrake.multibody.math.SpatialVelocity_[float]<a class="headerlink" href="#pydrake.multibody.math.SpatialVelocity_[float].Zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Factory to create a <em>zero</em> SpatialVector, i.e. rotational and
translational components are both zero.</p>
</dd></dl>

</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="pydrake.multibody.meshcat.html" class="btn btn-neutral float-right" title="pydrake.multibody.meshcat" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="pydrake.multibody.inverse_kinematics.html" class="btn btn-neutral float-left" title="pydrake.multibody.inverse_kinematics" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>